[
  {
    "Lab scenario": "SQL injection vulnerability in WHERE clause allowing retrieval of hidden data",
  "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. When the user selects a category, the application carries out a SQL query like the following:\nSELECT * FROM products WHERE category = 'Gifts' AND released = 1\nTo solve the lab, perform a SQL injection attack that causes the application to display one or more unreleased products.",
  "Vulnerability name": "SQL injection",
  "Lab Level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create products table with released flag\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT, released INTEGER)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Teddy Bear', 'Gifts', 1)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Secret Item', 'Gifts', 0)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Tech Gadget', 'Electronics', 1)\");\n});\n\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>Product Search</h1>\n    <form method=\"GET\" action=\"/products\">\n      <label for=\"category\">Category:</label>\n      <input type=\"text\" id=\"category\" name=\"category\" value=\"Gifts\">\n      <button type=\"submit\">Show Products</button>\n    </form>\n  `);\n});\n\n// Vulnerable product route\napp.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM products WHERE category = '${category}' AND released = 1`;\n\n  console.log(\"Executing query:\", query);\n  \n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error fetching products\");\n    } else {\n      res.send(`\n        <h2>Products in ${category}</h2>\n        <ul>\n          ${rows.map(p => `<li>${p.name}</li>`).join('')}\n        </ul>\n      `);\n    }\n  });\n});\n\n// Start server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection in login form allowing authentication bypass",
  "Lab Description": "This lab contains a SQL injection vulnerability in the login functionality. The application constructs a SQL query using unsanitized user inputs, allowing attackers to bypass authentication.\nTo solve the lab, exploit the SQL injection vulnerability to log in as the administrator without a valid password.",
  "Vulnerability name": "SQL injection",
  "Lab Level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample user data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user', 'user123')\");\n});\n\n// Serve the login form\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>Login</h1>\n    <form method=\"POST\" action=\"/login\">\n      <label for=\"username\">Username:</label>\n      <input type=\"text\" id=\"username\" name=\"username\"><br><br>\n      <label for=\"password\">Password:</label>\n      <input type=\"password\" id=\"password\" name=\"password\"><br><br>\n      <button type=\"submit\">Login</button>\n    </form>\n  `);\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable query: directly using user inputs without sanitization\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!`);\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running at http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection attack, querying the database type and version on Oracle",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. You can use a UNION attack to retrieve the results from an injected query.\nTo solve the lab, display the database version string.",
    "Vulnerability name": "SQL injection",
    "Lab Level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT, released INTEGER)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Teddy Bear', 'Gifts', 1)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Unreleased Puzzle', 'Gifts', 0)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Smartphone', 'Electronics', 1)\");\n});\n\napp.get('/', (req, res) => {\n  res.send(`\n    <form method=\"GET\" action=\"/products\">\n      <label for=\"category\">Category:</label>\n      <input type=\"text\" id=\"category\" name=\"category\">\n      <button type=\"submit\">Search</button>\n    </form>\n  `);\n});\n\n// Vulnerable route\napp.get('/products', (req, res) => {\n  const category = req.query.category; // Directly using user input without sanitization // vulnerability is here \n  const query = `SELECT * FROM products WHERE category = '${category}' AND released = 1`;\n\n  console.log(\"Executing query:\", query);\n  \n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else {\n      res.send(`\n        <h2>Products</h2>\n        <ul>\n          ${rows.map(row => `<li>${row.name}</li>`).join('')}\n        </ul>\n      `);\n    }\n  });\n});\n\n// Simulate database information retrieval for UNION-based injection\napp.get('/database-info', (req, res) => {\n  // Static response to simulate UNION attack\n  const simulatedResponse = [\n    { version: 'SQLite 3.32.3' },\n    { version: 'Oracle 19c' }\n  ];\n  res.json(simulatedResponse);\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection attack, querying the database type and version on MySQL and Microsoft",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. You can use a UNION attack to retrieve the results from an injected query.\nTo solve the lab, display the database version string.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route with instructions\napp.get('/', (req, res) => {\n  res.send(\n    <h1>SQL Injection Lab</h1>\n    <p>This lab demonstrates an SQL Injection vulnerability in the product category filter.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Try SQL Injection by modifying the 'category' parameter in the URL.</li>\n      <li>Example: <code>?category=Gifts' UNION SELECT 'MySQL 8.0.28', 'MySQL' -- </code></li>\n      <li>Example: <code>?category=Gifts' UNION SELECT 'Microsoft SQL Server 2019', 'SQL Server' -- </code></li>\n      <li><a href=\"/database-info\">Simulated Database Info</a></li>\n    </ul>\n  );\n});\n\n// Vulnerable route for products\napp.get('/products', (req, res) => {\n  const category = req.query.category || ''; // Safeguard against null category\n  const query = SELECT * FROM products WHERE category = '${category}'; // Vulnerable query\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    // Simulate UNION query output\n    res.send(\n      <h2>Products</h2>\n      <ul>\n        <li>MySQL 8.0.28</li>\n        <li>Microsoft SQL Server 2019</li>\n      </ul>\n    );\n  } else {\n    // Normal query execution\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred during query execution.\");\n      } else {\n        res.send(\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => <li>${row.name}</li>).join('')}\n          </ul>\n        );\n      }\n    });\n  }\n});\n\n// Simulated database info for UNION-based injection\napp.get('/database-info', (req, res) => {\n  // Static response to mimic UNION injection output for database versions\n  const simulatedResponse = [\n    { version: 'MySQL 8.0.28', db: 'MySQL' },\n    { version: 'Microsoft SQL Server 2019', db: 'SQL Server' }\n  ];\n  res.json(simulatedResponse);\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});",
    "lab level": "Easy"
  },
  {
    "Lab scenario": "SQL injection attack, listing the database contents on non-Oracle databases",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response so you can use a UNION attack to retrieve data from other tables.\nThe application has a login function, and the database contains a table that holds usernames and passwords. You need to determine the name of this table and the columns it contains, then retrieve the contents of the table to obtain the username and password of all users.\nTo solve the lab, log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database (simulating a non-Oracle database)\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'user123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'user456')\");\n\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route with instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab</h1>\n    <p>This lab demonstrates an SQL Injection vulnerability allowing database schema enumeration and data extraction.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Try SQL Injection by modifying the 'category' parameter in the URL.</li>\n      <li>Example: <code>?category=Gifts' UNION SELECT name, sql FROM sqlite_master -- </code></li>\n      <li>Example: <code>?category=Gifts' UNION SELECT username, password FROM users -- </code></li>\n    </ul>\n  `);\n});\n\n// Vulnerable route for products\napp.get('/products', (req, res) => {\n  const category = req.query.category || ''; // Safeguard against null category\n  const query = `SELECT * FROM products WHERE category = '${category}'`; // Vulnerable query\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    // Simulate UNION query output\n    if (category.includes(\"sqlite_master\")) {\n      res.send(`\n        <h2>Database Schema</h2>\n        <ul>\n          <li>users: id, username, password</li>\n          <li>products: id, name, category</li>\n        </ul>\n      `);\n    } else if (category.includes(\"users\")) {\n      res.send(`\n        <h2>User Credentials</h2>\n        <ul>\n          <li>administrator: admin123</li>\n          <li>user1: user123</li>\n          <li>user2: user456</li>\n        </ul>\n      `);\n    } else {\n      res.send(\"Invalid UNION query.\");\n    }\n  } else {\n    // Normal query execution\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred during query execution.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable query: directly using user inputs without sanitization\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!`);\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
    "lab level": "Intermediate"
  },
  {
    "Lab scenario": "SQL injection attack, listing the database contents on Oracle",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response so you can use a UNION attack to retrieve data from other tables.\nThe application has a login function, and the database contains a table that holds usernames and passwords. You need to determine the name of this table and the columns it contains, then retrieve the contents of the table to obtain the username and password of all users.\nTo solve the lab, log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "src code":"const express = require('express');\nconst sqlite3 = require('sqlite3').verbose(); // Simulating Oracle-like database\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create tables and populate them with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'user123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'user456')\");\n\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route for instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Oracle</h1>\n    <p>This lab demonstrates SQL Injection vulnerability allowing enumeration and extraction of database contents.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Inject queries to enumerate database schema and retrieve user credentials.</li>\n    </ul>\n  `);\n});\n\n// Vulnerable products route\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT * FROM products WHERE category = '${category}'`;\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    if (category.includes(\"sqlite_master\")) {\n      res.send(`\n        <h2>Database Schema</h2>\n        <ul>\n          <li>users: id, username, password</li>\n          <li>products: id, name, category</li>\n        </ul>\n      `);\n    } else if (category.includes(\"users\")) {\n      res.send(`\n        <h2>User Credentials</h2>\n        <ul>\n          <li>administrator: admin123</li>\n          <li>user1: user123</li>\n          <li>user2: user456</li>\n        </ul>\n      `);\n    } else {\n      res.send(\"Invalid UNION query.\");\n    }\n  } else {\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!`);\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
    "lab level": "Intermediate"
  },
  {
    "Lab scenario": "SQL injection UNION attack, determining the number of columns returned by the query",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables. The first step of such an attack is to determine the number of columns that are being returned by the query. You will then use this technique in subsequent labs to construct the full attack.\nTo solve the lab, determine the number of columns returned by the query by performing a SQL injection UNION attack that returns an additional row containing null values.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route for instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Determine Columns</h1>\n    <p>This lab demonstrates SQL Injection vulnerability for determining the number of columns.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Inject queries to determine the number of columns returned.</li>\n    </ul>\n  `);\n});\n\n// Vulnerable route for products\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT * FROM products WHERE category = '${category}'`;\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    res.send(`\n      <h2>Column Count</h2>\n      <p>The query returns 2 columns: id, name.</p>\n    `);\n  } else {\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
    "lab level": "Beginner"
  },
  {
    "Lab scenario": "SQL injection UNION attack, finding a column containing text",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables. To construct such an attack, you first need to determine the number of columns returned by the query. You can do this using a technique you learned in a previous lab. The next step is to identify a column that is compatible with string data.\nThe lab will provide a random value that you need to make appear within the query results. To solve the lab, perform a SQL injection UNION attack that returns an additional row containing the value provided. This technique helps you determine which columns are compatible with string data.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route for instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Find Text-Compatible Column</h1>\n    <p>This lab demonstrates SQL Injection vulnerability to identify string-compatible columns using UNION attacks.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Try SQL Injection by modifying the 'category' parameter in the URL.</li>\n      <li>Example: <code>?category=Gifts' UNION SELECT NULL, 'test' -- </code></li>\n    </ul>\n  `);\n});\n\n// Vulnerable products route\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT * FROM products WHERE category = '${category}'`; // Vulnerable query\n  console.log(\"Executing query:\", query);\n\n  // Handle UNION injection detection\n  if (category.includes(\"UNION\")) {\n    const testValue = \"test_string\"; // Simulated test value to inject\n    if (category.includes(\"NULL, 'test_string'\")) {\n      res.send(`\n        <h2>Column Compatibility</h2>\n        <p>The second column ('name') is compatible with string data.</p>\n      `);\n    } else {\n      res.send(`\n        <h2>Invalid Injection</h2>\n        <p>Ensure your UNION attack is formatted correctly.</p>\n      `);\n    }\n  } else {\n    // Normal query execution\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
    "lab level": "Beginner"
  },
  {
    "Lab scenario": "SQL injection UNION attack, retrieving data from other tables",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables. To construct such an attack, you need to combine some of the techniques you learned in previous labs.\nThe database contains a different table called users, with columns called username and password.\nTo solve the lab, perform a SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "Lab Level":"Hard",
     "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create tables and populate them with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product A', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product B', 'Electronics')\");\n});\n\n// Root route with instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Retrieving Data from Other Tables</h1>\n    <p>This lab demonstrates an SQL Injection vulnerability that allows attackers to retrieve data from other tables.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Try SQL Injection by modifying the 'category' parameter in the URL.</li>\n      <li>Example: <code>?category=Gifts' UNION SELECT username, password FROM users -- </code></li>\n    </ul>\n  `);\n});\n\n// Vulnerable products route\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT name, category FROM products WHERE category = '${category}'`; // Vulnerable query\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    if (category.includes(\"users\")) {\n      res.send(`\n        <h2>User Credentials</h2>\n        <ul>\n          <li>administrator: admin123</li>\n          <li>user1: password1</li>\n          <li>user2: password2</li>\n        </ul>\n      `);\n    } else {\n      res.send(\"Invalid UNION query.\");\n    }\n  } else {\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable query: directly using user inputs without sanitization\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!\");\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection UNION attack, retrieving multiple values in a single column",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response so you can use a UNION attack to retrieve data from other tables.\nThe database contains a different table called users, with columns called username and password.\nTo solve the lab, perform a SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user.",
    "Vulnerability name": "SQL injection"
  },
  {
"Lab scenario": "Blind SQL injection with conditional responses",
  "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and no error messages are displayed. But the application includes a Welcome back message in the page if the query returns any rows.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
  "Vulnerability name": "SQL injection",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n\n  const query = `SELECT CASE WHEN EXISTS (SELECT 1 FROM users WHERE username='administrator' AND password LIKE '${trackingId}%') THEN 1 ELSE 0 END AS result`;\n  console.log(\"Executing query:\", query);\n\n  db.get(query, [], (err, row) => {\n    if (err) {\n      console.error(\"SQL Error:\", err.message);\n      return res.status(500).send(\"Internal Server Error\");\n    }\n    \n    if (row && row.result === 1) {\n      res.send('<h1>Welcome back!</h1>');\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
  "lab level": "Intermediate"
  },
  {
    "Lab scenario": "Blind SQL injection with conditional errors",
    "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows. If the SQL query causes an error, then the application returns a custom error message.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)');\n  db.run('INSERT INTO users (username, password) VALUES (\"administrator\", \"admin123\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user1\", \"password1\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user2\", \"password2\")');\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n\n  // Vulnerable SQL query using the cookie value\n  const query = `SELECT CASE WHEN EXISTS (SELECT 1 FROM users WHERE username='administrator' AND password LIKE '${trackingId}%') THEN 1 ELSE 0 END AS result`;\n  console.log('Executing query:', query);\n\n  db.get(query, [], (err, row) => {\n    if (err) {\n      console.error('SQL Error:', err.message);\n      return res.status(500).send('Internal Server Error');\n    }\n    \n    if (row && row.result === 1) {\n      res.send('<h1>Welcome back!</h1>');\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
    "lab level": "Intermediate"
  },
  {
    "Lab scenario": "Visible error-based SQL injection",
    "Lab Description": "This lab contains a SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie. The results of the SQL query are not returned.\nThe database contains a different table called users, with columns called username and password. To solve the lab, find a way to leak the password for the administrator user, then log in to their account.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)');\n  db.run('INSERT INTO users (username, password) VALUES (\"administrator\", \"admin123\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user1\", \"password1\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user2\", \"password2\")');\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n  \n  // Vulnerable SQL query using the cookie value\n  const query = `SELECT * FROM users WHERE username='administrator' AND password LIKE '${trackingId}%'`;\n  console.log('Executing query:', query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(err.message); // Visible SQL error\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
  "lab level": "Intermediate"
  },
  {
    "Lab scenario": "Blind SQL injection with time delays",
    "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information.\nTo solve the lab, exploit the SQL injection vulnerability to cause a 10 second delay.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n});\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n  const query = `SELECT CASE WHEN (1=1) THEN randomblob(1000000000) ELSE NULL END FROM users WHERE username='administrator' AND password LIKE '${trackingId}%'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Internal Server Error\");\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
     "lab level": "Intermediate"
  },
  {
    "Lab scenario": "Blind SQL injection with time delays and information retrieval",
    "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n  const query = `SELECT CASE WHEN (1=1) THEN randomblob(100000000) ELSE NULL END FROM users WHERE username='administrator' AND password LIKE '${trackingId}%'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Internal Server Error\");\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
    "lab level": "Intermediate"
  },
  {
    "Lab scenario": "Blind SQL injection with out-of-band interaction",
  "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe SQL query is executed asynchronously and has no effect on the application's response. However, you can trigger out-of-band interactions with an external domain.\nTo solve the lab, exploit the SQL injection vulnerability to cause a DNS lookup to Burp Collaborator.",
  "Vulnerability name": "SQL injection",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\nconst dns = require('dns');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const query = `SELECT username FROM users WHERE id = ${trackingId}`;\n  db.get(query, (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (row) {\n      res.send(`Welcome, ${row.username}!`);\n    } else {\n      res.send(\"User not found.\");\n    }\n  });\n});\n\napp.get('/dns', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const domain = 'example.com'; // Replace with Burp Collaborator domain\n  dns.lookup(trackingId + '.' + domain, (err, address, family) => {\n    if (err) {\n      res.status(500).send(\"DNS lookup failed.\");\n    } else {\n      res.send(`DNS lookup successful: ${address}`);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
  "lab level": "Advanced"
  },
  {
    "Lab scenario": "Blind SQL injection with out-of-band data exfiltration",
    "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe SQL query is executed asynchronously and has no effect on the application's response. However, you can trigger out-of-band interactions with an external domain.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\nconst dns = require('dns');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const query = `SELECT username FROM users WHERE id = ${trackingId}`;\n  db.get(query, (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (row) {\n      res.send(`Welcome, ${row.username}!`);\n    } else {\n      res.send(\"User not found.\");\n    }\n  });\n});\n\napp.get('/dns', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const domain = 'example.com'; // Replace with Burp Collaborator domain\n  dns.lookup(trackingId + '.' + domain, (err, address, family) => {\n    if (err) {\n      res.status(500).send(\"DNS lookup failed.\");\n    } else {\n      res.send(`DNS lookup successful: ${address}`);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
    "lab level": "Advanced"
  },
  {
    "Lab scenario": "SQL injection with filter bypass via XML encoding",
    "Lab Description": "This lab contains a SQL injection vulnerability in its stock check feature. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables.\nThe database contains a users table, which contains the usernames and passwords of registered users. To solve the lab, perform a SQL injection attack to retrieve the admin user's credentials, then log in to their account.",
    "Vulnerability name": "SQL injection",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n\n  db.run(\"CREATE TABLE stock (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Laptop', 10)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Phone', 20)\");\n});\n\napp.post('/stock', (req, res) => {\n  xml2js.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send(\"Invalid XML\");\n      return;\n    }\n    const product = result.stock.product[0];\n    const query = `SELECT product, quantity FROM stock WHERE product = '${product}'`;\n    console.log(\"Executing query:\", query);\n\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.json(rows);\n      }\n    });\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});",
    "lab level": "Intermediate"
  }
]