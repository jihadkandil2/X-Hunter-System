[
    {
        "Lab scenario": "JWT authentication bypass via unverified signature",
        "Lab Description": "This lab uses a JWT-based mechanism for handling sessions. Due to implementation flaws, the server doesn't verify the signature of any JWTs that it receives.\nTo solve the lab, modify your session token to gain access to the admin panel at /admin, then delete the user carlos.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "JWT"
      },
      {
        "Lab scenario": "JWT authentication bypass via flawed signature verification",
        "Lab Description": "This lab uses a JWT-based mechanism for handling sessions. The server is insecurely configured to accept unsigned JWTs.\nTo solve the lab, modify your session token to gain access to the admin panel at /admin, then delete the user carlos.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "JWT"
      },
      {
        "Lab scenario": "JWT authentication bypass via weak signing key",
        "Lab Description": "This lab uses a JWT-based mechanism for handling sessions. It uses an extremely weak secret key to both sign and verify tokens. This can be easily brute-forced using a wordlist of common secrets.\nTo solve the lab, first brute-force the website's secret key. Once you've obtained this, use it to sign a modified session token that gives you access to the admin panel at /admin, then delete the user carlos.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "JWT"
      },
      {
        "Lab scenario": "JWT authentication bypass via jwk header injection",
        "Lab Description": "This lab uses a JWT-based mechanism for handling sessions. The server supports the jwk parameter in the JWT header. This is sometimes used to embed the correct verification key directly in the token. However, it fails to check whether the provided key came from a trusted source.\nTo solve the lab, modify and sign a JWT that gives you access to the admin panel at /admin, then delete the user carlos.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "JWT"
      },
      {
        "Lab scenario": "JWT authentication bypass via jku header injection",
        "Lab Description": "This lab uses a JWT-based mechanism for handling sessions. The server supports the jku parameter in the JWT header. However, it fails to check whether the provided URL belongs to a trusted domain before fetching the key.\nTo solve the lab, forge a JWT that gives you access to the admin panel at /admin, then delete the user carlos.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "JWT"
      },
      {
        "Lab scenario": "JWT authentication bypass via kid header path traversal",
        "Lab Description": "This lab uses a JWT-based mechanism for handling sessions. In order to verify the signature, the server uses the kid parameter in JWT header to fetch the relevant key from its filesystem.\nTo solve the lab, forge a JWT that gives you access to the admin panel at /admin, then delete the user carlos.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "JWT"
      },
      {
        "Lab scenario": "JWT authentication bypass via algorithm confusion",
        "Lab Description": "This lab uses a JWT-based mechanism for handling sessions. It uses a robust RSA key pair to sign and verify tokens. However, due to implementation flaws, this mechanism is vulnerable to algorithm confusion attacks.\nTo solve the lab, first obtain the server's public key. This is exposed via a standard endpoint. Use this key to sign a modified session token that gives you access to the admin panel at /admin, then delete the user carlos.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "JWT",
         "lab level": "Medium",
           "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\n\nconst app = express();\nconst port = 3000;\n\nconst privateKey = fs.readFileSync('private.key', 'utf8');\nconst publicKey = fs.readFileSync('public.key', 'utf8');\n\napp.use(bodyParser.json());\napp.use(express.static(__dirname));\n\nconst users = {\n  wiener: { password: 'peter', role: 'user' },\n  carlos: { password: 'secret', role: 'admin' }\n};\n\n// Expose public key\napp.get('/publicKey', (req, res) => {\n  res.type('text/plain').send(publicKey);\n});\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>JWT Authentication</h2>\n        <form action='/login' method='POST'>\n          <input type='text' name='username' placeholder='Username' required />\n          <input type='password' name='password' placeholder='Password' required />\n          <button type='submit'>Login</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ username, role: users[username].role }, privateKey, { algorithm: 'RS256' });\n    return res.json({ token });\n  }\n  res.status(401).json({ error: 'Invalid credentials' });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  try {\n    const decoded = jwt.verify(token, publicKey);\n    if (decoded.role === 'admin') return res.json({ message: 'Welcome, admin!' });\n  } catch (err) {\n    return res.status(403).json({ error: 'Invalid token' });\n  }\n  res.status(403).json({ error: 'Access denied' });\n});\n\napp.post('/admin/deleteUser', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  try {\n    const decoded = jwt.verify(token, publicKey);\n    if (decoded.role === 'admin') {\n      const { username } = req.body;\n      if (username && username === 'carlos') {\n        return res.json({ message: `User ${username} deleted` });\n      }\n      return res.status(400).json({ error: 'Invalid username' });\n    }\n    return res.status(403).json({ error: 'Access denied' });\n  } catch(err) {\n    return res.status(403).json({ error: 'Invalid token' });\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Lab running on http://localhost:${port}`);\n});"
      },
      {
        "Lab scenario": "JWT authentication bypass via algorithm confusion with no exposed key",
        "Lab Description": "This lab uses a JWT-based mechanism for handling sessions. It uses a robust RSA key pair to sign and verify tokens. However, due to implementation flaws, this mechanism is vulnerable to algorithm confusion attacks.\nTo solve the lab, first obtain the server's public key. Use this key to sign a modified session token that gives you access to the admin panel at /admin, then delete the user carlos.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "JWT",
         "lab level": "Medium",
         "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\n\nconst app = express();\nconst port = 3000;\n\nconst privateKey = fs.readFileSync('private.key', 'utf8');\nconst publicKey = fs.readFileSync('public.key', 'utf8');\n\napp.use(bodyParser.json());\napp.use(express.static(__dirname));\n\nconst users = {\n  wiener: { password: 'peter', role: 'user' },\n  carlos: { password: 'secret', role: 'admin' }\n};\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>JWT Authentication</h2>\n        <form action='/login' method='POST'>\n          <input type='text' name='username' placeholder='Username' required />\n          <input type='password' name='password' placeholder='Password' required />\n          <button type='submit'>Login</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ username, role: users[username].role }, privateKey, { algorithm: 'RS256' });\n    return res.json({ token });\n  }\n  res.status(401).json({ error: 'Invalid credentials' });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n\n  try {\n    const decoded = jwt.verify(token, publicKey);\n    if (decoded.role === 'admin') return res.json({ message: 'Welcome, admin!' });\n  } catch (err) {\n    return res.status(403).json({ error: 'Invalid token' });\n  }\n  res.status(403).json({ error: 'Access denied' });\n});\n\napp.listen(port, () => {\n  console.log(`Lab running on http://localhost:${port}`);\n});"
      }
]