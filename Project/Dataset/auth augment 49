[
    {
        "Lab scenario": "Banking API JWT signature verification bypass",
        "Lab Description": "The banking API accepts unsigned JWTs when the alg header is set to 'none'. Attackers can modify token claims to escalate privileges.\nTo solve: Forge an administrative JWT by removing the signature and access the /transfers endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite during normal login",
            "2. Decode token in JWT Editor and change alg to 'none'",
            "3. Modify 'role' claim from 'user' to 'admin'",
            "4. Remove signature section (leave trailing dot)",
            "5. Submit tampered token in Authorization header to /api/transfers"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/api/transfers', (req, res) => {\n    const token = req.headers.authorization.split(' ')[1];\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.header.alg === 'none') {\n        const payload = decoded.payload;\n        if (payload.role === 'admin') {\n            return res.send('Admin transfer initiated');\n        }\n    }\n    res.status(403).send('Forbidden');\n});\napp.listen(3000);"
    },
    {
        "Lab scenario": "E-commerce session fixation via login CSRF",
        "Lab Description": "The application accepts pre-defined session IDs during login without regeneration. Attackers can set sessions before authentication occurs.\nTo solve: Fixate a session cookie and capture user credentials via phishing.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Intercept GET /login request and inject Set-Cookie header",
            "2. Generate phishing page with auto-submitting login form",
            "3. Embed fixed session ID in form action URL",
            "4. Trick victim into entering credentials",
            "5. Hijack session using captured session ID"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\napp.post('/login', (req, res) => {\n    if (!req.cookies.sessionid) {\n        res.cookie('sessionid', req.query.sid || Math.random().toString(36));\n    }\n    if (req.body.user === 'admin' && req.body.pass === 'S3cr3t!') {\n        res.send('Logged in');\n    } else {\n        res.send('Login failed');\n    }\n});\napp.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare portal OAuth redirect_parameter injection",
        "Lab Description": "The OAuth implementation fails to validate redirect_uri parameters, allowing attackers to steal authorization codes.\nTo solve: Hijack an OAuth flow to capture a valid code and exchange it for an access token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Identify OAuth authorization endpoint (/oauth/authorize)",
            "2. Append malicious redirect_uri to authorization request",
            "3. Trick user into initiating OAuth flow",
            "4. Intercept authorization code sent to attacker's server",
            "5. Exchange code for token at /oauth/token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\nconst codes = {};\napp.get('/oauth/authorize', (req, res) => {\n    const code = Math.random().toString(36).substring(2);\n    codes[code] = { user: req.query.user_id };\n    res.redirect(`${req.query.redirect_uri}?code=${code}`);\n});\napp.post('/oauth/token', (req, res) => {\n    if (codes[req.body.code]) {\n        res.json({ access_token: 'stolen_token' });\n    } else {\n        res.status(400).send('Invalid code');\n    }\n});\napp.listen(3000);"
    },
    {
        "Lab scenario": "E-commerce OAuth token redirect hijacking",
        "Lab Description": "The checkout flow leaks OAuth tokens via referer header when redirecting to payment processor. Attackers can intercept these tokens to compromise connected social accounts.\nTo solve: Capture OAuth token during checkout flow and use it to authenticate as victim.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Set up malicious server logging referer headers",
            "2. Add crafted product to cart with payment URL pointing to attacker server",
            "3. Initiate checkout and monitor server logs for OAuth token in referer",
            "4. Use Postman to send GET /userinfo with stolen token",
            "5. Change account email using captured access token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => { const token = req.query.access_token; res.redirect(`https://checkout/payment?token=${token}`); });app.get('/payment', (req, res) => { if (!req.query.token) return res.status(400).send('Missing token'); processPayment(req.query.token); });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT dashboard credential stuffing via API rate limit bypass",
        "Lab Description": "The IoT admin portal has weak rate limiting that resets per endpoint. Attackers can distribute credential stuffing attempts across multiple API routes.\nTo solve: Bypass rate limits using 3 parallel attacks on different endpoints with top 100 passwords.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Use OWASP ZAP to identify all authentication-related endpoints (/auth, /login, /api/auth)",
            "2. Configure 3 separate Burp Intruder attacks with same password list",
            "3. Stagger attacks with 10ms delay between requests per endpoint",
            "4. Monitor for 302 redirects indicating successful login",
            "5. Hijack session to dump all connected IoT device credentials"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const rateLimit = require('express-rate-limit');const app = express();const authLimiter = rateLimit({ windowMs: 15*60*1000, max: 100 });app.use('/login', authLimiter);app.post('/login', (req, res) => { if (req.body.user === 'admin' && req.body.pass === 's3cr3t') { res.send('Logged in'); } else { res.status(401).send('Failed'); } });app.post('/api/auth', (req, res) => { if (req.body.username === 'admin' && req.body.password === 's3cr3t') { res.send('OK'); } else { res.status(401).send('Denied'); } });app.listen(3000);"
    },
    {
        "Lab scenario": "Social media JWT kid parameter injection",
        "Lab Description": "The social media platform's JWT validation improperly handles the kid (Key ID) parameter in token headers, allowing attackers to specify arbitrary keys from the filesystem.\nTo solve: Forge an admin JWT by injecting a filesystem path and access restricted user data.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite and decode in JWT Editor",
            "2. Modify kid header parameter to point to /dev/null or known static file",
            "3. Sign new token with empty/known secret using HS256 algorithm",
            "4. Replace Authorization header with forged token in /api/admin/users request",
            "5. Extract sensitive user PII from response"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/verify-token', (req, res) => { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.decode(token, {complete: true}); const key = fs.readFileSync(decoded.header.kid || 'keys/public.pem'); jwt.verify(token, key, {algorithms: ['RS256', 'HS256']}, (err, payload) => { if (err) return res.status(403).send('Invalid token'); res.send(payload); }); });app.listen(3000);"
    },
    {
        "Lab scenario": "Banking portal OAuth implicit flow token leakage",
        "Lab Description": "The banking application's OAuth implementation leaks access tokens in URL fragments during the implicit flow. Attackers can steal tokens via Referer headers or browser history.\nTo solve: Capture victim's OAuth token and use it to initiate unauthorized transfers.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Set up malicious website logging Referer headers",
            "2. Trick victim into clicking crafted link to banking portal",
            "3. Monitor server logs for OAuth token in Referer after redirection",
            "4. Use Postman to configure Authorization: Bearer [token]",
            "5. Submit POST /transfer request moving funds to attacker account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => { const token = req.query.access_token; res.redirect(`/dashboard#token=${token}`); });app.get('/dashboard', (req, res) => { res.send('Loading dashboard...'); });app.post('/transfer', (req, res) => { if (!req.headers.authorization) return res.status(401).send('Missing token'); processTransfer(req.body); });app.listen(3000);"
    },
    {
        "Lab scenario": "CMS session fixation via login CSRF",
        "Lab Description": "The content management system accepts pre-set session IDs during login without regeneration, enabling attackers to fixate sessions via CSRF.\nTo solve: Create malicious page that sets session cookie and forces admin login, then hijack authenticated session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Use OWASP ZAP to record fresh session cookie value",
            "2. Craft HTML form with hidden inputs setting session cookie and credentials",
            "3. Trick admin into visiting attack page while logged out",
            "4. Automatically submit form via JavaScript after cookie set",
            "5. Reuse captured session ID in authenticated requests"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const cookieParser = require('cookie-parser');const app = express();app.use(cookieParser());app.post('/login', (req, res) => { if (!req.cookies.sessionid) res.cookie('sessionid', req.body.sessionid || generateId()); if (checkCredentials(req.body)) { res.send('Logged in'); } else { res.status(401).send('Failed'); } });app.get('/admin', (req, res) => { if (!req.cookies.sessionid) return res.redirect('/login'); res.send('Admin panel'); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare API JWT algorithm confusion attack",
        "Lab Description": "The healthcare portal API uses RS256 signed JWTs but fails to validate the signing algorithm properly. Attackers can forge tokens by switching to HS256 and using the public key as secret.\nTo solve: Extract the public key, forge an admin JWT, and access patient records.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Use Burp Suite to intercept /auth/public-key endpoint response containing RSA public key",
            "2. Convert PEM public key to JWK format using openssl and jwt_tool",
            "3. Craft HS256 token with {role:admin} using public key as secret",
            "4. Replace Authorization header with forged token in /api/patient-records request",
            "5. Verify access to sensitive patient health data (PHI)"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();const publicKey = '-----BEGIN PUBLIC KEY-----\\nMIIBI...\\n-----END PUBLIC KEY-----';app.get('/auth/public-key', (req, res) => { res.send(publicKey); });app.post('/verify-token', (req, res) => { const token = req.body.token; jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }, (err, decoded) => { if (err) return res.status(403).send('Invalid token'); res.send(decoded); }); });app.listen(3000);"
    },
    {
        "Lab scenario": "E-commerce JWT none algorithm bypass",
        "Lab Description": "The online store's JWT implementation accepts tokens with 'none' algorithm, allowing attackers to bypass signature verification. The application fails to validate the algorithm parameter in the JWT header.\nTo solve: Forge an administrative JWT token with algorithm set to 'none' and access order history.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite while browsing the store",
            "2. Decode token in JWT Editor and change algorithm to 'none'",
            "3. Modify payload to include {'role':'admin'} claim",
            "4. Remove signature section from the token (after last dot)",
            "5. Use forged token in Authorization header to access /admin/orders"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/verify', (req, res) => { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, null, {algorithms: ['RS256', 'none']}); res.send(decoded); });app.listen(3000);"
    },
    {
        "Lab scenario": "Banking portal OAuth redirect_uri manipulation",
        "Lab Description": "The online banking OAuth implementation fails to properly validate redirect_uri parameters during authorization code flow. Attackers can steal authorization codes by specifying malicious callback URLs.\nTo solve: Intercept authorization request and modify redirect_uri to attacker-controlled domain to capture victim's authorization code.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Intercept GET /oauth/authorize request using Burp Suite",
            "2. Modify redirect_uri parameter to attacker-controlled domain",
            "3. Trick victim into completing OAuth flow (phishing/social engineering)",
            "4. Capture authorization code at attacker server",
            "5. Exchange code for access token at /oauth/token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri || 'https://bank.com/callback'; const code = generateCode(req.query.client_id); res.redirect(`${redirectUri}?code=${code}`); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare portal session timeout manipulation",
        "Lab Description": "The patient portal maintains active sessions indefinitely by only checking session validity client-side. The server accepts expired session cookies if they aren't explicitly invalidated.\nTo solve: Capture valid session cookie and reuse it after logout to access medical records.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
            "1. Log in and capture session cookie using browser developer tools",
            "2. Log out and observe Set-Cookie header doesn't expire session",
            "3. Manually re-add captured session cookie using EditThisCookie",
            "4. Access /patient/records endpoint with stolen cookie",
            "5. Verify continued access to sensitive health data"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const cookieParser = require('cookie-parser');const app = express();app.use(cookieParser());app.post('/logout', (req, res) => { res.clearCookie('session'); res.send('Logged out'); });app.get('/patient/records', (req, res) => { if (req.cookies.session) return res.send(patientData); res.status(401).send('Unauthorized'); });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT dashboard JWT public key injection",
        "Lab Description": "The IoT management dashboard's JWT verification accepts arbitrary public keys via the jku (JWK Set URL) header parameter. The server doesn't validate the jku domain against an allowlist.\nTo solve: Host malicious JWK Set and forge admin token signed with attacker-controlled key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Set up attacker-controlled server hosting JWK Set with public key",
            "2. Generate RSA key pair and add public key to JWK Set",
            "3. Craft JWT with jku pointing to attacker server and {'role':'admin'}",
            "4. Sign token with private key from generated pair",
            "5. Access /admin/devices endpoint with forged token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.post('/verify', async (req, res) => { const token = req.body.token; const header = jwt.decode(token, {complete: true}).header; const jwks = await axios.get(header.jku); const key = jwks.data.keys.find(k => k.kid === header.kid); jwt.verify(token, key, (err, payload) => { if (err) return res.status(403).send('Invalid'); res.send(payload); }); });app.listen(3000);"
    },
    {
        "Lab scenario": "Social media platform OAuth scope escalation",
        "Lab Description": "The social media API's OAuth implementation fails to properly validate requested scopes against client registration. Attackers can request elevated privileges during authorization.\nTo solve: Modify scope parameter during OAuth flow to gain read/write access to private messages.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Intercept GET /oauth/authorize request using OWASP ZAP",
            "2. Add 'messages_read messages_write' to scope parameter",
            "3. Complete OAuth flow with modified scope",
            "4. Capture access token with elevated privileges",
            "5. Access /api/messages endpoint with powerful token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.get('/oauth/token', (req, res) => { const scope = req.query.scope || 'basic_profile'; const token = generateToken(scope); res.send({access_token: token}); });app.get('/api/messages', (req, res) => { const token = req.headers.authorization.split(' ')[1]; const scope = decodeToken(token).scope; if (scope.includes('messages_read')) return res.send(messages); res.status(403).send('Forbidden'); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare portal JWT signature stripping attack",
        "Lab Description": "The patient portal's JWT validation fails when tokens lack signatures entirely. The system accepts unsigned tokens if the algorithm header is removed.\nTo solve: Remove signature and algorithm header from captured JWT to gain unauthorized access to medical records.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite while authenticated as low-privilege user",
            "2. In JWT Editor, completely remove the signature section (including trailing dot)",
            "3. Delete the 'alg' header parameter from the token",
            "4. Modify 'role' claim to 'admin' in payload",
            "5. Submit modified token in Authorization header to /api/patient/records"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => { const token = req.body.token; try { const decoded = jwt.decode(token, {complete: true}); if (!decoded.header.alg) return res.send(decoded.payload); jwt.verify(token, publicKey, (err, payload) => { if (err) throw err; res.send(payload); }); } catch(e) { res.status(403).send('Invalid token'); } });app.listen(3000);"
    },
    {
        "Lab scenario": "Banking API OAuth token leakage via GraphQL introspection",
        "Lab Description": "The banking GraphQL API exposes active OAuth tokens through introspection queries. The debug endpoint mistakenly includes authentication tokens in introspection responses.\nTo solve: Extract valid OAuth tokens via introspection query and use them to perform unauthorized transactions.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Send introspection query to /graphql endpoint using Postman",
            "2. Analyze response for __schema fields containing token data",
            "3. Craft query to extract activeTokens {accessToken user}",
            "4. Identify admin-level token in response",
            "5. Use stolen token in Authorization header for POST /transfer mutation"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const app = express();app.use('/graphql', graphqlHTTP({ schema: schema, graphiql: true, context: ({req}) => { return { token: req.headers.authorization, tokens: activeTokens } }));app.listen(3000);"
    },
    {
        "Lab scenario": "E-commerce platform session regeneration race condition",
        "Lab Description": "The shopping cart system fails to properly invalidate old sessions during password changes. Attackers can maintain access by rapidly making requests with the old session during the change process.\nTo solve: Maintain active session during victim's password change to preserve account access.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Capture valid session cookie using browser developer tools",
            "2. Start Burp Intruder hammering /account endpoint with old session",
            "3. Simultaneously trigger password change via victim's session",
            "4. Observe some requests still succeed post-password-change",
            "5. Use maintained session to access /account/payment_methods"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const cookieParser = require('cookie-parser');const app = express();app.use(cookieParser());app.post('/change-password', (req, res) => { updatePassword(req.user.id, req.body.newPassword); res.send('Password changed'); });app.get('/account', (req, res) => { if (req.cookies.session) return res.send(accountData); res.status(401).send('Unauthorized'); });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT admin panel JWT key confusion via x5u header",
        "Lab Description": "The IoT management interface supports x5u header in JWTs to specify certificate location but doesn't validate the certificate source. Attackers can specify malicious x5u URLs containing their public key.\nTo solve: Forge admin token by hosting attacker-controlled x509 certificate and signing with corresponding private key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Generate RSA key pair and self-signed x509 certificate",
            "2. Host certificate at attacker-controlled HTTPS endpoint",
            "3. Craft JWT with x5u pointing to malicious certificate",
            "4. Include {'role':'superadmin'} claim signed with private key",
            "5. Access /admin/device_controls with forged token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.post('/verify', async (req, res) => { const token = req.body.token; const header = jwt.decode(token, {complete: true}).header; const cert = await axios.get(header.x5u); jwt.verify(token, cert.data, (err, payload) => { if (err) return res.status(403).send('Invalid'); res.send(payload); }); });app.listen(3000);"
    },
    {
        "Lab scenario": "Social media platform JWT claim injection via nested JSON",
        "Lab Description": "The social media API's JWT parser processes nested JSON claims incorrectly, allowing attackers to inject privileged claims through JSON object nesting. The system only validates top-level claims.\nTo solve: Inject admin privileges by nesting malicious claims within JSON objects in the JWT payload.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite while authenticated as normal user",
            "2. In JWT Editor, add nested object: {'user':{'isAdmin':true}}",
            "3. Maintain original top-level claims to pass validation",
            "4. Observe server processes nested isAdmin claim",
            "5. Access /admin/moderation endpoint with elevated privileges"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => { const token = req.body.token; const payload = jwt.verify(token, secret); if (payload.role === 'admin') return grantAdminAccess(); if (payload.user && payload.user.isAdmin) return grantAdminAccess(); res.send(payload); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare portal OAuth token replay via state parameter",
        "Lab Description": "The patient portal's OAuth implementation fails to validate state parameters after initial authorization, allowing token replay attacks. The system maintains active sessions for reused state values.\nTo solve: Capture valid state parameter during OAuth flow and replay it to gain unauthorized access.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Intercept OAuth flow using OWASP ZAP and capture state parameter",
            "2. Observe state remains valid for 5 minutes post-authentication",
            "3. Construct malicious redirect URI with captured state",
            "4. Trick victim into initiating OAuth flow (phishing)",
            "5. Replay state parameter to hijack authenticated session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();const activeStates = new Set();app.get('/oauth/callback', (req, res) => { if (!activeStates.has(req.query.state)) return res.status(400).send('Invalid state'); activeStates.delete(req.query.state); res.cookie('session', generateSession(req.query.code)); });app.listen(3000);"
    },
    {
        "Lab scenario": "Banking application session token prediction via LCG",
        "Lab Description": "The mobile banking app generates session tokens using a linear congruential generator (LCG) with insufficient entropy. The algorithm parameters can be derived from captured tokens.\nTo solve: Predict next valid session tokens by analyzing token sequence and brute-forcing LCG parameters.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture sequence of 5+ session tokens using MITM proxy",
            "2. Analyze tokens using Python LCG cracker script",
            "3. Derive LCG parameters (modulus, multiplier, increment)",
            "4. Generate next valid tokens using calculated parameters",
            "5. Hijack authenticated sessions with predicted tokens"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();let seed = Date.now();app.post('/login', (req, res) => { seed = (seed * 1664525 + 1013904223) % 4294967296; res.cookie('session', seed.toString(16)); });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT dashboard MFA bypass via status code manipulation",
        "Lab Description": "The IoT admin dashboard's MFA verification only checks HTTP status codes, not actual verification results. Forcing a 200 status code bypasses MFA protection.\nTo solve: Intercept MFA verification request and override response status code to bypass protection.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Authenticate with valid credentials using Burp Suite",
            "2. Intercept POST /mfa-verify request to verification endpoint",
            "3. Using Burp Repeater, modify response to force 200 status code",
            "4. Observe dashboard grants full access without valid MFA code",
            "5. Access all IoT device controls with bypassed MFA"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/mfa-verify', (req, res) => { if (req.body.code === storedCode) { res.status(200).send('Verified'); } else { res.status(403).send('Invalid code'); } });app.get('/admin', (req, res) => { if (req.session.mfaVerified === true || req.session.mfaVerified === '200') { return res.send(adminPanel); } res.status(403).send('MFA required'); });app.listen(3000);"
    },
    {
        "Lab scenario": "E-commerce platform JWT key substitution via x5c header",
        "Lab Description": "The online store's JWT validation improperly trusts x5c certificate chain headers, allowing attackers to substitute their own public key. The system fails to validate the certificate chain properly.\nTo solve: Forge admin token by injecting attacker-controlled x5c certificate header and signing with corresponding private key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Generate RSA key pair and self-signed x509 certificate",
            "2. Craft JWT with x5c header containing attacker certificate",
            "3. Include {'role':'admin'} claim signed with private key",
            "4. Use Burp Suite to replace legitimate token with forged one",
            "5. Access /admin/product_management endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => { const token = req.body.token; const header = jwt.decode(token, {complete: true}).header; const cert = header.x5c[0]; jwt.verify(token, cert, (err, payload) => { if (err) return res.status(403).send('Invalid'); res.send(payload); }); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare API OAuth token leakage via WebSocket",
        "Lab Description": "The patient data API leaks active OAuth tokens through WebSocket connection messages during real-time updates. The tokens are visible in WebSocket handshake responses.\nTo solve: Intercept WebSocket upgrade request and extract active tokens from connection messages to gain unauthorized access.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Use OWASP ZAP to intercept WebSocket upgrade request",
            "2. Monitor WebSocket messages for token leakage",
            "3. Extract valid bearer tokens from message metadata",
            "4. Use Postman to authenticate with stolen token",
            "5. Access /api/patient/records endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ server });wss.on('connection', (ws, req) => { ws.send(JSON.stringify({ token: req.headers.authorization, data: updates })); });app.listen(3000);"
    },
    {
        "Lab scenario": "Banking portal session token reflection via XSS",
        "Lab Description": "The online banking portal reflects session tokens in error messages when invalid characters are submitted. This allows token theft via stored XSS in the transaction notes field.\nTo solve: Inject XSS payload to capture admin session tokens through error message reflection.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Discover XSS vulnerability in transaction notes field",
            "2. Craft payload to extract session token from error messages",
            "3. Submit malicious transaction with XSS payload",
            "4. Wait for admin to view transaction and trigger payload",
            "5. Receive admin session token at attacker server"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/transfer', (req, res) => { if (!validateSession(req.cookies.session)) { return res.status(400).send(`Invalid session: ${req.cookies.session}`); } processTransfer(req.body); });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT admin console MFA bypass via null byte",
        "Lab Description": "The IoT management console's MFA verification is vulnerable to null byte injection in the verification code parameter. Terminating the code with a null byte bypasses verification.\nTo solve: Intercept MFA submission and append null byte to bypass verification while maintaining valid session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Authenticate with valid credentials using Burp Suite",
            "2. Intercept POST /mfa-verify request",
            "3. Append null byte (%00) to verification code parameter",
            "4. Forward modified request to bypass MFA check",
            "5. Access privileged device controls without valid MFA code"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/mfa-verify', (req, res) => { const code = req.body.code.split('\0')[0]; if (code === storedCode) { req.session.mfaVerified = true; res.redirect('/admin'); } else { res.status(403).send('Invalid code'); } });app.listen(3000);"
    },
    {
        "Lab scenario": "Social media platform JWT type confusion attack",
        "Lab Description": "The social media API's JWT parser incorrectly processes token types, accepting access tokens as refresh tokens when the 'typ' header is modified. This allows privilege escalation by converting access tokens into refresh tokens.\nTo solve: Modify JWT 'typ' header to convert access token into refresh token and generate new elevated privileges.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid access token using Burp Suite",
            "2. Change 'typ' header from 'at+jwt' to 'rt+jwt'",
            "3. Submit modified token to /oauth/token endpoint",
            "4. Receive new access token with extended privileges",
            "5. Access restricted API endpoints with elevated token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/token', (req, res) => { const token = req.body.token; const decoded = jwt.decode(token, {complete: true}); if (decoded.header.typ === 'rt+jwt') { return res.send({access_token: generatePrivilegedToken()}); } res.status(400).send('Invalid token type'); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare portal OAuth token recycling via stale nonces",
        "Lab Description": "The patient portal's OAuth implementation fails to properly invalidate used nonces, allowing authorization codes to be reused with the same nonce. The system only checks nonce uniqueness per session.\nTo solve: Capture valid nonce and reuse it with authorization code to generate multiple access tokens.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Intercept OAuth flow using OWASP ZAP",
            "2. Capture valid nonce parameter from authorization request",
            "3. Replay authorization code with same nonce multiple times",
            "4. Generate multiple valid access tokens from single code",
            "5. Use tokens to access protected health records"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();const usedNonces = new Set();app.get('/oauth/callback', (req, res) => { if (usedNonces.has(req.query.nonce)) return res.status(400).send('Nonce reused'); usedNonces.add(req.query.nonce); res.send({access_token: generateToken(req.query.code)}); });app.listen(3000);"
    },
    {
        "Lab scenario": "Banking application session fixation via WebSocket handshake",
        "Lab Description": "The mobile banking app assigns WebSocket session IDs during the handshake phase and maintains them post-authentication. Attackers can pre-set WS session IDs to hijack authenticated sessions.\nTo solve: Fixate WebSocket session ID during handshake and intercept real-time transaction data.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Intercept WebSocket upgrade request using MITM proxy",
            "2. Inject custom Sec-WebSocket-Key header with fixed value",
            "3. Complete authentication while maintaining WS connection",
            "4. Observe real-time transaction data in hijacked session",
            "5. Perform unauthorized transactions via WS channel"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ server });wss.on('connection', (ws, req) => { if (!ws.sessionId) ws.sessionId = req.headers['sec-websocket-key']; authenticatedSessions[ws.sessionId] = ws; });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT admin console MFA bypass via case-sensitive comparison",
        "Lab Description": "The IoT management console's MFA verification performs case-sensitive comparison of verification codes, allowing bypass when mixed-case codes are submitted. The stored code is always uppercase.\nTo solve: Submit lowercase version of valid code to bypass MFA protection.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
            "1. Intercept valid uppercase MFA code using Burp Suite",
            "2. Resubmit code in lowercase letters",
            "3. Observe system accepts mixed-case code",
            "4. Bypass MFA protection with modified case",
            "5. Gain admin access to device controls"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/verify-mfa', (req, res) => { if (req.body.code === storedCode.toUpperCase()) { res.send('Verified'); } else { res.status(403).send('Invalid code'); } });app.listen(3000);"
    },
    {
        "Lab scenario": "E-commerce platform JWT algorithm substitution via cty header",
        "Lab Description": "The online store's JWT processor incorrectly uses the 'cty' (content type) header to determine verification algorithm instead of the 'alg' header. This allows attackers to bypass signature verification by manipulating content type declarations.\nTo solve: Forge admin token by setting 'cty' header to 'JWT' while using 'none' algorithm to bypass signature checks.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite",
            "2. Set 'cty' header to 'JWT' and 'alg' to 'none'",
            "3. Remove signature section entirely",
            "4. Modify payload to include admin privileges",
            "5. Submit forged token to /admin/inventory endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => { const token = req.body.token; const header = jwt.decode(token, {complete: true}).header; const algorithm = header.cty === 'JWT' ? 'none' : header.alg; jwt.verify(token, null, {algorithms: [algorithm]}, (err, payload) => { if (err) return res.status(403).send('Invalid'); res.send(payload); }); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare portal OAuth token leakage via HTTP/2 trailer headers",
        "Lab Description": "The patient data API leaks active OAuth tokens in HTTP/2 trailer headers during large file downloads. The tokens are visible in the trailing headers after the response body.\nTo solve: Initiate large file download and extract valid tokens from trailer headers to gain unauthorized access to medical records.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Use OWASP ZAP to intercept /api/export-medical-records request",
            "2. Observe trailer headers containing Authorization tokens",
            "3. Extract valid bearer tokens from trailer headers",
            "4. Use Postman to authenticate with stolen token",
            "5. Access /api/patient/records endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.get('/export', (req, res) => { res.writeHead(200, {'Trailer': 'Authorization'}); res.write(largeData); res.addTrailers({'Authorization': `Bearer ${req.headers.authorization}`}); res.end(); });app.listen(3000);"
    },
    {
        "Lab scenario": "Banking application session fixation via WebTransport handshake",
        "Lab Description": "The next-gen banking app assigns session identifiers during WebTransport protocol handshake and maintains them post-login. Attackers can pre-set session IDs during the QUIC connection establishment.\nTo solve: Fixate WebTransport session ID during handshake and hijack authenticated banking sessions.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Intercept WebTransport handshake using specialized proxy",
            "2. Inject custom session-id in SETTINGS frame",
            "3. Complete authentication while maintaining connection",
            "4. Observe real-time transaction data in hijacked session",
            "5. Perform unauthorized transfers via hijacked channel"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const webtransport = require('webtransport');const app = express();const wt = new webtransport.WebTransportServer({ port: 443 });wt.on('session', (session) => { if (!session.sessionId) session.sessionId = generateId(); authenticatedSessions[session.sessionId] = session; });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT admin console MFA bypass via whitespace padding",
        "Lab Description": "The IoT management system's MFA verification trims whitespace from submitted codes but not from stored codes. Submitting codes with trailing whitespace bypasses verification when the system performs exact comparisons.\nTo solve: Append whitespace to valid MFA codes to bypass verification while maintaining valid session.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
            "1. Intercept valid MFA code submission using Burp Suite",
            "2. Add trailing whitespace characters to the code",
            "3. Observe system accepts padded code",
            "4. Bypass MFA protection with whitespace manipulation",
            "5. Gain admin access to device controls"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/verify-mfa', (req, res) => { if (req.body.code.trim() === storedCode) { res.send('Verified'); } else { res.status(403).send('Invalid code'); } });app.listen(3000);"
    },
    {
        "Lab scenario": "Social media platform JWT claim smuggling via nested arrays",
        "Lab Description": "The social media API's JWT parser incorrectly processes nested array claims, allowing privilege escalation when array indices are manipulated. The system only validates the first element of role arrays.\nTo solve: Inject admin privileges by nesting role claims in arrays and manipulating indices to bypass validation.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite",
            "2. Modify payload to include nested role arrays: {'roles':['user',['admin']]}",
            "3. Exploit parser behavior that only checks roles[0]",
            "4. Submit modified token to /api/admin/moderation",
            "5. Verify elevated access to moderation tools"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => { const token = req.body.token; const payload = jwt.verify(token, secret); if (payload.roles[0] === 'user') return grantAccess(); res.status(403).send('Forbidden'); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare portal OAuth token leakage via HTTP/3 grease frames",
        "Lab Description": "The patient portal's HTTP/3 implementation leaks OAuth tokens in reserved grease frame types during connection establishment. These frames are visible in QUIC handshake captures.\nTo solve: Capture QUIC handshake using specialized tools and extract tokens from reserved frame types to gain API access.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Use qlog-enabled client to capture QUIC handshake",
            "2. Analyze grease frames for leaked token data",
            "3. Extract valid bearer tokens from reserved frame types",
            "4. Use Postman to authenticate with stolen token",
            "5. Access /api/patient/records endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const http3 = require('http3');const app = express();const server = http3.createServer((req, res) => { res.setHeader('X-Grease', `Bearer ${req.token}`); res.end(patientData); });server.listen(443);"
    },
    {
        "Lab scenario": "Banking application session fixation via WebSocket subprotocol negotiation",
        "Lab Description": "The mobile banking app uses WebSocket subprotocols for session identification but fails to regenerate them post-authentication. Attackers can fixate sessions by specifying custom subprotocols during handshake.\nTo solve: Specify attacker-controlled subprotocol during WebSocket upgrade and hijack authenticated banking sessions.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Intercept WebSocket upgrade request using MITM proxy",
            "2. Inject custom Sec-WebSocket-Protocol header with session ID",
            "3. Complete authentication while maintaining WS connection",
            "4. Observe transaction data in hijacked session",
            "5. Initiate unauthorized transfers via WS channel"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ server });wss.on('connection', (ws, req) => { ws.sessionId = req.headers['sec-websocket-protocol']; authenticatedSessions[ws.sessionId] = ws; });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT admin console MFA bypass via Unicode normalization",
        "Lab Description": "The IoT management system's MFA verification fails to normalize Unicode characters in verification codes. The stored code uses NFC normalization while comparison uses literal matching.\nTo solve: Submit denormalized Unicode variants of valid codes to bypass MFA protection.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Intercept valid MFA code submission using Burp Suite",
            "2. Modify code to use NFD Unicode normalization",
            "3. Submit denormalized code with different byte representation",
            "4. Bypass MFA verification while maintaining valid session",
            "5. Access device management controls"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/verify-mfa', (req, res) => { if (req.body.code === storedCode) { res.send('Verified'); } else { res.status(403).send('Invalid code'); } });app.listen(3000);"
    },
    {
        "Lab scenario": "E-commerce platform OAuth token injection via broken PKCE",
        "Lab Description": "The online store's OAuth implementation fails to properly validate PKCE code verifiers during token exchange. Attackers can inject authorization codes without valid code_challenge.\nTo solve: Bypass PKCE protection by omitting code_verifier parameter during token exchange to obtain valid access tokens.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Intercept authorization code flow using OWASP ZAP",
            "2. Capture valid authorization code",
            "3. Submit code to /oauth/token endpoint without code_verifier",
            "4. Obtain access token despite PKCE requirements",
            "5. Access restricted /admin/inventory API"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/token', (req, res) => { if (!req.body.code_verifier) return res.send({access_token: generateToken(req.body.code)}); if (validatePkce(req.body.code, req.body.code_verifier)) { res.send({access_token: generateToken(req.body.code)}); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare API JWT key confusion via x5t header",
        "Lab Description": "The patient records API incorrectly uses the x5t (thumbprint) header to select verification keys without proper validation. Attackers can specify arbitrary key thumbprints to bypass signature verification.\nTo solve: Forge admin token by injecting malicious x5t header pointing to attacker-controlled key and access sensitive medical data.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite",
            "2. Generate RSA key pair and calculate thumbprint",
            "3. Craft token with x5t header matching generated key",
            "4. Sign with private key and set admin privileges",
            "5. Submit to /api/patient/records endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();const keyStore = {};app.post('/verify', (req, res) => { const token = req.body.token; const header = jwt.decode(token, {complete: true}).header; const key = keyStore[header.x5t]; jwt.verify(token, key, (err, payload) => { if (err) return res.status(403).send('Invalid'); res.send(payload); }); });app.listen(3000);"
    },
    {
        "Lab scenario": "Banking portal OAuth token leakage via HTTP Trailers",
        "Lab Description": "The online banking API leaks active OAuth tokens in HTTP trailer headers during large transfers. The tokens become visible after the response body is complete.\nTo solve: Initiate large transfer and extract valid tokens from trailer headers to perform unauthorized transactions.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Initiate large transfer request using OWASP ZAP",
            "2. Monitor response trailers for Authorization header",
            "3. Extract valid bearer token from trailer",
            "4. Use token in Postman to access /transfers endpoint",
            "5. Submit unauthorized transfer to attacker account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.get('/transfer', (req, res) => { res.writeHead(200, {'Trailer': 'Authorization'}); res.write(transferData); res.addTrailers({'Authorization': `Bearer ${req.token}`}); res.end(); });app.listen(3000);"
    },
    {
        "Lab scenario": "Social media platform session fixation via WebTransport",
        "Lab Description": "The social media app assigns session IDs during WebTransport connection setup and maintains them post-login. Attackers can pre-set session IDs during QUIC handshake.\nTo solve: Fixate WebTransport session ID during connection establishment and hijack authenticated sessions.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Intercept WebTransport handshake using specialized proxy",
            "2. Inject custom session-id in SETTINGS frame",
            "3. Complete authentication while maintaining connection",
            "4. Access private messages in hijacked session",
            "5. Post malicious content as victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const webtransport = require('webtransport');const app = express();const wt = new webtransport.WebTransportServer({ port: 443 });wt.on('session', (session) => { session.sessionId = session.handshakeHeaders['session-id'] || generateId(); authenticatedSessions[session.sessionId] = session; });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT admin console MFA bypass via type juggling",
        "Lab Description": "The IoT management system's MFA verification is vulnerable to PHP-style type juggling. Numeric codes submitted as strings bypass verification due to loose comparison.\nTo solve: Submit valid code as string instead of number to bypass MFA protection.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
            "1. Intercept MFA code submission using Burp Suite",
            "2. Change code from number to string (123456 → \"123456\")",
            "3. Observe system accepts stringified code",
            "4. Bypass MFA verification",
            "5. Access device management controls"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/verify-mfa', (req, res) => { if (req.body.code == storedCode) { res.send('Verified'); } else { res.status(403).send('Invalid code'); } });app.listen(3000);"
    },
    {
        "Lab scenario": "E-commerce platform JWT algorithm substitution via cnf claim",
        "Lab Description": "The online store's JWT processor incorrectly uses the 'cnf' (confirmation) claim to determine verification keys instead of the standard 'alg' header. This allows attackers to specify arbitrary verification keys.\nTo solve: Forge admin token by injecting a malicious 'cnf' claim pointing to an attacker-controlled key and access order management functions.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite",
            "2. Generate RSA key pair and add public key to 'cnf' claim",
            "3. Sign token with private key and set admin privileges",
            "4. Submit forged token to /admin/orders endpoint",
            "5. Verify access to order management functions"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => { const token = req.body.token; const payload = jwt.decode(token, {complete: true}).payload; const key = payload.cnf.jwk; jwt.verify(token, key, (err, payload) => { if (err) return res.status(403).send('Invalid'); res.send(payload); }); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare portal OAuth token leakage via HTTP/2 PRIORITY frames",
        "Lab Description": "The patient records API leaks active OAuth tokens in HTTP/2 PRIORITY frame extensions during stream prioritization. The tokens are visible in PRIORITY frame payloads.\nTo solve: Initiate multiple parallel requests and extract valid tokens from PRIORITY frames to access medical records.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Use specialized HTTP/2 proxy to capture PRIORITY frames",
            "2. Identify frames containing Authorization headers",
            "3. Extract valid bearer tokens from frame payloads",
            "4. Use Postman to authenticate with stolen token",
            "5. Access /api/patient/records endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const http2 = require('http2');const app = express();const server = http2.createServer();server.on('stream', (stream, headers) => { stream.priority({weight: 1, exclusive: true, parent: 0, auth: headers.authorization}); stream.respond(patientData); });server.listen(443);"
    },
    {
        "Lab scenario": "Banking application session fixation via WebSocket compression context takeover",
        "Lab Description": "The mobile banking app maintains WebSocket compression contexts across sessions when the same Sec-WebSocket-Extensions header is used. Attackers can fixate sessions by controlling compression contexts.\nTo solve: Establish WebSocket connection with custom compression header and hijack authenticated sessions sharing the same context.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Intercept WebSocket upgrade request using MITM proxy",
            "2. Inject custom Sec-WebSocket-Extensions header",
            "3. Complete authentication while maintaining compression context",
            "4. Observe transaction data in hijacked session",
            "5. Initiate unauthorized transfers via compressed channel"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ server, perMessageDeflate: true });wss.on('connection', (ws, req) => { ws.sessionId = req.headers['sec-websocket-extensions']; authenticatedSessions[ws.sessionId] = ws; });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT admin console MFA bypass via parameter pollution",
        "Lab Description": "The IoT management system's MFA verification is vulnerable to HTTP parameter pollution. Submitting duplicate code parameters with different values bypasses verification.\nTo solve: Submit both valid and invalid codes simultaneously using parameter pollution to bypass MFA protection.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
            "1. Intercept MFA code submission using Burp Suite",
            "2. Add duplicate code parameter with invalid value",
            "3. Observe system processes first valid code parameter",
            "4. Bypass MFA verification",
            "5. Access device management controls"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/verify-mfa', (req, res) => { const code = Array.isArray(req.body.code) ? req.body.code[0] : req.body.code; if (code === storedCode) { res.send('Verified'); } else { res.status(403).send('Invalid code'); } });app.listen(3000);"
    },
    {
        "Lab scenario": "Social media platform JWT claim smuggling via duplicate headers",
        "Lab Description": "The social media API's JWT parser processes duplicate headers inconsistently, allowing privilege escalation when malicious headers are duplicated. The system only validates the first instance of critical headers.\nTo solve: Inject admin privileges by duplicating headers with conflicting values to bypass validation.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid JWT using Burp Suite",
            "2. Duplicate critical headers with conflicting values",
            "3. Set first 'alg' header to 'none' and second to 'HS256'",
            "4. Include admin claim in payload",
            "5. Submit to /api/admin/moderation endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => { const token = req.body.token; const headers = jwt.decode(token, {complete: true}).header; const alg = Array.isArray(headers.alg) ? headers.alg[0] : headers.alg; jwt.verify(token, null, {algorithms: [alg]}, (err, payload) => { if (err) return res.status(403).send('Invalid'); res.send(payload); }); });app.listen(3000);"
    },
    {
        "Lab scenario": "Healthcare portal OAuth token leakage via HTTP/2 SETTINGS frames",
        "Lab Description": "The patient records API leaks active OAuth tokens in custom HTTP/2 SETTINGS frame parameters during connection tuning. The tokens are visible in SETTINGS frame payloads.\nTo solve: Initiate connection and extract valid tokens from custom SETTINGS parameters to access medical records.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Use specialized HTTP/2 proxy to capture SETTINGS frames",
            "2. Identify custom SETTINGS parameters containing tokens",
            "3. Extract valid bearer tokens from frame payloads",
            "4. Use Postman to authenticate with stolen token",
            "5. Access /api/patient/records endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const http2 = require('http2');const app = express();const server = http2.createServer();server.on('session', (session) => { session.settings({enable_token: currentToken}); });server.on('stream', (stream) => { stream.respond(patientData); });server.listen(443);"
    },
    {
        "Lab scenario": "Banking application session fixation via WebSocket permessage-deflate context",
        "Lab Description": "The mobile banking app reuses WebSocket permessage-deflate compression contexts across sessions when the same compression settings are negotiated. Attackers can fixate sessions by controlling compression contexts.\nTo solve: Establish WebSocket connection with custom compression settings and hijack authenticated sessions sharing the same context.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Intercept WebSocket upgrade request using MITM proxy",
            "2. Negotiate specific deflate settings (windowBits=10, memLevel=4)",
            "3. Complete authentication while maintaining compression context",
            "4. Observe transaction data in hijacked session",
            "5. Initiate unauthorized transfers via compressed channel"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ server, perMessageDeflate: {zlibDeflateOptions: {windowBits: 10, memLevel: 4}} });wss.on('connection', (ws, req) => { ws.sessionId = req.headers['sec-websocket-extensions']; authenticatedSessions[ws.sessionId] = ws; });app.listen(3000);"
    },
    {
        "Lab scenario": "IoT admin console MFA bypass via array parameter processing",
        "Lab Description": "The IoT management system's MFA verification incorrectly processes array parameters, accepting the first valid code when multiple values are submitted. The system fails to validate array length.\nTo solve: Submit both valid and invalid codes as an array to bypass MFA protection.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
            "1. Intercept MFA code submission using Burp Suite",
            "2. Convert code parameter to array with valid code first",
            "3. Observe system processes first valid code",
            "4. Bypass MFA verification",
            "5. Access device management controls"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');const app = express();app.post('/verify-mfa', (req, res) => { const code = Array.isArray(req.body.code) ? req.body.code.find(c => c === storedCode) : req.body.code; if (code) { res.send('Verified'); } else { res.status(403).send('Invalid code'); } });app.listen(3000);"
    }
]
